
_test：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <ImageListInit>:
int normal_shift = 0;
int hover_shift = -30;
int pressed_shift = -50;

void ImageListInit(ImageList *image_list)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
	image_list->head=0;
       3:	8b 45 08             	mov    0x8(%ebp),%eax
       6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	image_list->tail=0;
       c:	8b 45 08             	mov    0x8(%ebp),%eax
       f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
      16:	90                   	nop
      17:	5d                   	pop    %ebp
      18:	c3                   	ret    

00000019 <ImageListAppend>:

void ImageListAppend(char *filename, int size, int filename_len, ImageList *image_list, char* type, int type_len)
{
      19:	55                   	push   %ebp
      1a:	89 e5                	mov    %esp,%ebp
      1c:	83 ec 38             	sub    $0x38,%esp
	Image *append_image=(Image*)malloc(sizeof(Image));
      1f:	83 ec 0c             	sub    $0xc,%esp
      22:	6a 3c                	push   $0x3c
      24:	e8 94 70 00 00       	call   70bd <malloc>
      29:	83 c4 10             	add    $0x10,%esp
      2c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	append_image->image_name=(char*)malloc(sizeof(char)*filename_len);
      2f:	8b 45 10             	mov    0x10(%ebp),%eax
      32:	83 ec 0c             	sub    $0xc,%esp
      35:	50                   	push   %eax
      36:	e8 82 70 00 00       	call   70bd <malloc>
      3b:	83 c4 10             	add    $0x10,%esp
      3e:	89 c2                	mov    %eax,%edx
      40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      43:	89 10                	mov    %edx,(%eax)
    int len=0;
      45:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    for (int i = 0; i < filename_len; i++)
      4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
      53:	eb 2e                	jmp    83 <ImageListAppend+0x6a>
    {
        if(filename[i]!=' ')
      55:	8b 55 f0             	mov    -0x10(%ebp),%edx
      58:	8b 45 08             	mov    0x8(%ebp),%eax
      5b:	01 d0                	add    %edx,%eax
      5d:	0f b6 00             	movzbl (%eax),%eax
      60:	3c 20                	cmp    $0x20,%al
      62:	74 1b                	je     7f <ImageListAppend+0x66>
        {
            append_image->image_name[i]=filename[i];
      64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      67:	8b 10                	mov    (%eax),%edx
      69:	8b 45 f0             	mov    -0x10(%ebp),%eax
      6c:	01 c2                	add    %eax,%edx
      6e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
      71:	8b 45 08             	mov    0x8(%ebp),%eax
      74:	01 c8                	add    %ecx,%eax
      76:	0f b6 00             	movzbl (%eax),%eax
      79:	88 02                	mov    %al,(%edx)
            len++;
      7b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
void ImageListAppend(char *filename, int size, int filename_len, ImageList *image_list, char* type, int type_len)
{
	Image *append_image=(Image*)malloc(sizeof(Image));
	append_image->image_name=(char*)malloc(sizeof(char)*filename_len);
    int len=0;
    for (int i = 0; i < filename_len; i++)
      7f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
      83:	8b 45 f0             	mov    -0x10(%ebp),%eax
      86:	3b 45 10             	cmp    0x10(%ebp),%eax
      89:	7c ca                	jl     55 <ImageListAppend+0x3c>
        {
            append_image->image_name[i]=filename[i];
            len++;
        }
    }
    append_image->image_name[len]='\0';
      8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      8e:	8b 10                	mov    (%eax),%edx
      90:	8b 45 f4             	mov    -0xc(%ebp),%eax
      93:	01 d0                	add    %edx,%eax
      95:	c6 00 00             	movb   $0x0,(%eax)
    append_image->image_size=size;
      98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      9b:	8b 55 0c             	mov    0xc(%ebp),%edx
      9e:	89 50 08             	mov    %edx,0x8(%eax)
    append_image->data=(RGB*)malloc(sizeof(RGB)*append_image->image_size);
      a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      a4:	8b 40 08             	mov    0x8(%eax),%eax
      a7:	89 c2                	mov    %eax,%edx
      a9:	89 d0                	mov    %edx,%eax
      ab:	01 c0                	add    %eax,%eax
      ad:	01 d0                	add    %edx,%eax
      af:	83 ec 0c             	sub    $0xc,%esp
      b2:	50                   	push   %eax
      b3:	e8 05 70 00 00       	call   70bd <malloc>
      b8:	83 c4 10             	add    $0x10,%esp
      bb:	89 c2                	mov    %eax,%edx
      bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      c0:	89 50 14             	mov    %edx,0x14(%eax)
    int h,w;
    read24BitmapFile(append_image->image_name, append_image->data, &h, &w);
      c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      c6:	8b 50 14             	mov    0x14(%eax),%edx
      c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      cc:	8b 00                	mov    (%eax),%eax
      ce:	8d 4d d8             	lea    -0x28(%ebp),%ecx
      d1:	51                   	push   %ecx
      d2:	8d 4d dc             	lea    -0x24(%ebp),%ecx
      d5:	51                   	push   %ecx
      d6:	52                   	push   %edx
      d7:	50                   	push   %eax
      d8:	e8 ef 76 00 00       	call   77cc <read24BitmapFile>
      dd:	83 c4 10             	add    $0x10,%esp
    append_image->h=h;
      e0:	8b 55 dc             	mov    -0x24(%ebp),%edx
      e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      e6:	89 50 20             	mov    %edx,0x20(%eax)
    append_image->w=w;
      e9:	8b 55 d8             	mov    -0x28(%ebp),%edx
      ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      ef:	89 50 28             	mov    %edx,0x28(%eax)
    if(strcmp(append_image->image_name, "enemy_big.bmp")==0 || strcmp(append_image->image_name, "enemy_middle.bmp")==0 || strcmp(append_image->image_name, "enemy_small.bmp")==0)
      f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      f5:	8b 00                	mov    (%eax),%eax
      f7:	83 ec 08             	sub    $0x8,%esp
      fa:	68 5c c7 01 00       	push   $0x1c75c
      ff:	50                   	push   %eax
     100:	e8 3d 69 00 00       	call   6a42 <strcmp>
     105:	83 c4 10             	add    $0x10,%esp
     108:	85 c0                	test   %eax,%eax
     10a:	74 34                	je     140 <ImageListAppend+0x127>
     10c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     10f:	8b 00                	mov    (%eax),%eax
     111:	83 ec 08             	sub    $0x8,%esp
     114:	68 6a c7 01 00       	push   $0x1c76a
     119:	50                   	push   %eax
     11a:	e8 23 69 00 00       	call   6a42 <strcmp>
     11f:	83 c4 10             	add    $0x10,%esp
     122:	85 c0                	test   %eax,%eax
     124:	74 1a                	je     140 <ImageListAppend+0x127>
     126:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     129:	8b 00                	mov    (%eax),%eax
     12b:	83 ec 08             	sub    $0x8,%esp
     12e:	68 7b c7 01 00       	push   $0x1c77b
     133:	50                   	push   %eax
     134:	e8 09 69 00 00       	call   6a42 <strcmp>
     139:	83 c4 10             	add    $0x10,%esp
     13c:	85 c0                	test   %eax,%eax
     13e:	75 0c                	jne    14c <ImageListAppend+0x133>
    {
        append_image->gif_img_num = 6;
     140:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     143:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
     14a:	eb 30                	jmp    17c <ImageListAppend+0x163>
    }
    else if(strcmp("giphy_small.bmp", append_image->image_name)==0)
     14c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     14f:	8b 00                	mov    (%eax),%eax
     151:	83 ec 08             	sub    $0x8,%esp
     154:	50                   	push   %eax
     155:	68 8b c7 01 00       	push   $0x1c78b
     15a:	e8 e3 68 00 00       	call   6a42 <strcmp>
     15f:	83 c4 10             	add    $0x10,%esp
     162:	85 c0                	test   %eax,%eax
     164:	75 0c                	jne    172 <ImageListAppend+0x159>
    {
        append_image->gif_img_num = 27;
     166:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     169:	c7 40 0c 1b 00 00 00 	movl   $0x1b,0xc(%eax)
     170:	eb 0a                	jmp    17c <ImageListAppend+0x163>
    }
    else
    {
        append_image->gif_img_num = 1;
     172:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     175:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    }
    append_image->is_onshow = 0;
     17c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     17f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    len=0;
     186:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    append_image->image_type=(char*)malloc(sizeof(char)*(type_len+1));
     18d:	8b 45 1c             	mov    0x1c(%ebp),%eax
     190:	83 c0 01             	add    $0x1,%eax
     193:	83 ec 0c             	sub    $0xc,%esp
     196:	50                   	push   %eax
     197:	e8 21 6f 00 00       	call   70bd <malloc>
     19c:	83 c4 10             	add    $0x10,%esp
     19f:	89 c2                	mov    %eax,%edx
     1a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     1a4:	89 50 04             	mov    %edx,0x4(%eax)
    for (int i = 0; i < type_len; i++)
     1a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
     1ae:	eb 2f                	jmp    1df <ImageListAppend+0x1c6>
    {
        if(type[i]!=' ')
     1b0:	8b 55 ec             	mov    -0x14(%ebp),%edx
     1b3:	8b 45 18             	mov    0x18(%ebp),%eax
     1b6:	01 d0                	add    %edx,%eax
     1b8:	0f b6 00             	movzbl (%eax),%eax
     1bb:	3c 20                	cmp    $0x20,%al
     1bd:	74 1c                	je     1db <ImageListAppend+0x1c2>
        {
            append_image->image_type[i]=type[i];
     1bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     1c2:	8b 50 04             	mov    0x4(%eax),%edx
     1c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
     1c8:	01 c2                	add    %eax,%edx
     1ca:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     1cd:	8b 45 18             	mov    0x18(%ebp),%eax
     1d0:	01 c8                	add    %ecx,%eax
     1d2:	0f b6 00             	movzbl (%eax),%eax
     1d5:	88 02                	mov    %al,(%edx)
            len++;
     1d7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
        append_image->gif_img_num = 1;
    }
    append_image->is_onshow = 0;
    len=0;
    append_image->image_type=(char*)malloc(sizeof(char)*(type_len+1));
    for (int i = 0; i < type_len; i++)
     1db:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
     1df:	8b 45 ec             	mov    -0x14(%ebp),%eax
     1e2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
     1e5:	7c c9                	jl     1b0 <ImageListAppend+0x197>
        {
            append_image->image_type[i]=type[i];
            len++;
        }
    }
    append_image->image_type[len]='\0';
     1e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     1ea:	8b 50 04             	mov    0x4(%eax),%edx
     1ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1f0:	01 d0                	add    %edx,%eax
     1f2:	c6 00 00             	movb   $0x0,(%eax)
    append_image->scale_needed=0;
     1f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     1f8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
    image_origin_preview->height=h;
     1ff:	a1 88 58 02 00       	mov    0x25888,%eax
     204:	8b 55 dc             	mov    -0x24(%ebp),%edx
     207:	89 50 04             	mov    %edx,0x4(%eax)
    image_origin_preview->width=w;
     20a:	a1 88 58 02 00       	mov    0x25888,%eax
     20f:	8b 55 d8             	mov    -0x28(%ebp),%edx
     212:	89 10                	mov    %edx,(%eax)
    image_origin_preview->data=append_image->data;
     214:	a1 88 58 02 00       	mov    0x25888,%eax
     219:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     21c:	8b 52 14             	mov    0x14(%edx),%edx
     21f:	89 50 08             	mov    %edx,0x8(%eax)
    if(h>80 || w>80)
     222:	8b 45 dc             	mov    -0x24(%ebp),%eax
     225:	83 f8 50             	cmp    $0x50,%eax
     228:	7f 0c                	jg     236 <ImageListAppend+0x21d>
     22a:	8b 45 d8             	mov    -0x28(%ebp),%eax
     22d:	83 f8 50             	cmp    $0x50,%eax
     230:	0f 8e 09 01 00 00    	jle    33f <ImageListAppend+0x326>
    {
        append_image->scale_needed=1;
     236:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     239:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
        float scale_tem=1;
     240:	d9 e8                	fld1   
     242:	d9 5d e8             	fstps  -0x18(%ebp)
        if(h>=w)
     245:	8b 55 dc             	mov    -0x24(%ebp),%edx
     248:	8b 45 d8             	mov    -0x28(%ebp),%eax
     24b:	39 c2                	cmp    %eax,%edx
     24d:	7c 16                	jl     265 <ImageListAppend+0x24c>
        {
            scale_tem=(float)80/h;
     24f:	8b 45 dc             	mov    -0x24(%ebp),%eax
     252:	89 45 cc             	mov    %eax,-0x34(%ebp)
     255:	db 45 cc             	fildl  -0x34(%ebp)
     258:	d9 05 d0 c8 01 00    	flds   0x1c8d0
     25e:	de f1                	fdivp  %st,%st(1)
     260:	d9 5d e8             	fstps  -0x18(%ebp)
     263:	eb 14                	jmp    279 <ImageListAppend+0x260>
        }
        else
        {
            scale_tem=(float)80/w;
     265:	8b 45 d8             	mov    -0x28(%ebp),%eax
     268:	89 45 cc             	mov    %eax,-0x34(%ebp)
     26b:	db 45 cc             	fildl  -0x34(%ebp)
     26e:	d9 05 d0 c8 01 00    	flds   0x1c8d0
     274:	de f1                	fdivp  %st,%st(1)
     276:	d9 5d e8             	fstps  -0x18(%ebp)
        }
        image_scale_preview->height=image_origin_preview->height*scale_tem;
     279:	8b 15 24 58 02 00    	mov    0x25824,%edx
     27f:	a1 88 58 02 00       	mov    0x25888,%eax
     284:	8b 40 04             	mov    0x4(%eax),%eax
     287:	89 45 cc             	mov    %eax,-0x34(%ebp)
     28a:	db 45 cc             	fildl  -0x34(%ebp)
     28d:	d8 4d e8             	fmuls  -0x18(%ebp)
     290:	d9 7d d6             	fnstcw -0x2a(%ebp)
     293:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
     297:	b4 0c                	mov    $0xc,%ah
     299:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
     29d:	d9 6d d4             	fldcw  -0x2c(%ebp)
     2a0:	db 5d d0             	fistpl -0x30(%ebp)
     2a3:	d9 6d d6             	fldcw  -0x2a(%ebp)
     2a6:	8b 45 d0             	mov    -0x30(%ebp),%eax
     2a9:	89 42 04             	mov    %eax,0x4(%edx)
        image_scale_preview->width=image_origin_preview->width*scale_tem;
     2ac:	a1 24 58 02 00       	mov    0x25824,%eax
     2b1:	8b 15 88 58 02 00    	mov    0x25888,%edx
     2b7:	8b 12                	mov    (%edx),%edx
     2b9:	89 55 cc             	mov    %edx,-0x34(%ebp)
     2bc:	db 45 cc             	fildl  -0x34(%ebp)
     2bf:	d8 4d e8             	fmuls  -0x18(%ebp)
     2c2:	d9 6d d4             	fldcw  -0x2c(%ebp)
     2c5:	db 5d d0             	fistpl -0x30(%ebp)
     2c8:	d9 6d d6             	fldcw  -0x2a(%ebp)
     2cb:	8b 55 d0             	mov    -0x30(%ebp),%edx
     2ce:	89 10                	mov    %edx,(%eax)
        append_image->scale_data=(RGB*)malloc(sizeof(RGB)*image_scale_preview->height*image_scale_preview->width);
     2d0:	a1 24 58 02 00       	mov    0x25824,%eax
     2d5:	8b 40 04             	mov    0x4(%eax),%eax
     2d8:	89 c2                	mov    %eax,%edx
     2da:	a1 24 58 02 00       	mov    0x25824,%eax
     2df:	8b 00                	mov    (%eax),%eax
     2e1:	0f af d0             	imul   %eax,%edx
     2e4:	89 d0                	mov    %edx,%eax
     2e6:	01 c0                	add    %eax,%eax
     2e8:	01 d0                	add    %edx,%eax
     2ea:	83 ec 0c             	sub    $0xc,%esp
     2ed:	50                   	push   %eax
     2ee:	e8 ca 6d 00 00       	call   70bd <malloc>
     2f3:	83 c4 10             	add    $0x10,%esp
     2f6:	89 c2                	mov    %eax,%edx
     2f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     2fb:	89 50 1c             	mov    %edx,0x1c(%eax)
        image_scale_preview->data=append_image->scale_data;
     2fe:	a1 24 58 02 00       	mov    0x25824,%eax
     303:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     306:	8b 52 1c             	mov    0x1c(%edx),%edx
     309:	89 50 08             	mov    %edx,0x8(%eax)
        picScale(image_origin_preview, image_scale_preview);
     30c:	8b 15 24 58 02 00    	mov    0x25824,%edx
     312:	a1 88 58 02 00       	mov    0x25888,%eax
     317:	83 ec 08             	sub    $0x8,%esp
     31a:	52                   	push   %edx
     31b:	50                   	push   %eax
     31c:	e8 63 8b 00 00       	call   8e84 <picScale>
     321:	83 c4 10             	add    $0x10,%esp
        append_image->scale_h=image_scale_preview->height;
     324:	a1 24 58 02 00       	mov    0x25824,%eax
     329:	8b 50 04             	mov    0x4(%eax),%edx
     32c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     32f:	89 50 24             	mov    %edx,0x24(%eax)
        append_image->scale_w=image_scale_preview->width;
     332:	a1 24 58 02 00       	mov    0x25824,%eax
     337:	8b 10                	mov    (%eax),%edx
     339:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     33c:	89 50 2c             	mov    %edx,0x2c(%eax)
    }
    append_image->save_time=0;
     33f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     342:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
	if(image_list->tail==0)
     349:	8b 45 14             	mov    0x14(%ebp),%eax
     34c:	8b 40 04             	mov    0x4(%eax),%eax
     34f:	85 c0                	test   %eax,%eax
     351:	75 2b                	jne    37e <ImageListAppend+0x365>
	{
		image_list->head=append_image;
     353:	8b 45 14             	mov    0x14(%ebp),%eax
     356:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     359:	89 10                	mov    %edx,(%eax)
		image_list->tail=append_image;
     35b:	8b 45 14             	mov    0x14(%ebp),%eax
     35e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     361:	89 50 04             	mov    %edx,0x4(%eax)
		image_list->head->next=0;
     364:	8b 45 14             	mov    0x14(%ebp),%eax
     367:	8b 00                	mov    (%eax),%eax
     369:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
		image_list->head->prev=0;
     370:	8b 45 14             	mov    0x14(%ebp),%eax
     373:	8b 00                	mov    (%eax),%eax
     375:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
		image_list->tail->next=append_image;
		image_list->tail=append_image;
		image_list->tail->prev=ptr;
		image_list->tail->next=0;
	}
}
     37c:	eb 37                	jmp    3b5 <ImageListAppend+0x39c>
		image_list->tail=append_image;
		image_list->head->next=0;
		image_list->head->prev=0;
	}
	else{
		Image* ptr=image_list->tail;
     37e:	8b 45 14             	mov    0x14(%ebp),%eax
     381:	8b 40 04             	mov    0x4(%eax),%eax
     384:	89 45 e0             	mov    %eax,-0x20(%ebp)
		image_list->tail->next=append_image;
     387:	8b 45 14             	mov    0x14(%ebp),%eax
     38a:	8b 40 04             	mov    0x4(%eax),%eax
     38d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     390:	89 50 38             	mov    %edx,0x38(%eax)
		image_list->tail=append_image;
     393:	8b 45 14             	mov    0x14(%ebp),%eax
     396:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     399:	89 50 04             	mov    %edx,0x4(%eax)
		image_list->tail->prev=ptr;
     39c:	8b 45 14             	mov    0x14(%ebp),%eax
     39f:	8b 40 04             	mov    0x4(%eax),%eax
     3a2:	8b 55 e0             	mov    -0x20(%ebp),%edx
     3a5:	89 50 34             	mov    %edx,0x34(%eax)
		image_list->tail->next=0;
     3a8:	8b 45 14             	mov    0x14(%ebp),%eax
     3ab:	8b 40 04             	mov    0x4(%eax),%eax
     3ae:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
	}
}
     3b5:	90                   	nop
     3b6:	c9                   	leave  
     3b7:	c3                   	ret    

000003b8 <fmtname>:

char*
fmtname(char *path)
{
     3b8:	55                   	push   %ebp
     3b9:	89 e5                	mov    %esp,%ebp
     3bb:	53                   	push   %ebx
     3bc:	83 ec 14             	sub    $0x14,%esp
  static char buf[DIRSIZ+1];
  char *p;
  
  // Find first character after last slash.
  for(p=path+strlen(path); p >= path && *p != '/'; p--)
     3bf:	83 ec 0c             	sub    $0xc,%esp
     3c2:	ff 75 08             	pushl  0x8(%ebp)
     3c5:	e8 b7 66 00 00       	call   6a81 <strlen>
     3ca:	83 c4 10             	add    $0x10,%esp
     3cd:	89 c2                	mov    %eax,%edx
     3cf:	8b 45 08             	mov    0x8(%ebp),%eax
     3d2:	01 d0                	add    %edx,%eax
     3d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
     3d7:	eb 04                	jmp    3dd <fmtname+0x25>
     3d9:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     3dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3e0:	3b 45 08             	cmp    0x8(%ebp),%eax
     3e3:	72 0a                	jb     3ef <fmtname+0x37>
     3e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3e8:	0f b6 00             	movzbl (%eax),%eax
     3eb:	3c 2f                	cmp    $0x2f,%al
     3ed:	75 ea                	jne    3d9 <fmtname+0x21>
    ;
  p++;
     3ef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  
  // Return blank-padded name.
  if(strlen(p) >= DIRSIZ)
     3f3:	83 ec 0c             	sub    $0xc,%esp
     3f6:	ff 75 f4             	pushl  -0xc(%ebp)
     3f9:	e8 83 66 00 00       	call   6a81 <strlen>
     3fe:	83 c4 10             	add    $0x10,%esp
     401:	83 f8 1d             	cmp    $0x1d,%eax
     404:	76 05                	jbe    40b <fmtname+0x53>
    return p;
     406:	8b 45 f4             	mov    -0xc(%ebp),%eax
     409:	eb 60                	jmp    46b <fmtname+0xb3>
  memmove(buf, p, strlen(p));
     40b:	83 ec 0c             	sub    $0xc,%esp
     40e:	ff 75 f4             	pushl  -0xc(%ebp)
     411:	e8 6b 66 00 00       	call   6a81 <strlen>
     416:	83 c4 10             	add    $0x10,%esp
     419:	83 ec 04             	sub    $0x4,%esp
     41c:	50                   	push   %eax
     41d:	ff 75 f4             	pushl  -0xc(%ebp)
     420:	68 bc 57 02 00       	push   $0x257bc
     425:	e8 d4 67 00 00       	call   6bfe <memmove>
     42a:	83 c4 10             	add    $0x10,%esp
  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
     42d:	83 ec 0c             	sub    $0xc,%esp
     430:	ff 75 f4             	pushl  -0xc(%ebp)
     433:	e8 49 66 00 00       	call   6a81 <strlen>
     438:	83 c4 10             	add    $0x10,%esp
     43b:	ba 1e 00 00 00       	mov    $0x1e,%edx
     440:	89 d3                	mov    %edx,%ebx
     442:	29 c3                	sub    %eax,%ebx
     444:	83 ec 0c             	sub    $0xc,%esp
     447:	ff 75 f4             	pushl  -0xc(%ebp)
     44a:	e8 32 66 00 00       	call   6a81 <strlen>
     44f:	83 c4 10             	add    $0x10,%esp
     452:	05 bc 57 02 00       	add    $0x257bc,%eax
     457:	83 ec 04             	sub    $0x4,%esp
     45a:	53                   	push   %ebx
     45b:	6a 20                	push   $0x20
     45d:	50                   	push   %eax
     45e:	e8 45 66 00 00       	call   6aa8 <memset>
     463:	83 c4 10             	add    $0x10,%esp
  return buf;
     466:	b8 bc 57 02 00       	mov    $0x257bc,%eax
}
     46b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     46e:	c9                   	leave  
     46f:	c3                   	ret    

00000470 <ls>:

void
ls(char *path)
{
     470:	55                   	push   %ebp
     471:	89 e5                	mov    %esp,%ebp
     473:	57                   	push   %edi
     474:	56                   	push   %esi
     475:	53                   	push   %ebx
     476:	81 ec 4c 02 00 00    	sub    $0x24c,%esp
  char buf[512], *p;
  int fd;
  struct dirent de;
  struct stat st;
  
  if((fd = open(path, 0)) < 0){
     47c:	83 ec 08             	sub    $0x8,%esp
     47f:	6a 00                	push   $0x0
     481:	ff 75 08             	pushl  0x8(%ebp)
     484:	e8 fa 67 00 00       	call   6c83 <open>
     489:	83 c4 10             	add    $0x10,%esp
     48c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     48f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
     493:	79 1a                	jns    4af <ls+0x3f>
    printf(2, "ls: cannot open %s\n", path);
     495:	83 ec 04             	sub    $0x4,%esp
     498:	ff 75 08             	pushl  0x8(%ebp)
     49b:	68 9b c7 01 00       	push   $0x1c79b
     4a0:	6a 02                	push   $0x2
     4a2:	e8 43 69 00 00       	call   6dea <printf>
     4a7:	83 c4 10             	add    $0x10,%esp
    return;
     4aa:	e9 e3 01 00 00       	jmp    692 <ls+0x222>
  }
  
  if(fstat(fd, &st) < 0){
     4af:	83 ec 08             	sub    $0x8,%esp
     4b2:	8d 85 ac fd ff ff    	lea    -0x254(%ebp),%eax
     4b8:	50                   	push   %eax
     4b9:	ff 75 e4             	pushl  -0x1c(%ebp)
     4bc:	e8 da 67 00 00       	call   6c9b <fstat>
     4c1:	83 c4 10             	add    $0x10,%esp
     4c4:	85 c0                	test   %eax,%eax
     4c6:	79 28                	jns    4f0 <ls+0x80>
    printf(2, "ls: cannot stat %s\n", path);
     4c8:	83 ec 04             	sub    $0x4,%esp
     4cb:	ff 75 08             	pushl  0x8(%ebp)
     4ce:	68 af c7 01 00       	push   $0x1c7af
     4d3:	6a 02                	push   $0x2
     4d5:	e8 10 69 00 00       	call   6dea <printf>
     4da:	83 c4 10             	add    $0x10,%esp
    close(fd);
     4dd:	83 ec 0c             	sub    $0xc,%esp
     4e0:	ff 75 e4             	pushl  -0x1c(%ebp)
     4e3:	e8 83 67 00 00       	call   6c6b <close>
     4e8:	83 c4 10             	add    $0x10,%esp
    return;
     4eb:	e9 a2 01 00 00       	jmp    692 <ls+0x222>
  }
  
  switch(st.type){
     4f0:	0f b7 85 ac fd ff ff 	movzwl -0x254(%ebp),%eax
     4f7:	98                   	cwtl   
     4f8:	83 f8 01             	cmp    $0x1,%eax
     4fb:	74 48                	je     545 <ls+0xd5>
     4fd:	83 f8 02             	cmp    $0x2,%eax
     500:	0f 85 7e 01 00 00    	jne    684 <ls+0x214>
  case T_FILE:
    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
     506:	8b bd bc fd ff ff    	mov    -0x244(%ebp),%edi
     50c:	8b b5 b4 fd ff ff    	mov    -0x24c(%ebp),%esi
     512:	0f b7 85 ac fd ff ff 	movzwl -0x254(%ebp),%eax
     519:	0f bf d8             	movswl %ax,%ebx
     51c:	83 ec 0c             	sub    $0xc,%esp
     51f:	ff 75 08             	pushl  0x8(%ebp)
     522:	e8 91 fe ff ff       	call   3b8 <fmtname>
     527:	83 c4 10             	add    $0x10,%esp
     52a:	83 ec 08             	sub    $0x8,%esp
     52d:	57                   	push   %edi
     52e:	56                   	push   %esi
     52f:	53                   	push   %ebx
     530:	50                   	push   %eax
     531:	68 c3 c7 01 00       	push   $0x1c7c3
     536:	6a 01                	push   $0x1
     538:	e8 ad 68 00 00       	call   6dea <printf>
     53d:	83 c4 20             	add    $0x20,%esp
    break;
     540:	e9 3f 01 00 00       	jmp    684 <ls+0x214>
  
  case T_DIR:
    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
     545:	83 ec 0c             	sub    $0xc,%esp
     548:	ff 75 08             	pushl  0x8(%ebp)
     54b:	e8 31 65 00 00       	call   6a81 <strlen>
     550:	83 c4 10             	add    $0x10,%esp
     553:	83 c0 20             	add    $0x20,%eax
     556:	3d 00 02 00 00       	cmp    $0x200,%eax
     55b:	76 17                	jbe    574 <ls+0x104>
      printf(1, "ls: path too long\n");
     55d:	83 ec 08             	sub    $0x8,%esp
     560:	68 d0 c7 01 00       	push   $0x1c7d0
     565:	6a 01                	push   $0x1
     567:	e8 7e 68 00 00       	call   6dea <printf>
     56c:	83 c4 10             	add    $0x10,%esp
      break;
     56f:	e9 10 01 00 00       	jmp    684 <ls+0x214>
    }
    strcpy(buf, path);
     574:	83 ec 08             	sub    $0x8,%esp
     577:	ff 75 08             	pushl  0x8(%ebp)
     57a:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     580:	50                   	push   %eax
     581:	e8 8c 64 00 00       	call   6a12 <strcpy>
     586:	83 c4 10             	add    $0x10,%esp
    p = buf+strlen(buf);
     589:	83 ec 0c             	sub    $0xc,%esp
     58c:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     592:	50                   	push   %eax
     593:	e8 e9 64 00 00       	call   6a81 <strlen>
     598:	83 c4 10             	add    $0x10,%esp
     59b:	89 c2                	mov    %eax,%edx
     59d:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     5a3:	01 d0                	add    %edx,%eax
     5a5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    *p++ = '/';
     5a8:	8b 45 e0             	mov    -0x20(%ebp),%eax
     5ab:	8d 50 01             	lea    0x1(%eax),%edx
     5ae:	89 55 e0             	mov    %edx,-0x20(%ebp)
     5b1:	c6 00 2f             	movb   $0x2f,(%eax)
    while(read(fd, &de, sizeof(de)) == sizeof(de)){
     5b4:	e9 aa 00 00 00       	jmp    663 <ls+0x1f3>
      if(de.inum == 0)
     5b9:	0f b7 85 c0 fd ff ff 	movzwl -0x240(%ebp),%eax
     5c0:	66 85 c0             	test   %ax,%ax
     5c3:	75 05                	jne    5ca <ls+0x15a>
        continue;
     5c5:	e9 99 00 00 00       	jmp    663 <ls+0x1f3>
      memmove(p, de.name, DIRSIZ);
     5ca:	83 ec 04             	sub    $0x4,%esp
     5cd:	6a 1e                	push   $0x1e
     5cf:	8d 85 c0 fd ff ff    	lea    -0x240(%ebp),%eax
     5d5:	83 c0 02             	add    $0x2,%eax
     5d8:	50                   	push   %eax
     5d9:	ff 75 e0             	pushl  -0x20(%ebp)
     5dc:	e8 1d 66 00 00       	call   6bfe <memmove>
     5e1:	83 c4 10             	add    $0x10,%esp
      p[DIRSIZ] = 0;
     5e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
     5e7:	83 c0 1e             	add    $0x1e,%eax
     5ea:	c6 00 00             	movb   $0x0,(%eax)
      if(stat(buf, &st) < 0){
     5ed:	83 ec 08             	sub    $0x8,%esp
     5f0:	8d 85 ac fd ff ff    	lea    -0x254(%ebp),%eax
     5f6:	50                   	push   %eax
     5f7:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     5fd:	50                   	push   %eax
     5fe:	e8 61 65 00 00       	call   6b64 <stat>
     603:	83 c4 10             	add    $0x10,%esp
     606:	85 c0                	test   %eax,%eax
     608:	79 1b                	jns    625 <ls+0x1b5>
        printf(1, "ls: cannot stat %s\n", buf);
     60a:	83 ec 04             	sub    $0x4,%esp
     60d:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     613:	50                   	push   %eax
     614:	68 af c7 01 00       	push   $0x1c7af
     619:	6a 01                	push   $0x1
     61b:	e8 ca 67 00 00       	call   6dea <printf>
     620:	83 c4 10             	add    $0x10,%esp
        continue;
     623:	eb 3e                	jmp    663 <ls+0x1f3>
      }
      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
     625:	8b bd bc fd ff ff    	mov    -0x244(%ebp),%edi
     62b:	8b b5 b4 fd ff ff    	mov    -0x24c(%ebp),%esi
     631:	0f b7 85 ac fd ff ff 	movzwl -0x254(%ebp),%eax
     638:	0f bf d8             	movswl %ax,%ebx
     63b:	83 ec 0c             	sub    $0xc,%esp
     63e:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     644:	50                   	push   %eax
     645:	e8 6e fd ff ff       	call   3b8 <fmtname>
     64a:	83 c4 10             	add    $0x10,%esp
     64d:	83 ec 08             	sub    $0x8,%esp
     650:	57                   	push   %edi
     651:	56                   	push   %esi
     652:	53                   	push   %ebx
     653:	50                   	push   %eax
     654:	68 c3 c7 01 00       	push   $0x1c7c3
     659:	6a 01                	push   $0x1
     65b:	e8 8a 67 00 00       	call   6dea <printf>
     660:	83 c4 20             	add    $0x20,%esp
      break;
    }
    strcpy(buf, path);
    p = buf+strlen(buf);
    *p++ = '/';
    while(read(fd, &de, sizeof(de)) == sizeof(de)){
     663:	83 ec 04             	sub    $0x4,%esp
     666:	6a 20                	push   $0x20
     668:	8d 85 c0 fd ff ff    	lea    -0x240(%ebp),%eax
     66e:	50                   	push   %eax
     66f:	ff 75 e4             	pushl  -0x1c(%ebp)
     672:	e8 e4 65 00 00       	call   6c5b <read>
     677:	83 c4 10             	add    $0x10,%esp
     67a:	83 f8 20             	cmp    $0x20,%eax
     67d:	0f 84 36 ff ff ff    	je     5b9 <ls+0x149>
        printf(1, "ls: cannot stat %s\n", buf);
        continue;
      }
      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
    }
    break;
     683:	90                   	nop
  }
  close(fd);
     684:	83 ec 0c             	sub    $0xc,%esp
     687:	ff 75 e4             	pushl  -0x1c(%ebp)
     68a:	e8 dc 65 00 00       	call   6c6b <close>
     68f:	83 c4 10             	add    $0x10,%esp
}
     692:	8d 65 f4             	lea    -0xc(%ebp),%esp
     695:	5b                   	pop    %ebx
     696:	5e                   	pop    %esi
     697:	5f                   	pop    %edi
     698:	5d                   	pop    %ebp
     699:	c3                   	ret    

0000069a <ls_new>:

void
ls_new(char *path)
{
     69a:	55                   	push   %ebp
     69b:	89 e5                	mov    %esp,%ebp
     69d:	57                   	push   %edi
     69e:	56                   	push   %esi
     69f:	53                   	push   %ebx
     6a0:	81 ec 7c 02 00 00    	sub    $0x27c,%esp
  char buf[512], *p;
  int fd;
  struct dirent de;
  struct stat st;
  
  if((fd = open(path, 0)) < 0){
     6a6:	83 ec 08             	sub    $0x8,%esp
     6a9:	6a 00                	push   $0x0
     6ab:	ff 75 08             	pushl  0x8(%ebp)
     6ae:	e8 d0 65 00 00       	call   6c83 <open>
     6b3:	83 c4 10             	add    $0x10,%esp
     6b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
     6b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
     6bd:	79 1a                	jns    6d9 <ls_new+0x3f>
    printf(2, "ls: cannot open %s\n", path);
     6bf:	83 ec 04             	sub    $0x4,%esp
     6c2:	ff 75 08             	pushl  0x8(%ebp)
     6c5:	68 9b c7 01 00       	push   $0x1c79b
     6ca:	6a 02                	push   $0x2
     6cc:	e8 19 67 00 00       	call   6dea <printf>
     6d1:	83 c4 10             	add    $0x10,%esp
    return;
     6d4:	e9 51 03 00 00       	jmp    a2a <ls_new+0x390>
  }
  
  if(fstat(fd, &st) < 0){
     6d9:	83 ec 08             	sub    $0x8,%esp
     6dc:	8d 85 a4 fd ff ff    	lea    -0x25c(%ebp),%eax
     6e2:	50                   	push   %eax
     6e3:	ff 75 e0             	pushl  -0x20(%ebp)
     6e6:	e8 b0 65 00 00       	call   6c9b <fstat>
     6eb:	83 c4 10             	add    $0x10,%esp
     6ee:	85 c0                	test   %eax,%eax
     6f0:	79 28                	jns    71a <ls_new+0x80>
    printf(2, "ls: cannot stat %s\n", path);
     6f2:	83 ec 04             	sub    $0x4,%esp
     6f5:	ff 75 08             	pushl  0x8(%ebp)
     6f8:	68 af c7 01 00       	push   $0x1c7af
     6fd:	6a 02                	push   $0x2
     6ff:	e8 e6 66 00 00       	call   6dea <printf>
     704:	83 c4 10             	add    $0x10,%esp
    close(fd);
     707:	83 ec 0c             	sub    $0xc,%esp
     70a:	ff 75 e0             	pushl  -0x20(%ebp)
     70d:	e8 59 65 00 00       	call   6c6b <close>
     712:	83 c4 10             	add    $0x10,%esp
    return;
     715:	e9 10 03 00 00       	jmp    a2a <ls_new+0x390>
  }
  
  switch(st.type){
     71a:	0f b7 85 a4 fd ff ff 	movzwl -0x25c(%ebp),%eax
     721:	98                   	cwtl   
     722:	83 f8 01             	cmp    $0x1,%eax
     725:	74 48                	je     76f <ls_new+0xd5>
     727:	83 f8 02             	cmp    $0x2,%eax
     72a:	0f 85 ec 02 00 00    	jne    a1c <ls_new+0x382>
  case T_FILE:
    printf(1, "%s %d %d %d %s\n", fmtname(path), st.type, st.ino, st.size);
     730:	8b bd b4 fd ff ff    	mov    -0x24c(%ebp),%edi
     736:	8b b5 ac fd ff ff    	mov    -0x254(%ebp),%esi
     73c:	0f b7 85 a4 fd ff ff 	movzwl -0x25c(%ebp),%eax
     743:	0f bf d8             	movswl %ax,%ebx
     746:	83 ec 0c             	sub    $0xc,%esp
     749:	ff 75 08             	pushl  0x8(%ebp)
     74c:	e8 67 fc ff ff       	call   3b8 <fmtname>
     751:	83 c4 10             	add    $0x10,%esp
     754:	83 ec 08             	sub    $0x8,%esp
     757:	57                   	push   %edi
     758:	56                   	push   %esi
     759:	53                   	push   %ebx
     75a:	50                   	push   %eax
     75b:	68 e3 c7 01 00       	push   $0x1c7e3
     760:	6a 01                	push   $0x1
     762:	e8 83 66 00 00       	call   6dea <printf>
     767:	83 c4 20             	add    $0x20,%esp
    break;
     76a:	e9 ad 02 00 00       	jmp    a1c <ls_new+0x382>
  
  case T_DIR:
    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
     76f:	83 ec 0c             	sub    $0xc,%esp
     772:	ff 75 08             	pushl  0x8(%ebp)
     775:	e8 07 63 00 00       	call   6a81 <strlen>
     77a:	83 c4 10             	add    $0x10,%esp
     77d:	83 c0 20             	add    $0x20,%eax
     780:	3d 00 02 00 00       	cmp    $0x200,%eax
     785:	76 17                	jbe    79e <ls_new+0x104>
      printf(1, "ls: path too long\n");
     787:	83 ec 08             	sub    $0x8,%esp
     78a:	68 d0 c7 01 00       	push   $0x1c7d0
     78f:	6a 01                	push   $0x1
     791:	e8 54 66 00 00       	call   6dea <printf>
     796:	83 c4 10             	add    $0x10,%esp
      break;
     799:	e9 7e 02 00 00       	jmp    a1c <ls_new+0x382>
    }
    strcpy(buf, path);
     79e:	83 ec 08             	sub    $0x8,%esp
     7a1:	ff 75 08             	pushl  0x8(%ebp)
     7a4:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
     7aa:	50                   	push   %eax
     7ab:	e8 62 62 00 00       	call   6a12 <strcpy>
     7b0:	83 c4 10             	add    $0x10,%esp
    p = buf+strlen(buf);
     7b3:	83 ec 0c             	sub    $0xc,%esp
     7b6:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
     7bc:	50                   	push   %eax
     7bd:	e8 bf 62 00 00       	call   6a81 <strlen>
     7c2:	83 c4 10             	add    $0x10,%esp
     7c5:	89 c2                	mov    %eax,%edx
     7c7:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
     7cd:	01 d0                	add    %edx,%eax
     7cf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    *p++ = '/';
     7d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
     7d5:	8d 50 01             	lea    0x1(%eax),%edx
     7d8:	89 55 dc             	mov    %edx,-0x24(%ebp)
     7db:	c6 00 2f             	movb   $0x2f,(%eax)
    while(read(fd, &de, sizeof(de)) == sizeof(de)){
     7de:	e9 18 02 00 00       	jmp    9fb <ls_new+0x361>
      if(de.inum == 0)
     7e3:	0f b7 85 b8 fd ff ff 	movzwl -0x248(%ebp),%eax
     7ea:	66 85 c0             	test   %ax,%ax
     7ed:	75 05                	jne    7f4 <ls_new+0x15a>
        continue;
     7ef:	e9 07 02 00 00       	jmp    9fb <ls_new+0x361>
      memmove(p, de.name, DIRSIZ);
     7f4:	83 ec 04             	sub    $0x4,%esp
     7f7:	6a 1e                	push   $0x1e
     7f9:	8d 85 b8 fd ff ff    	lea    -0x248(%ebp),%eax
     7ff:	83 c0 02             	add    $0x2,%eax
     802:	50                   	push   %eax
     803:	ff 75 dc             	pushl  -0x24(%ebp)
     806:	e8 f3 63 00 00       	call   6bfe <memmove>
     80b:	83 c4 10             	add    $0x10,%esp
      p[DIRSIZ] = 0;
     80e:	8b 45 dc             	mov    -0x24(%ebp),%eax
     811:	83 c0 1e             	add    $0x1e,%eax
     814:	c6 00 00             	movb   $0x0,(%eax)
      if(stat(buf, &st) < 0){
     817:	83 ec 08             	sub    $0x8,%esp
     81a:	8d 85 a4 fd ff ff    	lea    -0x25c(%ebp),%eax
     820:	50                   	push   %eax
     821:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
     827:	50                   	push   %eax
     828:	e8 37 63 00 00       	call   6b64 <stat>
     82d:	83 c4 10             	add    $0x10,%esp
     830:	85 c0                	test   %eax,%eax
     832:	79 1e                	jns    852 <ls_new+0x1b8>
        printf(1, "ls: cannot stat %s\n", buf);
     834:	83 ec 04             	sub    $0x4,%esp
     837:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
     83d:	50                   	push   %eax
     83e:	68 af c7 01 00       	push   $0x1c7af
     843:	6a 01                	push   $0x1
     845:	e8 a0 65 00 00       	call   6dea <printf>
     84a:	83 c4 10             	add    $0x10,%esp
        continue;
     84d:	e9 a9 01 00 00       	jmp    9fb <ls_new+0x361>
      }
      is_file = 0;
     852:	c7 05 a0 57 02 00 00 	movl   $0x0,0x257a0
     859:	00 00 00 
      char *filetype;
      char *filename;
      filename=fmtname(buf);
     85c:	83 ec 0c             	sub    $0xc,%esp
     85f:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
     865:	50                   	push   %eax
     866:	e8 4d fb ff ff       	call   3b8 <fmtname>
     86b:	83 c4 10             	add    $0x10,%esp
     86e:	89 45 d8             	mov    %eax,-0x28(%ebp)
      for(filetype=filename+strlen(filename); filetype >= filename && *filetype != '.'; filetype--)
     871:	83 ec 0c             	sub    $0xc,%esp
     874:	ff 75 d8             	pushl  -0x28(%ebp)
     877:	e8 05 62 00 00       	call   6a81 <strlen>
     87c:	83 c4 10             	add    $0x10,%esp
     87f:	89 c2                	mov    %eax,%edx
     881:	8b 45 d8             	mov    -0x28(%ebp),%eax
     884:	01 d0                	add    %edx,%eax
     886:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     889:	eb 04                	jmp    88f <ls_new+0x1f5>
     88b:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
     88f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     892:	3b 45 d8             	cmp    -0x28(%ebp),%eax
     895:	72 0a                	jb     8a1 <ls_new+0x207>
     897:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     89a:	0f b6 00             	movzbl (%eax),%eax
     89d:	3c 2e                	cmp    $0x2e,%al
     89f:	75 ea                	jne    88b <ls_new+0x1f1>
          ;
      if(*filetype != '.' || filename[0]=='.') is_file=0;
     8a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     8a4:	0f b6 00             	movzbl (%eax),%eax
     8a7:	3c 2e                	cmp    $0x2e,%al
     8a9:	75 0a                	jne    8b5 <ls_new+0x21b>
     8ab:	8b 45 d8             	mov    -0x28(%ebp),%eax
     8ae:	0f b6 00             	movzbl (%eax),%eax
     8b1:	3c 2e                	cmp    $0x2e,%al
     8b3:	75 0c                	jne    8c1 <ls_new+0x227>
     8b5:	c7 05 a0 57 02 00 00 	movl   $0x0,0x257a0
     8bc:	00 00 00 
     8bf:	eb 14                	jmp    8d5 <ls_new+0x23b>
      else if(*filetype == '.') is_file=1;
     8c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     8c4:	0f b6 00             	movzbl (%eax),%eax
     8c7:	3c 2e                	cmp    $0x2e,%al
     8c9:	75 0a                	jne    8d5 <ls_new+0x23b>
     8cb:	c7 05 a0 57 02 00 01 	movl   $0x1,0x257a0
     8d2:	00 00 00 
      if(is_file == 0)
     8d5:	a1 a0 57 02 00       	mov    0x257a0,%eax
     8da:	85 c0                	test   %eax,%eax
     8dc:	75 5c                	jne    93a <ls_new+0x2a0>
      {
          char tem[]="not a file";
     8de:	c7 85 99 fd ff ff 6e 	movl   $0x20746f6e,-0x267(%ebp)
     8e5:	6f 74 20 
     8e8:	c7 85 9d fd ff ff 61 	movl   $0x69662061,-0x263(%ebp)
     8ef:	20 66 69 
     8f2:	66 c7 85 a1 fd ff ff 	movw   $0x656c,-0x25f(%ebp)
     8f9:	6c 65 
     8fb:	c6 85 a3 fd ff ff 00 	movb   $0x0,-0x25d(%ebp)
          printf(1, "%s %d %d %d %s\n", filename, st.type, st.ino, st.size, tem);
     902:	8b 8d b4 fd ff ff    	mov    -0x24c(%ebp),%ecx
     908:	8b 95 ac fd ff ff    	mov    -0x254(%ebp),%edx
     90e:	0f b7 85 a4 fd ff ff 	movzwl -0x25c(%ebp),%eax
     915:	98                   	cwtl   
     916:	83 ec 04             	sub    $0x4,%esp
     919:	8d 9d 99 fd ff ff    	lea    -0x267(%ebp),%ebx
     91f:	53                   	push   %ebx
     920:	51                   	push   %ecx
     921:	52                   	push   %edx
     922:	50                   	push   %eax
     923:	ff 75 d8             	pushl  -0x28(%ebp)
     926:	68 e3 c7 01 00       	push   $0x1c7e3
     92b:	6a 01                	push   $0x1
     92d:	e8 b8 64 00 00       	call   6dea <printf>
     932:	83 c4 20             	add    $0x20,%esp
     935:	e9 c1 00 00 00       	jmp    9fb <ls_new+0x361>
      }
      else if(is_file == 1)
     93a:	a1 a0 57 02 00       	mov    0x257a0,%eax
     93f:	83 f8 01             	cmp    $0x1,%eax
     942:	0f 85 b3 00 00 00    	jne    9fb <ls_new+0x361>
      {
          filetype++;
     948:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
          char tem[DIRSIZ+1];
          memmove(tem, filetype, strlen(filetype));
     94c:	83 ec 0c             	sub    $0xc,%esp
     94f:	ff 75 e4             	pushl  -0x1c(%ebp)
     952:	e8 2a 61 00 00       	call   6a81 <strlen>
     957:	83 c4 10             	add    $0x10,%esp
     95a:	83 ec 04             	sub    $0x4,%esp
     95d:	50                   	push   %eax
     95e:	ff 75 e4             	pushl  -0x1c(%ebp)
     961:	8d 85 7a fd ff ff    	lea    -0x286(%ebp),%eax
     967:	50                   	push   %eax
     968:	e8 91 62 00 00       	call   6bfe <memmove>
     96d:	83 c4 10             	add    $0x10,%esp
          printf(1, "%s %d %d %d %s\n", filename, st.type, st.ino, st.size, tem);
     970:	8b 8d b4 fd ff ff    	mov    -0x24c(%ebp),%ecx
     976:	8b 95 ac fd ff ff    	mov    -0x254(%ebp),%edx
     97c:	0f b7 85 a4 fd ff ff 	movzwl -0x25c(%ebp),%eax
     983:	98                   	cwtl   
     984:	83 ec 04             	sub    $0x4,%esp
     987:	8d 9d 7a fd ff ff    	lea    -0x286(%ebp),%ebx
     98d:	53                   	push   %ebx
     98e:	51                   	push   %ecx
     98f:	52                   	push   %edx
     990:	50                   	push   %eax
     991:	ff 75 d8             	pushl  -0x28(%ebp)
     994:	68 e3 c7 01 00       	push   $0x1c7e3
     999:	6a 01                	push   $0x1
     99b:	e8 4a 64 00 00       	call   6dea <printf>
     9a0:	83 c4 20             	add    $0x20,%esp
          // adjust image size here
          if(st.size<1000000) ImageListAppend(filename, st.size, strlen(filename), image_list, tem, strlen(tem));
     9a3:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
     9a9:	3d 3f 42 0f 00       	cmp    $0xf423f,%eax
     9ae:	77 4b                	ja     9fb <ls_new+0x361>
     9b0:	83 ec 0c             	sub    $0xc,%esp
     9b3:	8d 85 7a fd ff ff    	lea    -0x286(%ebp),%eax
     9b9:	50                   	push   %eax
     9ba:	e8 c2 60 00 00       	call   6a81 <strlen>
     9bf:	83 c4 10             	add    $0x10,%esp
     9c2:	89 c6                	mov    %eax,%esi
     9c4:	8b 1d 74 58 02 00    	mov    0x25874,%ebx
     9ca:	83 ec 0c             	sub    $0xc,%esp
     9cd:	ff 75 d8             	pushl  -0x28(%ebp)
     9d0:	e8 ac 60 00 00       	call   6a81 <strlen>
     9d5:	83 c4 10             	add    $0x10,%esp
     9d8:	89 c1                	mov    %eax,%ecx
     9da:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
     9e0:	89 c2                	mov    %eax,%edx
     9e2:	83 ec 08             	sub    $0x8,%esp
     9e5:	56                   	push   %esi
     9e6:	8d 85 7a fd ff ff    	lea    -0x286(%ebp),%eax
     9ec:	50                   	push   %eax
     9ed:	53                   	push   %ebx
     9ee:	51                   	push   %ecx
     9ef:	52                   	push   %edx
     9f0:	ff 75 d8             	pushl  -0x28(%ebp)
     9f3:	e8 21 f6 ff ff       	call   19 <ImageListAppend>
     9f8:	83 c4 20             	add    $0x20,%esp
      break;
    }
    strcpy(buf, path);
    p = buf+strlen(buf);
    *p++ = '/';
    while(read(fd, &de, sizeof(de)) == sizeof(de)){
     9fb:	83 ec 04             	sub    $0x4,%esp
     9fe:	6a 20                	push   $0x20
     a00:	8d 85 b8 fd ff ff    	lea    -0x248(%ebp),%eax
     a06:	50                   	push   %eax
     a07:	ff 75 e0             	pushl  -0x20(%ebp)
     a0a:	e8 4c 62 00 00       	call   6c5b <read>
     a0f:	83 c4 10             	add    $0x10,%esp
     a12:	83 f8 20             	cmp    $0x20,%eax
     a15:	0f 84 c8 fd ff ff    	je     7e3 <ls_new+0x149>
          // adjust image size here
          if(st.size<1000000) ImageListAppend(filename, st.size, strlen(filename), image_list, tem, strlen(tem));
        //   else if(st.size == 1080138) ImageListAppend(filename, st.size, strlen(filename), image_list, tem, strlen(tem));
      }
    }
    break;
     a1b:	90                   	nop
  }
  close(fd);
     a1c:	83 ec 0c             	sub    $0xc,%esp
     a1f:	ff 75 e0             	pushl  -0x20(%ebp)
     a22:	e8 44 62 00 00       	call   6c6b <close>
     a27:	83 c4 10             	add    $0x10,%esp
}
     a2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
     a2d:	5b                   	pop    %ebx
     a2e:	5e                   	pop    %esi
     a2f:	5f                   	pop    %edi
     a30:	5d                   	pop    %ebp
     a31:	c3                   	ret    

00000a32 <isMouseInCutBoxLeft>:

int isMouseInCutBoxLeft(int x, int y) {
     a32:	55                   	push   %ebp
     a33:	89 e5                	mov    %esp,%ebp
   if (cutbox_pos.x-cut_box_dash_corner_height <= x && x <= cutbox_pos.x 
     a35:	a1 24 53 02 00       	mov    0x25324,%eax
     a3a:	ba 05 00 00 00       	mov    $0x5,%edx
     a3f:	29 d0                	sub    %edx,%eax
     a41:	3b 45 08             	cmp    0x8(%ebp),%eax
     a44:	7f 3b                	jg     a81 <isMouseInCutBoxLeft+0x4f>
     a46:	a1 24 53 02 00       	mov    0x25324,%eax
     a4b:	3b 45 08             	cmp    0x8(%ebp),%eax
     a4e:	7c 31                	jl     a81 <isMouseInCutBoxLeft+0x4f>
        && cutbox_pos.y + cut_box_dash_corner_width <= y && y <= cutbox_pos.y + cutbox_size.h - cut_box_dash_corner_width ){
     a50:	a1 28 53 02 00       	mov    0x25328,%eax
     a55:	ba 0a 00 00 00       	mov    $0xa,%edx
     a5a:	01 d0                	add    %edx,%eax
     a5c:	3b 45 0c             	cmp    0xc(%ebp),%eax
     a5f:	7f 20                	jg     a81 <isMouseInCutBoxLeft+0x4f>
     a61:	8b 15 28 53 02 00    	mov    0x25328,%edx
     a67:	a1 14 53 02 00       	mov    0x25314,%eax
     a6c:	01 d0                	add    %edx,%eax
     a6e:	ba 0a 00 00 00       	mov    $0xa,%edx
     a73:	29 d0                	sub    %edx,%eax
     a75:	3b 45 0c             	cmp    0xc(%ebp),%eax
     a78:	7c 07                	jl     a81 <isMouseInCutBoxLeft+0x4f>
        return 1;
     a7a:	b8 01 00 00 00       	mov    $0x1,%eax
     a7f:	eb 05                	jmp    a86 <isMouseInCutBoxLeft+0x54>
   }
   else {
        return 0;
     a81:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     a86:	5d                   	pop    %ebp
     a87:	c3                   	ret    

00000a88 <isMouseInCutBoxUpLeft>:

int isMouseInCutBoxUpLeft(int x, int y) {
     a88:	55                   	push   %ebp
     a89:	89 e5                	mov    %esp,%ebp
   if ( ( cutbox_pos.x-cut_box_dash_corner_height <= x && x <= cutbox_pos.x 
     a8b:	a1 24 53 02 00       	mov    0x25324,%eax
     a90:	ba 05 00 00 00       	mov    $0x5,%edx
     a95:	29 d0                	sub    %edx,%eax
     a97:	3b 45 08             	cmp    0x8(%ebp),%eax
     a9a:	7f 2c                	jg     ac8 <isMouseInCutBoxUpLeft+0x40>
     a9c:	a1 24 53 02 00       	mov    0x25324,%eax
     aa1:	3b 45 08             	cmp    0x8(%ebp),%eax
     aa4:	7c 22                	jl     ac8 <isMouseInCutBoxUpLeft+0x40>
            && cutbox_pos.y - cut_box_dash_corner_height <= y && y < cutbox_pos.y + cut_box_dash_corner_width ) 
     aa6:	a1 28 53 02 00       	mov    0x25328,%eax
     aab:	ba 05 00 00 00       	mov    $0x5,%edx
     ab0:	29 d0                	sub    %edx,%eax
     ab2:	3b 45 0c             	cmp    0xc(%ebp),%eax
     ab5:	7f 11                	jg     ac8 <isMouseInCutBoxUpLeft+0x40>
     ab7:	a1 28 53 02 00       	mov    0x25328,%eax
     abc:	ba 0a 00 00 00       	mov    $0xa,%edx
     ac1:	01 d0                	add    %edx,%eax
     ac3:	3b 45 0c             	cmp    0xc(%ebp),%eax
     ac6:	7f 3d                	jg     b05 <isMouseInCutBoxUpLeft+0x7d>
        || ( cutbox_pos.x-cut_box_dash_corner_height <= x && x < cutbox_pos.x + cut_box_dash_corner_width
     ac8:	a1 24 53 02 00       	mov    0x25324,%eax
     acd:	ba 05 00 00 00       	mov    $0x5,%edx
     ad2:	29 d0                	sub    %edx,%eax
     ad4:	3b 45 08             	cmp    0x8(%ebp),%eax
     ad7:	7f 33                	jg     b0c <isMouseInCutBoxUpLeft+0x84>
     ad9:	a1 24 53 02 00       	mov    0x25324,%eax
     ade:	ba 0a 00 00 00       	mov    $0xa,%edx
     ae3:	01 d0                	add    %edx,%eax
     ae5:	3b 45 08             	cmp    0x8(%ebp),%eax
     ae8:	7e 22                	jle    b0c <isMouseInCutBoxUpLeft+0x84>
            && cutbox_pos.y - cut_box_dash_corner_height <= y && y <= cutbox_pos.y ) ){
     aea:	a1 28 53 02 00       	mov    0x25328,%eax
     aef:	ba 05 00 00 00       	mov    $0x5,%edx
     af4:	29 d0                	sub    %edx,%eax
     af6:	3b 45 0c             	cmp    0xc(%ebp),%eax
     af9:	7f 11                	jg     b0c <isMouseInCutBoxUpLeft+0x84>
     afb:	a1 28 53 02 00       	mov    0x25328,%eax
     b00:	3b 45 0c             	cmp    0xc(%ebp),%eax
     b03:	7c 07                	jl     b0c <isMouseInCutBoxUpLeft+0x84>
        return 1;
     b05:	b8 01 00 00 00       	mov    $0x1,%eax
     b0a:	eb 05                	jmp    b11 <isMouseInCutBoxUpLeft+0x89>
   }
   else {
        return 0;
     b0c:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     b11:	5d                   	pop    %ebp
     b12:	c3                   	ret    

00000b13 <isMouseInCutBoxDownLeft>:

int isMouseInCutBoxDownLeft(int x, int y) {
     b13:	55                   	push   %ebp
     b14:	89 e5                	mov    %esp,%ebp
   if ( ( cutbox_pos.x-cut_box_dash_corner_height <= x && x <= cutbox_pos.x 
     b16:	a1 24 53 02 00       	mov    0x25324,%eax
     b1b:	ba 05 00 00 00       	mov    $0x5,%edx
     b20:	29 d0                	sub    %edx,%eax
     b22:	3b 45 08             	cmp    0x8(%ebp),%eax
     b25:	7f 3c                	jg     b63 <isMouseInCutBoxDownLeft+0x50>
     b27:	a1 24 53 02 00       	mov    0x25324,%eax
     b2c:	3b 45 08             	cmp    0x8(%ebp),%eax
     b2f:	7c 32                	jl     b63 <isMouseInCutBoxDownLeft+0x50>
            && cutbox_pos.y + cutbox_size.h - cut_box_dash_corner_width < y && y <= cutbox_pos.y + cutbox_size.h + cut_box_dash_corner_height ) 
     b31:	8b 15 28 53 02 00    	mov    0x25328,%edx
     b37:	a1 14 53 02 00       	mov    0x25314,%eax
     b3c:	01 d0                	add    %edx,%eax
     b3e:	ba 0a 00 00 00       	mov    $0xa,%edx
     b43:	29 d0                	sub    %edx,%eax
     b45:	3b 45 0c             	cmp    0xc(%ebp),%eax
     b48:	7d 19                	jge    b63 <isMouseInCutBoxDownLeft+0x50>
     b4a:	8b 15 28 53 02 00    	mov    0x25328,%edx
     b50:	a1 14 53 02 00       	mov    0x25314,%eax
     b55:	01 d0                	add    %edx,%eax
     b57:	ba 05 00 00 00       	mov    $0x5,%edx
     b5c:	01 d0                	add    %edx,%eax
     b5e:	3b 45 0c             	cmp    0xc(%ebp),%eax
     b61:	7d 4d                	jge    bb0 <isMouseInCutBoxDownLeft+0x9d>
        || ( cutbox_pos.x-cut_box_dash_corner_height <= x && x < cutbox_pos.x + cut_box_dash_corner_width
     b63:	a1 24 53 02 00       	mov    0x25324,%eax
     b68:	ba 05 00 00 00       	mov    $0x5,%edx
     b6d:	29 d0                	sub    %edx,%eax
     b6f:	3b 45 08             	cmp    0x8(%ebp),%eax
     b72:	7f 43                	jg     bb7 <isMouseInCutBoxDownLeft+0xa4>
     b74:	a1 24 53 02 00       	mov    0x25324,%eax
     b79:	ba 0a 00 00 00       	mov    $0xa,%edx
     b7e:	01 d0                	add    %edx,%eax
     b80:	3b 45 08             	cmp    0x8(%ebp),%eax
     b83:	7e 32                	jle    bb7 <isMouseInCutBoxDownLeft+0xa4>
            && cutbox_pos.y + cutbox_size.h <= y && y <= cutbox_pos.y + cutbox_size.h + cut_box_dash_corner_height ) ){
     b85:	8b 15 28 53 02 00    	mov    0x25328,%edx
     b8b:	a1 14 53 02 00       	mov    0x25314,%eax
     b90:	01 d0                	add    %edx,%eax
     b92:	3b 45 0c             	cmp    0xc(%ebp),%eax
     b95:	7f 20                	jg     bb7 <isMouseInCutBoxDownLeft+0xa4>
     b97:	8b 15 28 53 02 00    	mov    0x25328,%edx
     b9d:	a1 14 53 02 00       	mov    0x25314,%eax
     ba2:	01 d0                	add    %edx,%eax
     ba4:	ba 05 00 00 00       	mov    $0x5,%edx
     ba9:	01 d0                	add    %edx,%eax
     bab:	3b 45 0c             	cmp    0xc(%ebp),%eax
     bae:	7c 07                	jl     bb7 <isMouseInCutBoxDownLeft+0xa4>
        return 1;
     bb0:	b8 01 00 00 00       	mov    $0x1,%eax
     bb5:	eb 05                	jmp    bbc <isMouseInCutBoxDownLeft+0xa9>
   }
   else {
        return 0;
     bb7:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     bbc:	5d                   	pop    %ebp
     bbd:	c3                   	ret    

00000bbe <isMouseInCutBoxRight>:

int isMouseInCutBoxRight(int x, int y) {
     bbe:	55                   	push   %ebp
     bbf:	89 e5                	mov    %esp,%ebp
   if (cutbox_pos.x + cutbox_size.w <= x && x < cutbox_pos.x + cutbox_size.w + cut_box_dash_corner_height 
     bc1:	8b 15 24 53 02 00    	mov    0x25324,%edx
     bc7:	a1 18 53 02 00       	mov    0x25318,%eax
     bcc:	01 d0                	add    %edx,%eax
     bce:	3b 45 08             	cmp    0x8(%ebp),%eax
     bd1:	7f 4a                	jg     c1d <isMouseInCutBoxRight+0x5f>
     bd3:	8b 15 24 53 02 00    	mov    0x25324,%edx
     bd9:	a1 18 53 02 00       	mov    0x25318,%eax
     bde:	01 d0                	add    %edx,%eax
     be0:	ba 05 00 00 00       	mov    $0x5,%edx
     be5:	01 d0                	add    %edx,%eax
     be7:	3b 45 08             	cmp    0x8(%ebp),%eax
     bea:	7e 31                	jle    c1d <isMouseInCutBoxRight+0x5f>
        && cutbox_pos.y + cut_box_dash_corner_width <= y && y <= cutbox_pos.y + cutbox_size.h - cut_box_dash_corner_width ){
     bec:	a1 28 53 02 00       	mov    0x25328,%eax
     bf1:	ba 0a 00 00 00       	mov    $0xa,%edx
     bf6:	01 d0                	add    %edx,%eax
     bf8:	3b 45 0c             	cmp    0xc(%ebp),%eax
     bfb:	7f 20                	jg     c1d <isMouseInCutBoxRight+0x5f>
     bfd:	8b 15 28 53 02 00    	mov    0x25328,%edx
     c03:	a1 14 53 02 00       	mov    0x25314,%eax
     c08:	01 d0                	add    %edx,%eax
     c0a:	ba 0a 00 00 00       	mov    $0xa,%edx
     c0f:	29 d0                	sub    %edx,%eax
     c11:	3b 45 0c             	cmp    0xc(%ebp),%eax
     c14:	7c 07                	jl     c1d <isMouseInCutBoxRight+0x5f>
        return 1;
     c16:	b8 01 00 00 00       	mov    $0x1,%eax
     c1b:	eb 05                	jmp    c22 <isMouseInCutBoxRight+0x64>
   }
   else {
        return 0;
     c1d:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     c22:	5d                   	pop    %ebp
     c23:	c3                   	ret    

00000c24 <isMouseInCutBoxUpRight>:

int isMouseInCutBoxUpRight(int x, int y) {
     c24:	55                   	push   %ebp
     c25:	89 e5                	mov    %esp,%ebp
   if ( ( cutbox_pos.x + cutbox_size.w -cut_box_dash_corner_width < x && x <= cutbox_pos.x + cutbox_size.w + cut_box_dash_corner_height
     c27:	8b 15 24 53 02 00    	mov    0x25324,%edx
     c2d:	a1 18 53 02 00       	mov    0x25318,%eax
     c32:	01 d0                	add    %edx,%eax
     c34:	ba 0a 00 00 00       	mov    $0xa,%edx
     c39:	29 d0                	sub    %edx,%eax
     c3b:	3b 45 08             	cmp    0x8(%ebp),%eax
     c3e:	7d 34                	jge    c74 <isMouseInCutBoxUpRight+0x50>
     c40:	8b 15 24 53 02 00    	mov    0x25324,%edx
     c46:	a1 18 53 02 00       	mov    0x25318,%eax
     c4b:	01 d0                	add    %edx,%eax
     c4d:	ba 05 00 00 00       	mov    $0x5,%edx
     c52:	01 d0                	add    %edx,%eax
     c54:	3b 45 08             	cmp    0x8(%ebp),%eax
     c57:	7c 1b                	jl     c74 <isMouseInCutBoxUpRight+0x50>
            && cutbox_pos.y - cut_box_dash_corner_height <= y && y <= cutbox_pos.y ) 
     c59:	a1 28 53 02 00       	mov    0x25328,%eax
     c5e:	ba 05 00 00 00       	mov    $0x5,%edx
     c63:	29 d0                	sub    %edx,%eax
     c65:	3b 45 0c             	cmp    0xc(%ebp),%eax
     c68:	7f 0a                	jg     c74 <isMouseInCutBoxUpRight+0x50>
     c6a:	a1 28 53 02 00       	mov    0x25328,%eax
     c6f:	3b 45 0c             	cmp    0xc(%ebp),%eax
     c72:	7d 4d                	jge    cc1 <isMouseInCutBoxUpRight+0x9d>
        || ( cutbox_pos.x + cutbox_size.w <= x && x <= cutbox_pos.x + cutbox_size.w + cut_box_dash_corner_height
     c74:	8b 15 24 53 02 00    	mov    0x25324,%edx
     c7a:	a1 18 53 02 00       	mov    0x25318,%eax
     c7f:	01 d0                	add    %edx,%eax
     c81:	3b 45 08             	cmp    0x8(%ebp),%eax
     c84:	7f 42                	jg     cc8 <isMouseInCutBoxUpRight+0xa4>
     c86:	8b 15 24 53 02 00    	mov    0x25324,%edx
     c8c:	a1 18 53 02 00       	mov    0x25318,%eax
     c91:	01 d0                	add    %edx,%eax
     c93:	ba 05 00 00 00       	mov    $0x5,%edx
     c98:	01 d0                	add    %edx,%eax
     c9a:	3b 45 08             	cmp    0x8(%ebp),%eax
     c9d:	7c 29                	jl     cc8 <isMouseInCutBoxUpRight+0xa4>
            && cutbox_pos.y - cut_box_dash_corner_height <= y && y <= cutbox_pos.y + cut_box_dash_corner_width ) ){
     c9f:	a1 28 53 02 00       	mov    0x25328,%eax
     ca4:	ba 05 00 00 00       	mov    $0x5,%edx
     ca9:	29 d0                	sub    %edx,%eax
     cab:	3b 45 0c             	cmp    0xc(%ebp),%eax
     cae:	7f 18                	jg     cc8 <isMouseInCutBoxUpRight+0xa4>
     cb0:	a1 28 53 02 00       	mov    0x25328,%eax
     cb5:	ba 0a 00 00 00       	mov    $0xa,%edx
     cba:	01 d0                	add    %edx,%eax
     cbc:	3b 45 0c             	cmp    0xc(%ebp),%eax
     cbf:	7c 07                	jl     cc8 <isMouseInCutBoxUpRight+0xa4>
        return 1;
     cc1:	b8 01 00 00 00       	mov    $0x1,%eax
     cc6:	eb 05                	jmp    ccd <isMouseInCutBoxUpRight+0xa9>
   }
   else {
        return 0;
     cc8:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     ccd:	5d                   	pop    %ebp
     cce:	c3                   	ret    

00000ccf <isMouseInCutBoxDownRight>:

int isMouseInCutBoxDownRight(int x, int y) {
     ccf:	55                   	push   %ebp
     cd0:	89 e5                	mov    %esp,%ebp
   if ( ( cutbox_pos.x + cutbox_size.w -cut_box_dash_corner_width < x && x < cutbox_pos.x + cutbox_size.w + cut_box_dash_corner_height
     cd2:	8b 15 24 53 02 00    	mov    0x25324,%edx
     cd8:	a1 18 53 02 00       	mov    0x25318,%eax
     cdd:	01 d0                	add    %edx,%eax
     cdf:	ba 0a 00 00 00       	mov    $0xa,%edx
     ce4:	29 d0                	sub    %edx,%eax
     ce6:	3b 45 08             	cmp    0x8(%ebp),%eax
     ce9:	7d 44                	jge    d2f <isMouseInCutBoxDownRight+0x60>
     ceb:	8b 15 24 53 02 00    	mov    0x25324,%edx
     cf1:	a1 18 53 02 00       	mov    0x25318,%eax
     cf6:	01 d0                	add    %edx,%eax
     cf8:	ba 05 00 00 00       	mov    $0x5,%edx
     cfd:	01 d0                	add    %edx,%eax
     cff:	3b 45 08             	cmp    0x8(%ebp),%eax
     d02:	7e 2b                	jle    d2f <isMouseInCutBoxDownRight+0x60>
            && cutbox_pos.y + cutbox_size.h <= y && y <= cutbox_pos.y + cutbox_size.h + cut_box_dash_corner_height ) 
     d04:	8b 15 28 53 02 00    	mov    0x25328,%edx
     d0a:	a1 14 53 02 00       	mov    0x25314,%eax
     d0f:	01 d0                	add    %edx,%eax
     d11:	3b 45 0c             	cmp    0xc(%ebp),%eax
     d14:	7f 19                	jg     d2f <isMouseInCutBoxDownRight+0x60>
     d16:	8b 15 28 53 02 00    	mov    0x25328,%edx
     d1c:	a1 14 53 02 00       	mov    0x25314,%eax
     d21:	01 d0                	add    %edx,%eax
     d23:	ba 05 00 00 00       	mov    $0x5,%edx
     d28:	01 d0                	add    %edx,%eax
     d2a:	3b 45 0c             	cmp    0xc(%ebp),%eax
     d2d:	7d 5d                	jge    d8c <isMouseInCutBoxDownRight+0xbd>
        || ( cutbox_pos.x + cutbox_size.w <= x && x < cutbox_pos.x + cutbox_size.w + cut_box_dash_corner_height
     d2f:	8b 15 24 53 02 00    	mov    0x25324,%edx
     d35:	a1 18 53 02 00       	mov    0x25318,%eax
     d3a:	01 d0                	add    %edx,%eax
     d3c:	3b 45 08             	cmp    0x8(%ebp),%eax
     d3f:	7f 52                	jg     d93 <isMouseInCutBoxDownRight+0xc4>
     d41:	8b 15 24 53 02 00    	mov    0x25324,%edx
     d47:	a1 18 53 02 00       	mov    0x25318,%eax
     d4c:	01 d0                	add    %edx,%eax
     d4e:	ba 05 00 00 00       	mov    $0x5,%edx
     d53:	01 d0                	add    %edx,%eax
     d55:	3b 45 08             	cmp    0x8(%ebp),%eax
     d58:	7e 39                	jle    d93 <isMouseInCutBoxDownRight+0xc4>
            && cutbox_pos.y + cutbox_size.h - cut_box_dash_corner_width <= y && y <= cutbox_pos.y + cutbox_size.h + cut_box_dash_corner_height ) ){
     d5a:	8b 15 28 53 02 00    	mov    0x25328,%edx
     d60:	a1 14 53 02 00       	mov    0x25314,%eax
     d65:	01 d0                	add    %edx,%eax
     d67:	ba 0a 00 00 00       	mov    $0xa,%edx
     d6c:	29 d0                	sub    %edx,%eax
     d6e:	3b 45 0c             	cmp    0xc(%ebp),%eax
     d71:	7f 20                	jg     d93 <isMouseInCutBoxDownRight+0xc4>
     d73:	8b 15 28 53 02 00    	mov    0x25328,%edx
     d79:	a1 14 53 02 00       	mov    0x25314,%eax
     d7e:	01 d0                	add    %edx,%eax
     d80:	ba 05 00 00 00       	mov    $0x5,%edx
     d85:	01 d0                	add    %edx,%eax
     d87:	3b 45 0c             	cmp    0xc(%ebp),%eax
     d8a:	7c 07                	jl     d93 <isMouseInCutBoxDownRight+0xc4>
        return 1;
     d8c:	b8 01 00 00 00       	mov    $0x1,%eax
     d91:	eb 05                	jmp    d98 <isMouseInCutBoxDownRight+0xc9>
   }
   else {
        return 0;
     d93:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     d98:	5d                   	pop    %ebp
     d99:	c3                   	ret    

00000d9a <isMouseInCutBoxUp>:

int isMouseInCutBoxUp(int x, int y) {
     d9a:	55                   	push   %ebp
     d9b:	89 e5                	mov    %esp,%ebp
   if (cutbox_pos.x + cut_box_dash_corner_width <= x && x <= cutbox_pos.x + cutbox_size.w - cut_box_dash_corner_width
     d9d:	a1 24 53 02 00       	mov    0x25324,%eax
     da2:	ba 0a 00 00 00       	mov    $0xa,%edx
     da7:	01 d0                	add    %edx,%eax
     da9:	3b 45 08             	cmp    0x8(%ebp),%eax
     dac:	7f 3b                	jg     de9 <isMouseInCutBoxUp+0x4f>
     dae:	8b 15 24 53 02 00    	mov    0x25324,%edx
     db4:	a1 18 53 02 00       	mov    0x25318,%eax
     db9:	01 d0                	add    %edx,%eax
     dbb:	ba 0a 00 00 00       	mov    $0xa,%edx
     dc0:	29 d0                	sub    %edx,%eax
     dc2:	3b 45 08             	cmp    0x8(%ebp),%eax
     dc5:	7c 22                	jl     de9 <isMouseInCutBoxUp+0x4f>
        && cutbox_pos.y - cut_box_dash_corner_height <= y && y <= cutbox_pos.y ){
     dc7:	a1 28 53 02 00       	mov    0x25328,%eax
     dcc:	ba 05 00 00 00       	mov    $0x5,%edx
     dd1:	29 d0                	sub    %edx,%eax
     dd3:	3b 45 0c             	cmp    0xc(%ebp),%eax
     dd6:	7f 11                	jg     de9 <isMouseInCutBoxUp+0x4f>
     dd8:	a1 28 53 02 00       	mov    0x25328,%eax
     ddd:	3b 45 0c             	cmp    0xc(%ebp),%eax
     de0:	7c 07                	jl     de9 <isMouseInCutBoxUp+0x4f>
        return 1;
     de2:	b8 01 00 00 00       	mov    $0x1,%eax
     de7:	eb 05                	jmp    dee <isMouseInCutBoxUp+0x54>
   }
   else {
        return 0;
     de9:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     dee:	5d                   	pop    %ebp
     def:	c3                   	ret    

00000df0 <isMouseInCutBoxDown>:

int isMouseInCutBoxDown(int x, int y) {
     df0:	55                   	push   %ebp
     df1:	89 e5                	mov    %esp,%ebp
   if (cutbox_pos.x + cut_box_dash_corner_width <= x && x <= cutbox_pos.x + cutbox_size.w - cut_box_dash_corner_width
     df3:	a1 24 53 02 00       	mov    0x25324,%eax
     df8:	ba 0a 00 00 00       	mov    $0xa,%edx
     dfd:	01 d0                	add    %edx,%eax
     dff:	3b 45 08             	cmp    0x8(%ebp),%eax
     e02:	7f 4b                	jg     e4f <isMouseInCutBoxDown+0x5f>
     e04:	8b 15 24 53 02 00    	mov    0x25324,%edx
     e0a:	a1 18 53 02 00       	mov    0x25318,%eax
     e0f:	01 d0                	add    %edx,%eax
     e11:	ba 0a 00 00 00       	mov    $0xa,%edx
     e16:	29 d0                	sub    %edx,%eax
     e18:	3b 45 08             	cmp    0x8(%ebp),%eax
     e1b:	7c 32                	jl     e4f <isMouseInCutBoxDown+0x5f>
        && cutbox_pos.y + cutbox_size.h <= y && y <= cutbox_pos.y + cutbox_size.h + cut_box_dash_corner_height ){
     e1d:	8b 15 28 53 02 00    	mov    0x25328,%edx
     e23:	a1 14 53 02 00       	mov    0x25314,%eax
     e28:	01 d0                	add    %edx,%eax
     e2a:	3b 45 0c             	cmp    0xc(%ebp),%eax
     e2d:	7f 20                	jg     e4f <isMouseInCutBoxDown+0x5f>
     e2f:	8b 15 28 53 02 00    	mov    0x25328,%edx
     e35:	a1 14 53 02 00       	mov    0x25314,%eax
     e3a:	01 d0                	add    %edx,%eax
     e3c:	ba 05 00 00 00       	mov    $0x5,%edx
     e41:	01 d0                	add    %edx,%eax
     e43:	3b 45 0c             	cmp    0xc(%ebp),%eax
     e46:	7c 07                	jl     e4f <isMouseInCutBoxDown+0x5f>
        return 1;
     e48:	b8 01 00 00 00       	mov    $0x1,%eax
     e4d:	eb 05                	jmp    e54 <isMouseInCutBoxDown+0x64>
   }
   else {
        return 0;
     e4f:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     e54:	5d                   	pop    %ebp
     e55:	c3                   	ret    

00000e56 <isMouseInCutBoxConfirmButton>:

int isMouseInCutBoxConfirmButton(int x, int y) {
     e56:	55                   	push   %ebp
     e57:	89 e5                	mov    %esp,%ebp
   if (cutbox_pos.x + cutbox_size.w + cut_box_dash_corner_height <= x && x < cutbox_pos.x + cutbox_size.w + cut_box_dash_corner_height + cut_box_button_width
     e59:	8b 15 24 53 02 00    	mov    0x25324,%edx
     e5f:	a1 18 53 02 00       	mov    0x25318,%eax
     e64:	01 d0                	add    %edx,%eax
     e66:	ba 05 00 00 00       	mov    $0x5,%edx
     e6b:	01 d0                	add    %edx,%eax
     e6d:	3b 45 08             	cmp    0x8(%ebp),%eax
     e70:	7f 60                	jg     ed2 <isMouseInCutBoxConfirmButton+0x7c>
     e72:	8b 15 24 53 02 00    	mov    0x25324,%edx
     e78:	a1 18 53 02 00       	mov    0x25318,%eax
     e7d:	01 d0                	add    %edx,%eax
     e7f:	ba 05 00 00 00       	mov    $0x5,%edx
     e84:	01 d0                	add    %edx,%eax
     e86:	ba 14 00 00 00       	mov    $0x14,%edx
     e8b:	01 d0                	add    %edx,%eax
     e8d:	3b 45 08             	cmp    0x8(%ebp),%eax
     e90:	7e 40                	jle    ed2 <isMouseInCutBoxConfirmButton+0x7c>
        && cutbox_pos.y + cutbox_size.h + cut_box_dash_corner_height - cut_box_button_width <= y && y <= cutbox_pos.y + cutbox_size.h + cut_box_dash_corner_height ){
     e92:	8b 15 28 53 02 00    	mov    0x25328,%edx
     e98:	a1 14 53 02 00       	mov    0x25314,%eax
     e9d:	01 d0                	add    %edx,%eax
     e9f:	ba 05 00 00 00       	mov    $0x5,%edx
     ea4:	01 d0                	add    %edx,%eax
     ea6:	ba 14 00 00 00       	mov    $0x14,%edx
     eab:	29 d0                	sub    %edx,%eax
     ead:	3b 45 0c             	cmp    0xc(%ebp),%eax
     eb0:	7f 20                	jg     ed2 <isMouseInCutBoxConfirmButton+0x7c>
     eb2:	8b 15 28 53 02 00    	mov    0x25328,%edx
     eb8:	a1 14 53 02 00       	mov    0x25314,%eax
     ebd:	01 d0                	add    %edx,%eax
     ebf:	ba 05 00 00 00       	mov    $0x5,%edx
     ec4:	01 d0                	add    %edx,%eax
     ec6:	3b 45 0c             	cmp    0xc(%ebp),%eax
     ec9:	7c 07                	jl     ed2 <isMouseInCutBoxConfirmButton+0x7c>
        return 1;
     ecb:	b8 01 00 00 00       	mov    $0x1,%eax
     ed0:	eb 05                	jmp    ed7 <isMouseInCutBoxConfirmButton+0x81>
   }
   else {
        return 0;
     ed2:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     ed7:	5d                   	pop    %ebp
     ed8:	c3                   	ret    

00000ed9 <isCutBoxInContent>:

int isCutBoxInContent(int x, int y, int width, int height) {
     ed9:	55                   	push   %ebp
     eda:	89 e5                	mov    %esp,%ebp
   if ( content_pos.x <= x && x + width <= content_pos.x + content_size.w
     edc:	a1 1c 53 02 00       	mov    0x2531c,%eax
     ee1:	3b 45 08             	cmp    0x8(%ebp),%eax
     ee4:	7f 45                	jg     f2b <isCutBoxInContent+0x52>
     ee6:	8b 55 08             	mov    0x8(%ebp),%edx
     ee9:	8b 45 10             	mov    0x10(%ebp),%eax
     eec:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
     eef:	8b 15 1c 53 02 00    	mov    0x2531c,%edx
     ef5:	a1 10 53 02 00       	mov    0x25310,%eax
     efa:	01 d0                	add    %edx,%eax
     efc:	39 c1                	cmp    %eax,%ecx
     efe:	7f 2b                	jg     f2b <isCutBoxInContent+0x52>
        && content_pos.y <= y && y + height <= content_pos.y + content_size.h ){
     f00:	a1 20 53 02 00       	mov    0x25320,%eax
     f05:	3b 45 0c             	cmp    0xc(%ebp),%eax
     f08:	7f 21                	jg     f2b <isCutBoxInContent+0x52>
     f0a:	8b 55 0c             	mov    0xc(%ebp),%edx
     f0d:	8b 45 14             	mov    0x14(%ebp),%eax
     f10:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
     f13:	8b 15 20 53 02 00    	mov    0x25320,%edx
     f19:	a1 0c 53 02 00       	mov    0x2530c,%eax
     f1e:	01 d0                	add    %edx,%eax
     f20:	39 c1                	cmp    %eax,%ecx
     f22:	7f 07                	jg     f2b <isCutBoxInContent+0x52>
        return 1;
     f24:	b8 01 00 00 00       	mov    $0x1,%eax
     f29:	eb 05                	jmp    f30 <isCutBoxInContent+0x57>
   }
   else {
        return 0;
     f2b:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     f30:	5d                   	pop    %ebp
     f31:	c3                   	ret    

00000f32 <isMouseInContent>:

int isMouseInContent(int x, int y) {
     f32:	55                   	push   %ebp
     f33:	89 e5                	mov    %esp,%ebp
   if (140 + (500-content_size.w)/2 < x && x < 640-(500-content_size.w)/2 && 30 + (410-content_size.h)/2 < y && y < 440 - (410-content_size.h)/2){
     f35:	a1 10 53 02 00       	mov    0x25310,%eax
     f3a:	ba f4 01 00 00       	mov    $0x1f4,%edx
     f3f:	29 c2                	sub    %eax,%edx
     f41:	89 d0                	mov    %edx,%eax
     f43:	89 c2                	mov    %eax,%edx
     f45:	c1 ea 1f             	shr    $0x1f,%edx
     f48:	01 d0                	add    %edx,%eax
     f4a:	d1 f8                	sar    %eax
     f4c:	05 8c 00 00 00       	add    $0x8c,%eax
     f51:	3b 45 08             	cmp    0x8(%ebp),%eax
     f54:	7d 70                	jge    fc6 <isMouseInContent+0x94>
     f56:	a1 10 53 02 00       	mov    0x25310,%eax
     f5b:	ba f4 01 00 00       	mov    $0x1f4,%edx
     f60:	29 c2                	sub    %eax,%edx
     f62:	89 d0                	mov    %edx,%eax
     f64:	89 c2                	mov    %eax,%edx
     f66:	c1 ea 1f             	shr    $0x1f,%edx
     f69:	01 d0                	add    %edx,%eax
     f6b:	d1 f8                	sar    %eax
     f6d:	ba 80 02 00 00       	mov    $0x280,%edx
     f72:	29 c2                	sub    %eax,%edx
     f74:	89 d0                	mov    %edx,%eax
     f76:	3b 45 08             	cmp    0x8(%ebp),%eax
     f79:	7e 4b                	jle    fc6 <isMouseInContent+0x94>
     f7b:	a1 0c 53 02 00       	mov    0x2530c,%eax
     f80:	ba 9a 01 00 00       	mov    $0x19a,%edx
     f85:	29 c2                	sub    %eax,%edx
     f87:	89 d0                	mov    %edx,%eax
     f89:	89 c2                	mov    %eax,%edx
     f8b:	c1 ea 1f             	shr    $0x1f,%edx
     f8e:	01 d0                	add    %edx,%eax
     f90:	d1 f8                	sar    %eax
     f92:	83 c0 1e             	add    $0x1e,%eax
     f95:	3b 45 0c             	cmp    0xc(%ebp),%eax
     f98:	7d 2c                	jge    fc6 <isMouseInContent+0x94>
     f9a:	a1 0c 53 02 00       	mov    0x2530c,%eax
     f9f:	ba 9a 01 00 00       	mov    $0x19a,%edx
     fa4:	29 c2                	sub    %eax,%edx
     fa6:	89 d0                	mov    %edx,%eax
     fa8:	89 c2                	mov    %eax,%edx
     faa:	c1 ea 1f             	shr    $0x1f,%edx
     fad:	01 d0                	add    %edx,%eax
     faf:	d1 f8                	sar    %eax
     fb1:	ba b8 01 00 00       	mov    $0x1b8,%edx
     fb6:	29 c2                	sub    %eax,%edx
     fb8:	89 d0                	mov    %edx,%eax
     fba:	3b 45 0c             	cmp    0xc(%ebp),%eax
     fbd:	7e 07                	jle    fc6 <isMouseInContent+0x94>
       return 1;
     fbf:	b8 01 00 00 00       	mov    $0x1,%eax
     fc4:	eb 05                	jmp    fcb <isMouseInContent+0x99>
   }
   else {
        return 0;
     fc6:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
     fcb:	5d                   	pop    %ebp
     fcc:	c3                   	ret    

00000fcd <isMouseInPencilColorButton>:

int isMouseInPencilColorButton(int x, int y) {
     fcd:	55                   	push   %ebp
     fce:	89 e5                	mov    %esp,%ebp
    if (555 <= x && x <= 575 && 5 <= y && y <= 25){
     fd0:	81 7d 08 2a 02 00 00 	cmpl   $0x22a,0x8(%ebp)
     fd7:	7e 34                	jle    100d <isMouseInPencilColorButton+0x40>
     fd9:	81 7d 08 3f 02 00 00 	cmpl   $0x23f,0x8(%ebp)
     fe0:	7f 2b                	jg     100d <isMouseInPencilColorButton+0x40>
     fe2:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
     fe6:	7e 25                	jle    100d <isMouseInPencilColorButton+0x40>
     fe8:	83 7d 0c 19          	cmpl   $0x19,0xc(%ebp)
     fec:	7f 1f                	jg     100d <isMouseInPencilColorButton+0x40>
        pencil_color = (RGB){0,0,255};
     fee:	c6 05 d5 52 02 00 00 	movb   $0x0,0x252d5
     ff5:	c6 05 d6 52 02 00 00 	movb   $0x0,0x252d6
     ffc:	c6 05 d7 52 02 00 ff 	movb   $0xff,0x252d7
        return 1;
    1003:	b8 01 00 00 00       	mov    $0x1,%eax
    1008:	e9 b3 00 00 00       	jmp    10c0 <isMouseInPencilColorButton+0xf3>
    }
    else if(525 <= x && x <= 545 && 5 <= y && y <= 25)
    100d:	81 7d 08 0c 02 00 00 	cmpl   $0x20c,0x8(%ebp)
    1014:	7e 31                	jle    1047 <isMouseInPencilColorButton+0x7a>
    1016:	81 7d 08 21 02 00 00 	cmpl   $0x221,0x8(%ebp)
    101d:	7f 28                	jg     1047 <isMouseInPencilColorButton+0x7a>
    101f:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    1023:	7e 22                	jle    1047 <isMouseInPencilColorButton+0x7a>
    1025:	83 7d 0c 19          	cmpl   $0x19,0xc(%ebp)
    1029:	7f 1c                	jg     1047 <isMouseInPencilColorButton+0x7a>
    {
        pencil_color = (RGB){0,255,0};
    102b:	c6 05 d5 52 02 00 00 	movb   $0x0,0x252d5
    1032:	c6 05 d6 52 02 00 ff 	movb   $0xff,0x252d6
    1039:	c6 05 d7 52 02 00 00 	movb   $0x0,0x252d7
        return 1;
    1040:	b8 01 00 00 00       	mov    $0x1,%eax
    1045:	eb 79                	jmp    10c0 <isMouseInPencilColorButton+0xf3>
    }
    else if(495 <= x && x <= 515 && 5 <= y && y <= 25)
    1047:	81 7d 08 ee 01 00 00 	cmpl   $0x1ee,0x8(%ebp)
    104e:	7e 31                	jle    1081 <isMouseInPencilColorButton+0xb4>
    1050:	81 7d 08 03 02 00 00 	cmpl   $0x203,0x8(%ebp)
    1057:	7f 28                	jg     1081 <isMouseInPencilColorButton+0xb4>
    1059:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    105d:	7e 22                	jle    1081 <isMouseInPencilColorButton+0xb4>
    105f:	83 7d 0c 19          	cmpl   $0x19,0xc(%ebp)
    1063:	7f 1c                	jg     1081 <isMouseInPencilColorButton+0xb4>
    {
        pencil_color = (RGB){255,0,0};
    1065:	c6 05 d5 52 02 00 ff 	movb   $0xff,0x252d5
    106c:	c6 05 d6 52 02 00 00 	movb   $0x0,0x252d6
    1073:	c6 05 d7 52 02 00 00 	movb   $0x0,0x252d7
        return 1;
    107a:	b8 01 00 00 00       	mov    $0x1,%eax
    107f:	eb 3f                	jmp    10c0 <isMouseInPencilColorButton+0xf3>
    }
    else if(465 <= x && x <= 485 && 5 <= y && y <= 25)
    1081:	81 7d 08 d0 01 00 00 	cmpl   $0x1d0,0x8(%ebp)
    1088:	7e 31                	jle    10bb <isMouseInPencilColorButton+0xee>
    108a:	81 7d 08 e5 01 00 00 	cmpl   $0x1e5,0x8(%ebp)
    1091:	7f 28                	jg     10bb <isMouseInPencilColorButton+0xee>
    1093:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    1097:	7e 22                	jle    10bb <isMouseInPencilColorButton+0xee>
    1099:	83 7d 0c 19          	cmpl   $0x19,0xc(%ebp)
    109d:	7f 1c                	jg     10bb <isMouseInPencilColorButton+0xee>
    {
        pencil_color = (RGB){128,0,128};
    109f:	c6 05 d5 52 02 00 80 	movb   $0x80,0x252d5
    10a6:	c6 05 d6 52 02 00 00 	movb   $0x0,0x252d6
    10ad:	c6 05 d7 52 02 00 80 	movb   $0x80,0x252d7
        return 1;
    10b4:	b8 01 00 00 00       	mov    $0x1,%eax
    10b9:	eb 05                	jmp    10c0 <isMouseInPencilColorButton+0xf3>
    }
    else {
        return 0;
    10bb:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
    10c0:	5d                   	pop    %ebp
    10c1:	c3                   	ret    

000010c2 <isMouseInRubberButton>:

int isMouseInRubberButton(int x, int y) {
    10c2:	55                   	push   %ebp
    10c3:	89 e5                	mov    %esp,%ebp
   if (610 < x && x <= 640 && 0 <= y && y <= 30){
    10c5:	81 7d 08 62 02 00 00 	cmpl   $0x262,0x8(%ebp)
    10cc:	7e 5a                	jle    1128 <isMouseInRubberButton+0x66>
    10ce:	81 7d 08 80 02 00 00 	cmpl   $0x280,0x8(%ebp)
    10d5:	7f 51                	jg     1128 <isMouseInRubberButton+0x66>
    10d7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    10db:	78 4b                	js     1128 <isMouseInRubberButton+0x66>
    10dd:	83 7d 0c 1e          	cmpl   $0x1e,0xc(%ebp)
    10e1:	7f 45                	jg     1128 <isMouseInRubberButton+0x66>
        pencil_color = (RGB){255,255,255};
    10e3:	c6 05 d5 52 02 00 ff 	movb   $0xff,0x252d5
    10ea:	c6 05 d6 52 02 00 ff 	movb   $0xff,0x252d6
    10f1:	c6 05 d7 52 02 00 ff 	movb   $0xff,0x252d7
        if(is_rubber == 0) is_rubber = 1;
    10f8:	a1 98 57 02 00       	mov    0x25798,%eax
    10fd:	85 c0                	test   %eax,%eax
    10ff:	75 0c                	jne    110d <isMouseInRubberButton+0x4b>
    1101:	c7 05 98 57 02 00 01 	movl   $0x1,0x25798
    1108:	00 00 00 
    110b:	eb 14                	jmp    1121 <isMouseInRubberButton+0x5f>
        else if(is_rubber == 1) is_rubber = 0;
    110d:	a1 98 57 02 00       	mov    0x25798,%eax
    1112:	83 f8 01             	cmp    $0x1,%eax
    1115:	75 0a                	jne    1121 <isMouseInRubberButton+0x5f>
    1117:	c7 05 98 57 02 00 00 	movl   $0x0,0x25798
    111e:	00 00 00 
        return 1;
    1121:	b8 01 00 00 00       	mov    $0x1,%eax
    1126:	eb 05                	jmp    112d <isMouseInRubberButton+0x6b>
   }
   else {
        return 0;
    1128:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    112d:	5d                   	pop    %ebp
    112e:	c3                   	ret    

0000112f <isMouseInPencilButton>:

int isMouseInPencilButton(int x, int y) {
    112f:	55                   	push   %ebp
    1130:	89 e5                	mov    %esp,%ebp
   if (580 <= x && x <= 610 && 0 <= y && y <= 30){
    1132:	81 7d 08 43 02 00 00 	cmpl   $0x243,0x8(%ebp)
    1139:	7e 5a                	jle    1195 <isMouseInPencilButton+0x66>
    113b:	81 7d 08 62 02 00 00 	cmpl   $0x262,0x8(%ebp)
    1142:	7f 51                	jg     1195 <isMouseInPencilButton+0x66>
    1144:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1148:	78 4b                	js     1195 <isMouseInPencilButton+0x66>
    114a:	83 7d 0c 1e          	cmpl   $0x1e,0xc(%ebp)
    114e:	7f 45                	jg     1195 <isMouseInPencilButton+0x66>
        pencil_color = (RGB){0,0,255};
    1150:	c6 05 d5 52 02 00 00 	movb   $0x0,0x252d5
    1157:	c6 05 d6 52 02 00 00 	movb   $0x0,0x252d6
    115e:	c6 05 d7 52 02 00 ff 	movb   $0xff,0x252d7
        if(is_pencil == 0) is_pencil = 1;
    1165:	a1 94 57 02 00       	mov    0x25794,%eax
    116a:	85 c0                	test   %eax,%eax
    116c:	75 0c                	jne    117a <isMouseInPencilButton+0x4b>
    116e:	c7 05 94 57 02 00 01 	movl   $0x1,0x25794
    1175:	00 00 00 
    1178:	eb 14                	jmp    118e <isMouseInPencilButton+0x5f>
        else if(is_pencil == 1) is_pencil = 0;
    117a:	a1 94 57 02 00       	mov    0x25794,%eax
    117f:	83 f8 01             	cmp    $0x1,%eax
    1182:	75 0a                	jne    118e <isMouseInPencilButton+0x5f>
    1184:	c7 05 94 57 02 00 00 	movl   $0x0,0x25794
    118b:	00 00 00 
        return 1;
    118e:	b8 01 00 00 00       	mov    $0x1,%eax
    1193:	eb 05                	jmp    119a <isMouseInPencilButton+0x6b>
   }
   else {
        return 0;
    1195:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    119a:	5d                   	pop    %ebp
    119b:	c3                   	ret    

0000119c <isMouseInSaveButton>:

int isMouseInSaveButton(int x, int y) {
    119c:	55                   	push   %ebp
    119d:	89 e5                	mov    %esp,%ebp
    119f:	53                   	push   %ebx
    11a0:	81 ec a4 00 00 00    	sub    $0xa4,%esp
   if (0 <= x && x <= 30 && 0 <= y && y <= 30){
    11a6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    11aa:	0f 88 be 03 00 00    	js     156e <isMouseInSaveButton+0x3d2>
    11b0:	83 7d 08 1e          	cmpl   $0x1e,0x8(%ebp)
    11b4:	0f 8f b4 03 00 00    	jg     156e <isMouseInSaveButton+0x3d2>
    11ba:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    11be:	0f 88 aa 03 00 00    	js     156e <isMouseInSaveButton+0x3d2>
    11c4:	83 7d 0c 1e          	cmpl   $0x1e,0xc(%ebp)
    11c8:	0f 8f a0 03 00 00    	jg     156e <isMouseInSaveButton+0x3d2>
        struct RGB *t;
        struct RGB *o;
        printf(1, "Save begin.\n");
    11ce:	83 ec 08             	sub    $0x8,%esp
    11d1:	68 f3 c7 01 00       	push   $0x1c7f3
    11d6:	6a 01                	push   $0x1
    11d8:	e8 0d 5c 00 00       	call   6dea <printf>
    11dd:	83 c4 10             	add    $0x10,%esp
        edit_img = malloc(content_size.h*content_size.w*3);
    11e0:	8b 15 0c 53 02 00    	mov    0x2530c,%edx
    11e6:	a1 10 53 02 00       	mov    0x25310,%eax
    11eb:	0f af d0             	imul   %eax,%edx
    11ee:	89 d0                	mov    %edx,%eax
    11f0:	01 c0                	add    %eax,%eax
    11f2:	01 d0                	add    %edx,%eax
    11f4:	83 ec 0c             	sub    $0xc,%esp
    11f7:	50                   	push   %eax
    11f8:	e8 c0 5e 00 00       	call   70bd <malloc>
    11fd:	83 c4 10             	add    $0x10,%esp
    1200:	a3 68 58 02 00       	mov    %eax,0x25868
        int max_line = content_size.w;
    1205:	a1 10 53 02 00       	mov    0x25310,%eax
    120a:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (int i = 0; i < content_size.h; i++) {
    120d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1214:	eb 68                	jmp    127e <isMouseInSaveButton+0xe2>
            o = wnd.content + (content_pos.y + i) * wnd.size.w + content_pos.x;
    1216:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    121c:	8b 15 20 53 02 00    	mov    0x25320,%edx
    1222:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1225:	01 c2                	add    %eax,%edx
    1227:	a1 b0 58 02 00       	mov    0x258b0,%eax
    122c:	0f af c2             	imul   %edx,%eax
    122f:	89 c2                	mov    %eax,%edx
    1231:	a1 1c 53 02 00       	mov    0x2531c,%eax
    1236:	01 c2                	add    %eax,%edx
    1238:	89 d0                	mov    %edx,%eax
    123a:	01 c0                	add    %eax,%eax
    123c:	01 d0                	add    %edx,%eax
    123e:	01 c8                	add    %ecx,%eax
    1240:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            t = edit_img + i * content_size.w;
    1243:	8b 15 68 58 02 00    	mov    0x25868,%edx
    1249:	a1 10 53 02 00       	mov    0x25310,%eax
    124e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    1252:	89 c1                	mov    %eax,%ecx
    1254:	89 c8                	mov    %ecx,%eax
    1256:	01 c0                	add    %eax,%eax
    1258:	01 c8                	add    %ecx,%eax
    125a:	01 d0                	add    %edx,%eax
    125c:	89 45 d0             	mov    %eax,-0x30(%ebp)
            memmove(t, o, max_line * 3);
    125f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    1262:	89 d0                	mov    %edx,%eax
    1264:	01 c0                	add    %eax,%eax
    1266:	01 d0                	add    %edx,%eax
    1268:	83 ec 04             	sub    $0x4,%esp
    126b:	50                   	push   %eax
    126c:	ff 75 d4             	pushl  -0x2c(%ebp)
    126f:	ff 75 d0             	pushl  -0x30(%ebp)
    1272:	e8 87 59 00 00       	call   6bfe <memmove>
    1277:	83 c4 10             	add    $0x10,%esp
        struct RGB *t;
        struct RGB *o;
        printf(1, "Save begin.\n");
        edit_img = malloc(content_size.h*content_size.w*3);
        int max_line = content_size.w;
        for (int i = 0; i < content_size.h; i++) {
    127a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    127e:	a1 0c 53 02 00       	mov    0x2530c,%eax
    1283:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1286:	7f 8e                	jg     1216 <isMouseInSaveButton+0x7a>
            o = wnd.content + (content_pos.y + i) * wnd.size.w + content_pos.x;
            t = edit_img + i * content_size.w;
            memmove(t, o, max_line * 3);
        }
        image_show[image_item-1]->save_time=image_show[image_item-1]->save_time+1;
    1288:	a1 54 58 02 00       	mov    0x25854,%eax
    128d:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    1293:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    1299:	c1 e2 02             	shl    $0x2,%edx
    129c:	01 d0                	add    %edx,%eax
    129e:	8b 00                	mov    (%eax),%eax
    12a0:	8b 15 54 58 02 00    	mov    0x25854,%edx
    12a6:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    12ac:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    12b2:	c1 e1 02             	shl    $0x2,%ecx
    12b5:	01 ca                	add    %ecx,%edx
    12b7:	8b 12                	mov    (%edx),%edx
    12b9:	8b 52 30             	mov    0x30(%edx),%edx
    12bc:	83 c2 01             	add    $0x1,%edx
    12bf:	89 50 30             	mov    %edx,0x30(%eax)
        int filename_len = strlen(image_show[image_item-1]->image_name);
    12c2:	a1 54 58 02 00       	mov    0x25854,%eax
    12c7:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    12cd:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    12d3:	c1 e2 02             	shl    $0x2,%edx
    12d6:	01 d0                	add    %edx,%eax
    12d8:	8b 00                	mov    (%eax),%eax
    12da:	8b 00                	mov    (%eax),%eax
    12dc:	83 ec 0c             	sub    $0xc,%esp
    12df:	50                   	push   %eax
    12e0:	e8 9c 57 00 00       	call   6a81 <strlen>
    12e5:	83 c4 10             	add    $0x10,%esp
    12e8:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int filetype_len = strlen(image_show[image_item-1]->image_type);
    12eb:	a1 54 58 02 00       	mov    0x25854,%eax
    12f0:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    12f6:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    12fc:	c1 e2 02             	shl    $0x2,%edx
    12ff:	01 d0                	add    %edx,%eax
    1301:	8b 00                	mov    (%eax),%eax
    1303:	8b 40 04             	mov    0x4(%eax),%eax
    1306:	83 ec 0c             	sub    $0xc,%esp
    1309:	50                   	push   %eax
    130a:	e8 72 57 00 00       	call   6a81 <strlen>
    130f:	83 c4 10             	add    $0x10,%esp
    1312:	89 45 c8             	mov    %eax,-0x38(%ebp)
        char* save_filename;
        save_filename=malloc(sizeof(char)*(filename_len+10));
    1315:	8b 45 cc             	mov    -0x34(%ebp),%eax
    1318:	83 c0 0a             	add    $0xa,%eax
    131b:	83 ec 0c             	sub    $0xc,%esp
    131e:	50                   	push   %eax
    131f:	e8 99 5d 00 00       	call   70bd <malloc>
    1324:	83 c4 10             	add    $0x10,%esp
    1327:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        for(int i=0;i<filename_len-filetype_len-1;i++)
    132a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1331:	eb 30                	jmp    1363 <isMouseInSaveButton+0x1c7>
        {
            save_filename[i]=image_show[image_item-1]->image_name[i];
    1333:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1336:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    1339:	01 c2                	add    %eax,%edx
    133b:	a1 54 58 02 00       	mov    0x25854,%eax
    1340:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    1346:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    134c:	c1 e1 02             	shl    $0x2,%ecx
    134f:	01 c8                	add    %ecx,%eax
    1351:	8b 00                	mov    (%eax),%eax
    1353:	8b 08                	mov    (%eax),%ecx
    1355:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1358:	01 c8                	add    %ecx,%eax
    135a:	0f b6 00             	movzbl (%eax),%eax
    135d:	88 02                	mov    %al,(%edx)
        image_show[image_item-1]->save_time=image_show[image_item-1]->save_time+1;
        int filename_len = strlen(image_show[image_item-1]->image_name);
        int filetype_len = strlen(image_show[image_item-1]->image_type);
        char* save_filename;
        save_filename=malloc(sizeof(char)*(filename_len+10));
        for(int i=0;i<filename_len-filetype_len-1;i++)
    135f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1363:	8b 45 cc             	mov    -0x34(%ebp),%eax
    1366:	2b 45 c8             	sub    -0x38(%ebp),%eax
    1369:	83 e8 01             	sub    $0x1,%eax
    136c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    136f:	7f c2                	jg     1333 <isMouseInSaveButton+0x197>
        {
            save_filename[i]=image_show[image_item-1]->image_name[i];
        }
        save_filename[filename_len-filetype_len-1]='-';
    1371:	8b 45 cc             	mov    -0x34(%ebp),%eax
    1374:	2b 45 c8             	sub    -0x38(%ebp),%eax
    1377:	8d 50 ff             	lea    -0x1(%eax),%edx
    137a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    137d:	01 d0                	add    %edx,%eax
    137f:	c6 00 2d             	movb   $0x2d,(%eax)
        save_filename[filename_len-filetype_len]='v';
    1382:	8b 45 cc             	mov    -0x34(%ebp),%eax
    1385:	2b 45 c8             	sub    -0x38(%ebp),%eax
    1388:	89 c2                	mov    %eax,%edx
    138a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    138d:	01 d0                	add    %edx,%eax
    138f:	c6 00 76             	movb   $0x76,(%eax)
        char s[100];
        int k=0;
    1392:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        int save_time_tem=image_show[image_item-1]->save_time;
    1399:	a1 54 58 02 00       	mov    0x25854,%eax
    139e:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    13a4:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    13aa:	c1 e2 02             	shl    $0x2,%edx
    13ad:	01 d0                	add    %edx,%eax
    13af:	8b 00                	mov    (%eax),%eax
    13b1:	8b 40 30             	mov    0x30(%eax),%eax
    13b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        do{
           s[k++]=save_time_tem%10+'0';
    13b7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    13ba:	8d 43 01             	lea    0x1(%ebx),%eax
    13bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    13c0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    13c3:	ba 67 66 66 66       	mov    $0x66666667,%edx
    13c8:	89 c8                	mov    %ecx,%eax
    13ca:	f7 ea                	imul   %edx
    13cc:	c1 fa 02             	sar    $0x2,%edx
    13cf:	89 c8                	mov    %ecx,%eax
    13d1:	c1 f8 1f             	sar    $0x1f,%eax
    13d4:	29 c2                	sub    %eax,%edx
    13d6:	89 d0                	mov    %edx,%eax
    13d8:	c1 e0 02             	shl    $0x2,%eax
    13db:	01 d0                	add    %edx,%eax
    13dd:	01 c0                	add    %eax,%eax
    13df:	29 c1                	sub    %eax,%ecx
    13e1:	89 ca                	mov    %ecx,%edx
    13e3:	89 d0                	mov    %edx,%eax
    13e5:	83 c0 30             	add    $0x30,%eax
    13e8:	88 84 1d 60 ff ff ff 	mov    %al,-0xa0(%ebp,%ebx,1)
        }
        while ((save_time_tem/=10)>0);
    13ef:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    13f2:	ba 67 66 66 66       	mov    $0x66666667,%edx
    13f7:	89 c8                	mov    %ecx,%eax
    13f9:	f7 ea                	imul   %edx
    13fb:	c1 fa 02             	sar    $0x2,%edx
    13fe:	89 c8                	mov    %ecx,%eax
    1400:	c1 f8 1f             	sar    $0x1f,%eax
    1403:	29 c2                	sub    %eax,%edx
    1405:	89 d0                	mov    %edx,%eax
    1407:	89 45 e8             	mov    %eax,-0x18(%ebp)
    140a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    140e:	7f a7                	jg     13b7 <isMouseInSaveButton+0x21b>
        s[k]='.';
    1410:	8d 95 60 ff ff ff    	lea    -0xa0(%ebp),%edx
    1416:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1419:	01 d0                	add    %edx,%eax
    141b:	c6 00 2e             	movb   $0x2e,(%eax)
        int index = filename_len-filetype_len+1;
    141e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    1421:	2b 45 c8             	sub    -0x38(%ebp),%eax
    1424:	83 c0 01             	add    $0x1,%eax
    1427:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        for(int j=k-1;j>=0;j--)
    142a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    142d:	83 e8 01             	sub    $0x1,%eax
    1430:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1433:	eb 20                	jmp    1455 <isMouseInSaveButton+0x2b9>
        {
            save_filename[index] = s[j];
    1435:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1438:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    143b:	01 c2                	add    %eax,%edx
    143d:	8d 8d 60 ff ff ff    	lea    -0xa0(%ebp),%ecx
    1443:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1446:	01 c8                	add    %ecx,%eax
    1448:	0f b6 00             	movzbl (%eax),%eax
    144b:	88 02                	mov    %al,(%edx)
            index++;
    144d:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
           s[k++]=save_time_tem%10+'0';
        }
        while ((save_time_tem/=10)>0);
        s[k]='.';
        int index = filename_len-filetype_len+1;
        for(int j=k-1;j>=0;j--)
    1451:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    1455:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    1459:	79 da                	jns    1435 <isMouseInSaveButton+0x299>
        {
            save_filename[index] = s[j];
            index++;
        }
        save_filename[index]='.';
    145b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    145e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    1461:	01 d0                	add    %edx,%eax
    1463:	c6 00 2e             	movb   $0x2e,(%eax)
        index++;
    1466:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        for(int i=index;i<index+filetype_len;i++)
    146a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    146d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1470:	eb 34                	jmp    14a6 <isMouseInSaveButton+0x30a>
        {
            save_filename[i]=image_show[image_item-1]->image_type[i-index];
    1472:	8b 55 dc             	mov    -0x24(%ebp),%edx
    1475:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    1478:	01 c2                	add    %eax,%edx
    147a:	a1 54 58 02 00       	mov    0x25854,%eax
    147f:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    1485:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    148b:	c1 e1 02             	shl    $0x2,%ecx
    148e:	01 c8                	add    %ecx,%eax
    1490:	8b 00                	mov    (%eax),%eax
    1492:	8b 48 04             	mov    0x4(%eax),%ecx
    1495:	8b 45 dc             	mov    -0x24(%ebp),%eax
    1498:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    149b:	01 c8                	add    %ecx,%eax
    149d:	0f b6 00             	movzbl (%eax),%eax
    14a0:	88 02                	mov    %al,(%edx)
            save_filename[index] = s[j];
            index++;
        }
        save_filename[index]='.';
        index++;
        for(int i=index;i<index+filetype_len;i++)
    14a2:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    14a6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    14a9:	8b 45 c8             	mov    -0x38(%ebp),%eax
    14ac:	01 d0                	add    %edx,%eax
    14ae:	3b 45 dc             	cmp    -0x24(%ebp),%eax
    14b1:	7f bf                	jg     1472 <isMouseInSaveButton+0x2d6>
        {
            save_filename[i]=image_show[image_item-1]->image_type[i-index];
        }
        save_filename[index+filetype_len]='\0';
    14b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    14b6:	8b 45 c8             	mov    -0x38(%ebp),%eax
    14b9:	01 d0                	add    %edx,%eax
    14bb:	89 c2                	mov    %eax,%edx
    14bd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    14c0:	01 d0                	add    %edx,%eax
    14c2:	c6 00 00             	movb   $0x0,(%eax)
        //printf(1, "%d %s %s %s %d %d\n", image_show[image_item-1]->save_time, save_filename, image_show[image_item-1]->image_name, image_show[image_item-1]->image_type, filename_len, filetype_len);
        write24BitmapFile(save_filename, edit_img, content_size.h, content_size.w);
    14c5:	8b 0d 10 53 02 00    	mov    0x25310,%ecx
    14cb:	8b 15 0c 53 02 00    	mov    0x2530c,%edx
    14d1:	a1 68 58 02 00       	mov    0x25868,%eax
    14d6:	51                   	push   %ecx
    14d7:	52                   	push   %edx
    14d8:	50                   	push   %eax
    14d9:	ff 75 c4             	pushl  -0x3c(%ebp)
    14dc:	e8 42 65 00 00       	call   7a23 <write24BitmapFile>
    14e1:	83 c4 10             	add    $0x10,%esp
        printf(1, "Save succeed.\n");
    14e4:	83 ec 08             	sub    $0x8,%esp
    14e7:	68 00 c8 01 00       	push   $0x1c800
    14ec:	6a 01                	push   $0x1
    14ee:	e8 f7 58 00 00       	call   6dea <printf>
    14f3:	83 c4 10             	add    $0x10,%esp
        ImageListAppend(save_filename, content_size.h*content_size.w*3, strlen(save_filename), image_list, "bmp", 3);
    14f6:	8b 1d 74 58 02 00    	mov    0x25874,%ebx
    14fc:	83 ec 0c             	sub    $0xc,%esp
    14ff:	ff 75 c4             	pushl  -0x3c(%ebp)
    1502:	e8 7a 55 00 00       	call   6a81 <strlen>
    1507:	83 c4 10             	add    $0x10,%esp
    150a:	89 c1                	mov    %eax,%ecx
    150c:	8b 15 0c 53 02 00    	mov    0x2530c,%edx
    1512:	a1 10 53 02 00       	mov    0x25310,%eax
    1517:	0f af d0             	imul   %eax,%edx
    151a:	89 d0                	mov    %edx,%eax
    151c:	01 c0                	add    %eax,%eax
    151e:	01 d0                	add    %edx,%eax
    1520:	83 ec 08             	sub    $0x8,%esp
    1523:	6a 03                	push   $0x3
    1525:	68 0f c8 01 00       	push   $0x1c80f
    152a:	53                   	push   %ebx
    152b:	51                   	push   %ecx
    152c:	50                   	push   %eax
    152d:	ff 75 c4             	pushl  -0x3c(%ebp)
    1530:	e8 e4 ea ff ff       	call   19 <ImageListAppend>
    1535:	83 c4 20             	add    $0x20,%esp
        free(edit_img);
    1538:	a1 68 58 02 00       	mov    0x25868,%eax
    153d:	83 ec 0c             	sub    $0xc,%esp
    1540:	50                   	push   %eax
    1541:	e8 35 5a 00 00       	call   6f7b <free>
    1546:	83 c4 10             	add    $0x10,%esp
        free(save_filename);
    1549:	83 ec 0c             	sub    $0xc,%esp
    154c:	ff 75 c4             	pushl  -0x3c(%ebp)
    154f:	e8 27 5a 00 00       	call   6f7b <free>
    1554:	83 c4 10             	add    $0x10,%esp
        api_repaint(&wnd);
    1557:	83 ec 0c             	sub    $0xc,%esp
    155a:	68 a0 58 02 00       	push   $0x258a0
    155f:	e8 25 67 00 00       	call   7c89 <api_repaint>
    1564:	83 c4 10             	add    $0x10,%esp
        return 1;
    1567:	b8 01 00 00 00       	mov    $0x1,%eax
    156c:	eb 05                	jmp    1573 <isMouseInSaveButton+0x3d7>
   }
   else {
        return 0;
    156e:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    1573:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    1576:	c9                   	leave  
    1577:	c3                   	ret    

00001578 <drawCutBoxWidth>:

void drawCutBoxWidth(int y_corner, int y_dash, int width) {
    1578:	55                   	push   %ebp
    1579:	89 e5                	mov    %esp,%ebp
    157b:	81 ec 98 00 00 00    	sub    $0x98,%esp
    api_drawRect(&wnd, (Point) {cutbox_pos.x, y_corner}, (Size) {cut_box_dash_corner_height, cut_box_dash_corner_width}, cut_box_color);
    1581:	b8 05 00 00 00       	mov    $0x5,%eax
    1586:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
    158c:	b8 0a 00 00 00       	mov    $0xa,%eax
    1591:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
    1597:	a1 24 53 02 00       	mov    0x25324,%eax
    159c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
    15a2:	8b 45 08             	mov    0x8(%ebp),%eax
    15a5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
    15ab:	83 ec 08             	sub    $0x8,%esp
    15ae:	83 ec 04             	sub    $0x4,%esp
    15b1:	89 e0                	mov    %esp,%eax
    15b3:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    15ba:	66 89 10             	mov    %dx,(%eax)
    15bd:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    15c4:	88 50 02             	mov    %dl,0x2(%eax)
    15c7:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
    15cd:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
    15d3:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
    15d9:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
    15df:	68 a0 58 02 00       	push   $0x258a0
    15e4:	e8 4d 67 00 00       	call   7d36 <api_drawRect>
    15e9:	83 c4 20             	add    $0x20,%esp
    api_update(&wnd, (Rect){cutbox_pos.x, y_corner, cut_box_dash_corner_width, cut_box_dash_corner_height});
    15ec:	a1 24 53 02 00       	mov    0x25324,%eax
    15f1:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
    15f7:	8b 45 08             	mov    0x8(%ebp),%eax
    15fa:	89 45 80             	mov    %eax,-0x80(%ebp)
    15fd:	b8 0a 00 00 00       	mov    $0xa,%eax
    1602:	89 45 84             	mov    %eax,-0x7c(%ebp)
    1605:	b8 05 00 00 00       	mov    $0x5,%eax
    160a:	89 45 88             	mov    %eax,-0x78(%ebp)
    160d:	83 ec 0c             	sub    $0xc,%esp
    1610:	ff 75 88             	pushl  -0x78(%ebp)
    1613:	ff 75 84             	pushl  -0x7c(%ebp)
    1616:	ff 75 80             	pushl  -0x80(%ebp)
    1619:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
    161f:	68 a0 58 02 00       	push   $0x258a0
    1624:	e8 7e 66 00 00       	call   7ca7 <api_update>
    1629:	83 c4 20             	add    $0x20,%esp
    int image_width = width - cut_box_dash_corner_width*2 - cut_box_dash_width*2;
    162c:	b8 0a 00 00 00       	mov    $0xa,%eax
    1631:	8d 14 00             	lea    (%eax,%eax,1),%edx
    1634:	8b 45 10             	mov    0x10(%ebp),%eax
    1637:	29 d0                	sub    %edx,%eax
    1639:	89 c2                	mov    %eax,%edx
    163b:	b8 06 00 00 00       	mov    $0x6,%eax
    1640:	01 c0                	add    %eax,%eax
    1642:	29 c2                	sub    %eax,%edx
    1644:	89 d0                	mov    %edx,%eax
    1646:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(image_width > 0)
    1649:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    164d:	0f 8e da 01 00 00    	jle    182d <drawCutBoxWidth+0x2b5>
    {
        int cut_box_width = image_width / cut_box_dash_width;
    1653:	b9 06 00 00 00       	mov    $0x6,%ecx
    1658:	8b 45 f0             	mov    -0x10(%ebp),%eax
    165b:	99                   	cltd   
    165c:	f7 f9                	idiv   %ecx
    165e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int i=0;i<cut_box_width;i++)
    1661:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1668:	e9 d1 00 00 00       	jmp    173e <drawCutBoxWidth+0x1c6>
        {
            if(i%2==0)
    166d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1670:	83 e0 01             	and    $0x1,%eax
    1673:	85 c0                	test   %eax,%eax
    1675:	0f 85 bf 00 00 00    	jne    173a <drawCutBoxWidth+0x1c2>
            {
                api_drawRect(&wnd, (Point) {cutbox_pos.x+cut_box_dash_corner_width+cut_box_dash_width+i*cut_box_dash_width, y_dash}, (Size) {cut_box_dash_height, cut_box_dash_width}, cut_box_color);
    167b:	b8 02 00 00 00       	mov    $0x2,%eax
    1680:	89 45 8c             	mov    %eax,-0x74(%ebp)
    1683:	b8 06 00 00 00       	mov    $0x6,%eax
    1688:	89 45 90             	mov    %eax,-0x70(%ebp)
    168b:	a1 24 53 02 00       	mov    0x25324,%eax
    1690:	ba 0a 00 00 00       	mov    $0xa,%edx
    1695:	01 d0                	add    %edx,%eax
    1697:	ba 06 00 00 00       	mov    $0x6,%edx
    169c:	01 c2                	add    %eax,%edx
    169e:	b8 06 00 00 00       	mov    $0x6,%eax
    16a3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    16a7:	01 d0                	add    %edx,%eax
    16a9:	89 45 94             	mov    %eax,-0x6c(%ebp)
    16ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    16af:	89 45 98             	mov    %eax,-0x68(%ebp)
    16b2:	83 ec 08             	sub    $0x8,%esp
    16b5:	83 ec 04             	sub    $0x4,%esp
    16b8:	89 e0                	mov    %esp,%eax
    16ba:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    16c1:	66 89 10             	mov    %dx,(%eax)
    16c4:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    16cb:	88 50 02             	mov    %dl,0x2(%eax)
    16ce:	ff 75 90             	pushl  -0x70(%ebp)
    16d1:	ff 75 8c             	pushl  -0x74(%ebp)
    16d4:	ff 75 98             	pushl  -0x68(%ebp)
    16d7:	ff 75 94             	pushl  -0x6c(%ebp)
    16da:	68 a0 58 02 00       	push   $0x258a0
    16df:	e8 52 66 00 00       	call   7d36 <api_drawRect>
    16e4:	83 c4 20             	add    $0x20,%esp
                api_update(&wnd, (Rect){cutbox_pos.x+cut_box_dash_corner_width+cut_box_dash_width+i*cut_box_dash_width, y_dash, cut_box_dash_width, cut_box_dash_height});
    16e7:	a1 24 53 02 00       	mov    0x25324,%eax
    16ec:	ba 0a 00 00 00       	mov    $0xa,%edx
    16f1:	01 d0                	add    %edx,%eax
    16f3:	ba 06 00 00 00       	mov    $0x6,%edx
    16f8:	01 c2                	add    %eax,%edx
    16fa:	b8 06 00 00 00       	mov    $0x6,%eax
    16ff:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    1703:	01 d0                	add    %edx,%eax
    1705:	89 45 9c             	mov    %eax,-0x64(%ebp)
    1708:	8b 45 0c             	mov    0xc(%ebp),%eax
    170b:	89 45 a0             	mov    %eax,-0x60(%ebp)
    170e:	b8 06 00 00 00       	mov    $0x6,%eax
    1713:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    1716:	b8 02 00 00 00       	mov    $0x2,%eax
    171b:	89 45 a8             	mov    %eax,-0x58(%ebp)
    171e:	83 ec 0c             	sub    $0xc,%esp
    1721:	ff 75 a8             	pushl  -0x58(%ebp)
    1724:	ff 75 a4             	pushl  -0x5c(%ebp)
    1727:	ff 75 a0             	pushl  -0x60(%ebp)
    172a:	ff 75 9c             	pushl  -0x64(%ebp)
    172d:	68 a0 58 02 00       	push   $0x258a0
    1732:	e8 70 65 00 00       	call   7ca7 <api_update>
    1737:	83 c4 20             	add    $0x20,%esp
    api_update(&wnd, (Rect){cutbox_pos.x, y_corner, cut_box_dash_corner_width, cut_box_dash_corner_height});
    int image_width = width - cut_box_dash_corner_width*2 - cut_box_dash_width*2;
    if(image_width > 0)
    {
        int cut_box_width = image_width / cut_box_dash_width;
        for(int i=0;i<cut_box_width;i++)
    173a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    173e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1741:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    1744:	0f 8c 23 ff ff ff    	jl     166d <drawCutBoxWidth+0xf5>
            {
                api_drawRect(&wnd, (Point) {cutbox_pos.x+cut_box_dash_corner_width+cut_box_dash_width+i*cut_box_dash_width, y_dash}, (Size) {cut_box_dash_height, cut_box_dash_width}, cut_box_color);
                api_update(&wnd, (Rect){cutbox_pos.x+cut_box_dash_corner_width+cut_box_dash_width+i*cut_box_dash_width, y_dash, cut_box_dash_width, cut_box_dash_height});
            }
        }
        if(cut_box_width%2==0)
    174a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    174d:	83 e0 01             	and    $0x1,%eax
    1750:	85 c0                	test   %eax,%eax
    1752:	0f 85 d5 00 00 00    	jne    182d <drawCutBoxWidth+0x2b5>
        {
            api_drawRect(&wnd, (Point) {cutbox_pos.x +cut_box_dash_corner_width+cut_box_dash_width+ cut_box_width*cut_box_dash_width, y_dash}, (Size) {cut_box_dash_height, image_width - cut_box_width*cut_box_dash_width}, cut_box_color);
    1758:	b8 02 00 00 00       	mov    $0x2,%eax
    175d:	89 45 ac             	mov    %eax,-0x54(%ebp)
    1760:	b8 06 00 00 00       	mov    $0x6,%eax
    1765:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    1769:	8b 55 f0             	mov    -0x10(%ebp),%edx
    176c:	29 c2                	sub    %eax,%edx
    176e:	89 d0                	mov    %edx,%eax
    1770:	89 45 b0             	mov    %eax,-0x50(%ebp)
    1773:	a1 24 53 02 00       	mov    0x25324,%eax
    1778:	ba 0a 00 00 00       	mov    $0xa,%edx
    177d:	01 d0                	add    %edx,%eax
    177f:	ba 06 00 00 00       	mov    $0x6,%edx
    1784:	01 c2                	add    %eax,%edx
    1786:	b8 06 00 00 00       	mov    $0x6,%eax
    178b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    178f:	01 d0                	add    %edx,%eax
    1791:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    1794:	8b 45 0c             	mov    0xc(%ebp),%eax
    1797:	89 45 b8             	mov    %eax,-0x48(%ebp)
    179a:	83 ec 08             	sub    $0x8,%esp
    179d:	83 ec 04             	sub    $0x4,%esp
    17a0:	89 e0                	mov    %esp,%eax
    17a2:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    17a9:	66 89 10             	mov    %dx,(%eax)
    17ac:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    17b3:	88 50 02             	mov    %dl,0x2(%eax)
    17b6:	ff 75 b0             	pushl  -0x50(%ebp)
    17b9:	ff 75 ac             	pushl  -0x54(%ebp)
    17bc:	ff 75 b8             	pushl  -0x48(%ebp)
    17bf:	ff 75 b4             	pushl  -0x4c(%ebp)
    17c2:	68 a0 58 02 00       	push   $0x258a0
    17c7:	e8 6a 65 00 00       	call   7d36 <api_drawRect>
    17cc:	83 c4 20             	add    $0x20,%esp
            api_update(&wnd, (Rect){cutbox_pos.x+cut_box_dash_corner_width+cut_box_dash_width+cut_box_width*cut_box_dash_width, y_dash, image_width - cut_box_width*cut_box_dash_width, cut_box_dash_height});
    17cf:	a1 24 53 02 00       	mov    0x25324,%eax
    17d4:	ba 0a 00 00 00       	mov    $0xa,%edx
    17d9:	01 d0                	add    %edx,%eax
    17db:	ba 06 00 00 00       	mov    $0x6,%edx
    17e0:	01 c2                	add    %eax,%edx
    17e2:	b8 06 00 00 00       	mov    $0x6,%eax
    17e7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    17eb:	01 d0                	add    %edx,%eax
    17ed:	89 45 bc             	mov    %eax,-0x44(%ebp)
    17f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    17f3:	89 45 c0             	mov    %eax,-0x40(%ebp)
    17f6:	b8 06 00 00 00       	mov    $0x6,%eax
    17fb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    17ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1802:	29 c2                	sub    %eax,%edx
    1804:	89 d0                	mov    %edx,%eax
    1806:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    1809:	b8 02 00 00 00       	mov    $0x2,%eax
    180e:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1811:	83 ec 0c             	sub    $0xc,%esp
    1814:	ff 75 c8             	pushl  -0x38(%ebp)
    1817:	ff 75 c4             	pushl  -0x3c(%ebp)
    181a:	ff 75 c0             	pushl  -0x40(%ebp)
    181d:	ff 75 bc             	pushl  -0x44(%ebp)
    1820:	68 a0 58 02 00       	push   $0x258a0
    1825:	e8 7d 64 00 00       	call   7ca7 <api_update>
    182a:	83 c4 20             	add    $0x20,%esp
        }
    }
    api_drawRect(&wnd, (Point) {cutbox_pos.x+image_width+cut_box_dash_width*2+cut_box_dash_corner_width, y_corner}, (Size) {cut_box_dash_corner_height, cut_box_dash_corner_width}, cut_box_color);
    182d:	b8 05 00 00 00       	mov    $0x5,%eax
    1832:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1835:	b8 0a 00 00 00       	mov    $0xa,%eax
    183a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    183d:	8b 15 24 53 02 00    	mov    0x25324,%edx
    1843:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1846:	01 c2                	add    %eax,%edx
    1848:	b8 06 00 00 00       	mov    $0x6,%eax
    184d:	01 c0                	add    %eax,%eax
    184f:	01 d0                	add    %edx,%eax
    1851:	ba 0a 00 00 00       	mov    $0xa,%edx
    1856:	01 d0                	add    %edx,%eax
    1858:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    185b:	8b 45 08             	mov    0x8(%ebp),%eax
    185e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1861:	83 ec 08             	sub    $0x8,%esp
    1864:	83 ec 04             	sub    $0x4,%esp
    1867:	89 e0                	mov    %esp,%eax
    1869:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    1870:	66 89 10             	mov    %dx,(%eax)
    1873:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    187a:	88 50 02             	mov    %dl,0x2(%eax)
    187d:	ff 75 d0             	pushl  -0x30(%ebp)
    1880:	ff 75 cc             	pushl  -0x34(%ebp)
    1883:	ff 75 d8             	pushl  -0x28(%ebp)
    1886:	ff 75 d4             	pushl  -0x2c(%ebp)
    1889:	68 a0 58 02 00       	push   $0x258a0
    188e:	e8 a3 64 00 00       	call   7d36 <api_drawRect>
    1893:	83 c4 20             	add    $0x20,%esp
    api_update(&wnd, (Rect){cutbox_pos.x+image_width+cut_box_dash_width*2+cut_box_dash_corner_width, y_corner, cut_box_dash_corner_width, cut_box_dash_corner_height});
    1896:	8b 15 24 53 02 00    	mov    0x25324,%edx
    189c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    189f:	01 c2                	add    %eax,%edx
    18a1:	b8 06 00 00 00       	mov    $0x6,%eax
    18a6:	01 c0                	add    %eax,%eax
    18a8:	01 d0                	add    %edx,%eax
    18aa:	ba 0a 00 00 00       	mov    $0xa,%edx
    18af:	01 d0                	add    %edx,%eax
    18b1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    18b4:	8b 45 08             	mov    0x8(%ebp),%eax
    18b7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    18ba:	b8 0a 00 00 00       	mov    $0xa,%eax
    18bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    18c2:	b8 05 00 00 00       	mov    $0x5,%eax
    18c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    18ca:	83 ec 0c             	sub    $0xc,%esp
    18cd:	ff 75 e8             	pushl  -0x18(%ebp)
    18d0:	ff 75 e4             	pushl  -0x1c(%ebp)
    18d3:	ff 75 e0             	pushl  -0x20(%ebp)
    18d6:	ff 75 dc             	pushl  -0x24(%ebp)
    18d9:	68 a0 58 02 00       	push   $0x258a0
    18de:	e8 c4 63 00 00       	call   7ca7 <api_update>
    18e3:	83 c4 20             	add    $0x20,%esp
}
    18e6:	90                   	nop
    18e7:	c9                   	leave  
    18e8:	c3                   	ret    

000018e9 <drawCutBoxHeight>:

void drawCutBoxHeight(int x_corner, int x_dash, int height) {
    18e9:	55                   	push   %ebp
    18ea:	89 e5                	mov    %esp,%ebp
    18ec:	81 ec 98 00 00 00    	sub    $0x98,%esp
    api_drawRect(&wnd, (Point) {x_corner, cutbox_pos.y}, (Size) {cut_box_dash_corner_width, cut_box_dash_corner_height}, cut_box_color);
    18f2:	b8 0a 00 00 00       	mov    $0xa,%eax
    18f7:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
    18fd:	b8 05 00 00 00       	mov    $0x5,%eax
    1902:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
    1908:	8b 45 08             	mov    0x8(%ebp),%eax
    190b:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
    1911:	a1 28 53 02 00       	mov    0x25328,%eax
    1916:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
    191c:	83 ec 08             	sub    $0x8,%esp
    191f:	83 ec 04             	sub    $0x4,%esp
    1922:	89 e0                	mov    %esp,%eax
    1924:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    192b:	66 89 10             	mov    %dx,(%eax)
    192e:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    1935:	88 50 02             	mov    %dl,0x2(%eax)
    1938:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
    193e:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
    1944:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
    194a:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
    1950:	68 a0 58 02 00       	push   $0x258a0
    1955:	e8 dc 63 00 00       	call   7d36 <api_drawRect>
    195a:	83 c4 20             	add    $0x20,%esp
    api_update(&wnd, (Rect){x_corner, cutbox_pos.y, cut_box_dash_corner_height, cut_box_dash_corner_width});
    195d:	8b 45 08             	mov    0x8(%ebp),%eax
    1960:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
    1966:	a1 28 53 02 00       	mov    0x25328,%eax
    196b:	89 45 80             	mov    %eax,-0x80(%ebp)
    196e:	b8 05 00 00 00       	mov    $0x5,%eax
    1973:	89 45 84             	mov    %eax,-0x7c(%ebp)
    1976:	b8 0a 00 00 00       	mov    $0xa,%eax
    197b:	89 45 88             	mov    %eax,-0x78(%ebp)
    197e:	83 ec 0c             	sub    $0xc,%esp
    1981:	ff 75 88             	pushl  -0x78(%ebp)
    1984:	ff 75 84             	pushl  -0x7c(%ebp)
    1987:	ff 75 80             	pushl  -0x80(%ebp)
    198a:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
    1990:	68 a0 58 02 00       	push   $0x258a0
    1995:	e8 0d 63 00 00       	call   7ca7 <api_update>
    199a:	83 c4 20             	add    $0x20,%esp
    int image_height = height - cut_box_dash_corner_width*2 - cut_box_dash_width*2;
    199d:	b8 0a 00 00 00       	mov    $0xa,%eax
    19a2:	8d 14 00             	lea    (%eax,%eax,1),%edx
    19a5:	8b 45 10             	mov    0x10(%ebp),%eax
    19a8:	29 d0                	sub    %edx,%eax
    19aa:	89 c2                	mov    %eax,%edx
    19ac:	b8 06 00 00 00       	mov    $0x6,%eax
    19b1:	01 c0                	add    %eax,%eax
    19b3:	29 c2                	sub    %eax,%edx
    19b5:	89 d0                	mov    %edx,%eax
    19b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(image_height > 0)
    19ba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    19be:	0f 8e da 01 00 00    	jle    1b9e <drawCutBoxHeight+0x2b5>
    {
        int cut_box_width = image_height / cut_box_dash_width;
    19c4:	b9 06 00 00 00       	mov    $0x6,%ecx
    19c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    19cc:	99                   	cltd   
    19cd:	f7 f9                	idiv   %ecx
    19cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int i=0;i<cut_box_width;i++)
    19d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    19d9:	e9 d1 00 00 00       	jmp    1aaf <drawCutBoxHeight+0x1c6>
        {
            if(i%2==0)
    19de:	8b 45 f4             	mov    -0xc(%ebp),%eax
    19e1:	83 e0 01             	and    $0x1,%eax
    19e4:	85 c0                	test   %eax,%eax
    19e6:	0f 85 bf 00 00 00    	jne    1aab <drawCutBoxHeight+0x1c2>
            {
                api_drawRect(&wnd, (Point) {x_dash, cutbox_pos.y+cut_box_dash_corner_width+cut_box_dash_width+i*cut_box_dash_width}, (Size) {cut_box_dash_width, cut_box_dash_height}, cut_box_color);
    19ec:	b8 06 00 00 00       	mov    $0x6,%eax
    19f1:	89 45 8c             	mov    %eax,-0x74(%ebp)
    19f4:	b8 02 00 00 00       	mov    $0x2,%eax
    19f9:	89 45 90             	mov    %eax,-0x70(%ebp)
    19fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    19ff:	89 45 94             	mov    %eax,-0x6c(%ebp)
    1a02:	a1 28 53 02 00       	mov    0x25328,%eax
    1a07:	ba 0a 00 00 00       	mov    $0xa,%edx
    1a0c:	01 d0                	add    %edx,%eax
    1a0e:	ba 06 00 00 00       	mov    $0x6,%edx
    1a13:	01 c2                	add    %eax,%edx
    1a15:	b8 06 00 00 00       	mov    $0x6,%eax
    1a1a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    1a1e:	01 d0                	add    %edx,%eax
    1a20:	89 45 98             	mov    %eax,-0x68(%ebp)
    1a23:	83 ec 08             	sub    $0x8,%esp
    1a26:	83 ec 04             	sub    $0x4,%esp
    1a29:	89 e0                	mov    %esp,%eax
    1a2b:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    1a32:	66 89 10             	mov    %dx,(%eax)
    1a35:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    1a3c:	88 50 02             	mov    %dl,0x2(%eax)
    1a3f:	ff 75 90             	pushl  -0x70(%ebp)
    1a42:	ff 75 8c             	pushl  -0x74(%ebp)
    1a45:	ff 75 98             	pushl  -0x68(%ebp)
    1a48:	ff 75 94             	pushl  -0x6c(%ebp)
    1a4b:	68 a0 58 02 00       	push   $0x258a0
    1a50:	e8 e1 62 00 00       	call   7d36 <api_drawRect>
    1a55:	83 c4 20             	add    $0x20,%esp
                api_update(&wnd, (Rect){x_dash, cutbox_pos.y+cut_box_dash_corner_width+cut_box_dash_width+i*cut_box_dash_width, cut_box_dash_height, cut_box_dash_width});
    1a58:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a5b:	89 45 9c             	mov    %eax,-0x64(%ebp)
    1a5e:	a1 28 53 02 00       	mov    0x25328,%eax
    1a63:	ba 0a 00 00 00       	mov    $0xa,%edx
    1a68:	01 d0                	add    %edx,%eax
    1a6a:	ba 06 00 00 00       	mov    $0x6,%edx
    1a6f:	01 c2                	add    %eax,%edx
    1a71:	b8 06 00 00 00       	mov    $0x6,%eax
    1a76:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    1a7a:	01 d0                	add    %edx,%eax
    1a7c:	89 45 a0             	mov    %eax,-0x60(%ebp)
    1a7f:	b8 02 00 00 00       	mov    $0x2,%eax
    1a84:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    1a87:	b8 06 00 00 00       	mov    $0x6,%eax
    1a8c:	89 45 a8             	mov    %eax,-0x58(%ebp)
    1a8f:	83 ec 0c             	sub    $0xc,%esp
    1a92:	ff 75 a8             	pushl  -0x58(%ebp)
    1a95:	ff 75 a4             	pushl  -0x5c(%ebp)
    1a98:	ff 75 a0             	pushl  -0x60(%ebp)
    1a9b:	ff 75 9c             	pushl  -0x64(%ebp)
    1a9e:	68 a0 58 02 00       	push   $0x258a0
    1aa3:	e8 ff 61 00 00       	call   7ca7 <api_update>
    1aa8:	83 c4 20             	add    $0x20,%esp
    api_update(&wnd, (Rect){x_corner, cutbox_pos.y, cut_box_dash_corner_height, cut_box_dash_corner_width});
    int image_height = height - cut_box_dash_corner_width*2 - cut_box_dash_width*2;
    if(image_height > 0)
    {
        int cut_box_width = image_height / cut_box_dash_width;
        for(int i=0;i<cut_box_width;i++)
    1aab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1aaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ab2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    1ab5:	0f 8c 23 ff ff ff    	jl     19de <drawCutBoxHeight+0xf5>
            {
                api_drawRect(&wnd, (Point) {x_dash, cutbox_pos.y+cut_box_dash_corner_width+cut_box_dash_width+i*cut_box_dash_width}, (Size) {cut_box_dash_width, cut_box_dash_height}, cut_box_color);
                api_update(&wnd, (Rect){x_dash, cutbox_pos.y+cut_box_dash_corner_width+cut_box_dash_width+i*cut_box_dash_width, cut_box_dash_height, cut_box_dash_width});
            }
        }
        if(cut_box_width%2==0)
    1abb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1abe:	83 e0 01             	and    $0x1,%eax
    1ac1:	85 c0                	test   %eax,%eax
    1ac3:	0f 85 d5 00 00 00    	jne    1b9e <drawCutBoxHeight+0x2b5>
        {
            api_drawRect(&wnd, (Point) {x_dash, cutbox_pos.y+cut_box_dash_corner_width+cut_box_dash_width+cut_box_width*cut_box_dash_width}, (Size) {image_height - cut_box_width*cut_box_dash_width, cut_box_dash_height}, cut_box_color);
    1ac9:	b8 06 00 00 00       	mov    $0x6,%eax
    1ace:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    1ad2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1ad5:	29 c2                	sub    %eax,%edx
    1ad7:	89 d0                	mov    %edx,%eax
    1ad9:	89 45 ac             	mov    %eax,-0x54(%ebp)
    1adc:	b8 02 00 00 00       	mov    $0x2,%eax
    1ae1:	89 45 b0             	mov    %eax,-0x50(%ebp)
    1ae4:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ae7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    1aea:	a1 28 53 02 00       	mov    0x25328,%eax
    1aef:	ba 0a 00 00 00       	mov    $0xa,%edx
    1af4:	01 d0                	add    %edx,%eax
    1af6:	ba 06 00 00 00       	mov    $0x6,%edx
    1afb:	01 c2                	add    %eax,%edx
    1afd:	b8 06 00 00 00       	mov    $0x6,%eax
    1b02:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    1b06:	01 d0                	add    %edx,%eax
    1b08:	89 45 b8             	mov    %eax,-0x48(%ebp)
    1b0b:	83 ec 08             	sub    $0x8,%esp
    1b0e:	83 ec 04             	sub    $0x4,%esp
    1b11:	89 e0                	mov    %esp,%eax
    1b13:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    1b1a:	66 89 10             	mov    %dx,(%eax)
    1b1d:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    1b24:	88 50 02             	mov    %dl,0x2(%eax)
    1b27:	ff 75 b0             	pushl  -0x50(%ebp)
    1b2a:	ff 75 ac             	pushl  -0x54(%ebp)
    1b2d:	ff 75 b8             	pushl  -0x48(%ebp)
    1b30:	ff 75 b4             	pushl  -0x4c(%ebp)
    1b33:	68 a0 58 02 00       	push   $0x258a0
    1b38:	e8 f9 61 00 00       	call   7d36 <api_drawRect>
    1b3d:	83 c4 20             	add    $0x20,%esp
            api_update(&wnd, (Rect){x_dash, cutbox_pos.y+cut_box_dash_corner_width+cut_box_dash_width+cut_box_width*cut_box_dash_width, cut_box_dash_height, image_height - cut_box_width*cut_box_dash_width});
    1b40:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b43:	89 45 bc             	mov    %eax,-0x44(%ebp)
    1b46:	a1 28 53 02 00       	mov    0x25328,%eax
    1b4b:	ba 0a 00 00 00       	mov    $0xa,%edx
    1b50:	01 d0                	add    %edx,%eax
    1b52:	ba 06 00 00 00       	mov    $0x6,%edx
    1b57:	01 c2                	add    %eax,%edx
    1b59:	b8 06 00 00 00       	mov    $0x6,%eax
    1b5e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    1b62:	01 d0                	add    %edx,%eax
    1b64:	89 45 c0             	mov    %eax,-0x40(%ebp)
    1b67:	b8 02 00 00 00       	mov    $0x2,%eax
    1b6c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    1b6f:	b8 06 00 00 00       	mov    $0x6,%eax
    1b74:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    1b78:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1b7b:	29 c2                	sub    %eax,%edx
    1b7d:	89 d0                	mov    %edx,%eax
    1b7f:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1b82:	83 ec 0c             	sub    $0xc,%esp
    1b85:	ff 75 c8             	pushl  -0x38(%ebp)
    1b88:	ff 75 c4             	pushl  -0x3c(%ebp)
    1b8b:	ff 75 c0             	pushl  -0x40(%ebp)
    1b8e:	ff 75 bc             	pushl  -0x44(%ebp)
    1b91:	68 a0 58 02 00       	push   $0x258a0
    1b96:	e8 0c 61 00 00       	call   7ca7 <api_update>
    1b9b:	83 c4 20             	add    $0x20,%esp
        }
    }
    api_drawRect(&wnd, (Point) {x_corner, cutbox_pos.y+image_height+cut_box_dash_width*2+cut_box_dash_corner_width}, (Size) {cut_box_dash_corner_width, cut_box_dash_corner_height}, cut_box_color);
    1b9e:	b8 0a 00 00 00       	mov    $0xa,%eax
    1ba3:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1ba6:	b8 05 00 00 00       	mov    $0x5,%eax
    1bab:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1bae:	8b 45 08             	mov    0x8(%ebp),%eax
    1bb1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1bb4:	8b 15 28 53 02 00    	mov    0x25328,%edx
    1bba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1bbd:	01 c2                	add    %eax,%edx
    1bbf:	b8 06 00 00 00       	mov    $0x6,%eax
    1bc4:	01 c0                	add    %eax,%eax
    1bc6:	01 d0                	add    %edx,%eax
    1bc8:	ba 0a 00 00 00       	mov    $0xa,%edx
    1bcd:	01 d0                	add    %edx,%eax
    1bcf:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1bd2:	83 ec 08             	sub    $0x8,%esp
    1bd5:	83 ec 04             	sub    $0x4,%esp
    1bd8:	89 e0                	mov    %esp,%eax
    1bda:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    1be1:	66 89 10             	mov    %dx,(%eax)
    1be4:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    1beb:	88 50 02             	mov    %dl,0x2(%eax)
    1bee:	ff 75 d0             	pushl  -0x30(%ebp)
    1bf1:	ff 75 cc             	pushl  -0x34(%ebp)
    1bf4:	ff 75 d8             	pushl  -0x28(%ebp)
    1bf7:	ff 75 d4             	pushl  -0x2c(%ebp)
    1bfa:	68 a0 58 02 00       	push   $0x258a0
    1bff:	e8 32 61 00 00       	call   7d36 <api_drawRect>
    1c04:	83 c4 20             	add    $0x20,%esp
    api_update(&wnd, (Rect){x_corner, cutbox_pos.y+image_height+cut_box_dash_width*2+cut_box_dash_corner_width, cut_box_dash_corner_height, cut_box_dash_corner_width});
    1c07:	8b 45 08             	mov    0x8(%ebp),%eax
    1c0a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1c0d:	8b 15 28 53 02 00    	mov    0x25328,%edx
    1c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c16:	01 c2                	add    %eax,%edx
    1c18:	b8 06 00 00 00       	mov    $0x6,%eax
    1c1d:	01 c0                	add    %eax,%eax
    1c1f:	01 d0                	add    %edx,%eax
    1c21:	ba 0a 00 00 00       	mov    $0xa,%edx
    1c26:	01 d0                	add    %edx,%eax
    1c28:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1c2b:	b8 05 00 00 00       	mov    $0x5,%eax
    1c30:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c33:	b8 0a 00 00 00       	mov    $0xa,%eax
    1c38:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1c3b:	83 ec 0c             	sub    $0xc,%esp
    1c3e:	ff 75 e8             	pushl  -0x18(%ebp)
    1c41:	ff 75 e4             	pushl  -0x1c(%ebp)
    1c44:	ff 75 e0             	pushl  -0x20(%ebp)
    1c47:	ff 75 dc             	pushl  -0x24(%ebp)
    1c4a:	68 a0 58 02 00       	push   $0x258a0
    1c4f:	e8 53 60 00 00       	call   7ca7 <api_update>
    1c54:	83 c4 20             	add    $0x20,%esp
}
    1c57:	90                   	nop
    1c58:	c9                   	leave  
    1c59:	c3                   	ret    

00001c5a <drawCutBoxCorner>:

void drawCutBoxCorner(Point pos) {
    1c5a:	55                   	push   %ebp
    1c5b:	89 e5                	mov    %esp,%ebp
    1c5d:	83 ec 28             	sub    $0x28,%esp
    api_drawRect(&wnd, pos, (Size) {cut_box_dash_corner_height, cut_box_dash_corner_height}, cut_box_color);
    1c60:	b8 05 00 00 00       	mov    $0x5,%eax
    1c65:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1c68:	b8 05 00 00 00       	mov    $0x5,%eax
    1c6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c70:	83 ec 08             	sub    $0x8,%esp
    1c73:	83 ec 04             	sub    $0x4,%esp
    1c76:	89 e0                	mov    %esp,%eax
    1c78:	0f b7 15 d8 52 02 00 	movzwl 0x252d8,%edx
    1c7f:	66 89 10             	mov    %dx,(%eax)
    1c82:	0f b6 15 da 52 02 00 	movzbl 0x252da,%edx
    1c89:	88 50 02             	mov    %dl,0x2(%eax)
    1c8c:	ff 75 e4             	pushl  -0x1c(%ebp)
    1c8f:	ff 75 e0             	pushl  -0x20(%ebp)
    1c92:	ff 75 0c             	pushl  0xc(%ebp)
    1c95:	ff 75 08             	pushl  0x8(%ebp)
    1c98:	68 a0 58 02 00       	push   $0x258a0
    1c9d:	e8 94 60 00 00       	call   7d36 <api_drawRect>
    1ca2:	83 c4 20             	add    $0x20,%esp
    api_update(&wnd, (Rect){pos.x, pos.y, cut_box_dash_corner_height, cut_box_dash_corner_height});
    1ca5:	8b 45 08             	mov    0x8(%ebp),%eax
    1ca8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1cab:	8b 45 0c             	mov    0xc(%ebp),%eax
    1cae:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1cb1:	b8 05 00 00 00       	mov    $0x5,%eax
    1cb6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1cb9:	b8 05 00 00 00       	mov    $0x5,%eax
    1cbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1cc1:	83 ec 0c             	sub    $0xc,%esp
    1cc4:	ff 75 f4             	pushl  -0xc(%ebp)
    1cc7:	ff 75 f0             	pushl  -0x10(%ebp)
    1cca:	ff 75 ec             	pushl  -0x14(%ebp)
    1ccd:	ff 75 e8             	pushl  -0x18(%ebp)
    1cd0:	68 a0 58 02 00       	push   $0x258a0
    1cd5:	e8 cd 5f 00 00       	call   7ca7 <api_update>
    1cda:	83 c4 20             	add    $0x20,%esp
}
    1cdd:	90                   	nop
    1cde:	c9                   	leave  
    1cdf:	c3                   	ret    

00001ce0 <drawCutBoxButton>:

void drawCutBoxButton(Point pos) {
    1ce0:	55                   	push   %ebp
    1ce1:	89 e5                	mov    %esp,%ebp
    1ce3:	83 ec 38             	sub    $0x38,%esp
    api_paint24BitmapToContentTransparent(&wnd, cut_confirm_icon, (Point){pos.x,pos.y}, (Point){0,0}, (Size){cut_box_button_width,cut_box_button_height},(Size){cut_box_button_width,cut_box_button_height});
    1ce6:	b8 14 00 00 00       	mov    $0x14,%eax
    1ceb:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1cee:	b8 14 00 00 00       	mov    $0x14,%eax
    1cf3:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1cf6:	b8 14 00 00 00       	mov    $0x14,%eax
    1cfb:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1cfe:	b8 14 00 00 00       	mov    $0x14,%eax
    1d03:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1d06:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    1d0d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    1d14:	8b 45 08             	mov    0x8(%ebp),%eax
    1d17:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1d1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d1d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1d20:	a1 34 58 02 00       	mov    0x25834,%eax
    1d25:	83 ec 08             	sub    $0x8,%esp
    1d28:	ff 75 cc             	pushl  -0x34(%ebp)
    1d2b:	ff 75 c8             	pushl  -0x38(%ebp)
    1d2e:	ff 75 d4             	pushl  -0x2c(%ebp)
    1d31:	ff 75 d0             	pushl  -0x30(%ebp)
    1d34:	ff 75 dc             	pushl  -0x24(%ebp)
    1d37:	ff 75 d8             	pushl  -0x28(%ebp)
    1d3a:	ff 75 e4             	pushl  -0x1c(%ebp)
    1d3d:	ff 75 e0             	pushl  -0x20(%ebp)
    1d40:	50                   	push   %eax
    1d41:	68 a0 58 02 00       	push   $0x258a0
    1d46:	e8 fe 5e 00 00       	call   7c49 <api_paint24BitmapToContentTransparent>
    1d4b:	83 c4 30             	add    $0x30,%esp
    api_update(&wnd, (Rect){pos.x, pos.y, cut_box_button_height, cut_box_button_height});
    1d4e:	8b 45 08             	mov    0x8(%ebp),%eax
    1d51:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1d54:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d57:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1d5a:	b8 14 00 00 00       	mov    $0x14,%eax
    1d5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1d62:	b8 14 00 00 00       	mov    $0x14,%eax
    1d67:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1d6a:	83 ec 0c             	sub    $0xc,%esp
    1d6d:	ff 75 f4             	pushl  -0xc(%ebp)
    1d70:	ff 75 f0             	pushl  -0x10(%ebp)
    1d73:	ff 75 ec             	pushl  -0x14(%ebp)
    1d76:	ff 75 e8             	pushl  -0x18(%ebp)
    1d79:	68 a0 58 02 00       	push   $0x258a0
    1d7e:	e8 24 5f 00 00       	call   7ca7 <api_update>
    1d83:	83 c4 20             	add    $0x20,%esp
}
    1d86:	90                   	nop
    1d87:	c9                   	leave  
    1d88:	c3                   	ret    

00001d89 <drawCutBox>:

void drawCutBox(Point pos, int width, int height) {
    1d89:	55                   	push   %ebp
    1d8a:	89 e5                	mov    %esp,%ebp
    1d8c:	83 ec 58             	sub    $0x58,%esp
    api_paint24BitmapToContent(&wnd, cut_img_save, (Point){content_pos.x - cut_box_dash_corner_height,content_pos.y - cut_box_dash_corner_height}, (Point){0,0}, (Size){content_size.h+2*cut_box_dash_corner_height, content_size.w+2*cut_box_dash_corner_height+2*cut_box_button_width},(Size){content_size.h+2*cut_box_dash_corner_height,content_size.w+2*cut_box_dash_corner_height+2*cut_box_button_width});
    1d8f:	a1 0c 53 02 00       	mov    0x2530c,%eax
    1d94:	ba 05 00 00 00       	mov    $0x5,%edx
    1d99:	01 d2                	add    %edx,%edx
    1d9b:	01 d0                	add    %edx,%eax
    1d9d:	89 45 b0             	mov    %eax,-0x50(%ebp)
    1da0:	a1 10 53 02 00       	mov    0x25310,%eax
    1da5:	ba 05 00 00 00       	mov    $0x5,%edx
    1daa:	01 d2                	add    %edx,%edx
    1dac:	01 c2                	add    %eax,%edx
    1dae:	b8 14 00 00 00       	mov    $0x14,%eax
    1db3:	01 c0                	add    %eax,%eax
    1db5:	01 d0                	add    %edx,%eax
    1db7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    1dba:	a1 0c 53 02 00       	mov    0x2530c,%eax
    1dbf:	ba 05 00 00 00       	mov    $0x5,%edx
    1dc4:	01 d2                	add    %edx,%edx
    1dc6:	01 d0                	add    %edx,%eax
    1dc8:	89 45 b8             	mov    %eax,-0x48(%ebp)
    1dcb:	a1 10 53 02 00       	mov    0x25310,%eax
    1dd0:	ba 05 00 00 00       	mov    $0x5,%edx
    1dd5:	01 d2                	add    %edx,%edx
    1dd7:	01 c2                	add    %eax,%edx
    1dd9:	b8 14 00 00 00       	mov    $0x14,%eax
    1dde:	01 c0                	add    %eax,%eax
    1de0:	01 d0                	add    %edx,%eax
    1de2:	89 45 bc             	mov    %eax,-0x44(%ebp)
    1de5:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    1dec:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    1df3:	a1 1c 53 02 00       	mov    0x2531c,%eax
    1df8:	ba 05 00 00 00       	mov    $0x5,%edx
    1dfd:	29 d0                	sub    %edx,%eax
    1dff:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1e02:	a1 20 53 02 00       	mov    0x25320,%eax
    1e07:	ba 05 00 00 00       	mov    $0x5,%edx
    1e0c:	29 d0                	sub    %edx,%eax
    1e0e:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1e11:	a1 7c 58 02 00       	mov    0x2587c,%eax
    1e16:	83 ec 08             	sub    $0x8,%esp
    1e19:	ff 75 b4             	pushl  -0x4c(%ebp)
    1e1c:	ff 75 b0             	pushl  -0x50(%ebp)
    1e1f:	ff 75 bc             	pushl  -0x44(%ebp)
    1e22:	ff 75 b8             	pushl  -0x48(%ebp)
    1e25:	ff 75 c4             	pushl  -0x3c(%ebp)
    1e28:	ff 75 c0             	pushl  -0x40(%ebp)
    1e2b:	ff 75 cc             	pushl  -0x34(%ebp)
    1e2e:	ff 75 c8             	pushl  -0x38(%ebp)
    1e31:	50                   	push   %eax
    1e32:	68 a0 58 02 00       	push   $0x258a0
    1e37:	e8 cd 5d 00 00       	call   7c09 <api_paint24BitmapToContent>
    1e3c:	83 c4 30             	add    $0x30,%esp
    drawCutBoxWidth(pos.y - cut_box_dash_corner_height, pos.y - cut_box_dash_height, width);
    1e3f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e42:	ba 02 00 00 00       	mov    $0x2,%edx
    1e47:	29 d0                	sub    %edx,%eax
    1e49:	89 c2                	mov    %eax,%edx
    1e4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e4e:	b9 05 00 00 00       	mov    $0x5,%ecx
    1e53:	29 c8                	sub    %ecx,%eax
    1e55:	83 ec 04             	sub    $0x4,%esp
    1e58:	ff 75 10             	pushl  0x10(%ebp)
    1e5b:	52                   	push   %edx
    1e5c:	50                   	push   %eax
    1e5d:	e8 16 f7 ff ff       	call   1578 <drawCutBoxWidth>
    1e62:	83 c4 10             	add    $0x10,%esp
    drawCutBoxWidth(pos.y + height, pos.y + height, width);
    1e65:	8b 55 0c             	mov    0xc(%ebp),%edx
    1e68:	8b 45 14             	mov    0x14(%ebp),%eax
    1e6b:	01 c2                	add    %eax,%edx
    1e6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1e70:	8b 45 14             	mov    0x14(%ebp),%eax
    1e73:	01 c8                	add    %ecx,%eax
    1e75:	83 ec 04             	sub    $0x4,%esp
    1e78:	ff 75 10             	pushl  0x10(%ebp)
    1e7b:	52                   	push   %edx
    1e7c:	50                   	push   %eax
    1e7d:	e8 f6 f6 ff ff       	call   1578 <drawCutBoxWidth>
    1e82:	83 c4 10             	add    $0x10,%esp
    drawCutBoxHeight(pos.x - cut_box_dash_corner_height, pos.x - cut_box_dash_height, height);
    1e85:	8b 45 08             	mov    0x8(%ebp),%eax
    1e88:	ba 02 00 00 00       	mov    $0x2,%edx
    1e8d:	29 d0                	sub    %edx,%eax
    1e8f:	89 c2                	mov    %eax,%edx
    1e91:	8b 45 08             	mov    0x8(%ebp),%eax
    1e94:	b9 05 00 00 00       	mov    $0x5,%ecx
    1e99:	29 c8                	sub    %ecx,%eax
    1e9b:	83 ec 04             	sub    $0x4,%esp
    1e9e:	ff 75 14             	pushl  0x14(%ebp)
    1ea1:	52                   	push   %edx
    1ea2:	50                   	push   %eax
    1ea3:	e8 41 fa ff ff       	call   18e9 <drawCutBoxHeight>
    1ea8:	83 c4 10             	add    $0x10,%esp
    drawCutBoxHeight(pos.x + width, pos.x + width, height);
    1eab:	8b 55 08             	mov    0x8(%ebp),%edx
    1eae:	8b 45 10             	mov    0x10(%ebp),%eax
    1eb1:	01 c2                	add    %eax,%edx
    1eb3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    1eb6:	8b 45 10             	mov    0x10(%ebp),%eax
    1eb9:	01 c8                	add    %ecx,%eax
    1ebb:	83 ec 04             	sub    $0x4,%esp
    1ebe:	ff 75 14             	pushl  0x14(%ebp)
    1ec1:	52                   	push   %edx
    1ec2:	50                   	push   %eax
    1ec3:	e8 21 fa ff ff       	call   18e9 <drawCutBoxHeight>
    1ec8:	83 c4 10             	add    $0x10,%esp
    drawCutBoxCorner((Point){pos.x - cut_box_dash_corner_height, pos.y - cut_box_dash_corner_height});
    1ecb:	8b 45 08             	mov    0x8(%ebp),%eax
    1ece:	ba 05 00 00 00       	mov    $0x5,%edx
    1ed3:	29 d0                	sub    %edx,%eax
    1ed5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1ed8:	8b 45 0c             	mov    0xc(%ebp),%eax
    1edb:	ba 05 00 00 00       	mov    $0x5,%edx
    1ee0:	29 d0                	sub    %edx,%eax
    1ee2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1ee5:	83 ec 08             	sub    $0x8,%esp
    1ee8:	ff 75 d4             	pushl  -0x2c(%ebp)
    1eeb:	ff 75 d0             	pushl  -0x30(%ebp)
    1eee:	e8 67 fd ff ff       	call   1c5a <drawCutBoxCorner>
    1ef3:	83 c4 10             	add    $0x10,%esp
    drawCutBoxCorner((Point){pos.x + width, pos.y - cut_box_dash_corner_height});
    1ef6:	8b 55 08             	mov    0x8(%ebp),%edx
    1ef9:	8b 45 10             	mov    0x10(%ebp),%eax
    1efc:	01 d0                	add    %edx,%eax
    1efe:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1f01:	8b 45 0c             	mov    0xc(%ebp),%eax
    1f04:	ba 05 00 00 00       	mov    $0x5,%edx
    1f09:	29 d0                	sub    %edx,%eax
    1f0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1f0e:	83 ec 08             	sub    $0x8,%esp
    1f11:	ff 75 dc             	pushl  -0x24(%ebp)
    1f14:	ff 75 d8             	pushl  -0x28(%ebp)
    1f17:	e8 3e fd ff ff       	call   1c5a <drawCutBoxCorner>
    1f1c:	83 c4 10             	add    $0x10,%esp
    drawCutBoxCorner((Point){pos.x - cut_box_dash_corner_height, pos.y + height});
    1f1f:	8b 45 08             	mov    0x8(%ebp),%eax
    1f22:	ba 05 00 00 00       	mov    $0x5,%edx
    1f27:	29 d0                	sub    %edx,%eax
    1f29:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1f2c:	8b 55 0c             	mov    0xc(%ebp),%edx
    1f2f:	8b 45 14             	mov    0x14(%ebp),%eax
    1f32:	01 d0                	add    %edx,%eax
    1f34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1f37:	83 ec 08             	sub    $0x8,%esp
    1f3a:	ff 75 e4             	pushl  -0x1c(%ebp)
    1f3d:	ff 75 e0             	pushl  -0x20(%ebp)
    1f40:	e8 15 fd ff ff       	call   1c5a <drawCutBoxCorner>
    1f45:	83 c4 10             	add    $0x10,%esp
    drawCutBoxCorner((Point){pos.x + width, pos.y + height});
    1f48:	8b 55 08             	mov    0x8(%ebp),%edx
    1f4b:	8b 45 10             	mov    0x10(%ebp),%eax
    1f4e:	01 d0                	add    %edx,%eax
    1f50:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1f53:	8b 55 0c             	mov    0xc(%ebp),%edx
    1f56:	8b 45 14             	mov    0x14(%ebp),%eax
    1f59:	01 d0                	add    %edx,%eax
    1f5b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1f5e:	83 ec 08             	sub    $0x8,%esp
    1f61:	ff 75 ec             	pushl  -0x14(%ebp)
    1f64:	ff 75 e8             	pushl  -0x18(%ebp)
    1f67:	e8 ee fc ff ff       	call   1c5a <drawCutBoxCorner>
    1f6c:	83 c4 10             	add    $0x10,%esp
    drawCutBoxButton((Point){pos.x + width + cut_box_dash_corner_height, pos.y + height + cut_box_dash_corner_height - cut_box_button_height});
    1f6f:	8b 55 08             	mov    0x8(%ebp),%edx
    1f72:	8b 45 10             	mov    0x10(%ebp),%eax
    1f75:	01 d0                	add    %edx,%eax
    1f77:	ba 05 00 00 00       	mov    $0x5,%edx
    1f7c:	01 d0                	add    %edx,%eax
    1f7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1f81:	8b 55 0c             	mov    0xc(%ebp),%edx
    1f84:	8b 45 14             	mov    0x14(%ebp),%eax
    1f87:	01 d0                	add    %edx,%eax
    1f89:	ba 05 00 00 00       	mov    $0x5,%edx
    1f8e:	01 d0                	add    %edx,%eax
    1f90:	ba 14 00 00 00       	mov    $0x14,%edx
    1f95:	29 d0                	sub    %edx,%eax
    1f97:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1f9a:	83 ec 08             	sub    $0x8,%esp
    1f9d:	ff 75 f4             	pushl  -0xc(%ebp)
    1fa0:	ff 75 f0             	pushl  -0x10(%ebp)
    1fa3:	e8 38 fd ff ff       	call   1ce0 <drawCutBoxButton>
    1fa8:	83 c4 10             	add    $0x10,%esp
}
    1fab:	90                   	nop
    1fac:	c9                   	leave  
    1fad:	c3                   	ret    

00001fae <isMouseInCutButton>:

int isMouseInCutButton(int x, int y) {
    1fae:	55                   	push   %ebp
    1faf:	89 e5                	mov    %esp,%ebp
    1fb1:	83 ec 18             	sub    $0x18,%esp
    if (60 < x && x <= 90 && 0 <= y && y <= 30){
    1fb4:	83 7d 08 3c          	cmpl   $0x3c,0x8(%ebp)
    1fb8:	0f 8e 8c 01 00 00    	jle    214a <isMouseInCutButton+0x19c>
    1fbe:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
    1fc2:	0f 8f 82 01 00 00    	jg     214a <isMouseInCutButton+0x19c>
    1fc8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1fcc:	0f 88 78 01 00 00    	js     214a <isMouseInCutButton+0x19c>
    1fd2:	83 7d 0c 1e          	cmpl   $0x1e,0xc(%ebp)
    1fd6:	0f 8f 6e 01 00 00    	jg     214a <isMouseInCutButton+0x19c>
        if(is_cut == 0) 
    1fdc:	a1 9c 57 02 00       	mov    0x2579c,%eax
    1fe1:	85 c0                	test   %eax,%eax
    1fe3:	0f 85 5a 01 00 00    	jne    2143 <isMouseInCutButton+0x195>
        {
            is_cut = 1;
    1fe9:	c7 05 9c 57 02 00 01 	movl   $0x1,0x2579c
    1ff0:	00 00 00 
            cutbox_pos.x = content_pos.x;
    1ff3:	a1 1c 53 02 00       	mov    0x2531c,%eax
    1ff8:	a3 24 53 02 00       	mov    %eax,0x25324
            cutbox_pos.y = content_pos.y;
    1ffd:	a1 20 53 02 00       	mov    0x25320,%eax
    2002:	a3 28 53 02 00       	mov    %eax,0x25328
            cutbox_size.w = content_size.w;
    2007:	a1 10 53 02 00       	mov    0x25310,%eax
    200c:	a3 18 53 02 00       	mov    %eax,0x25318
            cutbox_size.h = content_size.h;
    2011:	a1 0c 53 02 00       	mov    0x2530c,%eax
    2016:	a3 14 53 02 00       	mov    %eax,0x25314
            struct RGB *t;
            struct RGB *o;
            cut_img_save = malloc((cutbox_size.w+cut_box_dash_corner_height*2)*(cutbox_size.h+cut_box_dash_corner_height*2+cut_box_button_width*2)*3);
    201b:	a1 18 53 02 00       	mov    0x25318,%eax
    2020:	ba 05 00 00 00       	mov    $0x5,%edx
    2025:	01 d2                	add    %edx,%edx
    2027:	01 c2                	add    %eax,%edx
    2029:	a1 14 53 02 00       	mov    0x25314,%eax
    202e:	b9 05 00 00 00       	mov    $0x5,%ecx
    2033:	01 c9                	add    %ecx,%ecx
    2035:	01 c1                	add    %eax,%ecx
    2037:	b8 14 00 00 00       	mov    $0x14,%eax
    203c:	01 c0                	add    %eax,%eax
    203e:	01 c8                	add    %ecx,%eax
    2040:	0f af d0             	imul   %eax,%edx
    2043:	89 d0                	mov    %edx,%eax
    2045:	01 c0                	add    %eax,%eax
    2047:	01 d0                	add    %edx,%eax
    2049:	83 ec 0c             	sub    $0xc,%esp
    204c:	50                   	push   %eax
    204d:	e8 6b 50 00 00       	call   70bd <malloc>
    2052:	83 c4 10             	add    $0x10,%esp
    2055:	a3 7c 58 02 00       	mov    %eax,0x2587c
            int max_line = cutbox_size.w+cut_box_dash_corner_height*2+cut_box_button_width*2;
    205a:	a1 18 53 02 00       	mov    0x25318,%eax
    205f:	ba 05 00 00 00       	mov    $0x5,%edx
    2064:	01 d2                	add    %edx,%edx
    2066:	01 c2                	add    %eax,%edx
    2068:	b8 14 00 00 00       	mov    $0x14,%eax
    206d:	01 c0                	add    %eax,%eax
    206f:	01 d0                	add    %edx,%eax
    2071:	89 45 f0             	mov    %eax,-0x10(%ebp)
            for (int i = 0; i < cutbox_size.h+cut_box_dash_corner_height*2; i++) {
    2074:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    207b:	e9 8b 00 00 00       	jmp    210b <isMouseInCutButton+0x15d>
                o = wnd.content + (cutbox_pos.y - cut_box_dash_corner_height + i) * wnd.size.w + cutbox_pos.x - cut_box_dash_corner_height;
    2080:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    2086:	a1 28 53 02 00       	mov    0x25328,%eax
    208b:	ba 05 00 00 00       	mov    $0x5,%edx
    2090:	29 d0                	sub    %edx,%eax
    2092:	89 c2                	mov    %eax,%edx
    2094:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2097:	01 c2                	add    %eax,%edx
    2099:	a1 b0 58 02 00       	mov    0x258b0,%eax
    209e:	0f af c2             	imul   %edx,%eax
    20a1:	89 c2                	mov    %eax,%edx
    20a3:	a1 24 53 02 00       	mov    0x25324,%eax
    20a8:	01 d0                	add    %edx,%eax
    20aa:	ba 05 00 00 00       	mov    $0x5,%edx
    20af:	29 d0                	sub    %edx,%eax
    20b1:	89 c2                	mov    %eax,%edx
    20b3:	89 d0                	mov    %edx,%eax
    20b5:	01 c0                	add    %eax,%eax
    20b7:	01 d0                	add    %edx,%eax
    20b9:	01 c8                	add    %ecx,%eax
    20bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
                t = cut_img_save + i * (cutbox_size.w+cut_box_dash_corner_height*2+cut_box_button_width*2);
    20be:	8b 15 7c 58 02 00    	mov    0x2587c,%edx
    20c4:	a1 18 53 02 00       	mov    0x25318,%eax
    20c9:	b9 05 00 00 00       	mov    $0x5,%ecx
    20ce:	01 c9                	add    %ecx,%ecx
    20d0:	01 c1                	add    %eax,%ecx
    20d2:	b8 14 00 00 00       	mov    $0x14,%eax
    20d7:	01 c0                	add    %eax,%eax
    20d9:	01 c8                	add    %ecx,%eax
    20db:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    20df:	89 c1                	mov    %eax,%ecx
    20e1:	89 c8                	mov    %ecx,%eax
    20e3:	01 c0                	add    %eax,%eax
    20e5:	01 c8                	add    %ecx,%eax
    20e7:	01 d0                	add    %edx,%eax
    20e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
                memmove(t, o, max_line * 3);
    20ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
    20ef:	89 d0                	mov    %edx,%eax
    20f1:	01 c0                	add    %eax,%eax
    20f3:	01 d0                	add    %edx,%eax
    20f5:	83 ec 04             	sub    $0x4,%esp
    20f8:	50                   	push   %eax
    20f9:	ff 75 ec             	pushl  -0x14(%ebp)
    20fc:	ff 75 e8             	pushl  -0x18(%ebp)
    20ff:	e8 fa 4a 00 00       	call   6bfe <memmove>
    2104:	83 c4 10             	add    $0x10,%esp
            cutbox_size.h = content_size.h;
            struct RGB *t;
            struct RGB *o;
            cut_img_save = malloc((cutbox_size.w+cut_box_dash_corner_height*2)*(cutbox_size.h+cut_box_dash_corner_height*2+cut_box_button_width*2)*3);
            int max_line = cutbox_size.w+cut_box_dash_corner_height*2+cut_box_button_width*2;
            for (int i = 0; i < cutbox_size.h+cut_box_dash_corner_height*2; i++) {
    2107:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    210b:	a1 14 53 02 00       	mov    0x25314,%eax
    2110:	ba 05 00 00 00       	mov    $0x5,%edx
    2115:	01 d2                	add    %edx,%edx
    2117:	01 d0                	add    %edx,%eax
    2119:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    211c:	0f 8f 5e ff ff ff    	jg     2080 <isMouseInCutButton+0xd2>
                o = wnd.content + (cutbox_pos.y - cut_box_dash_corner_height + i) * wnd.size.w + cutbox_pos.x - cut_box_dash_corner_height;
                t = cut_img_save + i * (cutbox_size.w+cut_box_dash_corner_height*2+cut_box_button_width*2);
                memmove(t, o, max_line * 3);
            }
            drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    2122:	8b 15 14 53 02 00    	mov    0x25314,%edx
    2128:	a1 18 53 02 00       	mov    0x25318,%eax
    212d:	52                   	push   %edx
    212e:	50                   	push   %eax
    212f:	ff 35 28 53 02 00    	pushl  0x25328
    2135:	ff 35 24 53 02 00    	pushl  0x25324
    213b:	e8 49 fc ff ff       	call   1d89 <drawCutBox>
    2140:	83 c4 10             	add    $0x10,%esp
            // api_paint24BitmapToContent(&wnd, cut_img_save, (Point){cutbox_pos.x - cut_box_dash_corner_height,cutbox_pos.y - cut_box_dash_corner_height}, (Point){0,0}, (Size){cutbox_size.h+2*cut_box_dash_corner_height,cutbox_size.w+2*cut_box_dash_corner_height},(Size){cutbox_size.h+2*cut_box_dash_corner_height,cutbox_size.w+2*cut_box_dash_corner_height});
            // api_repaint(&wnd);
        }
        return 1;
    2143:	b8 01 00 00 00       	mov    $0x1,%eax
    2148:	eb 05                	jmp    214f <isMouseInCutButton+0x1a1>
    }
    else {
        return 0;
    214a:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
    214f:	c9                   	leave  
    2150:	c3                   	ret    

00002151 <setImageList>:

void setImageList()
{
    2151:	55                   	push   %ebp
    2152:	89 e5                	mov    %esp,%ebp
    2154:	81 ec 88 00 00 00    	sub    $0x88,%esp
    RGBA image_name_color = {255,0,0,0};
    215a:	c6 45 80 ff          	movb   $0xff,-0x80(%ebp)
    215e:	c6 45 81 00          	movb   $0x0,-0x7f(%ebp)
    2162:	c6 45 82 00          	movb   $0x0,-0x7e(%ebp)
    2166:	c6 45 83 00          	movb   $0x0,-0x7d(%ebp)
    struct RGB *t;
    struct RGB *o;
    int max_line = image_list_size.w;
    216a:	a1 f0 52 02 00       	mov    0x252f0,%eax
    216f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (int i = 0; i < image_list_size.h; i++) {
    2172:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2179:	eb 68                	jmp    21e3 <setImageList+0x92>
        o = wnd.content + (image_list_pos.y + i) * wnd.size.w + image_list_pos.x;
    217b:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    2181:	8b 15 f8 52 02 00    	mov    0x252f8,%edx
    2187:	8b 45 f4             	mov    -0xc(%ebp),%eax
    218a:	01 c2                	add    %eax,%edx
    218c:	a1 b0 58 02 00       	mov    0x258b0,%eax
    2191:	0f af c2             	imul   %edx,%eax
    2194:	89 c2                	mov    %eax,%edx
    2196:	a1 f4 52 02 00       	mov    0x252f4,%eax
    219b:	01 c2                	add    %eax,%edx
    219d:	89 d0                	mov    %edx,%eax
    219f:	01 c0                	add    %eax,%eax
    21a1:	01 d0                	add    %edx,%eax
    21a3:	01 c8                	add    %ecx,%eax
    21a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        t = image_list_origin + i * image_list_size.w;
    21a8:	8b 15 f4 58 02 00    	mov    0x258f4,%edx
    21ae:	a1 f0 52 02 00       	mov    0x252f0,%eax
    21b3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    21b7:	89 c1                	mov    %eax,%ecx
    21b9:	89 c8                	mov    %ecx,%eax
    21bb:	01 c0                	add    %eax,%eax
    21bd:	01 c8                	add    %ecx,%eax
    21bf:	01 d0                	add    %edx,%eax
    21c1:	89 45 e0             	mov    %eax,-0x20(%ebp)
        memmove(o, t, max_line * 3);
    21c4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    21c7:	89 d0                	mov    %edx,%eax
    21c9:	01 c0                	add    %eax,%eax
    21cb:	01 d0                	add    %edx,%eax
    21cd:	83 ec 04             	sub    $0x4,%esp
    21d0:	50                   	push   %eax
    21d1:	ff 75 e0             	pushl  -0x20(%ebp)
    21d4:	ff 75 e4             	pushl  -0x1c(%ebp)
    21d7:	e8 22 4a 00 00       	call   6bfe <memmove>
    21dc:	83 c4 10             	add    $0x10,%esp
{
    RGBA image_name_color = {255,0,0,0};
    struct RGB *t;
    struct RGB *o;
    int max_line = image_list_size.w;
    for (int i = 0; i < image_list_size.h; i++) {
    21df:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    21e3:	a1 ec 52 02 00       	mov    0x252ec,%eax
    21e8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    21eb:	7f 8e                	jg     217b <setImageList+0x2a>
        o = wnd.content + (image_list_pos.y + i) * wnd.size.w + image_list_pos.x;
        t = image_list_origin + i * image_list_size.w;
        memmove(o, t, max_line * 3);
    }
    for(int i=0;i<3;i++)
    21ed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    21f4:	e9 a7 03 00 00       	jmp    25a0 <setImageList+0x44f>
    {
        if(image_show[i]->scale_needed==1)
    21f9:	a1 54 58 02 00       	mov    0x25854,%eax
    21fe:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2201:	c1 e2 02             	shl    $0x2,%edx
    2204:	01 d0                	add    %edx,%eax
    2206:	8b 00                	mov    (%eax),%eax
    2208:	8b 40 18             	mov    0x18(%eax),%eax
    220b:	83 f8 01             	cmp    $0x1,%eax
    220e:	0f 85 06 01 00 00    	jne    231a <setImageList+0x1c9>
        {
            int pos_y=120+130*i-image_show[i]->scale_h/2;
    2214:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2217:	01 c0                	add    %eax,%eax
    2219:	89 c2                	mov    %eax,%edx
    221b:	c1 e2 06             	shl    $0x6,%edx
    221e:	01 d0                	add    %edx,%eax
    2220:	8d 48 78             	lea    0x78(%eax),%ecx
    2223:	a1 54 58 02 00       	mov    0x25854,%eax
    2228:	8b 55 f0             	mov    -0x10(%ebp),%edx
    222b:	c1 e2 02             	shl    $0x2,%edx
    222e:	01 d0                	add    %edx,%eax
    2230:	8b 00                	mov    (%eax),%eax
    2232:	8b 40 24             	mov    0x24(%eax),%eax
    2235:	89 c2                	mov    %eax,%edx
    2237:	c1 ea 1f             	shr    $0x1f,%edx
    223a:	01 d0                	add    %edx,%eax
    223c:	d1 f8                	sar    %eax
    223e:	29 c1                	sub    %eax,%ecx
    2240:	89 c8                	mov    %ecx,%eax
    2242:	89 45 dc             	mov    %eax,-0x24(%ebp)
            int pos_x=70-image_show[i]->scale_w/2;
    2245:	a1 54 58 02 00       	mov    0x25854,%eax
    224a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    224d:	c1 e2 02             	shl    $0x2,%edx
    2250:	01 d0                	add    %edx,%eax
    2252:	8b 00                	mov    (%eax),%eax
    2254:	8b 40 2c             	mov    0x2c(%eax),%eax
    2257:	89 c2                	mov    %eax,%edx
    2259:	c1 ea 1f             	shr    $0x1f,%edx
    225c:	01 d0                	add    %edx,%eax
    225e:	d1 f8                	sar    %eax
    2260:	ba 46 00 00 00       	mov    $0x46,%edx
    2265:	29 c2                	sub    %eax,%edx
    2267:	89 d0                	mov    %edx,%eax
    2269:	89 45 d8             	mov    %eax,-0x28(%ebp)
            api_paint24BitmapToContent(&wnd, image_show[i]->scale_data, (Point){pos_x,pos_y}, (Point){0,0}, (Size){image_show[i]->scale_h,image_show[i]->scale_w},(Size){image_show[i]->scale_h,image_show[i]->scale_w});
    226c:	a1 54 58 02 00       	mov    0x25854,%eax
    2271:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2274:	c1 e2 02             	shl    $0x2,%edx
    2277:	01 d0                	add    %edx,%eax
    2279:	8b 00                	mov    (%eax),%eax
    227b:	8b 40 24             	mov    0x24(%eax),%eax
    227e:	89 45 84             	mov    %eax,-0x7c(%ebp)
    2281:	a1 54 58 02 00       	mov    0x25854,%eax
    2286:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2289:	c1 e2 02             	shl    $0x2,%edx
    228c:	01 d0                	add    %edx,%eax
    228e:	8b 00                	mov    (%eax),%eax
    2290:	8b 40 2c             	mov    0x2c(%eax),%eax
    2293:	89 45 88             	mov    %eax,-0x78(%ebp)
    2296:	a1 54 58 02 00       	mov    0x25854,%eax
    229b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    229e:	c1 e2 02             	shl    $0x2,%edx
    22a1:	01 d0                	add    %edx,%eax
    22a3:	8b 00                	mov    (%eax),%eax
    22a5:	8b 40 24             	mov    0x24(%eax),%eax
    22a8:	89 45 8c             	mov    %eax,-0x74(%ebp)
    22ab:	a1 54 58 02 00       	mov    0x25854,%eax
    22b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    22b3:	c1 e2 02             	shl    $0x2,%edx
    22b6:	01 d0                	add    %edx,%eax
    22b8:	8b 00                	mov    (%eax),%eax
    22ba:	8b 40 2c             	mov    0x2c(%eax),%eax
    22bd:	89 45 90             	mov    %eax,-0x70(%ebp)
    22c0:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    22c7:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    22ce:	8b 45 d8             	mov    -0x28(%ebp),%eax
    22d1:	89 45 9c             	mov    %eax,-0x64(%ebp)
    22d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    22d7:	89 45 a0             	mov    %eax,-0x60(%ebp)
    22da:	a1 54 58 02 00       	mov    0x25854,%eax
    22df:	8b 55 f0             	mov    -0x10(%ebp),%edx
    22e2:	c1 e2 02             	shl    $0x2,%edx
    22e5:	01 d0                	add    %edx,%eax
    22e7:	8b 00                	mov    (%eax),%eax
    22e9:	8b 40 1c             	mov    0x1c(%eax),%eax
    22ec:	83 ec 08             	sub    $0x8,%esp
    22ef:	ff 75 88             	pushl  -0x78(%ebp)
    22f2:	ff 75 84             	pushl  -0x7c(%ebp)
    22f5:	ff 75 90             	pushl  -0x70(%ebp)
    22f8:	ff 75 8c             	pushl  -0x74(%ebp)
    22fb:	ff 75 98             	pushl  -0x68(%ebp)
    22fe:	ff 75 94             	pushl  -0x6c(%ebp)
    2301:	ff 75 a0             	pushl  -0x60(%ebp)
    2304:	ff 75 9c             	pushl  -0x64(%ebp)
    2307:	50                   	push   %eax
    2308:	68 a0 58 02 00       	push   $0x258a0
    230d:	e8 f7 58 00 00       	call   7c09 <api_paint24BitmapToContent>
    2312:	83 c4 30             	add    $0x30,%esp
    2315:	e9 01 01 00 00       	jmp    241b <setImageList+0x2ca>
        }
        else
        {
            int pos_y=120+130*i-image_show[i]->h/2;
    231a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    231d:	01 c0                	add    %eax,%eax
    231f:	89 c2                	mov    %eax,%edx
    2321:	c1 e2 06             	shl    $0x6,%edx
    2324:	01 d0                	add    %edx,%eax
    2326:	8d 48 78             	lea    0x78(%eax),%ecx
    2329:	a1 54 58 02 00       	mov    0x25854,%eax
    232e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2331:	c1 e2 02             	shl    $0x2,%edx
    2334:	01 d0                	add    %edx,%eax
    2336:	8b 00                	mov    (%eax),%eax
    2338:	8b 40 20             	mov    0x20(%eax),%eax
    233b:	89 c2                	mov    %eax,%edx
    233d:	c1 ea 1f             	shr    $0x1f,%edx
    2340:	01 d0                	add    %edx,%eax
    2342:	d1 f8                	sar    %eax
    2344:	29 c1                	sub    %eax,%ecx
    2346:	89 c8                	mov    %ecx,%eax
    2348:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            int pos_x=70-image_show[i]->w/2;
    234b:	a1 54 58 02 00       	mov    0x25854,%eax
    2350:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2353:	c1 e2 02             	shl    $0x2,%edx
    2356:	01 d0                	add    %edx,%eax
    2358:	8b 00                	mov    (%eax),%eax
    235a:	8b 40 28             	mov    0x28(%eax),%eax
    235d:	89 c2                	mov    %eax,%edx
    235f:	c1 ea 1f             	shr    $0x1f,%edx
    2362:	01 d0                	add    %edx,%eax
    2364:	d1 f8                	sar    %eax
    2366:	ba 46 00 00 00       	mov    $0x46,%edx
    236b:	29 c2                	sub    %eax,%edx
    236d:	89 d0                	mov    %edx,%eax
    236f:	89 45 d0             	mov    %eax,-0x30(%ebp)
            api_paint24BitmapToContent(&wnd, image_show[i]->data, (Point){pos_x,pos_y}, (Point){0,0}, (Size){image_show[i]->h,image_show[i]->w},(Size){image_show[i]->h,image_show[i]->w});
    2372:	a1 54 58 02 00       	mov    0x25854,%eax
    2377:	8b 55 f0             	mov    -0x10(%ebp),%edx
    237a:	c1 e2 02             	shl    $0x2,%edx
    237d:	01 d0                	add    %edx,%eax
    237f:	8b 00                	mov    (%eax),%eax
    2381:	8b 40 20             	mov    0x20(%eax),%eax
    2384:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    2387:	a1 54 58 02 00       	mov    0x25854,%eax
    238c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    238f:	c1 e2 02             	shl    $0x2,%edx
    2392:	01 d0                	add    %edx,%eax
    2394:	8b 00                	mov    (%eax),%eax
    2396:	8b 40 28             	mov    0x28(%eax),%eax
    2399:	89 45 a8             	mov    %eax,-0x58(%ebp)
    239c:	a1 54 58 02 00       	mov    0x25854,%eax
    23a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    23a4:	c1 e2 02             	shl    $0x2,%edx
    23a7:	01 d0                	add    %edx,%eax
    23a9:	8b 00                	mov    (%eax),%eax
    23ab:	8b 40 20             	mov    0x20(%eax),%eax
    23ae:	89 45 ac             	mov    %eax,-0x54(%ebp)
    23b1:	a1 54 58 02 00       	mov    0x25854,%eax
    23b6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    23b9:	c1 e2 02             	shl    $0x2,%edx
    23bc:	01 d0                	add    %edx,%eax
    23be:	8b 00                	mov    (%eax),%eax
    23c0:	8b 40 28             	mov    0x28(%eax),%eax
    23c3:	89 45 b0             	mov    %eax,-0x50(%ebp)
    23c6:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
    23cd:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    23d4:	8b 45 d0             	mov    -0x30(%ebp),%eax
    23d7:	89 45 bc             	mov    %eax,-0x44(%ebp)
    23da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    23dd:	89 45 c0             	mov    %eax,-0x40(%ebp)
    23e0:	a1 54 58 02 00       	mov    0x25854,%eax
    23e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    23e8:	c1 e2 02             	shl    $0x2,%edx
    23eb:	01 d0                	add    %edx,%eax
    23ed:	8b 00                	mov    (%eax),%eax
    23ef:	8b 40 14             	mov    0x14(%eax),%eax
    23f2:	83 ec 08             	sub    $0x8,%esp
    23f5:	ff 75 a8             	pushl  -0x58(%ebp)
    23f8:	ff 75 a4             	pushl  -0x5c(%ebp)
    23fb:	ff 75 b0             	pushl  -0x50(%ebp)
    23fe:	ff 75 ac             	pushl  -0x54(%ebp)
    2401:	ff 75 b8             	pushl  -0x48(%ebp)
    2404:	ff 75 b4             	pushl  -0x4c(%ebp)
    2407:	ff 75 c0             	pushl  -0x40(%ebp)
    240a:	ff 75 bc             	pushl  -0x44(%ebp)
    240d:	50                   	push   %eax
    240e:	68 a0 58 02 00       	push   $0x258a0
    2413:	e8 f1 57 00 00       	call   7c09 <api_paint24BitmapToContent>
    2418:	83 c4 30             	add    $0x30,%esp
        }
        int name_len=strlen(image_show[i]->image_name);
    241b:	a1 54 58 02 00       	mov    0x25854,%eax
    2420:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2423:	c1 e2 02             	shl    $0x2,%edx
    2426:	01 d0                	add    %edx,%eax
    2428:	8b 00                	mov    (%eax),%eax
    242a:	8b 00                	mov    (%eax),%eax
    242c:	83 ec 0c             	sub    $0xc,%esp
    242f:	50                   	push   %eax
    2430:	e8 4c 46 00 00       	call   6a81 <strlen>
    2435:	83 c4 10             	add    $0x10,%esp
    2438:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int offset_x;
        if(name_len>15)
    243b:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    243f:	0f 8e e4 00 00 00    	jle    2529 <setImageList+0x3d8>
        {
            char* image_name_slug;
            image_name_slug=(char*)malloc(sizeof(char)*name_len);
    2445:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2448:	83 ec 0c             	sub    $0xc,%esp
    244b:	50                   	push   %eax
    244c:	e8 6c 4c 00 00       	call   70bd <malloc>
    2451:	83 c4 10             	add    $0x10,%esp
    2454:	89 45 c8             	mov    %eax,-0x38(%ebp)
            for(int j=0;j<6;j++) 
    2457:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    245e:	eb 57                	jmp    24b7 <setImageList+0x366>
            {
                image_name_slug[j]=image_show[i]->image_name[j];
    2460:	8b 55 ec             	mov    -0x14(%ebp),%edx
    2463:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2466:	01 c2                	add    %eax,%edx
    2468:	a1 54 58 02 00       	mov    0x25854,%eax
    246d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2470:	c1 e1 02             	shl    $0x2,%ecx
    2473:	01 c8                	add    %ecx,%eax
    2475:	8b 00                	mov    (%eax),%eax
    2477:	8b 08                	mov    (%eax),%ecx
    2479:	8b 45 ec             	mov    -0x14(%ebp),%eax
    247c:	01 c8                	add    %ecx,%eax
    247e:	0f b6 00             	movzbl (%eax),%eax
    2481:	88 02                	mov    %al,(%edx)
                image_name_slug[14-j]=image_show[i]->image_name[name_len-1-j];
    2483:	b8 0e 00 00 00       	mov    $0xe,%eax
    2488:	2b 45 ec             	sub    -0x14(%ebp),%eax
    248b:	89 c2                	mov    %eax,%edx
    248d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2490:	01 c2                	add    %eax,%edx
    2492:	a1 54 58 02 00       	mov    0x25854,%eax
    2497:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    249a:	c1 e1 02             	shl    $0x2,%ecx
    249d:	01 c8                	add    %ecx,%eax
    249f:	8b 00                	mov    (%eax),%eax
    24a1:	8b 00                	mov    (%eax),%eax
    24a3:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    24a6:	83 e9 01             	sub    $0x1,%ecx
    24a9:	2b 4d ec             	sub    -0x14(%ebp),%ecx
    24ac:	01 c8                	add    %ecx,%eax
    24ae:	0f b6 00             	movzbl (%eax),%eax
    24b1:	88 02                	mov    %al,(%edx)
        int offset_x;
        if(name_len>15)
        {
            char* image_name_slug;
            image_name_slug=(char*)malloc(sizeof(char)*name_len);
            for(int j=0;j<6;j++) 
    24b3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    24b7:	83 7d ec 05          	cmpl   $0x5,-0x14(%ebp)
    24bb:	7e a3                	jle    2460 <setImageList+0x30f>
            {
                image_name_slug[j]=image_show[i]->image_name[j];
                image_name_slug[14-j]=image_show[i]->image_name[name_len-1-j];
            }
            image_name_slug[6]='.';
    24bd:	8b 45 c8             	mov    -0x38(%ebp),%eax
    24c0:	83 c0 06             	add    $0x6,%eax
    24c3:	c6 00 2e             	movb   $0x2e,(%eax)
            image_name_slug[7]='.';
    24c6:	8b 45 c8             	mov    -0x38(%ebp),%eax
    24c9:	83 c0 07             	add    $0x7,%eax
    24cc:	c6 00 2e             	movb   $0x2e,(%eax)
            image_name_slug[8]='.';
    24cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
    24d2:	83 c0 08             	add    $0x8,%eax
    24d5:	c6 00 2e             	movb   $0x2e,(%eax)
            name_len=15;
    24d8:	c7 45 cc 0f 00 00 00 	movl   $0xf,-0x34(%ebp)
            offset_x=(140-name_len*9)/2;
    24df:	8b 55 cc             	mov    -0x34(%ebp),%edx
    24e2:	89 d0                	mov    %edx,%eax
    24e4:	c1 e0 03             	shl    $0x3,%eax
    24e7:	01 d0                	add    %edx,%eax
    24e9:	f7 d8                	neg    %eax
    24eb:	05 8c 00 00 00       	add    $0x8c,%eax
    24f0:	89 c2                	mov    %eax,%edx
    24f2:	c1 ea 1f             	shr    $0x1f,%edx
    24f5:	01 d0                	add    %edx,%eax
    24f7:	d1 f8                	sar    %eax
    24f9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            api_drawString(&wnd, offset_x, 80+130*i+90, image_name_slug, image_name_color);
    24fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24ff:	01 c0                	add    %eax,%eax
    2501:	89 c2                	mov    %eax,%edx
    2503:	c1 e2 06             	shl    $0x6,%edx
    2506:	01 d0                	add    %edx,%eax
    2508:	05 aa 00 00 00       	add    $0xaa,%eax
    250d:	83 ec 0c             	sub    $0xc,%esp
    2510:	ff 75 80             	pushl  -0x80(%ebp)
    2513:	ff 75 c8             	pushl  -0x38(%ebp)
    2516:	50                   	push   %eax
    2517:	ff 75 c4             	pushl  -0x3c(%ebp)
    251a:	68 a0 58 02 00       	push   $0x258a0
    251f:	e8 9e 58 00 00       	call   7dc2 <api_drawString>
    2524:	83 c4 20             	add    $0x20,%esp
    2527:	eb 63                	jmp    258c <setImageList+0x43b>
        }
        else if(name_len<=15 && name_len>=0)
    2529:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    252d:	7f 5d                	jg     258c <setImageList+0x43b>
    252f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    2533:	78 57                	js     258c <setImageList+0x43b>
        {
            offset_x=(140-name_len*9)/2;       
    2535:	8b 55 cc             	mov    -0x34(%ebp),%edx
    2538:	89 d0                	mov    %edx,%eax
    253a:	c1 e0 03             	shl    $0x3,%eax
    253d:	01 d0                	add    %edx,%eax
    253f:	f7 d8                	neg    %eax
    2541:	05 8c 00 00 00       	add    $0x8c,%eax
    2546:	89 c2                	mov    %eax,%edx
    2548:	c1 ea 1f             	shr    $0x1f,%edx
    254b:	01 d0                	add    %edx,%eax
    254d:	d1 f8                	sar    %eax
    254f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            api_drawString(&wnd, offset_x, 80+130*i+90, image_show[i]->image_name, image_name_color);
    2552:	a1 54 58 02 00       	mov    0x25854,%eax
    2557:	8b 55 f0             	mov    -0x10(%ebp),%edx
    255a:	c1 e2 02             	shl    $0x2,%edx
    255d:	01 d0                	add    %edx,%eax
    255f:	8b 00                	mov    (%eax),%eax
    2561:	8b 10                	mov    (%eax),%edx
    2563:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2566:	01 c0                	add    %eax,%eax
    2568:	89 c1                	mov    %eax,%ecx
    256a:	c1 e1 06             	shl    $0x6,%ecx
    256d:	01 c8                	add    %ecx,%eax
    256f:	05 aa 00 00 00       	add    $0xaa,%eax
    2574:	83 ec 0c             	sub    $0xc,%esp
    2577:	ff 75 80             	pushl  -0x80(%ebp)
    257a:	52                   	push   %edx
    257b:	50                   	push   %eax
    257c:	ff 75 c4             	pushl  -0x3c(%ebp)
    257f:	68 a0 58 02 00       	push   $0x258a0
    2584:	e8 39 58 00 00       	call   7dc2 <api_drawString>
    2589:	83 c4 20             	add    $0x20,%esp
        }
        api_repaint(&wnd);
    258c:	83 ec 0c             	sub    $0xc,%esp
    258f:	68 a0 58 02 00       	push   $0x258a0
    2594:	e8 f0 56 00 00       	call   7c89 <api_repaint>
    2599:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < image_list_size.h; i++) {
        o = wnd.content + (image_list_pos.y + i) * wnd.size.w + image_list_pos.x;
        t = image_list_origin + i * image_list_size.w;
        memmove(o, t, max_line * 3);
    }
    for(int i=0;i<3;i++)
    259c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    25a0:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    25a4:	0f 8e 4f fc ff ff    	jle    21f9 <setImageList+0xa8>
            offset_x=(140-name_len*9)/2;       
            api_drawString(&wnd, offset_x, 80+130*i+90, image_show[i]->image_name, image_name_color);
        }
        api_repaint(&wnd);
    }
}
    25aa:	90                   	nop
    25ab:	c9                   	leave  
    25ac:	c3                   	ret    

000025ad <isMouseInListUpButton>:

int isMouseInListUpButton(int x, int y) {
    25ad:	55                   	push   %ebp
    25ae:	89 e5                	mov    %esp,%ebp
    25b0:	83 ec 08             	sub    $0x8,%esp
   if (47 <= x && x <= 82 && 45 <= y && y <= 65){
    25b3:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
    25b7:	7e 78                	jle    2631 <isMouseInListUpButton+0x84>
    25b9:	83 7d 08 52          	cmpl   $0x52,0x8(%ebp)
    25bd:	7f 72                	jg     2631 <isMouseInListUpButton+0x84>
    25bf:	83 7d 0c 2c          	cmpl   $0x2c,0xc(%ebp)
    25c3:	7e 6c                	jle    2631 <isMouseInListUpButton+0x84>
    25c5:	83 7d 0c 41          	cmpl   $0x41,0xc(%ebp)
    25c9:	7f 66                	jg     2631 <isMouseInListUpButton+0x84>
        if(image_show[0]->prev==0) return 1;
    25cb:	a1 54 58 02 00       	mov    0x25854,%eax
    25d0:	8b 00                	mov    (%eax),%eax
    25d2:	8b 40 34             	mov    0x34(%eax),%eax
    25d5:	85 c0                	test   %eax,%eax
    25d7:	75 07                	jne    25e0 <isMouseInListUpButton+0x33>
    25d9:	b8 01 00 00 00       	mov    $0x1,%eax
    25de:	eb 56                	jmp    2636 <isMouseInListUpButton+0x89>
        else
        {
            image_show[2]=image_show[1];
    25e0:	a1 54 58 02 00       	mov    0x25854,%eax
    25e5:	8d 50 08             	lea    0x8(%eax),%edx
    25e8:	a1 54 58 02 00       	mov    0x25854,%eax
    25ed:	8b 40 04             	mov    0x4(%eax),%eax
    25f0:	89 02                	mov    %eax,(%edx)
            image_show[1]=image_show[0];
    25f2:	a1 54 58 02 00       	mov    0x25854,%eax
    25f7:	8d 50 04             	lea    0x4(%eax),%edx
    25fa:	a1 54 58 02 00       	mov    0x25854,%eax
    25ff:	8b 00                	mov    (%eax),%eax
    2601:	89 02                	mov    %eax,(%edx)
            image_show[0]=image_show[0]->prev;
    2603:	a1 54 58 02 00       	mov    0x25854,%eax
    2608:	8b 15 54 58 02 00    	mov    0x25854,%edx
    260e:	8b 12                	mov    (%edx),%edx
    2610:	8b 52 34             	mov    0x34(%edx),%edx
    2613:	89 10                	mov    %edx,(%eax)
            setImageList();
    2615:	e8 37 fb ff ff       	call   2151 <setImageList>
            api_repaint(&wnd);
    261a:	83 ec 0c             	sub    $0xc,%esp
    261d:	68 a0 58 02 00       	push   $0x258a0
    2622:	e8 62 56 00 00       	call   7c89 <api_repaint>
    2627:	83 c4 10             	add    $0x10,%esp
        }
        return 1;
    262a:	b8 01 00 00 00       	mov    $0x1,%eax
    262f:	eb 05                	jmp    2636 <isMouseInListUpButton+0x89>
   }
   else {
        return 0;
    2631:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    2636:	c9                   	leave  
    2637:	c3                   	ret    

00002638 <isMouseInListDownButton>:

int isMouseInListDownButton(int x, int y) {
    2638:	55                   	push   %ebp
    2639:	89 e5                	mov    %esp,%ebp
    263b:	83 ec 08             	sub    $0x8,%esp
   if (47 <= x && x <= 82 && 465 <= y && y <= 485){
    263e:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
    2642:	0f 8e 85 00 00 00    	jle    26cd <isMouseInListDownButton+0x95>
    2648:	83 7d 08 52          	cmpl   $0x52,0x8(%ebp)
    264c:	7f 7f                	jg     26cd <isMouseInListDownButton+0x95>
    264e:	81 7d 0c d0 01 00 00 	cmpl   $0x1d0,0xc(%ebp)
    2655:	7e 76                	jle    26cd <isMouseInListDownButton+0x95>
    2657:	81 7d 0c e5 01 00 00 	cmpl   $0x1e5,0xc(%ebp)
    265e:	7f 6d                	jg     26cd <isMouseInListDownButton+0x95>
        if(image_show[2]->next==0) return 1;
    2660:	a1 54 58 02 00       	mov    0x25854,%eax
    2665:	83 c0 08             	add    $0x8,%eax
    2668:	8b 00                	mov    (%eax),%eax
    266a:	8b 40 38             	mov    0x38(%eax),%eax
    266d:	85 c0                	test   %eax,%eax
    266f:	75 07                	jne    2678 <isMouseInListDownButton+0x40>
    2671:	b8 01 00 00 00       	mov    $0x1,%eax
    2676:	eb 5a                	jmp    26d2 <isMouseInListDownButton+0x9a>
        else
        {
            image_show[0]=image_show[1];
    2678:	a1 54 58 02 00       	mov    0x25854,%eax
    267d:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2683:	8b 52 04             	mov    0x4(%edx),%edx
    2686:	89 10                	mov    %edx,(%eax)
            image_show[1]=image_show[2];
    2688:	a1 54 58 02 00       	mov    0x25854,%eax
    268d:	8d 50 04             	lea    0x4(%eax),%edx
    2690:	a1 54 58 02 00       	mov    0x25854,%eax
    2695:	8b 40 08             	mov    0x8(%eax),%eax
    2698:	89 02                	mov    %eax,(%edx)
            image_show[2]=image_show[2]->next;
    269a:	a1 54 58 02 00       	mov    0x25854,%eax
    269f:	8d 50 08             	lea    0x8(%eax),%edx
    26a2:	a1 54 58 02 00       	mov    0x25854,%eax
    26a7:	83 c0 08             	add    $0x8,%eax
    26aa:	8b 00                	mov    (%eax),%eax
    26ac:	8b 40 38             	mov    0x38(%eax),%eax
    26af:	89 02                	mov    %eax,(%edx)
            setImageList();
    26b1:	e8 9b fa ff ff       	call   2151 <setImageList>
            api_repaint(&wnd);
    26b6:	83 ec 0c             	sub    $0xc,%esp
    26b9:	68 a0 58 02 00       	push   $0x258a0
    26be:	e8 c6 55 00 00       	call   7c89 <api_repaint>
    26c3:	83 c4 10             	add    $0x10,%esp
        }
        return 1;
    26c6:	b8 01 00 00 00       	mov    $0x1,%eax
    26cb:	eb 05                	jmp    26d2 <isMouseInListDownButton+0x9a>
   }
   else {
        return 0;
    26cd:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    26d2:	c9                   	leave  
    26d3:	c3                   	ret    

000026d4 <showImageInContent>:

void showImageInContent()
{
    26d4:	55                   	push   %ebp
    26d5:	89 e5                	mov    %esp,%ebp
    26d7:	56                   	push   %esi
    26d8:	53                   	push   %ebx
    26d9:	83 ec 70             	sub    $0x70,%esp
    RGBA image_name_color = {255,0,0,0};
    26dc:	c6 45 90 ff          	movb   $0xff,-0x70(%ebp)
    26e0:	c6 45 91 00          	movb   $0x0,-0x6f(%ebp)
    26e4:	c6 45 92 00          	movb   $0x0,-0x6e(%ebp)
    26e8:	c6 45 93 00          	movb   $0x0,-0x6d(%ebp)
    struct RGB *t;
    struct RGB *o;
    int max_line = edit_img_size.w;
    26ec:	a1 e0 52 02 00       	mov    0x252e0,%eax
    26f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for (int i = 0; i < edit_img_size.h; i++) {
    26f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    26fb:	eb 68                	jmp    2765 <showImageInContent+0x91>
        o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    26fd:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    2703:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    2709:	8b 45 f4             	mov    -0xc(%ebp),%eax
    270c:	01 c2                	add    %eax,%edx
    270e:	a1 b0 58 02 00       	mov    0x258b0,%eax
    2713:	0f af c2             	imul   %edx,%eax
    2716:	89 c2                	mov    %eax,%edx
    2718:	a1 e4 52 02 00       	mov    0x252e4,%eax
    271d:	01 c2                	add    %eax,%edx
    271f:	89 d0                	mov    %edx,%eax
    2721:	01 c0                	add    %eax,%eax
    2723:	01 d0                	add    %edx,%eax
    2725:	01 c8                	add    %ecx,%eax
    2727:	89 45 e8             	mov    %eax,-0x18(%ebp)
        t = edit_img_origin + i * edit_img_size.w;
    272a:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    2730:	a1 e0 52 02 00       	mov    0x252e0,%eax
    2735:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2739:	89 c1                	mov    %eax,%ecx
    273b:	89 c8                	mov    %ecx,%eax
    273d:	01 c0                	add    %eax,%eax
    273f:	01 c8                	add    %ecx,%eax
    2741:	01 d0                	add    %edx,%eax
    2743:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(o, t, max_line * 3);
    2746:	8b 55 ec             	mov    -0x14(%ebp),%edx
    2749:	89 d0                	mov    %edx,%eax
    274b:	01 c0                	add    %eax,%eax
    274d:	01 d0                	add    %edx,%eax
    274f:	83 ec 04             	sub    $0x4,%esp
    2752:	50                   	push   %eax
    2753:	ff 75 e4             	pushl  -0x1c(%ebp)
    2756:	ff 75 e8             	pushl  -0x18(%ebp)
    2759:	e8 a0 44 00 00       	call   6bfe <memmove>
    275e:	83 c4 10             	add    $0x10,%esp
{
    RGBA image_name_color = {255,0,0,0};
    struct RGB *t;
    struct RGB *o;
    int max_line = edit_img_size.w;
    for (int i = 0; i < edit_img_size.h; i++) {
    2761:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2765:	a1 dc 52 02 00       	mov    0x252dc,%eax
    276a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    276d:	7f 8e                	jg     26fd <showImageInContent+0x29>
        o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
        t = edit_img_origin + i * edit_img_size.w;
        memmove(o, t, max_line * 3);
    }
    max_line = image_title_size.w;
    276f:	a1 00 53 02 00       	mov    0x25300,%eax
    2774:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for (int i = 0; i < image_title_size.h; i++) {
    2777:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    277e:	eb 68                	jmp    27e8 <showImageInContent+0x114>
        o = wnd.content + (image_title_pos.y + i) * wnd.size.w + image_title_pos.x;
    2780:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    2786:	8b 15 08 53 02 00    	mov    0x25308,%edx
    278c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    278f:	01 c2                	add    %eax,%edx
    2791:	a1 b0 58 02 00       	mov    0x258b0,%eax
    2796:	0f af c2             	imul   %edx,%eax
    2799:	89 c2                	mov    %eax,%edx
    279b:	a1 04 53 02 00       	mov    0x25304,%eax
    27a0:	01 c2                	add    %eax,%edx
    27a2:	89 d0                	mov    %edx,%eax
    27a4:	01 c0                	add    %eax,%eax
    27a6:	01 d0                	add    %edx,%eax
    27a8:	01 c8                	add    %ecx,%eax
    27aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
        t = image_title_origin + i * image_title_size.w;
    27ad:	8b 15 fc 58 02 00    	mov    0x258fc,%edx
    27b3:	a1 00 53 02 00       	mov    0x25300,%eax
    27b8:	0f af 45 f0          	imul   -0x10(%ebp),%eax
    27bc:	89 c1                	mov    %eax,%ecx
    27be:	89 c8                	mov    %ecx,%eax
    27c0:	01 c0                	add    %eax,%eax
    27c2:	01 c8                	add    %ecx,%eax
    27c4:	01 d0                	add    %edx,%eax
    27c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(o, t, max_line * 3);
    27c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    27cc:	89 d0                	mov    %edx,%eax
    27ce:	01 c0                	add    %eax,%eax
    27d0:	01 d0                	add    %edx,%eax
    27d2:	83 ec 04             	sub    $0x4,%esp
    27d5:	50                   	push   %eax
    27d6:	ff 75 e4             	pushl  -0x1c(%ebp)
    27d9:	ff 75 e8             	pushl  -0x18(%ebp)
    27dc:	e8 1d 44 00 00       	call   6bfe <memmove>
    27e1:	83 c4 10             	add    $0x10,%esp
        o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
        t = edit_img_origin + i * edit_img_size.w;
        memmove(o, t, max_line * 3);
    }
    max_line = image_title_size.w;
    for (int i = 0; i < image_title_size.h; i++) {
    27e4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    27e8:	a1 fc 52 02 00       	mov    0x252fc,%eax
    27ed:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    27f0:	7f 8e                	jg     2780 <showImageInContent+0xac>
        o = wnd.content + (image_title_pos.y + i) * wnd.size.w + image_title_pos.x;
        t = image_title_origin + i * image_title_size.w;
        memmove(o, t, max_line * 3);
    }
    printf(1, "%s, %d, %d, %d\n", image_show[image_item-1]->image_name, image_show[image_item-1]->w, image_show[image_item-1]->h, image_show[image_item-1]->gif_img_num);
    27f2:	a1 54 58 02 00       	mov    0x25854,%eax
    27f7:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    27fd:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2803:	c1 e2 02             	shl    $0x2,%edx
    2806:	01 d0                	add    %edx,%eax
    2808:	8b 00                	mov    (%eax),%eax
    280a:	8b 58 0c             	mov    0xc(%eax),%ebx
    280d:	a1 54 58 02 00       	mov    0x25854,%eax
    2812:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2818:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    281e:	c1 e2 02             	shl    $0x2,%edx
    2821:	01 d0                	add    %edx,%eax
    2823:	8b 00                	mov    (%eax),%eax
    2825:	8b 48 20             	mov    0x20(%eax),%ecx
    2828:	a1 54 58 02 00       	mov    0x25854,%eax
    282d:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2833:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2839:	c1 e2 02             	shl    $0x2,%edx
    283c:	01 d0                	add    %edx,%eax
    283e:	8b 00                	mov    (%eax),%eax
    2840:	8b 50 28             	mov    0x28(%eax),%edx
    2843:	a1 54 58 02 00       	mov    0x25854,%eax
    2848:	8b 35 a8 57 02 00    	mov    0x257a8,%esi
    284e:	81 c6 ff ff ff 3f    	add    $0x3fffffff,%esi
    2854:	c1 e6 02             	shl    $0x2,%esi
    2857:	01 f0                	add    %esi,%eax
    2859:	8b 00                	mov    (%eax),%eax
    285b:	8b 00                	mov    (%eax),%eax
    285d:	83 ec 08             	sub    $0x8,%esp
    2860:	53                   	push   %ebx
    2861:	51                   	push   %ecx
    2862:	52                   	push   %edx
    2863:	50                   	push   %eax
    2864:	68 13 c8 01 00       	push   $0x1c813
    2869:	6a 01                	push   $0x1
    286b:	e8 7a 45 00 00       	call   6dea <printf>
    2870:	83 c4 20             	add    $0x20,%esp
    if(image_show[image_item-1]->gif_img_num>1)
    2873:	a1 54 58 02 00       	mov    0x25854,%eax
    2878:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    287e:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2884:	c1 e2 02             	shl    $0x2,%edx
    2887:	01 d0                	add    %edx,%eax
    2889:	8b 00                	mov    (%eax),%eax
    288b:	8b 40 0c             	mov    0xc(%eax),%eax
    288e:	83 f8 01             	cmp    $0x1,%eax
    2891:	0f 8e 9c 03 00 00    	jle    2c33 <showImageInContent+0x55f>
    {
        free(current_gif_img);
    2897:	a1 84 58 02 00       	mov    0x25884,%eax
    289c:	83 ec 0c             	sub    $0xc,%esp
    289f:	50                   	push   %eax
    28a0:	e8 d6 46 00 00       	call   6f7b <free>
    28a5:	83 c4 10             	add    $0x10,%esp
        int pos_y=235-(image_show[image_item-1]->h/image_show[image_item-1]->gif_img_num)/2;
    28a8:	a1 54 58 02 00       	mov    0x25854,%eax
    28ad:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    28b3:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    28b9:	c1 e2 02             	shl    $0x2,%edx
    28bc:	01 d0                	add    %edx,%eax
    28be:	8b 00                	mov    (%eax),%eax
    28c0:	8b 40 20             	mov    0x20(%eax),%eax
    28c3:	8b 15 54 58 02 00    	mov    0x25854,%edx
    28c9:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    28cf:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    28d5:	c1 e1 02             	shl    $0x2,%ecx
    28d8:	01 ca                	add    %ecx,%edx
    28da:	8b 12                	mov    (%edx),%edx
    28dc:	8b 5a 0c             	mov    0xc(%edx),%ebx
    28df:	99                   	cltd   
    28e0:	f7 fb                	idiv   %ebx
    28e2:	89 c2                	mov    %eax,%edx
    28e4:	c1 ea 1f             	shr    $0x1f,%edx
    28e7:	01 d0                	add    %edx,%eax
    28e9:	d1 f8                	sar    %eax
    28eb:	ba eb 00 00 00       	mov    $0xeb,%edx
    28f0:	29 c2                	sub    %eax,%edx
    28f2:	89 d0                	mov    %edx,%eax
    28f4:	89 45 e0             	mov    %eax,-0x20(%ebp)
        int pos_x=390-image_show[image_item-1]->w/2;
    28f7:	a1 54 58 02 00       	mov    0x25854,%eax
    28fc:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2902:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2908:	c1 e2 02             	shl    $0x2,%edx
    290b:	01 d0                	add    %edx,%eax
    290d:	8b 00                	mov    (%eax),%eax
    290f:	8b 40 28             	mov    0x28(%eax),%eax
    2912:	89 c2                	mov    %eax,%edx
    2914:	c1 ea 1f             	shr    $0x1f,%edx
    2917:	01 d0                	add    %edx,%eax
    2919:	d1 f8                	sar    %eax
    291b:	ba 86 01 00 00       	mov    $0x186,%edx
    2920:	29 c2                	sub    %eax,%edx
    2922:	89 d0                	mov    %edx,%eax
    2924:	89 45 dc             	mov    %eax,-0x24(%ebp)
        api_paint24BitmapToContent(&wnd, image_show[image_item-1]->data, (Point){pos_x,pos_y}, (Point){0,(image_show[image_item-1]->h/image_show[image_item-1]->gif_img_num)*(gif_frame-1)},(Size){image_show[image_item-1]->h,image_show[image_item-1]->w},(Size){(image_show[image_item-1]->h/image_show[image_item-1]->gif_img_num),image_show[image_item-1]->w});
    2927:	a1 54 58 02 00       	mov    0x25854,%eax
    292c:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2932:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2938:	c1 e2 02             	shl    $0x2,%edx
    293b:	01 d0                	add    %edx,%eax
    293d:	8b 00                	mov    (%eax),%eax
    293f:	8b 40 20             	mov    0x20(%eax),%eax
    2942:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2948:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    294e:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2954:	c1 e1 02             	shl    $0x2,%ecx
    2957:	01 ca                	add    %ecx,%edx
    2959:	8b 12                	mov    (%edx),%edx
    295b:	8b 5a 0c             	mov    0xc(%edx),%ebx
    295e:	99                   	cltd   
    295f:	f7 fb                	idiv   %ebx
    2961:	89 45 94             	mov    %eax,-0x6c(%ebp)
    2964:	a1 54 58 02 00       	mov    0x25854,%eax
    2969:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    296f:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2975:	c1 e2 02             	shl    $0x2,%edx
    2978:	01 d0                	add    %edx,%eax
    297a:	8b 00                	mov    (%eax),%eax
    297c:	8b 40 28             	mov    0x28(%eax),%eax
    297f:	89 45 98             	mov    %eax,-0x68(%ebp)
    2982:	a1 54 58 02 00       	mov    0x25854,%eax
    2987:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    298d:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2993:	c1 e2 02             	shl    $0x2,%edx
    2996:	01 d0                	add    %edx,%eax
    2998:	8b 00                	mov    (%eax),%eax
    299a:	8b 40 20             	mov    0x20(%eax),%eax
    299d:	89 45 9c             	mov    %eax,-0x64(%ebp)
    29a0:	a1 54 58 02 00       	mov    0x25854,%eax
    29a5:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    29ab:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    29b1:	c1 e2 02             	shl    $0x2,%edx
    29b4:	01 d0                	add    %edx,%eax
    29b6:	8b 00                	mov    (%eax),%eax
    29b8:	8b 40 28             	mov    0x28(%eax),%eax
    29bb:	89 45 a0             	mov    %eax,-0x60(%ebp)
    29be:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
    29c5:	a1 54 58 02 00       	mov    0x25854,%eax
    29ca:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    29d0:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    29d6:	c1 e2 02             	shl    $0x2,%edx
    29d9:	01 d0                	add    %edx,%eax
    29db:	8b 00                	mov    (%eax),%eax
    29dd:	8b 40 20             	mov    0x20(%eax),%eax
    29e0:	8b 15 54 58 02 00    	mov    0x25854,%edx
    29e6:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    29ec:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    29f2:	c1 e1 02             	shl    $0x2,%ecx
    29f5:	01 ca                	add    %ecx,%edx
    29f7:	8b 12                	mov    (%edx),%edx
    29f9:	8b 5a 0c             	mov    0xc(%edx),%ebx
    29fc:	99                   	cltd   
    29fd:	f7 fb                	idiv   %ebx
    29ff:	89 c2                	mov    %eax,%edx
    2a01:	a1 2c 53 02 00       	mov    0x2532c,%eax
    2a06:	83 e8 01             	sub    $0x1,%eax
    2a09:	0f af c2             	imul   %edx,%eax
    2a0c:	89 45 a8             	mov    %eax,-0x58(%ebp)
    2a0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2a12:	89 45 ac             	mov    %eax,-0x54(%ebp)
    2a15:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2a18:	89 45 b0             	mov    %eax,-0x50(%ebp)
    2a1b:	a1 54 58 02 00       	mov    0x25854,%eax
    2a20:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2a26:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2a2c:	c1 e2 02             	shl    $0x2,%edx
    2a2f:	01 d0                	add    %edx,%eax
    2a31:	8b 00                	mov    (%eax),%eax
    2a33:	8b 40 14             	mov    0x14(%eax),%eax
    2a36:	83 ec 08             	sub    $0x8,%esp
    2a39:	ff 75 98             	pushl  -0x68(%ebp)
    2a3c:	ff 75 94             	pushl  -0x6c(%ebp)
    2a3f:	ff 75 a0             	pushl  -0x60(%ebp)
    2a42:	ff 75 9c             	pushl  -0x64(%ebp)
    2a45:	ff 75 a8             	pushl  -0x58(%ebp)
    2a48:	ff 75 a4             	pushl  -0x5c(%ebp)
    2a4b:	ff 75 b0             	pushl  -0x50(%ebp)
    2a4e:	ff 75 ac             	pushl  -0x54(%ebp)
    2a51:	50                   	push   %eax
    2a52:	68 a0 58 02 00       	push   $0x258a0
    2a57:	e8 ad 51 00 00       	call   7c09 <api_paint24BitmapToContent>
    2a5c:	83 c4 30             	add    $0x30,%esp
        api_drawString(&wnd, 140, 6, image_show[image_item-1]->image_name, image_name_color);
    2a5f:	a1 54 58 02 00       	mov    0x25854,%eax
    2a64:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2a6a:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2a70:	c1 e2 02             	shl    $0x2,%edx
    2a73:	01 d0                	add    %edx,%eax
    2a75:	8b 00                	mov    (%eax),%eax
    2a77:	8b 00                	mov    (%eax),%eax
    2a79:	83 ec 0c             	sub    $0xc,%esp
    2a7c:	ff 75 90             	pushl  -0x70(%ebp)
    2a7f:	50                   	push   %eax
    2a80:	6a 06                	push   $0x6
    2a82:	68 8c 00 00 00       	push   $0x8c
    2a87:	68 a0 58 02 00       	push   $0x258a0
    2a8c:	e8 31 53 00 00       	call   7dc2 <api_drawString>
    2a91:	83 c4 20             	add    $0x20,%esp
        gif_frame = (gif_frame % image_show[image_item-1]->gif_img_num ) + 1;
    2a94:	a1 2c 53 02 00       	mov    0x2532c,%eax
    2a99:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2a9f:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    2aa5:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2aab:	c1 e1 02             	shl    $0x2,%ecx
    2aae:	01 ca                	add    %ecx,%edx
    2ab0:	8b 12                	mov    (%edx),%edx
    2ab2:	8b 4a 0c             	mov    0xc(%edx),%ecx
    2ab5:	99                   	cltd   
    2ab6:	f7 f9                	idiv   %ecx
    2ab8:	89 d0                	mov    %edx,%eax
    2aba:	83 c0 01             	add    $0x1,%eax
    2abd:	a3 2c 53 02 00       	mov    %eax,0x2532c
        current_gif_img = (Image*)malloc(sizeof(Image));
    2ac2:	83 ec 0c             	sub    $0xc,%esp
    2ac5:	6a 3c                	push   $0x3c
    2ac7:	e8 f1 45 00 00       	call   70bd <malloc>
    2acc:	83 c4 10             	add    $0x10,%esp
    2acf:	a3 84 58 02 00       	mov    %eax,0x25884
        current_gif_img->data = image_show[image_item-1]->data;
    2ad4:	a1 84 58 02 00       	mov    0x25884,%eax
    2ad9:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2adf:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    2ae5:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2aeb:	c1 e1 02             	shl    $0x2,%ecx
    2aee:	01 ca                	add    %ecx,%edx
    2af0:	8b 12                	mov    (%edx),%edx
    2af2:	8b 52 14             	mov    0x14(%edx),%edx
    2af5:	89 50 14             	mov    %edx,0x14(%eax)
        current_gif_img->h = image_show[image_item-1]->h;
    2af8:	a1 84 58 02 00       	mov    0x25884,%eax
    2afd:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2b03:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    2b09:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2b0f:	c1 e1 02             	shl    $0x2,%ecx
    2b12:	01 ca                	add    %ecx,%edx
    2b14:	8b 12                	mov    (%edx),%edx
    2b16:	8b 52 20             	mov    0x20(%edx),%edx
    2b19:	89 50 20             	mov    %edx,0x20(%eax)
        current_gif_img->w = image_show[image_item-1]->w;
    2b1c:	a1 84 58 02 00       	mov    0x25884,%eax
    2b21:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2b27:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    2b2d:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2b33:	c1 e1 02             	shl    $0x2,%ecx
    2b36:	01 ca                	add    %ecx,%edx
    2b38:	8b 12                	mov    (%edx),%edx
    2b3a:	8b 52 28             	mov    0x28(%edx),%edx
    2b3d:	89 50 28             	mov    %edx,0x28(%eax)
        current_gif_img->gif_img_num = image_show[image_item-1]->gif_img_num;
    2b40:	a1 84 58 02 00       	mov    0x25884,%eax
    2b45:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2b4b:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    2b51:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2b57:	c1 e1 02             	shl    $0x2,%ecx
    2b5a:	01 ca                	add    %ecx,%edx
    2b5c:	8b 12                	mov    (%edx),%edx
    2b5e:	8b 52 0c             	mov    0xc(%edx),%edx
    2b61:	89 50 0c             	mov    %edx,0xc(%eax)
        current_gif_img->is_onshow = 1;
    2b64:	a1 84 58 02 00       	mov    0x25884,%eax
    2b69:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
        has_content = 1;
    2b70:	c7 05 a4 57 02 00 01 	movl   $0x1,0x257a4
    2b77:	00 00 00 
        content_size=(Size){(image_show[image_item-1]->h/image_show[image_item-1]->gif_img_num),image_show[image_item-1]->w};
    2b7a:	a1 54 58 02 00       	mov    0x25854,%eax
    2b7f:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2b85:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2b8b:	c1 e2 02             	shl    $0x2,%edx
    2b8e:	01 d0                	add    %edx,%eax
    2b90:	8b 00                	mov    (%eax),%eax
    2b92:	8b 40 20             	mov    0x20(%eax),%eax
    2b95:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2b9b:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    2ba1:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2ba7:	c1 e1 02             	shl    $0x2,%ecx
    2baa:	01 ca                	add    %ecx,%edx
    2bac:	8b 12                	mov    (%edx),%edx
    2bae:	8b 5a 0c             	mov    0xc(%edx),%ebx
    2bb1:	99                   	cltd   
    2bb2:	f7 fb                	idiv   %ebx
    2bb4:	89 c1                	mov    %eax,%ecx
    2bb6:	a1 54 58 02 00       	mov    0x25854,%eax
    2bbb:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2bc1:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2bc7:	c1 e2 02             	shl    $0x2,%edx
    2bca:	01 d0                	add    %edx,%eax
    2bcc:	8b 00                	mov    (%eax),%eax
    2bce:	8b 40 28             	mov    0x28(%eax),%eax
    2bd1:	89 0d 0c 53 02 00    	mov    %ecx,0x2530c
    2bd7:	a3 10 53 02 00       	mov    %eax,0x25310
        content_pos=(Point){140 + (500-content_size.w)/2,30 + (410-content_size.h)/2};
    2bdc:	a1 10 53 02 00       	mov    0x25310,%eax
    2be1:	ba f4 01 00 00       	mov    $0x1f4,%edx
    2be6:	29 c2                	sub    %eax,%edx
    2be8:	89 d0                	mov    %edx,%eax
    2bea:	89 c2                	mov    %eax,%edx
    2bec:	c1 ea 1f             	shr    $0x1f,%edx
    2bef:	01 d0                	add    %edx,%eax
    2bf1:	d1 f8                	sar    %eax
    2bf3:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
    2bf9:	a1 0c 53 02 00       	mov    0x2530c,%eax
    2bfe:	b9 9a 01 00 00       	mov    $0x19a,%ecx
    2c03:	29 c1                	sub    %eax,%ecx
    2c05:	89 c8                	mov    %ecx,%eax
    2c07:	89 c1                	mov    %eax,%ecx
    2c09:	c1 e9 1f             	shr    $0x1f,%ecx
    2c0c:	01 c8                	add    %ecx,%eax
    2c0e:	d1 f8                	sar    %eax
    2c10:	83 c0 1e             	add    $0x1e,%eax
    2c13:	89 15 1c 53 02 00    	mov    %edx,0x2531c
    2c19:	a3 20 53 02 00       	mov    %eax,0x25320
        scale_degree=1;
    2c1e:	d9 e8                	fld1   
    2c20:	d9 1d 30 53 02 00    	fstps  0x25330
        turn_degree=0;
    2c26:	d9 ee                	fldz   
    2c28:	d9 1d b0 57 02 00    	fstps  0x257b0
    2c2e:	e9 3c 03 00 00       	jmp    2f6f <showImageInContent+0x89b>
    }
    else
    {
        int pos_y=235-image_show[image_item-1]->h/2;
    2c33:	a1 54 58 02 00       	mov    0x25854,%eax
    2c38:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2c3e:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2c44:	c1 e2 02             	shl    $0x2,%edx
    2c47:	01 d0                	add    %edx,%eax
    2c49:	8b 00                	mov    (%eax),%eax
    2c4b:	8b 40 20             	mov    0x20(%eax),%eax
    2c4e:	89 c2                	mov    %eax,%edx
    2c50:	c1 ea 1f             	shr    $0x1f,%edx
    2c53:	01 d0                	add    %edx,%eax
    2c55:	d1 f8                	sar    %eax
    2c57:	ba eb 00 00 00       	mov    $0xeb,%edx
    2c5c:	29 c2                	sub    %eax,%edx
    2c5e:	89 d0                	mov    %edx,%eax
    2c60:	89 45 d8             	mov    %eax,-0x28(%ebp)
        int pos_x=390-image_show[image_item-1]->w/2;
    2c63:	a1 54 58 02 00       	mov    0x25854,%eax
    2c68:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2c6e:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2c74:	c1 e2 02             	shl    $0x2,%edx
    2c77:	01 d0                	add    %edx,%eax
    2c79:	8b 00                	mov    (%eax),%eax
    2c7b:	8b 40 28             	mov    0x28(%eax),%eax
    2c7e:	89 c2                	mov    %eax,%edx
    2c80:	c1 ea 1f             	shr    $0x1f,%edx
    2c83:	01 d0                	add    %edx,%eax
    2c85:	d1 f8                	sar    %eax
    2c87:	ba 86 01 00 00       	mov    $0x186,%edx
    2c8c:	29 c2                	sub    %eax,%edx
    2c8e:	89 d0                	mov    %edx,%eax
    2c90:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        api_paint24BitmapToContent(&wnd, image_show[image_item-1]->data, (Point){pos_x,pos_y}, (Point){0,0}, (Size){image_show[image_item-1]->h,image_show[image_item-1]->w},(Size){image_show[image_item-1]->h,image_show[image_item-1]->w});
    2c93:	a1 54 58 02 00       	mov    0x25854,%eax
    2c98:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2c9e:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2ca4:	c1 e2 02             	shl    $0x2,%edx
    2ca7:	01 d0                	add    %edx,%eax
    2ca9:	8b 00                	mov    (%eax),%eax
    2cab:	8b 40 20             	mov    0x20(%eax),%eax
    2cae:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2cb1:	a1 54 58 02 00       	mov    0x25854,%eax
    2cb6:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2cbc:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2cc2:	c1 e2 02             	shl    $0x2,%edx
    2cc5:	01 d0                	add    %edx,%eax
    2cc7:	8b 00                	mov    (%eax),%eax
    2cc9:	8b 40 28             	mov    0x28(%eax),%eax
    2ccc:	89 45 b8             	mov    %eax,-0x48(%ebp)
    2ccf:	a1 54 58 02 00       	mov    0x25854,%eax
    2cd4:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2cda:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2ce0:	c1 e2 02             	shl    $0x2,%edx
    2ce3:	01 d0                	add    %edx,%eax
    2ce5:	8b 00                	mov    (%eax),%eax
    2ce7:	8b 40 20             	mov    0x20(%eax),%eax
    2cea:	89 45 bc             	mov    %eax,-0x44(%ebp)
    2ced:	a1 54 58 02 00       	mov    0x25854,%eax
    2cf2:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2cf8:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2cfe:	c1 e2 02             	shl    $0x2,%edx
    2d01:	01 d0                	add    %edx,%eax
    2d03:	8b 00                	mov    (%eax),%eax
    2d05:	8b 40 28             	mov    0x28(%eax),%eax
    2d08:	89 45 c0             	mov    %eax,-0x40(%ebp)
    2d0b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    2d12:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    2d19:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2d1c:	89 45 cc             	mov    %eax,-0x34(%ebp)
    2d1f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2d22:	89 45 d0             	mov    %eax,-0x30(%ebp)
    2d25:	a1 54 58 02 00       	mov    0x25854,%eax
    2d2a:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2d30:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2d36:	c1 e2 02             	shl    $0x2,%edx
    2d39:	01 d0                	add    %edx,%eax
    2d3b:	8b 00                	mov    (%eax),%eax
    2d3d:	8b 40 14             	mov    0x14(%eax),%eax
    2d40:	83 ec 08             	sub    $0x8,%esp
    2d43:	ff 75 b8             	pushl  -0x48(%ebp)
    2d46:	ff 75 b4             	pushl  -0x4c(%ebp)
    2d49:	ff 75 c0             	pushl  -0x40(%ebp)
    2d4c:	ff 75 bc             	pushl  -0x44(%ebp)
    2d4f:	ff 75 c8             	pushl  -0x38(%ebp)
    2d52:	ff 75 c4             	pushl  -0x3c(%ebp)
    2d55:	ff 75 d0             	pushl  -0x30(%ebp)
    2d58:	ff 75 cc             	pushl  -0x34(%ebp)
    2d5b:	50                   	push   %eax
    2d5c:	68 a0 58 02 00       	push   $0x258a0
    2d61:	e8 a3 4e 00 00       	call   7c09 <api_paint24BitmapToContent>
    2d66:	83 c4 30             	add    $0x30,%esp
        api_drawString(&wnd, 140, 6, image_show[image_item-1]->image_name, image_name_color);
    2d69:	a1 54 58 02 00       	mov    0x25854,%eax
    2d6e:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2d74:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2d7a:	c1 e2 02             	shl    $0x2,%edx
    2d7d:	01 d0                	add    %edx,%eax
    2d7f:	8b 00                	mov    (%eax),%eax
    2d81:	8b 00                	mov    (%eax),%eax
    2d83:	83 ec 0c             	sub    $0xc,%esp
    2d86:	ff 75 90             	pushl  -0x70(%ebp)
    2d89:	50                   	push   %eax
    2d8a:	6a 06                	push   $0x6
    2d8c:	68 8c 00 00 00       	push   $0x8c
    2d91:	68 a0 58 02 00       	push   $0x258a0
    2d96:	e8 27 50 00 00       	call   7dc2 <api_drawString>
    2d9b:	83 c4 20             	add    $0x20,%esp
        content_size=(Size){image_show[image_item-1]->h,image_show[image_item-1]->w};
    2d9e:	a1 54 58 02 00       	mov    0x25854,%eax
    2da3:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2da9:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2daf:	c1 e2 02             	shl    $0x2,%edx
    2db2:	01 d0                	add    %edx,%eax
    2db4:	8b 00                	mov    (%eax),%eax
    2db6:	8b 50 20             	mov    0x20(%eax),%edx
    2db9:	a1 54 58 02 00       	mov    0x25854,%eax
    2dbe:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    2dc4:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2dca:	c1 e1 02             	shl    $0x2,%ecx
    2dcd:	01 c8                	add    %ecx,%eax
    2dcf:	8b 00                	mov    (%eax),%eax
    2dd1:	8b 40 28             	mov    0x28(%eax),%eax
    2dd4:	89 15 0c 53 02 00    	mov    %edx,0x2530c
    2dda:	a3 10 53 02 00       	mov    %eax,0x25310
        content_pos=(Point){140 + (500-content_size.w)/2,30 + (410-content_size.h)/2};
    2ddf:	a1 10 53 02 00       	mov    0x25310,%eax
    2de4:	ba f4 01 00 00       	mov    $0x1f4,%edx
    2de9:	29 c2                	sub    %eax,%edx
    2deb:	89 d0                	mov    %edx,%eax
    2ded:	89 c2                	mov    %eax,%edx
    2def:	c1 ea 1f             	shr    $0x1f,%edx
    2df2:	01 d0                	add    %edx,%eax
    2df4:	d1 f8                	sar    %eax
    2df6:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
    2dfc:	a1 0c 53 02 00       	mov    0x2530c,%eax
    2e01:	b9 9a 01 00 00       	mov    $0x19a,%ecx
    2e06:	29 c1                	sub    %eax,%ecx
    2e08:	89 c8                	mov    %ecx,%eax
    2e0a:	89 c1                	mov    %eax,%ecx
    2e0c:	c1 e9 1f             	shr    $0x1f,%ecx
    2e0f:	01 c8                	add    %ecx,%eax
    2e11:	d1 f8                	sar    %eax
    2e13:	83 c0 1e             	add    $0x1e,%eax
    2e16:	89 15 1c 53 02 00    	mov    %edx,0x2531c
    2e1c:	a3 20 53 02 00       	mov    %eax,0x25320
        scale_degree=1;
    2e21:	d9 e8                	fld1   
    2e23:	d9 1d 30 53 02 00    	fstps  0x25330
        turn_degree=0;
    2e29:	d9 ee                	fldz   
    2e2b:	d9 1d b0 57 02 00    	fstps  0x257b0
        image_origin->data=image_show[image_item-1]->data;
    2e31:	a1 80 58 02 00       	mov    0x25880,%eax
    2e36:	8b 15 54 58 02 00    	mov    0x25854,%edx
    2e3c:	8b 0d a8 57 02 00    	mov    0x257a8,%ecx
    2e42:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    2e48:	c1 e1 02             	shl    $0x2,%ecx
    2e4b:	01 ca                	add    %ecx,%edx
    2e4d:	8b 12                	mov    (%edx),%edx
    2e4f:	8b 52 14             	mov    0x14(%edx),%edx
    2e52:	89 50 08             	mov    %edx,0x8(%eax)
        image_origin->height=content_size.h;
    2e55:	a1 80 58 02 00       	mov    0x25880,%eax
    2e5a:	8b 15 0c 53 02 00    	mov    0x2530c,%edx
    2e60:	89 50 04             	mov    %edx,0x4(%eax)
        image_origin->width=content_size.w;
    2e63:	a1 80 58 02 00       	mov    0x25880,%eax
    2e68:	8b 15 10 53 02 00    	mov    0x25310,%edx
    2e6e:	89 10                	mov    %edx,(%eax)
        image_origin_mirror->height=content_size.h;
    2e70:	a1 50 58 02 00       	mov    0x25850,%eax
    2e75:	8b 15 0c 53 02 00    	mov    0x2530c,%edx
    2e7b:	89 50 04             	mov    %edx,0x4(%eax)
        image_origin_mirror->width=content_size.w;
    2e7e:	a1 50 58 02 00       	mov    0x25850,%eax
    2e83:	8b 15 10 53 02 00    	mov    0x25310,%edx
    2e89:	89 10                	mov    %edx,(%eax)
        image_in_content_torollover=(RGB*)malloc(sizeof(RGB)*image_origin->height*image_origin->width);
    2e8b:	a1 80 58 02 00       	mov    0x25880,%eax
    2e90:	8b 40 04             	mov    0x4(%eax),%eax
    2e93:	89 c2                	mov    %eax,%edx
    2e95:	a1 80 58 02 00       	mov    0x25880,%eax
    2e9a:	8b 00                	mov    (%eax),%eax
    2e9c:	0f af d0             	imul   %eax,%edx
    2e9f:	89 d0                	mov    %edx,%eax
    2ea1:	01 c0                	add    %eax,%eax
    2ea3:	01 d0                	add    %edx,%eax
    2ea5:	83 ec 0c             	sub    $0xc,%esp
    2ea8:	50                   	push   %eax
    2ea9:	e8 0f 42 00 00       	call   70bd <malloc>
    2eae:	83 c4 10             	add    $0x10,%esp
    2eb1:	a3 08 58 02 00       	mov    %eax,0x25808
        memmove(image_in_content_torollover, image_show[image_item-1]->data, image_origin->height*image_origin->width*3);
    2eb6:	a1 80 58 02 00       	mov    0x25880,%eax
    2ebb:	8b 50 04             	mov    0x4(%eax),%edx
    2ebe:	a1 80 58 02 00       	mov    0x25880,%eax
    2ec3:	8b 00                	mov    (%eax),%eax
    2ec5:	0f af d0             	imul   %eax,%edx
    2ec8:	89 d0                	mov    %edx,%eax
    2eca:	01 c0                	add    %eax,%eax
    2ecc:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    2ecf:	a1 54 58 02 00       	mov    0x25854,%eax
    2ed4:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2eda:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2ee0:	c1 e2 02             	shl    $0x2,%edx
    2ee3:	01 d0                	add    %edx,%eax
    2ee5:	8b 00                	mov    (%eax),%eax
    2ee7:	8b 50 14             	mov    0x14(%eax),%edx
    2eea:	a1 08 58 02 00       	mov    0x25808,%eax
    2eef:	83 ec 04             	sub    $0x4,%esp
    2ef2:	51                   	push   %ecx
    2ef3:	52                   	push   %edx
    2ef4:	50                   	push   %eax
    2ef5:	e8 04 3d 00 00       	call   6bfe <memmove>
    2efa:	83 c4 10             	add    $0x10,%esp
        image_in_content_toturnaround=(RGB*)malloc(sizeof(RGB)*image_origin->height*image_origin->width);
    2efd:	a1 80 58 02 00       	mov    0x25880,%eax
    2f02:	8b 40 04             	mov    0x4(%eax),%eax
    2f05:	89 c2                	mov    %eax,%edx
    2f07:	a1 80 58 02 00       	mov    0x25880,%eax
    2f0c:	8b 00                	mov    (%eax),%eax
    2f0e:	0f af d0             	imul   %eax,%edx
    2f11:	89 d0                	mov    %edx,%eax
    2f13:	01 c0                	add    %eax,%eax
    2f15:	01 d0                	add    %edx,%eax
    2f17:	83 ec 0c             	sub    $0xc,%esp
    2f1a:	50                   	push   %eax
    2f1b:	e8 9d 41 00 00       	call   70bd <malloc>
    2f20:	83 c4 10             	add    $0x10,%esp
    2f23:	a3 d0 58 02 00       	mov    %eax,0x258d0
        memmove(image_in_content_toturnaround, image_show[image_item-1]->data, image_origin->height*image_origin->width*3);
    2f28:	a1 80 58 02 00       	mov    0x25880,%eax
    2f2d:	8b 50 04             	mov    0x4(%eax),%edx
    2f30:	a1 80 58 02 00       	mov    0x25880,%eax
    2f35:	8b 00                	mov    (%eax),%eax
    2f37:	0f af d0             	imul   %eax,%edx
    2f3a:	89 d0                	mov    %edx,%eax
    2f3c:	01 c0                	add    %eax,%eax
    2f3e:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    2f41:	a1 54 58 02 00       	mov    0x25854,%eax
    2f46:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2f4c:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2f52:	c1 e2 02             	shl    $0x2,%edx
    2f55:	01 d0                	add    %edx,%eax
    2f57:	8b 00                	mov    (%eax),%eax
    2f59:	8b 50 14             	mov    0x14(%eax),%edx
    2f5c:	a1 d0 58 02 00       	mov    0x258d0,%eax
    2f61:	83 ec 04             	sub    $0x4,%esp
    2f64:	51                   	push   %ecx
    2f65:	52                   	push   %edx
    2f66:	50                   	push   %eax
    2f67:	e8 92 3c 00 00       	call   6bfe <memmove>
    2f6c:	83 c4 10             	add    $0x10,%esp
    }
    current_gif_img_num = image_show[image_item-1]->gif_img_num;
    2f6f:	a1 54 58 02 00       	mov    0x25854,%eax
    2f74:	8b 15 a8 57 02 00    	mov    0x257a8,%edx
    2f7a:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    2f80:	c1 e2 02             	shl    $0x2,%edx
    2f83:	01 d0                	add    %edx,%eax
    2f85:	8b 00                	mov    (%eax),%eax
    2f87:	8b 40 0c             	mov    0xc(%eax),%eax
    2f8a:	a3 ac 57 02 00       	mov    %eax,0x257ac
    api_repaint(&wnd);
    2f8f:	83 ec 0c             	sub    $0xc,%esp
    2f92:	68 a0 58 02 00       	push   $0x258a0
    2f97:	e8 ed 4c 00 00       	call   7c89 <api_repaint>
    2f9c:	83 c4 10             	add    $0x10,%esp
}
    2f9f:	90                   	nop
    2fa0:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2fa3:	5b                   	pop    %ebx
    2fa4:	5e                   	pop    %esi
    2fa5:	5d                   	pop    %ebp
    2fa6:	c3                   	ret    

00002fa7 <isMouseInListItem>:

int isMouseInListItem(int x, int y) {
    2fa7:	55                   	push   %ebp
    2fa8:	89 e5                	mov    %esp,%ebp
    2faa:	83 ec 08             	sub    $0x8,%esp
   if (30 <= x && x <= 110 && 80 <= y && y <= 188){
    2fad:	83 7d 08 1d          	cmpl   $0x1d,0x8(%ebp)
    2fb1:	7e 38                	jle    2feb <isMouseInListItem+0x44>
    2fb3:	83 7d 08 6e          	cmpl   $0x6e,0x8(%ebp)
    2fb7:	7f 32                	jg     2feb <isMouseInListItem+0x44>
    2fb9:	83 7d 0c 4f          	cmpl   $0x4f,0xc(%ebp)
    2fbd:	7e 2c                	jle    2feb <isMouseInListItem+0x44>
    2fbf:	81 7d 0c bc 00 00 00 	cmpl   $0xbc,0xc(%ebp)
    2fc6:	7f 23                	jg     2feb <isMouseInListItem+0x44>
        has_content = 0;
    2fc8:	c7 05 a4 57 02 00 00 	movl   $0x0,0x257a4
    2fcf:	00 00 00 
        image_item = 1;
    2fd2:	c7 05 a8 57 02 00 01 	movl   $0x1,0x257a8
    2fd9:	00 00 00 
        showImageInContent();
    2fdc:	e8 f3 f6 ff ff       	call   26d4 <showImageInContent>
        return 1;
    2fe1:	b8 01 00 00 00       	mov    $0x1,%eax
    2fe6:	e9 81 00 00 00       	jmp    306c <isMouseInListItem+0xc5>
   }
   else if (30 <= x && x <= 110 && 210 <= y && y <= 318)
    2feb:	83 7d 08 1d          	cmpl   $0x1d,0x8(%ebp)
    2fef:	7e 38                	jle    3029 <isMouseInListItem+0x82>
    2ff1:	83 7d 08 6e          	cmpl   $0x6e,0x8(%ebp)
    2ff5:	7f 32                	jg     3029 <isMouseInListItem+0x82>
    2ff7:	81 7d 0c d1 00 00 00 	cmpl   $0xd1,0xc(%ebp)
    2ffe:	7e 29                	jle    3029 <isMouseInListItem+0x82>
    3000:	81 7d 0c 3e 01 00 00 	cmpl   $0x13e,0xc(%ebp)
    3007:	7f 20                	jg     3029 <isMouseInListItem+0x82>
   {
        has_content = 0;
    3009:	c7 05 a4 57 02 00 00 	movl   $0x0,0x257a4
    3010:	00 00 00 
        image_item = 2;
    3013:	c7 05 a8 57 02 00 02 	movl   $0x2,0x257a8
    301a:	00 00 00 
        showImageInContent();
    301d:	e8 b2 f6 ff ff       	call   26d4 <showImageInContent>
        return 1;
    3022:	b8 01 00 00 00       	mov    $0x1,%eax
    3027:	eb 43                	jmp    306c <isMouseInListItem+0xc5>
   }
   else if (30 <= x && x <= 110 && 340 <= y && y <= 448)
    3029:	83 7d 08 1d          	cmpl   $0x1d,0x8(%ebp)
    302d:	7e 38                	jle    3067 <isMouseInListItem+0xc0>
    302f:	83 7d 08 6e          	cmpl   $0x6e,0x8(%ebp)
    3033:	7f 32                	jg     3067 <isMouseInListItem+0xc0>
    3035:	81 7d 0c 53 01 00 00 	cmpl   $0x153,0xc(%ebp)
    303c:	7e 29                	jle    3067 <isMouseInListItem+0xc0>
    303e:	81 7d 0c c0 01 00 00 	cmpl   $0x1c0,0xc(%ebp)
    3045:	7f 20                	jg     3067 <isMouseInListItem+0xc0>
   {
        has_content = 0;
    3047:	c7 05 a4 57 02 00 00 	movl   $0x0,0x257a4
    304e:	00 00 00 
        image_item = 3;
    3051:	c7 05 a8 57 02 00 03 	movl   $0x3,0x257a8
    3058:	00 00 00 
        showImageInContent();
    305b:	e8 74 f6 ff ff       	call   26d4 <showImageInContent>
        return 1;
    3060:	b8 01 00 00 00       	mov    $0x1,%eax
    3065:	eb 05                	jmp    306c <isMouseInListItem+0xc5>
   }
   else {
        return 0;
    3067:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    306c:	c9                   	leave  
    306d:	c3                   	ret    

0000306e <isMouseInDeleteButton>:

int isMouseInDeleteButton(int x, int y) {
    306e:	55                   	push   %ebp
    306f:	89 e5                	mov    %esp,%ebp
    3071:	83 ec 28             	sub    $0x28,%esp
   if (30 < x && x <= 60 && 0 <= y && y <= 30){
    3074:	83 7d 08 1e          	cmpl   $0x1e,0x8(%ebp)
    3078:	0f 8e 77 01 00 00    	jle    31f5 <isMouseInDeleteButton+0x187>
    307e:	83 7d 08 3c          	cmpl   $0x3c,0x8(%ebp)
    3082:	0f 8f 6d 01 00 00    	jg     31f5 <isMouseInDeleteButton+0x187>
    3088:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    308c:	0f 88 63 01 00 00    	js     31f5 <isMouseInDeleteButton+0x187>
    3092:	83 7d 0c 1e          	cmpl   $0x1e,0xc(%ebp)
    3096:	0f 8f 59 01 00 00    	jg     31f5 <isMouseInDeleteButton+0x187>
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
    309c:	a1 e0 52 02 00       	mov    0x252e0,%eax
    30a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int i = 0; i < edit_img_size.h; i++) {
    30a4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    30ab:	eb 68                	jmp    3115 <isMouseInDeleteButton+0xa7>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    30ad:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    30b3:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    30b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    30bc:	01 c2                	add    %eax,%edx
    30be:	a1 b0 58 02 00       	mov    0x258b0,%eax
    30c3:	0f af c2             	imul   %edx,%eax
    30c6:	89 c2                	mov    %eax,%edx
    30c8:	a1 e4 52 02 00       	mov    0x252e4,%eax
    30cd:	01 c2                	add    %eax,%edx
    30cf:	89 d0                	mov    %edx,%eax
    30d1:	01 c0                	add    %eax,%eax
    30d3:	01 d0                	add    %edx,%eax
    30d5:	01 c8                	add    %ecx,%eax
    30d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
            t = edit_img_origin + i * edit_img_size.w;
    30da:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    30e0:	a1 e0 52 02 00       	mov    0x252e0,%eax
    30e5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    30e9:	89 c1                	mov    %eax,%ecx
    30eb:	89 c8                	mov    %ecx,%eax
    30ed:	01 c0                	add    %eax,%eax
    30ef:	01 c8                	add    %ecx,%eax
    30f1:	01 d0                	add    %edx,%eax
    30f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            memmove(o, t, max_line * 3);
    30f6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    30f9:	89 d0                	mov    %edx,%eax
    30fb:	01 c0                	add    %eax,%eax
    30fd:	01 d0                	add    %edx,%eax
    30ff:	83 ec 04             	sub    $0x4,%esp
    3102:	50                   	push   %eax
    3103:	ff 75 e4             	pushl  -0x1c(%ebp)
    3106:	ff 75 e8             	pushl  -0x18(%ebp)
    3109:	e8 f0 3a 00 00       	call   6bfe <memmove>
    310e:	83 c4 10             	add    $0x10,%esp
int isMouseInDeleteButton(int x, int y) {
   if (30 < x && x <= 60 && 0 <= y && y <= 30){
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
        for (int i = 0; i < edit_img_size.h; i++) {
    3111:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3115:	a1 dc 52 02 00       	mov    0x252dc,%eax
    311a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    311d:	7f 8e                	jg     30ad <isMouseInDeleteButton+0x3f>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
            t = edit_img_origin + i * edit_img_size.w;
            memmove(o, t, max_line * 3);
        }
        max_line = image_title_size.w;
    311f:	a1 00 53 02 00       	mov    0x25300,%eax
    3124:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int i = 0; i < image_title_size.h; i++) {
    3127:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    312e:	eb 68                	jmp    3198 <isMouseInDeleteButton+0x12a>
            o = wnd.content + (image_title_pos.y + i) * wnd.size.w + image_title_pos.x;
    3130:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    3136:	8b 15 08 53 02 00    	mov    0x25308,%edx
    313c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    313f:	01 c2                	add    %eax,%edx
    3141:	a1 b0 58 02 00       	mov    0x258b0,%eax
    3146:	0f af c2             	imul   %edx,%eax
    3149:	89 c2                	mov    %eax,%edx
    314b:	a1 04 53 02 00       	mov    0x25304,%eax
    3150:	01 c2                	add    %eax,%edx
    3152:	89 d0                	mov    %edx,%eax
    3154:	01 c0                	add    %eax,%eax
    3156:	01 d0                	add    %edx,%eax
    3158:	01 c8                	add    %ecx,%eax
    315a:	89 45 e8             	mov    %eax,-0x18(%ebp)
            t = image_title_origin + i * image_title_size.w;
    315d:	8b 15 fc 58 02 00    	mov    0x258fc,%edx
    3163:	a1 00 53 02 00       	mov    0x25300,%eax
    3168:	0f af 45 f0          	imul   -0x10(%ebp),%eax
    316c:	89 c1                	mov    %eax,%ecx
    316e:	89 c8                	mov    %ecx,%eax
    3170:	01 c0                	add    %eax,%eax
    3172:	01 c8                	add    %ecx,%eax
    3174:	01 d0                	add    %edx,%eax
    3176:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            memmove(o, t, max_line * 3);
    3179:	8b 55 ec             	mov    -0x14(%ebp),%edx
    317c:	89 d0                	mov    %edx,%eax
    317e:	01 c0                	add    %eax,%eax
    3180:	01 d0                	add    %edx,%eax
    3182:	83 ec 04             	sub    $0x4,%esp
    3185:	50                   	push   %eax
    3186:	ff 75 e4             	pushl  -0x1c(%ebp)
    3189:	ff 75 e8             	pushl  -0x18(%ebp)
    318c:	e8 6d 3a 00 00       	call   6bfe <memmove>
    3191:	83 c4 10             	add    $0x10,%esp
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
            t = edit_img_origin + i * edit_img_size.w;
            memmove(o, t, max_line * 3);
        }
        max_line = image_title_size.w;
        for (int i = 0; i < image_title_size.h; i++) {
    3194:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    3198:	a1 fc 52 02 00       	mov    0x252fc,%eax
    319d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    31a0:	7f 8e                	jg     3130 <isMouseInDeleteButton+0xc2>
            o = wnd.content + (image_title_pos.y + i) * wnd.size.w + image_title_pos.x;
            t = image_title_origin + i * image_title_size.w;
            memmove(o, t, max_line * 3);
        }
        image_item = 0;
    31a2:	c7 05 a8 57 02 00 00 	movl   $0x0,0x257a8
    31a9:	00 00 00 
        content_size=(Size){410,380};
    31ac:	c7 05 0c 53 02 00 9a 	movl   $0x19a,0x2530c
    31b3:	01 00 00 
    31b6:	c7 05 10 53 02 00 7c 	movl   $0x17c,0x25310
    31bd:	01 00 00 
        content_pos=(Point){140,30};
    31c0:	c7 05 1c 53 02 00 8c 	movl   $0x8c,0x2531c
    31c7:	00 00 00 
    31ca:	c7 05 20 53 02 00 1e 	movl   $0x1e,0x25320
    31d1:	00 00 00 
        api_repaint(&wnd);
    31d4:	83 ec 0c             	sub    $0xc,%esp
    31d7:	68 a0 58 02 00       	push   $0x258a0
    31dc:	e8 a8 4a 00 00       	call   7c89 <api_repaint>
    31e1:	83 c4 10             	add    $0x10,%esp
        has_content = 0;
    31e4:	c7 05 a4 57 02 00 00 	movl   $0x0,0x257a4
    31eb:	00 00 00 
        return 1;
    31ee:	b8 01 00 00 00       	mov    $0x1,%eax
    31f3:	eb 05                	jmp    31fa <isMouseInDeleteButton+0x18c>
   }
   else {
        return 0;
    31f5:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    31fa:	c9                   	leave  
    31fb:	c3                   	ret    

000031fc <image_scale_process>:

void image_scale_process(float zoom_degree)
{
    31fc:	55                   	push   %ebp
    31fd:	89 e5                	mov    %esp,%ebp
    31ff:	81 ec 88 00 00 00    	sub    $0x88,%esp
    if(has_content == 1 && current_gif_img->gif_img_num > 1 && current_gif_img->is_onshow == 1)
    3205:	a1 a4 57 02 00       	mov    0x257a4,%eax
    320a:	83 f8 01             	cmp    $0x1,%eax
    320d:	0f 85 8e 03 00 00    	jne    35a1 <image_scale_process+0x3a5>
    3213:	a1 84 58 02 00       	mov    0x25884,%eax
    3218:	8b 40 0c             	mov    0xc(%eax),%eax
    321b:	83 f8 01             	cmp    $0x1,%eax
    321e:	0f 8e 7d 03 00 00    	jle    35a1 <image_scale_process+0x3a5>
    3224:	a1 84 58 02 00       	mov    0x25884,%eax
    3229:	8b 40 10             	mov    0x10(%eax),%eax
    322c:	83 f8 01             	cmp    $0x1,%eax
    322f:	0f 85 6c 03 00 00    	jne    35a1 <image_scale_process+0x3a5>
    {
        has_content = 0;
    3235:	c7 05 a4 57 02 00 00 	movl   $0x0,0x257a4
    323c:	00 00 00 
        image_origin->data=current_gif_img->data;
    323f:	a1 80 58 02 00       	mov    0x25880,%eax
    3244:	8b 15 84 58 02 00    	mov    0x25884,%edx
    324a:	8b 52 14             	mov    0x14(%edx),%edx
    324d:	89 50 08             	mov    %edx,0x8(%eax)
        image_origin->height=current_gif_img->h;
    3250:	a1 80 58 02 00       	mov    0x25880,%eax
    3255:	8b 15 84 58 02 00    	mov    0x25884,%edx
    325b:	8b 52 20             	mov    0x20(%edx),%edx
    325e:	89 50 04             	mov    %edx,0x4(%eax)
        image_origin->width=current_gif_img->w;
    3261:	a1 80 58 02 00       	mov    0x25880,%eax
    3266:	8b 15 84 58 02 00    	mov    0x25884,%edx
    326c:	8b 52 28             	mov    0x28(%edx),%edx
    326f:	89 10                	mov    %edx,(%eax)
        scale_degree=scale_degree*zoom_degree;
    3271:	d9 05 30 53 02 00    	flds   0x25330
    3277:	d8 4d 08             	fmuls  0x8(%ebp)
    327a:	d9 1d 30 53 02 00    	fstps  0x25330
        image_scale->height=image_origin->height*scale_degree;
    3280:	8b 15 8c 58 02 00    	mov    0x2588c,%edx
    3286:	a1 80 58 02 00       	mov    0x25880,%eax
    328b:	8b 40 04             	mov    0x4(%eax),%eax
    328e:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
    3294:	db 85 7c ff ff ff    	fildl  -0x84(%ebp)
    329a:	d9 05 30 53 02 00    	flds   0x25330
    32a0:	de c9                	fmulp  %st,%st(1)
    32a2:	d9 7d 86             	fnstcw -0x7a(%ebp)
    32a5:	0f b7 45 86          	movzwl -0x7a(%ebp),%eax
    32a9:	b4 0c                	mov    $0xc,%ah
    32ab:	66 89 45 84          	mov    %ax,-0x7c(%ebp)
    32af:	d9 6d 84             	fldcw  -0x7c(%ebp)
    32b2:	db 5d 80             	fistpl -0x80(%ebp)
    32b5:	d9 6d 86             	fldcw  -0x7a(%ebp)
    32b8:	8b 45 80             	mov    -0x80(%ebp),%eax
    32bb:	89 42 04             	mov    %eax,0x4(%edx)
        image_scale->width=image_origin->width*scale_degree;
    32be:	a1 8c 58 02 00       	mov    0x2588c,%eax
    32c3:	8b 15 80 58 02 00    	mov    0x25880,%edx
    32c9:	8b 12                	mov    (%edx),%edx
    32cb:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
    32d1:	db 85 7c ff ff ff    	fildl  -0x84(%ebp)
    32d7:	d9 05 30 53 02 00    	flds   0x25330
    32dd:	de c9                	fmulp  %st,%st(1)
    32df:	d9 6d 84             	fldcw  -0x7c(%ebp)
    32e2:	db 5d 80             	fistpl -0x80(%ebp)
    32e5:	d9 6d 86             	fldcw  -0x7a(%ebp)
    32e8:	8b 55 80             	mov    -0x80(%ebp),%edx
    32eb:	89 10                	mov    %edx,(%eax)
        image_in_content_scaled=(RGB*)malloc(sizeof(RGB)*image_scale->height*image_scale->width);
    32ed:	a1 8c 58 02 00       	mov    0x2588c,%eax
    32f2:	8b 40 04             	mov    0x4(%eax),%eax
    32f5:	89 c2                	mov    %eax,%edx
    32f7:	a1 8c 58 02 00       	mov    0x2588c,%eax
    32fc:	8b 00                	mov    (%eax),%eax
    32fe:	0f af d0             	imul   %eax,%edx
    3301:	89 d0                	mov    %edx,%eax
    3303:	01 c0                	add    %eax,%eax
    3305:	01 d0                	add    %edx,%eax
    3307:	83 ec 0c             	sub    $0xc,%esp
    330a:	50                   	push   %eax
    330b:	e8 ad 3d 00 00       	call   70bd <malloc>
    3310:	83 c4 10             	add    $0x10,%esp
    3313:	a3 4c 58 02 00       	mov    %eax,0x2584c
        image_scale->data=image_in_content_scaled;
    3318:	a1 8c 58 02 00       	mov    0x2588c,%eax
    331d:	8b 15 4c 58 02 00    	mov    0x2584c,%edx
    3323:	89 50 08             	mov    %edx,0x8(%eax)
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
    3326:	a1 e0 52 02 00       	mov    0x252e0,%eax
    332b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int i = 0; i < edit_img_size.h; i++) {
    332e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3335:	eb 68                	jmp    339f <image_scale_process+0x1a3>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    3337:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    333d:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    3343:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3346:	01 c2                	add    %eax,%edx
    3348:	a1 b0 58 02 00       	mov    0x258b0,%eax
    334d:	0f af c2             	imul   %edx,%eax
    3350:	89 c2                	mov    %eax,%edx
    3352:	a1 e4 52 02 00       	mov    0x252e4,%eax
    3357:	01 c2                	add    %eax,%edx
    3359:	89 d0                	mov    %edx,%eax
    335b:	01 c0                	add    %eax,%eax
    335d:	01 d0                	add    %edx,%eax
    335f:	01 c8                	add    %ecx,%eax
    3361:	89 45 e8             	mov    %eax,-0x18(%ebp)
            t = edit_img_origin + i * edit_img_size.w;
    3364:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    336a:	a1 e0 52 02 00       	mov    0x252e0,%eax
    336f:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    3373:	89 c1                	mov    %eax,%ecx
    3375:	89 c8                	mov    %ecx,%eax
    3377:	01 c0                	add    %eax,%eax
    3379:	01 c8                	add    %ecx,%eax
    337b:	01 d0                	add    %edx,%eax
    337d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            memmove(o, t, max_line * 3);
    3380:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3383:	89 d0                	mov    %edx,%eax
    3385:	01 c0                	add    %eax,%eax
    3387:	01 d0                	add    %edx,%eax
    3389:	83 ec 04             	sub    $0x4,%esp
    338c:	50                   	push   %eax
    338d:	ff 75 e4             	pushl  -0x1c(%ebp)
    3390:	ff 75 e8             	pushl  -0x18(%ebp)
    3393:	e8 66 38 00 00       	call   6bfe <memmove>
    3398:	83 c4 10             	add    $0x10,%esp
        image_in_content_scaled=(RGB*)malloc(sizeof(RGB)*image_scale->height*image_scale->width);
        image_scale->data=image_in_content_scaled;
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
        for (int i = 0; i < edit_img_size.h; i++) {
    339b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    339f:	a1 dc 52 02 00       	mov    0x252dc,%eax
    33a4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    33a7:	7f 8e                	jg     3337 <image_scale_process+0x13b>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
            t = edit_img_origin + i * edit_img_size.w;
            memmove(o, t, max_line * 3);
        }
        picScale(image_origin, image_scale);
    33a9:	8b 15 8c 58 02 00    	mov    0x2588c,%edx
    33af:	a1 80 58 02 00       	mov    0x25880,%eax
    33b4:	83 ec 08             	sub    $0x8,%esp
    33b7:	52                   	push   %edx
    33b8:	50                   	push   %eax
    33b9:	e8 c6 5a 00 00       	call   8e84 <picScale>
    33be:	83 c4 10             	add    $0x10,%esp
        current_gif_img->w = image_scale->width;
    33c1:	a1 84 58 02 00       	mov    0x25884,%eax
    33c6:	8b 15 8c 58 02 00    	mov    0x2588c,%edx
    33cc:	8b 12                	mov    (%edx),%edx
    33ce:	89 50 28             	mov    %edx,0x28(%eax)
        current_gif_img->h = image_scale->height;
    33d1:	a1 84 58 02 00       	mov    0x25884,%eax
    33d6:	8b 15 8c 58 02 00    	mov    0x2588c,%edx
    33dc:	8b 52 04             	mov    0x4(%edx),%edx
    33df:	89 50 20             	mov    %edx,0x20(%eax)
        current_gif_img->data = image_scale->data;
    33e2:	a1 84 58 02 00       	mov    0x25884,%eax
    33e7:	8b 15 8c 58 02 00    	mov    0x2588c,%edx
    33ed:	8b 52 08             	mov    0x8(%edx),%edx
    33f0:	89 50 14             	mov    %edx,0x14(%eax)
        int pos_y=235-(current_gif_img->h/current_gif_img->gif_img_num)/2;
    33f3:	a1 84 58 02 00       	mov    0x25884,%eax
    33f8:	8b 40 20             	mov    0x20(%eax),%eax
    33fb:	8b 15 84 58 02 00    	mov    0x25884,%edx
    3401:	8b 4a 0c             	mov    0xc(%edx),%ecx
    3404:	99                   	cltd   
    3405:	f7 f9                	idiv   %ecx
    3407:	89 c2                	mov    %eax,%edx
    3409:	c1 ea 1f             	shr    $0x1f,%edx
    340c:	01 d0                	add    %edx,%eax
    340e:	d1 f8                	sar    %eax
    3410:	ba eb 00 00 00       	mov    $0xeb,%edx
    3415:	29 c2                	sub    %eax,%edx
    3417:	89 d0                	mov    %edx,%eax
    3419:	89 45 e0             	mov    %eax,-0x20(%ebp)
        int pos_x=390-current_gif_img->w/2;
    341c:	a1 84 58 02 00       	mov    0x25884,%eax
    3421:	8b 40 28             	mov    0x28(%eax),%eax
    3424:	89 c2                	mov    %eax,%edx
    3426:	c1 ea 1f             	shr    $0x1f,%edx
    3429:	01 d0                	add    %edx,%eax
    342b:	d1 f8                	sar    %eax
    342d:	ba 86 01 00 00       	mov    $0x186,%edx
    3432:	29 c2                	sub    %eax,%edx
    3434:	89 d0                	mov    %edx,%eax
    3436:	89 45 dc             	mov    %eax,-0x24(%ebp)
        api_paint24BitmapToContent(&wnd, current_gif_img->data, (Point){pos_x,pos_y}, (Point){0,(current_gif_img->h/current_gif_img->gif_img_num)*(gif_frame-1)},(Size){current_gif_img->h,current_gif_img->w},(Size){(current_gif_img->h/current_gif_img->gif_img_num),current_gif_img->w});
    3439:	a1 84 58 02 00       	mov    0x25884,%eax
    343e:	8b 40 20             	mov    0x20(%eax),%eax
    3441:	8b 15 84 58 02 00    	mov    0x25884,%edx
    3447:	8b 4a 0c             	mov    0xc(%edx),%ecx
    344a:	99                   	cltd   
    344b:	f7 f9                	idiv   %ecx
    344d:	89 45 88             	mov    %eax,-0x78(%ebp)
    3450:	a1 84 58 02 00       	mov    0x25884,%eax
    3455:	8b 40 28             	mov    0x28(%eax),%eax
    3458:	89 45 8c             	mov    %eax,-0x74(%ebp)
    345b:	a1 84 58 02 00       	mov    0x25884,%eax
    3460:	8b 40 20             	mov    0x20(%eax),%eax
    3463:	89 45 90             	mov    %eax,-0x70(%ebp)
    3466:	a1 84 58 02 00       	mov    0x25884,%eax
    346b:	8b 40 28             	mov    0x28(%eax),%eax
    346e:	89 45 94             	mov    %eax,-0x6c(%ebp)
    3471:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    3478:	a1 84 58 02 00       	mov    0x25884,%eax
    347d:	8b 40 20             	mov    0x20(%eax),%eax
    3480:	8b 15 84 58 02 00    	mov    0x25884,%edx
    3486:	8b 4a 0c             	mov    0xc(%edx),%ecx
    3489:	99                   	cltd   
    348a:	f7 f9                	idiv   %ecx
    348c:	89 c2                	mov    %eax,%edx
    348e:	a1 2c 53 02 00       	mov    0x2532c,%eax
    3493:	83 e8 01             	sub    $0x1,%eax
    3496:	0f af c2             	imul   %edx,%eax
    3499:	89 45 9c             	mov    %eax,-0x64(%ebp)
    349c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    349f:	89 45 a0             	mov    %eax,-0x60(%ebp)
    34a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    34a5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    34a8:	a1 84 58 02 00       	mov    0x25884,%eax
    34ad:	8b 40 14             	mov    0x14(%eax),%eax
    34b0:	83 ec 08             	sub    $0x8,%esp
    34b3:	ff 75 8c             	pushl  -0x74(%ebp)
    34b6:	ff 75 88             	pushl  -0x78(%ebp)
    34b9:	ff 75 94             	pushl  -0x6c(%ebp)
    34bc:	ff 75 90             	pushl  -0x70(%ebp)
    34bf:	ff 75 9c             	pushl  -0x64(%ebp)
    34c2:	ff 75 98             	pushl  -0x68(%ebp)
    34c5:	ff 75 a4             	pushl  -0x5c(%ebp)
    34c8:	ff 75 a0             	pushl  -0x60(%ebp)
    34cb:	50                   	push   %eax
    34cc:	68 a0 58 02 00       	push   $0x258a0
    34d1:	e8 33 47 00 00       	call   7c09 <api_paint24BitmapToContent>
    34d6:	83 c4 30             	add    $0x30,%esp
        gif_frame = (gif_frame % current_gif_img->gif_img_num ) + 1;
    34d9:	a1 2c 53 02 00       	mov    0x2532c,%eax
    34de:	8b 15 84 58 02 00    	mov    0x25884,%edx
    34e4:	8b 4a 0c             	mov    0xc(%edx),%ecx
    34e7:	99                   	cltd   
    34e8:	f7 f9                	idiv   %ecx
    34ea:	89 d0                	mov    %edx,%eax
    34ec:	83 c0 01             	add    $0x1,%eax
    34ef:	a3 2c 53 02 00       	mov    %eax,0x2532c
        content_size=(Size){(current_gif_img->h/current_gif_img->gif_img_num),current_gif_img->w};
    34f4:	a1 84 58 02 00       	mov    0x25884,%eax
    34f9:	8b 40 20             	mov    0x20(%eax),%eax
    34fc:	8b 15 84 58 02 00    	mov    0x25884,%edx
    3502:	8b 4a 0c             	mov    0xc(%edx),%ecx
    3505:	99                   	cltd   
    3506:	f7 f9                	idiv   %ecx
    3508:	89 c2                	mov    %eax,%edx
    350a:	a1 84 58 02 00       	mov    0x25884,%eax
    350f:	8b 40 28             	mov    0x28(%eax),%eax
    3512:	89 15 0c 53 02 00    	mov    %edx,0x2530c
    3518:	a3 10 53 02 00       	mov    %eax,0x25310
        content_pos=(Point){140 + (500-content_size.w)/2,30 + (410-content_size.h)/2};
    351d:	a1 10 53 02 00       	mov    0x25310,%eax
    3522:	ba f4 01 00 00       	mov    $0x1f4,%edx
    3527:	29 c2                	sub    %eax,%edx
    3529:	89 d0                	mov    %edx,%eax
    352b:	89 c2                	mov    %eax,%edx
    352d:	c1 ea 1f             	shr    $0x1f,%edx
    3530:	01 d0                	add    %edx,%eax
    3532:	d1 f8                	sar    %eax
    3534:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
    353a:	a1 0c 53 02 00       	mov    0x2530c,%eax
    353f:	b9 9a 01 00 00       	mov    $0x19a,%ecx
    3544:	29 c1                	sub    %eax,%ecx
    3546:	89 c8                	mov    %ecx,%eax
    3548:	89 c1                	mov    %eax,%ecx
    354a:	c1 e9 1f             	shr    $0x1f,%ecx
    354d:	01 c8                	add    %ecx,%eax
    354f:	d1 f8                	sar    %eax
    3551:	83 c0 1e             	add    $0x1e,%eax
    3554:	89 15 1c 53 02 00    	mov    %edx,0x2531c
    355a:	a3 20 53 02 00       	mov    %eax,0x25320
        free(image_in_content_scaled);
    355f:	a1 4c 58 02 00       	mov    0x2584c,%eax
    3564:	83 ec 0c             	sub    $0xc,%esp
    3567:	50                   	push   %eax
    3568:	e8 0e 3a 00 00       	call   6f7b <free>
    356d:	83 c4 10             	add    $0x10,%esp
        api_repaint(&wnd);
    3570:	83 ec 0c             	sub    $0xc,%esp
    3573:	68 a0 58 02 00       	push   $0x258a0
    3578:	e8 0c 47 00 00       	call   7c89 <api_repaint>
    357d:	83 c4 10             	add    $0x10,%esp
        has_content = 1;
    3580:	c7 05 a4 57 02 00 01 	movl   $0x1,0x257a4
    3587:	00 00 00 
        printf(1, "yes!!\n\n\n");
    358a:	83 ec 08             	sub    $0x8,%esp
    358d:	68 23 c8 01 00       	push   $0x1c823
    3592:	6a 01                	push   $0x1
    3594:	e8 51 38 00 00       	call   6dea <printf>
    3599:	83 c4 10             	add    $0x10,%esp
}

void image_scale_process(float zoom_degree)
{
    if(has_content == 1 && current_gif_img->gif_img_num > 1 && current_gif_img->is_onshow == 1)
    {
    359c:	e9 7b 02 00 00       	jmp    381c <image_scale_process+0x620>
        has_content = 1;
        printf(1, "yes!!\n\n\n");
    }
    else
    {
        scale_degree=scale_degree*zoom_degree;
    35a1:	d9 05 30 53 02 00    	flds   0x25330
    35a7:	d8 4d 08             	fmuls  0x8(%ebp)
    35aa:	d9 1d 30 53 02 00    	fstps  0x25330
        image_scale->height=image_origin->height*scale_degree;
    35b0:	8b 15 8c 58 02 00    	mov    0x2588c,%edx
    35b6:	a1 80 58 02 00       	mov    0x25880,%eax
    35bb:	8b 40 04             	mov    0x4(%eax),%eax
    35be:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
    35c4:	db 85 7c ff ff ff    	fildl  -0x84(%ebp)
    35ca:	d9 05 30 53 02 00    	flds   0x25330
    35d0:	de c9                	fmulp  %st,%st(1)
    35d2:	d9 7d 86             	fnstcw -0x7a(%ebp)
    35d5:	0f b7 45 86          	movzwl -0x7a(%ebp),%eax
    35d9:	b4 0c                	mov    $0xc,%ah
    35db:	66 89 45 84          	mov    %ax,-0x7c(%ebp)
    35df:	d9 6d 84             	fldcw  -0x7c(%ebp)
    35e2:	db 5d 80             	fistpl -0x80(%ebp)
    35e5:	d9 6d 86             	fldcw  -0x7a(%ebp)
    35e8:	8b 45 80             	mov    -0x80(%ebp),%eax
    35eb:	89 42 04             	mov    %eax,0x4(%edx)
        image_scale->width=image_origin->width*scale_degree;
    35ee:	a1 8c 58 02 00       	mov    0x2588c,%eax
    35f3:	8b 15 80 58 02 00    	mov    0x25880,%edx
    35f9:	8b 12                	mov    (%edx),%edx
    35fb:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
    3601:	db 85 7c ff ff ff    	fildl  -0x84(%ebp)
    3607:	d9 05 30 53 02 00    	flds   0x25330
    360d:	de c9                	fmulp  %st,%st(1)
    360f:	d9 6d 84             	fldcw  -0x7c(%ebp)
    3612:	db 5d 80             	fistpl -0x80(%ebp)
    3615:	d9 6d 86             	fldcw  -0x7a(%ebp)
    3618:	8b 55 80             	mov    -0x80(%ebp),%edx
    361b:	89 10                	mov    %edx,(%eax)
        image_in_content_scaled=(RGB*)malloc(sizeof(RGB)*image_scale->height*image_scale->width);
    361d:	a1 8c 58 02 00       	mov    0x2588c,%eax
    3622:	8b 40 04             	mov    0x4(%eax),%eax
    3625:	89 c2                	mov    %eax,%edx
    3627:	a1 8c 58 02 00       	mov    0x2588c,%eax
    362c:	8b 00                	mov    (%eax),%eax
    362e:	0f af d0             	imul   %eax,%edx
    3631:	89 d0                	mov    %edx,%eax
    3633:	01 c0                	add    %eax,%eax
    3635:	01 d0                	add    %edx,%eax
    3637:	83 ec 0c             	sub    $0xc,%esp
    363a:	50                   	push   %eax
    363b:	e8 7d 3a 00 00       	call   70bd <malloc>
    3640:	83 c4 10             	add    $0x10,%esp
    3643:	a3 4c 58 02 00       	mov    %eax,0x2584c
        image_scale->data=image_in_content_scaled;
    3648:	a1 8c 58 02 00       	mov    0x2588c,%eax
    364d:	8b 15 4c 58 02 00    	mov    0x2584c,%edx
    3653:	89 50 08             	mov    %edx,0x8(%eax)
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
    3656:	a1 e0 52 02 00       	mov    0x252e0,%eax
    365b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for (int i = 0; i < edit_img_size.h; i++) {
    365e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    3665:	eb 68                	jmp    36cf <image_scale_process+0x4d3>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    3667:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    366d:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    3673:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3676:	01 c2                	add    %eax,%edx
    3678:	a1 b0 58 02 00       	mov    0x258b0,%eax
    367d:	0f af c2             	imul   %edx,%eax
    3680:	89 c2                	mov    %eax,%edx
    3682:	a1 e4 52 02 00       	mov    0x252e4,%eax
    3687:	01 c2                	add    %eax,%edx
    3689:	89 d0                	mov    %edx,%eax
    368b:	01 c0                	add    %eax,%eax
    368d:	01 d0                	add    %edx,%eax
    368f:	01 c8                	add    %ecx,%eax
    3691:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            t = edit_img_origin + i * edit_img_size.w;
    3694:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    369a:	a1 e0 52 02 00       	mov    0x252e0,%eax
    369f:	0f af 45 f0          	imul   -0x10(%ebp),%eax
    36a3:	89 c1                	mov    %eax,%ecx
    36a5:	89 c8                	mov    %ecx,%eax
    36a7:	01 c0                	add    %eax,%eax
    36a9:	01 c8                	add    %ecx,%eax
    36ab:	01 d0                	add    %edx,%eax
    36ad:	89 45 d0             	mov    %eax,-0x30(%ebp)
            memmove(o, t, max_line * 3);
    36b0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    36b3:	89 d0                	mov    %edx,%eax
    36b5:	01 c0                	add    %eax,%eax
    36b7:	01 d0                	add    %edx,%eax
    36b9:	83 ec 04             	sub    $0x4,%esp
    36bc:	50                   	push   %eax
    36bd:	ff 75 d0             	pushl  -0x30(%ebp)
    36c0:	ff 75 d4             	pushl  -0x2c(%ebp)
    36c3:	e8 36 35 00 00       	call   6bfe <memmove>
    36c8:	83 c4 10             	add    $0x10,%esp
        image_in_content_scaled=(RGB*)malloc(sizeof(RGB)*image_scale->height*image_scale->width);
        image_scale->data=image_in_content_scaled;
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
        for (int i = 0; i < edit_img_size.h; i++) {
    36cb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    36cf:	a1 dc 52 02 00       	mov    0x252dc,%eax
    36d4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    36d7:	7f 8e                	jg     3667 <image_scale_process+0x46b>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
            t = edit_img_origin + i * edit_img_size.w;
            memmove(o, t, max_line * 3);
        }
        picScale(image_origin, image_scale);
    36d9:	8b 15 8c 58 02 00    	mov    0x2588c,%edx
    36df:	a1 80 58 02 00       	mov    0x25880,%eax
    36e4:	83 ec 08             	sub    $0x8,%esp
    36e7:	52                   	push   %edx
    36e8:	50                   	push   %eax
    36e9:	e8 96 57 00 00       	call   8e84 <picScale>
    36ee:	83 c4 10             	add    $0x10,%esp
        int pos_y=235-image_scale->height/2;
    36f1:	a1 8c 58 02 00       	mov    0x2588c,%eax
    36f6:	8b 40 04             	mov    0x4(%eax),%eax
    36f9:	89 c2                	mov    %eax,%edx
    36fb:	c1 ea 1f             	shr    $0x1f,%edx
    36fe:	01 d0                	add    %edx,%eax
    3700:	d1 f8                	sar    %eax
    3702:	ba eb 00 00 00       	mov    $0xeb,%edx
    3707:	29 c2                	sub    %eax,%edx
    3709:	89 d0                	mov    %edx,%eax
    370b:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int pos_x=390-image_scale->width/2;
    370e:	a1 8c 58 02 00       	mov    0x2588c,%eax
    3713:	8b 00                	mov    (%eax),%eax
    3715:	89 c2                	mov    %eax,%edx
    3717:	c1 ea 1f             	shr    $0x1f,%edx
    371a:	01 d0                	add    %edx,%eax
    371c:	d1 f8                	sar    %eax
    371e:	ba 86 01 00 00       	mov    $0x186,%edx
    3723:	29 c2                	sub    %eax,%edx
    3725:	89 d0                	mov    %edx,%eax
    3727:	89 45 c8             	mov    %eax,-0x38(%ebp)
        api_paint24BitmapToContent(&wnd, image_scale->data, (Point){pos_x,pos_y}, (Point){0,0}, (Size){image_scale->height,image_scale->width},(Size){image_scale->height,image_scale->width});
    372a:	a1 8c 58 02 00       	mov    0x2588c,%eax
    372f:	8b 40 04             	mov    0x4(%eax),%eax
    3732:	89 45 a8             	mov    %eax,-0x58(%ebp)
    3735:	a1 8c 58 02 00       	mov    0x2588c,%eax
    373a:	8b 00                	mov    (%eax),%eax
    373c:	89 45 ac             	mov    %eax,-0x54(%ebp)
    373f:	a1 8c 58 02 00       	mov    0x2588c,%eax
    3744:	8b 40 04             	mov    0x4(%eax),%eax
    3747:	89 45 b0             	mov    %eax,-0x50(%ebp)
    374a:	a1 8c 58 02 00       	mov    0x2588c,%eax
    374f:	8b 00                	mov    (%eax),%eax
    3751:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    3754:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    375b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    3762:	8b 45 c8             	mov    -0x38(%ebp),%eax
    3765:	89 45 c0             	mov    %eax,-0x40(%ebp)
    3768:	8b 45 cc             	mov    -0x34(%ebp),%eax
    376b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    376e:	a1 8c 58 02 00       	mov    0x2588c,%eax
    3773:	8b 40 08             	mov    0x8(%eax),%eax
    3776:	83 ec 08             	sub    $0x8,%esp
    3779:	ff 75 ac             	pushl  -0x54(%ebp)
    377c:	ff 75 a8             	pushl  -0x58(%ebp)
    377f:	ff 75 b4             	pushl  -0x4c(%ebp)
    3782:	ff 75 b0             	pushl  -0x50(%ebp)
    3785:	ff 75 bc             	pushl  -0x44(%ebp)
    3788:	ff 75 b8             	pushl  -0x48(%ebp)
    378b:	ff 75 c4             	pushl  -0x3c(%ebp)
    378e:	ff 75 c0             	pushl  -0x40(%ebp)
    3791:	50                   	push   %eax
    3792:	68 a0 58 02 00       	push   $0x258a0
    3797:	e8 6d 44 00 00       	call   7c09 <api_paint24BitmapToContent>
    379c:	83 c4 30             	add    $0x30,%esp
        content_size=(Size){image_scale->height,image_scale->width};
    379f:	a1 8c 58 02 00       	mov    0x2588c,%eax
    37a4:	8b 50 04             	mov    0x4(%eax),%edx
    37a7:	a1 8c 58 02 00       	mov    0x2588c,%eax
    37ac:	8b 00                	mov    (%eax),%eax
    37ae:	89 15 0c 53 02 00    	mov    %edx,0x2530c
    37b4:	a3 10 53 02 00       	mov    %eax,0x25310
        content_pos=(Point){140 + (500-content_size.w)/2,30 + (410-content_size.h)/2};
    37b9:	a1 10 53 02 00       	mov    0x25310,%eax
    37be:	ba f4 01 00 00       	mov    $0x1f4,%edx
    37c3:	29 c2                	sub    %eax,%edx
    37c5:	89 d0                	mov    %edx,%eax
    37c7:	89 c2                	mov    %eax,%edx
    37c9:	c1 ea 1f             	shr    $0x1f,%edx
    37cc:	01 d0                	add    %edx,%eax
    37ce:	d1 f8                	sar    %eax
    37d0:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
    37d6:	a1 0c 53 02 00       	mov    0x2530c,%eax
    37db:	b9 9a 01 00 00       	mov    $0x19a,%ecx
    37e0:	29 c1                	sub    %eax,%ecx
    37e2:	89 c8                	mov    %ecx,%eax
    37e4:	89 c1                	mov    %eax,%ecx
    37e6:	c1 e9 1f             	shr    $0x1f,%ecx
    37e9:	01 c8                	add    %ecx,%eax
    37eb:	d1 f8                	sar    %eax
    37ed:	83 c0 1e             	add    $0x1e,%eax
    37f0:	89 15 1c 53 02 00    	mov    %edx,0x2531c
    37f6:	a3 20 53 02 00       	mov    %eax,0x25320
        free(image_in_content_scaled);
    37fb:	a1 4c 58 02 00       	mov    0x2584c,%eax
    3800:	83 ec 0c             	sub    $0xc,%esp
    3803:	50                   	push   %eax
    3804:	e8 72 37 00 00       	call   6f7b <free>
    3809:	83 c4 10             	add    $0x10,%esp
        api_repaint(&wnd);
    380c:	83 ec 0c             	sub    $0xc,%esp
    380f:	68 a0 58 02 00       	push   $0x258a0
    3814:	e8 70 44 00 00       	call   7c89 <api_repaint>
    3819:	83 c4 10             	add    $0x10,%esp
    }
}
    381c:	90                   	nop
    381d:	c9                   	leave  
    381e:	c3                   	ret    

0000381f <isMouseInZoominButton>:

int isMouseInZoominButton(int x, int y) {
    381f:	55                   	push   %ebp
    3820:	89 e5                	mov    %esp,%ebp
    3822:	83 ec 08             	sub    $0x8,%esp
   if (140 < x && x <= 200 && 440 <= y && y <= 500){
    3825:	81 7d 08 8c 00 00 00 	cmpl   $0x8c,0x8(%ebp)
    382c:	7e 3a                	jle    3868 <isMouseInZoominButton+0x49>
    382e:	81 7d 08 c8 00 00 00 	cmpl   $0xc8,0x8(%ebp)
    3835:	7f 31                	jg     3868 <isMouseInZoominButton+0x49>
    3837:	81 7d 0c b7 01 00 00 	cmpl   $0x1b7,0xc(%ebp)
    383e:	7e 28                	jle    3868 <isMouseInZoominButton+0x49>
    3840:	81 7d 0c f4 01 00 00 	cmpl   $0x1f4,0xc(%ebp)
    3847:	7f 1f                	jg     3868 <isMouseInZoominButton+0x49>
        image_scale_process(2);
    3849:	83 ec 0c             	sub    $0xc,%esp
    384c:	d9 05 d4 c8 01 00    	flds   0x1c8d4
    3852:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    3856:	d9 1c 24             	fstps  (%esp)
    3859:	e8 9e f9 ff ff       	call   31fc <image_scale_process>
    385e:	83 c4 10             	add    $0x10,%esp
        return 1;
    3861:	b8 01 00 00 00       	mov    $0x1,%eax
    3866:	eb 05                	jmp    386d <isMouseInZoominButton+0x4e>
   }
   else {
        return 0;
    3868:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    386d:	c9                   	leave  
    386e:	c3                   	ret    

0000386f <isMouseInZoomoutButton>:

int isMouseInZoomoutButton(int x, int y) {
    386f:	55                   	push   %ebp
    3870:	89 e5                	mov    %esp,%ebp
    3872:	83 ec 08             	sub    $0x8,%esp
   if (200 < x && x <= 260 && 440 <= y && y <= 500){
    3875:	81 7d 08 c8 00 00 00 	cmpl   $0xc8,0x8(%ebp)
    387c:	7e 3a                	jle    38b8 <isMouseInZoomoutButton+0x49>
    387e:	81 7d 08 04 01 00 00 	cmpl   $0x104,0x8(%ebp)
    3885:	7f 31                	jg     38b8 <isMouseInZoomoutButton+0x49>
    3887:	81 7d 0c b7 01 00 00 	cmpl   $0x1b7,0xc(%ebp)
    388e:	7e 28                	jle    38b8 <isMouseInZoomoutButton+0x49>
    3890:	81 7d 0c f4 01 00 00 	cmpl   $0x1f4,0xc(%ebp)
    3897:	7f 1f                	jg     38b8 <isMouseInZoomoutButton+0x49>
        image_scale_process(0.5);
    3899:	83 ec 0c             	sub    $0xc,%esp
    389c:	d9 05 d8 c8 01 00    	flds   0x1c8d8
    38a2:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    38a6:	d9 1c 24             	fstps  (%esp)
    38a9:	e8 4e f9 ff ff       	call   31fc <image_scale_process>
    38ae:	83 c4 10             	add    $0x10,%esp
        return 1;
    38b1:	b8 01 00 00 00       	mov    $0x1,%eax
    38b6:	eb 05                	jmp    38bd <isMouseInZoomoutButton+0x4e>
   }
   else {
        return 0;
    38b8:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    38bd:	c9                   	leave  
    38be:	c3                   	ret    

000038bf <image_turn_process>:

void image_turn_process(float rotate_degree)
{
    38bf:	55                   	push   %ebp
    38c0:	89 e5                	mov    %esp,%ebp
    38c2:	83 ec 48             	sub    $0x48,%esp
    turn_degree=turn_degree+rotate_degree;
    38c5:	d9 05 b0 57 02 00    	flds   0x257b0
    38cb:	d8 45 08             	fadds  0x8(%ebp)
    38ce:	d9 1d b0 57 02 00    	fstps  0x257b0
    image_turn->height=image_origin->height;
    38d4:	a1 dc 58 02 00       	mov    0x258dc,%eax
    38d9:	8b 15 80 58 02 00    	mov    0x25880,%edx
    38df:	8b 52 04             	mov    0x4(%edx),%edx
    38e2:	89 50 04             	mov    %edx,0x4(%eax)
    image_turn->width=image_origin->width;
    38e5:	a1 dc 58 02 00       	mov    0x258dc,%eax
    38ea:	8b 15 80 58 02 00    	mov    0x25880,%edx
    38f0:	8b 12                	mov    (%edx),%edx
    38f2:	89 10                	mov    %edx,(%eax)
    printf(1, "0 %d, %d", image_turn->width, image_turn->height);
    38f4:	a1 dc 58 02 00       	mov    0x258dc,%eax
    38f9:	8b 50 04             	mov    0x4(%eax),%edx
    38fc:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3901:	8b 00                	mov    (%eax),%eax
    3903:	52                   	push   %edx
    3904:	50                   	push   %eax
    3905:	68 2c c8 01 00       	push   $0x1c82c
    390a:	6a 01                	push   $0x1
    390c:	e8 d9 34 00 00       	call   6dea <printf>
    3911:	83 c4 10             	add    $0x10,%esp
    getTurnSize(&(image_turn->width), &(image_turn->height), turn_degree);
    3914:	d9 05 b0 57 02 00    	flds   0x257b0
    391a:	a1 dc 58 02 00       	mov    0x258dc,%eax
    391f:	83 c0 04             	add    $0x4,%eax
    3922:	8b 15 dc 58 02 00    	mov    0x258dc,%edx
    3928:	83 ec 04             	sub    $0x4,%esp
    392b:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    392f:	d9 1c 24             	fstps  (%esp)
    3932:	50                   	push   %eax
    3933:	52                   	push   %edx
    3934:	e8 da 56 00 00       	call   9013 <getTurnSize>
    3939:	83 c4 10             	add    $0x10,%esp
    printf(1, "1 %d, %d", image_turn->width, image_turn->height);
    393c:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3941:	8b 50 04             	mov    0x4(%eax),%edx
    3944:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3949:	8b 00                	mov    (%eax),%eax
    394b:	52                   	push   %edx
    394c:	50                   	push   %eax
    394d:	68 35 c8 01 00       	push   $0x1c835
    3952:	6a 01                	push   $0x1
    3954:	e8 91 34 00 00       	call   6dea <printf>
    3959:	83 c4 10             	add    $0x10,%esp
    image_in_content_turned=(RGB*)malloc(sizeof(RGB)*image_turn->height*image_turn->width);
    395c:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3961:	8b 40 04             	mov    0x4(%eax),%eax
    3964:	89 c2                	mov    %eax,%edx
    3966:	a1 dc 58 02 00       	mov    0x258dc,%eax
    396b:	8b 00                	mov    (%eax),%eax
    396d:	0f af d0             	imul   %eax,%edx
    3970:	89 d0                	mov    %edx,%eax
    3972:	01 c0                	add    %eax,%eax
    3974:	01 d0                	add    %edx,%eax
    3976:	83 ec 0c             	sub    $0xc,%esp
    3979:	50                   	push   %eax
    397a:	e8 3e 37 00 00       	call   70bd <malloc>
    397f:	83 c4 10             	add    $0x10,%esp
    3982:	a3 40 58 02 00       	mov    %eax,0x25840
    image_turn->data=image_in_content_turned;
    3987:	a1 dc 58 02 00       	mov    0x258dc,%eax
    398c:	8b 15 40 58 02 00    	mov    0x25840,%edx
    3992:	89 50 08             	mov    %edx,0x8(%eax)
    struct RGB *t;
    struct RGB *o;
    int max_line = edit_img_size.w;
    3995:	a1 e0 52 02 00       	mov    0x252e0,%eax
    399a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (int i = 0; i < edit_img_size.h; i++) {
    399d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    39a4:	eb 68                	jmp    3a0e <image_turn_process+0x14f>
        o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    39a6:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    39ac:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    39b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    39b5:	01 c2                	add    %eax,%edx
    39b7:	a1 b0 58 02 00       	mov    0x258b0,%eax
    39bc:	0f af c2             	imul   %edx,%eax
    39bf:	89 c2                	mov    %eax,%edx
    39c1:	a1 e4 52 02 00       	mov    0x252e4,%eax
    39c6:	01 c2                	add    %eax,%edx
    39c8:	89 d0                	mov    %edx,%eax
    39ca:	01 c0                	add    %eax,%eax
    39cc:	01 d0                	add    %edx,%eax
    39ce:	01 c8                	add    %ecx,%eax
    39d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        t = edit_img_origin + i * edit_img_size.w;
    39d3:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    39d9:	a1 e0 52 02 00       	mov    0x252e0,%eax
    39de:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    39e2:	89 c1                	mov    %eax,%ecx
    39e4:	89 c8                	mov    %ecx,%eax
    39e6:	01 c0                	add    %eax,%eax
    39e8:	01 c8                	add    %ecx,%eax
    39ea:	01 d0                	add    %edx,%eax
    39ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
        memmove(o, t, max_line * 3);
    39ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
    39f2:	89 d0                	mov    %edx,%eax
    39f4:	01 c0                	add    %eax,%eax
    39f6:	01 d0                	add    %edx,%eax
    39f8:	83 ec 04             	sub    $0x4,%esp
    39fb:	50                   	push   %eax
    39fc:	ff 75 e8             	pushl  -0x18(%ebp)
    39ff:	ff 75 ec             	pushl  -0x14(%ebp)
    3a02:	e8 f7 31 00 00       	call   6bfe <memmove>
    3a07:	83 c4 10             	add    $0x10,%esp
    image_in_content_turned=(RGB*)malloc(sizeof(RGB)*image_turn->height*image_turn->width);
    image_turn->data=image_in_content_turned;
    struct RGB *t;
    struct RGB *o;
    int max_line = edit_img_size.w;
    for (int i = 0; i < edit_img_size.h; i++) {
    3a0a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a0e:	a1 dc 52 02 00       	mov    0x252dc,%eax
    3a13:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3a16:	7f 8e                	jg     39a6 <image_turn_process+0xe7>
        o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
        t = edit_img_origin + i * edit_img_size.w;
        memmove(o, t, max_line * 3);
    }
    picTurn(image_origin, image_turn, turn_degree);
    3a18:	d9 05 b0 57 02 00    	flds   0x257b0
    3a1e:	8b 15 dc 58 02 00    	mov    0x258dc,%edx
    3a24:	a1 80 58 02 00       	mov    0x25880,%eax
    3a29:	83 ec 04             	sub    $0x4,%esp
    3a2c:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    3a30:	d9 1c 24             	fstps  (%esp)
    3a33:	52                   	push   %edx
    3a34:	50                   	push   %eax
    3a35:	e8 f2 56 00 00       	call   912c <picTurn>
    3a3a:	83 c4 10             	add    $0x10,%esp
    int pos_y=235-image_turn->height/2;
    3a3d:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3a42:	8b 40 04             	mov    0x4(%eax),%eax
    3a45:	89 c2                	mov    %eax,%edx
    3a47:	c1 ea 1f             	shr    $0x1f,%edx
    3a4a:	01 d0                	add    %edx,%eax
    3a4c:	d1 f8                	sar    %eax
    3a4e:	ba eb 00 00 00       	mov    $0xeb,%edx
    3a53:	29 c2                	sub    %eax,%edx
    3a55:	89 d0                	mov    %edx,%eax
    3a57:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int pos_x=390-image_turn->width/2;
    3a5a:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3a5f:	8b 00                	mov    (%eax),%eax
    3a61:	89 c2                	mov    %eax,%edx
    3a63:	c1 ea 1f             	shr    $0x1f,%edx
    3a66:	01 d0                	add    %edx,%eax
    3a68:	d1 f8                	sar    %eax
    3a6a:	ba 86 01 00 00       	mov    $0x186,%edx
    3a6f:	29 c2                	sub    %eax,%edx
    3a71:	89 d0                	mov    %edx,%eax
    3a73:	89 45 e0             	mov    %eax,-0x20(%ebp)
    api_paint24BitmapToContent(&wnd, image_turn->data, (Point){pos_x,pos_y}, (Point){0,0}, (Size){image_turn->height,image_turn->width},(Size){image_turn->height,image_turn->width});
    3a76:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3a7b:	8b 40 04             	mov    0x4(%eax),%eax
    3a7e:	89 45 c0             	mov    %eax,-0x40(%ebp)
    3a81:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3a86:	8b 00                	mov    (%eax),%eax
    3a88:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3a8b:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3a90:	8b 40 04             	mov    0x4(%eax),%eax
    3a93:	89 45 c8             	mov    %eax,-0x38(%ebp)
    3a96:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3a9b:	8b 00                	mov    (%eax),%eax
    3a9d:	89 45 cc             	mov    %eax,-0x34(%ebp)
    3aa0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    3aa7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    3aae:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3ab1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    3ab4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3ab7:	89 45 dc             	mov    %eax,-0x24(%ebp)
    3aba:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3abf:	8b 40 08             	mov    0x8(%eax),%eax
    3ac2:	83 ec 08             	sub    $0x8,%esp
    3ac5:	ff 75 c4             	pushl  -0x3c(%ebp)
    3ac8:	ff 75 c0             	pushl  -0x40(%ebp)
    3acb:	ff 75 cc             	pushl  -0x34(%ebp)
    3ace:	ff 75 c8             	pushl  -0x38(%ebp)
    3ad1:	ff 75 d4             	pushl  -0x2c(%ebp)
    3ad4:	ff 75 d0             	pushl  -0x30(%ebp)
    3ad7:	ff 75 dc             	pushl  -0x24(%ebp)
    3ada:	ff 75 d8             	pushl  -0x28(%ebp)
    3add:	50                   	push   %eax
    3ade:	68 a0 58 02 00       	push   $0x258a0
    3ae3:	e8 21 41 00 00       	call   7c09 <api_paint24BitmapToContent>
    3ae8:	83 c4 30             	add    $0x30,%esp
    content_size=(Size){image_turn->height,image_turn->width};
    3aeb:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3af0:	8b 50 04             	mov    0x4(%eax),%edx
    3af3:	a1 dc 58 02 00       	mov    0x258dc,%eax
    3af8:	8b 00                	mov    (%eax),%eax
    3afa:	89 15 0c 53 02 00    	mov    %edx,0x2530c
    3b00:	a3 10 53 02 00       	mov    %eax,0x25310
    content_pos=(Point){140 + (500-content_size.w)/2,30 + (410-content_size.h)/2};
    3b05:	a1 10 53 02 00       	mov    0x25310,%eax
    3b0a:	ba f4 01 00 00       	mov    $0x1f4,%edx
    3b0f:	29 c2                	sub    %eax,%edx
    3b11:	89 d0                	mov    %edx,%eax
    3b13:	89 c2                	mov    %eax,%edx
    3b15:	c1 ea 1f             	shr    $0x1f,%edx
    3b18:	01 d0                	add    %edx,%eax
    3b1a:	d1 f8                	sar    %eax
    3b1c:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
    3b22:	a1 0c 53 02 00       	mov    0x2530c,%eax
    3b27:	b9 9a 01 00 00       	mov    $0x19a,%ecx
    3b2c:	29 c1                	sub    %eax,%ecx
    3b2e:	89 c8                	mov    %ecx,%eax
    3b30:	89 c1                	mov    %eax,%ecx
    3b32:	c1 e9 1f             	shr    $0x1f,%ecx
    3b35:	01 c8                	add    %ecx,%eax
    3b37:	d1 f8                	sar    %eax
    3b39:	83 c0 1e             	add    $0x1e,%eax
    3b3c:	89 15 1c 53 02 00    	mov    %edx,0x2531c
    3b42:	a3 20 53 02 00       	mov    %eax,0x25320
    free(image_in_content_turned);
    3b47:	a1 40 58 02 00       	mov    0x25840,%eax
    3b4c:	83 ec 0c             	sub    $0xc,%esp
    3b4f:	50                   	push   %eax
    3b50:	e8 26 34 00 00       	call   6f7b <free>
    3b55:	83 c4 10             	add    $0x10,%esp
    api_repaint(&wnd);
    3b58:	83 ec 0c             	sub    $0xc,%esp
    3b5b:	68 a0 58 02 00       	push   $0x258a0
    3b60:	e8 24 41 00 00       	call   7c89 <api_repaint>
    3b65:	83 c4 10             	add    $0x10,%esp
}
    3b68:	90                   	nop
    3b69:	c9                   	leave  
    3b6a:	c3                   	ret    

00003b6b <isMouseInRotateLeftNinetyButton>:

int isMouseInRotateLeftNinetyButton(int x, int y) {
    3b6b:	55                   	push   %ebp
    3b6c:	89 e5                	mov    %esp,%ebp
    3b6e:	83 ec 08             	sub    $0x8,%esp
   if (260 < x && x <= 325 && 440 <= y && y <= 500){
    3b71:	81 7d 08 04 01 00 00 	cmpl   $0x104,0x8(%ebp)
    3b78:	7e 3a                	jle    3bb4 <isMouseInRotateLeftNinetyButton+0x49>
    3b7a:	81 7d 08 45 01 00 00 	cmpl   $0x145,0x8(%ebp)
    3b81:	7f 31                	jg     3bb4 <isMouseInRotateLeftNinetyButton+0x49>
    3b83:	81 7d 0c b7 01 00 00 	cmpl   $0x1b7,0xc(%ebp)
    3b8a:	7e 28                	jle    3bb4 <isMouseInRotateLeftNinetyButton+0x49>
    3b8c:	81 7d 0c f4 01 00 00 	cmpl   $0x1f4,0xc(%ebp)
    3b93:	7f 1f                	jg     3bb4 <isMouseInRotateLeftNinetyButton+0x49>
        image_turn_process(-PI/2);
    3b95:	83 ec 0c             	sub    $0xc,%esp
    3b98:	d9 05 dc c8 01 00    	flds   0x1c8dc
    3b9e:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    3ba2:	d9 1c 24             	fstps  (%esp)
    3ba5:	e8 15 fd ff ff       	call   38bf <image_turn_process>
    3baa:	83 c4 10             	add    $0x10,%esp
        return 1;
    3bad:	b8 01 00 00 00       	mov    $0x1,%eax
    3bb2:	eb 05                	jmp    3bb9 <isMouseInRotateLeftNinetyButton+0x4e>
   }
   else {
        return 0;
    3bb4:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    3bb9:	c9                   	leave  
    3bba:	c3                   	ret    

00003bbb <isMouseInRotateLeftThirtyButton>:

int isMouseInRotateLeftThirtyButton(int x, int y) {
    3bbb:	55                   	push   %ebp
    3bbc:	89 e5                	mov    %esp,%ebp
    3bbe:	83 ec 08             	sub    $0x8,%esp
   if (325 < x && x <= 390 && 440 <= y && y <= 500){
    3bc1:	81 7d 08 45 01 00 00 	cmpl   $0x145,0x8(%ebp)
    3bc8:	7e 3a                	jle    3c04 <isMouseInRotateLeftThirtyButton+0x49>
    3bca:	81 7d 08 86 01 00 00 	cmpl   $0x186,0x8(%ebp)
    3bd1:	7f 31                	jg     3c04 <isMouseInRotateLeftThirtyButton+0x49>
    3bd3:	81 7d 0c b7 01 00 00 	cmpl   $0x1b7,0xc(%ebp)
    3bda:	7e 28                	jle    3c04 <isMouseInRotateLeftThirtyButton+0x49>
    3bdc:	81 7d 0c f4 01 00 00 	cmpl   $0x1f4,0xc(%ebp)
    3be3:	7f 1f                	jg     3c04 <isMouseInRotateLeftThirtyButton+0x49>
        image_turn_process(-PI/6);
    3be5:	83 ec 0c             	sub    $0xc,%esp
    3be8:	d9 05 e0 c8 01 00    	flds   0x1c8e0
    3bee:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    3bf2:	d9 1c 24             	fstps  (%esp)
    3bf5:	e8 c5 fc ff ff       	call   38bf <image_turn_process>
    3bfa:	83 c4 10             	add    $0x10,%esp
        return 1;
    3bfd:	b8 01 00 00 00       	mov    $0x1,%eax
    3c02:	eb 05                	jmp    3c09 <isMouseInRotateLeftThirtyButton+0x4e>
   }
   else {
        return 0;
    3c04:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    3c09:	c9                   	leave  
    3c0a:	c3                   	ret    

00003c0b <isMouseInRotateRightThirtyButton>:

int isMouseInRotateRightThirtyButton(int x, int y) {
    3c0b:	55                   	push   %ebp
    3c0c:	89 e5                	mov    %esp,%ebp
    3c0e:	83 ec 08             	sub    $0x8,%esp
   if (390 < x && x <= 455 && 440 <= y && y <= 500){
    3c11:	81 7d 08 86 01 00 00 	cmpl   $0x186,0x8(%ebp)
    3c18:	7e 3a                	jle    3c54 <isMouseInRotateRightThirtyButton+0x49>
    3c1a:	81 7d 08 c7 01 00 00 	cmpl   $0x1c7,0x8(%ebp)
    3c21:	7f 31                	jg     3c54 <isMouseInRotateRightThirtyButton+0x49>
    3c23:	81 7d 0c b7 01 00 00 	cmpl   $0x1b7,0xc(%ebp)
    3c2a:	7e 28                	jle    3c54 <isMouseInRotateRightThirtyButton+0x49>
    3c2c:	81 7d 0c f4 01 00 00 	cmpl   $0x1f4,0xc(%ebp)
    3c33:	7f 1f                	jg     3c54 <isMouseInRotateRightThirtyButton+0x49>
        image_turn_process(PI/6);
    3c35:	83 ec 0c             	sub    $0xc,%esp
    3c38:	d9 05 e4 c8 01 00    	flds   0x1c8e4
    3c3e:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    3c42:	d9 1c 24             	fstps  (%esp)
    3c45:	e8 75 fc ff ff       	call   38bf <image_turn_process>
    3c4a:	83 c4 10             	add    $0x10,%esp
        return 1;
    3c4d:	b8 01 00 00 00       	mov    $0x1,%eax
    3c52:	eb 05                	jmp    3c59 <isMouseInRotateRightThirtyButton+0x4e>
   }
   else {
        return 0;
    3c54:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    3c59:	c9                   	leave  
    3c5a:	c3                   	ret    

00003c5b <isMouseInRotateRightNinetyButton>:

int isMouseInRotateRightNinetyButton(int x, int y) {
    3c5b:	55                   	push   %ebp
    3c5c:	89 e5                	mov    %esp,%ebp
    3c5e:	83 ec 08             	sub    $0x8,%esp
   if (455 < x && x <= 520 && 440 <= y && y <= 500){
    3c61:	81 7d 08 c7 01 00 00 	cmpl   $0x1c7,0x8(%ebp)
    3c68:	7e 3a                	jle    3ca4 <isMouseInRotateRightNinetyButton+0x49>
    3c6a:	81 7d 08 08 02 00 00 	cmpl   $0x208,0x8(%ebp)
    3c71:	7f 31                	jg     3ca4 <isMouseInRotateRightNinetyButton+0x49>
    3c73:	81 7d 0c b7 01 00 00 	cmpl   $0x1b7,0xc(%ebp)
    3c7a:	7e 28                	jle    3ca4 <isMouseInRotateRightNinetyButton+0x49>
    3c7c:	81 7d 0c f4 01 00 00 	cmpl   $0x1f4,0xc(%ebp)
    3c83:	7f 1f                	jg     3ca4 <isMouseInRotateRightNinetyButton+0x49>
        image_turn_process(PI/2);
    3c85:	83 ec 0c             	sub    $0xc,%esp
    3c88:	d9 05 e8 c8 01 00    	flds   0x1c8e8
    3c8e:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    3c92:	d9 1c 24             	fstps  (%esp)
    3c95:	e8 25 fc ff ff       	call   38bf <image_turn_process>
    3c9a:	83 c4 10             	add    $0x10,%esp
        return 1;
    3c9d:	b8 01 00 00 00       	mov    $0x1,%eax
    3ca2:	eb 05                	jmp    3ca9 <isMouseInRotateRightNinetyButton+0x4e>
   }
   else {
        return 0;
    3ca4:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    3ca9:	c9                   	leave  
    3caa:	c3                   	ret    

00003cab <isMouseInRolloverButton>:

int isMouseInRolloverButton(int x, int y) {
    3cab:	55                   	push   %ebp
    3cac:	89 e5                	mov    %esp,%ebp
    3cae:	83 ec 48             	sub    $0x48,%esp
   if (520 < x && x <= 580 && 440 <= y && y <= 500){
    3cb1:	81 7d 08 08 02 00 00 	cmpl   $0x208,0x8(%ebp)
    3cb8:	0f 8e c9 02 00 00    	jle    3f87 <isMouseInRolloverButton+0x2dc>
    3cbe:	81 7d 08 44 02 00 00 	cmpl   $0x244,0x8(%ebp)
    3cc5:	0f 8f bc 02 00 00    	jg     3f87 <isMouseInRolloverButton+0x2dc>
    3ccb:	81 7d 0c b7 01 00 00 	cmpl   $0x1b7,0xc(%ebp)
    3cd2:	0f 8e af 02 00 00    	jle    3f87 <isMouseInRolloverButton+0x2dc>
    3cd8:	81 7d 0c f4 01 00 00 	cmpl   $0x1f4,0xc(%ebp)
    3cdf:	0f 8f a2 02 00 00    	jg     3f87 <isMouseInRolloverButton+0x2dc>
        image_origin_mirror->data=image_in_content_torollover;
    3ce5:	a1 50 58 02 00       	mov    0x25850,%eax
    3cea:	8b 15 08 58 02 00    	mov    0x25808,%edx
    3cf0:	89 50 08             	mov    %edx,0x8(%eax)
        image_rollover->height=image_origin_mirror->height;
    3cf3:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3cf8:	8b 15 50 58 02 00    	mov    0x25850,%edx
    3cfe:	8b 52 04             	mov    0x4(%edx),%edx
    3d01:	89 50 04             	mov    %edx,0x4(%eax)
        image_rollover->width=image_origin_mirror->width;
    3d04:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3d09:	8b 15 50 58 02 00    	mov    0x25850,%edx
    3d0f:	8b 12                	mov    (%edx),%edx
    3d11:	89 10                	mov    %edx,(%eax)
        image_in_content_rolledover=(RGB*)malloc(sizeof(RGB)*image_rollover->height*image_rollover->width);
    3d13:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3d18:	8b 40 04             	mov    0x4(%eax),%eax
    3d1b:	89 c2                	mov    %eax,%edx
    3d1d:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3d22:	8b 00                	mov    (%eax),%eax
    3d24:	0f af d0             	imul   %eax,%edx
    3d27:	89 d0                	mov    %edx,%eax
    3d29:	01 c0                	add    %eax,%eax
    3d2b:	01 d0                	add    %edx,%eax
    3d2d:	83 ec 0c             	sub    $0xc,%esp
    3d30:	50                   	push   %eax
    3d31:	e8 87 33 00 00       	call   70bd <malloc>
    3d36:	83 c4 10             	add    $0x10,%esp
    3d39:	a3 e0 58 02 00       	mov    %eax,0x258e0
        image_rollover->data=image_in_content_rolledover;
    3d3e:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3d43:	8b 15 e0 58 02 00    	mov    0x258e0,%edx
    3d49:	89 50 08             	mov    %edx,0x8(%eax)
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
    3d4c:	a1 e0 52 02 00       	mov    0x252e0,%eax
    3d51:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int i = 0; i < edit_img_size.h; i++) {
    3d54:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3d5b:	eb 68                	jmp    3dc5 <isMouseInRolloverButton+0x11a>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    3d5d:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    3d63:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    3d69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3d6c:	01 c2                	add    %eax,%edx
    3d6e:	a1 b0 58 02 00       	mov    0x258b0,%eax
    3d73:	0f af c2             	imul   %edx,%eax
    3d76:	89 c2                	mov    %eax,%edx
    3d78:	a1 e4 52 02 00       	mov    0x252e4,%eax
    3d7d:	01 c2                	add    %eax,%edx
    3d7f:	89 d0                	mov    %edx,%eax
    3d81:	01 c0                	add    %eax,%eax
    3d83:	01 d0                	add    %edx,%eax
    3d85:	01 c8                	add    %ecx,%eax
    3d87:	89 45 ec             	mov    %eax,-0x14(%ebp)
            t = edit_img_origin + i * edit_img_size.w;
    3d8a:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    3d90:	a1 e0 52 02 00       	mov    0x252e0,%eax
    3d95:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    3d99:	89 c1                	mov    %eax,%ecx
    3d9b:	89 c8                	mov    %ecx,%eax
    3d9d:	01 c0                	add    %eax,%eax
    3d9f:	01 c8                	add    %ecx,%eax
    3da1:	01 d0                	add    %edx,%eax
    3da3:	89 45 e8             	mov    %eax,-0x18(%ebp)
            memmove(o, t, max_line * 3);
    3da6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3da9:	89 d0                	mov    %edx,%eax
    3dab:	01 c0                	add    %eax,%eax
    3dad:	01 d0                	add    %edx,%eax
    3daf:	83 ec 04             	sub    $0x4,%esp
    3db2:	50                   	push   %eax
    3db3:	ff 75 e8             	pushl  -0x18(%ebp)
    3db6:	ff 75 ec             	pushl  -0x14(%ebp)
    3db9:	e8 40 2e 00 00       	call   6bfe <memmove>
    3dbe:	83 c4 10             	add    $0x10,%esp
        image_in_content_rolledover=(RGB*)malloc(sizeof(RGB)*image_rollover->height*image_rollover->width);
        image_rollover->data=image_in_content_rolledover;
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
        for (int i = 0; i < edit_img_size.h; i++) {
    3dc1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3dc5:	a1 dc 52 02 00       	mov    0x252dc,%eax
    3dca:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3dcd:	7f 8e                	jg     3d5d <isMouseInRolloverButton+0xb2>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
            t = edit_img_origin + i * edit_img_size.w;
            memmove(o, t, max_line * 3);
        }
        picRollingOver(image_origin_mirror, image_rollover);
    3dcf:	8b 15 f0 58 02 00    	mov    0x258f0,%edx
    3dd5:	a1 50 58 02 00       	mov    0x25850,%eax
    3dda:	83 ec 08             	sub    $0x8,%esp
    3ddd:	52                   	push   %edx
    3dde:	50                   	push   %eax
    3ddf:	e8 4f 55 00 00       	call   9333 <picRollingOver>
    3de4:	83 c4 10             	add    $0x10,%esp
        int pos_y=235-image_rollover->height/2;
    3de7:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3dec:	8b 40 04             	mov    0x4(%eax),%eax
    3def:	89 c2                	mov    %eax,%edx
    3df1:	c1 ea 1f             	shr    $0x1f,%edx
    3df4:	01 d0                	add    %edx,%eax
    3df6:	d1 f8                	sar    %eax
    3df8:	ba eb 00 00 00       	mov    $0xeb,%edx
    3dfd:	29 c2                	sub    %eax,%edx
    3dff:	89 d0                	mov    %edx,%eax
    3e01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int pos_x=390-image_rollover->width/2;
    3e04:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3e09:	8b 00                	mov    (%eax),%eax
    3e0b:	89 c2                	mov    %eax,%edx
    3e0d:	c1 ea 1f             	shr    $0x1f,%edx
    3e10:	01 d0                	add    %edx,%eax
    3e12:	d1 f8                	sar    %eax
    3e14:	ba 86 01 00 00       	mov    $0x186,%edx
    3e19:	29 c2                	sub    %eax,%edx
    3e1b:	89 d0                	mov    %edx,%eax
    3e1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
        api_paint24BitmapToContent(&wnd, image_rollover->data, (Point){pos_x,pos_y}, (Point){0,0}, (Size){image_rollover->height,image_rollover->width},(Size){image_rollover->height,image_rollover->width});
    3e20:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3e25:	8b 40 04             	mov    0x4(%eax),%eax
    3e28:	89 45 c0             	mov    %eax,-0x40(%ebp)
    3e2b:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3e30:	8b 00                	mov    (%eax),%eax
    3e32:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    3e35:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3e3a:	8b 40 04             	mov    0x4(%eax),%eax
    3e3d:	89 45 c8             	mov    %eax,-0x38(%ebp)
    3e40:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3e45:	8b 00                	mov    (%eax),%eax
    3e47:	89 45 cc             	mov    %eax,-0x34(%ebp)
    3e4a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    3e51:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    3e58:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3e5b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    3e5e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3e61:	89 45 dc             	mov    %eax,-0x24(%ebp)
    3e64:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3e69:	8b 40 08             	mov    0x8(%eax),%eax
    3e6c:	83 ec 08             	sub    $0x8,%esp
    3e6f:	ff 75 c4             	pushl  -0x3c(%ebp)
    3e72:	ff 75 c0             	pushl  -0x40(%ebp)
    3e75:	ff 75 cc             	pushl  -0x34(%ebp)
    3e78:	ff 75 c8             	pushl  -0x38(%ebp)
    3e7b:	ff 75 d4             	pushl  -0x2c(%ebp)
    3e7e:	ff 75 d0             	pushl  -0x30(%ebp)
    3e81:	ff 75 dc             	pushl  -0x24(%ebp)
    3e84:	ff 75 d8             	pushl  -0x28(%ebp)
    3e87:	50                   	push   %eax
    3e88:	68 a0 58 02 00       	push   $0x258a0
    3e8d:	e8 77 3d 00 00       	call   7c09 <api_paint24BitmapToContent>
    3e92:	83 c4 30             	add    $0x30,%esp
        content_size=(Size){image_rollover->height,image_rollover->width};
    3e95:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3e9a:	8b 50 04             	mov    0x4(%eax),%edx
    3e9d:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3ea2:	8b 00                	mov    (%eax),%eax
    3ea4:	89 15 0c 53 02 00    	mov    %edx,0x2530c
    3eaa:	a3 10 53 02 00       	mov    %eax,0x25310
        content_pos=(Point){140 + (500-content_size.w)/2,30 + (410-content_size.h)/2};
    3eaf:	a1 10 53 02 00       	mov    0x25310,%eax
    3eb4:	ba f4 01 00 00       	mov    $0x1f4,%edx
    3eb9:	29 c2                	sub    %eax,%edx
    3ebb:	89 d0                	mov    %edx,%eax
    3ebd:	89 c2                	mov    %eax,%edx
    3ebf:	c1 ea 1f             	shr    $0x1f,%edx
    3ec2:	01 d0                	add    %edx,%eax
    3ec4:	d1 f8                	sar    %eax
    3ec6:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
    3ecc:	a1 0c 53 02 00       	mov    0x2530c,%eax
    3ed1:	b9 9a 01 00 00       	mov    $0x19a,%ecx
    3ed6:	29 c1                	sub    %eax,%ecx
    3ed8:	89 c8                	mov    %ecx,%eax
    3eda:	89 c1                	mov    %eax,%ecx
    3edc:	c1 e9 1f             	shr    $0x1f,%ecx
    3edf:	01 c8                	add    %ecx,%eax
    3ee1:	d1 f8                	sar    %eax
    3ee3:	83 c0 1e             	add    $0x1e,%eax
    3ee6:	89 15 1c 53 02 00    	mov    %edx,0x2531c
    3eec:	a3 20 53 02 00       	mov    %eax,0x25320
        free(image_in_content_torollover);
    3ef1:	a1 08 58 02 00       	mov    0x25808,%eax
    3ef6:	83 ec 0c             	sub    $0xc,%esp
    3ef9:	50                   	push   %eax
    3efa:	e8 7c 30 00 00       	call   6f7b <free>
    3eff:	83 c4 10             	add    $0x10,%esp
        image_in_content_torollover=(RGB*)malloc(sizeof(RGB)*image_rollover->height*image_rollover->width);
    3f02:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3f07:	8b 40 04             	mov    0x4(%eax),%eax
    3f0a:	89 c2                	mov    %eax,%edx
    3f0c:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3f11:	8b 00                	mov    (%eax),%eax
    3f13:	0f af d0             	imul   %eax,%edx
    3f16:	89 d0                	mov    %edx,%eax
    3f18:	01 c0                	add    %eax,%eax
    3f1a:	01 d0                	add    %edx,%eax
    3f1c:	83 ec 0c             	sub    $0xc,%esp
    3f1f:	50                   	push   %eax
    3f20:	e8 98 31 00 00       	call   70bd <malloc>
    3f25:	83 c4 10             	add    $0x10,%esp
    3f28:	a3 08 58 02 00       	mov    %eax,0x25808
        memmove(image_in_content_torollover, image_in_content_rolledover, image_rollover->height*image_rollover->width*3);
    3f2d:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3f32:	8b 50 04             	mov    0x4(%eax),%edx
    3f35:	a1 f0 58 02 00       	mov    0x258f0,%eax
    3f3a:	8b 00                	mov    (%eax),%eax
    3f3c:	0f af d0             	imul   %eax,%edx
    3f3f:	89 d0                	mov    %edx,%eax
    3f41:	01 c0                	add    %eax,%eax
    3f43:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    3f46:	8b 15 e0 58 02 00    	mov    0x258e0,%edx
    3f4c:	a1 08 58 02 00       	mov    0x25808,%eax
    3f51:	83 ec 04             	sub    $0x4,%esp
    3f54:	51                   	push   %ecx
    3f55:	52                   	push   %edx
    3f56:	50                   	push   %eax
    3f57:	e8 a2 2c 00 00       	call   6bfe <memmove>
    3f5c:	83 c4 10             	add    $0x10,%esp
        free(image_in_content_rolledover);
    3f5f:	a1 e0 58 02 00       	mov    0x258e0,%eax
    3f64:	83 ec 0c             	sub    $0xc,%esp
    3f67:	50                   	push   %eax
    3f68:	e8 0e 30 00 00       	call   6f7b <free>
    3f6d:	83 c4 10             	add    $0x10,%esp
        api_repaint(&wnd);
    3f70:	83 ec 0c             	sub    $0xc,%esp
    3f73:	68 a0 58 02 00       	push   $0x258a0
    3f78:	e8 0c 3d 00 00       	call   7c89 <api_repaint>
    3f7d:	83 c4 10             	add    $0x10,%esp
        return 1;
    3f80:	b8 01 00 00 00       	mov    $0x1,%eax
    3f85:	eb 05                	jmp    3f8c <isMouseInRolloverButton+0x2e1>
   }
   else {
        return 0;
    3f87:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    3f8c:	c9                   	leave  
    3f8d:	c3                   	ret    

00003f8e <isMouseInTurnaroundButton>:

int isMouseInTurnaroundButton(int x, int y) {
    3f8e:	55                   	push   %ebp
    3f8f:	89 e5                	mov    %esp,%ebp
    3f91:	83 ec 48             	sub    $0x48,%esp
   if (580 < x && x <= 640 && 440 <= y && y <= 500){
    3f94:	81 7d 08 44 02 00 00 	cmpl   $0x244,0x8(%ebp)
    3f9b:	0f 8e c9 02 00 00    	jle    426a <isMouseInTurnaroundButton+0x2dc>
    3fa1:	81 7d 08 80 02 00 00 	cmpl   $0x280,0x8(%ebp)
    3fa8:	0f 8f bc 02 00 00    	jg     426a <isMouseInTurnaroundButton+0x2dc>
    3fae:	81 7d 0c b7 01 00 00 	cmpl   $0x1b7,0xc(%ebp)
    3fb5:	0f 8e af 02 00 00    	jle    426a <isMouseInTurnaroundButton+0x2dc>
    3fbb:	81 7d 0c f4 01 00 00 	cmpl   $0x1f4,0xc(%ebp)
    3fc2:	0f 8f a2 02 00 00    	jg     426a <isMouseInTurnaroundButton+0x2dc>
        image_origin_mirror->data=image_in_content_toturnaround;
    3fc8:	a1 50 58 02 00       	mov    0x25850,%eax
    3fcd:	8b 15 d0 58 02 00    	mov    0x258d0,%edx
    3fd3:	89 50 08             	mov    %edx,0x8(%eax)
        image_turnaround->height=image_origin_mirror->height;
    3fd6:	a1 3c 58 02 00       	mov    0x2583c,%eax
    3fdb:	8b 15 50 58 02 00    	mov    0x25850,%edx
    3fe1:	8b 52 04             	mov    0x4(%edx),%edx
    3fe4:	89 50 04             	mov    %edx,0x4(%eax)
        image_turnaround->width=image_origin_mirror->width;
    3fe7:	a1 3c 58 02 00       	mov    0x2583c,%eax
    3fec:	8b 15 50 58 02 00    	mov    0x25850,%edx
    3ff2:	8b 12                	mov    (%edx),%edx
    3ff4:	89 10                	mov    %edx,(%eax)
        image_in_content_turnedaround=(RGB*)malloc(sizeof(RGB)*image_turnaround->height*image_turnaround->width);
    3ff6:	a1 3c 58 02 00       	mov    0x2583c,%eax
    3ffb:	8b 40 04             	mov    0x4(%eax),%eax
    3ffe:	89 c2                	mov    %eax,%edx
    4000:	a1 3c 58 02 00       	mov    0x2583c,%eax
    4005:	8b 00                	mov    (%eax),%eax
    4007:	0f af d0             	imul   %eax,%edx
    400a:	89 d0                	mov    %edx,%eax
    400c:	01 c0                	add    %eax,%eax
    400e:	01 d0                	add    %edx,%eax
    4010:	83 ec 0c             	sub    $0xc,%esp
    4013:	50                   	push   %eax
    4014:	e8 a4 30 00 00       	call   70bd <malloc>
    4019:	83 c4 10             	add    $0x10,%esp
    401c:	a3 20 58 02 00       	mov    %eax,0x25820
        image_turnaround->data=image_in_content_turnedaround;
    4021:	a1 3c 58 02 00       	mov    0x2583c,%eax
    4026:	8b 15 20 58 02 00    	mov    0x25820,%edx
    402c:	89 50 08             	mov    %edx,0x8(%eax)
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
    402f:	a1 e0 52 02 00       	mov    0x252e0,%eax
    4034:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int i = 0; i < edit_img_size.h; i++) {
    4037:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    403e:	eb 68                	jmp    40a8 <isMouseInTurnaroundButton+0x11a>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    4040:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    4046:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    404c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    404f:	01 c2                	add    %eax,%edx
    4051:	a1 b0 58 02 00       	mov    0x258b0,%eax
    4056:	0f af c2             	imul   %edx,%eax
    4059:	89 c2                	mov    %eax,%edx
    405b:	a1 e4 52 02 00       	mov    0x252e4,%eax
    4060:	01 c2                	add    %eax,%edx
    4062:	89 d0                	mov    %edx,%eax
    4064:	01 c0                	add    %eax,%eax
    4066:	01 d0                	add    %edx,%eax
    4068:	01 c8                	add    %ecx,%eax
    406a:	89 45 ec             	mov    %eax,-0x14(%ebp)
            t = edit_img_origin + i * edit_img_size.w;
    406d:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    4073:	a1 e0 52 02 00       	mov    0x252e0,%eax
    4078:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    407c:	89 c1                	mov    %eax,%ecx
    407e:	89 c8                	mov    %ecx,%eax
    4080:	01 c0                	add    %eax,%eax
    4082:	01 c8                	add    %ecx,%eax
    4084:	01 d0                	add    %edx,%eax
    4086:	89 45 e8             	mov    %eax,-0x18(%ebp)
            memmove(o, t, max_line * 3);
    4089:	8b 55 f0             	mov    -0x10(%ebp),%edx
    408c:	89 d0                	mov    %edx,%eax
    408e:	01 c0                	add    %eax,%eax
    4090:	01 d0                	add    %edx,%eax
    4092:	83 ec 04             	sub    $0x4,%esp
    4095:	50                   	push   %eax
    4096:	ff 75 e8             	pushl  -0x18(%ebp)
    4099:	ff 75 ec             	pushl  -0x14(%ebp)
    409c:	e8 5d 2b 00 00       	call   6bfe <memmove>
    40a1:	83 c4 10             	add    $0x10,%esp
        image_in_content_turnedaround=(RGB*)malloc(sizeof(RGB)*image_turnaround->height*image_turnaround->width);
        image_turnaround->data=image_in_content_turnedaround;
        struct RGB *t;
        struct RGB *o;
        int max_line = edit_img_size.w;
        for (int i = 0; i < edit_img_size.h; i++) {
    40a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    40a8:	a1 dc 52 02 00       	mov    0x252dc,%eax
    40ad:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    40b0:	7f 8e                	jg     4040 <isMouseInTurnaroundButton+0xb2>
            o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
            t = edit_img_origin + i * edit_img_size.w;
            memmove(o, t, max_line * 3);
        }
        picTurnAround(image_origin_mirror, image_turnaround);
    40b2:	8b 15 3c 58 02 00    	mov    0x2583c,%edx
    40b8:	a1 50 58 02 00       	mov    0x25850,%eax
    40bd:	83 ec 08             	sub    $0x8,%esp
    40c0:	52                   	push   %edx
    40c1:	50                   	push   %eax
    40c2:	e8 28 53 00 00       	call   93ef <picTurnAround>
    40c7:	83 c4 10             	add    $0x10,%esp
        int pos_y=235-image_turnaround->height/2;
    40ca:	a1 3c 58 02 00       	mov    0x2583c,%eax
    40cf:	8b 40 04             	mov    0x4(%eax),%eax
    40d2:	89 c2                	mov    %eax,%edx
    40d4:	c1 ea 1f             	shr    $0x1f,%edx
    40d7:	01 d0                	add    %edx,%eax
    40d9:	d1 f8                	sar    %eax
    40db:	ba eb 00 00 00       	mov    $0xeb,%edx
    40e0:	29 c2                	sub    %eax,%edx
    40e2:	89 d0                	mov    %edx,%eax
    40e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int pos_x=390-image_turnaround->width/2;
    40e7:	a1 3c 58 02 00       	mov    0x2583c,%eax
    40ec:	8b 00                	mov    (%eax),%eax
    40ee:	89 c2                	mov    %eax,%edx
    40f0:	c1 ea 1f             	shr    $0x1f,%edx
    40f3:	01 d0                	add    %edx,%eax
    40f5:	d1 f8                	sar    %eax
    40f7:	ba 86 01 00 00       	mov    $0x186,%edx
    40fc:	29 c2                	sub    %eax,%edx
    40fe:	89 d0                	mov    %edx,%eax
    4100:	89 45 e0             	mov    %eax,-0x20(%ebp)
        api_paint24BitmapToContent(&wnd, image_turnaround->data, (Point){pos_x,pos_y}, (Point){0,0}, (Size){image_turnaround->height,image_turnaround->width},(Size){image_turnaround->height,image_turnaround->width});
    4103:	a1 3c 58 02 00       	mov    0x2583c,%eax
    4108:	8b 40 04             	mov    0x4(%eax),%eax
    410b:	89 45 c0             	mov    %eax,-0x40(%ebp)
    410e:	a1 3c 58 02 00       	mov    0x2583c,%eax
    4113:	8b 00                	mov    (%eax),%eax
    4115:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    4118:	a1 3c 58 02 00       	mov    0x2583c,%eax
    411d:	8b 40 04             	mov    0x4(%eax),%eax
    4120:	89 45 c8             	mov    %eax,-0x38(%ebp)
    4123:	a1 3c 58 02 00       	mov    0x2583c,%eax
    4128:	8b 00                	mov    (%eax),%eax
    412a:	89 45 cc             	mov    %eax,-0x34(%ebp)
    412d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    4134:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    413b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    413e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    4141:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4144:	89 45 dc             	mov    %eax,-0x24(%ebp)
    4147:	a1 3c 58 02 00       	mov    0x2583c,%eax
    414c:	8b 40 08             	mov    0x8(%eax),%eax
    414f:	83 ec 08             	sub    $0x8,%esp
    4152:	ff 75 c4             	pushl  -0x3c(%ebp)
    4155:	ff 75 c0             	pushl  -0x40(%ebp)
    4158:	ff 75 cc             	pushl  -0x34(%ebp)
    415b:	ff 75 c8             	pushl  -0x38(%ebp)
    415e:	ff 75 d4             	pushl  -0x2c(%ebp)
    4161:	ff 75 d0             	pushl  -0x30(%ebp)
    4164:	ff 75 dc             	pushl  -0x24(%ebp)
    4167:	ff 75 d8             	pushl  -0x28(%ebp)
    416a:	50                   	push   %eax
    416b:	68 a0 58 02 00       	push   $0x258a0
    4170:	e8 94 3a 00 00       	call   7c09 <api_paint24BitmapToContent>
    4175:	83 c4 30             	add    $0x30,%esp
        content_size=(Size){image_turnaround->height,image_turnaround->width};
    4178:	a1 3c 58 02 00       	mov    0x2583c,%eax
    417d:	8b 50 04             	mov    0x4(%eax),%edx
    4180:	a1 3c 58 02 00       	mov    0x2583c,%eax
    4185:	8b 00                	mov    (%eax),%eax
    4187:	89 15 0c 53 02 00    	mov    %edx,0x2530c
    418d:	a3 10 53 02 00       	mov    %eax,0x25310
        content_pos=(Point){140 + (500-content_size.w)/2,30 + (410-content_size.h)/2};
    4192:	a1 10 53 02 00       	mov    0x25310,%eax
    4197:	ba f4 01 00 00       	mov    $0x1f4,%edx
    419c:	29 c2                	sub    %eax,%edx
    419e:	89 d0                	mov    %edx,%eax
    41a0:	89 c2                	mov    %eax,%edx
    41a2:	c1 ea 1f             	shr    $0x1f,%edx
    41a5:	01 d0                	add    %edx,%eax
    41a7:	d1 f8                	sar    %eax
    41a9:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
    41af:	a1 0c 53 02 00       	mov    0x2530c,%eax
    41b4:	b9 9a 01 00 00       	mov    $0x19a,%ecx
    41b9:	29 c1                	sub    %eax,%ecx
    41bb:	89 c8                	mov    %ecx,%eax
    41bd:	89 c1                	mov    %eax,%ecx
    41bf:	c1 e9 1f             	shr    $0x1f,%ecx
    41c2:	01 c8                	add    %ecx,%eax
    41c4:	d1 f8                	sar    %eax
    41c6:	83 c0 1e             	add    $0x1e,%eax
    41c9:	89 15 1c 53 02 00    	mov    %edx,0x2531c
    41cf:	a3 20 53 02 00       	mov    %eax,0x25320
        free(image_in_content_toturnaround);
    41d4:	a1 d0 58 02 00       	mov    0x258d0,%eax
    41d9:	83 ec 0c             	sub    $0xc,%esp
    41dc:	50                   	push   %eax
    41dd:	e8 99 2d 00 00       	call   6f7b <free>
    41e2:	83 c4 10             	add    $0x10,%esp
        image_in_content_toturnaround=(RGB*)malloc(sizeof(RGB)*image_turnaround->height*image_turnaround->width);
    41e5:	a1 3c 58 02 00       	mov    0x2583c,%eax
    41ea:	8b 40 04             	mov    0x4(%eax),%eax
    41ed:	89 c2                	mov    %eax,%edx
    41ef:	a1 3c 58 02 00       	mov    0x2583c,%eax
    41f4:	8b 00                	mov    (%eax),%eax
    41f6:	0f af d0             	imul   %eax,%edx
    41f9:	89 d0                	mov    %edx,%eax
    41fb:	01 c0                	add    %eax,%eax
    41fd:	01 d0                	add    %edx,%eax
    41ff:	83 ec 0c             	sub    $0xc,%esp
    4202:	50                   	push   %eax
    4203:	e8 b5 2e 00 00       	call   70bd <malloc>
    4208:	83 c4 10             	add    $0x10,%esp
    420b:	a3 d0 58 02 00       	mov    %eax,0x258d0
        memmove(image_in_content_toturnaround, image_in_content_turnedaround, image_turnaround->height*image_turnaround->width*3);
    4210:	a1 3c 58 02 00       	mov    0x2583c,%eax
    4215:	8b 50 04             	mov    0x4(%eax),%edx
    4218:	a1 3c 58 02 00       	mov    0x2583c,%eax
    421d:	8b 00                	mov    (%eax),%eax
    421f:	0f af d0             	imul   %eax,%edx
    4222:	89 d0                	mov    %edx,%eax
    4224:	01 c0                	add    %eax,%eax
    4226:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    4229:	8b 15 20 58 02 00    	mov    0x25820,%edx
    422f:	a1 d0 58 02 00       	mov    0x258d0,%eax
    4234:	83 ec 04             	sub    $0x4,%esp
    4237:	51                   	push   %ecx
    4238:	52                   	push   %edx
    4239:	50                   	push   %eax
    423a:	e8 bf 29 00 00       	call   6bfe <memmove>
    423f:	83 c4 10             	add    $0x10,%esp
        free(image_in_content_turnedaround);
    4242:	a1 20 58 02 00       	mov    0x25820,%eax
    4247:	83 ec 0c             	sub    $0xc,%esp
    424a:	50                   	push   %eax
    424b:	e8 2b 2d 00 00       	call   6f7b <free>
    4250:	83 c4 10             	add    $0x10,%esp
        api_repaint(&wnd);
    4253:	83 ec 0c             	sub    $0xc,%esp
    4256:	68 a0 58 02 00       	push   $0x258a0
    425b:	e8 29 3a 00 00       	call   7c89 <api_repaint>
    4260:	83 c4 10             	add    $0x10,%esp
        return 1;
    4263:	b8 01 00 00 00       	mov    $0x1,%eax
    4268:	eb 05                	jmp    426f <isMouseInTurnaroundButton+0x2e1>
   }
   else {
        return 0;
    426a:	b8 00 00 00 00       	mov    $0x0,%eax
   }
}
    426f:	c9                   	leave  
    4270:	c3                   	ret    

00004271 <MsgProc>:

void MsgProc(struct message * msg)
{
    4271:	55                   	push   %ebp
    4272:	89 e5                	mov    %esp,%ebp
    4274:	56                   	push   %esi
    4275:	53                   	push   %ebx
    4276:	81 ec e0 00 00 00    	sub    $0xe0,%esp
    switch (msg->msg_type)
    427c:	8b 45 08             	mov    0x8(%ebp),%eax
    427f:	8b 00                	mov    (%eax),%eax
    4281:	83 e8 03             	sub    $0x3,%eax
    4284:	83 f8 07             	cmp    $0x7,%eax
    4287:	0f 87 ca 15 00 00    	ja     5857 <MsgProc+0x15e6>
    428d:	8b 04 85 94 c8 01 00 	mov    0x1c894(,%eax,4),%eax
    4294:	ff e0                	jmp    *%eax
    // api_drawImgButton(&wnd, image_list_up_icon, (Point){47,45}, (Size){20,35}, border2, borderColor, pressed_shift);
    // api_drawImgButton(&wnd, image_list_down_icon, (Point){47,465}, (Size){20,35}, border2, borderColor, pressed_shift);


    case M_MOUSE_DOWN:
        if(isMouseInPencilColorButton(msg->params[0], msg->params[1]))
    4296:	8b 45 08             	mov    0x8(%ebp),%eax
    4299:	8b 50 08             	mov    0x8(%eax),%edx
    429c:	8b 45 08             	mov    0x8(%ebp),%eax
    429f:	8b 40 04             	mov    0x4(%eax),%eax
    42a2:	52                   	push   %edx
    42a3:	50                   	push   %eax
    42a4:	e8 24 cd ff ff       	call   fcd <isMouseInPencilColorButton>
    42a9:	83 c4 08             	add    $0x8,%esp
    42ac:	85 c0                	test   %eax,%eax
    42ae:	0f 85 6f 15 00 00    	jne    5823 <MsgProc+0x15b2>
        {
            break;
        }
        if(isMouseInPencilButton(msg->params[0], msg->params[1]))
    42b4:	8b 45 08             	mov    0x8(%ebp),%eax
    42b7:	8b 50 08             	mov    0x8(%eax),%edx
    42ba:	8b 45 08             	mov    0x8(%ebp),%eax
    42bd:	8b 40 04             	mov    0x4(%eax),%eax
    42c0:	52                   	push   %edx
    42c1:	50                   	push   %eax
    42c2:	e8 68 ce ff ff       	call   112f <isMouseInPencilButton>
    42c7:	83 c4 08             	add    $0x8,%esp
    42ca:	85 c0                	test   %eax,%eax
    42cc:	0f 84 82 00 00 00    	je     4354 <MsgProc+0xe3>
        {
            api_drawImgButton(&wnd, pen_icon, (Point){579,0}, (Size){30,30}, border1, borderColor, pressed_shift);
    42d2:	a1 40 53 02 00       	mov    0x25340,%eax
    42d7:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    42dd:	c7 85 1c ff ff ff 1e 	movl   $0x1e,-0xe4(%ebp)
    42e4:	00 00 00 
    42e7:	c7 85 20 ff ff ff 1e 	movl   $0x1e,-0xe0(%ebp)
    42ee:	00 00 00 
    42f1:	c7 85 24 ff ff ff 43 	movl   $0x243,-0xdc(%ebp)
    42f8:	02 00 00 
    42fb:	c7 85 28 ff ff ff 00 	movl   $0x0,-0xd8(%ebp)
    4302:	00 00 00 
    4305:	8b 15 48 58 02 00    	mov    0x25848,%edx
    430b:	83 ec 0c             	sub    $0xc,%esp
    430e:	50                   	push   %eax
    430f:	83 ec 04             	sub    $0x4,%esp
    4312:	89 e0                	mov    %esp,%eax
    4314:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    431b:	66 89 18             	mov    %bx,(%eax)
    431e:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    4325:	88 58 02             	mov    %bl,0x2(%eax)
    4328:	51                   	push   %ecx
    4329:	ff b5 20 ff ff ff    	pushl  -0xe0(%ebp)
    432f:	ff b5 1c ff ff ff    	pushl  -0xe4(%ebp)
    4335:	ff b5 28 ff ff ff    	pushl  -0xd8(%ebp)
    433b:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
    4341:	52                   	push   %edx
    4342:	68 a0 58 02 00       	push   $0x258a0
    4347:	e8 2e 3b 00 00       	call   7e7a <api_drawImgButton>
    434c:	83 c4 30             	add    $0x30,%esp
            break;
    434f:	e9 03 15 00 00       	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInRubberButton(msg->params[0], msg->params[1]))
    4354:	8b 45 08             	mov    0x8(%ebp),%eax
    4357:	8b 50 08             	mov    0x8(%eax),%edx
    435a:	8b 45 08             	mov    0x8(%ebp),%eax
    435d:	8b 40 04             	mov    0x4(%eax),%eax
    4360:	83 ec 08             	sub    $0x8,%esp
    4363:	52                   	push   %edx
    4364:	50                   	push   %eax
    4365:	e8 58 cd ff ff       	call   10c2 <isMouseInRubberButton>
    436a:	83 c4 10             	add    $0x10,%esp
    436d:	85 c0                	test   %eax,%eax
    436f:	0f 85 b1 14 00 00    	jne    5826 <MsgProc+0x15b5>
        {
            break;
        }
        if(isMouseInSaveButton(msg->params[0], msg->params[1]))
    4375:	8b 45 08             	mov    0x8(%ebp),%eax
    4378:	8b 50 08             	mov    0x8(%eax),%edx
    437b:	8b 45 08             	mov    0x8(%ebp),%eax
    437e:	8b 40 04             	mov    0x4(%eax),%eax
    4381:	83 ec 08             	sub    $0x8,%esp
    4384:	52                   	push   %edx
    4385:	50                   	push   %eax
    4386:	e8 11 ce ff ff       	call   119c <isMouseInSaveButton>
    438b:	83 c4 10             	add    $0x10,%esp
    438e:	85 c0                	test   %eax,%eax
    4390:	0f 85 93 14 00 00    	jne    5829 <MsgProc+0x15b8>
        {
            break;
        }
        if(isMouseInDeleteButton(msg->params[0], msg->params[1]))
    4396:	8b 45 08             	mov    0x8(%ebp),%eax
    4399:	8b 50 08             	mov    0x8(%eax),%edx
    439c:	8b 45 08             	mov    0x8(%ebp),%eax
    439f:	8b 40 04             	mov    0x4(%eax),%eax
    43a2:	83 ec 08             	sub    $0x8,%esp
    43a5:	52                   	push   %edx
    43a6:	50                   	push   %eax
    43a7:	e8 c2 ec ff ff       	call   306e <isMouseInDeleteButton>
    43ac:	83 c4 10             	add    $0x10,%esp
    43af:	85 c0                	test   %eax,%eax
    43b1:	0f 85 75 14 00 00    	jne    582c <MsgProc+0x15bb>
        {
            break;
        }
        if(isMouseInListUpButton(msg->params[0], msg->params[1]))
    43b7:	8b 45 08             	mov    0x8(%ebp),%eax
    43ba:	8b 50 08             	mov    0x8(%eax),%edx
    43bd:	8b 45 08             	mov    0x8(%ebp),%eax
    43c0:	8b 40 04             	mov    0x4(%eax),%eax
    43c3:	83 ec 08             	sub    $0x8,%esp
    43c6:	52                   	push   %edx
    43c7:	50                   	push   %eax
    43c8:	e8 e0 e1 ff ff       	call   25ad <isMouseInListUpButton>
    43cd:	83 c4 10             	add    $0x10,%esp
    43d0:	85 c0                	test   %eax,%eax
    43d2:	0f 85 57 14 00 00    	jne    582f <MsgProc+0x15be>
        {
            break;
        }
        if(isMouseInListDownButton(msg->params[0], msg->params[1]))
    43d8:	8b 45 08             	mov    0x8(%ebp),%eax
    43db:	8b 50 08             	mov    0x8(%eax),%edx
    43de:	8b 45 08             	mov    0x8(%ebp),%eax
    43e1:	8b 40 04             	mov    0x4(%eax),%eax
    43e4:	83 ec 08             	sub    $0x8,%esp
    43e7:	52                   	push   %edx
    43e8:	50                   	push   %eax
    43e9:	e8 4a e2 ff ff       	call   2638 <isMouseInListDownButton>
    43ee:	83 c4 10             	add    $0x10,%esp
    43f1:	85 c0                	test   %eax,%eax
    43f3:	0f 85 39 14 00 00    	jne    5832 <MsgProc+0x15c1>
        {
            break;
        }
        if(isMouseInListItem(msg->params[0], msg->params[1]))
    43f9:	8b 45 08             	mov    0x8(%ebp),%eax
    43fc:	8b 50 08             	mov    0x8(%eax),%edx
    43ff:	8b 45 08             	mov    0x8(%ebp),%eax
    4402:	8b 40 04             	mov    0x4(%eax),%eax
    4405:	83 ec 08             	sub    $0x8,%esp
    4408:	52                   	push   %edx
    4409:	50                   	push   %eax
    440a:	e8 98 eb ff ff       	call   2fa7 <isMouseInListItem>
    440f:	83 c4 10             	add    $0x10,%esp
    4412:	85 c0                	test   %eax,%eax
    4414:	0f 85 1b 14 00 00    	jne    5835 <MsgProc+0x15c4>
        {
            break;
        }
        if(isMouseInZoominButton(msg->params[0], msg->params[1]))
    441a:	8b 45 08             	mov    0x8(%ebp),%eax
    441d:	8b 50 08             	mov    0x8(%eax),%edx
    4420:	8b 45 08             	mov    0x8(%ebp),%eax
    4423:	8b 40 04             	mov    0x4(%eax),%eax
    4426:	83 ec 08             	sub    $0x8,%esp
    4429:	52                   	push   %edx
    442a:	50                   	push   %eax
    442b:	e8 ef f3 ff ff       	call   381f <isMouseInZoominButton>
    4430:	83 c4 10             	add    $0x10,%esp
    4433:	85 c0                	test   %eax,%eax
    4435:	0f 84 82 00 00 00    	je     44bd <MsgProc+0x24c>
        {
            api_drawImgButton(&wnd, zoomin_icon, (Point){140, 440}, (Size){60, 60}, border2, borderColor, pressed_shift);
    443b:	a1 40 53 02 00       	mov    0x25340,%eax
    4440:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    4446:	c7 85 2c ff ff ff 3c 	movl   $0x3c,-0xd4(%ebp)
    444d:	00 00 00 
    4450:	c7 85 30 ff ff ff 3c 	movl   $0x3c,-0xd0(%ebp)
    4457:	00 00 00 
    445a:	c7 85 34 ff ff ff 8c 	movl   $0x8c,-0xcc(%ebp)
    4461:	00 00 00 
    4464:	c7 85 38 ff ff ff b8 	movl   $0x1b8,-0xc8(%ebp)
    446b:	01 00 00 
    446e:	8b 15 28 58 02 00    	mov    0x25828,%edx
    4474:	83 ec 0c             	sub    $0xc,%esp
    4477:	50                   	push   %eax
    4478:	83 ec 04             	sub    $0x4,%esp
    447b:	89 e0                	mov    %esp,%eax
    447d:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    4484:	66 89 18             	mov    %bx,(%eax)
    4487:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    448e:	88 58 02             	mov    %bl,0x2(%eax)
    4491:	51                   	push   %ecx
    4492:	ff b5 30 ff ff ff    	pushl  -0xd0(%ebp)
    4498:	ff b5 2c ff ff ff    	pushl  -0xd4(%ebp)
    449e:	ff b5 38 ff ff ff    	pushl  -0xc8(%ebp)
    44a4:	ff b5 34 ff ff ff    	pushl  -0xcc(%ebp)
    44aa:	52                   	push   %edx
    44ab:	68 a0 58 02 00       	push   $0x258a0
    44b0:	e8 c5 39 00 00       	call   7e7a <api_drawImgButton>
    44b5:	83 c4 30             	add    $0x30,%esp
            break;
    44b8:	e9 9a 13 00 00       	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInZoomoutButton(msg->params[0], msg->params[1]))
    44bd:	8b 45 08             	mov    0x8(%ebp),%eax
    44c0:	8b 50 08             	mov    0x8(%eax),%edx
    44c3:	8b 45 08             	mov    0x8(%ebp),%eax
    44c6:	8b 40 04             	mov    0x4(%eax),%eax
    44c9:	83 ec 08             	sub    $0x8,%esp
    44cc:	52                   	push   %edx
    44cd:	50                   	push   %eax
    44ce:	e8 9c f3 ff ff       	call   386f <isMouseInZoomoutButton>
    44d3:	83 c4 10             	add    $0x10,%esp
    44d6:	85 c0                	test   %eax,%eax
    44d8:	0f 85 5a 13 00 00    	jne    5838 <MsgProc+0x15c7>
        {
            break;
        }
        if(isMouseInRotateLeftNinetyButton(msg->params[0], msg->params[1]))
    44de:	8b 45 08             	mov    0x8(%ebp),%eax
    44e1:	8b 50 08             	mov    0x8(%eax),%edx
    44e4:	8b 45 08             	mov    0x8(%ebp),%eax
    44e7:	8b 40 04             	mov    0x4(%eax),%eax
    44ea:	83 ec 08             	sub    $0x8,%esp
    44ed:	52                   	push   %edx
    44ee:	50                   	push   %eax
    44ef:	e8 77 f6 ff ff       	call   3b6b <isMouseInRotateLeftNinetyButton>
    44f4:	83 c4 10             	add    $0x10,%esp
    44f7:	85 c0                	test   %eax,%eax
    44f9:	0f 85 3c 13 00 00    	jne    583b <MsgProc+0x15ca>
        {
            break;
        }
        if(isMouseInRotateLeftThirtyButton(msg->params[0], msg->params[1]))
    44ff:	8b 45 08             	mov    0x8(%ebp),%eax
    4502:	8b 50 08             	mov    0x8(%eax),%edx
    4505:	8b 45 08             	mov    0x8(%ebp),%eax
    4508:	8b 40 04             	mov    0x4(%eax),%eax
    450b:	83 ec 08             	sub    $0x8,%esp
    450e:	52                   	push   %edx
    450f:	50                   	push   %eax
    4510:	e8 a6 f6 ff ff       	call   3bbb <isMouseInRotateLeftThirtyButton>
    4515:	83 c4 10             	add    $0x10,%esp
    4518:	85 c0                	test   %eax,%eax
    451a:	0f 85 1e 13 00 00    	jne    583e <MsgProc+0x15cd>
        {
            break;
        }
        if(isMouseInRotateRightNinetyButton(msg->params[0], msg->params[1]))
    4520:	8b 45 08             	mov    0x8(%ebp),%eax
    4523:	8b 50 08             	mov    0x8(%eax),%edx
    4526:	8b 45 08             	mov    0x8(%ebp),%eax
    4529:	8b 40 04             	mov    0x4(%eax),%eax
    452c:	83 ec 08             	sub    $0x8,%esp
    452f:	52                   	push   %edx
    4530:	50                   	push   %eax
    4531:	e8 25 f7 ff ff       	call   3c5b <isMouseInRotateRightNinetyButton>
    4536:	83 c4 10             	add    $0x10,%esp
    4539:	85 c0                	test   %eax,%eax
    453b:	0f 85 00 13 00 00    	jne    5841 <MsgProc+0x15d0>
        {
            break;
        }
        if(isMouseInRotateRightThirtyButton(msg->params[0], msg->params[1]))
    4541:	8b 45 08             	mov    0x8(%ebp),%eax
    4544:	8b 50 08             	mov    0x8(%eax),%edx
    4547:	8b 45 08             	mov    0x8(%ebp),%eax
    454a:	8b 40 04             	mov    0x4(%eax),%eax
    454d:	83 ec 08             	sub    $0x8,%esp
    4550:	52                   	push   %edx
    4551:	50                   	push   %eax
    4552:	e8 b4 f6 ff ff       	call   3c0b <isMouseInRotateRightThirtyButton>
    4557:	83 c4 10             	add    $0x10,%esp
    455a:	85 c0                	test   %eax,%eax
    455c:	0f 85 e2 12 00 00    	jne    5844 <MsgProc+0x15d3>
        {
            break;
        }
        if(isMouseInRolloverButton(msg->params[0], msg->params[1]))
    4562:	8b 45 08             	mov    0x8(%ebp),%eax
    4565:	8b 50 08             	mov    0x8(%eax),%edx
    4568:	8b 45 08             	mov    0x8(%ebp),%eax
    456b:	8b 40 04             	mov    0x4(%eax),%eax
    456e:	83 ec 08             	sub    $0x8,%esp
    4571:	52                   	push   %edx
    4572:	50                   	push   %eax
    4573:	e8 33 f7 ff ff       	call   3cab <isMouseInRolloverButton>
    4578:	83 c4 10             	add    $0x10,%esp
    457b:	85 c0                	test   %eax,%eax
    457d:	0f 85 c4 12 00 00    	jne    5847 <MsgProc+0x15d6>
        {
            break;
        }
        if(isMouseInTurnaroundButton(msg->params[0], msg->params[1]))
    4583:	8b 45 08             	mov    0x8(%ebp),%eax
    4586:	8b 50 08             	mov    0x8(%eax),%edx
    4589:	8b 45 08             	mov    0x8(%ebp),%eax
    458c:	8b 40 04             	mov    0x4(%eax),%eax
    458f:	83 ec 08             	sub    $0x8,%esp
    4592:	52                   	push   %edx
    4593:	50                   	push   %eax
    4594:	e8 f5 f9 ff ff       	call   3f8e <isMouseInTurnaroundButton>
    4599:	83 c4 10             	add    $0x10,%esp
    459c:	85 c0                	test   %eax,%eax
    459e:	0f 85 a6 12 00 00    	jne    584a <MsgProc+0x15d9>
        {
            break;
        }
        if(isMouseInCutButton(msg->params[0], msg->params[1]))
    45a4:	8b 45 08             	mov    0x8(%ebp),%eax
    45a7:	8b 50 08             	mov    0x8(%eax),%edx
    45aa:	8b 45 08             	mov    0x8(%ebp),%eax
    45ad:	8b 40 04             	mov    0x4(%eax),%eax
    45b0:	83 ec 08             	sub    $0x8,%esp
    45b3:	52                   	push   %edx
    45b4:	50                   	push   %eax
    45b5:	e8 f4 d9 ff ff       	call   1fae <isMouseInCutButton>
    45ba:	83 c4 10             	add    $0x10,%esp
    45bd:	85 c0                	test   %eax,%eax
    45bf:	0f 85 88 12 00 00    	jne    584d <MsgProc+0x15dc>
        {
            break;
        }
        if(mouse_down == 0 && (is_pencil==1 ||  is_rubber == 1) && isMouseInContent(msg->params[0], msg->params[1]))
    45c5:	a1 90 57 02 00       	mov    0x25790,%eax
    45ca:	85 c0                	test   %eax,%eax
    45cc:	0f 85 52 01 00 00    	jne    4724 <MsgProc+0x4b3>
    45d2:	a1 94 57 02 00       	mov    0x25794,%eax
    45d7:	83 f8 01             	cmp    $0x1,%eax
    45da:	74 0e                	je     45ea <MsgProc+0x379>
    45dc:	a1 98 57 02 00       	mov    0x25798,%eax
    45e1:	83 f8 01             	cmp    $0x1,%eax
    45e4:	0f 85 3a 01 00 00    	jne    4724 <MsgProc+0x4b3>
    45ea:	8b 45 08             	mov    0x8(%ebp),%eax
    45ed:	8b 50 08             	mov    0x8(%eax),%edx
    45f0:	8b 45 08             	mov    0x8(%ebp),%eax
    45f3:	8b 40 04             	mov    0x4(%eax),%eax
    45f6:	83 ec 08             	sub    $0x8,%esp
    45f9:	52                   	push   %edx
    45fa:	50                   	push   %eax
    45fb:	e8 32 c9 ff ff       	call   f32 <isMouseInContent>
    4600:	83 c4 10             	add    $0x10,%esp
    4603:	85 c0                	test   %eax,%eax
    4605:	0f 84 19 01 00 00    	je     4724 <MsgProc+0x4b3>
        {
            mouse_down = 1;
    460b:	c7 05 90 57 02 00 01 	movl   $0x1,0x25790
    4612:	00 00 00 
            api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, pencil_color);
    4615:	b8 05 00 00 00       	mov    $0x5,%eax
    461a:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
    4620:	b8 05 00 00 00       	mov    $0x5,%eax
    4625:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
            break;
        }
        if(mouse_down == 0 && (is_pencil==1 ||  is_rubber == 1) && isMouseInContent(msg->params[0], msg->params[1]))
        {
            mouse_down = 1;
            api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
    462b:	8b 45 08             	mov    0x8(%ebp),%eax
    462e:	8b 40 04             	mov    0x4(%eax),%eax
    4631:	ba 05 00 00 00       	mov    $0x5,%edx
    4636:	89 d1                	mov    %edx,%ecx
    4638:	c1 e9 1f             	shr    $0x1f,%ecx
    463b:	01 ca                	add    %ecx,%edx
    463d:	d1 fa                	sar    %edx
    463f:	29 d0                	sub    %edx,%eax
    4641:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
    4647:	8b 45 08             	mov    0x8(%ebp),%eax
    464a:	8b 40 08             	mov    0x8(%eax),%eax
    464d:	ba 05 00 00 00       	mov    $0x5,%edx
    4652:	89 d1                	mov    %edx,%ecx
    4654:	c1 e9 1f             	shr    $0x1f,%ecx
    4657:	01 ca                	add    %ecx,%edx
    4659:	d1 fa                	sar    %edx
    465b:	29 d0                	sub    %edx,%eax
    465d:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
    4663:	83 ec 08             	sub    $0x8,%esp
    4666:	83 ec 04             	sub    $0x4,%esp
    4669:	89 e0                	mov    %esp,%eax
    466b:	0f b7 15 d5 52 02 00 	movzwl 0x252d5,%edx
    4672:	66 89 10             	mov    %dx,(%eax)
    4675:	0f b6 15 d7 52 02 00 	movzbl 0x252d7,%edx
    467c:	88 50 02             	mov    %dl,0x2(%eax)
    467f:	ff b5 40 ff ff ff    	pushl  -0xc0(%ebp)
    4685:	ff b5 3c ff ff ff    	pushl  -0xc4(%ebp)
    468b:	ff b5 48 ff ff ff    	pushl  -0xb8(%ebp)
    4691:	ff b5 44 ff ff ff    	pushl  -0xbc(%ebp)
    4697:	68 a0 58 02 00       	push   $0x258a0
    469c:	e8 95 36 00 00       	call   7d36 <api_drawRect>
    46a1:	83 c4 20             	add    $0x20,%esp
                                 (Size) {pointSize, pointSize}, pencil_color);
            api_update(&wnd, (Rect){msg->params[0] - pointSize / 2, msg->params[1] - pointSize /2, pointSize, pointSize});
    46a4:	8b 45 08             	mov    0x8(%ebp),%eax
    46a7:	8b 40 04             	mov    0x4(%eax),%eax
    46aa:	ba 05 00 00 00       	mov    $0x5,%edx
    46af:	89 d1                	mov    %edx,%ecx
    46b1:	c1 e9 1f             	shr    $0x1f,%ecx
    46b4:	01 ca                	add    %ecx,%edx
    46b6:	d1 fa                	sar    %edx
    46b8:	29 d0                	sub    %edx,%eax
    46ba:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
    46c0:	8b 45 08             	mov    0x8(%ebp),%eax
    46c3:	8b 40 08             	mov    0x8(%eax),%eax
    46c6:	ba 05 00 00 00       	mov    $0x5,%edx
    46cb:	89 d1                	mov    %edx,%ecx
    46cd:	c1 e9 1f             	shr    $0x1f,%ecx
    46d0:	01 ca                	add    %ecx,%edx
    46d2:	d1 fa                	sar    %edx
    46d4:	29 d0                	sub    %edx,%eax
    46d6:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
    46dc:	b8 05 00 00 00       	mov    $0x5,%eax
    46e1:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
    46e7:	b8 05 00 00 00       	mov    $0x5,%eax
    46ec:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
    46f2:	83 ec 0c             	sub    $0xc,%esp
    46f5:	ff b5 58 ff ff ff    	pushl  -0xa8(%ebp)
    46fb:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
    4701:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
    4707:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
    470d:	68 a0 58 02 00       	push   $0x258a0
    4712:	e8 90 35 00 00       	call   7ca7 <api_update>
    4717:	83 c4 20             	add    $0x20,%esp
            is_pencil=1;
    471a:	c7 05 94 57 02 00 01 	movl   $0x1,0x25794
    4721:	00 00 00 
        }
        if(mouse_down == 0 && is_cut==1 && (isMouseInCutBoxLeft(msg->params[0], msg->params[1]) || isMouseInCutBoxRight(msg->params[0], msg->params[1])))
    4724:	a1 90 57 02 00       	mov    0x25790,%eax
    4729:	85 c0                	test   %eax,%eax
    472b:	75 64                	jne    4791 <MsgProc+0x520>
    472d:	a1 9c 57 02 00       	mov    0x2579c,%eax
    4732:	83 f8 01             	cmp    $0x1,%eax
    4735:	75 5a                	jne    4791 <MsgProc+0x520>
    4737:	8b 45 08             	mov    0x8(%ebp),%eax
    473a:	8b 50 08             	mov    0x8(%eax),%edx
    473d:	8b 45 08             	mov    0x8(%ebp),%eax
    4740:	8b 40 04             	mov    0x4(%eax),%eax
    4743:	83 ec 08             	sub    $0x8,%esp
    4746:	52                   	push   %edx
    4747:	50                   	push   %eax
    4748:	e8 e5 c2 ff ff       	call   a32 <isMouseInCutBoxLeft>
    474d:	83 c4 10             	add    $0x10,%esp
    4750:	85 c0                	test   %eax,%eax
    4752:	75 1d                	jne    4771 <MsgProc+0x500>
    4754:	8b 45 08             	mov    0x8(%ebp),%eax
    4757:	8b 50 08             	mov    0x8(%eax),%edx
    475a:	8b 45 08             	mov    0x8(%ebp),%eax
    475d:	8b 40 04             	mov    0x4(%eax),%eax
    4760:	83 ec 08             	sub    $0x8,%esp
    4763:	52                   	push   %edx
    4764:	50                   	push   %eax
    4765:	e8 54 c4 ff ff       	call   bbe <isMouseInCutBoxRight>
    476a:	83 c4 10             	add    $0x10,%esp
    476d:	85 c0                	test   %eax,%eax
    476f:	74 20                	je     4791 <MsgProc+0x520>
        {
            mouse_down = 1;
    4771:	c7 05 90 57 02 00 01 	movl   $0x1,0x25790
    4778:	00 00 00 
            mousePos.x = msg->params[0];
    477b:	8b 45 08             	mov    0x8(%ebp),%eax
    477e:	8b 40 04             	mov    0x4(%eax),%eax
    4781:	a3 88 57 02 00       	mov    %eax,0x25788
            mousePos.y = msg->params[1];
    4786:	8b 45 08             	mov    0x8(%ebp),%eax
    4789:	8b 40 08             	mov    0x8(%eax),%eax
    478c:	a3 8c 57 02 00       	mov    %eax,0x2578c
        }
        if(isMouseInCutBoxConfirmButton(msg->params[0], msg->params[1]))
    4791:	8b 45 08             	mov    0x8(%ebp),%eax
    4794:	8b 50 08             	mov    0x8(%eax),%edx
    4797:	8b 45 08             	mov    0x8(%ebp),%eax
    479a:	8b 40 04             	mov    0x4(%eax),%eax
    479d:	83 ec 08             	sub    $0x8,%esp
    47a0:	52                   	push   %edx
    47a1:	50                   	push   %eax
    47a2:	e8 af c6 ff ff       	call   e56 <isMouseInCutBoxConfirmButton>
    47a7:	83 c4 10             	add    $0x10,%esp
    47aa:	85 c0                	test   %eax,%eax
    47ac:	0f 84 9e 10 00 00    	je     5850 <MsgProc+0x15df>
        {
            struct RGB *t;
            struct RGB *o;
            cut_img_result = malloc(cutbox_size.w*cutbox_size.h*3);
    47b2:	8b 15 18 53 02 00    	mov    0x25318,%edx
    47b8:	a1 14 53 02 00       	mov    0x25314,%eax
    47bd:	0f af d0             	imul   %eax,%edx
    47c0:	89 d0                	mov    %edx,%eax
    47c2:	01 c0                	add    %eax,%eax
    47c4:	01 d0                	add    %edx,%eax
    47c6:	83 ec 0c             	sub    $0xc,%esp
    47c9:	50                   	push   %eax
    47ca:	e8 ee 28 00 00       	call   70bd <malloc>
    47cf:	83 c4 10             	add    $0x10,%esp
    47d2:	a3 1c 58 02 00       	mov    %eax,0x2581c
            int max_line = cutbox_size.w;
    47d7:	a1 18 53 02 00       	mov    0x25318,%eax
    47dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
            for (int i = 0; i < cutbox_size.h; i++) {
    47df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    47e6:	eb 68                	jmp    4850 <MsgProc+0x5df>
                o = wnd.content + (cutbox_pos.y + i) * wnd.size.w + cutbox_pos.x;
    47e8:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    47ee:	8b 15 28 53 02 00    	mov    0x25328,%edx
    47f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47f7:	01 c2                	add    %eax,%edx
    47f9:	a1 b0 58 02 00       	mov    0x258b0,%eax
    47fe:	0f af c2             	imul   %edx,%eax
    4801:	89 c2                	mov    %eax,%edx
    4803:	a1 24 53 02 00       	mov    0x25324,%eax
    4808:	01 c2                	add    %eax,%edx
    480a:	89 d0                	mov    %edx,%eax
    480c:	01 c0                	add    %eax,%eax
    480e:	01 d0                	add    %edx,%eax
    4810:	01 c8                	add    %ecx,%eax
    4812:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                t = cut_img_result + i * cutbox_size.w;
    4815:	8b 15 1c 58 02 00    	mov    0x2581c,%edx
    481b:	a1 18 53 02 00       	mov    0x25318,%eax
    4820:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    4824:	89 c1                	mov    %eax,%ecx
    4826:	89 c8                	mov    %ecx,%eax
    4828:	01 c0                	add    %eax,%eax
    482a:	01 c8                	add    %ecx,%eax
    482c:	01 d0                	add    %edx,%eax
    482e:	89 45 e0             	mov    %eax,-0x20(%ebp)
                memmove(t, o, max_line * 3);
    4831:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4834:	89 d0                	mov    %edx,%eax
    4836:	01 c0                	add    %eax,%eax
    4838:	01 d0                	add    %edx,%eax
    483a:	83 ec 04             	sub    $0x4,%esp
    483d:	50                   	push   %eax
    483e:	ff 75 e4             	pushl  -0x1c(%ebp)
    4841:	ff 75 e0             	pushl  -0x20(%ebp)
    4844:	e8 b5 23 00 00       	call   6bfe <memmove>
    4849:	83 c4 10             	add    $0x10,%esp
        {
            struct RGB *t;
            struct RGB *o;
            cut_img_result = malloc(cutbox_size.w*cutbox_size.h*3);
            int max_line = cutbox_size.w;
            for (int i = 0; i < cutbox_size.h; i++) {
    484c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4850:	a1 14 53 02 00       	mov    0x25314,%eax
    4855:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    4858:	7f 8e                	jg     47e8 <MsgProc+0x577>
                o = wnd.content + (cutbox_pos.y + i) * wnd.size.w + cutbox_pos.x;
                t = cut_img_result + i * cutbox_size.w;
                memmove(t, o, max_line * 3);
            }
            max_line = edit_img_size.w;
    485a:	a1 e0 52 02 00       	mov    0x252e0,%eax
    485f:	89 45 e8             	mov    %eax,-0x18(%ebp)
            for (int i = 0; i < edit_img_size.h; i++) {
    4862:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4869:	eb 68                	jmp    48d3 <MsgProc+0x662>
                o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    486b:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    4871:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    4877:	8b 45 f0             	mov    -0x10(%ebp),%eax
    487a:	01 c2                	add    %eax,%edx
    487c:	a1 b0 58 02 00       	mov    0x258b0,%eax
    4881:	0f af c2             	imul   %edx,%eax
    4884:	89 c2                	mov    %eax,%edx
    4886:	a1 e4 52 02 00       	mov    0x252e4,%eax
    488b:	01 c2                	add    %eax,%edx
    488d:	89 d0                	mov    %edx,%eax
    488f:	01 c0                	add    %eax,%eax
    4891:	01 d0                	add    %edx,%eax
    4893:	01 c8                	add    %ecx,%eax
    4895:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                t = edit_img_origin + i * edit_img_size.w;
    4898:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    489e:	a1 e0 52 02 00       	mov    0x252e0,%eax
    48a3:	0f af 45 f0          	imul   -0x10(%ebp),%eax
    48a7:	89 c1                	mov    %eax,%ecx
    48a9:	89 c8                	mov    %ecx,%eax
    48ab:	01 c0                	add    %eax,%eax
    48ad:	01 c8                	add    %ecx,%eax
    48af:	01 d0                	add    %edx,%eax
    48b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
                memmove(o, t, max_line * 3);
    48b4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    48b7:	89 d0                	mov    %edx,%eax
    48b9:	01 c0                	add    %eax,%eax
    48bb:	01 d0                	add    %edx,%eax
    48bd:	83 ec 04             	sub    $0x4,%esp
    48c0:	50                   	push   %eax
    48c1:	ff 75 e0             	pushl  -0x20(%ebp)
    48c4:	ff 75 e4             	pushl  -0x1c(%ebp)
    48c7:	e8 32 23 00 00       	call   6bfe <memmove>
    48cc:	83 c4 10             	add    $0x10,%esp
                o = wnd.content + (cutbox_pos.y + i) * wnd.size.w + cutbox_pos.x;
                t = cut_img_result + i * cutbox_size.w;
                memmove(t, o, max_line * 3);
            }
            max_line = edit_img_size.w;
            for (int i = 0; i < edit_img_size.h; i++) {
    48cf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    48d3:	a1 dc 52 02 00       	mov    0x252dc,%eax
    48d8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    48db:	7f 8e                	jg     486b <MsgProc+0x5fa>
                o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
                t = edit_img_origin + i * edit_img_size.w;
                memmove(o, t, max_line * 3);
            }
            content_size=(Size){cutbox_size.h,cutbox_size.w};
    48dd:	8b 15 14 53 02 00    	mov    0x25314,%edx
    48e3:	a1 18 53 02 00       	mov    0x25318,%eax
    48e8:	89 15 0c 53 02 00    	mov    %edx,0x2530c
    48ee:	a3 10 53 02 00       	mov    %eax,0x25310
            content_pos=(Point){140 + (500-content_size.w)/2,30 + (410-content_size.h)/2};
    48f3:	a1 10 53 02 00       	mov    0x25310,%eax
    48f8:	ba f4 01 00 00       	mov    $0x1f4,%edx
    48fd:	29 c2                	sub    %eax,%edx
    48ff:	89 d0                	mov    %edx,%eax
    4901:	89 c2                	mov    %eax,%edx
    4903:	c1 ea 1f             	shr    $0x1f,%edx
    4906:	01 d0                	add    %edx,%eax
    4908:	d1 f8                	sar    %eax
    490a:	8d 90 8c 00 00 00    	lea    0x8c(%eax),%edx
    4910:	a1 0c 53 02 00       	mov    0x2530c,%eax
    4915:	b9 9a 01 00 00       	mov    $0x19a,%ecx
    491a:	29 c1                	sub    %eax,%ecx
    491c:	89 c8                	mov    %ecx,%eax
    491e:	89 c1                	mov    %eax,%ecx
    4920:	c1 e9 1f             	shr    $0x1f,%ecx
    4923:	01 c8                	add    %ecx,%eax
    4925:	d1 f8                	sar    %eax
    4927:	83 c0 1e             	add    $0x1e,%eax
    492a:	89 15 1c 53 02 00    	mov    %edx,0x2531c
    4930:	a3 20 53 02 00       	mov    %eax,0x25320
            int pos_y=235-content_size.h/2;
    4935:	a1 0c 53 02 00       	mov    0x2530c,%eax
    493a:	89 c2                	mov    %eax,%edx
    493c:	c1 ea 1f             	shr    $0x1f,%edx
    493f:	01 d0                	add    %edx,%eax
    4941:	d1 f8                	sar    %eax
    4943:	ba eb 00 00 00       	mov    $0xeb,%edx
    4948:	29 c2                	sub    %eax,%edx
    494a:	89 d0                	mov    %edx,%eax
    494c:	89 45 dc             	mov    %eax,-0x24(%ebp)
            int pos_x=390-content_size.w/2;
    494f:	a1 10 53 02 00       	mov    0x25310,%eax
    4954:	89 c2                	mov    %eax,%edx
    4956:	c1 ea 1f             	shr    $0x1f,%edx
    4959:	01 d0                	add    %edx,%eax
    495b:	d1 f8                	sar    %eax
    495d:	ba 86 01 00 00       	mov    $0x186,%edx
    4962:	29 c2                	sub    %eax,%edx
    4964:	89 d0                	mov    %edx,%eax
    4966:	89 45 d8             	mov    %eax,-0x28(%ebp)
            api_paint24BitmapToContent(&wnd, cut_img_result, (Point){pos_x,pos_y}, (Point){0,0}, (Size){content_size.h,content_size.w},(Size){content_size.h,content_size.w});
    4969:	a1 0c 53 02 00       	mov    0x2530c,%eax
    496e:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
    4974:	a1 10 53 02 00       	mov    0x25310,%eax
    4979:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
    497f:	a1 0c 53 02 00       	mov    0x2530c,%eax
    4984:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
    498a:	a1 10 53 02 00       	mov    0x25310,%eax
    498f:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
    4995:	c7 85 6c ff ff ff 00 	movl   $0x0,-0x94(%ebp)
    499c:	00 00 00 
    499f:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%ebp)
    49a6:	00 00 00 
    49a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    49ac:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
    49b2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    49b5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
    49bb:	a1 1c 58 02 00       	mov    0x2581c,%eax
    49c0:	83 ec 08             	sub    $0x8,%esp
    49c3:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
    49c9:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
    49cf:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    49d5:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
    49db:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
    49e1:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
    49e7:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
    49ed:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
    49f3:	50                   	push   %eax
    49f4:	68 a0 58 02 00       	push   $0x258a0
    49f9:	e8 0b 32 00 00       	call   7c09 <api_paint24BitmapToContent>
    49fe:	83 c4 30             	add    $0x30,%esp
            api_repaint(&wnd);
    4a01:	83 ec 0c             	sub    $0xc,%esp
    4a04:	68 a0 58 02 00       	push   $0x258a0
    4a09:	e8 7b 32 00 00       	call   7c89 <api_repaint>
    4a0e:	83 c4 10             	add    $0x10,%esp
        }
        break;
    4a11:	e9 3a 0e 00 00       	jmp    5850 <MsgProc+0x15df>
    case M_MOUSE_MOVE:
        if(mouse_down == 1 && is_cut==1 && isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h)) {
    4a16:	a1 90 57 02 00       	mov    0x25790,%eax
    4a1b:	83 f8 01             	cmp    $0x1,%eax
    4a1e:	0f 85 3d 09 00 00    	jne    5361 <MsgProc+0x10f0>
    4a24:	a1 9c 57 02 00       	mov    0x2579c,%eax
    4a29:	83 f8 01             	cmp    $0x1,%eax
    4a2c:	0f 85 2f 09 00 00    	jne    5361 <MsgProc+0x10f0>
    4a32:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    4a38:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    4a3e:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4a44:	a1 24 53 02 00       	mov    0x25324,%eax
    4a49:	53                   	push   %ebx
    4a4a:	51                   	push   %ecx
    4a4b:	52                   	push   %edx
    4a4c:	50                   	push   %eax
    4a4d:	e8 87 c4 ff ff       	call   ed9 <isCutBoxInContent>
    4a52:	83 c4 10             	add    $0x10,%esp
    4a55:	85 c0                	test   %eax,%eax
    4a57:	0f 84 04 09 00 00    	je     5361 <MsgProc+0x10f0>
            lastMousePos.x = mousePos.x;
    4a5d:	a1 88 57 02 00       	mov    0x25788,%eax
    4a62:	a3 80 57 02 00       	mov    %eax,0x25780
            lastMousePos.y = mousePos.y;
    4a67:	a1 8c 57 02 00       	mov    0x2578c,%eax
    4a6c:	a3 84 57 02 00       	mov    %eax,0x25784
            mousePos.x = msg->params[0];
    4a71:	8b 45 08             	mov    0x8(%ebp),%eax
    4a74:	8b 40 04             	mov    0x4(%eax),%eax
    4a77:	a3 88 57 02 00       	mov    %eax,0x25788
            mousePos.y = msg->params[1];
    4a7c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a7f:	8b 40 08             	mov    0x8(%eax),%eax
    4a82:	a3 8c 57 02 00       	mov    %eax,0x2578c
            int dx = mousePos.x - lastMousePos.x;
    4a87:	8b 15 88 57 02 00    	mov    0x25788,%edx
    4a8d:	a1 80 57 02 00       	mov    0x25780,%eax
    4a92:	29 c2                	sub    %eax,%edx
    4a94:	89 d0                	mov    %edx,%eax
    4a96:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            int dy = mousePos.y - lastMousePos.y;
    4a99:	8b 15 8c 57 02 00    	mov    0x2578c,%edx
    4a9f:	a1 84 57 02 00       	mov    0x25784,%eax
    4aa4:	29 c2                	sub    %eax,%edx
    4aa6:	89 d0                	mov    %edx,%eax
    4aa8:	89 45 d0             	mov    %eax,-0x30(%ebp)
            printf(1, "mousePos, %d, %d\n", mousePos.x, mousePos.y);
    4aab:	8b 15 8c 57 02 00    	mov    0x2578c,%edx
    4ab1:	a1 88 57 02 00       	mov    0x25788,%eax
    4ab6:	52                   	push   %edx
    4ab7:	50                   	push   %eax
    4ab8:	68 3e c8 01 00       	push   $0x1c83e
    4abd:	6a 01                	push   $0x1
    4abf:	e8 26 23 00 00       	call   6dea <printf>
    4ac4:	83 c4 10             	add    $0x10,%esp
            if(dx < 5 && dx > -5 && dy < 5 && dy > -5)
    4ac7:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    4acb:	0f 8f 90 08 00 00    	jg     5361 <MsgProc+0x10f0>
    4ad1:	83 7d d4 fc          	cmpl   $0xfffffffc,-0x2c(%ebp)
    4ad5:	0f 8c 86 08 00 00    	jl     5361 <MsgProc+0x10f0>
    4adb:	83 7d d0 04          	cmpl   $0x4,-0x30(%ebp)
    4adf:	0f 8f 7c 08 00 00    	jg     5361 <MsgProc+0x10f0>
    4ae5:	83 7d d0 fc          	cmpl   $0xfffffffc,-0x30(%ebp)
    4ae9:	0f 8c 72 08 00 00    	jl     5361 <MsgProc+0x10f0>
            {
                if(isMouseInCutBoxLeft(lastMousePos.x, lastMousePos.y))
    4aef:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4af5:	a1 80 57 02 00       	mov    0x25780,%eax
    4afa:	83 ec 08             	sub    $0x8,%esp
    4afd:	52                   	push   %edx
    4afe:	50                   	push   %eax
    4aff:	e8 2e bf ff ff       	call   a32 <isMouseInCutBoxLeft>
    4b04:	83 c4 10             	add    $0x10,%esp
    4b07:	85 c0                	test   %eax,%eax
    4b09:	0f 84 e8 00 00 00    	je     4bf7 <MsgProc+0x986>
                {
                    if(isCutBoxInContent(cutbox_pos.x + dx, cutbox_pos.y, cutbox_size.w - dx, cutbox_size.h))
    4b0f:	8b 0d 14 53 02 00    	mov    0x25314,%ecx
    4b15:	a1 18 53 02 00       	mov    0x25318,%eax
    4b1a:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    4b1d:	89 c2                	mov    %eax,%edx
    4b1f:	a1 28 53 02 00       	mov    0x25328,%eax
    4b24:	8b 35 24 53 02 00    	mov    0x25324,%esi
    4b2a:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
    4b2d:	01 f3                	add    %esi,%ebx
    4b2f:	51                   	push   %ecx
    4b30:	52                   	push   %edx
    4b31:	50                   	push   %eax
    4b32:	53                   	push   %ebx
    4b33:	e8 a1 c3 ff ff       	call   ed9 <isCutBoxInContent>
    4b38:	83 c4 10             	add    $0x10,%esp
    4b3b:	85 c0                	test   %eax,%eax
    4b3d:	0f 84 1e 08 00 00    	je     5361 <MsgProc+0x10f0>
                    {
                        printf(1, "lastmousePos, %d, %d\n", lastMousePos.x, lastMousePos.y);
    4b43:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4b49:	a1 80 57 02 00       	mov    0x25780,%eax
    4b4e:	52                   	push   %edx
    4b4f:	50                   	push   %eax
    4b50:	68 50 c8 01 00       	push   $0x1c850
    4b55:	6a 01                	push   $0x1
    4b57:	e8 8e 22 00 00       	call   6dea <printf>
    4b5c:	83 c4 10             	add    $0x10,%esp
                        cutbox_pos.x = cutbox_pos.x + dx;
    4b5f:	8b 15 24 53 02 00    	mov    0x25324,%edx
    4b65:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4b68:	01 d0                	add    %edx,%eax
    4b6a:	a3 24 53 02 00       	mov    %eax,0x25324
                        cutbox_size.w = cutbox_size.w - dx;
    4b6f:	a1 18 53 02 00       	mov    0x25318,%eax
    4b74:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    4b77:	a3 18 53 02 00       	mov    %eax,0x25318
                        drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    4b7c:	8b 15 14 53 02 00    	mov    0x25314,%edx
    4b82:	a1 18 53 02 00       	mov    0x25318,%eax
    4b87:	52                   	push   %edx
    4b88:	50                   	push   %eax
    4b89:	ff 35 28 53 02 00    	pushl  0x25328
    4b8f:	ff 35 24 53 02 00    	pushl  0x25324
    4b95:	e8 ef d1 ff ff       	call   1d89 <drawCutBox>
    4b9a:	83 c4 10             	add    $0x10,%esp
                        printf(1, "40, %d, %d, %d\n", cutbox_pos.x, cutbox_pos.y, isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h));
    4b9d:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    4ba3:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    4ba9:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4baf:	a1 24 53 02 00       	mov    0x25324,%eax
    4bb4:	53                   	push   %ebx
    4bb5:	51                   	push   %ecx
    4bb6:	52                   	push   %edx
    4bb7:	50                   	push   %eax
    4bb8:	e8 1c c3 ff ff       	call   ed9 <isCutBoxInContent>
    4bbd:	83 c4 10             	add    $0x10,%esp
    4bc0:	89 c1                	mov    %eax,%ecx
    4bc2:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4bc8:	a1 24 53 02 00       	mov    0x25324,%eax
    4bcd:	83 ec 0c             	sub    $0xc,%esp
    4bd0:	51                   	push   %ecx
    4bd1:	52                   	push   %edx
    4bd2:	50                   	push   %eax
    4bd3:	68 66 c8 01 00       	push   $0x1c866
    4bd8:	6a 01                	push   $0x1
    4bda:	e8 0b 22 00 00       	call   6dea <printf>
    4bdf:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
    4be2:	83 ec 0c             	sub    $0xc,%esp
    4be5:	68 a0 58 02 00       	push   $0x258a0
    4bea:	e8 9a 30 00 00       	call   7c89 <api_repaint>
    4bef:	83 c4 10             	add    $0x10,%esp
    4bf2:	e9 6a 07 00 00       	jmp    5361 <MsgProc+0x10f0>
                    }
                }
                else if(isMouseInCutBoxRight(lastMousePos.x, lastMousePos.y))
    4bf7:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4bfd:	a1 80 57 02 00       	mov    0x25780,%eax
    4c02:	83 ec 08             	sub    $0x8,%esp
    4c05:	52                   	push   %edx
    4c06:	50                   	push   %eax
    4c07:	e8 b2 bf ff ff       	call   bbe <isMouseInCutBoxRight>
    4c0c:	83 c4 10             	add    $0x10,%esp
    4c0f:	85 c0                	test   %eax,%eax
    4c11:	0f 84 d8 00 00 00    	je     4cef <MsgProc+0xa7e>
                {
                    if(isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w + dx, cutbox_size.h))
    4c17:	8b 0d 14 53 02 00    	mov    0x25314,%ecx
    4c1d:	8b 15 18 53 02 00    	mov    0x25318,%edx
    4c23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c26:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4c29:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4c2f:	a1 24 53 02 00       	mov    0x25324,%eax
    4c34:	51                   	push   %ecx
    4c35:	53                   	push   %ebx
    4c36:	52                   	push   %edx
    4c37:	50                   	push   %eax
    4c38:	e8 9c c2 ff ff       	call   ed9 <isCutBoxInContent>
    4c3d:	83 c4 10             	add    $0x10,%esp
    4c40:	85 c0                	test   %eax,%eax
    4c42:	0f 84 19 07 00 00    	je     5361 <MsgProc+0x10f0>
                    {
                        printf(1, "lastmousePos, %d, %d\n", lastMousePos.x, lastMousePos.y);
    4c48:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4c4e:	a1 80 57 02 00       	mov    0x25780,%eax
    4c53:	52                   	push   %edx
    4c54:	50                   	push   %eax
    4c55:	68 50 c8 01 00       	push   $0x1c850
    4c5a:	6a 01                	push   $0x1
    4c5c:	e8 89 21 00 00       	call   6dea <printf>
    4c61:	83 c4 10             	add    $0x10,%esp
                        cutbox_size.w = cutbox_size.w + dx;
    4c64:	8b 15 18 53 02 00    	mov    0x25318,%edx
    4c6a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c6d:	01 d0                	add    %edx,%eax
    4c6f:	a3 18 53 02 00       	mov    %eax,0x25318
                        drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    4c74:	8b 15 14 53 02 00    	mov    0x25314,%edx
    4c7a:	a1 18 53 02 00       	mov    0x25318,%eax
    4c7f:	52                   	push   %edx
    4c80:	50                   	push   %eax
    4c81:	ff 35 28 53 02 00    	pushl  0x25328
    4c87:	ff 35 24 53 02 00    	pushl  0x25324
    4c8d:	e8 f7 d0 ff ff       	call   1d89 <drawCutBox>
    4c92:	83 c4 10             	add    $0x10,%esp
                        printf(1, "40, %d, %d, %d\n", cutbox_pos.x, cutbox_pos.y, isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h));
    4c95:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    4c9b:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    4ca1:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4ca7:	a1 24 53 02 00       	mov    0x25324,%eax
    4cac:	53                   	push   %ebx
    4cad:	51                   	push   %ecx
    4cae:	52                   	push   %edx
    4caf:	50                   	push   %eax
    4cb0:	e8 24 c2 ff ff       	call   ed9 <isCutBoxInContent>
    4cb5:	83 c4 10             	add    $0x10,%esp
    4cb8:	89 c1                	mov    %eax,%ecx
    4cba:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4cc0:	a1 24 53 02 00       	mov    0x25324,%eax
    4cc5:	83 ec 0c             	sub    $0xc,%esp
    4cc8:	51                   	push   %ecx
    4cc9:	52                   	push   %edx
    4cca:	50                   	push   %eax
    4ccb:	68 66 c8 01 00       	push   $0x1c866
    4cd0:	6a 01                	push   $0x1
    4cd2:	e8 13 21 00 00       	call   6dea <printf>
    4cd7:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
    4cda:	83 ec 0c             	sub    $0xc,%esp
    4cdd:	68 a0 58 02 00       	push   $0x258a0
    4ce2:	e8 a2 2f 00 00       	call   7c89 <api_repaint>
    4ce7:	83 c4 10             	add    $0x10,%esp
    4cea:	e9 72 06 00 00       	jmp    5361 <MsgProc+0x10f0>
                    }
                }
                else if(isMouseInCutBoxUp(lastMousePos.x, lastMousePos.y))
    4cef:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4cf5:	a1 80 57 02 00       	mov    0x25780,%eax
    4cfa:	83 ec 08             	sub    $0x8,%esp
    4cfd:	52                   	push   %edx
    4cfe:	50                   	push   %eax
    4cff:	e8 96 c0 ff ff       	call   d9a <isMouseInCutBoxUp>
    4d04:	83 c4 10             	add    $0x10,%esp
    4d07:	85 c0                	test   %eax,%eax
    4d09:	0f 84 e8 00 00 00    	je     4df7 <MsgProc+0xb86>
                {
                    if(isCutBoxInContent(cutbox_pos.x, cutbox_pos.y + dy, cutbox_size.w, cutbox_size.h - dy))
    4d0f:	a1 14 53 02 00       	mov    0x25314,%eax
    4d14:	2b 45 d0             	sub    -0x30(%ebp),%eax
    4d17:	89 c1                	mov    %eax,%ecx
    4d19:	8b 15 18 53 02 00    	mov    0x25318,%edx
    4d1f:	8b 1d 28 53 02 00    	mov    0x25328,%ebx
    4d25:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4d28:	01 c3                	add    %eax,%ebx
    4d2a:	a1 24 53 02 00       	mov    0x25324,%eax
    4d2f:	51                   	push   %ecx
    4d30:	52                   	push   %edx
    4d31:	53                   	push   %ebx
    4d32:	50                   	push   %eax
    4d33:	e8 a1 c1 ff ff       	call   ed9 <isCutBoxInContent>
    4d38:	83 c4 10             	add    $0x10,%esp
    4d3b:	85 c0                	test   %eax,%eax
    4d3d:	0f 84 1e 06 00 00    	je     5361 <MsgProc+0x10f0>
                    {
                        printf(1, "lastmousePos, %d, %d\n", lastMousePos.x, lastMousePos.y);
    4d43:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4d49:	a1 80 57 02 00       	mov    0x25780,%eax
    4d4e:	52                   	push   %edx
    4d4f:	50                   	push   %eax
    4d50:	68 50 c8 01 00       	push   $0x1c850
    4d55:	6a 01                	push   $0x1
    4d57:	e8 8e 20 00 00       	call   6dea <printf>
    4d5c:	83 c4 10             	add    $0x10,%esp
                        cutbox_pos.y = cutbox_pos.y + dy;
    4d5f:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4d65:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4d68:	01 d0                	add    %edx,%eax
    4d6a:	a3 28 53 02 00       	mov    %eax,0x25328
                        cutbox_size.h = cutbox_size.h - dy;
    4d6f:	a1 14 53 02 00       	mov    0x25314,%eax
    4d74:	2b 45 d0             	sub    -0x30(%ebp),%eax
    4d77:	a3 14 53 02 00       	mov    %eax,0x25314
                        drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    4d7c:	8b 15 14 53 02 00    	mov    0x25314,%edx
    4d82:	a1 18 53 02 00       	mov    0x25318,%eax
    4d87:	52                   	push   %edx
    4d88:	50                   	push   %eax
    4d89:	ff 35 28 53 02 00    	pushl  0x25328
    4d8f:	ff 35 24 53 02 00    	pushl  0x25324
    4d95:	e8 ef cf ff ff       	call   1d89 <drawCutBox>
    4d9a:	83 c4 10             	add    $0x10,%esp
                        printf(1, "40, %d, %d, %d\n", cutbox_pos.x, cutbox_pos.y, isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h));
    4d9d:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    4da3:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    4da9:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4daf:	a1 24 53 02 00       	mov    0x25324,%eax
    4db4:	53                   	push   %ebx
    4db5:	51                   	push   %ecx
    4db6:	52                   	push   %edx
    4db7:	50                   	push   %eax
    4db8:	e8 1c c1 ff ff       	call   ed9 <isCutBoxInContent>
    4dbd:	83 c4 10             	add    $0x10,%esp
    4dc0:	89 c1                	mov    %eax,%ecx
    4dc2:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4dc8:	a1 24 53 02 00       	mov    0x25324,%eax
    4dcd:	83 ec 0c             	sub    $0xc,%esp
    4dd0:	51                   	push   %ecx
    4dd1:	52                   	push   %edx
    4dd2:	50                   	push   %eax
    4dd3:	68 66 c8 01 00       	push   $0x1c866
    4dd8:	6a 01                	push   $0x1
    4dda:	e8 0b 20 00 00       	call   6dea <printf>
    4ddf:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
    4de2:	83 ec 0c             	sub    $0xc,%esp
    4de5:	68 a0 58 02 00       	push   $0x258a0
    4dea:	e8 9a 2e 00 00       	call   7c89 <api_repaint>
    4def:	83 c4 10             	add    $0x10,%esp
    4df2:	e9 6a 05 00 00       	jmp    5361 <MsgProc+0x10f0>
                    }
                }
                else if(isMouseInCutBoxDown(lastMousePos.x, lastMousePos.y))
    4df7:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4dfd:	a1 80 57 02 00       	mov    0x25780,%eax
    4e02:	83 ec 08             	sub    $0x8,%esp
    4e05:	52                   	push   %edx
    4e06:	50                   	push   %eax
    4e07:	e8 e4 bf ff ff       	call   df0 <isMouseInCutBoxDown>
    4e0c:	83 c4 10             	add    $0x10,%esp
    4e0f:	85 c0                	test   %eax,%eax
    4e11:	0f 84 d8 00 00 00    	je     4eef <MsgProc+0xc7e>
                {
                    if(isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h + dy))
    4e17:	8b 15 14 53 02 00    	mov    0x25314,%edx
    4e1d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4e20:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4e23:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    4e29:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4e2f:	a1 24 53 02 00       	mov    0x25324,%eax
    4e34:	53                   	push   %ebx
    4e35:	51                   	push   %ecx
    4e36:	52                   	push   %edx
    4e37:	50                   	push   %eax
    4e38:	e8 9c c0 ff ff       	call   ed9 <isCutBoxInContent>
    4e3d:	83 c4 10             	add    $0x10,%esp
    4e40:	85 c0                	test   %eax,%eax
    4e42:	0f 84 19 05 00 00    	je     5361 <MsgProc+0x10f0>
                    {
                        printf(1, "lastmousePos, %d, %d\n", lastMousePos.x, lastMousePos.y);
    4e48:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4e4e:	a1 80 57 02 00       	mov    0x25780,%eax
    4e53:	52                   	push   %edx
    4e54:	50                   	push   %eax
    4e55:	68 50 c8 01 00       	push   $0x1c850
    4e5a:	6a 01                	push   $0x1
    4e5c:	e8 89 1f 00 00       	call   6dea <printf>
    4e61:	83 c4 10             	add    $0x10,%esp
                        cutbox_size.h = cutbox_size.h + dy;
    4e64:	8b 15 14 53 02 00    	mov    0x25314,%edx
    4e6a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4e6d:	01 d0                	add    %edx,%eax
    4e6f:	a3 14 53 02 00       	mov    %eax,0x25314
                        drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    4e74:	8b 15 14 53 02 00    	mov    0x25314,%edx
    4e7a:	a1 18 53 02 00       	mov    0x25318,%eax
    4e7f:	52                   	push   %edx
    4e80:	50                   	push   %eax
    4e81:	ff 35 28 53 02 00    	pushl  0x25328
    4e87:	ff 35 24 53 02 00    	pushl  0x25324
    4e8d:	e8 f7 ce ff ff       	call   1d89 <drawCutBox>
    4e92:	83 c4 10             	add    $0x10,%esp
                        printf(1, "40, %d, %d, %d\n", cutbox_pos.x, cutbox_pos.y, isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h));
    4e95:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    4e9b:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    4ea1:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4ea7:	a1 24 53 02 00       	mov    0x25324,%eax
    4eac:	53                   	push   %ebx
    4ead:	51                   	push   %ecx
    4eae:	52                   	push   %edx
    4eaf:	50                   	push   %eax
    4eb0:	e8 24 c0 ff ff       	call   ed9 <isCutBoxInContent>
    4eb5:	83 c4 10             	add    $0x10,%esp
    4eb8:	89 c1                	mov    %eax,%ecx
    4eba:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4ec0:	a1 24 53 02 00       	mov    0x25324,%eax
    4ec5:	83 ec 0c             	sub    $0xc,%esp
    4ec8:	51                   	push   %ecx
    4ec9:	52                   	push   %edx
    4eca:	50                   	push   %eax
    4ecb:	68 66 c8 01 00       	push   $0x1c866
    4ed0:	6a 01                	push   $0x1
    4ed2:	e8 13 1f 00 00       	call   6dea <printf>
    4ed7:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
    4eda:	83 ec 0c             	sub    $0xc,%esp
    4edd:	68 a0 58 02 00       	push   $0x258a0
    4ee2:	e8 a2 2d 00 00       	call   7c89 <api_repaint>
    4ee7:	83 c4 10             	add    $0x10,%esp
    4eea:	e9 72 04 00 00       	jmp    5361 <MsgProc+0x10f0>
                    }
                }
                else if(isMouseInCutBoxUpLeft(lastMousePos.x, lastMousePos.y))
    4eef:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4ef5:	a1 80 57 02 00       	mov    0x25780,%eax
    4efa:	83 ec 08             	sub    $0x8,%esp
    4efd:	52                   	push   %edx
    4efe:	50                   	push   %eax
    4eff:	e8 84 bb ff ff       	call   a88 <isMouseInCutBoxUpLeft>
    4f04:	83 c4 10             	add    $0x10,%esp
    4f07:	85 c0                	test   %eax,%eax
    4f09:	0f 84 0d 01 00 00    	je     501c <MsgProc+0xdab>
                {
                    if(isCutBoxInContent(cutbox_pos.x + dx, cutbox_pos.y + dy, cutbox_size.w - dx, cutbox_size.h - dy))
    4f0f:	a1 14 53 02 00       	mov    0x25314,%eax
    4f14:	2b 45 d0             	sub    -0x30(%ebp),%eax
    4f17:	89 c2                	mov    %eax,%edx
    4f19:	a1 18 53 02 00       	mov    0x25318,%eax
    4f1e:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    4f21:	8b 1d 28 53 02 00    	mov    0x25328,%ebx
    4f27:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    4f2a:	01 cb                	add    %ecx,%ebx
    4f2c:	8b 35 24 53 02 00    	mov    0x25324,%esi
    4f32:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    4f35:	01 f1                	add    %esi,%ecx
    4f37:	52                   	push   %edx
    4f38:	50                   	push   %eax
    4f39:	53                   	push   %ebx
    4f3a:	51                   	push   %ecx
    4f3b:	e8 99 bf ff ff       	call   ed9 <isCutBoxInContent>
    4f40:	83 c4 10             	add    $0x10,%esp
    4f43:	85 c0                	test   %eax,%eax
    4f45:	0f 84 16 04 00 00    	je     5361 <MsgProc+0x10f0>
                    {
                        printf(1, "lastmousePos, %d, %d\n", lastMousePos.x, lastMousePos.y);
    4f4b:	8b 15 84 57 02 00    	mov    0x25784,%edx
    4f51:	a1 80 57 02 00       	mov    0x25780,%eax
    4f56:	52                   	push   %edx
    4f57:	50                   	push   %eax
    4f58:	68 50 c8 01 00       	push   $0x1c850
    4f5d:	6a 01                	push   $0x1
    4f5f:	e8 86 1e 00 00       	call   6dea <printf>
    4f64:	83 c4 10             	add    $0x10,%esp
                        cutbox_pos.x = cutbox_pos.x + dx;
    4f67:	8b 15 24 53 02 00    	mov    0x25324,%edx
    4f6d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4f70:	01 d0                	add    %edx,%eax
    4f72:	a3 24 53 02 00       	mov    %eax,0x25324
                        cutbox_pos.y = cutbox_pos.y + dy;
    4f77:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4f7d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4f80:	01 d0                	add    %edx,%eax
    4f82:	a3 28 53 02 00       	mov    %eax,0x25328
                        cutbox_size.w = cutbox_size.w - dx;
    4f87:	a1 18 53 02 00       	mov    0x25318,%eax
    4f8c:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    4f8f:	a3 18 53 02 00       	mov    %eax,0x25318
                        cutbox_size.h = cutbox_size.h - dy;
    4f94:	a1 14 53 02 00       	mov    0x25314,%eax
    4f99:	2b 45 d0             	sub    -0x30(%ebp),%eax
    4f9c:	a3 14 53 02 00       	mov    %eax,0x25314
                        drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    4fa1:	8b 15 14 53 02 00    	mov    0x25314,%edx
    4fa7:	a1 18 53 02 00       	mov    0x25318,%eax
    4fac:	52                   	push   %edx
    4fad:	50                   	push   %eax
    4fae:	ff 35 28 53 02 00    	pushl  0x25328
    4fb4:	ff 35 24 53 02 00    	pushl  0x25324
    4fba:	e8 ca cd ff ff       	call   1d89 <drawCutBox>
    4fbf:	83 c4 10             	add    $0x10,%esp
                        printf(1, "40, %d, %d, %d\n", cutbox_pos.x, cutbox_pos.y, isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h));
    4fc2:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    4fc8:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    4fce:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4fd4:	a1 24 53 02 00       	mov    0x25324,%eax
    4fd9:	53                   	push   %ebx
    4fda:	51                   	push   %ecx
    4fdb:	52                   	push   %edx
    4fdc:	50                   	push   %eax
    4fdd:	e8 f7 be ff ff       	call   ed9 <isCutBoxInContent>
    4fe2:	83 c4 10             	add    $0x10,%esp
    4fe5:	89 c1                	mov    %eax,%ecx
    4fe7:	8b 15 28 53 02 00    	mov    0x25328,%edx
    4fed:	a1 24 53 02 00       	mov    0x25324,%eax
    4ff2:	83 ec 0c             	sub    $0xc,%esp
    4ff5:	51                   	push   %ecx
    4ff6:	52                   	push   %edx
    4ff7:	50                   	push   %eax
    4ff8:	68 66 c8 01 00       	push   $0x1c866
    4ffd:	6a 01                	push   $0x1
    4fff:	e8 e6 1d 00 00       	call   6dea <printf>
    5004:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
    5007:	83 ec 0c             	sub    $0xc,%esp
    500a:	68 a0 58 02 00       	push   $0x258a0
    500f:	e8 75 2c 00 00       	call   7c89 <api_repaint>
    5014:	83 c4 10             	add    $0x10,%esp
    5017:	e9 45 03 00 00       	jmp    5361 <MsgProc+0x10f0>
                    }
                }
                else if(isMouseInCutBoxUpRight(lastMousePos.x, lastMousePos.y))
    501c:	8b 15 84 57 02 00    	mov    0x25784,%edx
    5022:	a1 80 57 02 00       	mov    0x25780,%eax
    5027:	83 ec 08             	sub    $0x8,%esp
    502a:	52                   	push   %edx
    502b:	50                   	push   %eax
    502c:	e8 f3 bb ff ff       	call   c24 <isMouseInCutBoxUpRight>
    5031:	83 c4 10             	add    $0x10,%esp
    5034:	85 c0                	test   %eax,%eax
    5036:	0f 84 fe 00 00 00    	je     513a <MsgProc+0xec9>
                {
                    if(isCutBoxInContent(cutbox_pos.x, cutbox_pos.y + dy, cutbox_size.w + dx, cutbox_size.h - dy))
    503c:	a1 14 53 02 00       	mov    0x25314,%eax
    5041:	2b 45 d0             	sub    -0x30(%ebp),%eax
    5044:	89 c2                	mov    %eax,%edx
    5046:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    504c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    504f:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
    5052:	8b 0d 28 53 02 00    	mov    0x25328,%ecx
    5058:	8b 45 d0             	mov    -0x30(%ebp),%eax
    505b:	01 c1                	add    %eax,%ecx
    505d:	a1 24 53 02 00       	mov    0x25324,%eax
    5062:	52                   	push   %edx
    5063:	53                   	push   %ebx
    5064:	51                   	push   %ecx
    5065:	50                   	push   %eax
    5066:	e8 6e be ff ff       	call   ed9 <isCutBoxInContent>
    506b:	83 c4 10             	add    $0x10,%esp
    506e:	85 c0                	test   %eax,%eax
    5070:	0f 84 eb 02 00 00    	je     5361 <MsgProc+0x10f0>
                    {
                        printf(1, "lastmousePos, %d, %d\n", lastMousePos.x, lastMousePos.y);
    5076:	8b 15 84 57 02 00    	mov    0x25784,%edx
    507c:	a1 80 57 02 00       	mov    0x25780,%eax
    5081:	52                   	push   %edx
    5082:	50                   	push   %eax
    5083:	68 50 c8 01 00       	push   $0x1c850
    5088:	6a 01                	push   $0x1
    508a:	e8 5b 1d 00 00       	call   6dea <printf>
    508f:	83 c4 10             	add    $0x10,%esp
                        cutbox_pos.y = cutbox_pos.y + dy;
    5092:	8b 15 28 53 02 00    	mov    0x25328,%edx
    5098:	8b 45 d0             	mov    -0x30(%ebp),%eax
    509b:	01 d0                	add    %edx,%eax
    509d:	a3 28 53 02 00       	mov    %eax,0x25328
                        cutbox_size.w = cutbox_size.w + dx;
    50a2:	8b 15 18 53 02 00    	mov    0x25318,%edx
    50a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50ab:	01 d0                	add    %edx,%eax
    50ad:	a3 18 53 02 00       	mov    %eax,0x25318
                        cutbox_size.h = cutbox_size.h - dy;
    50b2:	a1 14 53 02 00       	mov    0x25314,%eax
    50b7:	2b 45 d0             	sub    -0x30(%ebp),%eax
    50ba:	a3 14 53 02 00       	mov    %eax,0x25314
                        drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    50bf:	8b 15 14 53 02 00    	mov    0x25314,%edx
    50c5:	a1 18 53 02 00       	mov    0x25318,%eax
    50ca:	52                   	push   %edx
    50cb:	50                   	push   %eax
    50cc:	ff 35 28 53 02 00    	pushl  0x25328
    50d2:	ff 35 24 53 02 00    	pushl  0x25324
    50d8:	e8 ac cc ff ff       	call   1d89 <drawCutBox>
    50dd:	83 c4 10             	add    $0x10,%esp
                        printf(1, "40, %d, %d, %d\n", cutbox_pos.x, cutbox_pos.y, isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h));
    50e0:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    50e6:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    50ec:	8b 15 28 53 02 00    	mov    0x25328,%edx
    50f2:	a1 24 53 02 00       	mov    0x25324,%eax
    50f7:	53                   	push   %ebx
    50f8:	51                   	push   %ecx
    50f9:	52                   	push   %edx
    50fa:	50                   	push   %eax
    50fb:	e8 d9 bd ff ff       	call   ed9 <isCutBoxInContent>
    5100:	83 c4 10             	add    $0x10,%esp
    5103:	89 c1                	mov    %eax,%ecx
    5105:	8b 15 28 53 02 00    	mov    0x25328,%edx
    510b:	a1 24 53 02 00       	mov    0x25324,%eax
    5110:	83 ec 0c             	sub    $0xc,%esp
    5113:	51                   	push   %ecx
    5114:	52                   	push   %edx
    5115:	50                   	push   %eax
    5116:	68 66 c8 01 00       	push   $0x1c866
    511b:	6a 01                	push   $0x1
    511d:	e8 c8 1c 00 00       	call   6dea <printf>
    5122:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
    5125:	83 ec 0c             	sub    $0xc,%esp
    5128:	68 a0 58 02 00       	push   $0x258a0
    512d:	e8 57 2b 00 00       	call   7c89 <api_repaint>
    5132:	83 c4 10             	add    $0x10,%esp
    5135:	e9 27 02 00 00       	jmp    5361 <MsgProc+0x10f0>
                    }
                }
                else if(isMouseInCutBoxDownLeft(lastMousePos.x, lastMousePos.y))
    513a:	8b 15 84 57 02 00    	mov    0x25784,%edx
    5140:	a1 80 57 02 00       	mov    0x25780,%eax
    5145:	83 ec 08             	sub    $0x8,%esp
    5148:	52                   	push   %edx
    5149:	50                   	push   %eax
    514a:	e8 c4 b9 ff ff       	call   b13 <isMouseInCutBoxDownLeft>
    514f:	83 c4 10             	add    $0x10,%esp
    5152:	85 c0                	test   %eax,%eax
    5154:	0f 84 fe 00 00 00    	je     5258 <MsgProc+0xfe7>
                {
                    if(isCutBoxInContent(cutbox_pos.x + dx, cutbox_pos.y, cutbox_size.w - dx, cutbox_size.h + dy))
    515a:	8b 15 14 53 02 00    	mov    0x25314,%edx
    5160:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5163:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5166:	a1 18 53 02 00       	mov    0x25318,%eax
    516b:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    516e:	89 c2                	mov    %eax,%edx
    5170:	a1 28 53 02 00       	mov    0x25328,%eax
    5175:	8b 35 24 53 02 00    	mov    0x25324,%esi
    517b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    517e:	01 f1                	add    %esi,%ecx
    5180:	53                   	push   %ebx
    5181:	52                   	push   %edx
    5182:	50                   	push   %eax
    5183:	51                   	push   %ecx
    5184:	e8 50 bd ff ff       	call   ed9 <isCutBoxInContent>
    5189:	83 c4 10             	add    $0x10,%esp
    518c:	85 c0                	test   %eax,%eax
    518e:	0f 84 cd 01 00 00    	je     5361 <MsgProc+0x10f0>
                    {
                        printf(1, "lastmousePos, %d, %d\n", lastMousePos.x, lastMousePos.y);
    5194:	8b 15 84 57 02 00    	mov    0x25784,%edx
    519a:	a1 80 57 02 00       	mov    0x25780,%eax
    519f:	52                   	push   %edx
    51a0:	50                   	push   %eax
    51a1:	68 50 c8 01 00       	push   $0x1c850
    51a6:	6a 01                	push   $0x1
    51a8:	e8 3d 1c 00 00       	call   6dea <printf>
    51ad:	83 c4 10             	add    $0x10,%esp
                        cutbox_pos.x = cutbox_pos.x + dx;
    51b0:	8b 15 24 53 02 00    	mov    0x25324,%edx
    51b6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    51b9:	01 d0                	add    %edx,%eax
    51bb:	a3 24 53 02 00       	mov    %eax,0x25324
                        cutbox_size.w = cutbox_size.w - dx;
    51c0:	a1 18 53 02 00       	mov    0x25318,%eax
    51c5:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    51c8:	a3 18 53 02 00       	mov    %eax,0x25318
                        cutbox_size.h = cutbox_size.h + dy;
    51cd:	8b 15 14 53 02 00    	mov    0x25314,%edx
    51d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    51d6:	01 d0                	add    %edx,%eax
    51d8:	a3 14 53 02 00       	mov    %eax,0x25314
                        drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    51dd:	8b 15 14 53 02 00    	mov    0x25314,%edx
    51e3:	a1 18 53 02 00       	mov    0x25318,%eax
    51e8:	52                   	push   %edx
    51e9:	50                   	push   %eax
    51ea:	ff 35 28 53 02 00    	pushl  0x25328
    51f0:	ff 35 24 53 02 00    	pushl  0x25324
    51f6:	e8 8e cb ff ff       	call   1d89 <drawCutBox>
    51fb:	83 c4 10             	add    $0x10,%esp
                        printf(1, "40, %d, %d, %d\n", cutbox_pos.x, cutbox_pos.y, isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h));
    51fe:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    5204:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    520a:	8b 15 28 53 02 00    	mov    0x25328,%edx
    5210:	a1 24 53 02 00       	mov    0x25324,%eax
    5215:	53                   	push   %ebx
    5216:	51                   	push   %ecx
    5217:	52                   	push   %edx
    5218:	50                   	push   %eax
    5219:	e8 bb bc ff ff       	call   ed9 <isCutBoxInContent>
    521e:	83 c4 10             	add    $0x10,%esp
    5221:	89 c1                	mov    %eax,%ecx
    5223:	8b 15 28 53 02 00    	mov    0x25328,%edx
    5229:	a1 24 53 02 00       	mov    0x25324,%eax
    522e:	83 ec 0c             	sub    $0xc,%esp
    5231:	51                   	push   %ecx
    5232:	52                   	push   %edx
    5233:	50                   	push   %eax
    5234:	68 66 c8 01 00       	push   $0x1c866
    5239:	6a 01                	push   $0x1
    523b:	e8 aa 1b 00 00       	call   6dea <printf>
    5240:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
    5243:	83 ec 0c             	sub    $0xc,%esp
    5246:	68 a0 58 02 00       	push   $0x258a0
    524b:	e8 39 2a 00 00       	call   7c89 <api_repaint>
    5250:	83 c4 10             	add    $0x10,%esp
    5253:	e9 09 01 00 00       	jmp    5361 <MsgProc+0x10f0>
                    }
                }
                else if(isMouseInCutBoxDownRight(lastMousePos.x, lastMousePos.y))
    5258:	8b 15 84 57 02 00    	mov    0x25784,%edx
    525e:	a1 80 57 02 00       	mov    0x25780,%eax
    5263:	83 ec 08             	sub    $0x8,%esp
    5266:	52                   	push   %edx
    5267:	50                   	push   %eax
    5268:	e8 62 ba ff ff       	call   ccf <isMouseInCutBoxDownRight>
    526d:	83 c4 10             	add    $0x10,%esp
    5270:	85 c0                	test   %eax,%eax
    5272:	0f 84 e9 00 00 00    	je     5361 <MsgProc+0x10f0>
                {
                    if(isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w + dx, cutbox_size.h + dy))
    5278:	8b 15 14 53 02 00    	mov    0x25314,%edx
    527e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5281:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5284:	8b 15 18 53 02 00    	mov    0x25318,%edx
    528a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    528d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    5290:	8b 15 28 53 02 00    	mov    0x25328,%edx
    5296:	a1 24 53 02 00       	mov    0x25324,%eax
    529b:	53                   	push   %ebx
    529c:	51                   	push   %ecx
    529d:	52                   	push   %edx
    529e:	50                   	push   %eax
    529f:	e8 35 bc ff ff       	call   ed9 <isCutBoxInContent>
    52a4:	83 c4 10             	add    $0x10,%esp
    52a7:	85 c0                	test   %eax,%eax
    52a9:	0f 84 b2 00 00 00    	je     5361 <MsgProc+0x10f0>
                    {
                        printf(1, "lastmousePos, %d, %d\n", lastMousePos.x, lastMousePos.y);
    52af:	8b 15 84 57 02 00    	mov    0x25784,%edx
    52b5:	a1 80 57 02 00       	mov    0x25780,%eax
    52ba:	52                   	push   %edx
    52bb:	50                   	push   %eax
    52bc:	68 50 c8 01 00       	push   $0x1c850
    52c1:	6a 01                	push   $0x1
    52c3:	e8 22 1b 00 00       	call   6dea <printf>
    52c8:	83 c4 10             	add    $0x10,%esp
                        cutbox_size.w = cutbox_size.w + dx;
    52cb:	8b 15 18 53 02 00    	mov    0x25318,%edx
    52d1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    52d4:	01 d0                	add    %edx,%eax
    52d6:	a3 18 53 02 00       	mov    %eax,0x25318
                        cutbox_size.h = cutbox_size.h + dy;
    52db:	8b 15 14 53 02 00    	mov    0x25314,%edx
    52e1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    52e4:	01 d0                	add    %edx,%eax
    52e6:	a3 14 53 02 00       	mov    %eax,0x25314
                        drawCutBox(cutbox_pos, cutbox_size.w, cutbox_size.h);
    52eb:	8b 15 14 53 02 00    	mov    0x25314,%edx
    52f1:	a1 18 53 02 00       	mov    0x25318,%eax
    52f6:	52                   	push   %edx
    52f7:	50                   	push   %eax
    52f8:	ff 35 28 53 02 00    	pushl  0x25328
    52fe:	ff 35 24 53 02 00    	pushl  0x25324
    5304:	e8 80 ca ff ff       	call   1d89 <drawCutBox>
    5309:	83 c4 10             	add    $0x10,%esp
                        printf(1, "40, %d, %d, %d\n", cutbox_pos.x, cutbox_pos.y, isCutBoxInContent(cutbox_pos.x, cutbox_pos.y, cutbox_size.w, cutbox_size.h));
    530c:	8b 1d 14 53 02 00    	mov    0x25314,%ebx
    5312:	8b 0d 18 53 02 00    	mov    0x25318,%ecx
    5318:	8b 15 28 53 02 00    	mov    0x25328,%edx
    531e:	a1 24 53 02 00       	mov    0x25324,%eax
    5323:	53                   	push   %ebx
    5324:	51                   	push   %ecx
    5325:	52                   	push   %edx
    5326:	50                   	push   %eax
    5327:	e8 ad bb ff ff       	call   ed9 <isCutBoxInContent>
    532c:	83 c4 10             	add    $0x10,%esp
    532f:	89 c1                	mov    %eax,%ecx
    5331:	8b 15 28 53 02 00    	mov    0x25328,%edx
    5337:	a1 24 53 02 00       	mov    0x25324,%eax
    533c:	83 ec 0c             	sub    $0xc,%esp
    533f:	51                   	push   %ecx
    5340:	52                   	push   %edx
    5341:	50                   	push   %eax
    5342:	68 66 c8 01 00       	push   $0x1c866
    5347:	6a 01                	push   $0x1
    5349:	e8 9c 1a 00 00       	call   6dea <printf>
    534e:	83 c4 20             	add    $0x20,%esp
                        api_repaint(&wnd);
    5351:	83 ec 0c             	sub    $0xc,%esp
    5354:	68 a0 58 02 00       	push   $0x258a0
    5359:	e8 2b 29 00 00       	call   7c89 <api_repaint>
    535e:	83 c4 10             	add    $0x10,%esp
                    }
                }
            }
            // cutbox_size.h = cutbox_size.h - dy;
        }
        if(mouse_down == 1 && (is_pencil==1 ||  is_rubber == 1) && isMouseInContent(msg->params[0], msg->params[1]))
    5361:	a1 90 57 02 00       	mov    0x25790,%eax
    5366:	83 f8 01             	cmp    $0x1,%eax
    5369:	0f 85 e4 04 00 00    	jne    5853 <MsgProc+0x15e2>
    536f:	a1 94 57 02 00       	mov    0x25794,%eax
    5374:	83 f8 01             	cmp    $0x1,%eax
    5377:	74 0e                	je     5387 <MsgProc+0x1116>
    5379:	a1 98 57 02 00       	mov    0x25798,%eax
    537e:	83 f8 01             	cmp    $0x1,%eax
    5381:	0f 85 cc 04 00 00    	jne    5853 <MsgProc+0x15e2>
    5387:	8b 45 08             	mov    0x8(%ebp),%eax
    538a:	8b 50 08             	mov    0x8(%eax),%edx
    538d:	8b 45 08             	mov    0x8(%ebp),%eax
    5390:	8b 40 04             	mov    0x4(%eax),%eax
    5393:	83 ec 08             	sub    $0x8,%esp
    5396:	52                   	push   %edx
    5397:	50                   	push   %eax
    5398:	e8 95 bb ff ff       	call   f32 <isMouseInContent>
    539d:	83 c4 10             	add    $0x10,%esp
    53a0:	85 c0                	test   %eax,%eax
    53a2:	0f 84 ab 04 00 00    	je     5853 <MsgProc+0x15e2>
        {
            api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, pencil_color);
    53a8:	b8 05 00 00 00       	mov    $0x5,%eax
    53ad:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
    53b3:	b8 05 00 00 00       	mov    $0x5,%eax
    53b8:	89 45 80             	mov    %eax,-0x80(%ebp)
            }
            // cutbox_size.h = cutbox_size.h - dy;
        }
        if(mouse_down == 1 && (is_pencil==1 ||  is_rubber == 1) && isMouseInContent(msg->params[0], msg->params[1]))
        {
            api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
    53bb:	8b 45 08             	mov    0x8(%ebp),%eax
    53be:	8b 40 04             	mov    0x4(%eax),%eax
    53c1:	ba 05 00 00 00       	mov    $0x5,%edx
    53c6:	89 d1                	mov    %edx,%ecx
    53c8:	c1 e9 1f             	shr    $0x1f,%ecx
    53cb:	01 ca                	add    %ecx,%edx
    53cd:	d1 fa                	sar    %edx
    53cf:	29 d0                	sub    %edx,%eax
    53d1:	89 45 84             	mov    %eax,-0x7c(%ebp)
    53d4:	8b 45 08             	mov    0x8(%ebp),%eax
    53d7:	8b 40 08             	mov    0x8(%eax),%eax
    53da:	ba 05 00 00 00       	mov    $0x5,%edx
    53df:	89 d1                	mov    %edx,%ecx
    53e1:	c1 e9 1f             	shr    $0x1f,%ecx
    53e4:	01 ca                	add    %ecx,%edx
    53e6:	d1 fa                	sar    %edx
    53e8:	29 d0                	sub    %edx,%eax
    53ea:	89 45 88             	mov    %eax,-0x78(%ebp)
    53ed:	83 ec 08             	sub    $0x8,%esp
    53f0:	83 ec 04             	sub    $0x4,%esp
    53f3:	89 e0                	mov    %esp,%eax
    53f5:	0f b7 15 d5 52 02 00 	movzwl 0x252d5,%edx
    53fc:	66 89 10             	mov    %dx,(%eax)
    53ff:	0f b6 15 d7 52 02 00 	movzbl 0x252d7,%edx
    5406:	88 50 02             	mov    %dl,0x2(%eax)
    5409:	ff 75 80             	pushl  -0x80(%ebp)
    540c:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
    5412:	ff 75 88             	pushl  -0x78(%ebp)
    5415:	ff 75 84             	pushl  -0x7c(%ebp)
    5418:	68 a0 58 02 00       	push   $0x258a0
    541d:	e8 14 29 00 00       	call   7d36 <api_drawRect>
    5422:	83 c4 20             	add    $0x20,%esp
                                 (Size) {pointSize, pointSize}, pencil_color);
            api_update(&wnd, (Rect){msg->params[0] - pointSize / 2, msg->params[1] - pointSize /2, pointSize, pointSize});
    5425:	8b 45 08             	mov    0x8(%ebp),%eax
    5428:	8b 40 04             	mov    0x4(%eax),%eax
    542b:	ba 05 00 00 00       	mov    $0x5,%edx
    5430:	89 d1                	mov    %edx,%ecx
    5432:	c1 e9 1f             	shr    $0x1f,%ecx
    5435:	01 ca                	add    %ecx,%edx
    5437:	d1 fa                	sar    %edx
    5439:	29 d0                	sub    %edx,%eax
    543b:	89 45 8c             	mov    %eax,-0x74(%ebp)
    543e:	8b 45 08             	mov    0x8(%ebp),%eax
    5441:	8b 40 08             	mov    0x8(%eax),%eax
    5444:	ba 05 00 00 00       	mov    $0x5,%edx
    5449:	89 d1                	mov    %edx,%ecx
    544b:	c1 e9 1f             	shr    $0x1f,%ecx
    544e:	01 ca                	add    %ecx,%edx
    5450:	d1 fa                	sar    %edx
    5452:	29 d0                	sub    %edx,%eax
    5454:	89 45 90             	mov    %eax,-0x70(%ebp)
    5457:	b8 05 00 00 00       	mov    $0x5,%eax
    545c:	89 45 94             	mov    %eax,-0x6c(%ebp)
    545f:	b8 05 00 00 00       	mov    $0x5,%eax
    5464:	89 45 98             	mov    %eax,-0x68(%ebp)
    5467:	83 ec 0c             	sub    $0xc,%esp
    546a:	ff 75 98             	pushl  -0x68(%ebp)
    546d:	ff 75 94             	pushl  -0x6c(%ebp)
    5470:	ff 75 90             	pushl  -0x70(%ebp)
    5473:	ff 75 8c             	pushl  -0x74(%ebp)
    5476:	68 a0 58 02 00       	push   $0x258a0
    547b:	e8 27 28 00 00       	call   7ca7 <api_update>
    5480:	83 c4 20             	add    $0x20,%esp
        }
        break;
    5483:	e9 cb 03 00 00       	jmp    5853 <MsgProc+0x15e2>
    case M_MOUSE_UP:
        mouse_down = 0;
    5488:	c7 05 90 57 02 00 00 	movl   $0x0,0x25790
    548f:	00 00 00 
        break;
    5492:	e9 c0 03 00 00       	jmp    5857 <MsgProc+0x15e6>
    case M_TIMER:
        if(has_content == 1 && current_gif_img->gif_img_num > 1 && current_gif_img->is_onshow == 1)
    5497:	a1 a4 57 02 00       	mov    0x257a4,%eax
    549c:	83 f8 01             	cmp    $0x1,%eax
    549f:	0f 85 b1 03 00 00    	jne    5856 <MsgProc+0x15e5>
    54a5:	a1 84 58 02 00       	mov    0x25884,%eax
    54aa:	8b 40 0c             	mov    0xc(%eax),%eax
    54ad:	83 f8 01             	cmp    $0x1,%eax
    54b0:	0f 8e a0 03 00 00    	jle    5856 <MsgProc+0x15e5>
    54b6:	a1 84 58 02 00       	mov    0x25884,%eax
    54bb:	8b 40 10             	mov    0x10(%eax),%eax
    54be:	83 f8 01             	cmp    $0x1,%eax
    54c1:	0f 85 8f 03 00 00    	jne    5856 <MsgProc+0x15e5>
        {
            struct RGB *t;
            struct RGB *o;
            int max_line = edit_img_size.w;
    54c7:	a1 e0 52 02 00       	mov    0x252e0,%eax
    54cc:	89 45 cc             	mov    %eax,-0x34(%ebp)
            for (int i = 0; i < edit_img_size.h; i++) {
    54cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    54d6:	eb 68                	jmp    5540 <MsgProc+0x12cf>
                o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    54d8:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    54de:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    54e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    54e7:	01 c2                	add    %eax,%edx
    54e9:	a1 b0 58 02 00       	mov    0x258b0,%eax
    54ee:	0f af c2             	imul   %edx,%eax
    54f1:	89 c2                	mov    %eax,%edx
    54f3:	a1 e4 52 02 00       	mov    0x252e4,%eax
    54f8:	01 c2                	add    %eax,%edx
    54fa:	89 d0                	mov    %edx,%eax
    54fc:	01 c0                	add    %eax,%eax
    54fe:	01 d0                	add    %edx,%eax
    5500:	01 c8                	add    %ecx,%eax
    5502:	89 45 c8             	mov    %eax,-0x38(%ebp)
                t = edit_img_origin + i * edit_img_size.w;
    5505:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    550b:	a1 e0 52 02 00       	mov    0x252e0,%eax
    5510:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    5514:	89 c1                	mov    %eax,%ecx
    5516:	89 c8                	mov    %ecx,%eax
    5518:	01 c0                	add    %eax,%eax
    551a:	01 c8                	add    %ecx,%eax
    551c:	01 d0                	add    %edx,%eax
    551e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
                memmove(o, t, max_line * 3);
    5521:	8b 55 cc             	mov    -0x34(%ebp),%edx
    5524:	89 d0                	mov    %edx,%eax
    5526:	01 c0                	add    %eax,%eax
    5528:	01 d0                	add    %edx,%eax
    552a:	83 ec 04             	sub    $0x4,%esp
    552d:	50                   	push   %eax
    552e:	ff 75 c4             	pushl  -0x3c(%ebp)
    5531:	ff 75 c8             	pushl  -0x38(%ebp)
    5534:	e8 c5 16 00 00       	call   6bfe <memmove>
    5539:	83 c4 10             	add    $0x10,%esp
        if(has_content == 1 && current_gif_img->gif_img_num > 1 && current_gif_img->is_onshow == 1)
        {
            struct RGB *t;
            struct RGB *o;
            int max_line = edit_img_size.w;
            for (int i = 0; i < edit_img_size.h; i++) {
    553c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5540:	a1 dc 52 02 00       	mov    0x252dc,%eax
    5545:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5548:	7f 8e                	jg     54d8 <MsgProc+0x1267>
                o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
                t = edit_img_origin + i * edit_img_size.w;
                memmove(o, t, max_line * 3);
            }
            int pos_y=235-(current_gif_img->h/current_gif_img->gif_img_num)/2;
    554a:	a1 84 58 02 00       	mov    0x25884,%eax
    554f:	8b 40 20             	mov    0x20(%eax),%eax
    5552:	8b 15 84 58 02 00    	mov    0x25884,%edx
    5558:	8b 72 0c             	mov    0xc(%edx),%esi
    555b:	99                   	cltd   
    555c:	f7 fe                	idiv   %esi
    555e:	89 c2                	mov    %eax,%edx
    5560:	c1 ea 1f             	shr    $0x1f,%edx
    5563:	01 d0                	add    %edx,%eax
    5565:	d1 f8                	sar    %eax
    5567:	ba eb 00 00 00       	mov    $0xeb,%edx
    556c:	29 c2                	sub    %eax,%edx
    556e:	89 d0                	mov    %edx,%eax
    5570:	89 45 c0             	mov    %eax,-0x40(%ebp)
            int pos_x=390-current_gif_img->w/2;
    5573:	a1 84 58 02 00       	mov    0x25884,%eax
    5578:	8b 40 28             	mov    0x28(%eax),%eax
    557b:	89 c2                	mov    %eax,%edx
    557d:	c1 ea 1f             	shr    $0x1f,%edx
    5580:	01 d0                	add    %edx,%eax
    5582:	d1 f8                	sar    %eax
    5584:	ba 86 01 00 00       	mov    $0x186,%edx
    5589:	29 c2                	sub    %eax,%edx
    558b:	89 d0                	mov    %edx,%eax
    558d:	89 45 bc             	mov    %eax,-0x44(%ebp)
            api_paint24BitmapToContent(&wnd, current_gif_img->data, (Point){pos_x,pos_y}, (Point){0,(current_gif_img->h / current_gif_img->gif_img_num)*(gif_frame-1)},(Size){current_gif_img->h,current_gif_img->w},(Size){(current_gif_img->h / current_gif_img->gif_img_num),current_gif_img->w});
    5590:	a1 84 58 02 00       	mov    0x25884,%eax
    5595:	8b 40 20             	mov    0x20(%eax),%eax
    5598:	8b 15 84 58 02 00    	mov    0x25884,%edx
    559e:	8b 72 0c             	mov    0xc(%edx),%esi
    55a1:	99                   	cltd   
    55a2:	f7 fe                	idiv   %esi
    55a4:	89 45 9c             	mov    %eax,-0x64(%ebp)
    55a7:	a1 84 58 02 00       	mov    0x25884,%eax
    55ac:	8b 40 28             	mov    0x28(%eax),%eax
    55af:	89 45 a0             	mov    %eax,-0x60(%ebp)
    55b2:	a1 84 58 02 00       	mov    0x25884,%eax
    55b7:	8b 40 20             	mov    0x20(%eax),%eax
    55ba:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    55bd:	a1 84 58 02 00       	mov    0x25884,%eax
    55c2:	8b 40 28             	mov    0x28(%eax),%eax
    55c5:	89 45 a8             	mov    %eax,-0x58(%ebp)
    55c8:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
    55cf:	a1 84 58 02 00       	mov    0x25884,%eax
    55d4:	8b 40 20             	mov    0x20(%eax),%eax
    55d7:	8b 15 84 58 02 00    	mov    0x25884,%edx
    55dd:	8b 72 0c             	mov    0xc(%edx),%esi
    55e0:	99                   	cltd   
    55e1:	f7 fe                	idiv   %esi
    55e3:	89 c2                	mov    %eax,%edx
    55e5:	a1 2c 53 02 00       	mov    0x2532c,%eax
    55ea:	83 e8 01             	sub    $0x1,%eax
    55ed:	0f af c2             	imul   %edx,%eax
    55f0:	89 45 b0             	mov    %eax,-0x50(%ebp)
    55f3:	8b 45 bc             	mov    -0x44(%ebp),%eax
    55f6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    55f9:	8b 45 c0             	mov    -0x40(%ebp),%eax
    55fc:	89 45 b8             	mov    %eax,-0x48(%ebp)
    55ff:	a1 84 58 02 00       	mov    0x25884,%eax
    5604:	8b 40 14             	mov    0x14(%eax),%eax
    5607:	83 ec 08             	sub    $0x8,%esp
    560a:	ff 75 a0             	pushl  -0x60(%ebp)
    560d:	ff 75 9c             	pushl  -0x64(%ebp)
    5610:	ff 75 a8             	pushl  -0x58(%ebp)
    5613:	ff 75 a4             	pushl  -0x5c(%ebp)
    5616:	ff 75 b0             	pushl  -0x50(%ebp)
    5619:	ff 75 ac             	pushl  -0x54(%ebp)
    561c:	ff 75 b8             	pushl  -0x48(%ebp)
    561f:	ff 75 b4             	pushl  -0x4c(%ebp)
    5622:	50                   	push   %eax
    5623:	68 a0 58 02 00       	push   $0x258a0
    5628:	e8 dc 25 00 00       	call   7c09 <api_paint24BitmapToContent>
    562d:	83 c4 30             	add    $0x30,%esp
            gif_frame = (gif_frame % current_gif_img->gif_img_num ) + 1;
    5630:	a1 2c 53 02 00       	mov    0x2532c,%eax
    5635:	8b 15 84 58 02 00    	mov    0x25884,%edx
    563b:	8b 4a 0c             	mov    0xc(%edx),%ecx
    563e:	99                   	cltd   
    563f:	f7 f9                	idiv   %ecx
    5641:	89 d0                	mov    %edx,%eax
    5643:	83 c0 01             	add    $0x1,%eax
    5646:	a3 2c 53 02 00       	mov    %eax,0x2532c
            printf(1, "gif_frame, %d\n", gif_frame);
    564b:	a1 2c 53 02 00       	mov    0x2532c,%eax
    5650:	83 ec 04             	sub    $0x4,%esp
    5653:	50                   	push   %eax
    5654:	68 76 c8 01 00       	push   $0x1c876
    5659:	6a 01                	push   $0x1
    565b:	e8 8a 17 00 00       	call   6dea <printf>
    5660:	83 c4 10             	add    $0x10,%esp
            api_repaint(&wnd);
    5663:	83 ec 0c             	sub    $0xc,%esp
    5666:	68 a0 58 02 00       	push   $0x258a0
    566b:	e8 19 26 00 00       	call   7c89 <api_repaint>
    5670:	83 c4 10             	add    $0x10,%esp
            // api_update(&wnd, (Rect){pos_x, pos_y, (current_gif_img->h / current_gif_img->gif_img_num), current_gif_img->w});
        }
        break;
    5673:	e9 de 01 00 00       	jmp    5856 <MsgProc+0x15e5>
    case M_CLOSE_WINDOW:
        // printf(1, save_icon);
        printf(1, "USER_CLOSE\n");
    5678:	83 ec 08             	sub    $0x8,%esp
    567b:	68 85 c8 01 00       	push   $0x1c885
    5680:	6a 01                	push   $0x1
    5682:	e8 63 17 00 00       	call   6dea <printf>
    5687:	83 c4 10             	add    $0x10,%esp
        free(save_icon);
    568a:	a1 38 58 02 00       	mov    0x25838,%eax
    568f:	83 ec 0c             	sub    $0xc,%esp
    5692:	50                   	push   %eax
    5693:	e8 e3 18 00 00       	call   6f7b <free>
    5698:	83 c4 10             	add    $0x10,%esp
        free(delete_icon);
    569b:	a1 04 58 02 00       	mov    0x25804,%eax
    56a0:	83 ec 0c             	sub    $0xc,%esp
    56a3:	50                   	push   %eax
    56a4:	e8 d2 18 00 00       	call   6f7b <free>
    56a9:	83 c4 10             	add    $0x10,%esp
        free(cut_icon);
    56ac:	a1 c4 58 02 00       	mov    0x258c4,%eax
    56b1:	83 ec 0c             	sub    $0xc,%esp
    56b4:	50                   	push   %eax
    56b5:	e8 c1 18 00 00       	call   6f7b <free>
    56ba:	83 c4 10             	add    $0x10,%esp
        free(pen_icon);
    56bd:	a1 48 58 02 00       	mov    0x25848,%eax
    56c2:	83 ec 0c             	sub    $0xc,%esp
    56c5:	50                   	push   %eax
    56c6:	e8 b0 18 00 00       	call   6f7b <free>
    56cb:	83 c4 10             	add    $0x10,%esp
        free(rubber_icon);
    56ce:	a1 cc 58 02 00       	mov    0x258cc,%eax
    56d3:	83 ec 0c             	sub    $0xc,%esp
    56d6:	50                   	push   %eax
    56d7:	e8 9f 18 00 00       	call   6f7b <free>
    56dc:	83 c4 10             	add    $0x10,%esp
        free(red_icon);
    56df:	a1 70 58 02 00       	mov    0x25870,%eax
    56e4:	83 ec 0c             	sub    $0xc,%esp
    56e7:	50                   	push   %eax
    56e8:	e8 8e 18 00 00       	call   6f7b <free>
    56ed:	83 c4 10             	add    $0x10,%esp
        free(green_icon);
    56f0:	a1 d8 58 02 00       	mov    0x258d8,%eax
    56f5:	83 ec 0c             	sub    $0xc,%esp
    56f8:	50                   	push   %eax
    56f9:	e8 7d 18 00 00       	call   6f7b <free>
    56fe:	83 c4 10             	add    $0x10,%esp
        free(blue_icon);
    5701:	a1 60 58 02 00       	mov    0x25860,%eax
    5706:	83 ec 0c             	sub    $0xc,%esp
    5709:	50                   	push   %eax
    570a:	e8 6c 18 00 00       	call   6f7b <free>
    570f:	83 c4 10             	add    $0x10,%esp
        free(purple_icon);
    5712:	a1 c8 58 02 00       	mov    0x258c8,%eax
    5717:	83 ec 0c             	sub    $0xc,%esp
    571a:	50                   	push   %eax
    571b:	e8 5b 18 00 00       	call   6f7b <free>
    5720:	83 c4 10             	add    $0x10,%esp
        free(zoomin_icon);
    5723:	a1 28 58 02 00       	mov    0x25828,%eax
    5728:	83 ec 0c             	sub    $0xc,%esp
    572b:	50                   	push   %eax
    572c:	e8 4a 18 00 00       	call   6f7b <free>
    5731:	83 c4 10             	add    $0x10,%esp
        free(zoomout_icon);
    5734:	a1 ec 58 02 00       	mov    0x258ec,%eax
    5739:	83 ec 0c             	sub    $0xc,%esp
    573c:	50                   	push   %eax
    573d:	e8 39 18 00 00       	call   6f7b <free>
    5742:	83 c4 10             	add    $0x10,%esp
        free(rotate_left_90_icon);
    5745:	a1 f8 58 02 00       	mov    0x258f8,%eax
    574a:	83 ec 0c             	sub    $0xc,%esp
    574d:	50                   	push   %eax
    574e:	e8 28 18 00 00       	call   6f7b <free>
    5753:	83 c4 10             	add    $0x10,%esp
        free(rotate_left_30_icon);
    5756:	a1 10 58 02 00       	mov    0x25810,%eax
    575b:	83 ec 0c             	sub    $0xc,%esp
    575e:	50                   	push   %eax
    575f:	e8 17 18 00 00       	call   6f7b <free>
    5764:	83 c4 10             	add    $0x10,%esp
        free(rotate_right_30_icon);
    5767:	a1 64 58 02 00       	mov    0x25864,%eax
    576c:	83 ec 0c             	sub    $0xc,%esp
    576f:	50                   	push   %eax
    5770:	e8 06 18 00 00       	call   6f7b <free>
    5775:	83 c4 10             	add    $0x10,%esp
        free(rotate_right_90_icon);
    5778:	a1 30 58 02 00       	mov    0x25830,%eax
    577d:	83 ec 0c             	sub    $0xc,%esp
    5780:	50                   	push   %eax
    5781:	e8 f5 17 00 00       	call   6f7b <free>
    5786:	83 c4 10             	add    $0x10,%esp
        free(image_list_up_icon);
    5789:	a1 6c 58 02 00       	mov    0x2586c,%eax
    578e:	83 ec 0c             	sub    $0xc,%esp
    5791:	50                   	push   %eax
    5792:	e8 e4 17 00 00       	call   6f7b <free>
    5797:	83 c4 10             	add    $0x10,%esp
        free(image_list_down_icon);
    579a:	a1 14 58 02 00       	mov    0x25814,%eax
    579f:	83 ec 0c             	sub    $0xc,%esp
    57a2:	50                   	push   %eax
    57a3:	e8 d3 17 00 00       	call   6f7b <free>
    57a8:	83 c4 10             	add    $0x10,%esp
        free(bmp_icon);
    57ab:	a1 00 58 02 00       	mov    0x25800,%eax
    57b0:	83 ec 0c             	sub    $0xc,%esp
    57b3:	50                   	push   %eax
    57b4:	e8 c2 17 00 00       	call   6f7b <free>
    57b9:	83 c4 10             	add    $0x10,%esp
        free(edit_img_origin);
    57bc:	a1 c0 58 02 00       	mov    0x258c0,%eax
    57c1:	83 ec 0c             	sub    $0xc,%esp
    57c4:	50                   	push   %eax
    57c5:	e8 b1 17 00 00       	call   6f7b <free>
    57ca:	83 c4 10             	add    $0x10,%esp
        free(image_title_origin);
    57cd:	a1 fc 58 02 00       	mov    0x258fc,%eax
    57d2:	83 ec 0c             	sub    $0xc,%esp
    57d5:	50                   	push   %eax
    57d6:	e8 a0 17 00 00       	call   6f7b <free>
    57db:	83 c4 10             	add    $0x10,%esp
        free(image_list_origin);
    57de:	a1 f4 58 02 00       	mov    0x258f4,%eax
    57e3:	83 ec 0c             	sub    $0xc,%esp
    57e6:	50                   	push   %eax
    57e7:	e8 8f 17 00 00       	call   6f7b <free>
    57ec:	83 c4 10             	add    $0x10,%esp
        free(cut_confirm_icon);
    57ef:	a1 34 58 02 00       	mov    0x25834,%eax
    57f4:	83 ec 0c             	sub    $0xc,%esp
    57f7:	50                   	push   %eax
    57f8:	e8 7e 17 00 00       	call   6f7b <free>
    57fd:	83 c4 10             	add    $0x10,%esp
        free(cut_cancel_icon);
    5800:	a1 58 58 02 00       	mov    0x25858,%eax
    5805:	83 ec 0c             	sub    $0xc,%esp
    5808:	50                   	push   %eax
    5809:	e8 6d 17 00 00       	call   6f7b <free>
    580e:	83 c4 10             	add    $0x10,%esp
        api_destroywindow(&wnd);
    5811:	83 ec 0c             	sub    $0xc,%esp
    5814:	68 a0 58 02 00       	push   $0x258a0
    5819:	e8 0e 27 00 00       	call   7f2c <api_destroywindow>
    581e:	83 c4 10             	add    $0x10,%esp
        break;
    5821:	eb 34                	jmp    5857 <MsgProc+0x15e6>


    case M_MOUSE_DOWN:
        if(isMouseInPencilColorButton(msg->params[0], msg->params[1]))
        {
            break;
    5823:	90                   	nop
    5824:	eb 31                	jmp    5857 <MsgProc+0x15e6>
            api_drawImgButton(&wnd, pen_icon, (Point){579,0}, (Size){30,30}, border1, borderColor, pressed_shift);
            break;
        }
        if(isMouseInRubberButton(msg->params[0], msg->params[1]))
        {
            break;
    5826:	90                   	nop
    5827:	eb 2e                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInSaveButton(msg->params[0], msg->params[1]))
        {
            break;
    5829:	90                   	nop
    582a:	eb 2b                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInDeleteButton(msg->params[0], msg->params[1]))
        {
            break;
    582c:	90                   	nop
    582d:	eb 28                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInListUpButton(msg->params[0], msg->params[1]))
        {
            break;
    582f:	90                   	nop
    5830:	eb 25                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInListDownButton(msg->params[0], msg->params[1]))
        {
            break;
    5832:	90                   	nop
    5833:	eb 22                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInListItem(msg->params[0], msg->params[1]))
        {
            break;
    5835:	90                   	nop
    5836:	eb 1f                	jmp    5857 <MsgProc+0x15e6>
            api_drawImgButton(&wnd, zoomin_icon, (Point){140, 440}, (Size){60, 60}, border2, borderColor, pressed_shift);
            break;
        }
        if(isMouseInZoomoutButton(msg->params[0], msg->params[1]))
        {
            break;
    5838:	90                   	nop
    5839:	eb 1c                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInRotateLeftNinetyButton(msg->params[0], msg->params[1]))
        {
            break;
    583b:	90                   	nop
    583c:	eb 19                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInRotateLeftThirtyButton(msg->params[0], msg->params[1]))
        {
            break;
    583e:	90                   	nop
    583f:	eb 16                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInRotateRightNinetyButton(msg->params[0], msg->params[1]))
        {
            break;
    5841:	90                   	nop
    5842:	eb 13                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInRotateRightThirtyButton(msg->params[0], msg->params[1]))
        {
            break;
    5844:	90                   	nop
    5845:	eb 10                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInRolloverButton(msg->params[0], msg->params[1]))
        {
            break;
    5847:	90                   	nop
    5848:	eb 0d                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInTurnaroundButton(msg->params[0], msg->params[1]))
        {
            break;
    584a:	90                   	nop
    584b:	eb 0a                	jmp    5857 <MsgProc+0x15e6>
        }
        if(isMouseInCutButton(msg->params[0], msg->params[1]))
        {
            break;
    584d:	90                   	nop
    584e:	eb 07                	jmp    5857 <MsgProc+0x15e6>
            int pos_y=235-content_size.h/2;
            int pos_x=390-content_size.w/2;
            api_paint24BitmapToContent(&wnd, cut_img_result, (Point){pos_x,pos_y}, (Point){0,0}, (Size){content_size.h,content_size.w},(Size){content_size.h,content_size.w});
            api_repaint(&wnd);
        }
        break;
    5850:	90                   	nop
    5851:	eb 04                	jmp    5857 <MsgProc+0x15e6>
        {
            api_drawRect(&wnd, (Point) {msg->params[0] - pointSize / 2, msg->params[1] - pointSize / 2},
                                 (Size) {pointSize, pointSize}, pencil_color);
            api_update(&wnd, (Rect){msg->params[0] - pointSize / 2, msg->params[1] - pointSize /2, pointSize, pointSize});
        }
        break;
    5853:	90                   	nop
    5854:	eb 01                	jmp    5857 <MsgProc+0x15e6>
            gif_frame = (gif_frame % current_gif_img->gif_img_num ) + 1;
            printf(1, "gif_frame, %d\n", gif_frame);
            api_repaint(&wnd);
            // api_update(&wnd, (Rect){pos_x, pos_y, (current_gif_img->h / current_gif_img->gif_img_num), current_gif_img->w});
        }
        break;
    5856:	90                   	nop
        free(cut_confirm_icon);
        free(cut_cancel_icon);
        api_destroywindow(&wnd);
        break;
    }
}
    5857:	90                   	nop
    5858:	8d 65 f8             	lea    -0x8(%ebp),%esp
    585b:	5b                   	pop    %ebx
    585c:	5e                   	pop    %esi
    585d:	5d                   	pop    %ebp
    585e:	c3                   	ret    

0000585f <main>:
int
main(int argc, char *argv[])
{
    585f:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    5863:	83 e4 f0             	and    $0xfffffff0,%esp
    5866:	ff 71 fc             	pushl  -0x4(%ecx)
    5869:	55                   	push   %ebp
    586a:	89 e5                	mov    %esp,%ebp
    586c:	53                   	push   %ebx
    586d:	51                   	push   %ecx
    586e:	81 ec 60 01 00 00    	sub    $0x160,%esp
    //int pra = argv[1][0] - '0';
    wnd.pos.x = 100;
    5874:	c7 05 a4 58 02 00 64 	movl   $0x64,0x258a4
    587b:	00 00 00 
    wnd.pos.y = 60;
    587e:	c7 05 a8 58 02 00 3c 	movl   $0x3c,0x258a8
    5885:	00 00 00 
    //wnd.pos.x = 160;
    //wnd.pos.y = 30;
    wnd.size.w = 640;
    5888:	c7 05 b0 58 02 00 80 	movl   $0x280,0x258b0
    588f:	02 00 00 
    wnd.size.h = 500;
    5892:	c7 05 ac 58 02 00 f4 	movl   $0x1f4,0x258ac
    5899:	01 00 00 
    wnd.title = "PhotoViewer";
    589c:	c7 05 b4 58 02 00 b4 	movl   $0x1c8b4,0x258b4
    58a3:	c8 01 00 
    
    int h,w;
    save_icon = malloc(30*30*3);
    58a6:	83 ec 0c             	sub    $0xc,%esp
    58a9:	68 8c 0a 00 00       	push   $0xa8c
    58ae:	e8 0a 18 00 00       	call   70bd <malloc>
    58b3:	83 c4 10             	add    $0x10,%esp
    58b6:	a3 38 58 02 00       	mov    %eax,0x25838
    delete_icon = malloc(30*30*3);
    58bb:	83 ec 0c             	sub    $0xc,%esp
    58be:	68 8c 0a 00 00       	push   $0xa8c
    58c3:	e8 f5 17 00 00       	call   70bd <malloc>
    58c8:	83 c4 10             	add    $0x10,%esp
    58cb:	a3 04 58 02 00       	mov    %eax,0x25804
    cut_icon = malloc(30*30*3);
    58d0:	83 ec 0c             	sub    $0xc,%esp
    58d3:	68 8c 0a 00 00       	push   $0xa8c
    58d8:	e8 e0 17 00 00       	call   70bd <malloc>
    58dd:	83 c4 10             	add    $0x10,%esp
    58e0:	a3 c4 58 02 00       	mov    %eax,0x258c4
    pen_icon = malloc(30*30*3);
    58e5:	83 ec 0c             	sub    $0xc,%esp
    58e8:	68 8c 0a 00 00       	push   $0xa8c
    58ed:	e8 cb 17 00 00       	call   70bd <malloc>
    58f2:	83 c4 10             	add    $0x10,%esp
    58f5:	a3 48 58 02 00       	mov    %eax,0x25848
    rubber_icon = malloc(30*30*3);
    58fa:	83 ec 0c             	sub    $0xc,%esp
    58fd:	68 8c 0a 00 00       	push   $0xa8c
    5902:	e8 b6 17 00 00       	call   70bd <malloc>
    5907:	83 c4 10             	add    $0x10,%esp
    590a:	a3 cc 58 02 00       	mov    %eax,0x258cc
    red_icon = malloc(20*20*3);
    590f:	83 ec 0c             	sub    $0xc,%esp
    5912:	68 b0 04 00 00       	push   $0x4b0
    5917:	e8 a1 17 00 00       	call   70bd <malloc>
    591c:	83 c4 10             	add    $0x10,%esp
    591f:	a3 70 58 02 00       	mov    %eax,0x25870
    green_icon = malloc(20*20*3);
    5924:	83 ec 0c             	sub    $0xc,%esp
    5927:	68 b0 04 00 00       	push   $0x4b0
    592c:	e8 8c 17 00 00       	call   70bd <malloc>
    5931:	83 c4 10             	add    $0x10,%esp
    5934:	a3 d8 58 02 00       	mov    %eax,0x258d8
    blue_icon = malloc(20*20*3);
    5939:	83 ec 0c             	sub    $0xc,%esp
    593c:	68 b0 04 00 00       	push   $0x4b0
    5941:	e8 77 17 00 00       	call   70bd <malloc>
    5946:	83 c4 10             	add    $0x10,%esp
    5949:	a3 60 58 02 00       	mov    %eax,0x25860
    purple_icon = malloc(20*20*3);
    594e:	83 ec 0c             	sub    $0xc,%esp
    5951:	68 b0 04 00 00       	push   $0x4b0
    5956:	e8 62 17 00 00       	call   70bd <malloc>
    595b:	83 c4 10             	add    $0x10,%esp
    595e:	a3 c8 58 02 00       	mov    %eax,0x258c8
    zoomin_icon = malloc(60*60*3);
    5963:	83 ec 0c             	sub    $0xc,%esp
    5966:	68 30 2a 00 00       	push   $0x2a30
    596b:	e8 4d 17 00 00       	call   70bd <malloc>
    5970:	83 c4 10             	add    $0x10,%esp
    5973:	a3 28 58 02 00       	mov    %eax,0x25828
    zoomout_icon = malloc(60*60*3);
    5978:	83 ec 0c             	sub    $0xc,%esp
    597b:	68 30 2a 00 00       	push   $0x2a30
    5980:	e8 38 17 00 00       	call   70bd <malloc>
    5985:	83 c4 10             	add    $0x10,%esp
    5988:	a3 ec 58 02 00       	mov    %eax,0x258ec
    rotate_left_90_icon = malloc(60*63*3);
    598d:	83 ec 0c             	sub    $0xc,%esp
    5990:	68 4c 2c 00 00       	push   $0x2c4c
    5995:	e8 23 17 00 00       	call   70bd <malloc>
    599a:	83 c4 10             	add    $0x10,%esp
    599d:	a3 f8 58 02 00       	mov    %eax,0x258f8
    rotate_left_30_icon = malloc(60*65*3);
    59a2:	83 ec 0c             	sub    $0xc,%esp
    59a5:	68 b4 2d 00 00       	push   $0x2db4
    59aa:	e8 0e 17 00 00       	call   70bd <malloc>
    59af:	83 c4 10             	add    $0x10,%esp
    59b2:	a3 10 58 02 00       	mov    %eax,0x25810
    rotate_right_30_icon = malloc(60*65*3);
    59b7:	83 ec 0c             	sub    $0xc,%esp
    59ba:	68 b4 2d 00 00       	push   $0x2db4
    59bf:	e8 f9 16 00 00       	call   70bd <malloc>
    59c4:	83 c4 10             	add    $0x10,%esp
    59c7:	a3 64 58 02 00       	mov    %eax,0x25864
    rotate_right_90_icon = malloc(60*65*3);
    59cc:	83 ec 0c             	sub    $0xc,%esp
    59cf:	68 b4 2d 00 00       	push   $0x2db4
    59d4:	e8 e4 16 00 00       	call   70bd <malloc>
    59d9:	83 c4 10             	add    $0x10,%esp
    59dc:	a3 30 58 02 00       	mov    %eax,0x25830
    image_list_up_icon = malloc(35*20*3);
    59e1:	83 ec 0c             	sub    $0xc,%esp
    59e4:	68 34 08 00 00       	push   $0x834
    59e9:	e8 cf 16 00 00       	call   70bd <malloc>
    59ee:	83 c4 10             	add    $0x10,%esp
    59f1:	a3 6c 58 02 00       	mov    %eax,0x2586c
    image_list_down_icon = malloc(35*20*3);
    59f6:	83 ec 0c             	sub    $0xc,%esp
    59f9:	68 34 08 00 00       	push   $0x834
    59fe:	e8 ba 16 00 00       	call   70bd <malloc>
    5a03:	83 c4 10             	add    $0x10,%esp
    5a06:	a3 14 58 02 00       	mov    %eax,0x25814
    bmp_icon = malloc(80*80*3);
    5a0b:	83 ec 0c             	sub    $0xc,%esp
    5a0e:	68 00 4b 00 00       	push   $0x4b00
    5a13:	e8 a5 16 00 00       	call   70bd <malloc>
    5a18:	83 c4 10             	add    $0x10,%esp
    5a1b:	a3 00 58 02 00       	mov    %eax,0x25800
    rollover_icon = malloc(60*60*3);
    5a20:	83 ec 0c             	sub    $0xc,%esp
    5a23:	68 30 2a 00 00       	push   $0x2a30
    5a28:	e8 90 16 00 00       	call   70bd <malloc>
    5a2d:	83 c4 10             	add    $0x10,%esp
    5a30:	a3 18 58 02 00       	mov    %eax,0x25818
    turnaround_icon = malloc(60*60*3);
    5a35:	83 ec 0c             	sub    $0xc,%esp
    5a38:	68 30 2a 00 00       	push   $0x2a30
    5a3d:	e8 7b 16 00 00       	call   70bd <malloc>
    5a42:	83 c4 10             	add    $0x10,%esp
    5a45:	a3 0c 58 02 00       	mov    %eax,0x2580c
    cut_confirm_icon = malloc(cut_box_button_width*cut_box_button_height*3);
    5a4a:	ba 14 00 00 00       	mov    $0x14,%edx
    5a4f:	b8 14 00 00 00       	mov    $0x14,%eax
    5a54:	0f af d0             	imul   %eax,%edx
    5a57:	89 d0                	mov    %edx,%eax
    5a59:	01 c0                	add    %eax,%eax
    5a5b:	01 d0                	add    %edx,%eax
    5a5d:	83 ec 0c             	sub    $0xc,%esp
    5a60:	50                   	push   %eax
    5a61:	e8 57 16 00 00       	call   70bd <malloc>
    5a66:	83 c4 10             	add    $0x10,%esp
    5a69:	a3 34 58 02 00       	mov    %eax,0x25834
    cut_cancel_icon = malloc(cut_box_button_width*cut_box_button_height*3);
    5a6e:	ba 14 00 00 00       	mov    $0x14,%edx
    5a73:	b8 14 00 00 00       	mov    $0x14,%eax
    5a78:	0f af d0             	imul   %eax,%edx
    5a7b:	89 d0                	mov    %edx,%eax
    5a7d:	01 c0                	add    %eax,%eax
    5a7f:	01 d0                	add    %edx,%eax
    5a81:	83 ec 0c             	sub    $0xc,%esp
    5a84:	50                   	push   %eax
    5a85:	e8 33 16 00 00       	call   70bd <malloc>
    5a8a:	83 c4 10             	add    $0x10,%esp
    5a8d:	a3 58 58 02 00       	mov    %eax,0x25858
    edit_img_test = malloc(edit_img_size.w*edit_img_size.h*3);
    5a92:	8b 15 e0 52 02 00    	mov    0x252e0,%edx
    5a98:	a1 dc 52 02 00       	mov    0x252dc,%eax
    5a9d:	0f af d0             	imul   %eax,%edx
    5aa0:	89 d0                	mov    %edx,%eax
    5aa2:	01 c0                	add    %eax,%eax
    5aa4:	01 d0                	add    %edx,%eax
    5aa6:	83 ec 0c             	sub    $0xc,%esp
    5aa9:	50                   	push   %eax
    5aaa:	e8 0e 16 00 00       	call   70bd <malloc>
    5aaf:	83 c4 10             	add    $0x10,%esp
    5ab2:	a3 2c 58 02 00       	mov    %eax,0x2582c
    
    api_createwindow(&wnd);
    5ab7:	83 ec 0c             	sub    $0xc,%esp
    5aba:	68 a0 58 02 00       	push   $0x258a0
    5abf:	e8 33 20 00 00       	call   7af7 <api_createwindow>
    5ac4:	83 c4 10             	add    $0x10,%esp
    

    // save_icon = LoadImg(save_filename);
    read24BitmapFile(save_filename, save_icon, &h, &w);
    5ac7:	a1 38 58 02 00       	mov    0x25838,%eax
    5acc:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5ad2:	52                   	push   %edx
    5ad3:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5ad9:	52                   	push   %edx
    5ada:	50                   	push   %eax
    5adb:	68 80 51 02 00       	push   $0x25180
    5ae0:	e8 e7 1c 00 00       	call   77cc <read24BitmapFile>
    5ae5:	83 c4 10             	add    $0x10,%esp
    printf(1, "Icon %d, %d", h, w);
    5ae8:	8b 95 a4 fe ff ff    	mov    -0x15c(%ebp),%edx
    5aee:	8b 85 a8 fe ff ff    	mov    -0x158(%ebp),%eax
    5af4:	52                   	push   %edx
    5af5:	50                   	push   %eax
    5af6:	68 c0 c8 01 00       	push   $0x1c8c0
    5afb:	6a 01                	push   $0x1
    5afd:	e8 e8 12 00 00       	call   6dea <printf>
    5b02:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(delete_filename, delete_icon,&h,&w);
    5b05:	a1 04 58 02 00       	mov    0x25804,%eax
    5b0a:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5b10:	52                   	push   %edx
    5b11:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5b17:	52                   	push   %edx
    5b18:	50                   	push   %eax
    5b19:	68 8c 51 02 00       	push   $0x2518c
    5b1e:	e8 a9 1c 00 00       	call   77cc <read24BitmapFile>
    5b23:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(cut_filename, cut_icon, &h, &w);
    5b26:	a1 c4 58 02 00       	mov    0x258c4,%eax
    5b2b:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5b31:	52                   	push   %edx
    5b32:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5b38:	52                   	push   %edx
    5b39:	50                   	push   %eax
    5b3a:	68 9c 51 02 00       	push   $0x2519c
    5b3f:	e8 88 1c 00 00       	call   77cc <read24BitmapFile>
    5b44:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(pen_filename, pen_icon, &h, &w);
    5b47:	a1 48 58 02 00       	mov    0x25848,%eax
    5b4c:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5b52:	52                   	push   %edx
    5b53:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5b59:	52                   	push   %edx
    5b5a:	50                   	push   %eax
    5b5b:	68 a8 51 02 00       	push   $0x251a8
    5b60:	e8 67 1c 00 00       	call   77cc <read24BitmapFile>
    5b65:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(rubber_filename, rubber_icon, &h, &w);
    5b68:	a1 cc 58 02 00       	mov    0x258cc,%eax
    5b6d:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5b73:	52                   	push   %edx
    5b74:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5b7a:	52                   	push   %edx
    5b7b:	50                   	push   %eax
    5b7c:	68 b4 51 02 00       	push   $0x251b4
    5b81:	e8 46 1c 00 00       	call   77cc <read24BitmapFile>
    5b86:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(red_filename, red_icon, &h, &w);
    5b89:	a1 70 58 02 00       	mov    0x25870,%eax
    5b8e:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5b94:	52                   	push   %edx
    5b95:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5b9b:	52                   	push   %edx
    5b9c:	50                   	push   %eax
    5b9d:	68 c4 51 02 00       	push   $0x251c4
    5ba2:	e8 25 1c 00 00       	call   77cc <read24BitmapFile>
    5ba7:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(green_filename, green_icon, &h, &w);
    5baa:	a1 d8 58 02 00       	mov    0x258d8,%eax
    5baf:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5bb5:	52                   	push   %edx
    5bb6:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5bbc:	52                   	push   %edx
    5bbd:	50                   	push   %eax
    5bbe:	68 d8 51 02 00       	push   $0x251d8
    5bc3:	e8 04 1c 00 00       	call   77cc <read24BitmapFile>
    5bc8:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(blue_filename, blue_icon, &h, &w);
    5bcb:	a1 60 58 02 00       	mov    0x25860,%eax
    5bd0:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5bd6:	52                   	push   %edx
    5bd7:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5bdd:	52                   	push   %edx
    5bde:	50                   	push   %eax
    5bdf:	68 e8 51 02 00       	push   $0x251e8
    5be4:	e8 e3 1b 00 00       	call   77cc <read24BitmapFile>
    5be9:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(purple_filename, purple_icon, &h, &w);
    5bec:	a1 c8 58 02 00       	mov    0x258c8,%eax
    5bf1:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5bf7:	52                   	push   %edx
    5bf8:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5bfe:	52                   	push   %edx
    5bff:	50                   	push   %eax
    5c00:	68 f4 51 02 00       	push   $0x251f4
    5c05:	e8 c2 1b 00 00       	call   77cc <read24BitmapFile>
    5c0a:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(zoomin_filename, zoomin_icon, &h, &w);
    5c0d:	a1 28 58 02 00       	mov    0x25828,%eax
    5c12:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5c18:	52                   	push   %edx
    5c19:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5c1f:	52                   	push   %edx
    5c20:	50                   	push   %eax
    5c21:	68 44 52 02 00       	push   $0x25244
    5c26:	e8 a1 1b 00 00       	call   77cc <read24BitmapFile>
    5c2b:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(zoomout_filename, zoomout_icon, &h, &w);
    5c2e:	a1 ec 58 02 00       	mov    0x258ec,%eax
    5c33:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5c39:	52                   	push   %edx
    5c3a:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5c40:	52                   	push   %edx
    5c41:	50                   	push   %eax
    5c42:	68 54 52 02 00       	push   $0x25254
    5c47:	e8 80 1b 00 00       	call   77cc <read24BitmapFile>
    5c4c:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(rotate_left_90_filename, rotate_left_90_icon, &h, &w);
    5c4f:	a1 f8 58 02 00       	mov    0x258f8,%eax
    5c54:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5c5a:	52                   	push   %edx
    5c5b:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5c61:	52                   	push   %edx
    5c62:	50                   	push   %eax
    5c63:	68 04 52 02 00       	push   $0x25204
    5c68:	e8 5f 1b 00 00       	call   77cc <read24BitmapFile>
    5c6d:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(rotate_left_30_filename, rotate_left_30_icon, &h, &w);
    5c70:	a1 10 58 02 00       	mov    0x25810,%eax
    5c75:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5c7b:	52                   	push   %edx
    5c7c:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5c82:	52                   	push   %edx
    5c83:	50                   	push   %eax
    5c84:	68 14 52 02 00       	push   $0x25214
    5c89:	e8 3e 1b 00 00       	call   77cc <read24BitmapFile>
    5c8e:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(rotate_right_30_filename, rotate_right_30_icon, &h, &w);
    5c91:	a1 64 58 02 00       	mov    0x25864,%eax
    5c96:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5c9c:	52                   	push   %edx
    5c9d:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5ca3:	52                   	push   %edx
    5ca4:	50                   	push   %eax
    5ca5:	68 24 52 02 00       	push   $0x25224
    5caa:	e8 1d 1b 00 00       	call   77cc <read24BitmapFile>
    5caf:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(rotate_right_90_filename, rotate_right_90_icon, &h, &w);
    5cb2:	a1 30 58 02 00       	mov    0x25830,%eax
    5cb7:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5cbd:	52                   	push   %edx
    5cbe:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5cc4:	52                   	push   %edx
    5cc5:	50                   	push   %eax
    5cc6:	68 34 52 02 00       	push   $0x25234
    5ccb:	e8 fc 1a 00 00       	call   77cc <read24BitmapFile>
    5cd0:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(image_list_down_filename, image_list_down_icon, &h, &w);
    5cd3:	a1 14 58 02 00       	mov    0x25814,%eax
    5cd8:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5cde:	52                   	push   %edx
    5cdf:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5ce5:	52                   	push   %edx
    5ce6:	50                   	push   %eax
    5ce7:	68 70 52 02 00       	push   $0x25270
    5cec:	e8 db 1a 00 00       	call   77cc <read24BitmapFile>
    5cf1:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(image_list_up_filename, image_list_up_icon, &h, &w);
    5cf4:	a1 6c 58 02 00       	mov    0x2586c,%eax
    5cf9:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5cff:	52                   	push   %edx
    5d00:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5d06:	52                   	push   %edx
    5d07:	50                   	push   %eax
    5d08:	68 64 52 02 00       	push   $0x25264
    5d0d:	e8 ba 1a 00 00       	call   77cc <read24BitmapFile>
    5d12:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(bmp_filename, bmp_icon, &h, &w);
    5d15:	a1 00 58 02 00       	mov    0x25800,%eax
    5d1a:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5d20:	52                   	push   %edx
    5d21:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5d27:	52                   	push   %edx
    5d28:	50                   	push   %eax
    5d29:	68 7c 52 02 00       	push   $0x2527c
    5d2e:	e8 99 1a 00 00       	call   77cc <read24BitmapFile>
    5d33:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(rollover_filename, rollover_icon, &h, &w);
    5d36:	a1 18 58 02 00       	mov    0x25818,%eax
    5d3b:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5d41:	52                   	push   %edx
    5d42:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5d48:	52                   	push   %edx
    5d49:	50                   	push   %eax
    5d4a:	68 88 52 02 00       	push   $0x25288
    5d4f:	e8 78 1a 00 00       	call   77cc <read24BitmapFile>
    5d54:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(turnaround_filename, turnaround_icon, &h, &w);
    5d57:	a1 0c 58 02 00       	mov    0x2580c,%eax
    5d5c:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5d62:	52                   	push   %edx
    5d63:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5d69:	52                   	push   %edx
    5d6a:	50                   	push   %eax
    5d6b:	68 9c 52 02 00       	push   $0x2529c
    5d70:	e8 57 1a 00 00       	call   77cc <read24BitmapFile>
    5d75:	83 c4 10             	add    $0x10,%esp
    read24BitmapFile(cut_confirm_filename, cut_confirm_icon, &h, &w);
    5d78:	a1 34 58 02 00       	mov    0x25834,%eax
    5d7d:	8d 95 a4 fe ff ff    	lea    -0x15c(%ebp),%edx
    5d83:	52                   	push   %edx
    5d84:	8d 95 a8 fe ff ff    	lea    -0x158(%ebp),%edx
    5d8a:	52                   	push   %edx
    5d8b:	50                   	push   %eax
    5d8c:	68 b0 52 02 00       	push   $0x252b0
    5d91:	e8 36 1a 00 00       	call   77cc <read24BitmapFile>
    5d96:	83 c4 10             	add    $0x10,%esp
    
    // memset(wnd.content, pra * 50, wnd.size.w * wnd.size.h * 3);

    api_drawImgButton(&wnd, save_icon, (Point){0, 0}, (Size){30, 30}, border1, borderColor, normal_shift);
    5d99:	a1 b8 57 02 00       	mov    0x257b8,%eax
    5d9e:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    5da4:	c7 85 ac fe ff ff 1e 	movl   $0x1e,-0x154(%ebp)
    5dab:	00 00 00 
    5dae:	c7 85 b0 fe ff ff 1e 	movl   $0x1e,-0x150(%ebp)
    5db5:	00 00 00 
    5db8:	c7 85 b4 fe ff ff 00 	movl   $0x0,-0x14c(%ebp)
    5dbf:	00 00 00 
    5dc2:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
    5dc9:	00 00 00 
    5dcc:	8b 15 38 58 02 00    	mov    0x25838,%edx
    5dd2:	83 ec 0c             	sub    $0xc,%esp
    5dd5:	50                   	push   %eax
    5dd6:	83 ec 04             	sub    $0x4,%esp
    5dd9:	89 e0                	mov    %esp,%eax
    5ddb:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    5de2:	66 89 18             	mov    %bx,(%eax)
    5de5:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    5dec:	88 58 02             	mov    %bl,0x2(%eax)
    5def:	51                   	push   %ecx
    5df0:	ff b5 b0 fe ff ff    	pushl  -0x150(%ebp)
    5df6:	ff b5 ac fe ff ff    	pushl  -0x154(%ebp)
    5dfc:	ff b5 b8 fe ff ff    	pushl  -0x148(%ebp)
    5e02:	ff b5 b4 fe ff ff    	pushl  -0x14c(%ebp)
    5e08:	52                   	push   %edx
    5e09:	68 a0 58 02 00       	push   $0x258a0
    5e0e:	e8 67 20 00 00       	call   7e7a <api_drawImgButton>
    5e13:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, delete_icon, (Point){30,0},(Size){30,30}, border1, borderColor, normal_shift);
    5e16:	a1 b8 57 02 00       	mov    0x257b8,%eax
    5e1b:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    5e21:	c7 85 bc fe ff ff 1e 	movl   $0x1e,-0x144(%ebp)
    5e28:	00 00 00 
    5e2b:	c7 85 c0 fe ff ff 1e 	movl   $0x1e,-0x140(%ebp)
    5e32:	00 00 00 
    5e35:	c7 85 c4 fe ff ff 1e 	movl   $0x1e,-0x13c(%ebp)
    5e3c:	00 00 00 
    5e3f:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
    5e46:	00 00 00 
    5e49:	8b 15 04 58 02 00    	mov    0x25804,%edx
    5e4f:	83 ec 0c             	sub    $0xc,%esp
    5e52:	50                   	push   %eax
    5e53:	83 ec 04             	sub    $0x4,%esp
    5e56:	89 e0                	mov    %esp,%eax
    5e58:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    5e5f:	66 89 18             	mov    %bx,(%eax)
    5e62:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    5e69:	88 58 02             	mov    %bl,0x2(%eax)
    5e6c:	51                   	push   %ecx
    5e6d:	ff b5 c0 fe ff ff    	pushl  -0x140(%ebp)
    5e73:	ff b5 bc fe ff ff    	pushl  -0x144(%ebp)
    5e79:	ff b5 c8 fe ff ff    	pushl  -0x138(%ebp)
    5e7f:	ff b5 c4 fe ff ff    	pushl  -0x13c(%ebp)
    5e85:	52                   	push   %edx
    5e86:	68 a0 58 02 00       	push   $0x258a0
    5e8b:	e8 ea 1f 00 00       	call   7e7a <api_drawImgButton>
    5e90:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, pen_icon, (Point){579,0}, (Size){30,30}, border1, borderColor, normal_shift);
    5e93:	a1 b8 57 02 00       	mov    0x257b8,%eax
    5e98:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    5e9e:	c7 85 cc fe ff ff 1e 	movl   $0x1e,-0x134(%ebp)
    5ea5:	00 00 00 
    5ea8:	c7 85 d0 fe ff ff 1e 	movl   $0x1e,-0x130(%ebp)
    5eaf:	00 00 00 
    5eb2:	c7 85 d4 fe ff ff 43 	movl   $0x243,-0x12c(%ebp)
    5eb9:	02 00 00 
    5ebc:	c7 85 d8 fe ff ff 00 	movl   $0x0,-0x128(%ebp)
    5ec3:	00 00 00 
    5ec6:	8b 15 48 58 02 00    	mov    0x25848,%edx
    5ecc:	83 ec 0c             	sub    $0xc,%esp
    5ecf:	50                   	push   %eax
    5ed0:	83 ec 04             	sub    $0x4,%esp
    5ed3:	89 e0                	mov    %esp,%eax
    5ed5:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    5edc:	66 89 18             	mov    %bx,(%eax)
    5edf:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    5ee6:	88 58 02             	mov    %bl,0x2(%eax)
    5ee9:	51                   	push   %ecx
    5eea:	ff b5 d0 fe ff ff    	pushl  -0x130(%ebp)
    5ef0:	ff b5 cc fe ff ff    	pushl  -0x134(%ebp)
    5ef6:	ff b5 d8 fe ff ff    	pushl  -0x128(%ebp)
    5efc:	ff b5 d4 fe ff ff    	pushl  -0x12c(%ebp)
    5f02:	52                   	push   %edx
    5f03:	68 a0 58 02 00       	push   $0x258a0
    5f08:	e8 6d 1f 00 00       	call   7e7a <api_drawImgButton>
    5f0d:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, rubber_icon, (Point){610,0}, (Size){30,30}, border1, borderColor, normal_shift);
    5f10:	a1 b8 57 02 00       	mov    0x257b8,%eax
    5f15:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    5f1b:	c7 85 dc fe ff ff 1e 	movl   $0x1e,-0x124(%ebp)
    5f22:	00 00 00 
    5f25:	c7 85 e0 fe ff ff 1e 	movl   $0x1e,-0x120(%ebp)
    5f2c:	00 00 00 
    5f2f:	c7 85 e4 fe ff ff 62 	movl   $0x262,-0x11c(%ebp)
    5f36:	02 00 00 
    5f39:	c7 85 e8 fe ff ff 00 	movl   $0x0,-0x118(%ebp)
    5f40:	00 00 00 
    5f43:	8b 15 cc 58 02 00    	mov    0x258cc,%edx
    5f49:	83 ec 0c             	sub    $0xc,%esp
    5f4c:	50                   	push   %eax
    5f4d:	83 ec 04             	sub    $0x4,%esp
    5f50:	89 e0                	mov    %esp,%eax
    5f52:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    5f59:	66 89 18             	mov    %bx,(%eax)
    5f5c:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    5f63:	88 58 02             	mov    %bl,0x2(%eax)
    5f66:	51                   	push   %ecx
    5f67:	ff b5 e0 fe ff ff    	pushl  -0x120(%ebp)
    5f6d:	ff b5 dc fe ff ff    	pushl  -0x124(%ebp)
    5f73:	ff b5 e8 fe ff ff    	pushl  -0x118(%ebp)
    5f79:	ff b5 e4 fe ff ff    	pushl  -0x11c(%ebp)
    5f7f:	52                   	push   %edx
    5f80:	68 a0 58 02 00       	push   $0x258a0
    5f85:	e8 f0 1e 00 00       	call   7e7a <api_drawImgButton>
    5f8a:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, red_icon, (Point){555,5}, (Size){20,20}, border1, borderColor, normal_shift);
    5f8d:	a1 b8 57 02 00       	mov    0x257b8,%eax
    5f92:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    5f98:	c7 85 ec fe ff ff 14 	movl   $0x14,-0x114(%ebp)
    5f9f:	00 00 00 
    5fa2:	c7 85 f0 fe ff ff 14 	movl   $0x14,-0x110(%ebp)
    5fa9:	00 00 00 
    5fac:	c7 85 f4 fe ff ff 2b 	movl   $0x22b,-0x10c(%ebp)
    5fb3:	02 00 00 
    5fb6:	c7 85 f8 fe ff ff 05 	movl   $0x5,-0x108(%ebp)
    5fbd:	00 00 00 
    5fc0:	8b 15 70 58 02 00    	mov    0x25870,%edx
    5fc6:	83 ec 0c             	sub    $0xc,%esp
    5fc9:	50                   	push   %eax
    5fca:	83 ec 04             	sub    $0x4,%esp
    5fcd:	89 e0                	mov    %esp,%eax
    5fcf:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    5fd6:	66 89 18             	mov    %bx,(%eax)
    5fd9:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    5fe0:	88 58 02             	mov    %bl,0x2(%eax)
    5fe3:	51                   	push   %ecx
    5fe4:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
    5fea:	ff b5 ec fe ff ff    	pushl  -0x114(%ebp)
    5ff0:	ff b5 f8 fe ff ff    	pushl  -0x108(%ebp)
    5ff6:	ff b5 f4 fe ff ff    	pushl  -0x10c(%ebp)
    5ffc:	52                   	push   %edx
    5ffd:	68 a0 58 02 00       	push   $0x258a0
    6002:	e8 73 1e 00 00       	call   7e7a <api_drawImgButton>
    6007:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, green_icon, (Point){525,5}, (Size){20,20}, border1, borderColor, normal_shift);
    600a:	a1 b8 57 02 00       	mov    0x257b8,%eax
    600f:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    6015:	c7 85 fc fe ff ff 14 	movl   $0x14,-0x104(%ebp)
    601c:	00 00 00 
    601f:	c7 85 00 ff ff ff 14 	movl   $0x14,-0x100(%ebp)
    6026:	00 00 00 
    6029:	c7 85 04 ff ff ff 0d 	movl   $0x20d,-0xfc(%ebp)
    6030:	02 00 00 
    6033:	c7 85 08 ff ff ff 05 	movl   $0x5,-0xf8(%ebp)
    603a:	00 00 00 
    603d:	8b 15 d8 58 02 00    	mov    0x258d8,%edx
    6043:	83 ec 0c             	sub    $0xc,%esp
    6046:	50                   	push   %eax
    6047:	83 ec 04             	sub    $0x4,%esp
    604a:	89 e0                	mov    %esp,%eax
    604c:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    6053:	66 89 18             	mov    %bx,(%eax)
    6056:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    605d:	88 58 02             	mov    %bl,0x2(%eax)
    6060:	51                   	push   %ecx
    6061:	ff b5 00 ff ff ff    	pushl  -0x100(%ebp)
    6067:	ff b5 fc fe ff ff    	pushl  -0x104(%ebp)
    606d:	ff b5 08 ff ff ff    	pushl  -0xf8(%ebp)
    6073:	ff b5 04 ff ff ff    	pushl  -0xfc(%ebp)
    6079:	52                   	push   %edx
    607a:	68 a0 58 02 00       	push   $0x258a0
    607f:	e8 f6 1d 00 00       	call   7e7a <api_drawImgButton>
    6084:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, blue_icon, (Point){495,5}, (Size){20,20}, border1, borderColor, normal_shift);
    6087:	a1 b8 57 02 00       	mov    0x257b8,%eax
    608c:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    6092:	c7 85 0c ff ff ff 14 	movl   $0x14,-0xf4(%ebp)
    6099:	00 00 00 
    609c:	c7 85 10 ff ff ff 14 	movl   $0x14,-0xf0(%ebp)
    60a3:	00 00 00 
    60a6:	c7 85 14 ff ff ff ef 	movl   $0x1ef,-0xec(%ebp)
    60ad:	01 00 00 
    60b0:	c7 85 18 ff ff ff 05 	movl   $0x5,-0xe8(%ebp)
    60b7:	00 00 00 
    60ba:	8b 15 60 58 02 00    	mov    0x25860,%edx
    60c0:	83 ec 0c             	sub    $0xc,%esp
    60c3:	50                   	push   %eax
    60c4:	83 ec 04             	sub    $0x4,%esp
    60c7:	89 e0                	mov    %esp,%eax
    60c9:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    60d0:	66 89 18             	mov    %bx,(%eax)
    60d3:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    60da:	88 58 02             	mov    %bl,0x2(%eax)
    60dd:	51                   	push   %ecx
    60de:	ff b5 10 ff ff ff    	pushl  -0xf0(%ebp)
    60e4:	ff b5 0c ff ff ff    	pushl  -0xf4(%ebp)
    60ea:	ff b5 18 ff ff ff    	pushl  -0xe8(%ebp)
    60f0:	ff b5 14 ff ff ff    	pushl  -0xec(%ebp)
    60f6:	52                   	push   %edx
    60f7:	68 a0 58 02 00       	push   $0x258a0
    60fc:	e8 79 1d 00 00       	call   7e7a <api_drawImgButton>
    6101:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, purple_icon, (Point){465,5}, (Size){20,20}, border1, borderColor, normal_shift);
    6104:	a1 b8 57 02 00       	mov    0x257b8,%eax
    6109:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    610f:	c7 85 1c ff ff ff 14 	movl   $0x14,-0xe4(%ebp)
    6116:	00 00 00 
    6119:	c7 85 20 ff ff ff 14 	movl   $0x14,-0xe0(%ebp)
    6120:	00 00 00 
    6123:	c7 85 24 ff ff ff d1 	movl   $0x1d1,-0xdc(%ebp)
    612a:	01 00 00 
    612d:	c7 85 28 ff ff ff 05 	movl   $0x5,-0xd8(%ebp)
    6134:	00 00 00 
    6137:	8b 15 c8 58 02 00    	mov    0x258c8,%edx
    613d:	83 ec 0c             	sub    $0xc,%esp
    6140:	50                   	push   %eax
    6141:	83 ec 04             	sub    $0x4,%esp
    6144:	89 e0                	mov    %esp,%eax
    6146:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    614d:	66 89 18             	mov    %bx,(%eax)
    6150:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    6157:	88 58 02             	mov    %bl,0x2(%eax)
    615a:	51                   	push   %ecx
    615b:	ff b5 20 ff ff ff    	pushl  -0xe0(%ebp)
    6161:	ff b5 1c ff ff ff    	pushl  -0xe4(%ebp)
    6167:	ff b5 28 ff ff ff    	pushl  -0xd8(%ebp)
    616d:	ff b5 24 ff ff ff    	pushl  -0xdc(%ebp)
    6173:	52                   	push   %edx
    6174:	68 a0 58 02 00       	push   $0x258a0
    6179:	e8 fc 1c 00 00       	call   7e7a <api_drawImgButton>
    617e:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, cut_icon, (Point){60,0}, (Size){30,30}, border1, borderColor, normal_shift);
    6181:	a1 b8 57 02 00       	mov    0x257b8,%eax
    6186:	8b 0d 34 53 02 00    	mov    0x25334,%ecx
    618c:	c7 85 2c ff ff ff 1e 	movl   $0x1e,-0xd4(%ebp)
    6193:	00 00 00 
    6196:	c7 85 30 ff ff ff 1e 	movl   $0x1e,-0xd0(%ebp)
    619d:	00 00 00 
    61a0:	c7 85 34 ff ff ff 3c 	movl   $0x3c,-0xcc(%ebp)
    61a7:	00 00 00 
    61aa:	c7 85 38 ff ff ff 00 	movl   $0x0,-0xc8(%ebp)
    61b1:	00 00 00 
    61b4:	8b 15 c4 58 02 00    	mov    0x258c4,%edx
    61ba:	83 ec 0c             	sub    $0xc,%esp
    61bd:	50                   	push   %eax
    61be:	83 ec 04             	sub    $0x4,%esp
    61c1:	89 e0                	mov    %esp,%eax
    61c3:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    61ca:	66 89 18             	mov    %bx,(%eax)
    61cd:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    61d4:	88 58 02             	mov    %bl,0x2(%eax)
    61d7:	51                   	push   %ecx
    61d8:	ff b5 30 ff ff ff    	pushl  -0xd0(%ebp)
    61de:	ff b5 2c ff ff ff    	pushl  -0xd4(%ebp)
    61e4:	ff b5 38 ff ff ff    	pushl  -0xc8(%ebp)
    61ea:	ff b5 34 ff ff ff    	pushl  -0xcc(%ebp)
    61f0:	52                   	push   %edx
    61f1:	68 a0 58 02 00       	push   $0x258a0
    61f6:	e8 7f 1c 00 00       	call   7e7a <api_drawImgButton>
    61fb:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, zoomin_icon, (Point){140, 440}, (Size){60, 60}, border2, borderColor, normal_shift);
    61fe:	a1 b8 57 02 00       	mov    0x257b8,%eax
    6203:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    6209:	c7 85 3c ff ff ff 3c 	movl   $0x3c,-0xc4(%ebp)
    6210:	00 00 00 
    6213:	c7 85 40 ff ff ff 3c 	movl   $0x3c,-0xc0(%ebp)
    621a:	00 00 00 
    621d:	c7 85 44 ff ff ff 8c 	movl   $0x8c,-0xbc(%ebp)
    6224:	00 00 00 
    6227:	c7 85 48 ff ff ff b8 	movl   $0x1b8,-0xb8(%ebp)
    622e:	01 00 00 
    6231:	8b 15 28 58 02 00    	mov    0x25828,%edx
    6237:	83 ec 0c             	sub    $0xc,%esp
    623a:	50                   	push   %eax
    623b:	83 ec 04             	sub    $0x4,%esp
    623e:	89 e0                	mov    %esp,%eax
    6240:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    6247:	66 89 18             	mov    %bx,(%eax)
    624a:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    6251:	88 58 02             	mov    %bl,0x2(%eax)
    6254:	51                   	push   %ecx
    6255:	ff b5 40 ff ff ff    	pushl  -0xc0(%ebp)
    625b:	ff b5 3c ff ff ff    	pushl  -0xc4(%ebp)
    6261:	ff b5 48 ff ff ff    	pushl  -0xb8(%ebp)
    6267:	ff b5 44 ff ff ff    	pushl  -0xbc(%ebp)
    626d:	52                   	push   %edx
    626e:	68 a0 58 02 00       	push   $0x258a0
    6273:	e8 02 1c 00 00       	call   7e7a <api_drawImgButton>
    6278:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, zoomout_icon, (Point){200,440}, (Size){60,60}, border2, borderColor, normal_shift);
    627b:	a1 b8 57 02 00       	mov    0x257b8,%eax
    6280:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    6286:	c7 85 4c ff ff ff 3c 	movl   $0x3c,-0xb4(%ebp)
    628d:	00 00 00 
    6290:	c7 85 50 ff ff ff 3c 	movl   $0x3c,-0xb0(%ebp)
    6297:	00 00 00 
    629a:	c7 85 54 ff ff ff c8 	movl   $0xc8,-0xac(%ebp)
    62a1:	00 00 00 
    62a4:	c7 85 58 ff ff ff b8 	movl   $0x1b8,-0xa8(%ebp)
    62ab:	01 00 00 
    62ae:	8b 15 ec 58 02 00    	mov    0x258ec,%edx
    62b4:	83 ec 0c             	sub    $0xc,%esp
    62b7:	50                   	push   %eax
    62b8:	83 ec 04             	sub    $0x4,%esp
    62bb:	89 e0                	mov    %esp,%eax
    62bd:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    62c4:	66 89 18             	mov    %bx,(%eax)
    62c7:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    62ce:	88 58 02             	mov    %bl,0x2(%eax)
    62d1:	51                   	push   %ecx
    62d2:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
    62d8:	ff b5 4c ff ff ff    	pushl  -0xb4(%ebp)
    62de:	ff b5 58 ff ff ff    	pushl  -0xa8(%ebp)
    62e4:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
    62ea:	52                   	push   %edx
    62eb:	68 a0 58 02 00       	push   $0x258a0
    62f0:	e8 85 1b 00 00       	call   7e7a <api_drawImgButton>
    62f5:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, rotate_left_90_icon, (Point){260,440}, (Size){60,63}, border2, borderColor, normal_shift);
    62f8:	a1 b8 57 02 00       	mov    0x257b8,%eax
    62fd:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    6303:	c7 85 5c ff ff ff 3c 	movl   $0x3c,-0xa4(%ebp)
    630a:	00 00 00 
    630d:	c7 85 60 ff ff ff 3f 	movl   $0x3f,-0xa0(%ebp)
    6314:	00 00 00 
    6317:	c7 85 64 ff ff ff 04 	movl   $0x104,-0x9c(%ebp)
    631e:	01 00 00 
    6321:	c7 85 68 ff ff ff b8 	movl   $0x1b8,-0x98(%ebp)
    6328:	01 00 00 
    632b:	8b 15 f8 58 02 00    	mov    0x258f8,%edx
    6331:	83 ec 0c             	sub    $0xc,%esp
    6334:	50                   	push   %eax
    6335:	83 ec 04             	sub    $0x4,%esp
    6338:	89 e0                	mov    %esp,%eax
    633a:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    6341:	66 89 18             	mov    %bx,(%eax)
    6344:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    634b:	88 58 02             	mov    %bl,0x2(%eax)
    634e:	51                   	push   %ecx
    634f:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
    6355:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
    635b:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
    6361:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
    6367:	52                   	push   %edx
    6368:	68 a0 58 02 00       	push   $0x258a0
    636d:	e8 08 1b 00 00       	call   7e7a <api_drawImgButton>
    6372:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, rotate_left_30_icon, (Point){325,440}, (Size){60,65}, border2, borderColor, normal_shift);
    6375:	a1 b8 57 02 00       	mov    0x257b8,%eax
    637a:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    6380:	c7 85 6c ff ff ff 3c 	movl   $0x3c,-0x94(%ebp)
    6387:	00 00 00 
    638a:	c7 85 70 ff ff ff 41 	movl   $0x41,-0x90(%ebp)
    6391:	00 00 00 
    6394:	c7 85 74 ff ff ff 45 	movl   $0x145,-0x8c(%ebp)
    639b:	01 00 00 
    639e:	c7 85 78 ff ff ff b8 	movl   $0x1b8,-0x88(%ebp)
    63a5:	01 00 00 
    63a8:	8b 15 10 58 02 00    	mov    0x25810,%edx
    63ae:	83 ec 0c             	sub    $0xc,%esp
    63b1:	50                   	push   %eax
    63b2:	83 ec 04             	sub    $0x4,%esp
    63b5:	89 e0                	mov    %esp,%eax
    63b7:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    63be:	66 89 18             	mov    %bx,(%eax)
    63c1:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    63c8:	88 58 02             	mov    %bl,0x2(%eax)
    63cb:	51                   	push   %ecx
    63cc:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
    63d2:	ff b5 6c ff ff ff    	pushl  -0x94(%ebp)
    63d8:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
    63de:	ff b5 74 ff ff ff    	pushl  -0x8c(%ebp)
    63e4:	52                   	push   %edx
    63e5:	68 a0 58 02 00       	push   $0x258a0
    63ea:	e8 8b 1a 00 00       	call   7e7a <api_drawImgButton>
    63ef:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, rotate_right_30_icon, (Point){390,440}, (Size){60,65}, border2, borderColor, normal_shift);
    63f2:	a1 b8 57 02 00       	mov    0x257b8,%eax
    63f7:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    63fd:	c7 85 7c ff ff ff 3c 	movl   $0x3c,-0x84(%ebp)
    6404:	00 00 00 
    6407:	c7 45 80 41 00 00 00 	movl   $0x41,-0x80(%ebp)
    640e:	c7 45 84 86 01 00 00 	movl   $0x186,-0x7c(%ebp)
    6415:	c7 45 88 b8 01 00 00 	movl   $0x1b8,-0x78(%ebp)
    641c:	8b 15 64 58 02 00    	mov    0x25864,%edx
    6422:	83 ec 0c             	sub    $0xc,%esp
    6425:	50                   	push   %eax
    6426:	83 ec 04             	sub    $0x4,%esp
    6429:	89 e0                	mov    %esp,%eax
    642b:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    6432:	66 89 18             	mov    %bx,(%eax)
    6435:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    643c:	88 58 02             	mov    %bl,0x2(%eax)
    643f:	51                   	push   %ecx
    6440:	ff 75 80             	pushl  -0x80(%ebp)
    6443:	ff b5 7c ff ff ff    	pushl  -0x84(%ebp)
    6449:	ff 75 88             	pushl  -0x78(%ebp)
    644c:	ff 75 84             	pushl  -0x7c(%ebp)
    644f:	52                   	push   %edx
    6450:	68 a0 58 02 00       	push   $0x258a0
    6455:	e8 20 1a 00 00       	call   7e7a <api_drawImgButton>
    645a:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, rotate_right_90_icon, (Point){455,440}, (Size){60,65}, border2, borderColor, normal_shift);
    645d:	a1 b8 57 02 00       	mov    0x257b8,%eax
    6462:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    6468:	c7 45 8c 3c 00 00 00 	movl   $0x3c,-0x74(%ebp)
    646f:	c7 45 90 41 00 00 00 	movl   $0x41,-0x70(%ebp)
    6476:	c7 45 94 c7 01 00 00 	movl   $0x1c7,-0x6c(%ebp)
    647d:	c7 45 98 b8 01 00 00 	movl   $0x1b8,-0x68(%ebp)
    6484:	8b 15 30 58 02 00    	mov    0x25830,%edx
    648a:	83 ec 0c             	sub    $0xc,%esp
    648d:	50                   	push   %eax
    648e:	83 ec 04             	sub    $0x4,%esp
    6491:	89 e0                	mov    %esp,%eax
    6493:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    649a:	66 89 18             	mov    %bx,(%eax)
    649d:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    64a4:	88 58 02             	mov    %bl,0x2(%eax)
    64a7:	51                   	push   %ecx
    64a8:	ff 75 90             	pushl  -0x70(%ebp)
    64ab:	ff 75 8c             	pushl  -0x74(%ebp)
    64ae:	ff 75 98             	pushl  -0x68(%ebp)
    64b1:	ff 75 94             	pushl  -0x6c(%ebp)
    64b4:	52                   	push   %edx
    64b5:	68 a0 58 02 00       	push   $0x258a0
    64ba:	e8 bb 19 00 00       	call   7e7a <api_drawImgButton>
    64bf:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, rollover_icon, (Point){520,440}, (Size){60,60}, border2, borderColor, normal_shift);
    64c2:	a1 b8 57 02 00       	mov    0x257b8,%eax
    64c7:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    64cd:	c7 45 9c 3c 00 00 00 	movl   $0x3c,-0x64(%ebp)
    64d4:	c7 45 a0 3c 00 00 00 	movl   $0x3c,-0x60(%ebp)
    64db:	c7 45 a4 08 02 00 00 	movl   $0x208,-0x5c(%ebp)
    64e2:	c7 45 a8 b8 01 00 00 	movl   $0x1b8,-0x58(%ebp)
    64e9:	8b 15 18 58 02 00    	mov    0x25818,%edx
    64ef:	83 ec 0c             	sub    $0xc,%esp
    64f2:	50                   	push   %eax
    64f3:	83 ec 04             	sub    $0x4,%esp
    64f6:	89 e0                	mov    %esp,%eax
    64f8:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    64ff:	66 89 18             	mov    %bx,(%eax)
    6502:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    6509:	88 58 02             	mov    %bl,0x2(%eax)
    650c:	51                   	push   %ecx
    650d:	ff 75 a0             	pushl  -0x60(%ebp)
    6510:	ff 75 9c             	pushl  -0x64(%ebp)
    6513:	ff 75 a8             	pushl  -0x58(%ebp)
    6516:	ff 75 a4             	pushl  -0x5c(%ebp)
    6519:	52                   	push   %edx
    651a:	68 a0 58 02 00       	push   $0x258a0
    651f:	e8 56 19 00 00       	call   7e7a <api_drawImgButton>
    6524:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, turnaround_icon, (Point){580,440}, (Size){60,60}, border2, borderColor, normal_shift);
    6527:	a1 b8 57 02 00       	mov    0x257b8,%eax
    652c:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    6532:	c7 45 ac 3c 00 00 00 	movl   $0x3c,-0x54(%ebp)
    6539:	c7 45 b0 3c 00 00 00 	movl   $0x3c,-0x50(%ebp)
    6540:	c7 45 b4 44 02 00 00 	movl   $0x244,-0x4c(%ebp)
    6547:	c7 45 b8 b8 01 00 00 	movl   $0x1b8,-0x48(%ebp)
    654e:	8b 15 0c 58 02 00    	mov    0x2580c,%edx
    6554:	83 ec 0c             	sub    $0xc,%esp
    6557:	50                   	push   %eax
    6558:	83 ec 04             	sub    $0x4,%esp
    655b:	89 e0                	mov    %esp,%eax
    655d:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    6564:	66 89 18             	mov    %bx,(%eax)
    6567:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    656e:	88 58 02             	mov    %bl,0x2(%eax)
    6571:	51                   	push   %ecx
    6572:	ff 75 b0             	pushl  -0x50(%ebp)
    6575:	ff 75 ac             	pushl  -0x54(%ebp)
    6578:	ff 75 b8             	pushl  -0x48(%ebp)
    657b:	ff 75 b4             	pushl  -0x4c(%ebp)
    657e:	52                   	push   %edx
    657f:	68 a0 58 02 00       	push   $0x258a0
    6584:	e8 f1 18 00 00       	call   7e7a <api_drawImgButton>
    6589:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, image_list_up_icon, (Point){47,45}, (Size){20,35}, border2, borderColor, normal_shift);
    658c:	a1 b8 57 02 00       	mov    0x257b8,%eax
    6591:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    6597:	c7 45 bc 14 00 00 00 	movl   $0x14,-0x44(%ebp)
    659e:	c7 45 c0 23 00 00 00 	movl   $0x23,-0x40(%ebp)
    65a5:	c7 45 c4 2f 00 00 00 	movl   $0x2f,-0x3c(%ebp)
    65ac:	c7 45 c8 2d 00 00 00 	movl   $0x2d,-0x38(%ebp)
    65b3:	8b 15 6c 58 02 00    	mov    0x2586c,%edx
    65b9:	83 ec 0c             	sub    $0xc,%esp
    65bc:	50                   	push   %eax
    65bd:	83 ec 04             	sub    $0x4,%esp
    65c0:	89 e0                	mov    %esp,%eax
    65c2:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    65c9:	66 89 18             	mov    %bx,(%eax)
    65cc:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    65d3:	88 58 02             	mov    %bl,0x2(%eax)
    65d6:	51                   	push   %ecx
    65d7:	ff 75 c0             	pushl  -0x40(%ebp)
    65da:	ff 75 bc             	pushl  -0x44(%ebp)
    65dd:	ff 75 c8             	pushl  -0x38(%ebp)
    65e0:	ff 75 c4             	pushl  -0x3c(%ebp)
    65e3:	52                   	push   %edx
    65e4:	68 a0 58 02 00       	push   $0x258a0
    65e9:	e8 8c 18 00 00       	call   7e7a <api_drawImgButton>
    65ee:	83 c4 30             	add    $0x30,%esp
    api_drawImgButton(&wnd, image_list_down_icon, (Point){47,465}, (Size){20,35}, border2, borderColor, normal_shift);
    65f1:	a1 b8 57 02 00       	mov    0x257b8,%eax
    65f6:	8b 0d 38 53 02 00    	mov    0x25338,%ecx
    65fc:	c7 45 cc 14 00 00 00 	movl   $0x14,-0x34(%ebp)
    6603:	c7 45 d0 23 00 00 00 	movl   $0x23,-0x30(%ebp)
    660a:	c7 45 d4 2f 00 00 00 	movl   $0x2f,-0x2c(%ebp)
    6611:	c7 45 d8 d1 01 00 00 	movl   $0x1d1,-0x28(%ebp)
    6618:	8b 15 14 58 02 00    	mov    0x25814,%edx
    661e:	83 ec 0c             	sub    $0xc,%esp
    6621:	50                   	push   %eax
    6622:	83 ec 04             	sub    $0x4,%esp
    6625:	89 e0                	mov    %esp,%eax
    6627:	0f b7 1d b4 57 02 00 	movzwl 0x257b4,%ebx
    662e:	66 89 18             	mov    %bx,(%eax)
    6631:	0f b6 1d b6 57 02 00 	movzbl 0x257b6,%ebx
    6638:	88 58 02             	mov    %bl,0x2(%eax)
    663b:	51                   	push   %ecx
    663c:	ff 75 d0             	pushl  -0x30(%ebp)
    663f:	ff 75 cc             	pushl  -0x34(%ebp)
    6642:	ff 75 d8             	pushl  -0x28(%ebp)
    6645:	ff 75 d4             	pushl  -0x2c(%ebp)
    6648:	52                   	push   %edx
    6649:	68 a0 58 02 00       	push   $0x258a0
    664e:	e8 27 18 00 00       	call   7e7a <api_drawImgButton>
    6653:	83 c4 30             	add    $0x30,%esp

    struct RGB *t;
    struct RGB *o;
    edit_img_origin = malloc(edit_img_size.h*edit_img_size.w*3);
    6656:	8b 15 dc 52 02 00    	mov    0x252dc,%edx
    665c:	a1 e0 52 02 00       	mov    0x252e0,%eax
    6661:	0f af d0             	imul   %eax,%edx
    6664:	89 d0                	mov    %edx,%eax
    6666:	01 c0                	add    %eax,%eax
    6668:	01 d0                	add    %edx,%eax
    666a:	83 ec 0c             	sub    $0xc,%esp
    666d:	50                   	push   %eax
    666e:	e8 4a 0a 00 00       	call   70bd <malloc>
    6673:	83 c4 10             	add    $0x10,%esp
    6676:	a3 c0 58 02 00       	mov    %eax,0x258c0
    int max_line = edit_img_size.w;
    667b:	a1 e0 52 02 00       	mov    0x252e0,%eax
    6680:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (int i = 0; i < edit_img_size.h; i++) {
    6683:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    668a:	eb 68                	jmp    66f4 <main+0xe95>
        o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
    668c:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    6692:	8b 15 e8 52 02 00    	mov    0x252e8,%edx
    6698:	8b 45 f4             	mov    -0xc(%ebp),%eax
    669b:	01 c2                	add    %eax,%edx
    669d:	a1 b0 58 02 00       	mov    0x258b0,%eax
    66a2:	0f af c2             	imul   %edx,%eax
    66a5:	89 c2                	mov    %eax,%edx
    66a7:	a1 e4 52 02 00       	mov    0x252e4,%eax
    66ac:	01 c2                	add    %eax,%edx
    66ae:	89 d0                	mov    %edx,%eax
    66b0:	01 c0                	add    %eax,%eax
    66b2:	01 d0                	add    %edx,%eax
    66b4:	01 c8                	add    %ecx,%eax
    66b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        t = edit_img_origin + i * edit_img_size.w;
    66b9:	8b 15 c0 58 02 00    	mov    0x258c0,%edx
    66bf:	a1 e0 52 02 00       	mov    0x252e0,%eax
    66c4:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    66c8:	89 c1                	mov    %eax,%ecx
    66ca:	89 c8                	mov    %ecx,%eax
    66cc:	01 c0                	add    %eax,%eax
    66ce:	01 c8                	add    %ecx,%eax
    66d0:	01 d0                	add    %edx,%eax
    66d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
        memmove(t, o, max_line * 3);
    66d5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    66d8:	89 d0                	mov    %edx,%eax
    66da:	01 c0                	add    %eax,%eax
    66dc:	01 d0                	add    %edx,%eax
    66de:	83 ec 04             	sub    $0x4,%esp
    66e1:	50                   	push   %eax
    66e2:	ff 75 e4             	pushl  -0x1c(%ebp)
    66e5:	ff 75 e0             	pushl  -0x20(%ebp)
    66e8:	e8 11 05 00 00       	call   6bfe <memmove>
    66ed:	83 c4 10             	add    $0x10,%esp

    struct RGB *t;
    struct RGB *o;
    edit_img_origin = malloc(edit_img_size.h*edit_img_size.w*3);
    int max_line = edit_img_size.w;
    for (int i = 0; i < edit_img_size.h; i++) {
    66f0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    66f4:	a1 dc 52 02 00       	mov    0x252dc,%eax
    66f9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    66fc:	7f 8e                	jg     668c <main+0xe2d>
        o = wnd.content + (edit_img_pos.y + i) * wnd.size.w + edit_img_pos.x;
        t = edit_img_origin + i * edit_img_size.w;
        memmove(t, o, max_line * 3);
    }

    image_list_origin = malloc(image_list_size.h*image_list_size.w*3);
    66fe:	8b 15 ec 52 02 00    	mov    0x252ec,%edx
    6704:	a1 f0 52 02 00       	mov    0x252f0,%eax
    6709:	0f af d0             	imul   %eax,%edx
    670c:	89 d0                	mov    %edx,%eax
    670e:	01 c0                	add    %eax,%eax
    6710:	01 d0                	add    %edx,%eax
    6712:	83 ec 0c             	sub    $0xc,%esp
    6715:	50                   	push   %eax
    6716:	e8 a2 09 00 00       	call   70bd <malloc>
    671b:	83 c4 10             	add    $0x10,%esp
    671e:	a3 f4 58 02 00       	mov    %eax,0x258f4
    max_line = image_list_size.w;
    6723:	a1 f0 52 02 00       	mov    0x252f0,%eax
    6728:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (int i = 0; i < image_list_size.h; i++) {
    672b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6732:	eb 68                	jmp    679c <main+0xf3d>
        o = wnd.content + (image_list_pos.y + i) * wnd.size.w + image_list_pos.x;
    6734:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    673a:	8b 15 f8 52 02 00    	mov    0x252f8,%edx
    6740:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6743:	01 c2                	add    %eax,%edx
    6745:	a1 b0 58 02 00       	mov    0x258b0,%eax
    674a:	0f af c2             	imul   %edx,%eax
    674d:	89 c2                	mov    %eax,%edx
    674f:	a1 f4 52 02 00       	mov    0x252f4,%eax
    6754:	01 c2                	add    %eax,%edx
    6756:	89 d0                	mov    %edx,%eax
    6758:	01 c0                	add    %eax,%eax
    675a:	01 d0                	add    %edx,%eax
    675c:	01 c8                	add    %ecx,%eax
    675e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        t = image_list_origin + i * image_list_size.w;
    6761:	8b 15 f4 58 02 00    	mov    0x258f4,%edx
    6767:	a1 f0 52 02 00       	mov    0x252f0,%eax
    676c:	0f af 45 f0          	imul   -0x10(%ebp),%eax
    6770:	89 c1                	mov    %eax,%ecx
    6772:	89 c8                	mov    %ecx,%eax
    6774:	01 c0                	add    %eax,%eax
    6776:	01 c8                	add    %ecx,%eax
    6778:	01 d0                	add    %edx,%eax
    677a:	89 45 e0             	mov    %eax,-0x20(%ebp)
        memmove(t, o, max_line * 3);
    677d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6780:	89 d0                	mov    %edx,%eax
    6782:	01 c0                	add    %eax,%eax
    6784:	01 d0                	add    %edx,%eax
    6786:	83 ec 04             	sub    $0x4,%esp
    6789:	50                   	push   %eax
    678a:	ff 75 e4             	pushl  -0x1c(%ebp)
    678d:	ff 75 e0             	pushl  -0x20(%ebp)
    6790:	e8 69 04 00 00       	call   6bfe <memmove>
    6795:	83 c4 10             	add    $0x10,%esp
        memmove(t, o, max_line * 3);
    }

    image_list_origin = malloc(image_list_size.h*image_list_size.w*3);
    max_line = image_list_size.w;
    for (int i = 0; i < image_list_size.h; i++) {
    6798:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    679c:	a1 ec 52 02 00       	mov    0x252ec,%eax
    67a1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    67a4:	7f 8e                	jg     6734 <main+0xed5>
        o = wnd.content + (image_list_pos.y + i) * wnd.size.w + image_list_pos.x;
        t = image_list_origin + i * image_list_size.w;
        memmove(t, o, max_line * 3);
    }

    image_title_origin = malloc(image_title_size.h*image_title_size.w*3);
    67a6:	8b 15 fc 52 02 00    	mov    0x252fc,%edx
    67ac:	a1 00 53 02 00       	mov    0x25300,%eax
    67b1:	0f af d0             	imul   %eax,%edx
    67b4:	89 d0                	mov    %edx,%eax
    67b6:	01 c0                	add    %eax,%eax
    67b8:	01 d0                	add    %edx,%eax
    67ba:	83 ec 0c             	sub    $0xc,%esp
    67bd:	50                   	push   %eax
    67be:	e8 fa 08 00 00       	call   70bd <malloc>
    67c3:	83 c4 10             	add    $0x10,%esp
    67c6:	a3 fc 58 02 00       	mov    %eax,0x258fc
    max_line = image_title_size.w;
    67cb:	a1 00 53 02 00       	mov    0x25300,%eax
    67d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (int i = 0; i < image_title_size.h; i++) {
    67d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    67da:	eb 68                	jmp    6844 <main+0xfe5>
        o = wnd.content + (image_title_pos.y + i) * wnd.size.w + image_title_pos.x;
    67dc:	8b 0d b8 58 02 00    	mov    0x258b8,%ecx
    67e2:	8b 15 08 53 02 00    	mov    0x25308,%edx
    67e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    67eb:	01 c2                	add    %eax,%edx
    67ed:	a1 b0 58 02 00       	mov    0x258b0,%eax
    67f2:	0f af c2             	imul   %edx,%eax
    67f5:	89 c2                	mov    %eax,%edx
    67f7:	a1 04 53 02 00       	mov    0x25304,%eax
    67fc:	01 c2                	add    %eax,%edx
    67fe:	89 d0                	mov    %edx,%eax
    6800:	01 c0                	add    %eax,%eax
    6802:	01 d0                	add    %edx,%eax
    6804:	01 c8                	add    %ecx,%eax
    6806:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        t = image_title_origin + i * image_title_size.w;
    6809:	8b 15 fc 58 02 00    	mov    0x258fc,%edx
    680f:	a1 00 53 02 00       	mov    0x25300,%eax
    6814:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    6818:	89 c1                	mov    %eax,%ecx
    681a:	89 c8                	mov    %ecx,%eax
    681c:	01 c0                	add    %eax,%eax
    681e:	01 c8                	add    %ecx,%eax
    6820:	01 d0                	add    %edx,%eax
    6822:	89 45 e0             	mov    %eax,-0x20(%ebp)
        memmove(t, o, max_line * 3);
    6825:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6828:	89 d0                	mov    %edx,%eax
    682a:	01 c0                	add    %eax,%eax
    682c:	01 d0                	add    %edx,%eax
    682e:	83 ec 04             	sub    $0x4,%esp
    6831:	50                   	push   %eax
    6832:	ff 75 e4             	pushl  -0x1c(%ebp)
    6835:	ff 75 e0             	pushl  -0x20(%ebp)
    6838:	e8 c1 03 00 00       	call   6bfe <memmove>
    683d:	83 c4 10             	add    $0x10,%esp
        memmove(t, o, max_line * 3);
    }

    image_title_origin = malloc(image_title_size.h*image_title_size.w*3);
    max_line = image_title_size.w;
    for (int i = 0; i < image_title_size.h; i++) {
    6840:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    6844:	a1 fc 52 02 00       	mov    0x252fc,%eax
    6849:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    684c:	7f 8e                	jg     67dc <main+0xf7d>
        o = wnd.content + (image_title_pos.y + i) * wnd.size.w + image_title_pos.x;
        t = image_title_origin + i * image_title_size.w;
        memmove(t, o, max_line * 3);
    }

    image_origin=(PBitmap*)malloc(sizeof(PBitmap));
    684e:	83 ec 0c             	sub    $0xc,%esp
    6851:	6a 0c                	push   $0xc
    6853:	e8 65 08 00 00       	call   70bd <malloc>
    6858:	83 c4 10             	add    $0x10,%esp
    685b:	a3 80 58 02 00       	mov    %eax,0x25880
    image_origin_preview=(PBitmap*)malloc(sizeof(PBitmap));
    6860:	83 ec 0c             	sub    $0xc,%esp
    6863:	6a 0c                	push   $0xc
    6865:	e8 53 08 00 00       	call   70bd <malloc>
    686a:	83 c4 10             	add    $0x10,%esp
    686d:	a3 88 58 02 00       	mov    %eax,0x25888
    image_origin_mirror=(PBitmap*)malloc(sizeof(PBitmap));
    6872:	83 ec 0c             	sub    $0xc,%esp
    6875:	6a 0c                	push   $0xc
    6877:	e8 41 08 00 00       	call   70bd <malloc>
    687c:	83 c4 10             	add    $0x10,%esp
    687f:	a3 50 58 02 00       	mov    %eax,0x25850
    image_scale=(PBitmap*)malloc(sizeof(PBitmap));
    6884:	83 ec 0c             	sub    $0xc,%esp
    6887:	6a 0c                	push   $0xc
    6889:	e8 2f 08 00 00       	call   70bd <malloc>
    688e:	83 c4 10             	add    $0x10,%esp
    6891:	a3 8c 58 02 00       	mov    %eax,0x2588c
    image_scale_preview=(PBitmap*)malloc(sizeof(PBitmap));
    6896:	83 ec 0c             	sub    $0xc,%esp
    6899:	6a 0c                	push   $0xc
    689b:	e8 1d 08 00 00       	call   70bd <malloc>
    68a0:	83 c4 10             	add    $0x10,%esp
    68a3:	a3 24 58 02 00       	mov    %eax,0x25824
    image_turn=(PBitmap*)malloc(sizeof(PBitmap));
    68a8:	83 ec 0c             	sub    $0xc,%esp
    68ab:	6a 0c                	push   $0xc
    68ad:	e8 0b 08 00 00       	call   70bd <malloc>
    68b2:	83 c4 10             	add    $0x10,%esp
    68b5:	a3 dc 58 02 00       	mov    %eax,0x258dc
    image_turnaround=(PBitmap*)malloc(sizeof(PBitmap));
    68ba:	83 ec 0c             	sub    $0xc,%esp
    68bd:	6a 0c                	push   $0xc
    68bf:	e8 f9 07 00 00       	call   70bd <malloc>
    68c4:	83 c4 10             	add    $0x10,%esp
    68c7:	a3 3c 58 02 00       	mov    %eax,0x2583c
    image_rollover=(PBitmap*)malloc(sizeof(PBitmap));
    68cc:	83 ec 0c             	sub    $0xc,%esp
    68cf:	6a 0c                	push   $0xc
    68d1:	e8 e7 07 00 00       	call   70bd <malloc>
    68d6:	83 c4 10             	add    $0x10,%esp
    68d9:	a3 f0 58 02 00       	mov    %eax,0x258f0
    image_in_content = malloc(edit_img_size.w*edit_img_size.h*3);
    68de:	8b 15 e0 52 02 00    	mov    0x252e0,%edx
    68e4:	a1 dc 52 02 00       	mov    0x252dc,%eax
    68e9:	0f af d0             	imul   %eax,%edx
    68ec:	89 d0                	mov    %edx,%eax
    68ee:	01 c0                	add    %eax,%eax
    68f0:	01 d0                	add    %edx,%eax
    68f2:	83 ec 0c             	sub    $0xc,%esp
    68f5:	50                   	push   %eax
    68f6:	e8 c2 07 00 00       	call   70bd <malloc>
    68fb:	83 c4 10             	add    $0x10,%esp
    68fe:	a3 e8 58 02 00       	mov    %eax,0x258e8

    image_list=(ImageList* )malloc(sizeof(ImageList));
    6903:	83 ec 0c             	sub    $0xc,%esp
    6906:	6a 08                	push   $0x8
    6908:	e8 b0 07 00 00       	call   70bd <malloc>
    690d:	83 c4 10             	add    $0x10,%esp
    6910:	a3 74 58 02 00       	mov    %eax,0x25874
	ImageListInit(image_list);
    6915:	a1 74 58 02 00       	mov    0x25874,%eax
    691a:	83 ec 0c             	sub    $0xc,%esp
    691d:	50                   	push   %eax
    691e:	e8 dd 96 ff ff       	call   0 <ImageListInit>
    6923:	83 c4 10             	add    $0x10,%esp
    ls_new(".");
    6926:	83 ec 0c             	sub    $0xc,%esp
    6929:	68 cc c8 01 00       	push   $0x1c8cc
    692e:	e8 67 9d ff ff       	call   69a <ls_new>
    6933:	83 c4 10             	add    $0x10,%esp
    ls(".");
    6936:	83 ec 0c             	sub    $0xc,%esp
    6939:	68 cc c8 01 00       	push   $0x1c8cc
    693e:	e8 2d 9b ff ff       	call   470 <ls>
    6943:	83 c4 10             	add    $0x10,%esp
    Image *header;
    header = image_list->head;
    6946:	a1 74 58 02 00       	mov    0x25874,%eax
    694b:	8b 00                	mov    (%eax),%eax
    694d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    image_show=(Image**)malloc(sizeof(Image*)*3);
    6950:	83 ec 0c             	sub    $0xc,%esp
    6953:	6a 0c                	push   $0xc
    6955:	e8 63 07 00 00       	call   70bd <malloc>
    695a:	83 c4 10             	add    $0x10,%esp
    695d:	a3 54 58 02 00       	mov    %eax,0x25854
    image_show[0] = header;
    6962:	a1 54 58 02 00       	mov    0x25854,%eax
    6967:	8b 55 dc             	mov    -0x24(%ebp),%edx
    696a:	89 10                	mov    %edx,(%eax)
    image_show[1] = header->next;
    696c:	a1 54 58 02 00       	mov    0x25854,%eax
    6971:	8d 50 04             	lea    0x4(%eax),%edx
    6974:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6977:	8b 40 38             	mov    0x38(%eax),%eax
    697a:	89 02                	mov    %eax,(%edx)
    image_show[2] = header->next->next;
    697c:	a1 54 58 02 00       	mov    0x25854,%eax
    6981:	8d 50 08             	lea    0x8(%eax),%edx
    6984:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6987:	8b 40 38             	mov    0x38(%eax),%eax
    698a:	8b 40 38             	mov    0x38(%eax),%eax
    698d:	89 02                	mov    %eax,(%edx)
    setImageList();
    698f:	e8 bd b7 ff ff       	call   2151 <setImageList>
    current_gif_img = (Image*)malloc(sizeof(Image));
    6994:	83 ec 0c             	sub    $0xc,%esp
    6997:	6a 3c                	push   $0x3c
    6999:	e8 1f 07 00 00       	call   70bd <malloc>
    699e:	83 c4 10             	add    $0x10,%esp
    69a1:	a3 84 58 02 00       	mov    %eax,0x25884

    api_repaint(&wnd);
    69a6:	83 ec 0c             	sub    $0xc,%esp
    69a9:	68 a0 58 02 00       	push   $0x258a0
    69ae:	e8 d6 12 00 00       	call   7c89 <api_repaint>
    69b3:	83 c4 10             	add    $0x10,%esp
    api_settimer(&wnd, 50);
    69b6:	83 ec 08             	sub    $0x8,%esp
    69b9:	6a 32                	push   $0x32
    69bb:	68 a0 58 02 00       	push   $0x258a0
    69c0:	e8 50 13 00 00       	call   7d15 <api_settimer>
    69c5:	83 c4 10             	add    $0x10,%esp
    api_exec(&wnd, &MsgProc);
    69c8:	83 ec 08             	sub    $0x8,%esp
    69cb:	68 71 42 00 00       	push   $0x4271
    69d0:	68 a0 58 02 00       	push   $0x258a0
    69d5:	e8 ff 12 00 00       	call   7cd9 <api_exec>
    69da:	83 c4 10             	add    $0x10,%esp
    return 0;
    69dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    69e2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    69e5:	59                   	pop    %ecx
    69e6:	5b                   	pop    %ebx
    69e7:	5d                   	pop    %ebp
    69e8:	8d 61 fc             	lea    -0x4(%ecx),%esp
    69eb:	c3                   	ret    

000069ec <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
    69ec:	55                   	push   %ebp
    69ed:	89 e5                	mov    %esp,%ebp
    69ef:	57                   	push   %edi
    69f0:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
    69f1:	8b 4d 08             	mov    0x8(%ebp),%ecx
    69f4:	8b 55 10             	mov    0x10(%ebp),%edx
    69f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    69fa:	89 cb                	mov    %ecx,%ebx
    69fc:	89 df                	mov    %ebx,%edi
    69fe:	89 d1                	mov    %edx,%ecx
    6a00:	fc                   	cld    
    6a01:	f3 aa                	rep stos %al,%es:(%edi)
    6a03:	89 ca                	mov    %ecx,%edx
    6a05:	89 fb                	mov    %edi,%ebx
    6a07:	89 5d 08             	mov    %ebx,0x8(%ebp)
    6a0a:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
    6a0d:	90                   	nop
    6a0e:	5b                   	pop    %ebx
    6a0f:	5f                   	pop    %edi
    6a10:	5d                   	pop    %ebp
    6a11:	c3                   	ret    

00006a12 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
    6a12:	55                   	push   %ebp
    6a13:	89 e5                	mov    %esp,%ebp
    6a15:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
    6a18:	8b 45 08             	mov    0x8(%ebp),%eax
    6a1b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
    6a1e:	90                   	nop
    6a1f:	8b 45 08             	mov    0x8(%ebp),%eax
    6a22:	8d 50 01             	lea    0x1(%eax),%edx
    6a25:	89 55 08             	mov    %edx,0x8(%ebp)
    6a28:	8b 55 0c             	mov    0xc(%ebp),%edx
    6a2b:	8d 4a 01             	lea    0x1(%edx),%ecx
    6a2e:	89 4d 0c             	mov    %ecx,0xc(%ebp)
    6a31:	0f b6 12             	movzbl (%edx),%edx
    6a34:	88 10                	mov    %dl,(%eax)
    6a36:	0f b6 00             	movzbl (%eax),%eax
    6a39:	84 c0                	test   %al,%al
    6a3b:	75 e2                	jne    6a1f <strcpy+0xd>
    ;
  return os;
    6a3d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6a40:	c9                   	leave  
    6a41:	c3                   	ret    

00006a42 <strcmp>:

int
strcmp(const char *p, const char *q)
{
    6a42:	55                   	push   %ebp
    6a43:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
    6a45:	eb 08                	jmp    6a4f <strcmp+0xd>
    p++, q++;
    6a47:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6a4b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
    6a4f:	8b 45 08             	mov    0x8(%ebp),%eax
    6a52:	0f b6 00             	movzbl (%eax),%eax
    6a55:	84 c0                	test   %al,%al
    6a57:	74 10                	je     6a69 <strcmp+0x27>
    6a59:	8b 45 08             	mov    0x8(%ebp),%eax
    6a5c:	0f b6 10             	movzbl (%eax),%edx
    6a5f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a62:	0f b6 00             	movzbl (%eax),%eax
    6a65:	38 c2                	cmp    %al,%dl
    6a67:	74 de                	je     6a47 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
    6a69:	8b 45 08             	mov    0x8(%ebp),%eax
    6a6c:	0f b6 00             	movzbl (%eax),%eax
    6a6f:	0f b6 d0             	movzbl %al,%edx
    6a72:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a75:	0f b6 00             	movzbl (%eax),%eax
    6a78:	0f b6 c0             	movzbl %al,%eax
    6a7b:	29 c2                	sub    %eax,%edx
    6a7d:	89 d0                	mov    %edx,%eax
}
    6a7f:	5d                   	pop    %ebp
    6a80:	c3                   	ret    

00006a81 <strlen>:

uint
strlen(char *s)
{
    6a81:	55                   	push   %ebp
    6a82:	89 e5                	mov    %esp,%ebp
    6a84:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
    6a87:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6a8e:	eb 04                	jmp    6a94 <strlen+0x13>
    6a90:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6a94:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a97:	8b 45 08             	mov    0x8(%ebp),%eax
    6a9a:	01 d0                	add    %edx,%eax
    6a9c:	0f b6 00             	movzbl (%eax),%eax
    6a9f:	84 c0                	test   %al,%al
    6aa1:	75 ed                	jne    6a90 <strlen+0xf>
    ;
  return n;
    6aa3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6aa6:	c9                   	leave  
    6aa7:	c3                   	ret    

00006aa8 <memset>:

void*
memset(void *dst, int c, uint n)
{
    6aa8:	55                   	push   %ebp
    6aa9:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
    6aab:	8b 45 10             	mov    0x10(%ebp),%eax
    6aae:	50                   	push   %eax
    6aaf:	ff 75 0c             	pushl  0xc(%ebp)
    6ab2:	ff 75 08             	pushl  0x8(%ebp)
    6ab5:	e8 32 ff ff ff       	call   69ec <stosb>
    6aba:	83 c4 0c             	add    $0xc,%esp
  return dst;
    6abd:	8b 45 08             	mov    0x8(%ebp),%eax
}
    6ac0:	c9                   	leave  
    6ac1:	c3                   	ret    

00006ac2 <strchr>:

char*
strchr(const char *s, char c)
{
    6ac2:	55                   	push   %ebp
    6ac3:	89 e5                	mov    %esp,%ebp
    6ac5:	83 ec 04             	sub    $0x4,%esp
    6ac8:	8b 45 0c             	mov    0xc(%ebp),%eax
    6acb:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
    6ace:	eb 14                	jmp    6ae4 <strchr+0x22>
    if(*s == c)
    6ad0:	8b 45 08             	mov    0x8(%ebp),%eax
    6ad3:	0f b6 00             	movzbl (%eax),%eax
    6ad6:	3a 45 fc             	cmp    -0x4(%ebp),%al
    6ad9:	75 05                	jne    6ae0 <strchr+0x1e>
      return (char*)s;
    6adb:	8b 45 08             	mov    0x8(%ebp),%eax
    6ade:	eb 13                	jmp    6af3 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
    6ae0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6ae4:	8b 45 08             	mov    0x8(%ebp),%eax
    6ae7:	0f b6 00             	movzbl (%eax),%eax
    6aea:	84 c0                	test   %al,%al
    6aec:	75 e2                	jne    6ad0 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
    6aee:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6af3:	c9                   	leave  
    6af4:	c3                   	ret    

00006af5 <gets>:

char*
gets(char *buf, int max)
{
    6af5:	55                   	push   %ebp
    6af6:	89 e5                	mov    %esp,%ebp
    6af8:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
    6afb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6b02:	eb 42                	jmp    6b46 <gets+0x51>
    cc = read(0, &c, 1);
    6b04:	83 ec 04             	sub    $0x4,%esp
    6b07:	6a 01                	push   $0x1
    6b09:	8d 45 ef             	lea    -0x11(%ebp),%eax
    6b0c:	50                   	push   %eax
    6b0d:	6a 00                	push   $0x0
    6b0f:	e8 47 01 00 00       	call   6c5b <read>
    6b14:	83 c4 10             	add    $0x10,%esp
    6b17:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
    6b1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6b1e:	7e 33                	jle    6b53 <gets+0x5e>
      break;
    buf[i++] = c;
    6b20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6b23:	8d 50 01             	lea    0x1(%eax),%edx
    6b26:	89 55 f4             	mov    %edx,-0xc(%ebp)
    6b29:	89 c2                	mov    %eax,%edx
    6b2b:	8b 45 08             	mov    0x8(%ebp),%eax
    6b2e:	01 c2                	add    %eax,%edx
    6b30:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    6b34:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
    6b36:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    6b3a:	3c 0a                	cmp    $0xa,%al
    6b3c:	74 16                	je     6b54 <gets+0x5f>
    6b3e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    6b42:	3c 0d                	cmp    $0xd,%al
    6b44:	74 0e                	je     6b54 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
    6b46:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6b49:	83 c0 01             	add    $0x1,%eax
    6b4c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6b4f:	7c b3                	jl     6b04 <gets+0xf>
    6b51:	eb 01                	jmp    6b54 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
    6b53:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
    6b54:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6b57:	8b 45 08             	mov    0x8(%ebp),%eax
    6b5a:	01 d0                	add    %edx,%eax
    6b5c:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
    6b5f:	8b 45 08             	mov    0x8(%ebp),%eax
}
    6b62:	c9                   	leave  
    6b63:	c3                   	ret    

00006b64 <stat>:

int
stat(char *n, struct stat *st)
{
    6b64:	55                   	push   %ebp
    6b65:	89 e5                	mov    %esp,%ebp
    6b67:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
    6b6a:	83 ec 08             	sub    $0x8,%esp
    6b6d:	6a 00                	push   $0x0
    6b6f:	ff 75 08             	pushl  0x8(%ebp)
    6b72:	e8 0c 01 00 00       	call   6c83 <open>
    6b77:	83 c4 10             	add    $0x10,%esp
    6b7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
    6b7d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6b81:	79 07                	jns    6b8a <stat+0x26>
    return -1;
    6b83:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    6b88:	eb 25                	jmp    6baf <stat+0x4b>
  r = fstat(fd, st);
    6b8a:	83 ec 08             	sub    $0x8,%esp
    6b8d:	ff 75 0c             	pushl  0xc(%ebp)
    6b90:	ff 75 f4             	pushl  -0xc(%ebp)
    6b93:	e8 03 01 00 00       	call   6c9b <fstat>
    6b98:	83 c4 10             	add    $0x10,%esp
    6b9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
    6b9e:	83 ec 0c             	sub    $0xc,%esp
    6ba1:	ff 75 f4             	pushl  -0xc(%ebp)
    6ba4:	e8 c2 00 00 00       	call   6c6b <close>
    6ba9:	83 c4 10             	add    $0x10,%esp
  return r;
    6bac:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6baf:	c9                   	leave  
    6bb0:	c3                   	ret    

00006bb1 <atoi>:

int
atoi(const char *s)
{
    6bb1:	55                   	push   %ebp
    6bb2:	89 e5                	mov    %esp,%ebp
    6bb4:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
    6bb7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
    6bbe:	eb 25                	jmp    6be5 <atoi+0x34>
    n = n*10 + *s++ - '0';
    6bc0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6bc3:	89 d0                	mov    %edx,%eax
    6bc5:	c1 e0 02             	shl    $0x2,%eax
    6bc8:	01 d0                	add    %edx,%eax
    6bca:	01 c0                	add    %eax,%eax
    6bcc:	89 c1                	mov    %eax,%ecx
    6bce:	8b 45 08             	mov    0x8(%ebp),%eax
    6bd1:	8d 50 01             	lea    0x1(%eax),%edx
    6bd4:	89 55 08             	mov    %edx,0x8(%ebp)
    6bd7:	0f b6 00             	movzbl (%eax),%eax
    6bda:	0f be c0             	movsbl %al,%eax
    6bdd:	01 c8                	add    %ecx,%eax
    6bdf:	83 e8 30             	sub    $0x30,%eax
    6be2:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
    6be5:	8b 45 08             	mov    0x8(%ebp),%eax
    6be8:	0f b6 00             	movzbl (%eax),%eax
    6beb:	3c 2f                	cmp    $0x2f,%al
    6bed:	7e 0a                	jle    6bf9 <atoi+0x48>
    6bef:	8b 45 08             	mov    0x8(%ebp),%eax
    6bf2:	0f b6 00             	movzbl (%eax),%eax
    6bf5:	3c 39                	cmp    $0x39,%al
    6bf7:	7e c7                	jle    6bc0 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
    6bf9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6bfc:	c9                   	leave  
    6bfd:	c3                   	ret    

00006bfe <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
    6bfe:	55                   	push   %ebp
    6bff:	89 e5                	mov    %esp,%ebp
    6c01:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
    6c04:	8b 45 08             	mov    0x8(%ebp),%eax
    6c07:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
    6c0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    6c0d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
    6c10:	eb 17                	jmp    6c29 <memmove+0x2b>
    *dst++ = *src++;
    6c12:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c15:	8d 50 01             	lea    0x1(%eax),%edx
    6c18:	89 55 fc             	mov    %edx,-0x4(%ebp)
    6c1b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6c1e:	8d 4a 01             	lea    0x1(%edx),%ecx
    6c21:	89 4d f8             	mov    %ecx,-0x8(%ebp)
    6c24:	0f b6 12             	movzbl (%edx),%edx
    6c27:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
    6c29:	8b 45 10             	mov    0x10(%ebp),%eax
    6c2c:	8d 50 ff             	lea    -0x1(%eax),%edx
    6c2f:	89 55 10             	mov    %edx,0x10(%ebp)
    6c32:	85 c0                	test   %eax,%eax
    6c34:	7f dc                	jg     6c12 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
    6c36:	8b 45 08             	mov    0x8(%ebp),%eax
}
    6c39:	c9                   	leave  
    6c3a:	c3                   	ret    

00006c3b <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
    6c3b:	b8 01 00 00 00       	mov    $0x1,%eax
    6c40:	cd 40                	int    $0x40
    6c42:	c3                   	ret    

00006c43 <exit>:
SYSCALL(exit)
    6c43:	b8 02 00 00 00       	mov    $0x2,%eax
    6c48:	cd 40                	int    $0x40
    6c4a:	c3                   	ret    

00006c4b <wait>:
SYSCALL(wait)
    6c4b:	b8 03 00 00 00       	mov    $0x3,%eax
    6c50:	cd 40                	int    $0x40
    6c52:	c3                   	ret    

00006c53 <pipe>:
SYSCALL(pipe)
    6c53:	b8 04 00 00 00       	mov    $0x4,%eax
    6c58:	cd 40                	int    $0x40
    6c5a:	c3                   	ret    

00006c5b <read>:
SYSCALL(read)
    6c5b:	b8 05 00 00 00       	mov    $0x5,%eax
    6c60:	cd 40                	int    $0x40
    6c62:	c3                   	ret    

00006c63 <write>:
SYSCALL(write)
    6c63:	b8 10 00 00 00       	mov    $0x10,%eax
    6c68:	cd 40                	int    $0x40
    6c6a:	c3                   	ret    

00006c6b <close>:
SYSCALL(close)
    6c6b:	b8 15 00 00 00       	mov    $0x15,%eax
    6c70:	cd 40                	int    $0x40
    6c72:	c3                   	ret    

00006c73 <kill>:
SYSCALL(kill)
    6c73:	b8 06 00 00 00       	mov    $0x6,%eax
    6c78:	cd 40                	int    $0x40
    6c7a:	c3                   	ret    

00006c7b <exec>:
SYSCALL(exec)
    6c7b:	b8 07 00 00 00       	mov    $0x7,%eax
    6c80:	cd 40                	int    $0x40
    6c82:	c3                   	ret    

00006c83 <open>:
SYSCALL(open)
    6c83:	b8 0f 00 00 00       	mov    $0xf,%eax
    6c88:	cd 40                	int    $0x40
    6c8a:	c3                   	ret    

00006c8b <mknod>:
SYSCALL(mknod)
    6c8b:	b8 11 00 00 00       	mov    $0x11,%eax
    6c90:	cd 40                	int    $0x40
    6c92:	c3                   	ret    

00006c93 <unlink>:
SYSCALL(unlink)
    6c93:	b8 12 00 00 00       	mov    $0x12,%eax
    6c98:	cd 40                	int    $0x40
    6c9a:	c3                   	ret    

00006c9b <fstat>:
SYSCALL(fstat)
    6c9b:	b8 08 00 00 00       	mov    $0x8,%eax
    6ca0:	cd 40                	int    $0x40
    6ca2:	c3                   	ret    

00006ca3 <link>:
SYSCALL(link)
    6ca3:	b8 13 00 00 00       	mov    $0x13,%eax
    6ca8:	cd 40                	int    $0x40
    6caa:	c3                   	ret    

00006cab <mkdir>:
SYSCALL(mkdir)
    6cab:	b8 14 00 00 00       	mov    $0x14,%eax
    6cb0:	cd 40                	int    $0x40
    6cb2:	c3                   	ret    

00006cb3 <chdir>:
SYSCALL(chdir)
    6cb3:	b8 09 00 00 00       	mov    $0x9,%eax
    6cb8:	cd 40                	int    $0x40
    6cba:	c3                   	ret    

00006cbb <dup>:
SYSCALL(dup)
    6cbb:	b8 0a 00 00 00       	mov    $0xa,%eax
    6cc0:	cd 40                	int    $0x40
    6cc2:	c3                   	ret    

00006cc3 <getpid>:
SYSCALL(getpid)
    6cc3:	b8 0b 00 00 00       	mov    $0xb,%eax
    6cc8:	cd 40                	int    $0x40
    6cca:	c3                   	ret    

00006ccb <sbrk>:
SYSCALL(sbrk)
    6ccb:	b8 0c 00 00 00       	mov    $0xc,%eax
    6cd0:	cd 40                	int    $0x40
    6cd2:	c3                   	ret    

00006cd3 <sleep>:
SYSCALL(sleep)
    6cd3:	b8 0d 00 00 00       	mov    $0xd,%eax
    6cd8:	cd 40                	int    $0x40
    6cda:	c3                   	ret    

00006cdb <uptime>:
SYSCALL(uptime)
    6cdb:	b8 0e 00 00 00       	mov    $0xe,%eax
    6ce0:	cd 40                	int    $0x40
    6ce2:	c3                   	ret    

00006ce3 <createwindow>:
SYSCALL(createwindow)
    6ce3:	b8 16 00 00 00       	mov    $0x16,%eax
    6ce8:	cd 40                	int    $0x40
    6cea:	c3                   	ret    

00006ceb <repaintwindow>:
SYSCALL(repaintwindow)
    6ceb:	b8 17 00 00 00       	mov    $0x17,%eax
    6cf0:	cd 40                	int    $0x40
    6cf2:	c3                   	ret    

00006cf3 <getmessage>:
SYSCALL(getmessage)
    6cf3:	b8 18 00 00 00       	mov    $0x18,%eax
    6cf8:	cd 40                	int    $0x40
    6cfa:	c3                   	ret    

00006cfb <settimer>:
SYSCALL(settimer)
    6cfb:	b8 19 00 00 00       	mov    $0x19,%eax
    6d00:	cd 40                	int    $0x40
    6d02:	c3                   	ret    

00006d03 <updatewindow>:
SYSCALL(updatewindow)
    6d03:	b8 1a 00 00 00       	mov    $0x1a,%eax
    6d08:	cd 40                	int    $0x40
    6d0a:	c3                   	ret    

00006d0b <destroywindow>:
SYSCALL(destroywindow)
    6d0b:	b8 1b 00 00 00       	mov    $0x1b,%eax
    6d10:	cd 40                	int    $0x40
    6d12:	c3                   	ret    

00006d13 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
    6d13:	55                   	push   %ebp
    6d14:	89 e5                	mov    %esp,%ebp
    6d16:	83 ec 18             	sub    $0x18,%esp
    6d19:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d1c:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
    6d1f:	83 ec 04             	sub    $0x4,%esp
    6d22:	6a 01                	push   $0x1
    6d24:	8d 45 f4             	lea    -0xc(%ebp),%eax
    6d27:	50                   	push   %eax
    6d28:	ff 75 08             	pushl  0x8(%ebp)
    6d2b:	e8 33 ff ff ff       	call   6c63 <write>
    6d30:	83 c4 10             	add    $0x10,%esp
}
    6d33:	90                   	nop
    6d34:	c9                   	leave  
    6d35:	c3                   	ret    

00006d36 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
    6d36:	55                   	push   %ebp
    6d37:	89 e5                	mov    %esp,%ebp
    6d39:	53                   	push   %ebx
    6d3a:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
    6d3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
    6d44:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    6d48:	74 17                	je     6d61 <printint+0x2b>
    6d4a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    6d4e:	79 11                	jns    6d61 <printint+0x2b>
    neg = 1;
    6d50:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
    6d57:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d5a:	f7 d8                	neg    %eax
    6d5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6d5f:	eb 06                	jmp    6d67 <printint+0x31>
  } else {
    x = xx;
    6d61:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d64:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
    6d67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
    6d6e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    6d71:	8d 41 01             	lea    0x1(%ecx),%eax
    6d74:	89 45 f4             	mov    %eax,-0xc(%ebp)
    6d77:	8b 5d 10             	mov    0x10(%ebp),%ebx
    6d7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d7d:	ba 00 00 00 00       	mov    $0x0,%edx
    6d82:	f7 f3                	div    %ebx
    6d84:	89 d0                	mov    %edx,%eax
    6d86:	0f b6 80 44 53 02 00 	movzbl 0x25344(%eax),%eax
    6d8d:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
    6d91:	8b 5d 10             	mov    0x10(%ebp),%ebx
    6d94:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d97:	ba 00 00 00 00       	mov    $0x0,%edx
    6d9c:	f7 f3                	div    %ebx
    6d9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    6da1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6da5:	75 c7                	jne    6d6e <printint+0x38>
  if(neg)
    6da7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6dab:	74 2d                	je     6dda <printint+0xa4>
    buf[i++] = '-';
    6dad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6db0:	8d 50 01             	lea    0x1(%eax),%edx
    6db3:	89 55 f4             	mov    %edx,-0xc(%ebp)
    6db6:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
    6dbb:	eb 1d                	jmp    6dda <printint+0xa4>
    putc(fd, buf[i]);
    6dbd:	8d 55 dc             	lea    -0x24(%ebp),%edx
    6dc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6dc3:	01 d0                	add    %edx,%eax
    6dc5:	0f b6 00             	movzbl (%eax),%eax
    6dc8:	0f be c0             	movsbl %al,%eax
    6dcb:	83 ec 08             	sub    $0x8,%esp
    6dce:	50                   	push   %eax
    6dcf:	ff 75 08             	pushl  0x8(%ebp)
    6dd2:	e8 3c ff ff ff       	call   6d13 <putc>
    6dd7:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
    6dda:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    6dde:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6de2:	79 d9                	jns    6dbd <printint+0x87>
    putc(fd, buf[i]);
}
    6de4:	90                   	nop
    6de5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6de8:	c9                   	leave  
    6de9:	c3                   	ret    

00006dea <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
    6dea:	55                   	push   %ebp
    6deb:	89 e5                	mov    %esp,%ebp
    6ded:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
    6df0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
    6df7:	8d 45 0c             	lea    0xc(%ebp),%eax
    6dfa:	83 c0 04             	add    $0x4,%eax
    6dfd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
    6e00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6e07:	e9 59 01 00 00       	jmp    6f65 <printf+0x17b>
    c = fmt[i] & 0xff;
    6e0c:	8b 55 0c             	mov    0xc(%ebp),%edx
    6e0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e12:	01 d0                	add    %edx,%eax
    6e14:	0f b6 00             	movzbl (%eax),%eax
    6e17:	0f be c0             	movsbl %al,%eax
    6e1a:	25 ff 00 00 00       	and    $0xff,%eax
    6e1f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
    6e22:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6e26:	75 2c                	jne    6e54 <printf+0x6a>
      if(c == '%'){
    6e28:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    6e2c:	75 0c                	jne    6e3a <printf+0x50>
        state = '%';
    6e2e:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
    6e35:	e9 27 01 00 00       	jmp    6f61 <printf+0x177>
      } else {
        putc(fd, c);
    6e3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6e3d:	0f be c0             	movsbl %al,%eax
    6e40:	83 ec 08             	sub    $0x8,%esp
    6e43:	50                   	push   %eax
    6e44:	ff 75 08             	pushl  0x8(%ebp)
    6e47:	e8 c7 fe ff ff       	call   6d13 <putc>
    6e4c:	83 c4 10             	add    $0x10,%esp
    6e4f:	e9 0d 01 00 00       	jmp    6f61 <printf+0x177>
      }
    } else if(state == '%'){
    6e54:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
    6e58:	0f 85 03 01 00 00    	jne    6f61 <printf+0x177>
      if(c == 'd'){
    6e5e:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
    6e62:	75 1e                	jne    6e82 <printf+0x98>
        printint(fd, *ap, 10, 1);
    6e64:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e67:	8b 00                	mov    (%eax),%eax
    6e69:	6a 01                	push   $0x1
    6e6b:	6a 0a                	push   $0xa
    6e6d:	50                   	push   %eax
    6e6e:	ff 75 08             	pushl  0x8(%ebp)
    6e71:	e8 c0 fe ff ff       	call   6d36 <printint>
    6e76:	83 c4 10             	add    $0x10,%esp
        ap++;
    6e79:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    6e7d:	e9 d8 00 00 00       	jmp    6f5a <printf+0x170>
      } else if(c == 'x' || c == 'p'){
    6e82:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
    6e86:	74 06                	je     6e8e <printf+0xa4>
    6e88:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
    6e8c:	75 1e                	jne    6eac <printf+0xc2>
        printint(fd, *ap, 16, 0);
    6e8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e91:	8b 00                	mov    (%eax),%eax
    6e93:	6a 00                	push   $0x0
    6e95:	6a 10                	push   $0x10
    6e97:	50                   	push   %eax
    6e98:	ff 75 08             	pushl  0x8(%ebp)
    6e9b:	e8 96 fe ff ff       	call   6d36 <printint>
    6ea0:	83 c4 10             	add    $0x10,%esp
        ap++;
    6ea3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    6ea7:	e9 ae 00 00 00       	jmp    6f5a <printf+0x170>
      } else if(c == 's'){
    6eac:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
    6eb0:	75 43                	jne    6ef5 <printf+0x10b>
        s = (char*)*ap;
    6eb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6eb5:	8b 00                	mov    (%eax),%eax
    6eb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
    6eba:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
    6ebe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6ec2:	75 25                	jne    6ee9 <printf+0xff>
          s = "(null)";
    6ec4:	c7 45 f4 ec c8 01 00 	movl   $0x1c8ec,-0xc(%ebp)
        while(*s != 0){
    6ecb:	eb 1c                	jmp    6ee9 <printf+0xff>
          putc(fd, *s);
    6ecd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6ed0:	0f b6 00             	movzbl (%eax),%eax
    6ed3:	0f be c0             	movsbl %al,%eax
    6ed6:	83 ec 08             	sub    $0x8,%esp
    6ed9:	50                   	push   %eax
    6eda:	ff 75 08             	pushl  0x8(%ebp)
    6edd:	e8 31 fe ff ff       	call   6d13 <putc>
    6ee2:	83 c4 10             	add    $0x10,%esp
          s++;
    6ee5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
    6ee9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6eec:	0f b6 00             	movzbl (%eax),%eax
    6eef:	84 c0                	test   %al,%al
    6ef1:	75 da                	jne    6ecd <printf+0xe3>
    6ef3:	eb 65                	jmp    6f5a <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
    6ef5:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
    6ef9:	75 1d                	jne    6f18 <printf+0x12e>
        putc(fd, *ap);
    6efb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6efe:	8b 00                	mov    (%eax),%eax
    6f00:	0f be c0             	movsbl %al,%eax
    6f03:	83 ec 08             	sub    $0x8,%esp
    6f06:	50                   	push   %eax
    6f07:	ff 75 08             	pushl  0x8(%ebp)
    6f0a:	e8 04 fe ff ff       	call   6d13 <putc>
    6f0f:	83 c4 10             	add    $0x10,%esp
        ap++;
    6f12:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    6f16:	eb 42                	jmp    6f5a <printf+0x170>
      } else if(c == '%'){
    6f18:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    6f1c:	75 17                	jne    6f35 <printf+0x14b>
        putc(fd, c);
    6f1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6f21:	0f be c0             	movsbl %al,%eax
    6f24:	83 ec 08             	sub    $0x8,%esp
    6f27:	50                   	push   %eax
    6f28:	ff 75 08             	pushl  0x8(%ebp)
    6f2b:	e8 e3 fd ff ff       	call   6d13 <putc>
    6f30:	83 c4 10             	add    $0x10,%esp
    6f33:	eb 25                	jmp    6f5a <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
    6f35:	83 ec 08             	sub    $0x8,%esp
    6f38:	6a 25                	push   $0x25
    6f3a:	ff 75 08             	pushl  0x8(%ebp)
    6f3d:	e8 d1 fd ff ff       	call   6d13 <putc>
    6f42:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
    6f45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6f48:	0f be c0             	movsbl %al,%eax
    6f4b:	83 ec 08             	sub    $0x8,%esp
    6f4e:	50                   	push   %eax
    6f4f:	ff 75 08             	pushl  0x8(%ebp)
    6f52:	e8 bc fd ff ff       	call   6d13 <putc>
    6f57:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
    6f5a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
    6f61:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6f65:	8b 55 0c             	mov    0xc(%ebp),%edx
    6f68:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f6b:	01 d0                	add    %edx,%eax
    6f6d:	0f b6 00             	movzbl (%eax),%eax
    6f70:	84 c0                	test   %al,%al
    6f72:	0f 85 94 fe ff ff    	jne    6e0c <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
    6f78:	90                   	nop
    6f79:	c9                   	leave  
    6f7a:	c3                   	ret    

00006f7b <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
    6f7b:	55                   	push   %ebp
    6f7c:	89 e5                	mov    %esp,%ebp
    6f7e:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
    6f81:	8b 45 08             	mov    0x8(%ebp),%eax
    6f84:	83 e8 08             	sub    $0x8,%eax
    6f87:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    6f8a:	a1 e4 57 02 00       	mov    0x257e4,%eax
    6f8f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    6f92:	eb 24                	jmp    6fb8 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
    6f94:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6f97:	8b 00                	mov    (%eax),%eax
    6f99:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6f9c:	77 12                	ja     6fb0 <free+0x35>
    6f9e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6fa1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6fa4:	77 24                	ja     6fca <free+0x4f>
    6fa6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6fa9:	8b 00                	mov    (%eax),%eax
    6fab:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6fae:	77 1a                	ja     6fca <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    6fb0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6fb3:	8b 00                	mov    (%eax),%eax
    6fb5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    6fb8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6fbb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6fbe:	76 d4                	jbe    6f94 <free+0x19>
    6fc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6fc3:	8b 00                	mov    (%eax),%eax
    6fc5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6fc8:	76 ca                	jbe    6f94 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
    6fca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6fcd:	8b 40 04             	mov    0x4(%eax),%eax
    6fd0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    6fd7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6fda:	01 c2                	add    %eax,%edx
    6fdc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6fdf:	8b 00                	mov    (%eax),%eax
    6fe1:	39 c2                	cmp    %eax,%edx
    6fe3:	75 24                	jne    7009 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
    6fe5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6fe8:	8b 50 04             	mov    0x4(%eax),%edx
    6feb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6fee:	8b 00                	mov    (%eax),%eax
    6ff0:	8b 40 04             	mov    0x4(%eax),%eax
    6ff3:	01 c2                	add    %eax,%edx
    6ff5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6ff8:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
    6ffb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6ffe:	8b 00                	mov    (%eax),%eax
    7000:	8b 10                	mov    (%eax),%edx
    7002:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7005:	89 10                	mov    %edx,(%eax)
    7007:	eb 0a                	jmp    7013 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
    7009:	8b 45 fc             	mov    -0x4(%ebp),%eax
    700c:	8b 10                	mov    (%eax),%edx
    700e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7011:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
    7013:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7016:	8b 40 04             	mov    0x4(%eax),%eax
    7019:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    7020:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7023:	01 d0                	add    %edx,%eax
    7025:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    7028:	75 20                	jne    704a <free+0xcf>
    p->s.size += bp->s.size;
    702a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    702d:	8b 50 04             	mov    0x4(%eax),%edx
    7030:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7033:	8b 40 04             	mov    0x4(%eax),%eax
    7036:	01 c2                	add    %eax,%edx
    7038:	8b 45 fc             	mov    -0x4(%ebp),%eax
    703b:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
    703e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7041:	8b 10                	mov    (%eax),%edx
    7043:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7046:	89 10                	mov    %edx,(%eax)
    7048:	eb 08                	jmp    7052 <free+0xd7>
  } else
    p->s.ptr = bp;
    704a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    704d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7050:	89 10                	mov    %edx,(%eax)
  freep = p;
    7052:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7055:	a3 e4 57 02 00       	mov    %eax,0x257e4
}
    705a:	90                   	nop
    705b:	c9                   	leave  
    705c:	c3                   	ret    

0000705d <morecore>:

static Header*
morecore(uint nu)
{
    705d:	55                   	push   %ebp
    705e:	89 e5                	mov    %esp,%ebp
    7060:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
    7063:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
    706a:	77 07                	ja     7073 <morecore+0x16>
    nu = 4096;
    706c:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
    7073:	8b 45 08             	mov    0x8(%ebp),%eax
    7076:	c1 e0 03             	shl    $0x3,%eax
    7079:	83 ec 0c             	sub    $0xc,%esp
    707c:	50                   	push   %eax
    707d:	e8 49 fc ff ff       	call   6ccb <sbrk>
    7082:	83 c4 10             	add    $0x10,%esp
    7085:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
    7088:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
    708c:	75 07                	jne    7095 <morecore+0x38>
    return 0;
    708e:	b8 00 00 00 00       	mov    $0x0,%eax
    7093:	eb 26                	jmp    70bb <morecore+0x5e>
  hp = (Header*)p;
    7095:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7098:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
    709b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    709e:	8b 55 08             	mov    0x8(%ebp),%edx
    70a1:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
    70a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    70a7:	83 c0 08             	add    $0x8,%eax
    70aa:	83 ec 0c             	sub    $0xc,%esp
    70ad:	50                   	push   %eax
    70ae:	e8 c8 fe ff ff       	call   6f7b <free>
    70b3:	83 c4 10             	add    $0x10,%esp
  return freep;
    70b6:	a1 e4 57 02 00       	mov    0x257e4,%eax
}
    70bb:	c9                   	leave  
    70bc:	c3                   	ret    

000070bd <malloc>:

void*
malloc(uint nbytes)
{
    70bd:	55                   	push   %ebp
    70be:	89 e5                	mov    %esp,%ebp
    70c0:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
    70c3:	8b 45 08             	mov    0x8(%ebp),%eax
    70c6:	83 c0 07             	add    $0x7,%eax
    70c9:	c1 e8 03             	shr    $0x3,%eax
    70cc:	83 c0 01             	add    $0x1,%eax
    70cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
    70d2:	a1 e4 57 02 00       	mov    0x257e4,%eax
    70d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    70da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    70de:	75 23                	jne    7103 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
    70e0:	c7 45 f0 dc 57 02 00 	movl   $0x257dc,-0x10(%ebp)
    70e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    70ea:	a3 e4 57 02 00       	mov    %eax,0x257e4
    70ef:	a1 e4 57 02 00       	mov    0x257e4,%eax
    70f4:	a3 dc 57 02 00       	mov    %eax,0x257dc
    base.s.size = 0;
    70f9:	c7 05 e0 57 02 00 00 	movl   $0x0,0x257e0
    7100:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    7103:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7106:	8b 00                	mov    (%eax),%eax
    7108:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
    710b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    710e:	8b 40 04             	mov    0x4(%eax),%eax
    7111:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    7114:	72 4d                	jb     7163 <malloc+0xa6>
      if(p->s.size == nunits)
    7116:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7119:	8b 40 04             	mov    0x4(%eax),%eax
    711c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    711f:	75 0c                	jne    712d <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
    7121:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7124:	8b 10                	mov    (%eax),%edx
    7126:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7129:	89 10                	mov    %edx,(%eax)
    712b:	eb 26                	jmp    7153 <malloc+0x96>
      else {
        p->s.size -= nunits;
    712d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7130:	8b 40 04             	mov    0x4(%eax),%eax
    7133:	2b 45 ec             	sub    -0x14(%ebp),%eax
    7136:	89 c2                	mov    %eax,%edx
    7138:	8b 45 f4             	mov    -0xc(%ebp),%eax
    713b:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
    713e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7141:	8b 40 04             	mov    0x4(%eax),%eax
    7144:	c1 e0 03             	shl    $0x3,%eax
    7147:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
    714a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    714d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7150:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
    7153:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7156:	a3 e4 57 02 00       	mov    %eax,0x257e4
      return (void*)(p + 1);
    715b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    715e:	83 c0 08             	add    $0x8,%eax
    7161:	eb 3b                	jmp    719e <malloc+0xe1>
    }
    if(p == freep)
    7163:	a1 e4 57 02 00       	mov    0x257e4,%eax
    7168:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    716b:	75 1e                	jne    718b <malloc+0xce>
      if((p = morecore(nunits)) == 0)
    716d:	83 ec 0c             	sub    $0xc,%esp
    7170:	ff 75 ec             	pushl  -0x14(%ebp)
    7173:	e8 e5 fe ff ff       	call   705d <morecore>
    7178:	83 c4 10             	add    $0x10,%esp
    717b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    717e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7182:	75 07                	jne    718b <malloc+0xce>
        return 0;
    7184:	b8 00 00 00 00       	mov    $0x0,%eax
    7189:	eb 13                	jmp    719e <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    718b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    718e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7191:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7194:	8b 00                	mov    (%eax),%eax
    7196:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
    7199:	e9 6d ff ff ff       	jmp    710b <malloc+0x4e>
}
    719e:	c9                   	leave  
    719f:	c3                   	ret    

000071a0 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
    71a0:	55                   	push   %ebp
    71a1:	89 e5                	mov    %esp,%ebp
    ++g_seed;
    71a3:	a1 e8 57 02 00       	mov    0x257e8,%eax
    71a8:	83 c0 01             	add    $0x1,%eax
    71ab:	a3 e8 57 02 00       	mov    %eax,0x257e8
    g_seed = (214013*g_seed+2531011);
    71b0:	a1 e8 57 02 00       	mov    0x257e8,%eax
    71b5:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
    71bb:	05 c3 9e 26 00       	add    $0x269ec3,%eax
    71c0:	a3 e8 57 02 00       	mov    %eax,0x257e8
    return (g_seed>>16)&0x7FFF;
    71c5:	a1 e8 57 02 00       	mov    0x257e8,%eax
    71ca:	c1 e8 10             	shr    $0x10,%eax
    71cd:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
    71d2:	5d                   	pop    %ebp
    71d3:	c3                   	ret    

000071d4 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
    71d4:	55                   	push   %ebp
    71d5:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
    71d7:	d9 45 08             	flds   0x8(%ebp)
    71da:	d9 ee                	fldz   
    71dc:	d9 c9                	fxch   %st(1)
    71de:	df e9                	fucomip %st(1),%st
    71e0:	dd d8                	fstp   %st(0)
    71e2:	76 05                	jbe    71e9 <abs+0x15>
    71e4:	d9 45 08             	flds   0x8(%ebp)
    71e7:	eb 05                	jmp    71ee <abs+0x1a>
	return -x;
    71e9:	d9 45 08             	flds   0x8(%ebp)
    71ec:	d9 e0                	fchs   
}
    71ee:	5d                   	pop    %ebp
    71ef:	c3                   	ret    

000071f0 <pow>:

float pow(float a, int b)
{
    71f0:	55                   	push   %ebp
    71f1:	89 e5                	mov    %esp,%ebp
    71f3:	83 ec 10             	sub    $0x10,%esp
	float r = a;
    71f6:	d9 45 08             	flds   0x8(%ebp)
    71f9:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
    71fc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    7200:	7e 17                	jle    7219 <pow+0x29>
		while (--b)
    7202:	eb 09                	jmp    720d <pow+0x1d>
			r *= a;
    7204:	d9 45 fc             	flds   -0x4(%ebp)
    7207:	d8 4d 08             	fmuls  0x8(%ebp)
    720a:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
    720d:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    7211:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    7215:	75 ed                	jne    7204 <pow+0x14>
    7217:	eb 2a                	jmp    7243 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
    7219:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    721d:	79 1f                	jns    723e <pow+0x4e>
		while (++b)
    721f:	eb 09                	jmp    722a <pow+0x3a>
			r *= a;
    7221:	d9 45 fc             	flds   -0x4(%ebp)
    7224:	d8 4d 08             	fmuls  0x8(%ebp)
    7227:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
    722a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    722e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    7232:	75 ed                	jne    7221 <pow+0x31>
			r *= a;
		r = 1.0 / r;
    7234:	d9 e8                	fld1   
    7236:	d8 75 fc             	fdivs  -0x4(%ebp)
    7239:	d9 5d fc             	fstps  -0x4(%ebp)
    723c:	eb 05                	jmp    7243 <pow+0x53>
	}
	else r = 0;
    723e:	d9 ee                	fldz   
    7240:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
    7243:	d9 45 fc             	flds   -0x4(%ebp)
}
    7246:	c9                   	leave  
    7247:	c3                   	ret    

00007248 <sqrt>:

float sqrt(float number) {
    7248:	55                   	push   %ebp
    7249:	89 e5                	mov    %esp,%ebp
    724b:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
    724e:	d9 ee                	fldz   
    7250:	d9 45 08             	flds   0x8(%ebp)
    7253:	d9 c9                	fxch   %st(1)
    7255:	df e9                	fucomip %st(1),%st
    7257:	dd d8                	fstp   %st(0)
    7259:	76 06                	jbe    7261 <sqrt+0x19>
		return -1;
    725b:	d9 e8                	fld1   
    725d:	d9 e0                	fchs   
    725f:	eb 3a                	jmp    729b <sqrt+0x53>
	}

	new_guess = 1;
    7261:	d9 e8                	fld1   
    7263:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
    7266:	d9 45 fc             	flds   -0x4(%ebp)
    7269:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
    726c:	d9 45 08             	flds   0x8(%ebp)
    726f:	d8 75 f8             	fdivs  -0x8(%ebp)
    7272:	d8 45 f8             	fadds  -0x8(%ebp)
    7275:	d9 05 f8 c8 01 00    	flds   0x1c8f8
    727b:	de f9                	fdivrp %st,%st(1)
    727d:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
    7280:	d9 45 fc             	flds   -0x4(%ebp)
    7283:	d9 45 f8             	flds   -0x8(%ebp)
    7286:	df e9                	fucomip %st(1),%st
    7288:	dd d8                	fstp   %st(0)
    728a:	7a da                	jp     7266 <sqrt+0x1e>
    728c:	d9 45 fc             	flds   -0x4(%ebp)
    728f:	d9 45 f8             	flds   -0x8(%ebp)
    7292:	df e9                	fucomip %st(1),%st
    7294:	dd d8                	fstp   %st(0)
    7296:	75 ce                	jne    7266 <sqrt+0x1e>

	return new_guess;
    7298:	d9 45 fc             	flds   -0x4(%ebp)
}
    729b:	c9                   	leave  
    729c:	c3                   	ret    

0000729d <cos>:

float cos(float x)
{
    729d:	55                   	push   %ebp
    729e:	89 e5                	mov    %esp,%ebp
    72a0:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    72a3:	d9 e8                	fld1   
    72a5:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    72a8:	d9 45 08             	flds   0x8(%ebp)
    72ab:	dd 05 00 c9 01 00    	fldl   0x1c900
    72b1:	d9 c9                	fxch   %st(1)
    72b3:	df e9                	fucomip %st(1),%st
    72b5:	dd d8                	fstp   %st(0)
    72b7:	77 0f                	ja     72c8 <cos+0x2b>
    72b9:	d9 45 08             	flds   0x8(%ebp)
    72bc:	dd 05 08 c9 01 00    	fldl   0x1c908
    72c2:	df e9                	fucomip %st(1),%st
    72c4:	dd d8                	fstp   %st(0)
    72c6:	76 3c                	jbe    7304 <cos+0x67>
    72c8:	d9 45 08             	flds   0x8(%ebp)
    72cb:	d9 45 08             	flds   0x8(%ebp)
    72ce:	dd 05 00 c9 01 00    	fldl   0x1c900
    72d4:	de f9                	fdivrp %st,%st(1)
    72d6:	d9 7d e2             	fnstcw -0x1e(%ebp)
    72d9:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    72dd:	b4 0c                	mov    $0xc,%ah
    72df:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    72e3:	d9 6d e0             	fldcw  -0x20(%ebp)
    72e6:	db 5d dc             	fistpl -0x24(%ebp)
    72e9:	d9 6d e2             	fldcw  -0x1e(%ebp)
    72ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72ef:	01 c0                	add    %eax,%eax
    72f1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    72f4:	db 45 d8             	fildl  -0x28(%ebp)
    72f7:	dd 05 10 c9 01 00    	fldl   0x1c910
    72fd:	de c9                	fmulp  %st,%st(1)
    72ff:	de e9                	fsubrp %st,%st(1)
    7301:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    7304:	d9 45 08             	flds   0x8(%ebp)
    7307:	dd 05 10 c9 01 00    	fldl   0x1c910
    730d:	d9 c9                	fxch   %st(1)
    730f:	df e9                	fucomip %st(1),%st
    7311:	dd d8                	fstp   %st(0)
    7313:	76 0e                	jbe    7323 <cos+0x86>
    7315:	d9 45 08             	flds   0x8(%ebp)
    7318:	dd 05 00 c9 01 00    	fldl   0x1c900
    731e:	de e9                	fsubrp %st,%st(1)
    7320:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    7323:	d9 45 08             	flds   0x8(%ebp)
    7326:	dd 05 18 c9 01 00    	fldl   0x1c918
    732c:	df e9                	fucomip %st(1),%st
    732e:	dd d8                	fstp   %st(0)
    7330:	76 0e                	jbe    7340 <cos+0xa3>
    7332:	d9 45 08             	flds   0x8(%ebp)
    7335:	dd 05 00 c9 01 00    	fldl   0x1c900
    733b:	de c1                	faddp  %st,%st(1)
    733d:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    7340:	d9 45 08             	flds   0x8(%ebp)
    7343:	dd 05 20 c9 01 00    	fldl   0x1c920
    7349:	d9 c9                	fxch   %st(1)
    734b:	df e9                	fucomip %st(1),%st
    734d:	dd d8                	fstp   %st(0)
    734f:	76 16                	jbe    7367 <cos+0xca>
    {
        x -= PI;
    7351:	d9 45 08             	flds   0x8(%ebp)
    7354:	dd 05 10 c9 01 00    	fldl   0x1c910
    735a:	de e9                	fsubrp %st,%st(1)
    735c:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    735f:	d9 45 f4             	flds   -0xc(%ebp)
    7362:	d9 e0                	fchs   
    7364:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    7367:	d9 45 08             	flds   0x8(%ebp)
    736a:	dd 05 28 c9 01 00    	fldl   0x1c928
    7370:	df e9                	fucomip %st(1),%st
    7372:	dd d8                	fstp   %st(0)
    7374:	76 16                	jbe    738c <cos+0xef>
    {
        x += PI;
    7376:	d9 45 08             	flds   0x8(%ebp)
    7379:	dd 05 10 c9 01 00    	fldl   0x1c910
    737f:	de c1                	faddp  %st,%st(1)
    7381:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    7384:	d9 45 f4             	flds   -0xc(%ebp)
    7387:	d9 e0                	fchs   
    7389:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
    738c:	d9 45 08             	flds   0x8(%ebp)
    738f:	dd 05 30 c9 01 00    	fldl   0x1c930
    7395:	d9 c9                	fxch   %st(1)
    7397:	df e9                	fucomip %st(1),%st
    7399:	dd d8                	fstp   %st(0)
    739b:	76 28                	jbe    73c5 <cos+0x128>
    739d:	d9 45 08             	flds   0x8(%ebp)
    73a0:	dd 05 20 c9 01 00    	fldl   0x1c920
    73a6:	de e1                	fsubp  %st,%st(1)
    73a8:	d9 5d e4             	fstps  -0x1c(%ebp)
    73ab:	d9 45 e4             	flds   -0x1c(%ebp)
    73ae:	83 ec 0c             	sub    $0xc,%esp
    73b1:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    73b5:	d9 1c 24             	fstps  (%esp)
    73b8:	e8 83 00 00 00       	call   7440 <sin>
    73bd:	83 c4 10             	add    $0x10,%esp
    73c0:	d8 4d f4             	fmuls  -0xc(%ebp)
    73c3:	eb 79                	jmp    743e <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
    73c5:	83 ec 08             	sub    $0x8,%esp
    73c8:	6a 02                	push   $0x2
    73ca:	ff 75 08             	pushl  0x8(%ebp)
    73cd:	e8 1e fe ff ff       	call   71f0 <pow>
    73d2:	83 c4 10             	add    $0x10,%esp
    73d5:	d9 05 f8 c8 01 00    	flds   0x1c8f8
    73db:	de f9                	fdivrp %st,%st(1)
    73dd:	d9 e8                	fld1   
    73df:	de e1                	fsubp  %st,%st(1)
    73e1:	d9 5d d8             	fstps  -0x28(%ebp)
    73e4:	83 ec 08             	sub    $0x8,%esp
    73e7:	6a 04                	push   $0x4
    73e9:	ff 75 08             	pushl  0x8(%ebp)
    73ec:	e8 ff fd ff ff       	call   71f0 <pow>
    73f1:	83 c4 10             	add    $0x10,%esp
    73f4:	d9 05 38 c9 01 00    	flds   0x1c938
    73fa:	de f9                	fdivrp %st,%st(1)
    73fc:	d8 45 d8             	fadds  -0x28(%ebp)
    73ff:	d9 5d d8             	fstps  -0x28(%ebp)
    7402:	83 ec 08             	sub    $0x8,%esp
    7405:	6a 06                	push   $0x6
    7407:	ff 75 08             	pushl  0x8(%ebp)
    740a:	e8 e1 fd ff ff       	call   71f0 <pow>
    740f:	83 c4 10             	add    $0x10,%esp
    7412:	d9 05 3c c9 01 00    	flds   0x1c93c
    7418:	de f9                	fdivrp %st,%st(1)
    741a:	d8 6d d8             	fsubrs -0x28(%ebp)
    741d:	d9 5d d8             	fstps  -0x28(%ebp)
    7420:	83 ec 08             	sub    $0x8,%esp
    7423:	6a 08                	push   $0x8
    7425:	ff 75 08             	pushl  0x8(%ebp)
    7428:	e8 c3 fd ff ff       	call   71f0 <pow>
    742d:	83 c4 10             	add    $0x10,%esp
    7430:	d9 05 40 c9 01 00    	flds   0x1c940
    7436:	de f9                	fdivrp %st,%st(1)
    7438:	d8 45 d8             	fadds  -0x28(%ebp)
    743b:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    743e:	c9                   	leave  
    743f:	c3                   	ret    

00007440 <sin>:

float sin(float x)
{
    7440:	55                   	push   %ebp
    7441:	89 e5                	mov    %esp,%ebp
    7443:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    7446:	d9 e8                	fld1   
    7448:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    744b:	d9 45 08             	flds   0x8(%ebp)
    744e:	dd 05 00 c9 01 00    	fldl   0x1c900
    7454:	d9 c9                	fxch   %st(1)
    7456:	df e9                	fucomip %st(1),%st
    7458:	dd d8                	fstp   %st(0)
    745a:	77 0f                	ja     746b <sin+0x2b>
    745c:	d9 45 08             	flds   0x8(%ebp)
    745f:	dd 05 08 c9 01 00    	fldl   0x1c908
    7465:	df e9                	fucomip %st(1),%st
    7467:	dd d8                	fstp   %st(0)
    7469:	76 3c                	jbe    74a7 <sin+0x67>
    746b:	d9 45 08             	flds   0x8(%ebp)
    746e:	d9 45 08             	flds   0x8(%ebp)
    7471:	dd 05 00 c9 01 00    	fldl   0x1c900
    7477:	de f9                	fdivrp %st,%st(1)
    7479:	d9 7d e2             	fnstcw -0x1e(%ebp)
    747c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    7480:	b4 0c                	mov    $0xc,%ah
    7482:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    7486:	d9 6d e0             	fldcw  -0x20(%ebp)
    7489:	db 5d dc             	fistpl -0x24(%ebp)
    748c:	d9 6d e2             	fldcw  -0x1e(%ebp)
    748f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7492:	01 c0                	add    %eax,%eax
    7494:	89 45 d8             	mov    %eax,-0x28(%ebp)
    7497:	db 45 d8             	fildl  -0x28(%ebp)
    749a:	dd 05 10 c9 01 00    	fldl   0x1c910
    74a0:	de c9                	fmulp  %st,%st(1)
    74a2:	de e9                	fsubrp %st,%st(1)
    74a4:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    74a7:	d9 45 08             	flds   0x8(%ebp)
    74aa:	dd 05 10 c9 01 00    	fldl   0x1c910
    74b0:	d9 c9                	fxch   %st(1)
    74b2:	df e9                	fucomip %st(1),%st
    74b4:	dd d8                	fstp   %st(0)
    74b6:	76 0e                	jbe    74c6 <sin+0x86>
    74b8:	d9 45 08             	flds   0x8(%ebp)
    74bb:	dd 05 00 c9 01 00    	fldl   0x1c900
    74c1:	de e9                	fsubrp %st,%st(1)
    74c3:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    74c6:	d9 45 08             	flds   0x8(%ebp)
    74c9:	dd 05 18 c9 01 00    	fldl   0x1c918
    74cf:	df e9                	fucomip %st(1),%st
    74d1:	dd d8                	fstp   %st(0)
    74d3:	76 0e                	jbe    74e3 <sin+0xa3>
    74d5:	d9 45 08             	flds   0x8(%ebp)
    74d8:	dd 05 00 c9 01 00    	fldl   0x1c900
    74de:	de c1                	faddp  %st,%st(1)
    74e0:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    74e3:	d9 45 08             	flds   0x8(%ebp)
    74e6:	dd 05 20 c9 01 00    	fldl   0x1c920
    74ec:	d9 c9                	fxch   %st(1)
    74ee:	df e9                	fucomip %st(1),%st
    74f0:	dd d8                	fstp   %st(0)
    74f2:	76 16                	jbe    750a <sin+0xca>
    {
        x -= PI;
    74f4:	d9 45 08             	flds   0x8(%ebp)
    74f7:	dd 05 10 c9 01 00    	fldl   0x1c910
    74fd:	de e9                	fsubrp %st,%st(1)
    74ff:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    7502:	d9 45 f4             	flds   -0xc(%ebp)
    7505:	d9 e0                	fchs   
    7507:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    750a:	d9 45 08             	flds   0x8(%ebp)
    750d:	dd 05 28 c9 01 00    	fldl   0x1c928
    7513:	df e9                	fucomip %st(1),%st
    7515:	dd d8                	fstp   %st(0)
    7517:	76 16                	jbe    752f <sin+0xef>
    {
        x += PI;
    7519:	d9 45 08             	flds   0x8(%ebp)
    751c:	dd 05 10 c9 01 00    	fldl   0x1c910
    7522:	de c1                	faddp  %st,%st(1)
    7524:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    7527:	d9 45 f4             	flds   -0xc(%ebp)
    752a:	d9 e0                	fchs   
    752c:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
    752f:	d9 ee                	fldz   
    7531:	d9 45 08             	flds   0x8(%ebp)
    7534:	d9 c9                	fxch   %st(1)
    7536:	df e9                	fucomip %st(1),%st
    7538:	dd d8                	fstp   %st(0)
    753a:	76 10                	jbe    754c <sin+0x10c>
    {
        x *= -1;
    753c:	d9 45 08             	flds   0x8(%ebp)
    753f:	d9 e0                	fchs   
    7541:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    7544:	d9 45 f4             	flds   -0xc(%ebp)
    7547:	d9 e0                	fchs   
    7549:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
    754c:	d9 45 08             	flds   0x8(%ebp)
    754f:	dd 05 30 c9 01 00    	fldl   0x1c930
    7555:	d9 c9                	fxch   %st(1)
    7557:	df e9                	fucomip %st(1),%st
    7559:	dd d8                	fstp   %st(0)
    755b:	76 28                	jbe    7585 <sin+0x145>
    755d:	d9 45 08             	flds   0x8(%ebp)
    7560:	dd 05 20 c9 01 00    	fldl   0x1c920
    7566:	de e1                	fsubp  %st,%st(1)
    7568:	d9 5d e4             	fstps  -0x1c(%ebp)
    756b:	d9 45 e4             	flds   -0x1c(%ebp)
    756e:	83 ec 0c             	sub    $0xc,%esp
    7571:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    7575:	d9 1c 24             	fstps  (%esp)
    7578:	e8 20 fd ff ff       	call   729d <cos>
    757d:	83 c4 10             	add    $0x10,%esp
    7580:	d8 4d f4             	fmuls  -0xc(%ebp)
    7583:	eb 7a                	jmp    75ff <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
    7585:	83 ec 08             	sub    $0x8,%esp
    7588:	6a 03                	push   $0x3
    758a:	ff 75 08             	pushl  0x8(%ebp)
    758d:	e8 5e fc ff ff       	call   71f0 <pow>
    7592:	83 c4 10             	add    $0x10,%esp
    7595:	d9 05 44 c9 01 00    	flds   0x1c944
    759b:	de f9                	fdivrp %st,%st(1)
    759d:	d9 45 08             	flds   0x8(%ebp)
    75a0:	de e1                	fsubp  %st,%st(1)
    75a2:	d9 5d d8             	fstps  -0x28(%ebp)
    75a5:	83 ec 08             	sub    $0x8,%esp
    75a8:	6a 05                	push   $0x5
    75aa:	ff 75 08             	pushl  0x8(%ebp)
    75ad:	e8 3e fc ff ff       	call   71f0 <pow>
    75b2:	83 c4 10             	add    $0x10,%esp
    75b5:	d9 05 48 c9 01 00    	flds   0x1c948
    75bb:	de f9                	fdivrp %st,%st(1)
    75bd:	d8 45 d8             	fadds  -0x28(%ebp)
    75c0:	d9 5d d8             	fstps  -0x28(%ebp)
    75c3:	83 ec 08             	sub    $0x8,%esp
    75c6:	6a 07                	push   $0x7
    75c8:	ff 75 08             	pushl  0x8(%ebp)
    75cb:	e8 20 fc ff ff       	call   71f0 <pow>
    75d0:	83 c4 10             	add    $0x10,%esp
    75d3:	d9 05 4c c9 01 00    	flds   0x1c94c
    75d9:	de f9                	fdivrp %st,%st(1)
    75db:	d8 6d d8             	fsubrs -0x28(%ebp)
    75de:	d9 5d d8             	fstps  -0x28(%ebp)
    75e1:	83 ec 08             	sub    $0x8,%esp
    75e4:	6a 09                	push   $0x9
    75e6:	ff 75 08             	pushl  0x8(%ebp)
    75e9:	e8 02 fc ff ff       	call   71f0 <pow>
    75ee:	83 c4 10             	add    $0x10,%esp
    75f1:	d9 05 50 c9 01 00    	flds   0x1c950
    75f7:	de f9                	fdivrp %st,%st(1)
    75f9:	d8 45 d8             	fadds  -0x28(%ebp)
    75fc:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    75ff:	c9                   	leave  
    7600:	c3                   	ret    

00007601 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
    7601:	55                   	push   %ebp
    7602:	89 e5                	mov    %esp,%ebp
    7604:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    7607:	83 ec 04             	sub    $0x4,%esp
    760a:	6a 0e                	push   $0xe
    760c:	ff 75 0c             	pushl  0xc(%ebp)
    760f:	ff 75 08             	pushl  0x8(%ebp)
    7612:	e8 44 f6 ff ff       	call   6c5b <read>
    7617:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    761a:	83 ec 04             	sub    $0x4,%esp
    761d:	6a 28                	push   $0x28
    761f:	ff 75 10             	pushl  0x10(%ebp)
    7622:	ff 75 08             	pushl  0x8(%ebp)
    7625:	e8 31 f6 ff ff       	call   6c5b <read>
    762a:	83 c4 10             	add    $0x10,%esp
}
    762d:	90                   	nop
    762e:	c9                   	leave  
    762f:	c3                   	ret    

00007630 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
    7630:	55                   	push   %ebp
    7631:	89 e5                	mov    %esp,%ebp
    7633:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    7639:	83 ec 08             	sub    $0x8,%esp
    763c:	6a 00                	push   $0x0
    763e:	ff 75 08             	pushl  0x8(%ebp)
    7641:	e8 3d f6 ff ff       	call   6c83 <open>
    7646:	83 c4 10             	add    $0x10,%esp
    7649:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    764c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    7650:	79 0a                	jns    765c <readBitmapFile+0x2c>
        return -1;
    7652:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    7657:	e9 6e 01 00 00       	jmp    77ca <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    765c:	83 ec 04             	sub    $0x4,%esp
    765f:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    7662:	50                   	push   %eax
    7663:	8d 45 ca             	lea    -0x36(%ebp),%eax
    7666:	50                   	push   %eax
    7667:	ff 75 ec             	pushl  -0x14(%ebp)
    766a:	e8 92 ff ff ff       	call   7601 <readBitmapHeader>
    766f:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    7672:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7675:	83 e8 36             	sub    $0x36,%eax
    7678:	83 ec 04             	sub    $0x4,%esp
    767b:	50                   	push   %eax
    767c:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    7682:	50                   	push   %eax
    7683:	ff 75 ec             	pushl  -0x14(%ebp)
    7686:	e8 d0 f5 ff ff       	call   6c5b <read>
    768b:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    768e:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    7691:	8b 45 14             	mov    0x14(%ebp),%eax
    7694:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    7696:	8b 55 aa             	mov    -0x56(%ebp),%edx
    7699:	8b 45 10             	mov    0x10(%ebp),%eax
    769c:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    769e:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    76a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    76a4:	8b 45 aa             	mov    -0x56(%ebp),%eax
    76a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    76aa:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    76ae:	0f b7 c0             	movzwl %ax,%eax
    76b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    76b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76b7:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    76bb:	8d 50 07             	lea    0x7(%eax),%edx
    76be:	85 c0                	test   %eax,%eax
    76c0:	0f 48 c2             	cmovs  %edx,%eax
    76c3:	c1 f8 03             	sar    $0x3,%eax
    76c6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    76c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    76cc:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    76cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    76d2:	83 e8 01             	sub    $0x1,%eax
    76d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    76d8:	e9 d0 00 00 00       	jmp    77ad <readBitmapFile+0x17d>
        if (bits == 32) {
    76dd:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    76e1:	75 22                	jne    7705 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    76e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    76e6:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    76ea:	89 c2                	mov    %eax,%edx
    76ec:	8b 45 d8             	mov    -0x28(%ebp),%eax
    76ef:	01 d0                	add    %edx,%eax
    76f1:	83 ec 04             	sub    $0x4,%esp
    76f4:	ff 75 dc             	pushl  -0x24(%ebp)
    76f7:	50                   	push   %eax
    76f8:	ff 75 ec             	pushl  -0x14(%ebp)
    76fb:	e8 5b f5 ff ff       	call   6c5b <read>
    7700:	83 c4 10             	add    $0x10,%esp
    7703:	eb 65                	jmp    776a <readBitmapFile+0x13a>
        } else {
            int j = 0;
    7705:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    770c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7713:	eb 4d                	jmp    7762 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    7715:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7718:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    771c:	c1 e0 02             	shl    $0x2,%eax
    771f:	89 c2                	mov    %eax,%edx
    7721:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7724:	c1 e0 02             	shl    $0x2,%eax
    7727:	01 c2                	add    %eax,%edx
    7729:	8b 45 d8             	mov    -0x28(%ebp),%eax
    772c:	01 d0                	add    %edx,%eax
    772e:	83 ec 04             	sub    $0x4,%esp
    7731:	6a 03                	push   $0x3
    7733:	50                   	push   %eax
    7734:	ff 75 ec             	pushl  -0x14(%ebp)
    7737:	e8 1f f5 ff ff       	call   6c5b <read>
    773c:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    773f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7742:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    7746:	c1 e0 02             	shl    $0x2,%eax
    7749:	89 c2                	mov    %eax,%edx
    774b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    774e:	c1 e0 02             	shl    $0x2,%eax
    7751:	01 d0                	add    %edx,%eax
    7753:	8d 50 03             	lea    0x3(%eax),%edx
    7756:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7759:	01 d0                	add    %edx,%eax
    775b:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    775e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7762:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7765:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7768:	7c ab                	jl     7715 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    776a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    776d:	99                   	cltd   
    776e:	c1 ea 1e             	shr    $0x1e,%edx
    7771:	01 d0                	add    %edx,%eax
    7773:	83 e0 03             	and    $0x3,%eax
    7776:	29 d0                	sub    %edx,%eax
    7778:	85 c0                	test   %eax,%eax
    777a:	7e 2d                	jle    77a9 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    777c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    777f:	99                   	cltd   
    7780:	c1 ea 1e             	shr    $0x1e,%edx
    7783:	01 d0                	add    %edx,%eax
    7785:	83 e0 03             	and    $0x3,%eax
    7788:	29 d0                	sub    %edx,%eax
    778a:	ba 04 00 00 00       	mov    $0x4,%edx
    778f:	29 c2                	sub    %eax,%edx
    7791:	89 d0                	mov    %edx,%eax
    7793:	83 ec 04             	sub    $0x4,%esp
    7796:	50                   	push   %eax
    7797:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    779d:	50                   	push   %eax
    779e:	ff 75 ec             	pushl  -0x14(%ebp)
    77a1:	e8 b5 f4 ff ff       	call   6c5b <read>
    77a6:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    77a9:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    77ad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77b1:	0f 89 26 ff ff ff    	jns    76dd <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    77b7:	83 ec 0c             	sub    $0xc,%esp
    77ba:	ff 75 ec             	pushl  -0x14(%ebp)
    77bd:	e8 a9 f4 ff ff       	call   6c6b <close>
    77c2:	83 c4 10             	add    $0x10,%esp
    return 0;
    77c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    77ca:	c9                   	leave  
    77cb:	c3                   	ret    

000077cc <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    77cc:	55                   	push   %ebp
    77cd:	89 e5                	mov    %esp,%ebp
    77cf:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    77d5:	83 ec 08             	sub    $0x8,%esp
    77d8:	6a 00                	push   $0x0
    77da:	ff 75 08             	pushl  0x8(%ebp)
    77dd:	e8 a1 f4 ff ff       	call   6c83 <open>
    77e2:	83 c4 10             	add    $0x10,%esp
    77e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    77e8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    77ec:	79 0a                	jns    77f8 <read24BitmapFile+0x2c>
        return -1;
    77ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    77f3:	e9 66 01 00 00       	jmp    795e <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    77f8:	83 ec 04             	sub    $0x4,%esp
    77fb:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    77fe:	50                   	push   %eax
    77ff:	8d 45 ca             	lea    -0x36(%ebp),%eax
    7802:	50                   	push   %eax
    7803:	ff 75 ec             	pushl  -0x14(%ebp)
    7806:	e8 f6 fd ff ff       	call   7601 <readBitmapHeader>
    780b:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    780e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7811:	83 e8 36             	sub    $0x36,%eax
    7814:	83 ec 04             	sub    $0x4,%esp
    7817:	50                   	push   %eax
    7818:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    781e:	50                   	push   %eax
    781f:	ff 75 ec             	pushl  -0x14(%ebp)
    7822:	e8 34 f4 ff ff       	call   6c5b <read>
    7827:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    782a:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    782d:	8b 45 14             	mov    0x14(%ebp),%eax
    7830:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    7832:	8b 55 aa             	mov    -0x56(%ebp),%edx
    7835:	8b 45 10             	mov    0x10(%ebp),%eax
    7838:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    783a:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    783d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    7840:	8b 45 aa             	mov    -0x56(%ebp),%eax
    7843:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    7846:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    784a:	0f b7 c0             	movzwl %ax,%eax
    784d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    7850:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7853:	89 d0                	mov    %edx,%eax
    7855:	01 c0                	add    %eax,%eax
    7857:	01 d0                	add    %edx,%eax
    7859:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    785c:	8b 45 0c             	mov    0xc(%ebp),%eax
    785f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    7862:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7865:	83 e8 01             	sub    $0x1,%eax
    7868:	89 45 f4             	mov    %eax,-0xc(%ebp)
    786b:	e9 d1 00 00 00       	jmp    7941 <read24BitmapFile+0x175>
        if (bits == 24) {
    7870:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    7874:	75 22                	jne    7898 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    7876:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7879:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    787d:	89 c2                	mov    %eax,%edx
    787f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7882:	01 d0                	add    %edx,%eax
    7884:	83 ec 04             	sub    $0x4,%esp
    7887:	ff 75 dc             	pushl  -0x24(%ebp)
    788a:	50                   	push   %eax
    788b:	ff 75 ec             	pushl  -0x14(%ebp)
    788e:	e8 c8 f3 ff ff       	call   6c5b <read>
    7893:	83 c4 10             	add    $0x10,%esp
    7896:	eb 66                	jmp    78fe <read24BitmapFile+0x132>
        } else {
            int j = 0;
    7898:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    789f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    78a6:	eb 4e                	jmp    78f6 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    78a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    78ab:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    78af:	89 c2                	mov    %eax,%edx
    78b1:	89 d0                	mov    %edx,%eax
    78b3:	01 c0                	add    %eax,%eax
    78b5:	01 d0                	add    %edx,%eax
    78b7:	89 c1                	mov    %eax,%ecx
    78b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    78bc:	89 d0                	mov    %edx,%eax
    78be:	01 c0                	add    %eax,%eax
    78c0:	01 d0                	add    %edx,%eax
    78c2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    78c5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78c8:	01 d0                	add    %edx,%eax
    78ca:	83 ec 04             	sub    $0x4,%esp
    78cd:	6a 03                	push   $0x3
    78cf:	50                   	push   %eax
    78d0:	ff 75 ec             	pushl  -0x14(%ebp)
    78d3:	e8 83 f3 ff ff       	call   6c5b <read>
    78d8:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    78db:	83 ec 04             	sub    $0x4,%esp
    78de:	6a 01                	push   $0x1
    78e0:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    78e6:	50                   	push   %eax
    78e7:	ff 75 ec             	pushl  -0x14(%ebp)
    78ea:	e8 6c f3 ff ff       	call   6c5b <read>
    78ef:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    78f2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    78f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    78f9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    78fc:	7c aa                	jl     78a8 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    78fe:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7901:	99                   	cltd   
    7902:	c1 ea 1e             	shr    $0x1e,%edx
    7905:	01 d0                	add    %edx,%eax
    7907:	83 e0 03             	and    $0x3,%eax
    790a:	29 d0                	sub    %edx,%eax
    790c:	85 c0                	test   %eax,%eax
    790e:	7e 2d                	jle    793d <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    7910:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7913:	99                   	cltd   
    7914:	c1 ea 1e             	shr    $0x1e,%edx
    7917:	01 d0                	add    %edx,%eax
    7919:	83 e0 03             	and    $0x3,%eax
    791c:	29 d0                	sub    %edx,%eax
    791e:	ba 04 00 00 00       	mov    $0x4,%edx
    7923:	29 c2                	sub    %eax,%edx
    7925:	89 d0                	mov    %edx,%eax
    7927:	83 ec 04             	sub    $0x4,%esp
    792a:	50                   	push   %eax
    792b:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    7931:	50                   	push   %eax
    7932:	ff 75 ec             	pushl  -0x14(%ebp)
    7935:	e8 21 f3 ff ff       	call   6c5b <read>
    793a:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    793d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    7941:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7945:	0f 89 25 ff ff ff    	jns    7870 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    794b:	83 ec 0c             	sub    $0xc,%esp
    794e:	ff 75 ec             	pushl  -0x14(%ebp)
    7951:	e8 15 f3 ff ff       	call   6c6b <close>
    7956:	83 c4 10             	add    $0x10,%esp
    return 0;
    7959:	b8 00 00 00 00       	mov    $0x0,%eax
}
    795e:	c9                   	leave  
    795f:	c3                   	ret    

00007960 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    7960:	55                   	push   %ebp
    7961:	89 e5                	mov    %esp,%ebp
    7963:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    7966:	8b 55 10             	mov    0x10(%ebp),%edx
    7969:	89 d0                	mov    %edx,%eax
    796b:	01 c0                	add    %eax,%eax
    796d:	01 d0                	add    %edx,%eax
    796f:	c1 e0 03             	shl    $0x3,%eax
    7972:	83 c0 1f             	add    $0x1f,%eax
    7975:	8d 50 1f             	lea    0x1f(%eax),%edx
    7978:	85 c0                	test   %eax,%eax
    797a:	0f 48 c2             	cmovs  %edx,%eax
    797d:	c1 f8 05             	sar    $0x5,%eax
    7980:	c1 e0 02             	shl    $0x2,%eax
    7983:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    7986:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    798c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    798f:	0f af 45 0c          	imul   0xc(%ebp),%eax
    7993:	83 c0 36             	add    $0x36,%eax
    7996:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    7999:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    799f:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    79a5:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    79ac:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    79b3:	8b 45 10             	mov    0x10(%ebp),%eax
    79b6:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    79b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    79bc:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    79bf:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    79c5:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    79cb:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    79d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    79d5:	0f af 45 0c          	imul   0xc(%ebp),%eax
    79d9:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    79dc:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    79e3:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    79ea:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    79f1:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    79f8:	83 ec 04             	sub    $0x4,%esp
    79fb:	6a 0e                	push   $0xe
    79fd:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    7a00:	50                   	push   %eax
    7a01:	ff 75 08             	pushl  0x8(%ebp)
    7a04:	e8 5a f2 ff ff       	call   6c63 <write>
    7a09:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    7a0c:	83 ec 04             	sub    $0x4,%esp
    7a0f:	6a 28                	push   $0x28
    7a11:	8d 45 be             	lea    -0x42(%ebp),%eax
    7a14:	50                   	push   %eax
    7a15:	ff 75 08             	pushl  0x8(%ebp)
    7a18:	e8 46 f2 ff ff       	call   6c63 <write>
    7a1d:	83 c4 10             	add    $0x10,%esp
}
    7a20:	90                   	nop
    7a21:	c9                   	leave  
    7a22:	c3                   	ret    

00007a23 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    7a23:	55                   	push   %ebp
    7a24:	89 e5                	mov    %esp,%ebp
    7a26:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    7a29:	83 ec 08             	sub    $0x8,%esp
    7a2c:	68 02 02 00 00       	push   $0x202
    7a31:	ff 75 08             	pushl  0x8(%ebp)
    7a34:	e8 4a f2 ff ff       	call   6c83 <open>
    7a39:	83 c4 10             	add    $0x10,%esp
    7a3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    7a3f:	8b 55 14             	mov    0x14(%ebp),%edx
    7a42:	89 d0                	mov    %edx,%eax
    7a44:	01 c0                	add    %eax,%eax
    7a46:	01 d0                	add    %edx,%eax
    7a48:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    7a4b:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    7a4f:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    7a53:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    7a57:	83 ec 04             	sub    $0x4,%esp
    7a5a:	ff 75 14             	pushl  0x14(%ebp)
    7a5d:	ff 75 10             	pushl  0x10(%ebp)
    7a60:	ff 75 f0             	pushl  -0x10(%ebp)
    7a63:	e8 f8 fe ff ff       	call   7960 <write24BitmapFileHeader>
    7a68:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    7a6b:	8b 45 10             	mov    0x10(%ebp),%eax
    7a6e:	83 e8 01             	sub    $0x1,%eax
    7a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7a74:	eb 66                	jmp    7adc <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    7a76:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7a79:	0f af 45 14          	imul   0x14(%ebp),%eax
    7a7d:	89 c2                	mov    %eax,%edx
    7a7f:	89 d0                	mov    %edx,%eax
    7a81:	01 c0                	add    %eax,%eax
    7a83:	01 c2                	add    %eax,%edx
    7a85:	8b 45 0c             	mov    0xc(%ebp),%eax
    7a88:	01 d0                	add    %edx,%eax
    7a8a:	83 ec 04             	sub    $0x4,%esp
    7a8d:	ff 75 ec             	pushl  -0x14(%ebp)
    7a90:	50                   	push   %eax
    7a91:	ff 75 f0             	pushl  -0x10(%ebp)
    7a94:	e8 ca f1 ff ff       	call   6c63 <write>
    7a99:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    7a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a9f:	99                   	cltd   
    7aa0:	c1 ea 1e             	shr    $0x1e,%edx
    7aa3:	01 d0                	add    %edx,%eax
    7aa5:	83 e0 03             	and    $0x3,%eax
    7aa8:	29 d0                	sub    %edx,%eax
    7aaa:	85 c0                	test   %eax,%eax
    7aac:	7e 2a                	jle    7ad8 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    7aae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7ab1:	99                   	cltd   
    7ab2:	c1 ea 1e             	shr    $0x1e,%edx
    7ab5:	01 d0                	add    %edx,%eax
    7ab7:	83 e0 03             	and    $0x3,%eax
    7aba:	29 d0                	sub    %edx,%eax
    7abc:	ba 04 00 00 00       	mov    $0x4,%edx
    7ac1:	29 c2                	sub    %eax,%edx
    7ac3:	89 d0                	mov    %edx,%eax
    7ac5:	83 ec 04             	sub    $0x4,%esp
    7ac8:	50                   	push   %eax
    7ac9:	8d 45 e9             	lea    -0x17(%ebp),%eax
    7acc:	50                   	push   %eax
    7acd:	ff 75 f0             	pushl  -0x10(%ebp)
    7ad0:	e8 8e f1 ff ff       	call   6c63 <write>
    7ad5:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    7ad8:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    7adc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ae0:	79 94                	jns    7a76 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    7ae2:	83 ec 0c             	sub    $0xc,%esp
    7ae5:	ff 75 f0             	pushl  -0x10(%ebp)
    7ae8:	e8 7e f1 ff ff       	call   6c6b <close>
    7aed:	83 c4 10             	add    $0x10,%esp
    return 0;
    7af0:	b8 00 00 00 00       	mov    $0x0,%eax
    7af5:	c9                   	leave  
    7af6:	c3                   	ret    

00007af7 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    7af7:	55                   	push   %ebp
    7af8:	89 e5                	mov    %esp,%ebp
    7afa:	57                   	push   %edi
    7afb:	56                   	push   %esi
    7afc:	53                   	push   %ebx
    7afd:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    7b00:	8b 45 08             	mov    0x8(%ebp),%eax
    7b03:	8b 50 10             	mov    0x10(%eax),%edx
    7b06:	8b 40 0c             	mov    0xc(%eax),%eax
    7b09:	89 45 e0             	mov    %eax,-0x20(%ebp)
    7b0c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    7b0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7b12:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7b15:	83 c2 1e             	add    $0x1e,%edx
    7b18:	0f af d0             	imul   %eax,%edx
    7b1b:	89 d0                	mov    %edx,%eax
    7b1d:	01 c0                	add    %eax,%eax
    7b1f:	01 d0                	add    %edx,%eax
    7b21:	83 ec 0c             	sub    $0xc,%esp
    7b24:	50                   	push   %eax
    7b25:	e8 93 f5 ff ff       	call   70bd <malloc>
    7b2a:	83 c4 10             	add    $0x10,%esp
    7b2d:	89 c2                	mov    %eax,%edx
    7b2f:	8b 45 08             	mov    0x8(%ebp),%eax
    7b32:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    7b35:	8b 45 08             	mov    0x8(%ebp),%eax
    7b38:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b3b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7b3e:	6b d2 5a             	imul   $0x5a,%edx,%edx
    7b41:	01 c2                	add    %eax,%edx
    7b43:	8b 45 08             	mov    0x8(%ebp),%eax
    7b46:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    7b49:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7b4c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7b4f:	0f af d0             	imul   %eax,%edx
    7b52:	89 d0                	mov    %edx,%eax
    7b54:	01 c0                	add    %eax,%eax
    7b56:	01 d0                	add    %edx,%eax
    7b58:	89 c2                	mov    %eax,%edx
    7b5a:	8b 45 08             	mov    0x8(%ebp),%eax
    7b5d:	8b 40 18             	mov    0x18(%eax),%eax
    7b60:	83 ec 04             	sub    $0x4,%esp
    7b63:	52                   	push   %edx
    7b64:	68 ff 00 00 00       	push   $0xff
    7b69:	50                   	push   %eax
    7b6a:	e8 39 ef ff ff       	call   6aa8 <memset>
    7b6f:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    7b72:	8b 45 08             	mov    0x8(%ebp),%eax
    7b75:	8b 78 1c             	mov    0x1c(%eax),%edi
    7b78:	8b 45 08             	mov    0x8(%ebp),%eax
    7b7b:	8b 70 14             	mov    0x14(%eax),%esi
    7b7e:	8b 45 08             	mov    0x8(%ebp),%eax
    7b81:	8b 58 0c             	mov    0xc(%eax),%ebx
    7b84:	8b 45 08             	mov    0x8(%ebp),%eax
    7b87:	8b 48 10             	mov    0x10(%eax),%ecx
    7b8a:	8b 45 08             	mov    0x8(%ebp),%eax
    7b8d:	8b 50 08             	mov    0x8(%eax),%edx
    7b90:	8b 45 08             	mov    0x8(%ebp),%eax
    7b93:	8b 40 04             	mov    0x4(%eax),%eax
    7b96:	83 ec 08             	sub    $0x8,%esp
    7b99:	57                   	push   %edi
    7b9a:	56                   	push   %esi
    7b9b:	53                   	push   %ebx
    7b9c:	51                   	push   %ecx
    7b9d:	52                   	push   %edx
    7b9e:	50                   	push   %eax
    7b9f:	e8 3f f1 ff ff       	call   6ce3 <createwindow>
    7ba4:	83 c4 20             	add    $0x20,%esp
    7ba7:	89 c2                	mov    %eax,%edx
    7ba9:	8b 45 08             	mov    0x8(%ebp),%eax
    7bac:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    7bae:	8b 45 08             	mov    0x8(%ebp),%eax
    7bb1:	8b 00                	mov    (%eax),%eax
}
    7bb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    7bb6:	5b                   	pop    %ebx
    7bb7:	5e                   	pop    %esi
    7bb8:	5f                   	pop    %edi
    7bb9:	5d                   	pop    %ebp
    7bba:	c3                   	ret    

00007bbb <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    7bbb:	55                   	push   %ebp
    7bbc:	89 e5                	mov    %esp,%ebp
    7bbe:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    7bc1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7bc8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7bcf:	8b 45 08             	mov    0x8(%ebp),%eax
    7bd2:	8b 40 18             	mov    0x18(%eax),%eax
    7bd5:	ff 75 1c             	pushl  0x1c(%ebp)
    7bd8:	ff 75 18             	pushl  0x18(%ebp)
    7bdb:	ff 75 1c             	pushl  0x1c(%ebp)
    7bde:	ff 75 18             	pushl  0x18(%ebp)
    7be1:	8b 55 08             	mov    0x8(%ebp),%edx
    7be4:	ff 72 10             	pushl  0x10(%edx)
    7be7:	ff 72 0c             	pushl  0xc(%edx)
    7bea:	ff 75 f4             	pushl  -0xc(%ebp)
    7bed:	ff 75 f0             	pushl  -0x10(%ebp)
    7bf0:	ff 75 14             	pushl  0x14(%ebp)
    7bf3:	ff 75 10             	pushl  0x10(%ebp)
    7bf6:	ff 75 0c             	pushl  0xc(%ebp)
    7bf9:	50                   	push   %eax
    7bfa:	e8 d5 07 00 00       	call   83d4 <drawBitmap>
    7bff:	83 c4 30             	add    $0x30,%esp
    return 0;
    7c02:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7c07:	c9                   	leave  
    7c08:	c3                   	ret    

00007c09 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    7c09:	55                   	push   %ebp
    7c0a:	89 e5                	mov    %esp,%ebp
    7c0c:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    7c0f:	8b 45 08             	mov    0x8(%ebp),%eax
    7c12:	8b 40 18             	mov    0x18(%eax),%eax
    7c15:	ff 75 2c             	pushl  0x2c(%ebp)
    7c18:	ff 75 28             	pushl  0x28(%ebp)
    7c1b:	ff 75 24             	pushl  0x24(%ebp)
    7c1e:	ff 75 20             	pushl  0x20(%ebp)
    7c21:	8b 55 08             	mov    0x8(%ebp),%edx
    7c24:	ff 72 10             	pushl  0x10(%edx)
    7c27:	ff 72 0c             	pushl  0xc(%edx)
    7c2a:	ff 75 1c             	pushl  0x1c(%ebp)
    7c2d:	ff 75 18             	pushl  0x18(%ebp)
    7c30:	ff 75 14             	pushl  0x14(%ebp)
    7c33:	ff 75 10             	pushl  0x10(%ebp)
    7c36:	ff 75 0c             	pushl  0xc(%ebp)
    7c39:	50                   	push   %eax
    7c3a:	e8 95 07 00 00       	call   83d4 <drawBitmap>
    7c3f:	83 c4 30             	add    $0x30,%esp
    return 0;
    7c42:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7c47:	c9                   	leave  
    7c48:	c3                   	ret    

00007c49 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    7c49:	55                   	push   %ebp
    7c4a:	89 e5                	mov    %esp,%ebp
    7c4c:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    7c4f:	8b 45 08             	mov    0x8(%ebp),%eax
    7c52:	8b 40 18             	mov    0x18(%eax),%eax
    7c55:	ff 75 2c             	pushl  0x2c(%ebp)
    7c58:	ff 75 28             	pushl  0x28(%ebp)
    7c5b:	ff 75 24             	pushl  0x24(%ebp)
    7c5e:	ff 75 20             	pushl  0x20(%ebp)
    7c61:	8b 55 08             	mov    0x8(%ebp),%edx
    7c64:	ff 72 10             	pushl  0x10(%edx)
    7c67:	ff 72 0c             	pushl  0xc(%edx)
    7c6a:	ff 75 1c             	pushl  0x1c(%ebp)
    7c6d:	ff 75 18             	pushl  0x18(%ebp)
    7c70:	ff 75 14             	pushl  0x14(%ebp)
    7c73:	ff 75 10             	pushl  0x10(%ebp)
    7c76:	ff 75 0c             	pushl  0xc(%ebp)
    7c79:	50                   	push   %eax
    7c7a:	e8 75 08 00 00       	call   84f4 <drawTransparentBitmap>
    7c7f:	83 c4 30             	add    $0x30,%esp
    return 0;
    7c82:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7c87:	c9                   	leave  
    7c88:	c3                   	ret    

00007c89 <api_repaint>:

int api_repaint(Window* wnd)
{
    7c89:	55                   	push   %ebp
    7c8a:	89 e5                	mov    %esp,%ebp
    7c8c:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    7c8f:	8b 45 08             	mov    0x8(%ebp),%eax
    7c92:	8b 00                	mov    (%eax),%eax
    7c94:	83 ec 0c             	sub    $0xc,%esp
    7c97:	50                   	push   %eax
    7c98:	e8 4e f0 ff ff       	call   6ceb <repaintwindow>
    7c9d:	83 c4 10             	add    $0x10,%esp
    return 0;
    7ca0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7ca5:	c9                   	leave  
    7ca6:	c3                   	ret    

00007ca7 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    7ca7:	55                   	push   %ebp
    7ca8:	89 e5                	mov    %esp,%ebp
    7caa:	56                   	push   %esi
    7cab:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    7cac:	8b 75 18             	mov    0x18(%ebp),%esi
    7caf:	8b 5d 14             	mov    0x14(%ebp),%ebx
    7cb2:	8b 4d 10             	mov    0x10(%ebp),%ecx
    7cb5:	8b 55 0c             	mov    0xc(%ebp),%edx
    7cb8:	8b 45 08             	mov    0x8(%ebp),%eax
    7cbb:	8b 00                	mov    (%eax),%eax
    7cbd:	83 ec 0c             	sub    $0xc,%esp
    7cc0:	56                   	push   %esi
    7cc1:	53                   	push   %ebx
    7cc2:	51                   	push   %ecx
    7cc3:	52                   	push   %edx
    7cc4:	50                   	push   %eax
    7cc5:	e8 39 f0 ff ff       	call   6d03 <updatewindow>
    7cca:	83 c4 20             	add    $0x20,%esp
    return 0;
    7ccd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7cd2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7cd5:	5b                   	pop    %ebx
    7cd6:	5e                   	pop    %esi
    7cd7:	5d                   	pop    %ebp
    7cd8:	c3                   	ret    

00007cd9 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    7cd9:	55                   	push   %ebp
    7cda:	89 e5                	mov    %esp,%ebp
    7cdc:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    7cdf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    7ce6:	8b 45 08             	mov    0x8(%ebp),%eax
    7ce9:	8b 00                	mov    (%eax),%eax
    7ceb:	83 ec 08             	sub    $0x8,%esp
    7cee:	8d 55 c8             	lea    -0x38(%ebp),%edx
    7cf1:	52                   	push   %edx
    7cf2:	50                   	push   %eax
    7cf3:	e8 fb ef ff ff       	call   6cf3 <getmessage>
    7cf8:	83 c4 10             	add    $0x10,%esp
    7cfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    7cfe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d02:	74 e2                	je     7ce6 <api_exec+0xd>
        {
            pf(&msg);
    7d04:	83 ec 0c             	sub    $0xc,%esp
    7d07:	8d 45 c8             	lea    -0x38(%ebp),%eax
    7d0a:	50                   	push   %eax
    7d0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d0e:	ff d0                	call   *%eax
    7d10:	83 c4 10             	add    $0x10,%esp
        }
    }
    7d13:	eb d1                	jmp    7ce6 <api_exec+0xd>

00007d15 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    7d15:	55                   	push   %ebp
    7d16:	89 e5                	mov    %esp,%ebp
    7d18:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    7d1b:	8b 45 08             	mov    0x8(%ebp),%eax
    7d1e:	8b 00                	mov    (%eax),%eax
    7d20:	83 ec 08             	sub    $0x8,%esp
    7d23:	ff 75 0c             	pushl  0xc(%ebp)
    7d26:	50                   	push   %eax
    7d27:	e8 cf ef ff ff       	call   6cfb <settimer>
    7d2c:	83 c4 10             	add    $0x10,%esp
    return 0;
    7d2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7d34:	c9                   	leave  
    7d35:	c3                   	ret    

00007d36 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    7d36:	55                   	push   %ebp
    7d37:	89 e5                	mov    %esp,%ebp
    7d39:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    7d3c:	8b 45 08             	mov    0x8(%ebp),%eax
    7d3f:	8b 50 18             	mov    0x18(%eax),%edx
    7d42:	ff 75 18             	pushl  0x18(%ebp)
    7d45:	ff 75 14             	pushl  0x14(%ebp)
    7d48:	83 ec 04             	sub    $0x4,%esp
    7d4b:	89 e0                	mov    %esp,%eax
    7d4d:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    7d51:	66 89 08             	mov    %cx,(%eax)
    7d54:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    7d58:	88 48 02             	mov    %cl,0x2(%eax)
    7d5b:	8b 45 08             	mov    0x8(%ebp),%eax
    7d5e:	ff 70 10             	pushl  0x10(%eax)
    7d61:	ff 70 0c             	pushl  0xc(%eax)
    7d64:	ff 75 10             	pushl  0x10(%ebp)
    7d67:	ff 75 0c             	pushl  0xc(%ebp)
    7d6a:	52                   	push   %edx
    7d6b:	e8 6f 04 00 00       	call   81df <drawRect>
    7d70:	83 c4 20             	add    $0x20,%esp
    return 0;
    7d73:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7d78:	c9                   	leave  
    7d79:	c3                   	ret    

00007d7a <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    7d7a:	55                   	push   %ebp
    7d7b:	89 e5                	mov    %esp,%ebp
    7d7d:	83 ec 28             	sub    $0x28,%esp
    7d80:	8b 45 14             	mov    0x14(%ebp),%eax
    7d83:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    7d86:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    7d8a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7d90:	8b 45 10             	mov    0x10(%ebp),%eax
    7d93:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7d96:	8b 45 08             	mov    0x8(%ebp),%eax
    7d99:	8b 40 18             	mov    0x18(%eax),%eax
    7d9c:	83 ec 04             	sub    $0x4,%esp
    7d9f:	ff 75 18             	pushl  0x18(%ebp)
    7da2:	52                   	push   %edx
    7da3:	8b 55 08             	mov    0x8(%ebp),%edx
    7da6:	ff 72 10             	pushl  0x10(%edx)
    7da9:	ff 72 0c             	pushl  0xc(%edx)
    7dac:	ff 75 f4             	pushl  -0xc(%ebp)
    7daf:	ff 75 f0             	pushl  -0x10(%ebp)
    7db2:	50                   	push   %eax
    7db3:	e8 d4 02 00 00       	call   808c <drawCharacter>
    7db8:	83 c4 20             	add    $0x20,%esp
    return 0;
    7dbb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7dc0:	c9                   	leave  
    7dc1:	c3                   	ret    

00007dc2 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    7dc2:	55                   	push   %ebp
    7dc3:	89 e5                	mov    %esp,%ebp
    7dc5:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    7dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dcb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7dce:	8b 45 10             	mov    0x10(%ebp),%eax
    7dd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7dd4:	8b 45 08             	mov    0x8(%ebp),%eax
    7dd7:	8b 40 18             	mov    0x18(%eax),%eax
    7dda:	83 ec 04             	sub    $0x4,%esp
    7ddd:	ff 75 18             	pushl  0x18(%ebp)
    7de0:	ff 75 14             	pushl  0x14(%ebp)
    7de3:	8b 55 08             	mov    0x8(%ebp),%edx
    7de6:	ff 72 10             	pushl  0x10(%edx)
    7de9:	ff 72 0c             	pushl  0xc(%edx)
    7dec:	ff 75 f4             	pushl  -0xc(%ebp)
    7def:	ff 75 f0             	pushl  -0x10(%ebp)
    7df2:	50                   	push   %eax
    7df3:	e8 8e 03 00 00       	call   8186 <drawString>
    7df8:	83 c4 20             	add    $0x20,%esp
    return 0;
    7dfb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7e00:	c9                   	leave  
    7e01:	c3                   	ret    

00007e02 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    7e02:	55                   	push   %ebp
    7e03:	89 e5                	mov    %esp,%ebp
    7e05:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    7e08:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    7e0c:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    7e10:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    7e14:	83 ec 08             	sub    $0x8,%esp
    7e17:	83 ec 04             	sub    $0x4,%esp
    7e1a:	89 e0                	mov    %esp,%eax
    7e1c:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    7e20:	66 89 10             	mov    %dx,(%eax)
    7e23:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    7e27:	88 50 02             	mov    %dl,0x2(%eax)
    7e2a:	ff 75 18             	pushl  0x18(%ebp)
    7e2d:	ff 75 14             	pushl  0x14(%ebp)
    7e30:	ff 75 10             	pushl  0x10(%ebp)
    7e33:	ff 75 0c             	pushl  0xc(%ebp)
    7e36:	ff 75 08             	pushl  0x8(%ebp)
    7e39:	e8 f8 fe ff ff       	call   7d36 <api_drawRect>
    7e3e:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    7e41:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    7e45:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    7e49:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    7e4d:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    7e51:	8b 45 10             	mov    0x10(%ebp),%eax
    7e54:	8d 50 0a             	lea    0xa(%eax),%edx
    7e57:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e5a:	83 c0 0a             	add    $0xa,%eax
    7e5d:	83 ec 0c             	sub    $0xc,%esp
    7e60:	ff 75 f4             	pushl  -0xc(%ebp)
    7e63:	ff 75 1c             	pushl  0x1c(%ebp)
    7e66:	52                   	push   %edx
    7e67:	50                   	push   %eax
    7e68:	ff 75 08             	pushl  0x8(%ebp)
    7e6b:	e8 52 ff ff ff       	call   7dc2 <api_drawString>
    7e70:	83 c4 20             	add    $0x20,%esp
    return 0;
    7e73:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7e78:	c9                   	leave  
    7e79:	c3                   	ret    

00007e7a <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    7e7a:	55                   	push   %ebp
    7e7b:	89 e5                	mov    %esp,%ebp
    7e7d:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    7e80:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7e87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7e8e:	8b 45 08             	mov    0x8(%ebp),%eax
    7e91:	8b 40 18             	mov    0x18(%eax),%eax
    7e94:	ff 75 1c             	pushl  0x1c(%ebp)
    7e97:	ff 75 18             	pushl  0x18(%ebp)
    7e9a:	ff 75 1c             	pushl  0x1c(%ebp)
    7e9d:	ff 75 18             	pushl  0x18(%ebp)
    7ea0:	8b 55 08             	mov    0x8(%ebp),%edx
    7ea3:	ff 72 10             	pushl  0x10(%edx)
    7ea6:	ff 72 0c             	pushl  0xc(%edx)
    7ea9:	ff 75 f4             	pushl  -0xc(%ebp)
    7eac:	ff 75 f0             	pushl  -0x10(%ebp)
    7eaf:	ff 75 14             	pushl  0x14(%ebp)
    7eb2:	ff 75 10             	pushl  0x10(%ebp)
    7eb5:	ff 75 0c             	pushl  0xc(%ebp)
    7eb8:	50                   	push   %eax
    7eb9:	e8 16 05 00 00       	call   83d4 <drawBitmap>
    7ebe:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    7ec1:	8b 45 08             	mov    0x8(%ebp),%eax
    7ec4:	8b 40 18             	mov    0x18(%eax),%eax
    7ec7:	ff 75 28             	pushl  0x28(%ebp)
    7eca:	ff 75 1c             	pushl  0x1c(%ebp)
    7ecd:	ff 75 18             	pushl  0x18(%ebp)
    7ed0:	8b 55 08             	mov    0x8(%ebp),%edx
    7ed3:	ff 72 10             	pushl  0x10(%edx)
    7ed6:	ff 72 0c             	pushl  0xc(%edx)
    7ed9:	ff 75 14             	pushl  0x14(%ebp)
    7edc:	ff 75 10             	pushl  0x10(%ebp)
    7edf:	50                   	push   %eax
    7ee0:	e8 99 07 00 00       	call   867e <colorShift>
    7ee5:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    7ee8:	8b 45 08             	mov    0x8(%ebp),%eax
    7eeb:	8b 50 18             	mov    0x18(%eax),%edx
    7eee:	83 ec 0c             	sub    $0xc,%esp
    7ef1:	ff 75 20             	pushl  0x20(%ebp)
    7ef4:	ff 75 1c             	pushl  0x1c(%ebp)
    7ef7:	ff 75 18             	pushl  0x18(%ebp)
    7efa:	83 ec 04             	sub    $0x4,%esp
    7efd:	89 e0                	mov    %esp,%eax
    7eff:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    7f03:	66 89 08             	mov    %cx,(%eax)
    7f06:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    7f0a:	88 48 02             	mov    %cl,0x2(%eax)
    7f0d:	8b 45 08             	mov    0x8(%ebp),%eax
    7f10:	ff 70 10             	pushl  0x10(%eax)
    7f13:	ff 70 0c             	pushl  0xc(%eax)
    7f16:	ff 75 14             	pushl  0x14(%ebp)
    7f19:	ff 75 10             	pushl  0x10(%ebp)
    7f1c:	52                   	push   %edx
    7f1d:	e8 6d 03 00 00       	call   828f <drawBorder>
    7f22:	83 c4 30             	add    $0x30,%esp
    return 0;
    7f25:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7f2a:	c9                   	leave  
    7f2b:	c3                   	ret    

00007f2c <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    7f2c:	55                   	push   %ebp
    7f2d:	89 e5                	mov    %esp,%ebp
    7f2f:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    7f32:	8b 45 08             	mov    0x8(%ebp),%eax
    7f35:	8b 00                	mov    (%eax),%eax
    7f37:	83 ec 0c             	sub    $0xc,%esp
    7f3a:	50                   	push   %eax
    7f3b:	e8 cb ed ff ff       	call   6d0b <destroywindow>
    7f40:	83 c4 10             	add    $0x10,%esp
    return 0;
    7f43:	b8 00 00 00 00       	mov    $0x0,%eax
    7f48:	c9                   	leave  
    7f49:	c3                   	ret    

00007f4a <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    7f4a:	55                   	push   %ebp
    7f4b:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    7f4d:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    7f51:	8b 45 08             	mov    0x8(%ebp),%eax
    7f54:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    7f57:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    7f5b:	8b 45 08             	mov    0x8(%ebp),%eax
    7f5e:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    7f61:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    7f65:	8b 45 08             	mov    0x8(%ebp),%eax
    7f68:	88 10                	mov    %dl,(%eax)
}
    7f6a:	90                   	nop
    7f6b:	5d                   	pop    %ebp
    7f6c:	c3                   	ret    

00007f6d <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    7f6d:	55                   	push   %ebp
    7f6e:	89 e5                	mov    %esp,%ebp
    7f70:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    7f73:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    7f77:	3c ff                	cmp    $0xff,%al
    7f79:	75 22                	jne    7f9d <drawPointAlpha+0x30>
        color->R = origin.R;
    7f7b:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    7f7f:	8b 45 08             	mov    0x8(%ebp),%eax
    7f82:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    7f85:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    7f89:	8b 45 08             	mov    0x8(%ebp),%eax
    7f8c:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    7f8f:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    7f93:	8b 45 08             	mov    0x8(%ebp),%eax
    7f96:	88 10                	mov    %dl,(%eax)
        return;
    7f98:	e9 ed 00 00 00       	jmp    808a <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    7f9d:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    7fa1:	84 c0                	test   %al,%al
    7fa3:	0f 84 e0 00 00 00    	je     8089 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    7fa9:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    7fad:	0f b6 c0             	movzbl %al,%eax
    7fb0:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    7fb4:	df 45 e4             	fild   -0x1c(%ebp)
    7fb7:	d9 05 a0 07 02 00    	flds   0x207a0
    7fbd:	de f9                	fdivrp %st,%st(1)
    7fbf:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    7fc2:	8b 45 08             	mov    0x8(%ebp),%eax
    7fc5:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    7fc9:	0f b6 c0             	movzbl %al,%eax
    7fcc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    7fcf:	db 45 e4             	fildl  -0x1c(%ebp)
    7fd2:	d9 e8                	fld1   
    7fd4:	d8 65 fc             	fsubs  -0x4(%ebp)
    7fd7:	de c9                	fmulp  %st,%st(1)
    7fd9:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    7fdd:	0f b6 c0             	movzbl %al,%eax
    7fe0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    7fe3:	db 45 e4             	fildl  -0x1c(%ebp)
    7fe6:	d8 4d fc             	fmuls  -0x4(%ebp)
    7fe9:	de c1                	faddp  %st,%st(1)
    7feb:	d9 7d ee             	fnstcw -0x12(%ebp)
    7fee:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    7ff2:	b4 0c                	mov    $0xc,%ah
    7ff4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    7ff8:	d9 6d ec             	fldcw  -0x14(%ebp)
    7ffb:	df 5d ea             	fistp  -0x16(%ebp)
    7ffe:	d9 6d ee             	fldcw  -0x12(%ebp)
    8001:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    8005:	89 c2                	mov    %eax,%edx
    8007:	8b 45 08             	mov    0x8(%ebp),%eax
    800a:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    800d:	8b 45 08             	mov    0x8(%ebp),%eax
    8010:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8014:	0f b6 c0             	movzbl %al,%eax
    8017:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    801a:	db 45 e4             	fildl  -0x1c(%ebp)
    801d:	d9 e8                	fld1   
    801f:	d8 65 fc             	fsubs  -0x4(%ebp)
    8022:	de c9                	fmulp  %st,%st(1)
    8024:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    8028:	0f b6 c0             	movzbl %al,%eax
    802b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    802e:	db 45 e4             	fildl  -0x1c(%ebp)
    8031:	d8 4d fc             	fmuls  -0x4(%ebp)
    8034:	de c1                	faddp  %st,%st(1)
    8036:	d9 6d ec             	fldcw  -0x14(%ebp)
    8039:	df 5d ea             	fistp  -0x16(%ebp)
    803c:	d9 6d ee             	fldcw  -0x12(%ebp)
    803f:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    8043:	89 c2                	mov    %eax,%edx
    8045:	8b 45 08             	mov    0x8(%ebp),%eax
    8048:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    804b:	8b 45 08             	mov    0x8(%ebp),%eax
    804e:	0f b6 00             	movzbl (%eax),%eax
    8051:	0f b6 c0             	movzbl %al,%eax
    8054:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8057:	db 45 e4             	fildl  -0x1c(%ebp)
    805a:	d9 e8                	fld1   
    805c:	d8 65 fc             	fsubs  -0x4(%ebp)
    805f:	de c9                	fmulp  %st,%st(1)
    8061:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    8065:	0f b6 c0             	movzbl %al,%eax
    8068:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    806b:	db 45 e4             	fildl  -0x1c(%ebp)
    806e:	d8 4d fc             	fmuls  -0x4(%ebp)
    8071:	de c1                	faddp  %st,%st(1)
    8073:	d9 6d ec             	fldcw  -0x14(%ebp)
    8076:	df 5d ea             	fistp  -0x16(%ebp)
    8079:	d9 6d ee             	fldcw  -0x12(%ebp)
    807c:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    8080:	89 c2                	mov    %eax,%edx
    8082:	8b 45 08             	mov    0x8(%ebp),%eax
    8085:	88 10                	mov    %dl,(%eax)
    8087:	eb 01                	jmp    808a <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    8089:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    808a:	c9                   	leave  
    808b:	c3                   	ret    

0000808c <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    808c:	55                   	push   %ebp
    808d:	89 e5                	mov    %esp,%ebp
    808f:	83 ec 14             	sub    $0x14,%esp
    8092:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8095:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    8098:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    809c:	83 e8 20             	sub    $0x20,%eax
    809f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    80a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    80a6:	0f 88 d7 00 00 00    	js     8183 <drawCharacter+0xf7>
    80ac:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    80b0:	0f 8f cd 00 00 00    	jg     8183 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    80b6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    80bd:	e9 b5 00 00 00       	jmp    8177 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    80c2:	8b 55 10             	mov    0x10(%ebp),%edx
    80c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    80c8:	01 c2                	add    %eax,%edx
    80ca:	8b 45 14             	mov    0x14(%ebp),%eax
    80cd:	39 c2                	cmp    %eax,%edx
    80cf:	0f 8f af 00 00 00    	jg     8184 <drawCharacter+0xf8>
    80d5:	8b 55 10             	mov    0x10(%ebp),%edx
    80d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    80db:	01 d0                	add    %edx,%eax
    80dd:	85 c0                	test   %eax,%eax
    80df:	0f 88 9f 00 00 00    	js     8184 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    80e5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    80ec:	eb 7b                	jmp    8169 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    80ee:	8b 55 fc             	mov    -0x4(%ebp),%edx
    80f1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    80f4:	89 d0                	mov    %edx,%eax
    80f6:	c1 e0 03             	shl    $0x3,%eax
    80f9:	01 d0                	add    %edx,%eax
    80fb:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    8101:	01 c2                	add    %eax,%edx
    8103:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8106:	01 d0                	add    %edx,%eax
    8108:	05 80 cb 01 00       	add    $0x1cb80,%eax
    810d:	0f b6 00             	movzbl (%eax),%eax
    8110:	3c 01                	cmp    $0x1,%al
    8112:	75 51                	jne    8165 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    8114:	8b 55 0c             	mov    0xc(%ebp),%edx
    8117:	8b 45 f8             	mov    -0x8(%ebp),%eax
    811a:	01 c2                	add    %eax,%edx
    811c:	8b 45 18             	mov    0x18(%ebp),%eax
    811f:	39 c2                	cmp    %eax,%edx
    8121:	7f 50                	jg     8173 <drawCharacter+0xe7>
    8123:	8b 55 0c             	mov    0xc(%ebp),%edx
    8126:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8129:	01 d0                	add    %edx,%eax
    812b:	85 c0                	test   %eax,%eax
    812d:	78 44                	js     8173 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    812f:	8b 55 10             	mov    0x10(%ebp),%edx
    8132:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8135:	01 c2                	add    %eax,%edx
    8137:	8b 45 18             	mov    0x18(%ebp),%eax
    813a:	0f af c2             	imul   %edx,%eax
    813d:	89 c2                	mov    %eax,%edx
    813f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8142:	01 c2                	add    %eax,%edx
    8144:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8147:	01 c2                	add    %eax,%edx
    8149:	89 d0                	mov    %edx,%eax
    814b:	01 c0                	add    %eax,%eax
    814d:	01 c2                	add    %eax,%edx
    814f:	8b 45 08             	mov    0x8(%ebp),%eax
    8152:	01 d0                	add    %edx,%eax
    8154:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    8157:	ff 75 20             	pushl  0x20(%ebp)
    815a:	ff 75 f0             	pushl  -0x10(%ebp)
    815d:	e8 0b fe ff ff       	call   7f6d <drawPointAlpha>
    8162:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    8165:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8169:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    816d:	0f 8e 7b ff ff ff    	jle    80ee <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    8173:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8177:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    817b:	0f 8e 41 ff ff ff    	jle    80c2 <drawCharacter+0x36>
    8181:	eb 01                	jmp    8184 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    8183:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    8184:	c9                   	leave  
    8185:	c3                   	ret    

00008186 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    8186:	55                   	push   %ebp
    8187:	89 e5                	mov    %esp,%ebp
    8189:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    818c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    8193:	eb 3d                	jmp    81d2 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    8195:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8198:	0f b6 00             	movzbl (%eax),%eax
    819b:	0f be c0             	movsbl %al,%eax
    819e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    81a1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    81a4:	01 ca                	add    %ecx,%edx
    81a6:	89 55 f4             	mov    %edx,-0xc(%ebp)
    81a9:	8b 55 10             	mov    0x10(%ebp),%edx
    81ac:	89 55 f8             	mov    %edx,-0x8(%ebp)
    81af:	ff 75 20             	pushl  0x20(%ebp)
    81b2:	50                   	push   %eax
    81b3:	ff 75 18             	pushl  0x18(%ebp)
    81b6:	ff 75 14             	pushl  0x14(%ebp)
    81b9:	ff 75 f8             	pushl  -0x8(%ebp)
    81bc:	ff 75 f4             	pushl  -0xc(%ebp)
    81bf:	ff 75 08             	pushl  0x8(%ebp)
    81c2:	e8 c5 fe ff ff       	call   808c <drawCharacter>
    81c7:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    81ca:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    81ce:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    81d2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    81d5:	0f b6 00             	movzbl (%eax),%eax
    81d8:	84 c0                	test   %al,%al
    81da:	75 b9                	jne    8195 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    81dc:	90                   	nop
    81dd:	c9                   	leave  
    81de:	c3                   	ret    

000081df <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    81df:	55                   	push   %ebp
    81e0:	89 e5                	mov    %esp,%ebp
    81e2:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    81e5:	8b 45 20             	mov    0x20(%ebp),%eax
    81e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    81eb:	8b 45 24             	mov    0x24(%ebp),%eax
    81ee:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    81f1:	8b 55 14             	mov    0x14(%ebp),%edx
    81f4:	8b 45 10             	mov    0x10(%ebp),%eax
    81f7:	29 c2                	sub    %eax,%edx
    81f9:	89 d0                	mov    %edx,%eax
    81fb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    81fe:	7d 0d                	jge    820d <drawRect+0x2e>
        draw_h = s.h - p.y;
    8200:	8b 55 14             	mov    0x14(%ebp),%edx
    8203:	8b 45 10             	mov    0x10(%ebp),%eax
    8206:	29 c2                	sub    %eax,%edx
    8208:	89 d0                	mov    %edx,%eax
    820a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    820d:	8b 55 18             	mov    0x18(%ebp),%edx
    8210:	8b 45 0c             	mov    0xc(%ebp),%eax
    8213:	29 c2                	sub    %eax,%edx
    8215:	89 d0                	mov    %edx,%eax
    8217:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    821a:	7d 0d                	jge    8229 <drawRect+0x4a>
        draw_w = s.w - p.x;
    821c:	8b 55 18             	mov    0x18(%ebp),%edx
    821f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8222:	29 c2                	sub    %eax,%edx
    8224:	89 d0                	mov    %edx,%eax
    8226:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    8229:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8230:	eb 52                	jmp    8284 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    8232:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    8239:	eb 3d                	jmp    8278 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    823b:	8b 55 10             	mov    0x10(%ebp),%edx
    823e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8241:	01 c2                	add    %eax,%edx
    8243:	8b 45 18             	mov    0x18(%ebp),%eax
    8246:	0f af c2             	imul   %edx,%eax
    8249:	89 c2                	mov    %eax,%edx
    824b:	8b 45 0c             	mov    0xc(%ebp),%eax
    824e:	01 c2                	add    %eax,%edx
    8250:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8253:	01 c2                	add    %eax,%edx
    8255:	89 d0                	mov    %edx,%eax
    8257:	01 c0                	add    %eax,%eax
    8259:	01 c2                	add    %eax,%edx
    825b:	8b 45 08             	mov    0x8(%ebp),%eax
    825e:	01 d0                	add    %edx,%eax
    8260:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    8263:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8266:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    826a:	66 89 10             	mov    %dx,(%eax)
    826d:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    8271:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    8274:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8278:	8b 45 f0             	mov    -0x10(%ebp),%eax
    827b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    827e:	7c bb                	jl     823b <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    8280:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8284:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8287:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    828a:	7c a6                	jl     8232 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    828c:	90                   	nop
    828d:	c9                   	leave  
    828e:	c3                   	ret    

0000828f <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    828f:	55                   	push   %ebp
    8290:	89 e5                	mov    %esp,%ebp
    8292:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    8295:	8b 45 28             	mov    0x28(%ebp),%eax
    8298:	89 45 c8             	mov    %eax,-0x38(%ebp)
    829b:	8b 45 24             	mov    0x24(%ebp),%eax
    829e:	89 45 cc             	mov    %eax,-0x34(%ebp)
    82a1:	ff 75 cc             	pushl  -0x34(%ebp)
    82a4:	ff 75 c8             	pushl  -0x38(%ebp)
    82a7:	83 ec 04             	sub    $0x4,%esp
    82aa:	89 e0                	mov    %esp,%eax
    82ac:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    82b0:	66 89 10             	mov    %dx,(%eax)
    82b3:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    82b7:	88 50 02             	mov    %dl,0x2(%eax)
    82ba:	ff 75 18             	pushl  0x18(%ebp)
    82bd:	ff 75 14             	pushl  0x14(%ebp)
    82c0:	ff 75 10             	pushl  0x10(%ebp)
    82c3:	ff 75 0c             	pushl  0xc(%ebp)
    82c6:	ff 75 08             	pushl  0x8(%ebp)
    82c9:	e8 11 ff ff ff       	call   81df <drawRect>
    82ce:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    82d1:	8b 45 28             	mov    0x28(%ebp),%eax
    82d4:	89 45 d0             	mov    %eax,-0x30(%ebp)
    82d7:	8b 45 24             	mov    0x24(%ebp),%eax
    82da:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    82dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    82e0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    82e3:	8b 55 10             	mov    0x10(%ebp),%edx
    82e6:	8b 45 20             	mov    0x20(%ebp),%eax
    82e9:	01 d0                	add    %edx,%eax
    82eb:	2b 45 28             	sub    0x28(%ebp),%eax
    82ee:	89 45 dc             	mov    %eax,-0x24(%ebp)
    82f1:	ff 75 d4             	pushl  -0x2c(%ebp)
    82f4:	ff 75 d0             	pushl  -0x30(%ebp)
    82f7:	83 ec 04             	sub    $0x4,%esp
    82fa:	89 e0                	mov    %esp,%eax
    82fc:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    8300:	66 89 10             	mov    %dx,(%eax)
    8303:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    8307:	88 50 02             	mov    %dl,0x2(%eax)
    830a:	ff 75 18             	pushl  0x18(%ebp)
    830d:	ff 75 14             	pushl  0x14(%ebp)
    8310:	ff 75 dc             	pushl  -0x24(%ebp)
    8313:	ff 75 d8             	pushl  -0x28(%ebp)
    8316:	ff 75 08             	pushl  0x8(%ebp)
    8319:	e8 c1 fe ff ff       	call   81df <drawRect>
    831e:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    8321:	8b 45 20             	mov    0x20(%ebp),%eax
    8324:	8b 55 28             	mov    0x28(%ebp),%edx
    8327:	01 d2                	add    %edx,%edx
    8329:	29 d0                	sub    %edx,%eax
    832b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    832e:	8b 45 28             	mov    0x28(%ebp),%eax
    8331:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8334:	8b 45 0c             	mov    0xc(%ebp),%eax
    8337:	89 45 e8             	mov    %eax,-0x18(%ebp)
    833a:	8b 55 10             	mov    0x10(%ebp),%edx
    833d:	8b 45 28             	mov    0x28(%ebp),%eax
    8340:	01 d0                	add    %edx,%eax
    8342:	89 45 ec             	mov    %eax,-0x14(%ebp)
    8345:	ff 75 e4             	pushl  -0x1c(%ebp)
    8348:	ff 75 e0             	pushl  -0x20(%ebp)
    834b:	83 ec 04             	sub    $0x4,%esp
    834e:	89 e0                	mov    %esp,%eax
    8350:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    8354:	66 89 10             	mov    %dx,(%eax)
    8357:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    835b:	88 50 02             	mov    %dl,0x2(%eax)
    835e:	ff 75 18             	pushl  0x18(%ebp)
    8361:	ff 75 14             	pushl  0x14(%ebp)
    8364:	ff 75 ec             	pushl  -0x14(%ebp)
    8367:	ff 75 e8             	pushl  -0x18(%ebp)
    836a:	ff 75 08             	pushl  0x8(%ebp)
    836d:	e8 6d fe ff ff       	call   81df <drawRect>
    8372:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    8375:	8b 45 20             	mov    0x20(%ebp),%eax
    8378:	8b 55 28             	mov    0x28(%ebp),%edx
    837b:	01 d2                	add    %edx,%edx
    837d:	29 d0                	sub    %edx,%eax
    837f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    8382:	8b 45 28             	mov    0x28(%ebp),%eax
    8385:	89 45 f4             	mov    %eax,-0xc(%ebp)
    8388:	8b 55 0c             	mov    0xc(%ebp),%edx
    838b:	8b 45 24             	mov    0x24(%ebp),%eax
    838e:	01 d0                	add    %edx,%eax
    8390:	2b 45 28             	sub    0x28(%ebp),%eax
    8393:	89 45 f8             	mov    %eax,-0x8(%ebp)
    8396:	8b 55 10             	mov    0x10(%ebp),%edx
    8399:	8b 45 28             	mov    0x28(%ebp),%eax
    839c:	01 d0                	add    %edx,%eax
    839e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    83a1:	ff 75 f4             	pushl  -0xc(%ebp)
    83a4:	ff 75 f0             	pushl  -0x10(%ebp)
    83a7:	83 ec 04             	sub    $0x4,%esp
    83aa:	89 e0                	mov    %esp,%eax
    83ac:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    83b0:	66 89 10             	mov    %dx,(%eax)
    83b3:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    83b7:	88 50 02             	mov    %dl,0x2(%eax)
    83ba:	ff 75 18             	pushl  0x18(%ebp)
    83bd:	ff 75 14             	pushl  0x14(%ebp)
    83c0:	ff 75 fc             	pushl  -0x4(%ebp)
    83c3:	ff 75 f8             	pushl  -0x8(%ebp)
    83c6:	ff 75 08             	pushl  0x8(%ebp)
    83c9:	e8 11 fe ff ff       	call   81df <drawRect>
    83ce:	83 c4 20             	add    $0x20,%esp
}
    83d1:	90                   	nop
    83d2:	c9                   	leave  
    83d3:	c3                   	ret    

000083d4 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    83d4:	55                   	push   %ebp
    83d5:	89 e5                	mov    %esp,%ebp
    83d7:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    83da:	8b 45 30             	mov    0x30(%ebp),%eax
    83dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    83e0:	8b 45 34             	mov    0x34(%ebp),%eax
    83e3:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    83e6:	8b 55 20             	mov    0x20(%ebp),%edx
    83e9:	8b 45 14             	mov    0x14(%ebp),%eax
    83ec:	29 c2                	sub    %eax,%edx
    83ee:	89 d0                	mov    %edx,%eax
    83f0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    83f3:	7d 0d                	jge    8402 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    83f5:	8b 55 20             	mov    0x20(%ebp),%edx
    83f8:	8b 45 14             	mov    0x14(%ebp),%eax
    83fb:	29 c2                	sub    %eax,%edx
    83fd:	89 d0                	mov    %edx,%eax
    83ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    8402:	8b 55 28             	mov    0x28(%ebp),%edx
    8405:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8408:	29 c2                	sub    %eax,%edx
    840a:	89 d0                	mov    %edx,%eax
    840c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    840f:	7d 0d                	jge    841e <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    8411:	8b 55 28             	mov    0x28(%ebp),%edx
    8414:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8417:	29 c2                	sub    %eax,%edx
    8419:	89 d0                	mov    %edx,%eax
    841b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    841e:	8b 55 24             	mov    0x24(%ebp),%edx
    8421:	8b 45 10             	mov    0x10(%ebp),%eax
    8424:	29 c2                	sub    %eax,%edx
    8426:	89 d0                	mov    %edx,%eax
    8428:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    842b:	7d 0d                	jge    843a <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    842d:	8b 55 24             	mov    0x24(%ebp),%edx
    8430:	8b 45 10             	mov    0x10(%ebp),%eax
    8433:	29 c2                	sub    %eax,%edx
    8435:	89 d0                	mov    %edx,%eax
    8437:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    843a:	8b 55 2c             	mov    0x2c(%ebp),%edx
    843d:	8b 45 18             	mov    0x18(%ebp),%eax
    8440:	29 c2                	sub    %eax,%edx
    8442:	89 d0                	mov    %edx,%eax
    8444:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8447:	7d 0d                	jge    8456 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    8449:	8b 55 2c             	mov    0x2c(%ebp),%edx
    844c:	8b 45 18             	mov    0x18(%ebp),%eax
    844f:	29 c2                	sub    %eax,%edx
    8451:	89 d0                	mov    %edx,%eax
    8453:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    8456:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    845d:	e9 83 00 00 00       	jmp    84e5 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    8462:	8b 55 14             	mov    0x14(%ebp),%edx
    8465:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8468:	01 d0                	add    %edx,%eax
    846a:	85 c0                	test   %eax,%eax
    846c:	78 72                	js     84e0 <drawBitmap+0x10c>
    846e:	8b 55 14             	mov    0x14(%ebp),%edx
    8471:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8474:	01 c2                	add    %eax,%edx
    8476:	8b 45 20             	mov    0x20(%ebp),%eax
    8479:	39 c2                	cmp    %eax,%edx
    847b:	7d 63                	jge    84e0 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    847d:	8b 55 14             	mov    0x14(%ebp),%edx
    8480:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8483:	01 c2                	add    %eax,%edx
    8485:	8b 45 24             	mov    0x24(%ebp),%eax
    8488:	0f af c2             	imul   %edx,%eax
    848b:	89 c2                	mov    %eax,%edx
    848d:	8b 45 10             	mov    0x10(%ebp),%eax
    8490:	01 c2                	add    %eax,%edx
    8492:	89 d0                	mov    %edx,%eax
    8494:	01 c0                	add    %eax,%eax
    8496:	01 c2                	add    %eax,%edx
    8498:	8b 45 08             	mov    0x8(%ebp),%eax
    849b:	01 d0                	add    %edx,%eax
    849d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    84a0:	8b 55 1c             	mov    0x1c(%ebp),%edx
    84a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    84a6:	01 c2                	add    %eax,%edx
    84a8:	8b 45 2c             	mov    0x2c(%ebp),%eax
    84ab:	0f af c2             	imul   %edx,%eax
    84ae:	89 c2                	mov    %eax,%edx
    84b0:	8b 45 18             	mov    0x18(%ebp),%eax
    84b3:	01 c2                	add    %eax,%edx
    84b5:	89 d0                	mov    %edx,%eax
    84b7:	01 c0                	add    %eax,%eax
    84b9:	01 c2                	add    %eax,%edx
    84bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    84be:	01 d0                	add    %edx,%eax
    84c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    84c3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    84c6:	89 d0                	mov    %edx,%eax
    84c8:	01 c0                	add    %eax,%eax
    84ca:	01 d0                	add    %edx,%eax
    84cc:	83 ec 04             	sub    $0x4,%esp
    84cf:	50                   	push   %eax
    84d0:	ff 75 e4             	pushl  -0x1c(%ebp)
    84d3:	ff 75 e8             	pushl  -0x18(%ebp)
    84d6:	e8 23 e7 ff ff       	call   6bfe <memmove>
    84db:	83 c4 10             	add    $0x10,%esp
    84de:	eb 01                	jmp    84e1 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    84e0:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    84e1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    84e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    84e8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    84eb:	0f 8c 71 ff ff ff    	jl     8462 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    84f1:	90                   	nop
    84f2:	c9                   	leave  
    84f3:	c3                   	ret    

000084f4 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    84f4:	55                   	push   %ebp
    84f5:	89 e5                	mov    %esp,%ebp
    84f7:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    84fa:	8b 45 30             	mov    0x30(%ebp),%eax
    84fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    8500:	8b 45 34             	mov    0x34(%ebp),%eax
    8503:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    8506:	8b 55 20             	mov    0x20(%ebp),%edx
    8509:	8b 45 14             	mov    0x14(%ebp),%eax
    850c:	29 c2                	sub    %eax,%edx
    850e:	89 d0                	mov    %edx,%eax
    8510:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8513:	7d 0d                	jge    8522 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    8515:	8b 55 20             	mov    0x20(%ebp),%edx
    8518:	8b 45 14             	mov    0x14(%ebp),%eax
    851b:	29 c2                	sub    %eax,%edx
    851d:	89 d0                	mov    %edx,%eax
    851f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    8522:	8b 55 28             	mov    0x28(%ebp),%edx
    8525:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8528:	29 c2                	sub    %eax,%edx
    852a:	89 d0                	mov    %edx,%eax
    852c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    852f:	7d 0d                	jge    853e <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    8531:	8b 55 28             	mov    0x28(%ebp),%edx
    8534:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8537:	29 c2                	sub    %eax,%edx
    8539:	89 d0                	mov    %edx,%eax
    853b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    853e:	8b 55 24             	mov    0x24(%ebp),%edx
    8541:	8b 45 10             	mov    0x10(%ebp),%eax
    8544:	29 c2                	sub    %eax,%edx
    8546:	89 d0                	mov    %edx,%eax
    8548:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    854b:	7d 0d                	jge    855a <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    854d:	8b 55 24             	mov    0x24(%ebp),%edx
    8550:	8b 45 10             	mov    0x10(%ebp),%eax
    8553:	29 c2                	sub    %eax,%edx
    8555:	89 d0                	mov    %edx,%eax
    8557:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    855a:	8b 55 2c             	mov    0x2c(%ebp),%edx
    855d:	8b 45 18             	mov    0x18(%ebp),%eax
    8560:	29 c2                	sub    %eax,%edx
    8562:	89 d0                	mov    %edx,%eax
    8564:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    8567:	7d 0d                	jge    8576 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    8569:	8b 55 2c             	mov    0x2c(%ebp),%edx
    856c:	8b 45 18             	mov    0x18(%ebp),%eax
    856f:	29 c2                	sub    %eax,%edx
    8571:	89 d0                	mov    %edx,%eax
    8573:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    8576:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    857d:	e9 b8 00 00 00       	jmp    863a <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    8582:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    8589:	e9 9c 00 00 00       	jmp    862a <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    858e:	8b 55 14             	mov    0x14(%ebp),%edx
    8591:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8594:	01 c2                	add    %eax,%edx
    8596:	8b 45 24             	mov    0x24(%ebp),%eax
    8599:	0f af c2             	imul   %edx,%eax
    859c:	89 c2                	mov    %eax,%edx
    859e:	8b 45 10             	mov    0x10(%ebp),%eax
    85a1:	01 c2                	add    %eax,%edx
    85a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    85a6:	01 c2                	add    %eax,%edx
    85a8:	89 d0                	mov    %edx,%eax
    85aa:	01 c0                	add    %eax,%eax
    85ac:	01 c2                	add    %eax,%edx
    85ae:	8b 45 08             	mov    0x8(%ebp),%eax
    85b1:	01 d0                	add    %edx,%eax
    85b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    85b6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    85b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    85bc:	01 c2                	add    %eax,%edx
    85be:	8b 45 2c             	mov    0x2c(%ebp),%eax
    85c1:	0f af c2             	imul   %edx,%eax
    85c4:	89 c2                	mov    %eax,%edx
    85c6:	8b 45 18             	mov    0x18(%ebp),%eax
    85c9:	01 c2                	add    %eax,%edx
    85cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    85ce:	01 c2                	add    %eax,%edx
    85d0:	89 d0                	mov    %edx,%eax
    85d2:	01 c0                	add    %eax,%eax
    85d4:	01 c2                	add    %eax,%edx
    85d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    85d9:	01 d0                	add    %edx,%eax
    85db:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    85de:	8b 45 e8             	mov    -0x18(%ebp),%eax
    85e1:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    85e5:	3c ff                	cmp    $0xff,%al
    85e7:	75 15                	jne    85fe <drawTransparentBitmap+0x10a>
    85e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    85ec:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    85f0:	3c ff                	cmp    $0xff,%al
    85f2:	75 0a                	jne    85fe <drawTransparentBitmap+0x10a>
    85f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    85f7:	0f b6 00             	movzbl (%eax),%eax
    85fa:	3c ff                	cmp    $0xff,%al
    85fc:	74 27                	je     8625 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    85fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8601:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    8605:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8608:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    860b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    860e:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    8612:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8615:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    8618:	8b 45 e8             	mov    -0x18(%ebp),%eax
    861b:	0f b6 10             	movzbl (%eax),%edx
    861e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8621:	88 10                	mov    %dl,(%eax)
    8623:	eb 01                	jmp    8626 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    8625:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    8626:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    862a:	8b 45 34             	mov    0x34(%ebp),%eax
    862d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8630:	0f 8f 58 ff ff ff    	jg     858e <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    8636:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    863a:	8b 45 30             	mov    0x30(%ebp),%eax
    863d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8640:	0f 8f 3c ff ff ff    	jg     8582 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    8646:	90                   	nop
    8647:	c9                   	leave  
    8648:	c3                   	ret    

00008649 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    8649:	55                   	push   %ebp
    864a:	89 e5                	mov    %esp,%ebp
    864c:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    864f:	ff 75 24             	pushl  0x24(%ebp)
    8652:	ff 75 20             	pushl  0x20(%ebp)
    8655:	ff 75 1c             	pushl  0x1c(%ebp)
    8658:	ff 75 18             	pushl  0x18(%ebp)
    865b:	ff 75 1c             	pushl  0x1c(%ebp)
    865e:	ff 75 18             	pushl  0x18(%ebp)
    8661:	ff 75 14             	pushl  0x14(%ebp)
    8664:	ff 75 10             	pushl  0x10(%ebp)
    8667:	ff 75 14             	pushl  0x14(%ebp)
    866a:	ff 75 10             	pushl  0x10(%ebp)
    866d:	ff 75 0c             	pushl  0xc(%ebp)
    8670:	ff 75 08             	pushl  0x8(%ebp)
    8673:	e8 5c fd ff ff       	call   83d4 <drawBitmap>
    8678:	83 c4 30             	add    $0x30,%esp
}
    867b:	90                   	nop
    867c:	c9                   	leave  
    867d:	c3                   	ret    

0000867e <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    867e:	55                   	push   %ebp
    867f:	89 e5                	mov    %esp,%ebp
    8681:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    8684:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8687:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    868a:	8b 45 20             	mov    0x20(%ebp),%eax
    868d:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    8690:	8b 55 14             	mov    0x14(%ebp),%edx
    8693:	8b 45 10             	mov    0x10(%ebp),%eax
    8696:	29 c2                	sub    %eax,%edx
    8698:	89 d0                	mov    %edx,%eax
    869a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    869d:	7d 0d                	jge    86ac <colorShift+0x2e>
        draw_h = s.h - p.y;
    869f:	8b 55 14             	mov    0x14(%ebp),%edx
    86a2:	8b 45 10             	mov    0x10(%ebp),%eax
    86a5:	29 c2                	sub    %eax,%edx
    86a7:	89 d0                	mov    %edx,%eax
    86a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    86ac:	8b 55 18             	mov    0x18(%ebp),%edx
    86af:	8b 45 0c             	mov    0xc(%ebp),%eax
    86b2:	29 c2                	sub    %eax,%edx
    86b4:	89 d0                	mov    %edx,%eax
    86b6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    86b9:	7d 0d                	jge    86c8 <colorShift+0x4a>
        draw_w = s.w - p.x;
    86bb:	8b 55 18             	mov    0x18(%ebp),%edx
    86be:	8b 45 0c             	mov    0xc(%ebp),%eax
    86c1:	29 c2                	sub    %eax,%edx
    86c3:	89 d0                	mov    %edx,%eax
    86c5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    86c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    86cf:	e9 fc 00 00 00       	jmp    87d0 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    86d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    86db:	e9 e0 00 00 00       	jmp    87c0 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    86e0:	8b 55 10             	mov    0x10(%ebp),%edx
    86e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    86e6:	01 c2                	add    %eax,%edx
    86e8:	8b 45 18             	mov    0x18(%ebp),%eax
    86eb:	0f af c2             	imul   %edx,%eax
    86ee:	89 c2                	mov    %eax,%edx
    86f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    86f3:	01 c2                	add    %eax,%edx
    86f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    86f8:	01 c2                	add    %eax,%edx
    86fa:	89 d0                	mov    %edx,%eax
    86fc:	01 c0                	add    %eax,%eax
    86fe:	01 c2                	add    %eax,%edx
    8700:	8b 45 08             	mov    0x8(%ebp),%eax
    8703:	01 d0                	add    %edx,%eax
    8705:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    8708:	8b 45 ec             	mov    -0x14(%ebp),%eax
    870b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    870f:	3c c8                	cmp    $0xc8,%al
    8711:	0f 86 a5 00 00 00    	jbe    87bc <colorShift+0x13e>
    8717:	8b 45 ec             	mov    -0x14(%ebp),%eax
    871a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    871e:	3c c8                	cmp    $0xc8,%al
    8720:	0f 86 96 00 00 00    	jbe    87bc <colorShift+0x13e>
    8726:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8729:	0f b6 00             	movzbl (%eax),%eax
    872c:	3c c8                	cmp    $0xc8,%al
    872e:	0f 86 88 00 00 00    	jbe    87bc <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    8734:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8737:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    873b:	0f b6 d0             	movzbl %al,%edx
    873e:	8b 45 24             	mov    0x24(%ebp),%eax
    8741:	01 d0                	add    %edx,%eax
    8743:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    8749:	89 d0                	mov    %edx,%eax
    874b:	c1 f8 1f             	sar    $0x1f,%eax
    874e:	c1 e8 18             	shr    $0x18,%eax
    8751:	01 c2                	add    %eax,%edx
    8753:	0f b6 d2             	movzbl %dl,%edx
    8756:	29 c2                	sub    %eax,%edx
    8758:	89 d0                	mov    %edx,%eax
    875a:	89 c2                	mov    %eax,%edx
    875c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    875f:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    8762:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8765:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8769:	0f b6 d0             	movzbl %al,%edx
    876c:	8b 45 24             	mov    0x24(%ebp),%eax
    876f:	01 d0                	add    %edx,%eax
    8771:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    8777:	89 d0                	mov    %edx,%eax
    8779:	c1 f8 1f             	sar    $0x1f,%eax
    877c:	c1 e8 18             	shr    $0x18,%eax
    877f:	01 c2                	add    %eax,%edx
    8781:	0f b6 d2             	movzbl %dl,%edx
    8784:	29 c2                	sub    %eax,%edx
    8786:	89 d0                	mov    %edx,%eax
    8788:	89 c2                	mov    %eax,%edx
    878a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    878d:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    8790:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8793:	0f b6 00             	movzbl (%eax),%eax
    8796:	0f b6 d0             	movzbl %al,%edx
    8799:	8b 45 24             	mov    0x24(%ebp),%eax
    879c:	01 d0                	add    %edx,%eax
    879e:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    87a4:	89 d0                	mov    %edx,%eax
    87a6:	c1 f8 1f             	sar    $0x1f,%eax
    87a9:	c1 e8 18             	shr    $0x18,%eax
    87ac:	01 c2                	add    %eax,%edx
    87ae:	0f b6 d2             	movzbl %dl,%edx
    87b1:	29 c2                	sub    %eax,%edx
    87b3:	89 d0                	mov    %edx,%eax
    87b5:	89 c2                	mov    %eax,%edx
    87b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    87ba:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    87bc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    87c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    87c3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    87c6:	0f 8c 14 ff ff ff    	jl     86e0 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    87cc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    87d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    87d3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    87d6:	0f 8c f8 fe ff ff    	jl     86d4 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    87dc:	90                   	nop
    87dd:	c9                   	leave  
    87de:	c3                   	ret    

000087df <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    87df:	55                   	push   %ebp
    87e0:	89 e5                	mov    %esp,%ebp
    87e2:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    87e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    87ec:	e9 fb 00 00 00       	jmp    88ec <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    87f1:	8b 55 14             	mov    0x14(%ebp),%edx
    87f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87f7:	01 c2                	add    %eax,%edx
    87f9:	0f b7 05 78 58 02 00 	movzwl 0x25878,%eax
    8800:	0f b7 c0             	movzwl %ax,%eax
    8803:	39 c2                	cmp    %eax,%edx
    8805:	0f 8f eb 00 00 00    	jg     88f6 <drawMouse+0x117>
    880b:	8b 55 14             	mov    0x14(%ebp),%edx
    880e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8811:	01 d0                	add    %edx,%eax
    8813:	85 c0                	test   %eax,%eax
    8815:	0f 88 db 00 00 00    	js     88f6 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    881b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8822:	e9 b7 00 00 00       	jmp    88de <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    8827:	8b 55 10             	mov    0x10(%ebp),%edx
    882a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    882d:	01 c2                	add    %eax,%edx
    882f:	0f b7 05 44 58 02 00 	movzwl 0x25844,%eax
    8836:	0f b7 c0             	movzwl %ax,%eax
    8839:	39 c2                	cmp    %eax,%edx
    883b:	0f 8f a7 00 00 00    	jg     88e8 <drawMouse+0x109>
    8841:	8b 55 10             	mov    0x10(%ebp),%edx
    8844:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8847:	01 d0                	add    %edx,%eax
    8849:	85 c0                	test   %eax,%eax
    884b:	0f 88 97 00 00 00    	js     88e8 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    8851:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8854:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    8857:	89 d0                	mov    %edx,%eax
    8859:	c1 e0 04             	shl    $0x4,%eax
    885c:	29 d0                	sub    %edx,%eax
    885e:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    8864:	01 c2                	add    %eax,%edx
    8866:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8869:	01 d0                	add    %edx,%eax
    886b:	05 60 c9 01 00       	add    $0x1c960,%eax
    8870:	0f b6 00             	movzbl (%eax),%eax
    8873:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    8876:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    887a:	74 5e                	je     88da <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    887c:	8b 55 14             	mov    0x14(%ebp),%edx
    887f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8882:	01 c2                	add    %eax,%edx
    8884:	0f b7 05 44 58 02 00 	movzwl 0x25844,%eax
    888b:	0f b7 c0             	movzwl %ax,%eax
    888e:	0f af c2             	imul   %edx,%eax
    8891:	89 c2                	mov    %eax,%edx
    8893:	8b 45 10             	mov    0x10(%ebp),%eax
    8896:	01 c2                	add    %eax,%edx
    8898:	8b 45 f8             	mov    -0x8(%ebp),%eax
    889b:	01 c2                	add    %eax,%edx
    889d:	89 d0                	mov    %edx,%eax
    889f:	01 c0                	add    %eax,%eax
    88a1:	01 c2                	add    %eax,%edx
    88a3:	8b 45 08             	mov    0x8(%ebp),%eax
    88a6:	01 d0                	add    %edx,%eax
    88a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    88ab:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    88af:	8d 50 ff             	lea    -0x1(%eax),%edx
    88b2:	89 d0                	mov    %edx,%eax
    88b4:	01 c0                	add    %eax,%eax
    88b6:	01 d0                	add    %edx,%eax
    88b8:	05 00 59 02 00       	add    $0x25900,%eax
    88bd:	83 ec 04             	sub    $0x4,%esp
    88c0:	89 e2                	mov    %esp,%edx
    88c2:	0f b7 08             	movzwl (%eax),%ecx
    88c5:	66 89 0a             	mov    %cx,(%edx)
    88c8:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    88cc:	88 42 02             	mov    %al,0x2(%edx)
    88cf:	ff 75 f0             	pushl  -0x10(%ebp)
    88d2:	e8 73 f6 ff ff       	call   7f4a <drawPoint>
    88d7:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    88da:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    88de:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    88e2:	0f 8e 3f ff ff ff    	jle    8827 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    88e8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    88ec:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    88f0:	0f 8e fb fe ff ff    	jle    87f1 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    88f6:	90                   	nop
    88f7:	c9                   	leave  
    88f8:	c3                   	ret    

000088f9 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    88f9:	55                   	push   %ebp
    88fa:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    88fc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    8900:	78 1b                	js     891d <getColor+0x24>
    8902:	8b 45 08             	mov    0x8(%ebp),%eax
    8905:	8b 40 04             	mov    0x4(%eax),%eax
    8908:	3b 45 0c             	cmp    0xc(%ebp),%eax
    890b:	7c 10                	jl     891d <getColor+0x24>
    890d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8911:	78 0a                	js     891d <getColor+0x24>
    8913:	8b 45 08             	mov    0x8(%ebp),%eax
    8916:	8b 00                	mov    (%eax),%eax
    8918:	3b 45 10             	cmp    0x10(%ebp),%eax
    891b:	7d 10                	jge    892d <getColor+0x34>
    {
        *isInPic = 1;
    891d:	8b 45 14             	mov    0x14(%ebp),%eax
    8920:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    8926:	b8 55 53 02 00       	mov    $0x25355,%eax
    892b:	eb 44                	jmp    8971 <getColor+0x78>
    }

    if (y == pic->height)
    892d:	8b 45 08             	mov    0x8(%ebp),%eax
    8930:	8b 40 04             	mov    0x4(%eax),%eax
    8933:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8936:	75 04                	jne    893c <getColor+0x43>
        y--;
    8938:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    893c:	8b 45 08             	mov    0x8(%ebp),%eax
    893f:	8b 00                	mov    (%eax),%eax
    8941:	3b 45 10             	cmp    0x10(%ebp),%eax
    8944:	75 04                	jne    894a <getColor+0x51>
        x--;
    8946:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    894a:	8b 45 14             	mov    0x14(%ebp),%eax
    894d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    8953:	8b 45 08             	mov    0x8(%ebp),%eax
    8956:	8b 48 08             	mov    0x8(%eax),%ecx
    8959:	8b 45 08             	mov    0x8(%ebp),%eax
    895c:	8b 00                	mov    (%eax),%eax
    895e:	0f af 45 0c          	imul   0xc(%ebp),%eax
    8962:	89 c2                	mov    %eax,%edx
    8964:	8b 45 10             	mov    0x10(%ebp),%eax
    8967:	01 c2                	add    %eax,%edx
    8969:	89 d0                	mov    %edx,%eax
    896b:	01 c0                	add    %eax,%eax
    896d:	01 d0                	add    %edx,%eax
    896f:	01 c8                	add    %ecx,%eax
}
    8971:	5d                   	pop    %ebp
    8972:	c3                   	ret    

00008973 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    8973:	55                   	push   %ebp
    8974:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    8976:	8b 45 08             	mov    0x8(%ebp),%eax
    8979:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    897d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8980:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    8983:	8b 45 08             	mov    0x8(%ebp),%eax
    8986:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    898a:	8b 45 0c             	mov    0xc(%ebp),%eax
    898d:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    8990:	8b 45 08             	mov    0x8(%ebp),%eax
    8993:	0f b6 10             	movzbl (%eax),%edx
    8996:	8b 45 0c             	mov    0xc(%ebp),%eax
    8999:	88 10                	mov    %dl,(%eax)

    return 1;
    899b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    89a0:	5d                   	pop    %ebp
    89a1:	c3                   	ret    

000089a2 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    89a2:	55                   	push   %ebp
    89a3:	89 e5                	mov    %esp,%ebp
    89a5:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    89a8:	d9 45 10             	flds   0x10(%ebp)
    89ab:	d9 7d be             	fnstcw -0x42(%ebp)
    89ae:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    89b2:	b4 0c                	mov    $0xc,%ah
    89b4:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    89b8:	d9 6d bc             	fldcw  -0x44(%ebp)
    89bb:	db 5d fc             	fistpl -0x4(%ebp)
    89be:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    89c1:	d9 45 0c             	flds   0xc(%ebp)
    89c4:	d9 6d bc             	fldcw  -0x44(%ebp)
    89c7:	db 5d f8             	fistpl -0x8(%ebp)
    89ca:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    89cd:	db 45 fc             	fildl  -0x4(%ebp)
    89d0:	d9 45 10             	flds   0x10(%ebp)
    89d3:	d9 c9                	fxch   %st(1)
    89d5:	df e9                	fucomip %st(1),%st
    89d7:	dd d8                	fstp   %st(0)
    89d9:	76 04                	jbe    89df <mixColor+0x3d>
        x--;
    89db:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    89df:	db 45 f8             	fildl  -0x8(%ebp)
    89e2:	d9 45 0c             	flds   0xc(%ebp)
    89e5:	d9 c9                	fxch   %st(1)
    89e7:	df e9                	fucomip %st(1),%st
    89e9:	dd d8                	fstp   %st(0)
    89eb:	76 04                	jbe    89f1 <mixColor+0x4f>
        y--;
    89ed:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    89f1:	8d 45 c0             	lea    -0x40(%ebp),%eax
    89f4:	50                   	push   %eax
    89f5:	ff 75 fc             	pushl  -0x4(%ebp)
    89f8:	ff 75 f8             	pushl  -0x8(%ebp)
    89fb:	ff 75 08             	pushl  0x8(%ebp)
    89fe:	e8 f6 fe ff ff       	call   88f9 <getColor>
    8a03:	83 c4 10             	add    $0x10,%esp
    8a06:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    8a09:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8a0c:	83 c0 01             	add    $0x1,%eax
    8a0f:	8d 55 c0             	lea    -0x40(%ebp),%edx
    8a12:	83 c2 04             	add    $0x4,%edx
    8a15:	52                   	push   %edx
    8a16:	ff 75 fc             	pushl  -0x4(%ebp)
    8a19:	50                   	push   %eax
    8a1a:	ff 75 08             	pushl  0x8(%ebp)
    8a1d:	e8 d7 fe ff ff       	call   88f9 <getColor>
    8a22:	83 c4 10             	add    $0x10,%esp
    8a25:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    8a28:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a2b:	83 c0 01             	add    $0x1,%eax
    8a2e:	8d 55 c0             	lea    -0x40(%ebp),%edx
    8a31:	83 c2 08             	add    $0x8,%edx
    8a34:	52                   	push   %edx
    8a35:	50                   	push   %eax
    8a36:	ff 75 f8             	pushl  -0x8(%ebp)
    8a39:	ff 75 08             	pushl  0x8(%ebp)
    8a3c:	e8 b8 fe ff ff       	call   88f9 <getColor>
    8a41:	83 c4 10             	add    $0x10,%esp
    8a44:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    8a47:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a4a:	8d 50 01             	lea    0x1(%eax),%edx
    8a4d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8a50:	83 c0 01             	add    $0x1,%eax
    8a53:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    8a56:	83 c1 0c             	add    $0xc,%ecx
    8a59:	51                   	push   %ecx
    8a5a:	52                   	push   %edx
    8a5b:	50                   	push   %eax
    8a5c:	ff 75 08             	pushl  0x8(%ebp)
    8a5f:	e8 95 fe ff ff       	call   88f9 <getColor>
    8a64:	83 c4 10             	add    $0x10,%esp
    8a67:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    8a6a:	db 45 fc             	fildl  -0x4(%ebp)
    8a6d:	d9 45 10             	flds   0x10(%ebp)
    8a70:	de e1                	fsubp  %st,%st(1)
    8a72:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    8a75:	db 45 f8             	fildl  -0x8(%ebp)
    8a78:	d9 45 0c             	flds   0xc(%ebp)
    8a7b:	de e1                	fsubp  %st,%st(1)
    8a7d:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    8a80:	d9 45 e4             	flds   -0x1c(%ebp)
    8a83:	d8 4d e0             	fmuls  -0x20(%ebp)
    8a86:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    8a89:	d9 e8                	fld1   
    8a8b:	d8 65 e0             	fsubs  -0x20(%ebp)
    8a8e:	d8 4d e4             	fmuls  -0x1c(%ebp)
    8a91:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    8a94:	d9 e8                	fld1   
    8a96:	d8 65 e4             	fsubs  -0x1c(%ebp)
    8a99:	d8 4d e0             	fmuls  -0x20(%ebp)
    8a9c:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    8a9f:	d9 e8                	fld1   
    8aa1:	d8 65 e4             	fsubs  -0x1c(%ebp)
    8aa4:	d9 e8                	fld1   
    8aa6:	d8 65 e0             	fsubs  -0x20(%ebp)
    8aa9:	de c9                	fmulp  %st,%st(1)
    8aab:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    8aae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8ab1:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    8ab5:	0f b6 c0             	movzbl %al,%eax
    8ab8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8abb:	db 45 b4             	fildl  -0x4c(%ebp)
    8abe:	d8 4d d0             	fmuls  -0x30(%ebp)
    8ac1:	8b 45 c0             	mov    -0x40(%ebp),%eax
    8ac4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8ac7:	db 45 b4             	fildl  -0x4c(%ebp)
    8aca:	de c9                	fmulp  %st,%st(1)
    8acc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8acf:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    8ad3:	0f b6 c0             	movzbl %al,%eax
    8ad6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8ad9:	db 45 b4             	fildl  -0x4c(%ebp)
    8adc:	d8 4d d4             	fmuls  -0x2c(%ebp)
    8adf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    8ae2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8ae5:	db 45 b4             	fildl  -0x4c(%ebp)
    8ae8:	de c9                	fmulp  %st,%st(1)
    8aea:	de c1                	faddp  %st,%st(1)
    8aec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8aef:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    8af3:	0f b6 c0             	movzbl %al,%eax
    8af6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8af9:	db 45 b4             	fildl  -0x4c(%ebp)
    8afc:	d8 4d d8             	fmuls  -0x28(%ebp)
    8aff:	8b 45 c8             	mov    -0x38(%ebp),%eax
    8b02:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8b05:	db 45 b4             	fildl  -0x4c(%ebp)
    8b08:	de c9                	fmulp  %st,%st(1)
    8b0a:	de c1                	faddp  %st,%st(1)
    8b0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8b0f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    8b13:	0f b6 c0             	movzbl %al,%eax
    8b16:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8b19:	db 45 b4             	fildl  -0x4c(%ebp)
    8b1c:	d8 4d dc             	fmuls  -0x24(%ebp)
    8b1f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    8b22:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8b25:	db 45 b4             	fildl  -0x4c(%ebp)
    8b28:	de c9                	fmulp  %st,%st(1)
    8b2a:	de c1                	faddp  %st,%st(1)
    8b2c:	d9 7d be             	fnstcw -0x42(%ebp)
    8b2f:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    8b33:	b4 0c                	mov    $0xc,%ah
    8b35:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    8b39:	d9 6d bc             	fldcw  -0x44(%ebp)
    8b3c:	db 5d b8             	fistpl -0x48(%ebp)
    8b3f:	d9 6d be             	fldcw  -0x42(%ebp)
    8b42:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8b45:	89 c2                	mov    %eax,%edx
    8b47:	8b 45 14             	mov    0x14(%ebp),%eax
    8b4a:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    8b4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8b50:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8b54:	0f b6 c0             	movzbl %al,%eax
    8b57:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8b5a:	db 45 b4             	fildl  -0x4c(%ebp)
    8b5d:	d8 4d d0             	fmuls  -0x30(%ebp)
    8b60:	8b 45 c0             	mov    -0x40(%ebp),%eax
    8b63:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8b66:	db 45 b4             	fildl  -0x4c(%ebp)
    8b69:	de c9                	fmulp  %st,%st(1)
    8b6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8b6e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8b72:	0f b6 c0             	movzbl %al,%eax
    8b75:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8b78:	db 45 b4             	fildl  -0x4c(%ebp)
    8b7b:	d8 4d d4             	fmuls  -0x2c(%ebp)
    8b7e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    8b81:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8b84:	db 45 b4             	fildl  -0x4c(%ebp)
    8b87:	de c9                	fmulp  %st,%st(1)
    8b89:	de c1                	faddp  %st,%st(1)
    8b8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8b8e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8b92:	0f b6 c0             	movzbl %al,%eax
    8b95:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8b98:	db 45 b4             	fildl  -0x4c(%ebp)
    8b9b:	d8 4d d8             	fmuls  -0x28(%ebp)
    8b9e:	8b 45 c8             	mov    -0x38(%ebp),%eax
    8ba1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8ba4:	db 45 b4             	fildl  -0x4c(%ebp)
    8ba7:	de c9                	fmulp  %st,%st(1)
    8ba9:	de c1                	faddp  %st,%st(1)
    8bab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8bae:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8bb2:	0f b6 c0             	movzbl %al,%eax
    8bb5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8bb8:	db 45 b4             	fildl  -0x4c(%ebp)
    8bbb:	d8 4d dc             	fmuls  -0x24(%ebp)
    8bbe:	8b 45 cc             	mov    -0x34(%ebp),%eax
    8bc1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8bc4:	db 45 b4             	fildl  -0x4c(%ebp)
    8bc7:	de c9                	fmulp  %st,%st(1)
    8bc9:	de c1                	faddp  %st,%st(1)
    8bcb:	d9 6d bc             	fldcw  -0x44(%ebp)
    8bce:	db 5d b8             	fistpl -0x48(%ebp)
    8bd1:	d9 6d be             	fldcw  -0x42(%ebp)
    8bd4:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8bd7:	89 c2                	mov    %eax,%edx
    8bd9:	8b 45 14             	mov    0x14(%ebp),%eax
    8bdc:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    8bdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8be2:	0f b6 00             	movzbl (%eax),%eax
    8be5:	0f b6 c0             	movzbl %al,%eax
    8be8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8beb:	db 45 b4             	fildl  -0x4c(%ebp)
    8bee:	d8 4d d0             	fmuls  -0x30(%ebp)
    8bf1:	8b 45 c0             	mov    -0x40(%ebp),%eax
    8bf4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8bf7:	db 45 b4             	fildl  -0x4c(%ebp)
    8bfa:	de c9                	fmulp  %st,%st(1)
    8bfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8bff:	0f b6 00             	movzbl (%eax),%eax
    8c02:	0f b6 c0             	movzbl %al,%eax
    8c05:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8c08:	db 45 b4             	fildl  -0x4c(%ebp)
    8c0b:	d8 4d d4             	fmuls  -0x2c(%ebp)
    8c0e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    8c11:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8c14:	db 45 b4             	fildl  -0x4c(%ebp)
    8c17:	de c9                	fmulp  %st,%st(1)
    8c19:	de c1                	faddp  %st,%st(1)
    8c1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8c1e:	0f b6 00             	movzbl (%eax),%eax
    8c21:	0f b6 c0             	movzbl %al,%eax
    8c24:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8c27:	db 45 b4             	fildl  -0x4c(%ebp)
    8c2a:	d8 4d d8             	fmuls  -0x28(%ebp)
    8c2d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    8c30:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8c33:	db 45 b4             	fildl  -0x4c(%ebp)
    8c36:	de c9                	fmulp  %st,%st(1)
    8c38:	de c1                	faddp  %st,%st(1)
    8c3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8c3d:	0f b6 00             	movzbl (%eax),%eax
    8c40:	0f b6 c0             	movzbl %al,%eax
    8c43:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8c46:	db 45 b4             	fildl  -0x4c(%ebp)
    8c49:	d8 4d dc             	fmuls  -0x24(%ebp)
    8c4c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    8c4f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    8c52:	db 45 b4             	fildl  -0x4c(%ebp)
    8c55:	de c9                	fmulp  %st,%st(1)
    8c57:	de c1                	faddp  %st,%st(1)
    8c59:	d9 6d bc             	fldcw  -0x44(%ebp)
    8c5c:	db 5d b8             	fistpl -0x48(%ebp)
    8c5f:	d9 6d be             	fldcw  -0x42(%ebp)
    8c62:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8c65:	89 c2                	mov    %eax,%edx
    8c67:	8b 45 14             	mov    0x14(%ebp),%eax
    8c6a:	88 10                	mov    %dl,(%eax)

    return 1;
    8c6c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8c71:	c9                   	leave  
    8c72:	c3                   	ret    

00008c73 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    8c73:	55                   	push   %ebp
    8c74:	89 e5                	mov    %esp,%ebp
    8c76:	53                   	push   %ebx
    8c77:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    8c7a:	8b 45 10             	mov    0x10(%ebp),%eax
    8c7d:	c1 f8 10             	sar    $0x10,%eax
    8c80:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    8c83:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c86:	c1 f8 10             	sar    $0x10,%eax
    8c89:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    8c8c:	8d 45 bc             	lea    -0x44(%ebp),%eax
    8c8f:	50                   	push   %eax
    8c90:	ff 75 f8             	pushl  -0x8(%ebp)
    8c93:	ff 75 f4             	pushl  -0xc(%ebp)
    8c96:	ff 75 08             	pushl  0x8(%ebp)
    8c99:	e8 5b fc ff ff       	call   88f9 <getColor>
    8c9e:	83 c4 10             	add    $0x10,%esp
    8ca1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    8ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8ca7:	83 c0 01             	add    $0x1,%eax
    8caa:	8d 55 bc             	lea    -0x44(%ebp),%edx
    8cad:	83 c2 04             	add    $0x4,%edx
    8cb0:	52                   	push   %edx
    8cb1:	ff 75 f8             	pushl  -0x8(%ebp)
    8cb4:	50                   	push   %eax
    8cb5:	ff 75 08             	pushl  0x8(%ebp)
    8cb8:	e8 3c fc ff ff       	call   88f9 <getColor>
    8cbd:	83 c4 10             	add    $0x10,%esp
    8cc0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    8cc3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8cc6:	83 c0 01             	add    $0x1,%eax
    8cc9:	8d 55 bc             	lea    -0x44(%ebp),%edx
    8ccc:	83 c2 08             	add    $0x8,%edx
    8ccf:	52                   	push   %edx
    8cd0:	50                   	push   %eax
    8cd1:	ff 75 f4             	pushl  -0xc(%ebp)
    8cd4:	ff 75 08             	pushl  0x8(%ebp)
    8cd7:	e8 1d fc ff ff       	call   88f9 <getColor>
    8cdc:	83 c4 10             	add    $0x10,%esp
    8cdf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    8ce2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8ce5:	8d 50 01             	lea    0x1(%eax),%edx
    8ce8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8ceb:	83 c0 01             	add    $0x1,%eax
    8cee:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    8cf1:	83 c1 0c             	add    $0xc,%ecx
    8cf4:	51                   	push   %ecx
    8cf5:	52                   	push   %edx
    8cf6:	50                   	push   %eax
    8cf7:	ff 75 08             	pushl  0x8(%ebp)
    8cfa:	e8 fa fb ff ff       	call   88f9 <getColor>
    8cff:	83 c4 10             	add    $0x10,%esp
    8d02:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    8d05:	8b 45 10             	mov    0x10(%ebp),%eax
    8d08:	0f b7 c0             	movzwl %ax,%eax
    8d0b:	c1 f8 08             	sar    $0x8,%eax
    8d0e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    8d11:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d14:	0f b7 c0             	movzwl %ax,%eax
    8d17:	c1 f8 08             	sar    $0x8,%eax
    8d1a:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    8d1d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8d20:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    8d24:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    8d27:	b8 ff 00 00 00       	mov    $0xff,%eax
    8d2c:	2b 45 dc             	sub    -0x24(%ebp),%eax
    8d2f:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    8d33:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    8d36:	b8 ff 00 00 00       	mov    $0xff,%eax
    8d3b:	2b 45 e0             	sub    -0x20(%ebp),%eax
    8d3e:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    8d42:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    8d45:	b8 ff 00 00 00       	mov    $0xff,%eax
    8d4a:	2b 45 e0             	sub    -0x20(%ebp),%eax
    8d4d:	89 c2                	mov    %eax,%edx
    8d4f:	b8 ff 00 00 00       	mov    $0xff,%eax
    8d54:	2b 45 dc             	sub    -0x24(%ebp),%eax
    8d57:	0f af c2             	imul   %edx,%eax
    8d5a:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    8d5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8d60:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    8d64:	0f b6 c0             	movzbl %al,%eax
    8d67:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    8d6b:	8b 55 bc             	mov    -0x44(%ebp),%edx
    8d6e:	0f af d0             	imul   %eax,%edx
    8d71:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8d74:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    8d78:	0f b6 c0             	movzbl %al,%eax
    8d7b:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    8d7f:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    8d82:	0f af c1             	imul   %ecx,%eax
    8d85:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    8d88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8d8b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    8d8f:	0f b6 c0             	movzbl %al,%eax
    8d92:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    8d96:	8b 55 c8             	mov    -0x38(%ebp),%edx
    8d99:	0f af d0             	imul   %eax,%edx
    8d9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8d9f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    8da3:	0f b6 c0             	movzbl %al,%eax
    8da6:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    8daa:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    8dad:	0f af c1             	imul   %ecx,%eax
    8db0:	01 d0                	add    %edx,%eax
    8db2:	01 d8                	add    %ebx,%eax
    8db4:	c1 e8 10             	shr    $0x10,%eax
    8db7:	89 c2                	mov    %eax,%edx
    8db9:	8b 45 14             	mov    0x14(%ebp),%eax
    8dbc:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    8dbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8dc2:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8dc6:	0f b6 c0             	movzbl %al,%eax
    8dc9:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    8dcd:	8b 55 bc             	mov    -0x44(%ebp),%edx
    8dd0:	0f af d0             	imul   %eax,%edx
    8dd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8dd6:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8dda:	0f b6 c0             	movzbl %al,%eax
    8ddd:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    8de1:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    8de4:	0f af c1             	imul   %ecx,%eax
    8de7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    8dea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8ded:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8df1:	0f b6 c0             	movzbl %al,%eax
    8df4:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    8df8:	8b 55 c8             	mov    -0x38(%ebp),%edx
    8dfb:	0f af d0             	imul   %eax,%edx
    8dfe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8e01:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    8e05:	0f b6 c0             	movzbl %al,%eax
    8e08:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    8e0c:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    8e0f:	0f af c1             	imul   %ecx,%eax
    8e12:	01 d0                	add    %edx,%eax
    8e14:	01 d8                	add    %ebx,%eax
    8e16:	c1 e8 10             	shr    $0x10,%eax
    8e19:	89 c2                	mov    %eax,%edx
    8e1b:	8b 45 14             	mov    0x14(%ebp),%eax
    8e1e:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    8e21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8e24:	0f b6 00             	movzbl (%eax),%eax
    8e27:	0f b6 c0             	movzbl %al,%eax
    8e2a:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    8e2e:	8b 55 bc             	mov    -0x44(%ebp),%edx
    8e31:	0f af d0             	imul   %eax,%edx
    8e34:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8e37:	0f b6 00             	movzbl (%eax),%eax
    8e3a:	0f b6 c0             	movzbl %al,%eax
    8e3d:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    8e41:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    8e44:	0f af c1             	imul   %ecx,%eax
    8e47:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    8e4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8e4d:	0f b6 00             	movzbl (%eax),%eax
    8e50:	0f b6 c0             	movzbl %al,%eax
    8e53:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    8e57:	8b 55 c8             	mov    -0x38(%ebp),%edx
    8e5a:	0f af d0             	imul   %eax,%edx
    8e5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8e60:	0f b6 00             	movzbl (%eax),%eax
    8e63:	0f b6 c0             	movzbl %al,%eax
    8e66:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    8e6a:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    8e6d:	0f af c1             	imul   %ecx,%eax
    8e70:	01 d0                	add    %edx,%eax
    8e72:	01 d8                	add    %ebx,%eax
    8e74:	c1 e8 10             	shr    $0x10,%eax
    8e77:	89 c2                	mov    %eax,%edx
    8e79:	8b 45 14             	mov    0x14(%ebp),%eax
    8e7c:	88 10                	mov    %dl,(%eax)
}
    8e7e:	90                   	nop
    8e7f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8e82:	c9                   	leave  
    8e83:	c3                   	ret    

00008e84 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    8e84:	55                   	push   %ebp
    8e85:	89 e5                	mov    %esp,%ebp
    8e87:	53                   	push   %ebx
    8e88:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    8e8b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e8e:	8b 00                	mov    (%eax),%eax
    8e90:	c1 e0 10             	shl    $0x10,%eax
    8e93:	89 c1                	mov    %eax,%ecx
    8e95:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e98:	8b 18                	mov    (%eax),%ebx
    8e9a:	89 c8                	mov    %ecx,%eax
    8e9c:	99                   	cltd   
    8e9d:	f7 fb                	idiv   %ebx
    8e9f:	83 c0 01             	add    $0x1,%eax
    8ea2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    8ea5:	8b 45 08             	mov    0x8(%ebp),%eax
    8ea8:	8b 40 04             	mov    0x4(%eax),%eax
    8eab:	c1 e0 10             	shl    $0x10,%eax
    8eae:	89 c1                	mov    %eax,%ecx
    8eb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8eb3:	8b 58 04             	mov    0x4(%eax),%ebx
    8eb6:	89 c8                	mov    %ecx,%eax
    8eb8:	99                   	cltd   
    8eb9:	f7 fb                	idiv   %ebx
    8ebb:	83 c0 01             	add    $0x1,%eax
    8ebe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    8ec1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8ec4:	d1 f8                	sar    %eax
    8ec6:	2d 00 80 00 00       	sub    $0x8000,%eax
    8ecb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    8ece:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8ed1:	d1 f8                	sar    %eax
    8ed3:	2d 00 80 00 00       	sub    $0x8000,%eax
    8ed8:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    8edb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8ede:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    8ee1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8ee8:	eb 5d                	jmp    8f47 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    8eea:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8eed:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    8ef0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    8ef7:	eb 3a                	jmp    8f33 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    8ef9:	8b 45 0c             	mov    0xc(%ebp),%eax
    8efc:	8b 48 08             	mov    0x8(%eax),%ecx
    8eff:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f02:	8b 00                	mov    (%eax),%eax
    8f04:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    8f08:	89 c2                	mov    %eax,%edx
    8f0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8f0d:	01 c2                	add    %eax,%edx
    8f0f:	89 d0                	mov    %edx,%eax
    8f11:	01 c0                	add    %eax,%eax
    8f13:	01 d0                	add    %edx,%eax
    8f15:	01 c8                	add    %ecx,%eax
    8f17:	50                   	push   %eax
    8f18:	ff 75 f0             	pushl  -0x10(%ebp)
    8f1b:	ff 75 f8             	pushl  -0x8(%ebp)
    8f1e:	ff 75 08             	pushl  0x8(%ebp)
    8f21:	e8 4d fd ff ff       	call   8c73 <mixColorInt>
    8f26:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    8f29:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8f2c:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    8f2f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    8f33:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f36:	8b 00                	mov    (%eax),%eax
    8f38:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    8f3b:	7f bc                	jg     8ef9 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    8f3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8f40:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    8f43:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8f47:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f4a:	8b 40 04             	mov    0x4(%eax),%eax
    8f4d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8f50:	7f 98                	jg     8eea <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    8f52:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8f57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8f5a:	c9                   	leave  
    8f5b:	c3                   	ret    

00008f5c <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    8f5c:	55                   	push   %ebp
    8f5d:	89 e5                	mov    %esp,%ebp
    8f5f:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    8f62:	8b 45 08             	mov    0x8(%ebp),%eax
    8f65:	8b 00                	mov    (%eax),%eax
    8f67:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8f6a:	db 45 e4             	fildl  -0x1c(%ebp)
    8f6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f70:	8b 00                	mov    (%eax),%eax
    8f72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8f75:	db 45 e4             	fildl  -0x1c(%ebp)
    8f78:	de f9                	fdivrp %st,%st(1)
    8f7a:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    8f7d:	8b 45 08             	mov    0x8(%ebp),%eax
    8f80:	8b 40 04             	mov    0x4(%eax),%eax
    8f83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8f86:	db 45 e4             	fildl  -0x1c(%ebp)
    8f89:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f8c:	8b 40 04             	mov    0x4(%eax),%eax
    8f8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    8f92:	db 45 e4             	fildl  -0x1c(%ebp)
    8f95:	de f9                	fdivrp %st,%st(1)
    8f97:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    8f9a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8fa1:	eb 5e                	jmp    9001 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    8fa3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8faa:	eb 47                	jmp    8ff3 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    8fac:	db 45 f8             	fildl  -0x8(%ebp)
    8faf:	d8 4d f4             	fmuls  -0xc(%ebp)
    8fb2:	d9 7d ee             	fnstcw -0x12(%ebp)
    8fb5:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    8fb9:	b4 0c                	mov    $0xc,%ah
    8fbb:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    8fbf:	d9 6d ec             	fldcw  -0x14(%ebp)
    8fc2:	db 5d e8             	fistpl -0x18(%ebp)
    8fc5:	d9 6d ee             	fldcw  -0x12(%ebp)
    8fc8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8fcb:	db 45 fc             	fildl  -0x4(%ebp)
    8fce:	d8 4d f0             	fmuls  -0x10(%ebp)
    8fd1:	d9 6d ec             	fldcw  -0x14(%ebp)
    8fd4:	db 5d e8             	fistpl -0x18(%ebp)
    8fd7:	d9 6d ee             	fldcw  -0x12(%ebp)
    8fda:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8fdd:	6a 00                	push   $0x0
    8fdf:	52                   	push   %edx
    8fe0:	50                   	push   %eax
    8fe1:	ff 75 08             	pushl  0x8(%ebp)
    8fe4:	e8 10 f9 ff ff       	call   88f9 <getColor>
    8fe9:	83 c4 10             	add    $0x10,%esp
    8fec:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    8fef:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8ff3:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ff6:	8b 00                	mov    (%eax),%eax
    8ff8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    8ffb:	7f af                	jg     8fac <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    8ffd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9001:	8b 45 0c             	mov    0xc(%ebp),%eax
    9004:	8b 40 04             	mov    0x4(%eax),%eax
    9007:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    900a:	7f 97                	jg     8fa3 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    900c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9011:	c9                   	leave  
    9012:	c3                   	ret    

00009013 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    9013:	55                   	push   %ebp
    9014:	89 e5                	mov    %esp,%ebp
    9016:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    9019:	8b 45 08             	mov    0x8(%ebp),%eax
    901c:	8b 00                	mov    (%eax),%eax
    901e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    9021:	db 45 e0             	fildl  -0x20(%ebp)
    9024:	d9 5d e0             	fstps  -0x20(%ebp)
    9027:	83 ec 0c             	sub    $0xc,%esp
    902a:	ff 75 10             	pushl  0x10(%ebp)
    902d:	e8 6b e2 ff ff       	call   729d <cos>
    9032:	83 c4 10             	add    $0x10,%esp
    9035:	d9 5d dc             	fstps  -0x24(%ebp)
    9038:	8b 45 dc             	mov    -0x24(%ebp),%eax
    903b:	83 ec 0c             	sub    $0xc,%esp
    903e:	50                   	push   %eax
    903f:	e8 90 e1 ff ff       	call   71d4 <abs>
    9044:	83 c4 10             	add    $0x10,%esp
    9047:	d8 4d e0             	fmuls  -0x20(%ebp)
    904a:	d9 5d e0             	fstps  -0x20(%ebp)
    904d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9050:	8b 00                	mov    (%eax),%eax
    9052:	89 45 dc             	mov    %eax,-0x24(%ebp)
    9055:	db 45 dc             	fildl  -0x24(%ebp)
    9058:	d9 5d dc             	fstps  -0x24(%ebp)
    905b:	83 ec 0c             	sub    $0xc,%esp
    905e:	ff 75 10             	pushl  0x10(%ebp)
    9061:	e8 da e3 ff ff       	call   7440 <sin>
    9066:	83 c4 10             	add    $0x10,%esp
    9069:	d9 5d d8             	fstps  -0x28(%ebp)
    906c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    906f:	83 ec 0c             	sub    $0xc,%esp
    9072:	50                   	push   %eax
    9073:	e8 5c e1 ff ff       	call   71d4 <abs>
    9078:	83 c4 10             	add    $0x10,%esp
    907b:	d8 4d dc             	fmuls  -0x24(%ebp)
    907e:	d8 45 e0             	fadds  -0x20(%ebp)
    9081:	d9 7d e6             	fnstcw -0x1a(%ebp)
    9084:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    9088:	b4 0c                	mov    $0xc,%ah
    908a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    908e:	d9 6d e4             	fldcw  -0x1c(%ebp)
    9091:	db 5d f4             	fistpl -0xc(%ebp)
    9094:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    9097:	8b 45 08             	mov    0x8(%ebp),%eax
    909a:	8b 00                	mov    (%eax),%eax
    909c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    909f:	db 45 e0             	fildl  -0x20(%ebp)
    90a2:	d9 5d e0             	fstps  -0x20(%ebp)
    90a5:	83 ec 0c             	sub    $0xc,%esp
    90a8:	ff 75 10             	pushl  0x10(%ebp)
    90ab:	e8 90 e3 ff ff       	call   7440 <sin>
    90b0:	83 c4 10             	add    $0x10,%esp
    90b3:	d9 5d dc             	fstps  -0x24(%ebp)
    90b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    90b9:	83 ec 0c             	sub    $0xc,%esp
    90bc:	50                   	push   %eax
    90bd:	e8 12 e1 ff ff       	call   71d4 <abs>
    90c2:	83 c4 10             	add    $0x10,%esp
    90c5:	d8 4d e0             	fmuls  -0x20(%ebp)
    90c8:	d9 5d e0             	fstps  -0x20(%ebp)
    90cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    90ce:	8b 00                	mov    (%eax),%eax
    90d0:	89 45 dc             	mov    %eax,-0x24(%ebp)
    90d3:	db 45 dc             	fildl  -0x24(%ebp)
    90d6:	d9 5d dc             	fstps  -0x24(%ebp)
    90d9:	83 ec 0c             	sub    $0xc,%esp
    90dc:	ff 75 10             	pushl  0x10(%ebp)
    90df:	e8 b9 e1 ff ff       	call   729d <cos>
    90e4:	83 c4 10             	add    $0x10,%esp
    90e7:	d9 5d d8             	fstps  -0x28(%ebp)
    90ea:	8b 45 d8             	mov    -0x28(%ebp),%eax
    90ed:	83 ec 0c             	sub    $0xc,%esp
    90f0:	50                   	push   %eax
    90f1:	e8 de e0 ff ff       	call   71d4 <abs>
    90f6:	83 c4 10             	add    $0x10,%esp
    90f9:	d8 4d dc             	fmuls  -0x24(%ebp)
    90fc:	d8 45 e0             	fadds  -0x20(%ebp)
    90ff:	d9 7d e6             	fnstcw -0x1a(%ebp)
    9102:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    9106:	b4 0c                	mov    $0xc,%ah
    9108:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    910c:	d9 6d e4             	fldcw  -0x1c(%ebp)
    910f:	db 5d f0             	fistpl -0x10(%ebp)
    9112:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    9115:	8b 45 0c             	mov    0xc(%ebp),%eax
    9118:	8b 55 f0             	mov    -0x10(%ebp),%edx
    911b:	89 10                	mov    %edx,(%eax)
    *width = w;
    911d:	8b 45 08             	mov    0x8(%ebp),%eax
    9120:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9123:	89 10                	mov    %edx,(%eax)
    return 1;
    9125:	b8 01 00 00 00       	mov    $0x1,%eax
}
    912a:	c9                   	leave  
    912b:	c3                   	ret    

0000912c <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    912c:	55                   	push   %ebp
    912d:	89 e5                	mov    %esp,%ebp
    912f:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    9132:	8b 45 08             	mov    0x8(%ebp),%eax
    9135:	8b 40 04             	mov    0x4(%eax),%eax
    9138:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    913b:	db 45 c4             	fildl  -0x3c(%ebp)
    913e:	d9 05 a4 07 02 00    	flds   0x207a4
    9144:	de f9                	fdivrp %st,%st(1)
    9146:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    9149:	8b 45 08             	mov    0x8(%ebp),%eax
    914c:	8b 00                	mov    (%eax),%eax
    914e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    9151:	db 45 c4             	fildl  -0x3c(%ebp)
    9154:	d9 05 a4 07 02 00    	flds   0x207a4
    915a:	de f9                	fdivrp %st,%st(1)
    915c:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    915f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9162:	8b 50 04             	mov    0x4(%eax),%edx
    9165:	8b 45 08             	mov    0x8(%ebp),%eax
    9168:	8b 40 04             	mov    0x4(%eax),%eax
    916b:	29 c2                	sub    %eax,%edx
    916d:	89 d0                	mov    %edx,%eax
    916f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    9172:	db 45 c4             	fildl  -0x3c(%ebp)
    9175:	d9 05 a4 07 02 00    	flds   0x207a4
    917b:	de f9                	fdivrp %st,%st(1)
    917d:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    9180:	8b 45 0c             	mov    0xc(%ebp),%eax
    9183:	8b 10                	mov    (%eax),%edx
    9185:	8b 45 08             	mov    0x8(%ebp),%eax
    9188:	8b 00                	mov    (%eax),%eax
    918a:	29 c2                	sub    %eax,%edx
    918c:	89 d0                	mov    %edx,%eax
    918e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    9191:	db 45 c4             	fildl  -0x3c(%ebp)
    9194:	d9 05 a4 07 02 00    	flds   0x207a4
    919a:	de f9                	fdivrp %st,%st(1)
    919c:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    919f:	d9 45 10             	flds   0x10(%ebp)
    91a2:	d9 e0                	fchs   
    91a4:	83 ec 0c             	sub    $0xc,%esp
    91a7:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    91ab:	d9 1c 24             	fstps  (%esp)
    91ae:	e8 ea e0 ff ff       	call   729d <cos>
    91b3:	83 c4 10             	add    $0x10,%esp
    91b6:	d9 5d c4             	fstps  -0x3c(%ebp)
    91b9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    91bc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    91bf:	d9 45 10             	flds   0x10(%ebp)
    91c2:	d9 e0                	fchs   
    91c4:	83 ec 0c             	sub    $0xc,%esp
    91c7:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    91cb:	d9 1c 24             	fstps  (%esp)
    91ce:	e8 6d e2 ff ff       	call   7440 <sin>
    91d3:	83 c4 10             	add    $0x10,%esp
    91d6:	d9 5d c4             	fstps  -0x3c(%ebp)
    91d9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    91dc:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    91df:	d9 ee                	fldz   
    91e1:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    91e4:	d9 ee                	fldz   
    91e6:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    91e9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    91f0:	e9 28 01 00 00       	jmp    931d <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    91f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    91fc:	e9 0a 01 00 00       	jmp    930b <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    9201:	db 45 f4             	fildl  -0xc(%ebp)
    9204:	d8 65 e4             	fsubs  -0x1c(%ebp)
    9207:	d8 65 ec             	fsubs  -0x14(%ebp)
    920a:	d8 4d dc             	fmuls  -0x24(%ebp)
    920d:	db 45 f0             	fildl  -0x10(%ebp)
    9210:	d8 65 e0             	fsubs  -0x20(%ebp)
    9213:	d8 65 e8             	fsubs  -0x18(%ebp)
    9216:	d8 4d d8             	fmuls  -0x28(%ebp)
    9219:	de c1                	faddp  %st,%st(1)
    921b:	d8 45 ec             	fadds  -0x14(%ebp)
    921e:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    9221:	db 45 f0             	fildl  -0x10(%ebp)
    9224:	d8 65 e0             	fsubs  -0x20(%ebp)
    9227:	d8 65 e8             	fsubs  -0x18(%ebp)
    922a:	d8 4d dc             	fmuls  -0x24(%ebp)
    922d:	db 45 f4             	fildl  -0xc(%ebp)
    9230:	d8 65 e4             	fsubs  -0x1c(%ebp)
    9233:	d8 65 ec             	fsubs  -0x14(%ebp)
    9236:	d8 4d d8             	fmuls  -0x28(%ebp)
    9239:	de e9                	fsubrp %st,%st(1)
    923b:	d8 45 e8             	fadds  -0x18(%ebp)
    923e:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    9241:	d9 45 d4             	flds   -0x2c(%ebp)
    9244:	d9 ee                	fldz   
    9246:	d9 c9                	fxch   %st(1)
    9248:	df e9                	fucomip %st(1),%st
    924a:	dd d8                	fstp   %st(0)
    924c:	0f 93 c0             	setae  %al
    924f:	83 f0 01             	xor    $0x1,%eax
    9252:	84 c0                	test   %al,%al
    9254:	75 52                	jne    92a8 <picTurn+0x17c>
    9256:	8b 45 08             	mov    0x8(%ebp),%eax
    9259:	8b 40 04             	mov    0x4(%eax),%eax
    925c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    925f:	db 45 c4             	fildl  -0x3c(%ebp)
    9262:	d9 45 d4             	flds   -0x2c(%ebp)
    9265:	d9 c9                	fxch   %st(1)
    9267:	df e9                	fucomip %st(1),%st
    9269:	dd d8                	fstp   %st(0)
    926b:	0f 97 c0             	seta   %al
    926e:	83 f0 01             	xor    $0x1,%eax
    9271:	84 c0                	test   %al,%al
    9273:	75 33                	jne    92a8 <picTurn+0x17c>
    9275:	d9 45 d0             	flds   -0x30(%ebp)
    9278:	d9 ee                	fldz   
    927a:	d9 c9                	fxch   %st(1)
    927c:	df e9                	fucomip %st(1),%st
    927e:	dd d8                	fstp   %st(0)
    9280:	0f 93 c0             	setae  %al
    9283:	83 f0 01             	xor    $0x1,%eax
    9286:	84 c0                	test   %al,%al
    9288:	75 1e                	jne    92a8 <picTurn+0x17c>
    928a:	8b 45 08             	mov    0x8(%ebp),%eax
    928d:	8b 00                	mov    (%eax),%eax
    928f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    9292:	db 45 c4             	fildl  -0x3c(%ebp)
    9295:	d9 45 d0             	flds   -0x30(%ebp)
    9298:	d9 c9                	fxch   %st(1)
    929a:	df e9                	fucomip %st(1),%st
    929c:	dd d8                	fstp   %st(0)
    929e:	0f 97 c0             	seta   %al
    92a1:	83 f0 01             	xor    $0x1,%eax
    92a4:	84 c0                	test   %al,%al
    92a6:	74 2f                	je     92d7 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    92a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    92ab:	8b 48 08             	mov    0x8(%eax),%ecx
    92ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    92b1:	8b 00                	mov    (%eax),%eax
    92b3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    92b7:	89 c2                	mov    %eax,%edx
    92b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    92bc:	01 c2                	add    %eax,%edx
    92be:	89 d0                	mov    %edx,%eax
    92c0:	01 c0                	add    %eax,%eax
    92c2:	01 d0                	add    %edx,%eax
    92c4:	01 c8                	add    %ecx,%eax
    92c6:	83 ec 08             	sub    $0x8,%esp
    92c9:	50                   	push   %eax
    92ca:	68 55 53 02 00       	push   $0x25355
    92cf:	e8 9f f6 ff ff       	call   8973 <setColor>
    92d4:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    92d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    92da:	8b 48 08             	mov    0x8(%eax),%ecx
    92dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    92e0:	8b 00                	mov    (%eax),%eax
    92e2:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    92e6:	89 c2                	mov    %eax,%edx
    92e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    92eb:	01 c2                	add    %eax,%edx
    92ed:	89 d0                	mov    %edx,%eax
    92ef:	01 c0                	add    %eax,%eax
    92f1:	01 d0                	add    %edx,%eax
    92f3:	01 c8                	add    %ecx,%eax
    92f5:	50                   	push   %eax
    92f6:	ff 75 d0             	pushl  -0x30(%ebp)
    92f9:	ff 75 d4             	pushl  -0x2c(%ebp)
    92fc:	ff 75 08             	pushl  0x8(%ebp)
    92ff:	e8 9e f6 ff ff       	call   89a2 <mixColor>
    9304:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    9307:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    930b:	8b 45 0c             	mov    0xc(%ebp),%eax
    930e:	8b 00                	mov    (%eax),%eax
    9310:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9313:	0f 8f e8 fe ff ff    	jg     9201 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    9319:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    931d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9320:	8b 40 04             	mov    0x4(%eax),%eax
    9323:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9326:	0f 8f c9 fe ff ff    	jg     91f5 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    932c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9331:	c9                   	leave  
    9332:	c3                   	ret    

00009333 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    9333:	55                   	push   %ebp
    9334:	89 e5                	mov    %esp,%ebp
    9336:	53                   	push   %ebx
    9337:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    933a:	8b 45 08             	mov    0x8(%ebp),%eax
    933d:	8b 10                	mov    (%eax),%edx
    933f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9342:	8b 00                	mov    (%eax),%eax
    9344:	39 c2                	cmp    %eax,%edx
    9346:	75 10                	jne    9358 <picRollingOver+0x25>
    9348:	8b 45 08             	mov    0x8(%ebp),%eax
    934b:	8b 50 04             	mov    0x4(%eax),%edx
    934e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9351:	8b 40 04             	mov    0x4(%eax),%eax
    9354:	39 c2                	cmp    %eax,%edx
    9356:	74 0a                	je     9362 <picRollingOver+0x2f>
        return 0;
    9358:	b8 00 00 00 00       	mov    $0x0,%eax
    935d:	e9 88 00 00 00       	jmp    93ea <picRollingOver+0xb7>

    int h = src->height;
    9362:	8b 45 08             	mov    0x8(%ebp),%eax
    9365:	8b 40 04             	mov    0x4(%eax),%eax
    9368:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    936b:	8b 45 08             	mov    0x8(%ebp),%eax
    936e:	8b 00                	mov    (%eax),%eax
    9370:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    9373:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    937a:	eb 61                	jmp    93dd <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    937c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9383:	eb 4c                	jmp    93d1 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    9385:	8b 45 0c             	mov    0xc(%ebp),%eax
    9388:	8b 48 08             	mov    0x8(%eax),%ecx
    938b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    938e:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9391:	83 e8 01             	sub    $0x1,%eax
    9394:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    9398:	89 c2                	mov    %eax,%edx
    939a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    939d:	01 c2                	add    %eax,%edx
    939f:	89 d0                	mov    %edx,%eax
    93a1:	01 c0                	add    %eax,%eax
    93a3:	01 d0                	add    %edx,%eax
    93a5:	01 c1                	add    %eax,%ecx
    93a7:	8b 45 08             	mov    0x8(%ebp),%eax
    93aa:	8b 58 08             	mov    0x8(%eax),%ebx
    93ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    93b0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    93b4:	89 c2                	mov    %eax,%edx
    93b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    93b9:	01 c2                	add    %eax,%edx
    93bb:	89 d0                	mov    %edx,%eax
    93bd:	01 c0                	add    %eax,%eax
    93bf:	01 d0                	add    %edx,%eax
    93c1:	01 d8                	add    %ebx,%eax
    93c3:	51                   	push   %ecx
    93c4:	50                   	push   %eax
    93c5:	e8 a9 f5 ff ff       	call   8973 <setColor>
    93ca:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    93cd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    93d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    93d4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    93d7:	7c ac                	jl     9385 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    93d9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    93dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    93e0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    93e3:	7c 97                	jl     937c <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    93e5:	b8 01 00 00 00       	mov    $0x1,%eax
}
    93ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    93ed:	c9                   	leave  
    93ee:	c3                   	ret    

000093ef <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    93ef:	55                   	push   %ebp
    93f0:	89 e5                	mov    %esp,%ebp
    93f2:	53                   	push   %ebx
    93f3:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    93f6:	8b 45 08             	mov    0x8(%ebp),%eax
    93f9:	8b 10                	mov    (%eax),%edx
    93fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    93fe:	8b 00                	mov    (%eax),%eax
    9400:	39 c2                	cmp    %eax,%edx
    9402:	75 10                	jne    9414 <picTurnAround+0x25>
    9404:	8b 45 08             	mov    0x8(%ebp),%eax
    9407:	8b 50 04             	mov    0x4(%eax),%edx
    940a:	8b 45 0c             	mov    0xc(%ebp),%eax
    940d:	8b 40 04             	mov    0x4(%eax),%eax
    9410:	39 c2                	cmp    %eax,%edx
    9412:	74 0a                	je     941e <picTurnAround+0x2f>
        return 0;
    9414:	b8 00 00 00 00       	mov    $0x0,%eax
    9419:	e9 88 00 00 00       	jmp    94a6 <picTurnAround+0xb7>

    int h = src->height;
    941e:	8b 45 08             	mov    0x8(%ebp),%eax
    9421:	8b 40 04             	mov    0x4(%eax),%eax
    9424:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    9427:	8b 45 08             	mov    0x8(%ebp),%eax
    942a:	8b 00                	mov    (%eax),%eax
    942c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    942f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9436:	eb 61                	jmp    9499 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    9438:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    943f:	eb 4c                	jmp    948d <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    9441:	8b 45 0c             	mov    0xc(%ebp),%eax
    9444:	8b 48 08             	mov    0x8(%eax),%ecx
    9447:	8b 45 f8             	mov    -0x8(%ebp),%eax
    944a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    944e:	89 c2                	mov    %eax,%edx
    9450:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9453:	2b 45 f4             	sub    -0xc(%ebp),%eax
    9456:	01 c2                	add    %eax,%edx
    9458:	89 d0                	mov    %edx,%eax
    945a:	01 c0                	add    %eax,%eax
    945c:	01 d0                	add    %edx,%eax
    945e:	83 e8 03             	sub    $0x3,%eax
    9461:	01 c1                	add    %eax,%ecx
    9463:	8b 45 08             	mov    0x8(%ebp),%eax
    9466:	8b 58 08             	mov    0x8(%eax),%ebx
    9469:	8b 45 f8             	mov    -0x8(%ebp),%eax
    946c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    9470:	89 c2                	mov    %eax,%edx
    9472:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9475:	01 c2                	add    %eax,%edx
    9477:	89 d0                	mov    %edx,%eax
    9479:	01 c0                	add    %eax,%eax
    947b:	01 d0                	add    %edx,%eax
    947d:	01 d8                	add    %ebx,%eax
    947f:	51                   	push   %ecx
    9480:	50                   	push   %eax
    9481:	e8 ed f4 ff ff       	call   8973 <setColor>
    9486:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    9489:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    948d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9490:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    9493:	7c ac                	jl     9441 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    9495:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9499:	8b 45 f8             	mov    -0x8(%ebp),%eax
    949c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    949f:	7c 97                	jl     9438 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    94a1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    94a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    94a9:	c9                   	leave  
    94aa:	c3                   	ret    

000094ab <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    94ab:	55                   	push   %ebp
    94ac:	89 e5                	mov    %esp,%ebp
    94ae:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    94b1:	83 ec 0c             	sub    $0xc,%esp
    94b4:	ff 75 08             	pushl  0x8(%ebp)
    94b7:	e8 c5 d5 ff ff       	call   6a81 <strlen>
    94bc:	83 c4 10             	add    $0x10,%esp
    94bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    94c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    94c5:	8d 50 ff             	lea    -0x1(%eax),%edx
    94c8:	8b 45 08             	mov    0x8(%ebp),%eax
    94cb:	01 d0                	add    %edx,%eax
    94cd:	0f b6 00             	movzbl (%eax),%eax
    94d0:	3c 67                	cmp    $0x67,%al
    94d2:	75 2b                	jne    94ff <type+0x54>
    94d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    94d7:	8d 50 fe             	lea    -0x2(%eax),%edx
    94da:	8b 45 08             	mov    0x8(%ebp),%eax
    94dd:	01 d0                	add    %edx,%eax
    94df:	0f b6 00             	movzbl (%eax),%eax
    94e2:	3c 70                	cmp    $0x70,%al
    94e4:	75 19                	jne    94ff <type+0x54>
    94e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    94e9:	8d 50 fd             	lea    -0x3(%eax),%edx
    94ec:	8b 45 08             	mov    0x8(%ebp),%eax
    94ef:	01 d0                	add    %edx,%eax
    94f1:	0f b6 00             	movzbl (%eax),%eax
    94f4:	3c 6a                	cmp    $0x6a,%al
    94f6:	75 07                	jne    94ff <type+0x54>
    94f8:	b8 00 00 00 00       	mov    $0x0,%eax
    94fd:	eb 7f                	jmp    957e <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    94ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9502:	8d 50 ff             	lea    -0x1(%eax),%edx
    9505:	8b 45 08             	mov    0x8(%ebp),%eax
    9508:	01 d0                	add    %edx,%eax
    950a:	0f b6 00             	movzbl (%eax),%eax
    950d:	3c 70                	cmp    $0x70,%al
    950f:	75 2b                	jne    953c <type+0x91>
    9511:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9514:	8d 50 fe             	lea    -0x2(%eax),%edx
    9517:	8b 45 08             	mov    0x8(%ebp),%eax
    951a:	01 d0                	add    %edx,%eax
    951c:	0f b6 00             	movzbl (%eax),%eax
    951f:	3c 6d                	cmp    $0x6d,%al
    9521:	75 19                	jne    953c <type+0x91>
    9523:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9526:	8d 50 fd             	lea    -0x3(%eax),%edx
    9529:	8b 45 08             	mov    0x8(%ebp),%eax
    952c:	01 d0                	add    %edx,%eax
    952e:	0f b6 00             	movzbl (%eax),%eax
    9531:	3c 62                	cmp    $0x62,%al
    9533:	75 07                	jne    953c <type+0x91>
    9535:	b8 01 00 00 00       	mov    $0x1,%eax
    953a:	eb 42                	jmp    957e <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    953c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    953f:	8d 50 ff             	lea    -0x1(%eax),%edx
    9542:	8b 45 08             	mov    0x8(%ebp),%eax
    9545:	01 d0                	add    %edx,%eax
    9547:	0f b6 00             	movzbl (%eax),%eax
    954a:	3c 67                	cmp    $0x67,%al
    954c:	75 2b                	jne    9579 <type+0xce>
    954e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9551:	8d 50 fe             	lea    -0x2(%eax),%edx
    9554:	8b 45 08             	mov    0x8(%ebp),%eax
    9557:	01 d0                	add    %edx,%eax
    9559:	0f b6 00             	movzbl (%eax),%eax
    955c:	3c 6e                	cmp    $0x6e,%al
    955e:	75 19                	jne    9579 <type+0xce>
    9560:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9563:	8d 50 fd             	lea    -0x3(%eax),%edx
    9566:	8b 45 08             	mov    0x8(%ebp),%eax
    9569:	01 d0                	add    %edx,%eax
    956b:	0f b6 00             	movzbl (%eax),%eax
    956e:	3c 70                	cmp    $0x70,%al
    9570:	75 07                	jne    9579 <type+0xce>
    9572:	b8 02 00 00 00       	mov    $0x2,%eax
    9577:	eb 05                	jmp    957e <type+0xd3>
    else return NONE;
    9579:	b8 03 00 00 00       	mov    $0x3,%eax
}
    957e:	c9                   	leave  
    957f:	c3                   	ret    

00009580 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    9580:	55                   	push   %ebp
    9581:	89 e5                	mov    %esp,%ebp
    9583:	56                   	push   %esi
    9584:	53                   	push   %ebx
    9585:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    9588:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    958f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    9596:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    959d:	83 ec 08             	sub    $0x8,%esp
    95a0:	6a 00                	push   $0x0
    95a2:	ff 75 0c             	pushl  0xc(%ebp)
    95a5:	e8 d9 d6 ff ff       	call   6c83 <open>
    95aa:	83 c4 10             	add    $0x10,%esp
    95ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
    95b0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    95b4:	79 2c                	jns    95e2 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    95b6:	83 ec 08             	sub    $0x8,%esp
    95b9:	ff 75 0c             	pushl  0xc(%ebp)
    95bc:	68 a8 07 02 00       	push   $0x207a8
    95c1:	e8 24 d8 ff ff       	call   6dea <printf>
    95c6:	83 c4 10             	add    $0x10,%esp
        return bmp;
    95c9:	8b 45 08             	mov    0x8(%ebp),%eax
    95cc:	8b 55 b8             	mov    -0x48(%ebp),%edx
    95cf:	89 10                	mov    %edx,(%eax)
    95d1:	8b 55 bc             	mov    -0x44(%ebp),%edx
    95d4:	89 50 04             	mov    %edx,0x4(%eax)
    95d7:	8b 55 c0             	mov    -0x40(%ebp),%edx
    95da:	89 50 08             	mov    %edx,0x8(%eax)
    95dd:	e9 2d 02 00 00       	jmp    980f <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    95e2:	83 ec 04             	sub    $0x4,%esp
    95e5:	6a 0e                	push   $0xe
    95e7:	8d 45 aa             	lea    -0x56(%ebp),%eax
    95ea:	50                   	push   %eax
    95eb:	ff 75 ec             	pushl  -0x14(%ebp)
    95ee:	e8 68 d6 ff ff       	call   6c5b <read>
    95f3:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    95f6:	83 ec 04             	sub    $0x4,%esp
    95f9:	6a 28                	push   $0x28
    95fb:	8d 45 82             	lea    -0x7e(%ebp),%eax
    95fe:	50                   	push   %eax
    95ff:	ff 75 ec             	pushl  -0x14(%ebp)
    9602:	e8 54 d6 ff ff       	call   6c5b <read>
    9607:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    960a:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    960e:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    9611:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    9615:	0f b7 d8             	movzwl %ax,%ebx
    9618:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    961b:	8b 55 ac             	mov    -0x54(%ebp),%edx
    961e:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    9622:	0f b7 c0             	movzwl %ax,%eax
    9625:	83 ec 04             	sub    $0x4,%esp
    9628:	6a 36                	push   $0x36
    962a:	56                   	push   %esi
    962b:	53                   	push   %ebx
    962c:	51                   	push   %ecx
    962d:	52                   	push   %edx
    962e:	50                   	push   %eax
    962f:	68 b8 07 02 00       	push   $0x207b8
    9634:	e8 b1 d7 ff ff       	call   6dea <printf>
    9639:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    963c:	8b 45 86             	mov    -0x7a(%ebp),%eax
    963f:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    9642:	8b 45 8a             	mov    -0x76(%ebp),%eax
    9645:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    9648:	8b 55 b8             	mov    -0x48(%ebp),%edx
    964b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    964e:	0f af c2             	imul   %edx,%eax
    9651:	89 c2                	mov    %eax,%edx
    9653:	89 d0                	mov    %edx,%eax
    9655:	01 c0                	add    %eax,%eax
    9657:	01 d0                	add    %edx,%eax
    9659:	83 ec 0c             	sub    $0xc,%esp
    965c:	50                   	push   %eax
    965d:	e8 5b da ff ff       	call   70bd <malloc>
    9662:	83 c4 10             	add    $0x10,%esp
    9665:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    9668:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    966c:	0f b7 c0             	movzwl %ax,%eax
    966f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    9672:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9675:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    9679:	83 c0 1f             	add    $0x1f,%eax
    967c:	c1 f8 05             	sar    $0x5,%eax
    967f:	c1 e0 02             	shl    $0x2,%eax
    9682:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    9685:	8b 45 bc             	mov    -0x44(%ebp),%eax
    9688:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    968c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    968f:	8b 55 bc             	mov    -0x44(%ebp),%edx
    9692:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9695:	83 ec 08             	sub    $0x8,%esp
    9698:	52                   	push   %edx
    9699:	50                   	push   %eax
    969a:	ff 75 e8             	pushl  -0x18(%ebp)
    969d:	ff 75 e0             	pushl  -0x20(%ebp)
    96a0:	ff 75 e4             	pushl  -0x1c(%ebp)
    96a3:	68 e0 07 02 00       	push   $0x207e0
    96a8:	e8 3d d7 ff ff       	call   6dea <printf>
    96ad:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    96b0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    96b3:	83 e8 36             	sub    $0x36,%eax
    96b6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    96b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    96bc:	83 ec 0c             	sub    $0xc,%esp
    96bf:	50                   	push   %eax
    96c0:	e8 f8 d9 ff ff       	call   70bd <malloc>
    96c5:	83 c4 10             	add    $0x10,%esp
    96c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    96cb:	83 ec 04             	sub    $0x4,%esp
    96ce:	ff 75 dc             	pushl  -0x24(%ebp)
    96d1:	ff 75 d8             	pushl  -0x28(%ebp)
    96d4:	ff 75 ec             	pushl  -0x14(%ebp)
    96d7:	e8 7f d5 ff ff       	call   6c5b <read>
    96dc:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    96df:	8b 45 ac             	mov    -0x54(%ebp),%eax
    96e2:	83 ec 0c             	sub    $0xc,%esp
    96e5:	50                   	push   %eax
    96e6:	e8 d2 d9 ff ff       	call   70bd <malloc>
    96eb:	83 c4 10             	add    $0x10,%esp
    96ee:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    96f1:	8b 45 ac             	mov    -0x54(%ebp),%eax
    96f4:	83 ec 04             	sub    $0x4,%esp
    96f7:	50                   	push   %eax
    96f8:	ff 75 d4             	pushl  -0x2c(%ebp)
    96fb:	ff 75 ec             	pushl  -0x14(%ebp)
    96fe:	e8 58 d5 ff ff       	call   6c5b <read>
    9703:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    9706:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    970a:	66 c1 e8 03          	shr    $0x3,%ax
    970e:	0f b7 c0             	movzwl %ax,%eax
    9711:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    9714:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    971b:	e9 c1 00 00 00       	jmp    97e1 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    9720:	8b 45 bc             	mov    -0x44(%ebp),%eax
    9723:	2b 45 f4             	sub    -0xc(%ebp),%eax
    9726:	8d 50 ff             	lea    -0x1(%eax),%edx
    9729:	8b 45 b8             	mov    -0x48(%ebp),%eax
    972c:	0f af c2             	imul   %edx,%eax
    972f:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    9732:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9735:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    9739:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    973c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9743:	e9 89 00 00 00       	jmp    97d1 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    9748:	8b 45 f0             	mov    -0x10(%ebp),%eax
    974b:	83 c0 01             	add    $0x1,%eax
    974e:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    9752:	89 c2                	mov    %eax,%edx
    9754:	8b 45 c8             	mov    -0x38(%ebp),%eax
    9757:	01 d0                	add    %edx,%eax
    9759:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    975c:	8b 55 c0             	mov    -0x40(%ebp),%edx
    975f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    9762:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9765:	01 c8                	add    %ecx,%eax
    9767:	89 c1                	mov    %eax,%ecx
    9769:	89 c8                	mov    %ecx,%eax
    976b:	01 c0                	add    %eax,%eax
    976d:	01 c8                	add    %ecx,%eax
    976f:	01 c2                	add    %eax,%edx
    9771:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    9774:	8d 48 ff             	lea    -0x1(%eax),%ecx
    9777:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    977a:	01 c8                	add    %ecx,%eax
    977c:	0f b6 00             	movzbl (%eax),%eax
    977f:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    9782:	8b 55 c0             	mov    -0x40(%ebp),%edx
    9785:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    9788:	8b 45 f0             	mov    -0x10(%ebp),%eax
    978b:	01 c8                	add    %ecx,%eax
    978d:	89 c1                	mov    %eax,%ecx
    978f:	89 c8                	mov    %ecx,%eax
    9791:	01 c0                	add    %eax,%eax
    9793:	01 c8                	add    %ecx,%eax
    9795:	01 c2                	add    %eax,%edx
    9797:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    979a:	8d 48 fe             	lea    -0x2(%eax),%ecx
    979d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    97a0:	01 c8                	add    %ecx,%eax
    97a2:	0f b6 00             	movzbl (%eax),%eax
    97a5:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    97a8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    97ab:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    97ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    97b1:	01 c8                	add    %ecx,%eax
    97b3:	89 c1                	mov    %eax,%ecx
    97b5:	89 c8                	mov    %ecx,%eax
    97b7:	01 c0                	add    %eax,%eax
    97b9:	01 c8                	add    %ecx,%eax
    97bb:	01 c2                	add    %eax,%edx
    97bd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    97c0:	8d 48 fd             	lea    -0x3(%eax),%ecx
    97c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    97c6:	01 c8                	add    %ecx,%eax
    97c8:	0f b6 00             	movzbl (%eax),%eax
    97cb:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    97cd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    97d1:	8b 45 b8             	mov    -0x48(%ebp),%eax
    97d4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    97d7:	0f 8f 6b ff ff ff    	jg     9748 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    97dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    97e1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    97e4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    97e7:	0f 8f 33 ff ff ff    	jg     9720 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    97ed:	83 ec 0c             	sub    $0xc,%esp
    97f0:	ff 75 ec             	pushl  -0x14(%ebp)
    97f3:	e8 73 d4 ff ff       	call   6c6b <close>
    97f8:	83 c4 10             	add    $0x10,%esp
    return bmp;
    97fb:	8b 45 08             	mov    0x8(%ebp),%eax
    97fe:	8b 55 b8             	mov    -0x48(%ebp),%edx
    9801:	89 10                	mov    %edx,(%eax)
    9803:	8b 55 bc             	mov    -0x44(%ebp),%edx
    9806:	89 50 04             	mov    %edx,0x4(%eax)
    9809:	8b 55 c0             	mov    -0x40(%ebp),%edx
    980c:	89 50 08             	mov    %edx,0x8(%eax)
}
    980f:	8b 45 08             	mov    0x8(%ebp),%eax
    9812:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9815:	5b                   	pop    %ebx
    9816:	5e                   	pop    %esi
    9817:	5d                   	pop    %ebp
    9818:	c2 04 00             	ret    $0x4

0000981b <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    981b:	55                   	push   %ebp
    981c:	89 e5                	mov    %esp,%ebp
    981e:	53                   	push   %ebx
    981f:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    9822:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    9826:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    982a:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    982e:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    9832:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    9836:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    983a:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    983e:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    9842:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    9846:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    984a:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    984e:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    9852:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    9856:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    985a:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    985e:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    9862:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    9866:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    986a:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    986e:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    9872:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    9876:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    987a:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    987e:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    9882:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    9886:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    988a:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    988e:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    9892:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    9896:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    989a:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    989e:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    98a2:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    98a6:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    98aa:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    98ae:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    98b2:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    98b6:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    98ba:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    98be:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    98c2:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    98c6:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    98ca:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    98ce:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    98d2:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    98d6:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    98da:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    98de:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    98e2:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    98e6:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    98ea:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    98ee:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    98f2:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    98f6:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    98fa:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    98fe:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    9902:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    9906:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    990a:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    990e:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    9912:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    9916:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    991a:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    991e:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    9922:	83 ec 0c             	sub    $0xc,%esp
    9925:	68 c8 02 08 00       	push   $0x802c8
    992a:	e8 8e d7 ff ff       	call   70bd <malloc>
    992f:	83 c4 10             	add    $0x10,%esp
    9932:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    9935:	83 ec 04             	sub    $0x4,%esp
    9938:	68 c8 02 08 00       	push   $0x802c8
    993d:	6a 00                	push   $0x0
    993f:	ff 75 f0             	pushl  -0x10(%ebp)
    9942:	e8 61 d1 ff ff       	call   6aa8 <memset>
    9947:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    994a:	83 ec 08             	sub    $0x8,%esp
    994d:	6a 00                	push   $0x0
    994f:	ff 75 0c             	pushl  0xc(%ebp)
    9952:	e8 2c d3 ff ff       	call   6c83 <open>
    9957:	83 c4 10             	add    $0x10,%esp
    995a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    995d:	83 ec 0c             	sub    $0xc,%esp
    9960:	68 40 42 0f 00       	push   $0xf4240
    9965:	e8 53 d7 ff ff       	call   70bd <malloc>
    996a:	83 c4 10             	add    $0x10,%esp
    996d:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    9970:	83 ec 04             	sub    $0x4,%esp
    9973:	68 40 42 0f 00       	push   $0xf4240
    9978:	ff 75 e8             	pushl  -0x18(%ebp)
    997b:	ff 75 ec             	pushl  -0x14(%ebp)
    997e:	e8 d8 d2 ff ff       	call   6c5b <read>
    9983:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    9986:	83 ec 0c             	sub    $0xc,%esp
    9989:	ff 75 ec             	pushl  -0x14(%ebp)
    998c:	e8 da d2 ff ff       	call   6c6b <close>
    9991:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    9994:	68 40 42 0f 00       	push   $0xf4240
    9999:	ff 75 e8             	pushl  -0x18(%ebp)
    999c:	8d 45 9c             	lea    -0x64(%ebp),%eax
    999f:	50                   	push   %eax
    99a0:	ff 75 f0             	pushl  -0x10(%ebp)
    99a3:	e8 5e 0c 01 00       	call   1a606 <_DecodeJPEG>
    99a8:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    99ab:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    99b2:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    99b9:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    99c0:	83 ec 0c             	sub    $0xc,%esp
    99c3:	ff 75 f0             	pushl  -0x10(%ebp)
    99c6:	e8 29 0b 01 00       	call   1a4f4 <GetImageSize>
    99cb:	83 c4 10             	add    $0x10,%esp
    99ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    99d1:	83 ec 0c             	sub    $0xc,%esp
    99d4:	ff 75 f0             	pushl  -0x10(%ebp)
    99d7:	e8 e1 0a 01 00       	call   1a4bd <GetImage>
    99dc:	83 c4 10             	add    $0x10,%esp
    99df:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    99e2:	83 ec 0c             	sub    $0xc,%esp
    99e5:	ff 75 f0             	pushl  -0x10(%ebp)
    99e8:	e8 f1 0a 01 00       	call   1a4de <GetWidth>
    99ed:	83 c4 10             	add    $0x10,%esp
    99f0:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    99f3:	83 ec 0c             	sub    $0xc,%esp
    99f6:	ff 75 f0             	pushl  -0x10(%ebp)
    99f9:	e8 eb 0a 01 00       	call   1a4e9 <GetHeight>
    99fe:	83 c4 10             	add    $0x10,%esp
    9a01:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    9a04:	8b 55 90             	mov    -0x70(%ebp),%edx
    9a07:	8b 45 94             	mov    -0x6c(%ebp),%eax
    9a0a:	0f af c2             	imul   %edx,%eax
    9a0d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    9a10:	8b 55 dc             	mov    -0x24(%ebp),%edx
    9a13:	89 d0                	mov    %edx,%eax
    9a15:	01 c0                	add    %eax,%eax
    9a17:	01 d0                	add    %edx,%eax
    9a19:	83 ec 0c             	sub    $0xc,%esp
    9a1c:	50                   	push   %eax
    9a1d:	e8 9b d6 ff ff       	call   70bd <malloc>
    9a22:	83 c4 10             	add    $0x10,%esp
    9a25:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    9a28:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9a2f:	e9 9c 00 00 00       	jmp    9ad0 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    9a34:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    9a37:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9a3a:	ba 56 55 55 55       	mov    $0x55555556,%edx
    9a3f:	89 c8                	mov    %ecx,%eax
    9a41:	f7 ea                	imul   %edx
    9a43:	89 c8                	mov    %ecx,%eax
    9a45:	c1 f8 1f             	sar    $0x1f,%eax
    9a48:	29 c2                	sub    %eax,%edx
    9a4a:	89 d0                	mov    %edx,%eax
    9a4c:	89 c2                	mov    %eax,%edx
    9a4e:	89 d0                	mov    %edx,%eax
    9a50:	01 c0                	add    %eax,%eax
    9a52:	01 d0                	add    %edx,%eax
    9a54:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    9a57:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9a5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9a5d:	01 c8                	add    %ecx,%eax
    9a5f:	0f b6 00             	movzbl (%eax),%eax
    9a62:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    9a65:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    9a68:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9a6b:	ba 56 55 55 55       	mov    $0x55555556,%edx
    9a70:	89 c8                	mov    %ecx,%eax
    9a72:	f7 ea                	imul   %edx
    9a74:	89 c8                	mov    %ecx,%eax
    9a76:	c1 f8 1f             	sar    $0x1f,%eax
    9a79:	29 c2                	sub    %eax,%edx
    9a7b:	89 d0                	mov    %edx,%eax
    9a7d:	89 c2                	mov    %eax,%edx
    9a7f:	89 d0                	mov    %edx,%eax
    9a81:	01 c0                	add    %eax,%eax
    9a83:	01 d0                	add    %edx,%eax
    9a85:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    9a88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9a8b:	8d 48 01             	lea    0x1(%eax),%ecx
    9a8e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9a91:	01 c8                	add    %ecx,%eax
    9a93:	0f b6 00             	movzbl (%eax),%eax
    9a96:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    9a99:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    9a9c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9a9f:	ba 56 55 55 55       	mov    $0x55555556,%edx
    9aa4:	89 c8                	mov    %ecx,%eax
    9aa6:	f7 ea                	imul   %edx
    9aa8:	89 c8                	mov    %ecx,%eax
    9aaa:	c1 f8 1f             	sar    $0x1f,%eax
    9aad:	29 c2                	sub    %eax,%edx
    9aaf:	89 d0                	mov    %edx,%eax
    9ab1:	89 c2                	mov    %eax,%edx
    9ab3:	89 d0                	mov    %edx,%eax
    9ab5:	01 c0                	add    %eax,%eax
    9ab7:	01 d0                	add    %edx,%eax
    9ab9:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    9abc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9abf:	8d 48 02             	lea    0x2(%eax),%ecx
    9ac2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9ac5:	01 c8                	add    %ecx,%eax
    9ac7:	0f b6 00             	movzbl (%eax),%eax
    9aca:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    9acc:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    9ad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9ad3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    9ad6:	0f 8c 58 ff ff ff    	jl     9a34 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    9adc:	8b 45 08             	mov    0x8(%ebp),%eax
    9adf:	8b 55 90             	mov    -0x70(%ebp),%edx
    9ae2:	89 10                	mov    %edx,(%eax)
    9ae4:	8b 55 94             	mov    -0x6c(%ebp),%edx
    9ae7:	89 50 04             	mov    %edx,0x4(%eax)
    9aea:	8b 55 98             	mov    -0x68(%ebp),%edx
    9aed:	89 50 08             	mov    %edx,0x8(%eax)
}
    9af0:	8b 45 08             	mov    0x8(%ebp),%eax
    9af3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9af6:	c9                   	leave  
    9af7:	c2 04 00             	ret    $0x4

00009afa <LoadPng>:

PBitmap LoadPng(char* filename){
    9afa:	55                   	push   %ebp
    9afb:	89 e5                	mov    %esp,%ebp
    9afd:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    9b00:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    9b07:	ff 75 0c             	pushl  0xc(%ebp)
    9b0a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    9b0d:	50                   	push   %eax
    9b0e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    9b11:	50                   	push   %eax
    9b12:	8d 45 e8             	lea    -0x18(%ebp),%eax
    9b15:	50                   	push   %eax
    9b16:	e8 d3 d3 00 00       	call   16eee <lodepng_decode24_file>
    9b1b:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    9b1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9b21:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    9b24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9b27:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    9b2a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    9b31:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    9b34:	8b 45 d8             	mov    -0x28(%ebp),%eax
    9b37:	0f af c2             	imul   %edx,%eax
    9b3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    9b3d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9b40:	89 d0                	mov    %edx,%eax
    9b42:	01 c0                	add    %eax,%eax
    9b44:	01 d0                	add    %edx,%eax
    9b46:	83 ec 0c             	sub    $0xc,%esp
    9b49:	50                   	push   %eax
    9b4a:	e8 6e d5 ff ff       	call   70bd <malloc>
    9b4f:	83 c4 10             	add    $0x10,%esp
    9b52:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    9b55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9b5c:	e9 87 00 00 00       	jmp    9be8 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    9b61:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    9b64:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9b67:	89 d0                	mov    %edx,%eax
    9b69:	01 c0                	add    %eax,%eax
    9b6b:	01 d0                	add    %edx,%eax
    9b6d:	01 c8                	add    %ecx,%eax
    9b6f:	0f b6 00             	movzbl (%eax),%eax
    9b72:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    9b75:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    9b78:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9b7b:	89 d0                	mov    %edx,%eax
    9b7d:	01 c0                	add    %eax,%eax
    9b7f:	01 d0                	add    %edx,%eax
    9b81:	83 c0 01             	add    $0x1,%eax
    9b84:	01 c8                	add    %ecx,%eax
    9b86:	0f b6 00             	movzbl (%eax),%eax
    9b89:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    9b8c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    9b8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9b92:	89 d0                	mov    %edx,%eax
    9b94:	01 c0                	add    %eax,%eax
    9b96:	01 d0                	add    %edx,%eax
    9b98:	83 c0 02             	add    $0x2,%eax
    9b9b:	01 c8                	add    %ecx,%eax
    9b9d:	0f b6 00             	movzbl (%eax),%eax
    9ba0:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    9ba3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    9ba6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9ba9:	89 d0                	mov    %edx,%eax
    9bab:	01 c0                	add    %eax,%eax
    9bad:	01 d0                	add    %edx,%eax
    9baf:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    9bb2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    9bb6:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    9bb9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    9bbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9bbf:	89 d0                	mov    %edx,%eax
    9bc1:	01 c0                	add    %eax,%eax
    9bc3:	01 d0                	add    %edx,%eax
    9bc5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    9bc8:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    9bcc:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    9bcf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    9bd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9bd5:	89 d0                	mov    %edx,%eax
    9bd7:	01 c0                	add    %eax,%eax
    9bd9:	01 d0                	add    %edx,%eax
    9bdb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    9bde:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    9be2:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    9be4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9be8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9beb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9bee:	0f 8c 6d ff ff ff    	jl     9b61 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    9bf4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9bf7:	83 ec 0c             	sub    $0xc,%esp
    9bfa:	50                   	push   %eax
    9bfb:	e8 7b d3 ff ff       	call   6f7b <free>
    9c00:	83 c4 10             	add    $0x10,%esp
    return bmp;
    9c03:	8b 45 08             	mov    0x8(%ebp),%eax
    9c06:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    9c09:	89 10                	mov    %edx,(%eax)
    9c0b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    9c0e:	89 50 04             	mov    %edx,0x4(%eax)
    9c11:	8b 55 dc             	mov    -0x24(%ebp),%edx
    9c14:	89 50 08             	mov    %edx,0x8(%eax)

}
    9c17:	8b 45 08             	mov    0x8(%ebp),%eax
    9c1a:	c9                   	leave  
    9c1b:	c2 04 00             	ret    $0x4

00009c1e <LoadImg>:

PBitmap LoadImg(char* filename){
    9c1e:	55                   	push   %ebp
    9c1f:	89 e5                	mov    %esp,%ebp
    9c21:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    9c24:	83 ec 0c             	sub    $0xc,%esp
    9c27:	ff 75 0c             	pushl  0xc(%ebp)
    9c2a:	e8 7c f8 ff ff       	call   94ab <type>
    9c2f:	83 c4 10             	add    $0x10,%esp
    9c32:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    9c35:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9c38:	83 f8 01             	cmp    $0x1,%eax
    9c3b:	74 1d                	je     9c5a <LoadImg+0x3c>
    9c3d:	83 f8 02             	cmp    $0x2,%eax
    9c40:	74 2c                	je     9c6e <LoadImg+0x50>
    9c42:	85 c0                	test   %eax,%eax
    9c44:	75 3c                	jne    9c82 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    9c46:	8b 45 08             	mov    0x8(%ebp),%eax
    9c49:	83 ec 08             	sub    $0x8,%esp
    9c4c:	ff 75 0c             	pushl  0xc(%ebp)
    9c4f:	50                   	push   %eax
    9c50:	e8 c6 fb ff ff       	call   981b <LoadJpeg>
    9c55:	83 c4 0c             	add    $0xc,%esp
    9c58:	eb 3c                	jmp    9c96 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    9c5a:	8b 45 08             	mov    0x8(%ebp),%eax
    9c5d:	83 ec 08             	sub    $0x8,%esp
    9c60:	ff 75 0c             	pushl  0xc(%ebp)
    9c63:	50                   	push   %eax
    9c64:	e8 17 f9 ff ff       	call   9580 <LoadBmp>
    9c69:	83 c4 0c             	add    $0xc,%esp
    9c6c:	eb 28                	jmp    9c96 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    9c6e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c71:	83 ec 08             	sub    $0x8,%esp
    9c74:	ff 75 0c             	pushl  0xc(%ebp)
    9c77:	50                   	push   %eax
    9c78:	e8 7d fe ff ff       	call   9afa <LoadPng>
    9c7d:	83 c4 0c             	add    $0xc,%esp
    9c80:	eb 14                	jmp    9c96 <LoadImg+0x78>

        default: return bmp;
    9c82:	8b 45 08             	mov    0x8(%ebp),%eax
    9c85:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9c88:	89 10                	mov    %edx,(%eax)
    9c8a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9c8d:	89 50 04             	mov    %edx,0x4(%eax)
    9c90:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9c93:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    9c96:	8b 45 08             	mov    0x8(%ebp),%eax
    9c99:	c9                   	leave  
    9c9a:	c2 04 00             	ret    $0x4

00009c9d <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    9c9d:	55                   	push   %ebp
    9c9e:	89 e5                	mov    %esp,%ebp
    9ca0:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    9ca3:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca6:	83 ec 0c             	sub    $0xc,%esp
    9ca9:	50                   	push   %eax
    9caa:	e8 0e d4 ff ff       	call   70bd <malloc>
    9caf:	83 c4 10             	add    $0x10,%esp
}
    9cb2:	c9                   	leave  
    9cb3:	c3                   	ret    

00009cb4 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    9cb4:	55                   	push   %ebp
    9cb5:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    9cb7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    9cbc:	5d                   	pop    %ebp
    9cbd:	c3                   	ret    

00009cbe <lodepng_free>:

static void lodepng_free(void* ptr) {
    9cbe:	55                   	push   %ebp
    9cbf:	89 e5                	mov    %esp,%ebp
    9cc1:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    9cc4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9cc8:	74 0e                	je     9cd8 <lodepng_free+0x1a>
    free(ptr);
    9cca:	83 ec 0c             	sub    $0xc,%esp
    9ccd:	ff 75 08             	pushl  0x8(%ebp)
    9cd0:	e8 a6 d2 ff ff       	call   6f7b <free>
    9cd5:	83 c4 10             	add    $0x10,%esp
}
    9cd8:	90                   	nop
    9cd9:	c9                   	leave  
    9cda:	c3                   	ret    

00009cdb <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    9cdb:	55                   	push   %ebp
    9cdc:	89 e5                	mov    %esp,%ebp
    9cde:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    9ce1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9ce8:	eb 19                	jmp    9d03 <lodepng_memcpy+0x28>
    9cea:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9ced:	8b 45 08             	mov    0x8(%ebp),%eax
    9cf0:	01 c2                	add    %eax,%edx
    9cf2:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    9cf5:	8b 45 0c             	mov    0xc(%ebp),%eax
    9cf8:	01 c8                	add    %ecx,%eax
    9cfa:	0f b6 00             	movzbl (%eax),%eax
    9cfd:	88 02                	mov    %al,(%edx)
    9cff:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9d03:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d06:	3b 45 10             	cmp    0x10(%ebp),%eax
    9d09:	7c df                	jl     9cea <lodepng_memcpy+0xf>
}
    9d0b:	90                   	nop
    9d0c:	c9                   	leave  
    9d0d:	c3                   	ret    

00009d0e <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    9d0e:	55                   	push   %ebp
    9d0f:	89 e5                	mov    %esp,%ebp
    9d11:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    9d14:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9d1b:	eb 11                	jmp    9d2e <lodepng_memset+0x20>
    9d1d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9d20:	8b 45 08             	mov    0x8(%ebp),%eax
    9d23:	01 d0                	add    %edx,%eax
    9d25:	8b 55 0c             	mov    0xc(%ebp),%edx
    9d28:	88 10                	mov    %dl,(%eax)
    9d2a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9d2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d31:	3b 45 10             	cmp    0x10(%ebp),%eax
    9d34:	7c e7                	jl     9d1d <lodepng_memset+0xf>
}
    9d36:	90                   	nop
    9d37:	c9                   	leave  
    9d38:	c3                   	ret    

00009d39 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    9d39:	55                   	push   %ebp
    9d3a:	89 e5                	mov    %esp,%ebp
    9d3c:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    9d3f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d42:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    9d45:	eb 04                	jmp    9d4b <lodepng_strlen+0x12>
    9d47:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    9d4b:	8b 45 08             	mov    0x8(%ebp),%eax
    9d4e:	0f b6 00             	movzbl (%eax),%eax
    9d51:	84 c0                	test   %al,%al
    9d53:	75 f2                	jne    9d47 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    9d55:	8b 55 08             	mov    0x8(%ebp),%edx
    9d58:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d5b:	29 c2                	sub    %eax,%edx
    9d5d:	89 d0                	mov    %edx,%eax
}
    9d5f:	c9                   	leave  
    9d60:	c3                   	ret    

00009d61 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    9d61:	55                   	push   %ebp
    9d62:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    9d64:	8b 55 08             	mov    0x8(%ebp),%edx
    9d67:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d6a:	01 c2                	add    %eax,%edx
    9d6c:	8b 45 10             	mov    0x10(%ebp),%eax
    9d6f:	89 10                	mov    %edx,(%eax)
  return *result < a;
    9d71:	8b 45 10             	mov    0x10(%ebp),%eax
    9d74:	8b 00                	mov    (%eax),%eax
    9d76:	3b 45 08             	cmp    0x8(%ebp),%eax
    9d79:	0f 9c c0             	setl   %al
    9d7c:	0f b6 c0             	movzbl %al,%eax
}
    9d7f:	5d                   	pop    %ebp
    9d80:	c3                   	ret    

00009d81 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    9d81:	55                   	push   %ebp
    9d82:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    9d84:	8b 45 08             	mov    0x8(%ebp),%eax
    9d87:	0f af 45 0c          	imul   0xc(%ebp),%eax
    9d8b:	89 c2                	mov    %eax,%edx
    9d8d:	8b 45 10             	mov    0x10(%ebp),%eax
    9d90:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    9d92:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9d96:	74 15                	je     9dad <lodepng_mulofl+0x2c>
    9d98:	8b 45 10             	mov    0x10(%ebp),%eax
    9d9b:	8b 00                	mov    (%eax),%eax
    9d9d:	99                   	cltd   
    9d9e:	f7 7d 08             	idivl  0x8(%ebp)
    9da1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9da4:	74 07                	je     9dad <lodepng_mulofl+0x2c>
    9da6:	b8 01 00 00 00       	mov    $0x1,%eax
    9dab:	eb 05                	jmp    9db2 <lodepng_mulofl+0x31>
    9dad:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9db2:	5d                   	pop    %ebp
    9db3:	c3                   	ret    

00009db4 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    9db4:	55                   	push   %ebp
    9db5:	89 e5                	mov    %esp,%ebp
    9db7:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    9dba:	8d 45 fc             	lea    -0x4(%ebp),%eax
    9dbd:	50                   	push   %eax
    9dbe:	ff 75 0c             	pushl  0xc(%ebp)
    9dc1:	ff 75 08             	pushl  0x8(%ebp)
    9dc4:	e8 98 ff ff ff       	call   9d61 <lodepng_addofl>
    9dc9:	83 c4 0c             	add    $0xc,%esp
    9dcc:	85 c0                	test   %eax,%eax
    9dce:	74 07                	je     9dd7 <lodepng_gtofl+0x23>
    9dd0:	b8 01 00 00 00       	mov    $0x1,%eax
    9dd5:	eb 0c                	jmp    9de3 <lodepng_gtofl+0x2f>
  return d > c;
    9dd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9dda:	3b 45 10             	cmp    0x10(%ebp),%eax
    9ddd:	0f 9f c0             	setg   %al
    9de0:	0f b6 c0             	movzbl %al,%eax
}
    9de3:	c9                   	leave  
    9de4:	c3                   	ret    

00009de5 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    9de5:	55                   	push   %ebp
    9de6:	89 e5                	mov    %esp,%ebp
    9de8:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    9deb:	8b 45 08             	mov    0x8(%ebp),%eax
    9dee:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    9df5:	8b 45 08             	mov    0x8(%ebp),%eax
    9df8:	8b 50 08             	mov    0x8(%eax),%edx
    9dfb:	8b 45 08             	mov    0x8(%ebp),%eax
    9dfe:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    9e01:	8b 45 08             	mov    0x8(%ebp),%eax
    9e04:	8b 00                	mov    (%eax),%eax
    9e06:	83 ec 0c             	sub    $0xc,%esp
    9e09:	50                   	push   %eax
    9e0a:	e8 af fe ff ff       	call   9cbe <lodepng_free>
    9e0f:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    9e12:	8b 45 08             	mov    0x8(%ebp),%eax
    9e15:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    9e1b:	90                   	nop
    9e1c:	c9                   	leave  
    9e1d:	c3                   	ret    

00009e1e <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    9e1e:	55                   	push   %ebp
    9e1f:	89 e5                	mov    %esp,%ebp
    9e21:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    9e24:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e27:	c1 e0 02             	shl    $0x2,%eax
    9e2a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    9e2d:	8b 45 08             	mov    0x8(%ebp),%eax
    9e30:	8b 40 08             	mov    0x8(%eax),%eax
    9e33:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    9e36:	7d 46                	jge    9e7e <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    9e38:	8b 45 08             	mov    0x8(%ebp),%eax
    9e3b:	8b 40 08             	mov    0x8(%eax),%eax
    9e3e:	d1 f8                	sar    %eax
    9e40:	89 c2                	mov    %eax,%edx
    9e42:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9e45:	01 d0                	add    %edx,%eax
    9e47:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    9e4a:	8b 45 08             	mov    0x8(%ebp),%eax
    9e4d:	8b 00                	mov    (%eax),%eax
    9e4f:	ff 75 f8             	pushl  -0x8(%ebp)
    9e52:	50                   	push   %eax
    9e53:	e8 5c fe ff ff       	call   9cb4 <lodepng_realloc>
    9e58:	83 c4 08             	add    $0x8,%esp
    9e5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    9e5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9e62:	74 13                	je     9e77 <uivector_resize+0x59>
      p->allocsize = newsize;
    9e64:	8b 45 08             	mov    0x8(%ebp),%eax
    9e67:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9e6a:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    9e6d:	8b 45 08             	mov    0x8(%ebp),%eax
    9e70:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e73:	89 10                	mov    %edx,(%eax)
    9e75:	eb 07                	jmp    9e7e <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    9e77:	b8 00 00 00 00       	mov    $0x0,%eax
    9e7c:	eb 0e                	jmp    9e8c <uivector_resize+0x6e>
  }
  p->size = size;
    9e7e:	8b 45 08             	mov    0x8(%ebp),%eax
    9e81:	8b 55 0c             	mov    0xc(%ebp),%edx
    9e84:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    9e87:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9e8c:	c9                   	leave  
    9e8d:	c3                   	ret    

00009e8e <uivector_init>:

static void uivector_init(uivector* p) {
    9e8e:	55                   	push   %ebp
    9e8f:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    9e91:	8b 45 08             	mov    0x8(%ebp),%eax
    9e94:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    9e9a:	8b 45 08             	mov    0x8(%ebp),%eax
    9e9d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    9ea4:	8b 45 08             	mov    0x8(%ebp),%eax
    9ea7:	8b 50 08             	mov    0x8(%eax),%edx
    9eaa:	8b 45 08             	mov    0x8(%ebp),%eax
    9ead:	89 50 04             	mov    %edx,0x4(%eax)
}
    9eb0:	90                   	nop
    9eb1:	5d                   	pop    %ebp
    9eb2:	c3                   	ret    

00009eb3 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    9eb3:	55                   	push   %ebp
    9eb4:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    9eb6:	8b 45 08             	mov    0x8(%ebp),%eax
    9eb9:	8b 40 04             	mov    0x4(%eax),%eax
    9ebc:	83 c0 01             	add    $0x1,%eax
    9ebf:	50                   	push   %eax
    9ec0:	ff 75 08             	pushl  0x8(%ebp)
    9ec3:	e8 56 ff ff ff       	call   9e1e <uivector_resize>
    9ec8:	83 c4 08             	add    $0x8,%esp
    9ecb:	85 c0                	test   %eax,%eax
    9ecd:	75 07                	jne    9ed6 <uivector_push_back+0x23>
    9ecf:	b8 00 00 00 00       	mov    $0x0,%eax
    9ed4:	eb 1f                	jmp    9ef5 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    9ed6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed9:	8b 10                	mov    (%eax),%edx
    9edb:	8b 45 08             	mov    0x8(%ebp),%eax
    9ede:	8b 40 04             	mov    0x4(%eax),%eax
    9ee1:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9ee6:	c1 e0 02             	shl    $0x2,%eax
    9ee9:	01 c2                	add    %eax,%edx
    9eeb:	8b 45 0c             	mov    0xc(%ebp),%eax
    9eee:	89 02                	mov    %eax,(%edx)
  return 1;
    9ef0:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9ef5:	c9                   	leave  
    9ef6:	c3                   	ret    

00009ef7 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    9ef7:	55                   	push   %ebp
    9ef8:	89 e5                	mov    %esp,%ebp
    9efa:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    9efd:	8b 45 08             	mov    0x8(%ebp),%eax
    9f00:	8b 40 08             	mov    0x8(%eax),%eax
    9f03:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9f06:	7d 46                	jge    9f4e <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    9f08:	8b 45 08             	mov    0x8(%ebp),%eax
    9f0b:	8b 40 08             	mov    0x8(%eax),%eax
    9f0e:	d1 f8                	sar    %eax
    9f10:	89 c2                	mov    %eax,%edx
    9f12:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f15:	01 d0                	add    %edx,%eax
    9f17:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    9f1a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f1d:	8b 00                	mov    (%eax),%eax
    9f1f:	ff 75 fc             	pushl  -0x4(%ebp)
    9f22:	50                   	push   %eax
    9f23:	e8 8c fd ff ff       	call   9cb4 <lodepng_realloc>
    9f28:	83 c4 08             	add    $0x8,%esp
    9f2b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    9f2e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9f32:	74 13                	je     9f47 <ucvector_resize+0x50>
      p->allocsize = newsize;
    9f34:	8b 45 08             	mov    0x8(%ebp),%eax
    9f37:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9f3a:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    9f3d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f40:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9f43:	89 10                	mov    %edx,(%eax)
    9f45:	eb 07                	jmp    9f4e <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    9f47:	b8 00 00 00 00       	mov    $0x0,%eax
    9f4c:	eb 0e                	jmp    9f5c <ucvector_resize+0x65>
  }
  p->size = size;
    9f4e:	8b 45 08             	mov    0x8(%ebp),%eax
    9f51:	8b 55 0c             	mov    0xc(%ebp),%edx
    9f54:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    9f57:	b8 01 00 00 00       	mov    $0x1,%eax
}
    9f5c:	c9                   	leave  
    9f5d:	c3                   	ret    

00009f5e <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    9f5e:	55                   	push   %ebp
    9f5f:	89 e5                	mov    %esp,%ebp
    9f61:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    9f64:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f67:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    9f6a:	8b 45 10             	mov    0x10(%ebp),%eax
    9f6d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    9f70:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9f73:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    9f76:	8b 45 08             	mov    0x8(%ebp),%eax
    9f79:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9f7c:	89 10                	mov    %edx,(%eax)
    9f7e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    9f81:	89 50 04             	mov    %edx,0x4(%eax)
    9f84:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9f87:	89 50 08             	mov    %edx,0x8(%eax)
}
    9f8a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f8d:	c9                   	leave  
    9f8e:	c2 04 00             	ret    $0x4

00009f91 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    9f91:	55                   	push   %ebp
    9f92:	89 e5                	mov    %esp,%ebp
    9f94:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    9f97:	8b 45 08             	mov    0x8(%ebp),%eax
    9f9a:	8b 00                	mov    (%eax),%eax
    9f9c:	83 ec 0c             	sub    $0xc,%esp
    9f9f:	50                   	push   %eax
    9fa0:	e8 19 fd ff ff       	call   9cbe <lodepng_free>
    9fa5:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    9fa8:	8b 45 08             	mov    0x8(%ebp),%eax
    9fab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    9fb1:	90                   	nop
    9fb2:	c9                   	leave  
    9fb3:	c3                   	ret    

00009fb4 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    9fb4:	55                   	push   %ebp
    9fb5:	89 e5                	mov    %esp,%ebp
    9fb7:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    9fba:	8b 45 0c             	mov    0xc(%ebp),%eax
    9fbd:	83 c0 01             	add    $0x1,%eax
    9fc0:	83 ec 0c             	sub    $0xc,%esp
    9fc3:	50                   	push   %eax
    9fc4:	e8 d4 fc ff ff       	call   9c9d <lodepng_malloc>
    9fc9:	83 c4 10             	add    $0x10,%esp
    9fcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    9fcf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9fd3:	74 1f                	je     9ff4 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    9fd5:	83 ec 04             	sub    $0x4,%esp
    9fd8:	ff 75 0c             	pushl  0xc(%ebp)
    9fdb:	ff 75 08             	pushl  0x8(%ebp)
    9fde:	ff 75 f4             	pushl  -0xc(%ebp)
    9fe1:	e8 f5 fc ff ff       	call   9cdb <lodepng_memcpy>
    9fe6:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    9fe9:	8b 55 0c             	mov    0xc(%ebp),%edx
    9fec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9fef:	01 d0                	add    %edx,%eax
    9ff1:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    9ff4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    9ff7:	c9                   	leave  
    9ff8:	c3                   	ret    

00009ff9 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    9ff9:	55                   	push   %ebp
    9ffa:	89 e5                	mov    %esp,%ebp
    9ffc:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    9fff:	ff 75 08             	pushl  0x8(%ebp)
    a002:	e8 32 fd ff ff       	call   9d39 <lodepng_strlen>
    a007:	83 c4 04             	add    $0x4,%esp
    a00a:	83 ec 08             	sub    $0x8,%esp
    a00d:	50                   	push   %eax
    a00e:	ff 75 08             	pushl  0x8(%ebp)
    a011:	e8 9e ff ff ff       	call   9fb4 <alloc_string_sized>
    a016:	83 c4 10             	add    $0x10,%esp
}
    a019:	c9                   	leave  
    a01a:	c3                   	ret    

0000a01b <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    a01b:	55                   	push   %ebp
    a01c:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    a01e:	8b 45 08             	mov    0x8(%ebp),%eax
    a021:	0f b6 00             	movzbl (%eax),%eax
    a024:	0f b6 c0             	movzbl %al,%eax
    a027:	c1 e0 18             	shl    $0x18,%eax
    a02a:	89 c2                	mov    %eax,%edx
    a02c:	8b 45 08             	mov    0x8(%ebp),%eax
    a02f:	83 c0 01             	add    $0x1,%eax
    a032:	0f b6 00             	movzbl (%eax),%eax
    a035:	0f b6 c0             	movzbl %al,%eax
    a038:	c1 e0 10             	shl    $0x10,%eax
    a03b:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    a03d:	8b 45 08             	mov    0x8(%ebp),%eax
    a040:	83 c0 02             	add    $0x2,%eax
    a043:	0f b6 00             	movzbl (%eax),%eax
    a046:	0f b6 c0             	movzbl %al,%eax
    a049:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    a04c:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    a04e:	8b 45 08             	mov    0x8(%ebp),%eax
    a051:	83 c0 03             	add    $0x3,%eax
    a054:	0f b6 00             	movzbl (%eax),%eax
    a057:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    a05a:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    a05c:	5d                   	pop    %ebp
    a05d:	c3                   	ret    

0000a05e <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    a05e:	55                   	push   %ebp
    a05f:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    a061:	8b 45 0c             	mov    0xc(%ebp),%eax
    a064:	c1 e8 18             	shr    $0x18,%eax
    a067:	89 c2                	mov    %eax,%edx
    a069:	8b 45 08             	mov    0x8(%ebp),%eax
    a06c:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    a06e:	8b 45 08             	mov    0x8(%ebp),%eax
    a071:	83 c0 01             	add    $0x1,%eax
    a074:	8b 55 0c             	mov    0xc(%ebp),%edx
    a077:	c1 ea 10             	shr    $0x10,%edx
    a07a:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    a07c:	8b 45 08             	mov    0x8(%ebp),%eax
    a07f:	83 c0 02             	add    $0x2,%eax
    a082:	8b 55 0c             	mov    0xc(%ebp),%edx
    a085:	c1 ea 08             	shr    $0x8,%edx
    a088:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    a08a:	8b 45 08             	mov    0x8(%ebp),%eax
    a08d:	83 c0 03             	add    $0x3,%eax
    a090:	8b 55 0c             	mov    0xc(%ebp),%edx
    a093:	88 10                	mov    %dl,(%eax)
}
    a095:	90                   	nop
    a096:	5d                   	pop    %ebp
    a097:	c3                   	ret    

0000a098 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    a098:	55                   	push   %ebp
    a099:	89 e5                	mov    %esp,%ebp
    a09b:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    a09e:	83 ec 08             	sub    $0x8,%esp
    a0a1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    a0a4:	50                   	push   %eax
    a0a5:	ff 75 08             	pushl  0x8(%ebp)
    a0a8:	e8 b7 ca ff ff       	call   6b64 <stat>
    a0ad:	83 c4 10             	add    $0x10,%esp
  return s.size;
    a0b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    a0b3:	c9                   	leave  
    a0b4:	c3                   	ret    

0000a0b5 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    a0b5:	55                   	push   %ebp
    a0b6:	89 e5                	mov    %esp,%ebp
    a0b8:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    a0bb:	83 ec 08             	sub    $0x8,%esp
    a0be:	6a 00                	push   $0x0
    a0c0:	ff 75 10             	pushl  0x10(%ebp)
    a0c3:	e8 bb cb ff ff       	call   6c83 <open>
    a0c8:	83 c4 10             	add    $0x10,%esp
    a0cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    a0ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a0d2:	79 07                	jns    a0db <lodepng_buffer_file+0x26>
  {
      return -1;
    a0d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a0d9:	eb 19                	jmp    a0f4 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    a0db:	83 ec 04             	sub    $0x4,%esp
    a0de:	ff 75 0c             	pushl  0xc(%ebp)
    a0e1:	ff 75 08             	pushl  0x8(%ebp)
    a0e4:	ff 75 f4             	pushl  -0xc(%ebp)
    a0e7:	e8 6f cb ff ff       	call   6c5b <read>
    a0ec:	83 c4 10             	add    $0x10,%esp
  return 0;
    a0ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a0f4:	c9                   	leave  
    a0f5:	c3                   	ret    

0000a0f6 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    a0f6:	55                   	push   %ebp
    a0f7:	89 e5                	mov    %esp,%ebp
    a0f9:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    a0fc:	83 ec 0c             	sub    $0xc,%esp
    a0ff:	ff 75 10             	pushl  0x10(%ebp)
    a102:	e8 91 ff ff ff       	call   a098 <lodepng_filesize>
    a107:	83 c4 10             	add    $0x10,%esp
    a10a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    a10d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a111:	79 07                	jns    a11a <lodepng_load_file+0x24>
    a113:	b8 4e 00 00 00       	mov    $0x4e,%eax
    a118:	eb 4a                	jmp    a164 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    a11a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a11d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a120:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    a122:	83 ec 0c             	sub    $0xc,%esp
    a125:	ff 75 f4             	pushl  -0xc(%ebp)
    a128:	e8 70 fb ff ff       	call   9c9d <lodepng_malloc>
    a12d:	83 c4 10             	add    $0x10,%esp
    a130:	89 c2                	mov    %eax,%edx
    a132:	8b 45 08             	mov    0x8(%ebp),%eax
    a135:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    a137:	8b 45 08             	mov    0x8(%ebp),%eax
    a13a:	8b 00                	mov    (%eax),%eax
    a13c:	85 c0                	test   %eax,%eax
    a13e:	75 0d                	jne    a14d <lodepng_load_file+0x57>
    a140:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    a144:	7e 07                	jle    a14d <lodepng_load_file+0x57>
    a146:	b8 53 00 00 00       	mov    $0x53,%eax
    a14b:	eb 17                	jmp    a164 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    a14d:	8b 45 08             	mov    0x8(%ebp),%eax
    a150:	8b 00                	mov    (%eax),%eax
    a152:	83 ec 04             	sub    $0x4,%esp
    a155:	ff 75 10             	pushl  0x10(%ebp)
    a158:	ff 75 f4             	pushl  -0xc(%ebp)
    a15b:	50                   	push   %eax
    a15c:	e8 54 ff ff ff       	call   a0b5 <lodepng_buffer_file>
    a161:	83 c4 10             	add    $0x10,%esp
}
    a164:	c9                   	leave  
    a165:	c3                   	ret    

0000a166 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    a166:	55                   	push   %ebp
    a167:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    a169:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    a16e:	5d                   	pop    %ebp
    a16f:	c3                   	ret    

0000a170 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    a170:	55                   	push   %ebp
    a171:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    a173:	8b 45 08             	mov    0x8(%ebp),%eax
    a176:	8b 55 0c             	mov    0xc(%ebp),%edx
    a179:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    a17b:	8b 45 08             	mov    0x8(%ebp),%eax
    a17e:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    a182:	90                   	nop
    a183:	5d                   	pop    %ebp
    a184:	c3                   	ret    

0000a185 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    a185:	55                   	push   %ebp
    a186:	89 e5                	mov    %esp,%ebp
    a188:	56                   	push   %esi
    a189:	53                   	push   %ebx
    a18a:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    a18d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    a191:	0f 85 aa 00 00 00    	jne    a241 <writeBits+0xbc>
    WRITEBIT(writer, value);
    a197:	8b 45 08             	mov    0x8(%ebp),%eax
    a19a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a19e:	0f b6 c0             	movzbl %al,%eax
    a1a1:	83 e0 07             	and    $0x7,%eax
    a1a4:	85 c0                	test   %eax,%eax
    a1a6:	75 39                	jne    a1e1 <writeBits+0x5c>
    a1a8:	8b 45 08             	mov    0x8(%ebp),%eax
    a1ab:	8b 00                	mov    (%eax),%eax
    a1ad:	8b 40 04             	mov    0x4(%eax),%eax
    a1b0:	8d 50 01             	lea    0x1(%eax),%edx
    a1b3:	8b 45 08             	mov    0x8(%ebp),%eax
    a1b6:	8b 00                	mov    (%eax),%eax
    a1b8:	52                   	push   %edx
    a1b9:	50                   	push   %eax
    a1ba:	e8 38 fd ff ff       	call   9ef7 <ucvector_resize>
    a1bf:	83 c4 08             	add    $0x8,%esp
    a1c2:	85 c0                	test   %eax,%eax
    a1c4:	0f 84 44 01 00 00    	je     a30e <writeBits+0x189>
    a1ca:	8b 45 08             	mov    0x8(%ebp),%eax
    a1cd:	8b 00                	mov    (%eax),%eax
    a1cf:	8b 10                	mov    (%eax),%edx
    a1d1:	8b 45 08             	mov    0x8(%ebp),%eax
    a1d4:	8b 00                	mov    (%eax),%eax
    a1d6:	8b 40 04             	mov    0x4(%eax),%eax
    a1d9:	83 e8 01             	sub    $0x1,%eax
    a1dc:	01 d0                	add    %edx,%eax
    a1de:	c6 00 00             	movb   $0x0,(%eax)
    a1e1:	8b 45 08             	mov    0x8(%ebp),%eax
    a1e4:	8b 00                	mov    (%eax),%eax
    a1e6:	8b 10                	mov    (%eax),%edx
    a1e8:	8b 45 08             	mov    0x8(%ebp),%eax
    a1eb:	8b 00                	mov    (%eax),%eax
    a1ed:	8b 40 04             	mov    0x4(%eax),%eax
    a1f0:	83 e8 01             	sub    $0x1,%eax
    a1f3:	01 c2                	add    %eax,%edx
    a1f5:	8b 45 08             	mov    0x8(%ebp),%eax
    a1f8:	8b 00                	mov    (%eax),%eax
    a1fa:	8b 08                	mov    (%eax),%ecx
    a1fc:	8b 45 08             	mov    0x8(%ebp),%eax
    a1ff:	8b 00                	mov    (%eax),%eax
    a201:	8b 40 04             	mov    0x4(%eax),%eax
    a204:	83 e8 01             	sub    $0x1,%eax
    a207:	01 c8                	add    %ecx,%eax
    a209:	0f b6 00             	movzbl (%eax),%eax
    a20c:	88 45 e7             	mov    %al,-0x19(%ebp)
    a20f:	8b 45 08             	mov    0x8(%ebp),%eax
    a212:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a216:	0f b6 c0             	movzbl %al,%eax
    a219:	83 e0 07             	and    $0x7,%eax
    a21c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a21f:	89 de                	mov    %ebx,%esi
    a221:	89 c1                	mov    %eax,%ecx
    a223:	d3 e6                	shl    %cl,%esi
    a225:	89 f0                	mov    %esi,%eax
    a227:	0a 45 e7             	or     -0x19(%ebp),%al
    a22a:	88 02                	mov    %al,(%edx)
    a22c:	8b 45 08             	mov    0x8(%ebp),%eax
    a22f:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a233:	8d 50 01             	lea    0x1(%eax),%edx
    a236:	8b 45 08             	mov    0x8(%ebp),%eax
    a239:	88 50 04             	mov    %dl,0x4(%eax)
    a23c:	e9 d1 00 00 00       	jmp    a312 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    a241:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a248:	e9 b3 00 00 00       	jmp    a300 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    a24d:	8b 45 08             	mov    0x8(%ebp),%eax
    a250:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a254:	0f b6 c0             	movzbl %al,%eax
    a257:	83 e0 07             	and    $0x7,%eax
    a25a:	85 c0                	test   %eax,%eax
    a25c:	75 39                	jne    a297 <writeBits+0x112>
    a25e:	8b 45 08             	mov    0x8(%ebp),%eax
    a261:	8b 00                	mov    (%eax),%eax
    a263:	8b 40 04             	mov    0x4(%eax),%eax
    a266:	8d 50 01             	lea    0x1(%eax),%edx
    a269:	8b 45 08             	mov    0x8(%ebp),%eax
    a26c:	8b 00                	mov    (%eax),%eax
    a26e:	52                   	push   %edx
    a26f:	50                   	push   %eax
    a270:	e8 82 fc ff ff       	call   9ef7 <ucvector_resize>
    a275:	83 c4 08             	add    $0x8,%esp
    a278:	85 c0                	test   %eax,%eax
    a27a:	0f 84 91 00 00 00    	je     a311 <writeBits+0x18c>
    a280:	8b 45 08             	mov    0x8(%ebp),%eax
    a283:	8b 00                	mov    (%eax),%eax
    a285:	8b 10                	mov    (%eax),%edx
    a287:	8b 45 08             	mov    0x8(%ebp),%eax
    a28a:	8b 00                	mov    (%eax),%eax
    a28c:	8b 40 04             	mov    0x4(%eax),%eax
    a28f:	83 e8 01             	sub    $0x1,%eax
    a292:	01 d0                	add    %edx,%eax
    a294:	c6 00 00             	movb   $0x0,(%eax)
    a297:	8b 45 08             	mov    0x8(%ebp),%eax
    a29a:	8b 00                	mov    (%eax),%eax
    a29c:	8b 10                	mov    (%eax),%edx
    a29e:	8b 45 08             	mov    0x8(%ebp),%eax
    a2a1:	8b 00                	mov    (%eax),%eax
    a2a3:	8b 40 04             	mov    0x4(%eax),%eax
    a2a6:	83 e8 01             	sub    $0x1,%eax
    a2a9:	01 c2                	add    %eax,%edx
    a2ab:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ae:	8b 00                	mov    (%eax),%eax
    a2b0:	8b 08                	mov    (%eax),%ecx
    a2b2:	8b 45 08             	mov    0x8(%ebp),%eax
    a2b5:	8b 00                	mov    (%eax),%eax
    a2b7:	8b 40 04             	mov    0x4(%eax),%eax
    a2ba:	83 e8 01             	sub    $0x1,%eax
    a2bd:	01 c8                	add    %ecx,%eax
    a2bf:	0f b6 00             	movzbl (%eax),%eax
    a2c2:	89 c6                	mov    %eax,%esi
    a2c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a2c7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a2ca:	89 c1                	mov    %eax,%ecx
    a2cc:	d3 eb                	shr    %cl,%ebx
    a2ce:	89 d8                	mov    %ebx,%eax
    a2d0:	83 e0 01             	and    $0x1,%eax
    a2d3:	89 c3                	mov    %eax,%ebx
    a2d5:	8b 45 08             	mov    0x8(%ebp),%eax
    a2d8:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a2dc:	0f b6 c0             	movzbl %al,%eax
    a2df:	83 e0 07             	and    $0x7,%eax
    a2e2:	89 c1                	mov    %eax,%ecx
    a2e4:	d3 e3                	shl    %cl,%ebx
    a2e6:	89 d8                	mov    %ebx,%eax
    a2e8:	09 f0                	or     %esi,%eax
    a2ea:	88 02                	mov    %al,(%edx)
    a2ec:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ef:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a2f3:	8d 50 01             	lea    0x1(%eax),%edx
    a2f6:	8b 45 08             	mov    0x8(%ebp),%eax
    a2f9:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    a2fc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a300:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a303:	3b 45 10             	cmp    0x10(%ebp),%eax
    a306:	0f 85 41 ff ff ff    	jne    a24d <writeBits+0xc8>
    a30c:	eb 04                	jmp    a312 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    a30e:	90                   	nop
    a30f:	eb 01                	jmp    a312 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    a311:	90                   	nop
    }
  }
}
    a312:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a315:	5b                   	pop    %ebx
    a316:	5e                   	pop    %esi
    a317:	5d                   	pop    %ebp
    a318:	c3                   	ret    

0000a319 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    a319:	55                   	push   %ebp
    a31a:	89 e5                	mov    %esp,%ebp
    a31c:	56                   	push   %esi
    a31d:	53                   	push   %ebx
    a31e:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    a321:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a328:	e9 bd 00 00 00       	jmp    a3ea <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    a32d:	8b 45 08             	mov    0x8(%ebp),%eax
    a330:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a334:	0f b6 c0             	movzbl %al,%eax
    a337:	83 e0 07             	and    $0x7,%eax
    a33a:	85 c0                	test   %eax,%eax
    a33c:	75 39                	jne    a377 <writeBitsReversed+0x5e>
    a33e:	8b 45 08             	mov    0x8(%ebp),%eax
    a341:	8b 00                	mov    (%eax),%eax
    a343:	8b 40 04             	mov    0x4(%eax),%eax
    a346:	8d 50 01             	lea    0x1(%eax),%edx
    a349:	8b 45 08             	mov    0x8(%ebp),%eax
    a34c:	8b 00                	mov    (%eax),%eax
    a34e:	52                   	push   %edx
    a34f:	50                   	push   %eax
    a350:	e8 a2 fb ff ff       	call   9ef7 <ucvector_resize>
    a355:	83 c4 08             	add    $0x8,%esp
    a358:	85 c0                	test   %eax,%eax
    a35a:	0f 84 98 00 00 00    	je     a3f8 <writeBitsReversed+0xdf>
    a360:	8b 45 08             	mov    0x8(%ebp),%eax
    a363:	8b 00                	mov    (%eax),%eax
    a365:	8b 10                	mov    (%eax),%edx
    a367:	8b 45 08             	mov    0x8(%ebp),%eax
    a36a:	8b 00                	mov    (%eax),%eax
    a36c:	8b 40 04             	mov    0x4(%eax),%eax
    a36f:	83 e8 01             	sub    $0x1,%eax
    a372:	01 d0                	add    %edx,%eax
    a374:	c6 00 00             	movb   $0x0,(%eax)
    a377:	8b 45 08             	mov    0x8(%ebp),%eax
    a37a:	8b 00                	mov    (%eax),%eax
    a37c:	8b 10                	mov    (%eax),%edx
    a37e:	8b 45 08             	mov    0x8(%ebp),%eax
    a381:	8b 00                	mov    (%eax),%eax
    a383:	8b 40 04             	mov    0x4(%eax),%eax
    a386:	83 e8 01             	sub    $0x1,%eax
    a389:	01 c2                	add    %eax,%edx
    a38b:	8b 45 08             	mov    0x8(%ebp),%eax
    a38e:	8b 00                	mov    (%eax),%eax
    a390:	8b 08                	mov    (%eax),%ecx
    a392:	8b 45 08             	mov    0x8(%ebp),%eax
    a395:	8b 00                	mov    (%eax),%eax
    a397:	8b 40 04             	mov    0x4(%eax),%eax
    a39a:	83 e8 01             	sub    $0x1,%eax
    a39d:	01 c8                	add    %ecx,%eax
    a39f:	0f b6 00             	movzbl (%eax),%eax
    a3a2:	89 c6                	mov    %eax,%esi
    a3a4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a3a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a3aa:	29 c1                	sub    %eax,%ecx
    a3ac:	89 c8                	mov    %ecx,%eax
    a3ae:	83 e8 01             	sub    $0x1,%eax
    a3b1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a3b4:	89 c1                	mov    %eax,%ecx
    a3b6:	d3 eb                	shr    %cl,%ebx
    a3b8:	89 d8                	mov    %ebx,%eax
    a3ba:	83 e0 01             	and    $0x1,%eax
    a3bd:	89 c3                	mov    %eax,%ebx
    a3bf:	8b 45 08             	mov    0x8(%ebp),%eax
    a3c2:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a3c6:	0f b6 c0             	movzbl %al,%eax
    a3c9:	83 e0 07             	and    $0x7,%eax
    a3cc:	89 c1                	mov    %eax,%ecx
    a3ce:	d3 e3                	shl    %cl,%ebx
    a3d0:	89 d8                	mov    %ebx,%eax
    a3d2:	09 f0                	or     %esi,%eax
    a3d4:	88 02                	mov    %al,(%edx)
    a3d6:	8b 45 08             	mov    0x8(%ebp),%eax
    a3d9:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    a3dd:	8d 50 01             	lea    0x1(%eax),%edx
    a3e0:	8b 45 08             	mov    0x8(%ebp),%eax
    a3e3:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    a3e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a3ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a3ed:	3b 45 10             	cmp    0x10(%ebp),%eax
    a3f0:	0f 85 37 ff ff ff    	jne    a32d <writeBitsReversed+0x14>
    a3f6:	eb 01                	jmp    a3f9 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    a3f8:	90                   	nop
  }
}
    a3f9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    a3fc:	5b                   	pop    %ebx
    a3fd:	5e                   	pop    %esi
    a3fe:	5d                   	pop    %ebp
    a3ff:	c3                   	ret    

0000a400 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    a400:	55                   	push   %ebp
    a401:	89 e5                	mov    %esp,%ebp
    a403:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    a406:	8b 45 08             	mov    0x8(%ebp),%eax
    a409:	8b 55 0c             	mov    0xc(%ebp),%edx
    a40c:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    a40e:	8b 45 08             	mov    0x8(%ebp),%eax
    a411:	8b 55 10             	mov    0x10(%ebp),%edx
    a414:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    a417:	8b 45 08             	mov    0x8(%ebp),%eax
    a41a:	83 c0 08             	add    $0x8,%eax
    a41d:	50                   	push   %eax
    a41e:	6a 08                	push   $0x8
    a420:	ff 75 10             	pushl  0x10(%ebp)
    a423:	e8 59 f9 ff ff       	call   9d81 <lodepng_mulofl>
    a428:	83 c4 0c             	add    $0xc,%esp
    a42b:	85 c0                	test   %eax,%eax
    a42d:	74 07                	je     a436 <LodePNGBitReader_init+0x36>
    a42f:	b8 69 00 00 00       	mov    $0x69,%eax
    a434:	eb 39                	jmp    a46f <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    a436:	8b 45 08             	mov    0x8(%ebp),%eax
    a439:	8b 40 08             	mov    0x8(%eax),%eax
    a43c:	8d 55 fc             	lea    -0x4(%ebp),%edx
    a43f:	52                   	push   %edx
    a440:	6a 40                	push   $0x40
    a442:	50                   	push   %eax
    a443:	e8 19 f9 ff ff       	call   9d61 <lodepng_addofl>
    a448:	83 c4 0c             	add    $0xc,%esp
    a44b:	85 c0                	test   %eax,%eax
    a44d:	74 07                	je     a456 <LodePNGBitReader_init+0x56>
    a44f:	b8 69 00 00 00       	mov    $0x69,%eax
    a454:	eb 19                	jmp    a46f <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    a456:	8b 45 08             	mov    0x8(%ebp),%eax
    a459:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    a460:	8b 45 08             	mov    0x8(%ebp),%eax
    a463:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    a46a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a46f:	c9                   	leave  
    a470:	c3                   	ret    

0000a471 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    a471:	55                   	push   %ebp
    a472:	89 e5                	mov    %esp,%ebp
    a474:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    a477:	8b 45 08             	mov    0x8(%ebp),%eax
    a47a:	8b 40 0c             	mov    0xc(%eax),%eax
    a47d:	c1 f8 03             	sar    $0x3,%eax
    a480:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    a483:	8b 45 08             	mov    0x8(%ebp),%eax
    a486:	8b 40 04             	mov    0x4(%eax),%eax
    a489:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    a48c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a48f:	8d 50 01             	lea    0x1(%eax),%edx
    a492:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a495:	39 c2                	cmp    %eax,%edx
    a497:	73 4e                	jae    a4e7 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    a499:	8b 45 08             	mov    0x8(%ebp),%eax
    a49c:	8b 10                	mov    (%eax),%edx
    a49e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a4a1:	01 d0                	add    %edx,%eax
    a4a3:	0f b6 00             	movzbl (%eax),%eax
    a4a6:	0f b6 d0             	movzbl %al,%edx
    a4a9:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ac:	8b 00                	mov    (%eax),%eax
    a4ae:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    a4b1:	83 c1 01             	add    $0x1,%ecx
    a4b4:	01 c8                	add    %ecx,%eax
    a4b6:	0f b6 00             	movzbl (%eax),%eax
    a4b9:	0f b6 c0             	movzbl %al,%eax
    a4bc:	c1 e0 08             	shl    $0x8,%eax
    a4bf:	09 c2                	or     %eax,%edx
    a4c1:	8b 45 08             	mov    0x8(%ebp),%eax
    a4c4:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    a4c7:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ca:	8b 50 10             	mov    0x10(%eax),%edx
    a4cd:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d0:	8b 40 0c             	mov    0xc(%eax),%eax
    a4d3:	83 e0 07             	and    $0x7,%eax
    a4d6:	89 c1                	mov    %eax,%ecx
    a4d8:	d3 ea                	shr    %cl,%edx
    a4da:	8b 45 08             	mov    0x8(%ebp),%eax
    a4dd:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    a4e0:	b8 01 00 00 00       	mov    $0x1,%eax
    a4e5:	eb 64                	jmp    a54b <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    a4e7:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ea:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    a4f1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a4f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a4f7:	39 c2                	cmp    %eax,%edx
    a4f9:	73 1e                	jae    a519 <ensureBits9+0xa8>
    a4fb:	8b 45 08             	mov    0x8(%ebp),%eax
    a4fe:	8b 50 10             	mov    0x10(%eax),%edx
    a501:	8b 45 08             	mov    0x8(%ebp),%eax
    a504:	8b 08                	mov    (%eax),%ecx
    a506:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a509:	01 c8                	add    %ecx,%eax
    a50b:	0f b6 00             	movzbl (%eax),%eax
    a50e:	0f b6 c0             	movzbl %al,%eax
    a511:	09 c2                	or     %eax,%edx
    a513:	8b 45 08             	mov    0x8(%ebp),%eax
    a516:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    a519:	8b 45 08             	mov    0x8(%ebp),%eax
    a51c:	8b 50 10             	mov    0x10(%eax),%edx
    a51f:	8b 45 08             	mov    0x8(%ebp),%eax
    a522:	8b 40 0c             	mov    0xc(%eax),%eax
    a525:	83 e0 07             	and    $0x7,%eax
    a528:	89 c1                	mov    %eax,%ecx
    a52a:	d3 ea                	shr    %cl,%edx
    a52c:	8b 45 08             	mov    0x8(%ebp),%eax
    a52f:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    a532:	8b 45 08             	mov    0x8(%ebp),%eax
    a535:	8b 50 0c             	mov    0xc(%eax),%edx
    a538:	8b 45 0c             	mov    0xc(%ebp),%eax
    a53b:	01 c2                	add    %eax,%edx
    a53d:	8b 45 08             	mov    0x8(%ebp),%eax
    a540:	8b 40 08             	mov    0x8(%eax),%eax
    a543:	39 c2                	cmp    %eax,%edx
    a545:	0f 9e c0             	setle  %al
    a548:	0f b6 c0             	movzbl %al,%eax
  }
}
    a54b:	c9                   	leave  
    a54c:	c3                   	ret    

0000a54d <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    a54d:	55                   	push   %ebp
    a54e:	89 e5                	mov    %esp,%ebp
    a550:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    a553:	8b 45 08             	mov    0x8(%ebp),%eax
    a556:	8b 40 0c             	mov    0xc(%eax),%eax
    a559:	c1 f8 03             	sar    $0x3,%eax
    a55c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    a55f:	8b 45 08             	mov    0x8(%ebp),%eax
    a562:	8b 40 04             	mov    0x4(%eax),%eax
    a565:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    a568:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a56b:	8d 50 02             	lea    0x2(%eax),%edx
    a56e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a571:	39 c2                	cmp    %eax,%edx
    a573:	73 6d                	jae    a5e2 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    a575:	8b 45 08             	mov    0x8(%ebp),%eax
    a578:	8b 10                	mov    (%eax),%edx
    a57a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a57d:	01 d0                	add    %edx,%eax
    a57f:	0f b6 00             	movzbl (%eax),%eax
    a582:	0f b6 d0             	movzbl %al,%edx
    a585:	8b 45 08             	mov    0x8(%ebp),%eax
    a588:	8b 00                	mov    (%eax),%eax
    a58a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    a58d:	83 c1 01             	add    $0x1,%ecx
    a590:	01 c8                	add    %ecx,%eax
    a592:	0f b6 00             	movzbl (%eax),%eax
    a595:	0f b6 c0             	movzbl %al,%eax
    a598:	c1 e0 08             	shl    $0x8,%eax
    a59b:	89 d1                	mov    %edx,%ecx
    a59d:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    a59f:	8b 45 08             	mov    0x8(%ebp),%eax
    a5a2:	8b 00                	mov    (%eax),%eax
    a5a4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a5a7:	83 c2 02             	add    $0x2,%edx
    a5aa:	01 d0                	add    %edx,%eax
    a5ac:	0f b6 00             	movzbl (%eax),%eax
    a5af:	0f b6 c0             	movzbl %al,%eax
    a5b2:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    a5b5:	09 c1                	or     %eax,%ecx
    a5b7:	89 ca                	mov    %ecx,%edx
    a5b9:	8b 45 08             	mov    0x8(%ebp),%eax
    a5bc:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    a5bf:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c2:	8b 50 10             	mov    0x10(%eax),%edx
    a5c5:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c8:	8b 40 0c             	mov    0xc(%eax),%eax
    a5cb:	83 e0 07             	and    $0x7,%eax
    a5ce:	89 c1                	mov    %eax,%ecx
    a5d0:	d3 ea                	shr    %cl,%edx
    a5d2:	8b 45 08             	mov    0x8(%ebp),%eax
    a5d5:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    a5d8:	b8 01 00 00 00       	mov    $0x1,%eax
    a5dd:	e9 95 00 00 00       	jmp    a677 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    a5e2:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    a5ec:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a5ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a5f2:	39 c2                	cmp    %eax,%edx
    a5f4:	73 1e                	jae    a614 <ensureBits17+0xc7>
    a5f6:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f9:	8b 50 10             	mov    0x10(%eax),%edx
    a5fc:	8b 45 08             	mov    0x8(%ebp),%eax
    a5ff:	8b 08                	mov    (%eax),%ecx
    a601:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a604:	01 c8                	add    %ecx,%eax
    a606:	0f b6 00             	movzbl (%eax),%eax
    a609:	0f b6 c0             	movzbl %al,%eax
    a60c:	09 c2                	or     %eax,%edx
    a60e:	8b 45 08             	mov    0x8(%ebp),%eax
    a611:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    a614:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a617:	8d 50 01             	lea    0x1(%eax),%edx
    a61a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a61d:	39 c2                	cmp    %eax,%edx
    a61f:	73 24                	jae    a645 <ensureBits17+0xf8>
    a621:	8b 45 08             	mov    0x8(%ebp),%eax
    a624:	8b 50 10             	mov    0x10(%eax),%edx
    a627:	8b 45 08             	mov    0x8(%ebp),%eax
    a62a:	8b 00                	mov    (%eax),%eax
    a62c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    a62f:	83 c1 01             	add    $0x1,%ecx
    a632:	01 c8                	add    %ecx,%eax
    a634:	0f b6 00             	movzbl (%eax),%eax
    a637:	0f b6 c0             	movzbl %al,%eax
    a63a:	c1 e0 08             	shl    $0x8,%eax
    a63d:	09 c2                	or     %eax,%edx
    a63f:	8b 45 08             	mov    0x8(%ebp),%eax
    a642:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    a645:	8b 45 08             	mov    0x8(%ebp),%eax
    a648:	8b 50 10             	mov    0x10(%eax),%edx
    a64b:	8b 45 08             	mov    0x8(%ebp),%eax
    a64e:	8b 40 0c             	mov    0xc(%eax),%eax
    a651:	83 e0 07             	and    $0x7,%eax
    a654:	89 c1                	mov    %eax,%ecx
    a656:	d3 ea                	shr    %cl,%edx
    a658:	8b 45 08             	mov    0x8(%ebp),%eax
    a65b:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    a65e:	8b 45 08             	mov    0x8(%ebp),%eax
    a661:	8b 50 0c             	mov    0xc(%eax),%edx
    a664:	8b 45 0c             	mov    0xc(%ebp),%eax
    a667:	01 c2                	add    %eax,%edx
    a669:	8b 45 08             	mov    0x8(%ebp),%eax
    a66c:	8b 40 08             	mov    0x8(%eax),%eax
    a66f:	39 c2                	cmp    %eax,%edx
    a671:	0f 9e c0             	setle  %al
    a674:	0f b6 c0             	movzbl %al,%eax
  }
}
    a677:	c9                   	leave  
    a678:	c3                   	ret    

0000a679 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    a679:	55                   	push   %ebp
    a67a:	89 e5                	mov    %esp,%ebp
    a67c:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    a67f:	8b 45 08             	mov    0x8(%ebp),%eax
    a682:	8b 40 0c             	mov    0xc(%eax),%eax
    a685:	c1 f8 03             	sar    $0x3,%eax
    a688:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    a68b:	8b 45 08             	mov    0x8(%ebp),%eax
    a68e:	8b 40 04             	mov    0x4(%eax),%eax
    a691:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    a694:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a697:	8d 50 03             	lea    0x3(%eax),%edx
    a69a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a69d:	39 c2                	cmp    %eax,%edx
    a69f:	0f 83 85 00 00 00    	jae    a72a <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    a6a5:	8b 45 08             	mov    0x8(%ebp),%eax
    a6a8:	8b 10                	mov    (%eax),%edx
    a6aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a6ad:	01 d0                	add    %edx,%eax
    a6af:	0f b6 00             	movzbl (%eax),%eax
    a6b2:	0f b6 d0             	movzbl %al,%edx
    a6b5:	8b 45 08             	mov    0x8(%ebp),%eax
    a6b8:	8b 00                	mov    (%eax),%eax
    a6ba:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    a6bd:	83 c1 01             	add    $0x1,%ecx
    a6c0:	01 c8                	add    %ecx,%eax
    a6c2:	0f b6 00             	movzbl (%eax),%eax
    a6c5:	0f b6 c0             	movzbl %al,%eax
    a6c8:	c1 e0 08             	shl    $0x8,%eax
    a6cb:	89 d1                	mov    %edx,%ecx
    a6cd:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    a6cf:	8b 45 08             	mov    0x8(%ebp),%eax
    a6d2:	8b 00                	mov    (%eax),%eax
    a6d4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a6d7:	83 c2 02             	add    $0x2,%edx
    a6da:	01 d0                	add    %edx,%eax
    a6dc:	0f b6 00             	movzbl (%eax),%eax
    a6df:	0f b6 c0             	movzbl %al,%eax
    a6e2:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    a6e5:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    a6e7:	8b 45 08             	mov    0x8(%ebp),%eax
    a6ea:	8b 00                	mov    (%eax),%eax
    a6ec:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a6ef:	83 c2 03             	add    $0x3,%edx
    a6f2:	01 d0                	add    %edx,%eax
    a6f4:	0f b6 00             	movzbl (%eax),%eax
    a6f7:	0f b6 c0             	movzbl %al,%eax
    a6fa:	c1 e0 18             	shl    $0x18,%eax
    a6fd:	09 c1                	or     %eax,%ecx
    a6ff:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    a701:	8b 45 08             	mov    0x8(%ebp),%eax
    a704:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    a707:	8b 45 08             	mov    0x8(%ebp),%eax
    a70a:	8b 50 10             	mov    0x10(%eax),%edx
    a70d:	8b 45 08             	mov    0x8(%ebp),%eax
    a710:	8b 40 0c             	mov    0xc(%eax),%eax
    a713:	83 e0 07             	and    $0x7,%eax
    a716:	89 c1                	mov    %eax,%ecx
    a718:	d3 ea                	shr    %cl,%edx
    a71a:	8b 45 08             	mov    0x8(%ebp),%eax
    a71d:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    a720:	b8 01 00 00 00       	mov    $0x1,%eax
    a725:	e9 c6 00 00 00       	jmp    a7f0 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    a72a:	8b 45 08             	mov    0x8(%ebp),%eax
    a72d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    a734:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a737:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a73a:	39 c2                	cmp    %eax,%edx
    a73c:	73 1e                	jae    a75c <ensureBits25+0xe3>
    a73e:	8b 45 08             	mov    0x8(%ebp),%eax
    a741:	8b 50 10             	mov    0x10(%eax),%edx
    a744:	8b 45 08             	mov    0x8(%ebp),%eax
    a747:	8b 08                	mov    (%eax),%ecx
    a749:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a74c:	01 c8                	add    %ecx,%eax
    a74e:	0f b6 00             	movzbl (%eax),%eax
    a751:	0f b6 c0             	movzbl %al,%eax
    a754:	09 c2                	or     %eax,%edx
    a756:	8b 45 08             	mov    0x8(%ebp),%eax
    a759:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    a75c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a75f:	8d 50 01             	lea    0x1(%eax),%edx
    a762:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a765:	39 c2                	cmp    %eax,%edx
    a767:	73 24                	jae    a78d <ensureBits25+0x114>
    a769:	8b 45 08             	mov    0x8(%ebp),%eax
    a76c:	8b 50 10             	mov    0x10(%eax),%edx
    a76f:	8b 45 08             	mov    0x8(%ebp),%eax
    a772:	8b 00                	mov    (%eax),%eax
    a774:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    a777:	83 c1 01             	add    $0x1,%ecx
    a77a:	01 c8                	add    %ecx,%eax
    a77c:	0f b6 00             	movzbl (%eax),%eax
    a77f:	0f b6 c0             	movzbl %al,%eax
    a782:	c1 e0 08             	shl    $0x8,%eax
    a785:	09 c2                	or     %eax,%edx
    a787:	8b 45 08             	mov    0x8(%ebp),%eax
    a78a:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    a78d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a790:	8d 50 02             	lea    0x2(%eax),%edx
    a793:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a796:	39 c2                	cmp    %eax,%edx
    a798:	73 24                	jae    a7be <ensureBits25+0x145>
    a79a:	8b 45 08             	mov    0x8(%ebp),%eax
    a79d:	8b 50 10             	mov    0x10(%eax),%edx
    a7a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a7a3:	8b 00                	mov    (%eax),%eax
    a7a5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    a7a8:	83 c1 02             	add    $0x2,%ecx
    a7ab:	01 c8                	add    %ecx,%eax
    a7ad:	0f b6 00             	movzbl (%eax),%eax
    a7b0:	0f b6 c0             	movzbl %al,%eax
    a7b3:	c1 e0 10             	shl    $0x10,%eax
    a7b6:	09 c2                	or     %eax,%edx
    a7b8:	8b 45 08             	mov    0x8(%ebp),%eax
    a7bb:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    a7be:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c1:	8b 50 10             	mov    0x10(%eax),%edx
    a7c4:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c7:	8b 40 0c             	mov    0xc(%eax),%eax
    a7ca:	83 e0 07             	and    $0x7,%eax
    a7cd:	89 c1                	mov    %eax,%ecx
    a7cf:	d3 ea                	shr    %cl,%edx
    a7d1:	8b 45 08             	mov    0x8(%ebp),%eax
    a7d4:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    a7d7:	8b 45 08             	mov    0x8(%ebp),%eax
    a7da:	8b 50 0c             	mov    0xc(%eax),%edx
    a7dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7e0:	01 c2                	add    %eax,%edx
    a7e2:	8b 45 08             	mov    0x8(%ebp),%eax
    a7e5:	8b 40 08             	mov    0x8(%eax),%eax
    a7e8:	39 c2                	cmp    %eax,%edx
    a7ea:	0f 9e c0             	setle  %al
    a7ed:	0f b6 c0             	movzbl %al,%eax
  }
}
    a7f0:	c9                   	leave  
    a7f1:	c3                   	ret    

0000a7f2 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    a7f2:	55                   	push   %ebp
    a7f3:	89 e5                	mov    %esp,%ebp
    a7f5:	53                   	push   %ebx
    a7f6:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    a7f9:	8b 45 08             	mov    0x8(%ebp),%eax
    a7fc:	8b 40 0c             	mov    0xc(%eax),%eax
    a7ff:	c1 f8 03             	sar    $0x3,%eax
    a802:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    a805:	8b 45 08             	mov    0x8(%ebp),%eax
    a808:	8b 40 04             	mov    0x4(%eax),%eax
    a80b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    a80e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a811:	8d 50 04             	lea    0x4(%eax),%edx
    a814:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a817:	39 c2                	cmp    %eax,%edx
    a819:	0f 83 c3 00 00 00    	jae    a8e2 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    a81f:	8b 45 08             	mov    0x8(%ebp),%eax
    a822:	8b 10                	mov    (%eax),%edx
    a824:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a827:	01 d0                	add    %edx,%eax
    a829:	0f b6 00             	movzbl (%eax),%eax
    a82c:	0f b6 d0             	movzbl %al,%edx
    a82f:	8b 45 08             	mov    0x8(%ebp),%eax
    a832:	8b 00                	mov    (%eax),%eax
    a834:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    a837:	83 c1 01             	add    $0x1,%ecx
    a83a:	01 c8                	add    %ecx,%eax
    a83c:	0f b6 00             	movzbl (%eax),%eax
    a83f:	0f b6 c0             	movzbl %al,%eax
    a842:	c1 e0 08             	shl    $0x8,%eax
    a845:	89 d1                	mov    %edx,%ecx
    a847:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    a849:	8b 45 08             	mov    0x8(%ebp),%eax
    a84c:	8b 00                	mov    (%eax),%eax
    a84e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a851:	83 c2 02             	add    $0x2,%edx
    a854:	01 d0                	add    %edx,%eax
    a856:	0f b6 00             	movzbl (%eax),%eax
    a859:	0f b6 c0             	movzbl %al,%eax
    a85c:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    a85f:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    a861:	8b 45 08             	mov    0x8(%ebp),%eax
    a864:	8b 00                	mov    (%eax),%eax
    a866:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a869:	83 c2 03             	add    $0x3,%edx
    a86c:	01 d0                	add    %edx,%eax
    a86e:	0f b6 00             	movzbl (%eax),%eax
    a871:	0f b6 c0             	movzbl %al,%eax
    a874:	c1 e0 18             	shl    $0x18,%eax
    a877:	09 c1                	or     %eax,%ecx
    a879:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    a87b:	8b 45 08             	mov    0x8(%ebp),%eax
    a87e:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    a881:	8b 45 08             	mov    0x8(%ebp),%eax
    a884:	8b 50 10             	mov    0x10(%eax),%edx
    a887:	8b 45 08             	mov    0x8(%ebp),%eax
    a88a:	8b 40 0c             	mov    0xc(%eax),%eax
    a88d:	83 e0 07             	and    $0x7,%eax
    a890:	89 c1                	mov    %eax,%ecx
    a892:	d3 ea                	shr    %cl,%edx
    a894:	8b 45 08             	mov    0x8(%ebp),%eax
    a897:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    a89a:	8b 45 08             	mov    0x8(%ebp),%eax
    a89d:	8b 50 10             	mov    0x10(%eax),%edx
    a8a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a8a3:	8b 00                	mov    (%eax),%eax
    a8a5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    a8a8:	83 c1 04             	add    $0x4,%ecx
    a8ab:	01 c8                	add    %ecx,%eax
    a8ad:	0f b6 00             	movzbl (%eax),%eax
    a8b0:	0f b6 c0             	movzbl %al,%eax
    a8b3:	c1 e0 18             	shl    $0x18,%eax
    a8b6:	89 c3                	mov    %eax,%ebx
    a8b8:	8b 45 08             	mov    0x8(%ebp),%eax
    a8bb:	8b 40 0c             	mov    0xc(%eax),%eax
    a8be:	83 e0 07             	and    $0x7,%eax
    a8c1:	b9 08 00 00 00       	mov    $0x8,%ecx
    a8c6:	29 c1                	sub    %eax,%ecx
    a8c8:	89 c8                	mov    %ecx,%eax
    a8ca:	89 c1                	mov    %eax,%ecx
    a8cc:	d3 e3                	shl    %cl,%ebx
    a8ce:	89 d8                	mov    %ebx,%eax
    a8d0:	09 c2                	or     %eax,%edx
    a8d2:	8b 45 08             	mov    0x8(%ebp),%eax
    a8d5:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    a8d8:	b8 01 00 00 00       	mov    $0x1,%eax
    a8dd:	e9 f7 00 00 00       	jmp    a9d9 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    a8e2:	8b 45 08             	mov    0x8(%ebp),%eax
    a8e5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    a8ec:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a8ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a8f2:	39 c2                	cmp    %eax,%edx
    a8f4:	73 1e                	jae    a914 <ensureBits32+0x122>
    a8f6:	8b 45 08             	mov    0x8(%ebp),%eax
    a8f9:	8b 50 10             	mov    0x10(%eax),%edx
    a8fc:	8b 45 08             	mov    0x8(%ebp),%eax
    a8ff:	8b 08                	mov    (%eax),%ecx
    a901:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a904:	01 c8                	add    %ecx,%eax
    a906:	0f b6 00             	movzbl (%eax),%eax
    a909:	0f b6 c0             	movzbl %al,%eax
    a90c:	09 c2                	or     %eax,%edx
    a90e:	8b 45 08             	mov    0x8(%ebp),%eax
    a911:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    a914:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a917:	8d 50 01             	lea    0x1(%eax),%edx
    a91a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a91d:	39 c2                	cmp    %eax,%edx
    a91f:	73 24                	jae    a945 <ensureBits32+0x153>
    a921:	8b 45 08             	mov    0x8(%ebp),%eax
    a924:	8b 50 10             	mov    0x10(%eax),%edx
    a927:	8b 45 08             	mov    0x8(%ebp),%eax
    a92a:	8b 00                	mov    (%eax),%eax
    a92c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    a92f:	83 c1 01             	add    $0x1,%ecx
    a932:	01 c8                	add    %ecx,%eax
    a934:	0f b6 00             	movzbl (%eax),%eax
    a937:	0f b6 c0             	movzbl %al,%eax
    a93a:	c1 e0 08             	shl    $0x8,%eax
    a93d:	09 c2                	or     %eax,%edx
    a93f:	8b 45 08             	mov    0x8(%ebp),%eax
    a942:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    a945:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a948:	8d 50 02             	lea    0x2(%eax),%edx
    a94b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a94e:	39 c2                	cmp    %eax,%edx
    a950:	73 24                	jae    a976 <ensureBits32+0x184>
    a952:	8b 45 08             	mov    0x8(%ebp),%eax
    a955:	8b 50 10             	mov    0x10(%eax),%edx
    a958:	8b 45 08             	mov    0x8(%ebp),%eax
    a95b:	8b 00                	mov    (%eax),%eax
    a95d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    a960:	83 c1 02             	add    $0x2,%ecx
    a963:	01 c8                	add    %ecx,%eax
    a965:	0f b6 00             	movzbl (%eax),%eax
    a968:	0f b6 c0             	movzbl %al,%eax
    a96b:	c1 e0 10             	shl    $0x10,%eax
    a96e:	09 c2                	or     %eax,%edx
    a970:	8b 45 08             	mov    0x8(%ebp),%eax
    a973:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    a976:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a979:	8d 50 03             	lea    0x3(%eax),%edx
    a97c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a97f:	39 c2                	cmp    %eax,%edx
    a981:	73 24                	jae    a9a7 <ensureBits32+0x1b5>
    a983:	8b 45 08             	mov    0x8(%ebp),%eax
    a986:	8b 50 10             	mov    0x10(%eax),%edx
    a989:	8b 45 08             	mov    0x8(%ebp),%eax
    a98c:	8b 00                	mov    (%eax),%eax
    a98e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    a991:	83 c1 03             	add    $0x3,%ecx
    a994:	01 c8                	add    %ecx,%eax
    a996:	0f b6 00             	movzbl (%eax),%eax
    a999:	0f b6 c0             	movzbl %al,%eax
    a99c:	c1 e0 18             	shl    $0x18,%eax
    a99f:	09 c2                	or     %eax,%edx
    a9a1:	8b 45 08             	mov    0x8(%ebp),%eax
    a9a4:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    a9a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a9aa:	8b 50 10             	mov    0x10(%eax),%edx
    a9ad:	8b 45 08             	mov    0x8(%ebp),%eax
    a9b0:	8b 40 0c             	mov    0xc(%eax),%eax
    a9b3:	83 e0 07             	and    $0x7,%eax
    a9b6:	89 c1                	mov    %eax,%ecx
    a9b8:	d3 ea                	shr    %cl,%edx
    a9ba:	8b 45 08             	mov    0x8(%ebp),%eax
    a9bd:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    a9c0:	8b 45 08             	mov    0x8(%ebp),%eax
    a9c3:	8b 50 0c             	mov    0xc(%eax),%edx
    a9c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9c9:	01 c2                	add    %eax,%edx
    a9cb:	8b 45 08             	mov    0x8(%ebp),%eax
    a9ce:	8b 40 08             	mov    0x8(%eax),%eax
    a9d1:	39 c2                	cmp    %eax,%edx
    a9d3:	0f 9e c0             	setle  %al
    a9d6:	0f b6 c0             	movzbl %al,%eax
  }
}
    a9d9:	83 c4 10             	add    $0x10,%esp
    a9dc:	5b                   	pop    %ebx
    a9dd:	5d                   	pop    %ebp
    a9de:	c3                   	ret    

0000a9df <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    a9df:	55                   	push   %ebp
    a9e0:	89 e5                	mov    %esp,%ebp
    a9e2:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    a9e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a9e6:	8b 50 10             	mov    0x10(%eax),%edx
    a9e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9ec:	bb 01 00 00 00       	mov    $0x1,%ebx
    a9f1:	89 c1                	mov    %eax,%ecx
    a9f3:	d3 e3                	shl    %cl,%ebx
    a9f5:	89 d8                	mov    %ebx,%eax
    a9f7:	83 e8 01             	sub    $0x1,%eax
    a9fa:	21 d0                	and    %edx,%eax
}
    a9fc:	5b                   	pop    %ebx
    a9fd:	5d                   	pop    %ebp
    a9fe:	c3                   	ret    

0000a9ff <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    a9ff:	55                   	push   %ebp
    aa00:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    aa02:	8b 45 08             	mov    0x8(%ebp),%eax
    aa05:	8b 50 10             	mov    0x10(%eax),%edx
    aa08:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa0b:	89 c1                	mov    %eax,%ecx
    aa0d:	d3 ea                	shr    %cl,%edx
    aa0f:	8b 45 08             	mov    0x8(%ebp),%eax
    aa12:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    aa15:	8b 45 08             	mov    0x8(%ebp),%eax
    aa18:	8b 50 0c             	mov    0xc(%eax),%edx
    aa1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa1e:	01 c2                	add    %eax,%edx
    aa20:	8b 45 08             	mov    0x8(%ebp),%eax
    aa23:	89 50 0c             	mov    %edx,0xc(%eax)
}
    aa26:	90                   	nop
    aa27:	5d                   	pop    %ebp
    aa28:	c3                   	ret    

0000aa29 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    aa29:	55                   	push   %ebp
    aa2a:	89 e5                	mov    %esp,%ebp
    aa2c:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    aa2f:	ff 75 0c             	pushl  0xc(%ebp)
    aa32:	ff 75 08             	pushl  0x8(%ebp)
    aa35:	e8 a5 ff ff ff       	call   a9df <peekBits>
    aa3a:	83 c4 08             	add    $0x8,%esp
    aa3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    aa40:	ff 75 0c             	pushl  0xc(%ebp)
    aa43:	ff 75 08             	pushl  0x8(%ebp)
    aa46:	e8 b4 ff ff ff       	call   a9ff <advanceBits>
    aa4b:	83 c4 08             	add    $0x8,%esp
  return result;
    aa4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    aa51:	c9                   	leave  
    aa52:	c3                   	ret    

0000aa53 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    aa53:	55                   	push   %ebp
    aa54:	89 e5                	mov    %esp,%ebp
    aa56:	53                   	push   %ebx
    aa57:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    aa5a:	ff 75 0c             	pushl  0xc(%ebp)
    aa5d:	ff 75 08             	pushl  0x8(%ebp)
    aa60:	8d 45 d8             	lea    -0x28(%ebp),%eax
    aa63:	50                   	push   %eax
    aa64:	e8 97 f9 ff ff       	call   a400 <LodePNGBitReader_init>
    aa69:	83 c4 0c             	add    $0xc,%esp
    aa6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    aa6f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    aa73:	74 0a                	je     aa7f <lode_png_test_bitreader+0x2c>
    aa75:	b8 00 00 00 00       	mov    $0x0,%eax
    aa7a:	e9 c3 00 00 00       	jmp    ab42 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    aa7f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    aa86:	e9 a6 00 00 00       	jmp    ab31 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    aa8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    aa8e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    aa95:	8b 45 14             	mov    0x14(%ebp),%eax
    aa98:	01 d0                	add    %edx,%eax
    aa9a:	8b 00                	mov    (%eax),%eax
    aa9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    aa9f:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    aaa3:	7e 14                	jle    aab9 <lode_png_test_bitreader+0x66>
    aaa5:	ff 75 ec             	pushl  -0x14(%ebp)
    aaa8:	8d 45 d8             	lea    -0x28(%ebp),%eax
    aaab:	50                   	push   %eax
    aaac:	e8 41 fd ff ff       	call   a7f2 <ensureBits32>
    aab1:	83 c4 08             	add    $0x8,%esp
    aab4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    aab7:	eb 46                	jmp    aaff <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    aab9:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    aabd:	7e 14                	jle    aad3 <lode_png_test_bitreader+0x80>
    aabf:	ff 75 ec             	pushl  -0x14(%ebp)
    aac2:	8d 45 d8             	lea    -0x28(%ebp),%eax
    aac5:	50                   	push   %eax
    aac6:	e8 ae fb ff ff       	call   a679 <ensureBits25>
    aacb:	83 c4 08             	add    $0x8,%esp
    aace:	89 45 f4             	mov    %eax,-0xc(%ebp)
    aad1:	eb 2c                	jmp    aaff <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    aad3:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    aad7:	7e 14                	jle    aaed <lode_png_test_bitreader+0x9a>
    aad9:	ff 75 ec             	pushl  -0x14(%ebp)
    aadc:	8d 45 d8             	lea    -0x28(%ebp),%eax
    aadf:	50                   	push   %eax
    aae0:	e8 68 fa ff ff       	call   a54d <ensureBits17>
    aae5:	83 c4 08             	add    $0x8,%esp
    aae8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    aaeb:	eb 12                	jmp    aaff <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    aaed:	ff 75 ec             	pushl  -0x14(%ebp)
    aaf0:	8d 45 d8             	lea    -0x28(%ebp),%eax
    aaf3:	50                   	push   %eax
    aaf4:	e8 78 f9 ff ff       	call   a471 <ensureBits9>
    aaf9:	83 c4 08             	add    $0x8,%esp
    aafc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    aaff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ab03:	75 07                	jne    ab0c <lode_png_test_bitreader+0xb9>
    ab05:	b8 00 00 00 00       	mov    $0x0,%eax
    ab0a:	eb 36                	jmp    ab42 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    ab0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ab0f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ab16:	8b 45 18             	mov    0x18(%ebp),%eax
    ab19:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ab1c:	ff 75 ec             	pushl  -0x14(%ebp)
    ab1f:	8d 45 d8             	lea    -0x28(%ebp),%eax
    ab22:	50                   	push   %eax
    ab23:	e8 01 ff ff ff       	call   aa29 <readBits>
    ab28:	83 c4 08             	add    $0x8,%esp
    ab2b:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    ab2d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ab31:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ab34:	3b 45 10             	cmp    0x10(%ebp),%eax
    ab37:	0f 8c 4e ff ff ff    	jl     aa8b <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    ab3d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    ab42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    ab45:	c9                   	leave  
    ab46:	c3                   	ret    

0000ab47 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    ab47:	55                   	push   %ebp
    ab48:	89 e5                	mov    %esp,%ebp
    ab4a:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    ab4d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    ab54:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    ab5b:	eb 27                	jmp    ab84 <reverseBits+0x3d>
    ab5d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab60:	2b 45 fc             	sub    -0x4(%ebp),%eax
    ab63:	83 e8 01             	sub    $0x1,%eax
    ab66:	8b 55 08             	mov    0x8(%ebp),%edx
    ab69:	89 c1                	mov    %eax,%ecx
    ab6b:	d3 ea                	shr    %cl,%edx
    ab6d:	89 d0                	mov    %edx,%eax
    ab6f:	83 e0 01             	and    $0x1,%eax
    ab72:	89 c2                	mov    %eax,%edx
    ab74:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ab77:	89 c1                	mov    %eax,%ecx
    ab79:	d3 e2                	shl    %cl,%edx
    ab7b:	89 d0                	mov    %edx,%eax
    ab7d:	09 45 f8             	or     %eax,-0x8(%ebp)
    ab80:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    ab84:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ab87:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ab8a:	72 d1                	jb     ab5d <reverseBits+0x16>
  return result;
    ab8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    ab8f:	c9                   	leave  
    ab90:	c3                   	ret    

0000ab91 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    ab91:	55                   	push   %ebp
    ab92:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    ab94:	8b 45 08             	mov    0x8(%ebp),%eax
    ab97:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    ab9d:	8b 45 08             	mov    0x8(%ebp),%eax
    aba0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    aba7:	8b 45 08             	mov    0x8(%ebp),%eax
    abaa:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    abb1:	8b 45 08             	mov    0x8(%ebp),%eax
    abb4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    abbb:	90                   	nop
    abbc:	5d                   	pop    %ebp
    abbd:	c3                   	ret    

0000abbe <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    abbe:	55                   	push   %ebp
    abbf:	89 e5                	mov    %esp,%ebp
    abc1:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    abc4:	8b 45 08             	mov    0x8(%ebp),%eax
    abc7:	8b 00                	mov    (%eax),%eax
    abc9:	83 ec 0c             	sub    $0xc,%esp
    abcc:	50                   	push   %eax
    abcd:	e8 ec f0 ff ff       	call   9cbe <lodepng_free>
    abd2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    abd5:	8b 45 08             	mov    0x8(%ebp),%eax
    abd8:	8b 40 04             	mov    0x4(%eax),%eax
    abdb:	83 ec 0c             	sub    $0xc,%esp
    abde:	50                   	push   %eax
    abdf:	e8 da f0 ff ff       	call   9cbe <lodepng_free>
    abe4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    abe7:	8b 45 08             	mov    0x8(%ebp),%eax
    abea:	8b 40 10             	mov    0x10(%eax),%eax
    abed:	83 ec 0c             	sub    $0xc,%esp
    abf0:	50                   	push   %eax
    abf1:	e8 c8 f0 ff ff       	call   9cbe <lodepng_free>
    abf6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    abf9:	8b 45 08             	mov    0x8(%ebp),%eax
    abfc:	8b 40 14             	mov    0x14(%eax),%eax
    abff:	83 ec 0c             	sub    $0xc,%esp
    ac02:	50                   	push   %eax
    ac03:	e8 b6 f0 ff ff       	call   9cbe <lodepng_free>
    ac08:	83 c4 10             	add    $0x10,%esp
}
    ac0b:	90                   	nop
    ac0c:	c9                   	leave  
    ac0d:	c3                   	ret    

0000ac0e <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    ac0e:	55                   	push   %ebp
    ac0f:	89 e5                	mov    %esp,%ebp
    ac11:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    ac14:	a1 c8 20 02 00       	mov    0x220c8,%eax
    ac19:	c1 e0 02             	shl    $0x2,%eax
    ac1c:	83 ec 0c             	sub    $0xc,%esp
    ac1f:	50                   	push   %eax
    ac20:	e8 78 f0 ff ff       	call   9c9d <lodepng_malloc>
    ac25:	83 c4 10             	add    $0x10,%esp
    ac28:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    ac2b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ac2f:	75 0a                	jne    ac3b <HuffmanTree_makeTable+0x2d>
    ac31:	b8 53 00 00 00       	mov    $0x53,%eax
    ac36:	e9 61 04 00 00       	jmp    b09c <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    ac3b:	a1 c8 20 02 00       	mov    0x220c8,%eax
    ac40:	c1 e0 02             	shl    $0x2,%eax
    ac43:	83 ec 04             	sub    $0x4,%esp
    ac46:	50                   	push   %eax
    ac47:	6a 00                	push   $0x0
    ac49:	ff 75 dc             	pushl  -0x24(%ebp)
    ac4c:	e8 bd f0 ff ff       	call   9d0e <lodepng_memset>
    ac51:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    ac54:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ac5b:	eb 7d                	jmp    acda <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    ac5d:	8b 45 08             	mov    0x8(%ebp),%eax
    ac60:	8b 00                	mov    (%eax),%eax
    ac62:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ac65:	c1 e2 02             	shl    $0x2,%edx
    ac68:	01 d0                	add    %edx,%eax
    ac6a:	8b 00                	mov    (%eax),%eax
    ac6c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    ac6f:	8b 45 08             	mov    0x8(%ebp),%eax
    ac72:	8b 40 04             	mov    0x4(%eax),%eax
    ac75:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ac78:	c1 e2 02             	shl    $0x2,%edx
    ac7b:	01 d0                	add    %edx,%eax
    ac7d:	8b 00                	mov    (%eax),%eax
    ac7f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    ac82:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    ac86:	76 4d                	jbe    acd5 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    ac88:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ac8b:	83 e8 09             	sub    $0x9,%eax
    ac8e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ac91:	89 c1                	mov    %eax,%ecx
    ac93:	d3 ea                	shr    %cl,%edx
    ac95:	89 d0                	mov    %edx,%eax
    ac97:	83 ec 08             	sub    $0x8,%esp
    ac9a:	6a 09                	push   $0x9
    ac9c:	50                   	push   %eax
    ac9d:	e8 a5 fe ff ff       	call   ab47 <reverseBits>
    aca2:	83 c4 10             	add    $0x10,%esp
    aca5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    aca8:	8b 45 d0             	mov    -0x30(%ebp),%eax
    acab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    acb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    acb5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    acb8:	8b 45 d0             	mov    -0x30(%ebp),%eax
    acbb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    acc2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    acc5:	01 d0                	add    %edx,%eax
    acc7:	8b 10                	mov    (%eax),%edx
    acc9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    accc:	39 c2                	cmp    %eax,%edx
    acce:	0f 43 c2             	cmovae %edx,%eax
    acd1:	89 01                	mov    %eax,(%ecx)
    acd3:	eb 01                	jmp    acd6 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    acd5:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    acd6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    acda:	8b 45 08             	mov    0x8(%ebp),%eax
    acdd:	8b 50 0c             	mov    0xc(%eax),%edx
    ace0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ace3:	39 c2                	cmp    %eax,%edx
    ace5:	0f 87 72 ff ff ff    	ja     ac5d <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    aceb:	a1 c8 20 02 00       	mov    0x220c8,%eax
    acf0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    acf3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    acfa:	eb 35                	jmp    ad31 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    acfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    acff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ad06:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ad09:	01 d0                	add    %edx,%eax
    ad0b:	8b 00                	mov    (%eax),%eax
    ad0d:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    ad10:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    ad14:	76 17                	jbe    ad2d <HuffmanTree_makeTable+0x11f>
    ad16:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ad19:	83 e8 09             	sub    $0x9,%eax
    ad1c:	ba 01 00 00 00       	mov    $0x1,%edx
    ad21:	89 c1                	mov    %eax,%ecx
    ad23:	d3 e2                	shl    %cl,%edx
    ad25:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ad28:	01 d0                	add    %edx,%eax
    ad2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    ad2d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ad31:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ad34:	a1 c8 20 02 00       	mov    0x220c8,%eax
    ad39:	39 c2                	cmp    %eax,%edx
    ad3b:	72 bf                	jb     acfc <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    ad3d:	83 ec 0c             	sub    $0xc,%esp
    ad40:	ff 75 e8             	pushl  -0x18(%ebp)
    ad43:	e8 55 ef ff ff       	call   9c9d <lodepng_malloc>
    ad48:	83 c4 10             	add    $0x10,%esp
    ad4b:	89 c2                	mov    %eax,%edx
    ad4d:	8b 45 08             	mov    0x8(%ebp),%eax
    ad50:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    ad53:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ad56:	01 c0                	add    %eax,%eax
    ad58:	83 ec 0c             	sub    $0xc,%esp
    ad5b:	50                   	push   %eax
    ad5c:	e8 3c ef ff ff       	call   9c9d <lodepng_malloc>
    ad61:	83 c4 10             	add    $0x10,%esp
    ad64:	89 c2                	mov    %eax,%edx
    ad66:	8b 45 08             	mov    0x8(%ebp),%eax
    ad69:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    ad6c:	8b 45 08             	mov    0x8(%ebp),%eax
    ad6f:	8b 40 10             	mov    0x10(%eax),%eax
    ad72:	85 c0                	test   %eax,%eax
    ad74:	74 0a                	je     ad80 <HuffmanTree_makeTable+0x172>
    ad76:	8b 45 08             	mov    0x8(%ebp),%eax
    ad79:	8b 40 14             	mov    0x14(%eax),%eax
    ad7c:	85 c0                	test   %eax,%eax
    ad7e:	75 18                	jne    ad98 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    ad80:	83 ec 0c             	sub    $0xc,%esp
    ad83:	ff 75 dc             	pushl  -0x24(%ebp)
    ad86:	e8 33 ef ff ff       	call   9cbe <lodepng_free>
    ad8b:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    ad8e:	b8 53 00 00 00       	mov    $0x53,%eax
    ad93:	e9 04 03 00 00       	jmp    b09c <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    ad98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ad9f:	eb 12                	jmp    adb3 <HuffmanTree_makeTable+0x1a5>
    ada1:	8b 45 08             	mov    0x8(%ebp),%eax
    ada4:	8b 50 10             	mov    0x10(%eax),%edx
    ada7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    adaa:	01 d0                	add    %edx,%eax
    adac:	c6 00 10             	movb   $0x10,(%eax)
    adaf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    adb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    adb6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    adb9:	7c e6                	jl     ada1 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    adbb:	a1 c8 20 02 00       	mov    0x220c8,%eax
    adc0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    adc3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    adca:	eb 5b                	jmp    ae27 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    adcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    adcf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    add6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    add9:	01 d0                	add    %edx,%eax
    addb:	8b 00                	mov    (%eax),%eax
    addd:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    ade0:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    ade4:	76 3c                	jbe    ae22 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    ade6:	8b 45 08             	mov    0x8(%ebp),%eax
    ade9:	8b 50 10             	mov    0x10(%eax),%edx
    adec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    adef:	01 d0                	add    %edx,%eax
    adf1:	8b 55 c8             	mov    -0x38(%ebp),%edx
    adf4:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    adf6:	8b 45 08             	mov    0x8(%ebp),%eax
    adf9:	8b 40 14             	mov    0x14(%eax),%eax
    adfc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    adff:	01 d2                	add    %edx,%edx
    ae01:	01 d0                	add    %edx,%eax
    ae03:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ae06:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    ae09:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ae0c:	83 e8 09             	sub    $0x9,%eax
    ae0f:	ba 01 00 00 00       	mov    $0x1,%edx
    ae14:	89 c1                	mov    %eax,%ecx
    ae16:	d3 e2                	shl    %cl,%edx
    ae18:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ae1b:	01 d0                	add    %edx,%eax
    ae1d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ae20:	eb 01                	jmp    ae23 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    ae22:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    ae23:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ae27:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ae2a:	a1 c8 20 02 00       	mov    0x220c8,%eax
    ae2f:	39 c2                	cmp    %eax,%edx
    ae31:	72 99                	jb     adcc <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    ae33:	83 ec 0c             	sub    $0xc,%esp
    ae36:	ff 75 dc             	pushl  -0x24(%ebp)
    ae39:	e8 80 ee ff ff       	call   9cbe <lodepng_free>
    ae3e:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    ae41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    ae48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ae4f:	e9 9d 01 00 00       	jmp    aff1 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    ae54:	8b 45 08             	mov    0x8(%ebp),%eax
    ae57:	8b 40 04             	mov    0x4(%eax),%eax
    ae5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ae5d:	c1 e2 02             	shl    $0x2,%edx
    ae60:	01 d0                	add    %edx,%eax
    ae62:	8b 00                	mov    (%eax),%eax
    ae64:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    ae67:	8b 45 08             	mov    0x8(%ebp),%eax
    ae6a:	8b 00                	mov    (%eax),%eax
    ae6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ae6f:	c1 e2 02             	shl    $0x2,%edx
    ae72:	01 d0                	add    %edx,%eax
    ae74:	8b 00                	mov    (%eax),%eax
    ae76:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    ae79:	83 ec 08             	sub    $0x8,%esp
    ae7c:	ff 75 c4             	pushl  -0x3c(%ebp)
    ae7f:	ff 75 c0             	pushl  -0x40(%ebp)
    ae82:	e8 c0 fc ff ff       	call   ab47 <reverseBits>
    ae87:	83 c4 10             	add    $0x10,%esp
    ae8a:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    ae8d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    ae91:	0f 84 55 01 00 00    	je     afec <HuffmanTree_makeTable+0x3de>
    numpresent++;
    ae97:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    ae9b:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    ae9f:	0f 87 81 00 00 00    	ja     af26 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    aea5:	b8 09 00 00 00       	mov    $0x9,%eax
    aeaa:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    aead:	ba 01 00 00 00       	mov    $0x1,%edx
    aeb2:	89 c1                	mov    %eax,%ecx
    aeb4:	d3 e2                	shl    %cl,%edx
    aeb6:	89 d0                	mov    %edx,%eax
    aeb8:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    aebb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    aec2:	eb 55                	jmp    af19 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    aec4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    aec7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    aeca:	89 c1                	mov    %eax,%ecx
    aecc:	d3 e2                	shl    %cl,%edx
    aece:	89 d0                	mov    %edx,%eax
    aed0:	0b 45 bc             	or     -0x44(%ebp),%eax
    aed3:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    aed6:	8b 45 08             	mov    0x8(%ebp),%eax
    aed9:	8b 50 10             	mov    0x10(%eax),%edx
    aedc:	8b 45 98             	mov    -0x68(%ebp),%eax
    aedf:	01 d0                	add    %edx,%eax
    aee1:	0f b6 00             	movzbl (%eax),%eax
    aee4:	3c 10                	cmp    $0x10,%al
    aee6:	74 0a                	je     aef2 <HuffmanTree_makeTable+0x2e4>
    aee8:	b8 37 00 00 00       	mov    $0x37,%eax
    aeed:	e9 aa 01 00 00       	jmp    b09c <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    aef2:	8b 45 08             	mov    0x8(%ebp),%eax
    aef5:	8b 50 10             	mov    0x10(%eax),%edx
    aef8:	8b 45 98             	mov    -0x68(%ebp),%eax
    aefb:	01 d0                	add    %edx,%eax
    aefd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    af00:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    af02:	8b 45 08             	mov    0x8(%ebp),%eax
    af05:	8b 40 14             	mov    0x14(%eax),%eax
    af08:	8b 55 98             	mov    -0x68(%ebp),%edx
    af0b:	01 d2                	add    %edx,%edx
    af0d:	01 d0                	add    %edx,%eax
    af0f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    af12:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    af15:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    af19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    af1c:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    af1f:	72 a3                	jb     aec4 <HuffmanTree_makeTable+0x2b6>
    af21:	e9 c7 00 00 00       	jmp    afed <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    af26:	a1 cc 20 02 00       	mov    0x220cc,%eax
    af2b:	23 45 bc             	and    -0x44(%ebp),%eax
    af2e:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    af31:	8b 45 08             	mov    0x8(%ebp),%eax
    af34:	8b 50 10             	mov    0x10(%eax),%edx
    af37:	8b 45 b8             	mov    -0x48(%ebp),%eax
    af3a:	01 d0                	add    %edx,%eax
    af3c:	0f b6 00             	movzbl (%eax),%eax
    af3f:	0f b6 c0             	movzbl %al,%eax
    af42:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    af45:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    af48:	83 e8 09             	sub    $0x9,%eax
    af4b:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    af4e:	8b 45 08             	mov    0x8(%ebp),%eax
    af51:	8b 40 14             	mov    0x14(%eax),%eax
    af54:	8b 55 b8             	mov    -0x48(%ebp),%edx
    af57:	01 d2                	add    %edx,%edx
    af59:	01 d0                	add    %edx,%eax
    af5b:	0f b7 00             	movzwl (%eax),%eax
    af5e:	0f b7 c0             	movzwl %ax,%eax
    af61:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    af64:	8b 45 b0             	mov    -0x50(%ebp),%eax
    af67:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    af6a:	83 c0 09             	add    $0x9,%eax
    af6d:	ba 01 00 00 00       	mov    $0x1,%edx
    af72:	89 c1                	mov    %eax,%ecx
    af74:	d3 e2                	shl    %cl,%edx
    af76:	89 d0                	mov    %edx,%eax
    af78:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    af7b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    af7e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    af81:	73 0a                	jae    af8d <HuffmanTree_makeTable+0x37f>
    af83:	b8 37 00 00 00       	mov    $0x37,%eax
    af88:	e9 0f 01 00 00       	jmp    b09c <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    af8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    af94:	eb 4c                	jmp    afe2 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    af96:	8b 45 bc             	mov    -0x44(%ebp),%eax
    af99:	c1 e8 09             	shr    $0x9,%eax
    af9c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    af9f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    afa2:	83 e8 09             	sub    $0x9,%eax
    afa5:	8b 55 e0             	mov    -0x20(%ebp),%edx
    afa8:	89 c1                	mov    %eax,%ecx
    afaa:	d3 e2                	shl    %cl,%edx
    afac:	89 d0                	mov    %edx,%eax
    afae:	0b 45 a4             	or     -0x5c(%ebp),%eax
    afb1:	89 c2                	mov    %eax,%edx
    afb3:	8b 45 ac             	mov    -0x54(%ebp),%eax
    afb6:	01 d0                	add    %edx,%eax
    afb8:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    afbb:	8b 45 08             	mov    0x8(%ebp),%eax
    afbe:	8b 50 10             	mov    0x10(%eax),%edx
    afc1:	8b 45 a0             	mov    -0x60(%ebp),%eax
    afc4:	01 d0                	add    %edx,%eax
    afc6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    afc9:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    afcb:	8b 45 08             	mov    0x8(%ebp),%eax
    afce:	8b 40 14             	mov    0x14(%eax),%eax
    afd1:	8b 55 a0             	mov    -0x60(%ebp),%edx
    afd4:	01 d2                	add    %edx,%edx
    afd6:	01 d0                	add    %edx,%eax
    afd8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    afdb:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    afde:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    afe2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    afe5:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    afe8:	72 ac                	jb     af96 <HuffmanTree_makeTable+0x388>
    afea:	eb 01                	jmp    afed <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    afec:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    afed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    aff1:	8b 45 08             	mov    0x8(%ebp),%eax
    aff4:	8b 50 0c             	mov    0xc(%eax),%edx
    aff7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    affa:	39 c2                	cmp    %eax,%edx
    affc:	0f 87 52 fe ff ff    	ja     ae54 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    b002:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    b006:	7f 61                	jg     b069 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    b008:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    b00f:	eb 4e                	jmp    b05f <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    b011:	8b 45 08             	mov    0x8(%ebp),%eax
    b014:	8b 50 10             	mov    0x10(%eax),%edx
    b017:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b01a:	01 d0                	add    %edx,%eax
    b01c:	0f b6 00             	movzbl (%eax),%eax
    b01f:	3c 10                	cmp    $0x10,%al
    b021:	75 38                	jne    b05b <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    b023:	8b 45 08             	mov    0x8(%ebp),%eax
    b026:	8b 50 10             	mov    0x10(%eax),%edx
    b029:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b02c:	01 d0                	add    %edx,%eax
    b02e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    b031:	8b 15 c8 20 02 00    	mov    0x220c8,%edx
    b037:	39 d1                	cmp    %edx,%ecx
    b039:	73 07                	jae    b042 <HuffmanTree_makeTable+0x434>
    b03b:	ba 01 00 00 00       	mov    $0x1,%edx
    b040:	eb 05                	jmp    b047 <HuffmanTree_makeTable+0x439>
    b042:	ba 0a 00 00 00       	mov    $0xa,%edx
    b047:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    b049:	8b 45 08             	mov    0x8(%ebp),%eax
    b04c:	8b 40 14             	mov    0x14(%eax),%eax
    b04f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b052:	01 d2                	add    %edx,%edx
    b054:	01 d0                	add    %edx,%eax
    b056:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    b05b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    b05f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b062:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    b065:	7c aa                	jl     b011 <HuffmanTree_makeTable+0x403>
    b067:	eb 2e                	jmp    b097 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    b069:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    b070:	eb 1d                	jmp    b08f <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    b072:	8b 45 08             	mov    0x8(%ebp),%eax
    b075:	8b 50 10             	mov    0x10(%eax),%edx
    b078:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b07b:	01 d0                	add    %edx,%eax
    b07d:	0f b6 00             	movzbl (%eax),%eax
    b080:	3c 10                	cmp    $0x10,%al
    b082:	75 07                	jne    b08b <HuffmanTree_makeTable+0x47d>
    b084:	b8 37 00 00 00       	mov    $0x37,%eax
    b089:	eb 11                	jmp    b09c <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    b08b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    b08f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b092:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    b095:	7c db                	jl     b072 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    b097:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b09c:	c9                   	leave  
    b09d:	c3                   	ret    

0000b09e <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    b09e:	55                   	push   %ebp
    b09f:	89 e5                	mov    %esp,%ebp
    b0a1:	56                   	push   %esi
    b0a2:	53                   	push   %ebx
    b0a3:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    b0a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    b0ad:	8b 45 08             	mov    0x8(%ebp),%eax
    b0b0:	8b 40 0c             	mov    0xc(%eax),%eax
    b0b3:	c1 e0 02             	shl    $0x2,%eax
    b0b6:	83 ec 0c             	sub    $0xc,%esp
    b0b9:	50                   	push   %eax
    b0ba:	e8 de eb ff ff       	call   9c9d <lodepng_malloc>
    b0bf:	83 c4 10             	add    $0x10,%esp
    b0c2:	89 c2                	mov    %eax,%edx
    b0c4:	8b 45 08             	mov    0x8(%ebp),%eax
    b0c7:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    b0c9:	8b 45 08             	mov    0x8(%ebp),%eax
    b0cc:	8b 40 08             	mov    0x8(%eax),%eax
    b0cf:	83 c0 01             	add    $0x1,%eax
    b0d2:	c1 e0 02             	shl    $0x2,%eax
    b0d5:	83 ec 0c             	sub    $0xc,%esp
    b0d8:	50                   	push   %eax
    b0d9:	e8 bf eb ff ff       	call   9c9d <lodepng_malloc>
    b0de:	83 c4 10             	add    $0x10,%esp
    b0e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    b0e4:	8b 45 08             	mov    0x8(%ebp),%eax
    b0e7:	8b 40 08             	mov    0x8(%eax),%eax
    b0ea:	83 c0 01             	add    $0x1,%eax
    b0ed:	c1 e0 02             	shl    $0x2,%eax
    b0f0:	83 ec 0c             	sub    $0xc,%esp
    b0f3:	50                   	push   %eax
    b0f4:	e8 a4 eb ff ff       	call   9c9d <lodepng_malloc>
    b0f9:	83 c4 10             	add    $0x10,%esp
    b0fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    b0ff:	8b 45 08             	mov    0x8(%ebp),%eax
    b102:	8b 00                	mov    (%eax),%eax
    b104:	85 c0                	test   %eax,%eax
    b106:	74 0c                	je     b114 <HuffmanTree_makeFromLengths2+0x76>
    b108:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    b10c:	74 06                	je     b114 <HuffmanTree_makeFromLengths2+0x76>
    b10e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    b112:	75 07                	jne    b11b <HuffmanTree_makeFromLengths2+0x7d>
    b114:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    b11b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b11f:	0f 85 7d 01 00 00    	jne    b2a2 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    b125:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    b12c:	eb 2c                	jmp    b15a <HuffmanTree_makeFromLengths2+0xbc>
    b12e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b131:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b138:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b13b:	01 c2                	add    %eax,%edx
    b13d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b140:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    b147:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b14a:	01 c8                	add    %ecx,%eax
    b14c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    b152:	8b 00                	mov    (%eax),%eax
    b154:	89 02                	mov    %eax,(%edx)
    b156:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    b15a:	8b 45 08             	mov    0x8(%ebp),%eax
    b15d:	8b 40 08             	mov    0x8(%eax),%eax
    b160:	83 c0 01             	add    $0x1,%eax
    b163:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    b166:	75 c6                	jne    b12e <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    b168:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    b16f:	eb 27                	jmp    b198 <HuffmanTree_makeFromLengths2+0xfa>
    b171:	8b 45 08             	mov    0x8(%ebp),%eax
    b174:	8b 40 04             	mov    0x4(%eax),%eax
    b177:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b17a:	c1 e2 02             	shl    $0x2,%edx
    b17d:	01 d0                	add    %edx,%eax
    b17f:	8b 00                	mov    (%eax),%eax
    b181:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b188:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b18b:	01 d0                	add    %edx,%eax
    b18d:	8b 10                	mov    (%eax),%edx
    b18f:	83 c2 01             	add    $0x1,%edx
    b192:	89 10                	mov    %edx,(%eax)
    b194:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    b198:	8b 45 08             	mov    0x8(%ebp),%eax
    b19b:	8b 40 0c             	mov    0xc(%eax),%eax
    b19e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    b1a1:	75 ce                	jne    b171 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    b1a3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    b1aa:	eb 47                	jmp    b1f3 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    b1ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b1af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b1b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b1b9:	01 d0                	add    %edx,%eax
    b1bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b1be:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    b1c4:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    b1cb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b1ce:	01 ca                	add    %ecx,%edx
    b1d0:	8b 0a                	mov    (%edx),%ecx
    b1d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b1d5:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    b1db:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    b1e2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b1e5:	01 da                	add    %ebx,%edx
    b1e7:	8b 12                	mov    (%edx),%edx
    b1e9:	01 ca                	add    %ecx,%edx
    b1eb:	01 d2                	add    %edx,%edx
    b1ed:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    b1ef:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    b1f3:	8b 45 08             	mov    0x8(%ebp),%eax
    b1f6:	8b 40 08             	mov    0x8(%eax),%eax
    b1f9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    b1fc:	73 ae                	jae    b1ac <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    b1fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    b205:	e9 89 00 00 00       	jmp    b293 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    b20a:	8b 45 08             	mov    0x8(%ebp),%eax
    b20d:	8b 40 04             	mov    0x4(%eax),%eax
    b210:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b213:	c1 e2 02             	shl    $0x2,%edx
    b216:	01 d0                	add    %edx,%eax
    b218:	8b 00                	mov    (%eax),%eax
    b21a:	85 c0                	test   %eax,%eax
    b21c:	74 71                	je     b28f <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    b21e:	8b 45 08             	mov    0x8(%ebp),%eax
    b221:	8b 00                	mov    (%eax),%eax
    b223:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b226:	c1 e2 02             	shl    $0x2,%edx
    b229:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    b22c:	8b 45 08             	mov    0x8(%ebp),%eax
    b22f:	8b 40 04             	mov    0x4(%eax),%eax
    b232:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b235:	c1 e2 02             	shl    $0x2,%edx
    b238:	01 d0                	add    %edx,%eax
    b23a:	8b 00                	mov    (%eax),%eax
    b23c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b243:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b246:	01 c2                	add    %eax,%edx
    b248:	8b 02                	mov    (%edx),%eax
    b24a:	8d 48 01             	lea    0x1(%eax),%ecx
    b24d:	89 0a                	mov    %ecx,(%edx)
    b24f:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    b251:	8b 45 08             	mov    0x8(%ebp),%eax
    b254:	8b 00                	mov    (%eax),%eax
    b256:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b259:	c1 e2 02             	shl    $0x2,%edx
    b25c:	01 c2                	add    %eax,%edx
    b25e:	8b 45 08             	mov    0x8(%ebp),%eax
    b261:	8b 00                	mov    (%eax),%eax
    b263:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    b266:	c1 e1 02             	shl    $0x2,%ecx
    b269:	01 c8                	add    %ecx,%eax
    b26b:	8b 18                	mov    (%eax),%ebx
    b26d:	8b 45 08             	mov    0x8(%ebp),%eax
    b270:	8b 40 04             	mov    0x4(%eax),%eax
    b273:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    b276:	c1 e1 02             	shl    $0x2,%ecx
    b279:	01 c8                	add    %ecx,%eax
    b27b:	8b 00                	mov    (%eax),%eax
    b27d:	be 01 00 00 00       	mov    $0x1,%esi
    b282:	89 c1                	mov    %eax,%ecx
    b284:	d3 e6                	shl    %cl,%esi
    b286:	89 f0                	mov    %esi,%eax
    b288:	83 e8 01             	sub    $0x1,%eax
    b28b:	21 d8                	and    %ebx,%eax
    b28d:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    b28f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    b293:	8b 45 08             	mov    0x8(%ebp),%eax
    b296:	8b 40 0c             	mov    0xc(%eax),%eax
    b299:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    b29c:	0f 85 68 ff ff ff    	jne    b20a <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    b2a2:	83 ec 0c             	sub    $0xc,%esp
    b2a5:	ff 75 e8             	pushl  -0x18(%ebp)
    b2a8:	e8 11 ea ff ff       	call   9cbe <lodepng_free>
    b2ad:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    b2b0:	83 ec 0c             	sub    $0xc,%esp
    b2b3:	ff 75 e4             	pushl  -0x1c(%ebp)
    b2b6:	e8 03 ea ff ff       	call   9cbe <lodepng_free>
    b2bb:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    b2be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b2c2:	75 11                	jne    b2d5 <HuffmanTree_makeFromLengths2+0x237>
    b2c4:	83 ec 0c             	sub    $0xc,%esp
    b2c7:	ff 75 08             	pushl  0x8(%ebp)
    b2ca:	e8 3f f9 ff ff       	call   ac0e <HuffmanTree_makeTable>
    b2cf:	83 c4 10             	add    $0x10,%esp
    b2d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    b2d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    b2d8:	8d 65 f8             	lea    -0x8(%ebp),%esp
    b2db:	5b                   	pop    %ebx
    b2dc:	5e                   	pop    %esi
    b2dd:	5d                   	pop    %ebp
    b2de:	c3                   	ret    

0000b2df <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    b2df:	55                   	push   %ebp
    b2e0:	89 e5                	mov    %esp,%ebp
    b2e2:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    b2e5:	8b 45 10             	mov    0x10(%ebp),%eax
    b2e8:	c1 e0 02             	shl    $0x2,%eax
    b2eb:	83 ec 0c             	sub    $0xc,%esp
    b2ee:	50                   	push   %eax
    b2ef:	e8 a9 e9 ff ff       	call   9c9d <lodepng_malloc>
    b2f4:	83 c4 10             	add    $0x10,%esp
    b2f7:	89 c2                	mov    %eax,%edx
    b2f9:	8b 45 08             	mov    0x8(%ebp),%eax
    b2fc:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    b2ff:	8b 45 08             	mov    0x8(%ebp),%eax
    b302:	8b 40 04             	mov    0x4(%eax),%eax
    b305:	85 c0                	test   %eax,%eax
    b307:	75 07                	jne    b310 <HuffmanTree_makeFromLengths+0x31>
    b309:	b8 53 00 00 00       	mov    $0x53,%eax
    b30e:	eb 56                	jmp    b366 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    b310:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    b317:	eb 25                	jmp    b33e <HuffmanTree_makeFromLengths+0x5f>
    b319:	8b 45 08             	mov    0x8(%ebp),%eax
    b31c:	8b 40 04             	mov    0x4(%eax),%eax
    b31f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    b322:	c1 e2 02             	shl    $0x2,%edx
    b325:	01 c2                	add    %eax,%edx
    b327:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b32a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    b331:	8b 45 0c             	mov    0xc(%ebp),%eax
    b334:	01 c8                	add    %ecx,%eax
    b336:	8b 00                	mov    (%eax),%eax
    b338:	89 02                	mov    %eax,(%edx)
    b33a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    b33e:	8b 45 10             	mov    0x10(%ebp),%eax
    b341:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    b344:	75 d3                	jne    b319 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    b346:	8b 55 10             	mov    0x10(%ebp),%edx
    b349:	8b 45 08             	mov    0x8(%ebp),%eax
    b34c:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    b34f:	8b 45 08             	mov    0x8(%ebp),%eax
    b352:	8b 55 14             	mov    0x14(%ebp),%edx
    b355:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    b358:	83 ec 0c             	sub    $0xc,%esp
    b35b:	ff 75 08             	pushl  0x8(%ebp)
    b35e:	e8 3b fd ff ff       	call   b09e <HuffmanTree_makeFromLengths2>
    b363:	83 c4 10             	add    $0x10,%esp
}
    b366:	c9                   	leave  
    b367:	c3                   	ret    

0000b368 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    b368:	55                   	push   %ebp
    b369:	89 e5                	mov    %esp,%ebp
    b36b:	53                   	push   %ebx
    b36c:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    b36f:	8b 45 08             	mov    0x8(%ebp),%eax
    b372:	8b 50 0c             	mov    0xc(%eax),%edx
    b375:	8b 45 08             	mov    0x8(%ebp),%eax
    b378:	8b 40 08             	mov    0x8(%eax),%eax
    b37b:	39 c2                	cmp    %eax,%edx
    b37d:	0f 82 0b 01 00 00    	jb     b48e <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    b383:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b38a:	eb 19                	jmp    b3a5 <bpmnode_create+0x3d>
    b38c:	8b 45 08             	mov    0x8(%ebp),%eax
    b38f:	8b 40 04             	mov    0x4(%eax),%eax
    b392:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b395:	c1 e2 04             	shl    $0x4,%edx
    b398:	01 d0                	add    %edx,%eax
    b39a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    b3a1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3a5:	8b 45 08             	mov    0x8(%ebp),%eax
    b3a8:	8b 00                	mov    (%eax),%eax
    b3aa:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    b3ad:	75 dd                	jne    b38c <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    b3af:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3b6:	eb 60                	jmp    b418 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    b3b8:	8b 45 08             	mov    0x8(%ebp),%eax
    b3bb:	8b 40 18             	mov    0x18(%eax),%eax
    b3be:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3c1:	c1 e2 02             	shl    $0x2,%edx
    b3c4:	01 d0                	add    %edx,%eax
    b3c6:	8b 00                	mov    (%eax),%eax
    b3c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    b3cb:	eb 13                	jmp    b3e0 <bpmnode_create+0x78>
    b3cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3d0:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    b3d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3da:	8b 40 08             	mov    0x8(%eax),%eax
    b3dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    b3e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b3e4:	75 e7                	jne    b3cd <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    b3e6:	8b 45 08             	mov    0x8(%ebp),%eax
    b3e9:	8b 40 1c             	mov    0x1c(%eax),%eax
    b3ec:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3ef:	c1 e2 02             	shl    $0x2,%edx
    b3f2:	01 d0                	add    %edx,%eax
    b3f4:	8b 00                	mov    (%eax),%eax
    b3f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    b3f9:	eb 13                	jmp    b40e <bpmnode_create+0xa6>
    b3fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3fe:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    b405:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b408:	8b 40 08             	mov    0x8(%eax),%eax
    b40b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    b40e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b412:	75 e7                	jne    b3fb <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    b414:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b418:	8b 45 08             	mov    0x8(%ebp),%eax
    b41b:	8b 40 14             	mov    0x14(%eax),%eax
    b41e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    b421:	75 95                	jne    b3b8 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    b423:	8b 45 08             	mov    0x8(%ebp),%eax
    b426:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    b42d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b434:	eb 44                	jmp    b47a <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    b436:	8b 45 08             	mov    0x8(%ebp),%eax
    b439:	8b 40 04             	mov    0x4(%eax),%eax
    b43c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b43f:	c1 e2 04             	shl    $0x4,%edx
    b442:	01 d0                	add    %edx,%eax
    b444:	8b 40 0c             	mov    0xc(%eax),%eax
    b447:	85 c0                	test   %eax,%eax
    b449:	75 2b                	jne    b476 <bpmnode_create+0x10e>
    b44b:	8b 45 08             	mov    0x8(%ebp),%eax
    b44e:	8b 58 10             	mov    0x10(%eax),%ebx
    b451:	8b 45 08             	mov    0x8(%ebp),%eax
    b454:	8b 40 08             	mov    0x8(%eax),%eax
    b457:	8d 48 01             	lea    0x1(%eax),%ecx
    b45a:	8b 55 08             	mov    0x8(%ebp),%edx
    b45d:	89 4a 08             	mov    %ecx,0x8(%edx)
    b460:	c1 e0 02             	shl    $0x2,%eax
    b463:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b466:	8b 45 08             	mov    0x8(%ebp),%eax
    b469:	8b 40 04             	mov    0x4(%eax),%eax
    b46c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b46f:	c1 e1 04             	shl    $0x4,%ecx
    b472:	01 c8                	add    %ecx,%eax
    b474:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    b476:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b47a:	8b 45 08             	mov    0x8(%ebp),%eax
    b47d:	8b 00                	mov    (%eax),%eax
    b47f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    b482:	75 b2                	jne    b436 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    b484:	8b 45 08             	mov    0x8(%ebp),%eax
    b487:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    b48e:	8b 45 08             	mov    0x8(%ebp),%eax
    b491:	8b 58 10             	mov    0x10(%eax),%ebx
    b494:	8b 45 08             	mov    0x8(%ebp),%eax
    b497:	8b 40 0c             	mov    0xc(%eax),%eax
    b49a:	8d 48 01             	lea    0x1(%eax),%ecx
    b49d:	8b 55 08             	mov    0x8(%ebp),%edx
    b4a0:	89 4a 0c             	mov    %ecx,0xc(%edx)
    b4a3:	c1 e0 02             	shl    $0x2,%eax
    b4a6:	01 d8                	add    %ebx,%eax
    b4a8:	8b 00                	mov    (%eax),%eax
    b4aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    b4ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b4b0:	8b 55 0c             	mov    0xc(%ebp),%edx
    b4b3:	89 10                	mov    %edx,(%eax)
  result->index = index;
    b4b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b4b8:	8b 55 10             	mov    0x10(%ebp),%edx
    b4bb:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    b4be:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b4c1:	8b 55 14             	mov    0x14(%ebp),%edx
    b4c4:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    b4c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    b4ca:	83 c4 10             	add    $0x10,%esp
    b4cd:	5b                   	pop    %ebx
    b4ce:	5d                   	pop    %ebp
    b4cf:	c3                   	ret    

0000b4d0 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    b4d0:	55                   	push   %ebp
    b4d1:	89 e5                	mov    %esp,%ebp
    b4d3:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    b4d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    b4d9:	c1 e0 04             	shl    $0x4,%eax
    b4dc:	83 ec 0c             	sub    $0xc,%esp
    b4df:	50                   	push   %eax
    b4e0:	e8 b8 e7 ff ff       	call   9c9d <lodepng_malloc>
    b4e5:	83 c4 10             	add    $0x10,%esp
    b4e8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    b4eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    b4f2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    b4f9:	e9 41 01 00 00       	jmp    b63f <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    b4fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b501:	83 e0 01             	and    $0x1,%eax
    b504:	85 c0                	test   %eax,%eax
    b506:	74 05                	je     b50d <bpmnode_sort+0x3d>
    b508:	8b 45 dc             	mov    -0x24(%ebp),%eax
    b50b:	eb 03                	jmp    b510 <bpmnode_sort+0x40>
    b50d:	8b 45 08             	mov    0x8(%ebp),%eax
    b510:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    b513:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b516:	83 e0 01             	and    $0x1,%eax
    b519:	85 c0                	test   %eax,%eax
    b51b:	74 05                	je     b522 <bpmnode_sort+0x52>
    b51d:	8b 45 08             	mov    0x8(%ebp),%eax
    b520:	eb 03                	jmp    b525 <bpmnode_sort+0x55>
    b522:	8b 45 dc             	mov    -0x24(%ebp),%eax
    b525:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    b528:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    b52f:	e9 f8 00 00 00       	jmp    b62c <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    b534:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b537:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b53a:	01 c2                	add    %eax,%edx
    b53c:	8b 45 0c             	mov    0xc(%ebp),%eax
    b53f:	39 c2                	cmp    %eax,%edx
    b541:	0f 4e c2             	cmovle %edx,%eax
    b544:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    b547:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b54a:	8d 14 00             	lea    (%eax,%eax,1),%edx
    b54d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b550:	01 c2                	add    %eax,%edx
    b552:	8b 45 0c             	mov    0xc(%ebp),%eax
    b555:	39 c2                	cmp    %eax,%edx
    b557:	0f 4e c2             	cmovle %edx,%eax
    b55a:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    b55d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b560:	89 45 e8             	mov    %eax,-0x18(%ebp)
    b563:	8b 45 d0             	mov    -0x30(%ebp),%eax
    b566:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    b569:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b56c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    b56f:	e9 a4 00 00 00       	jmp    b618 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    b574:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b577:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    b57a:	7d 62                	jge    b5de <bpmnode_sort+0x10e>
    b57c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b57f:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    b582:	7d 22                	jge    b5a6 <bpmnode_sort+0xd6>
    b584:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b587:	c1 e0 04             	shl    $0x4,%eax
    b58a:	89 c2                	mov    %eax,%edx
    b58c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b58f:	01 d0                	add    %edx,%eax
    b591:	8b 10                	mov    (%eax),%edx
    b593:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b596:	c1 e0 04             	shl    $0x4,%eax
    b599:	89 c1                	mov    %eax,%ecx
    b59b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b59e:	01 c8                	add    %ecx,%eax
    b5a0:	8b 00                	mov    (%eax),%eax
    b5a2:	39 c2                	cmp    %eax,%edx
    b5a4:	7f 38                	jg     b5de <bpmnode_sort+0x10e>
    b5a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    b5a9:	c1 e0 04             	shl    $0x4,%eax
    b5ac:	89 c2                	mov    %eax,%edx
    b5ae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    b5b1:	01 d0                	add    %edx,%eax
    b5b3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b5b6:	8d 4a 01             	lea    0x1(%edx),%ecx
    b5b9:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    b5bc:	89 d1                	mov    %edx,%ecx
    b5be:	c1 e1 04             	shl    $0x4,%ecx
    b5c1:	8b 55 d8             	mov    -0x28(%ebp),%edx
    b5c4:	01 ca                	add    %ecx,%edx
    b5c6:	8b 0a                	mov    (%edx),%ecx
    b5c8:	89 08                	mov    %ecx,(%eax)
    b5ca:	8b 4a 04             	mov    0x4(%edx),%ecx
    b5cd:	89 48 04             	mov    %ecx,0x4(%eax)
    b5d0:	8b 4a 08             	mov    0x8(%edx),%ecx
    b5d3:	89 48 08             	mov    %ecx,0x8(%eax)
    b5d6:	8b 52 0c             	mov    0xc(%edx),%edx
    b5d9:	89 50 0c             	mov    %edx,0xc(%eax)
    b5dc:	eb 36                	jmp    b614 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    b5de:	8b 45 e0             	mov    -0x20(%ebp),%eax
    b5e1:	c1 e0 04             	shl    $0x4,%eax
    b5e4:	89 c2                	mov    %eax,%edx
    b5e6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    b5e9:	01 d0                	add    %edx,%eax
    b5eb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b5ee:	8d 4a 01             	lea    0x1(%edx),%ecx
    b5f1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    b5f4:	89 d1                	mov    %edx,%ecx
    b5f6:	c1 e1 04             	shl    $0x4,%ecx
    b5f9:	8b 55 d8             	mov    -0x28(%ebp),%edx
    b5fc:	01 ca                	add    %ecx,%edx
    b5fe:	8b 0a                	mov    (%edx),%ecx
    b600:	89 08                	mov    %ecx,(%eax)
    b602:	8b 4a 04             	mov    0x4(%edx),%ecx
    b605:	89 48 04             	mov    %ecx,0x4(%eax)
    b608:	8b 4a 08             	mov    0x8(%edx),%ecx
    b60b:	89 48 08             	mov    %ecx,0x8(%eax)
    b60e:	8b 52 0c             	mov    0xc(%edx),%edx
    b611:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    b614:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    b618:	8b 45 e0             	mov    -0x20(%ebp),%eax
    b61b:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    b61e:	0f 8c 50 ff ff ff    	jl     b574 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    b624:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b627:	01 c0                	add    %eax,%eax
    b629:	01 45 ec             	add    %eax,-0x14(%ebp)
    b62c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b62f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b632:	0f 8c fc fe ff ff    	jl     b534 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    b638:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    b63c:	d1 65 f4             	shll   -0xc(%ebp)
    b63f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b642:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b645:	0f 8c b3 fe ff ff    	jl     b4fe <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    b64b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b64e:	83 e0 01             	and    $0x1,%eax
    b651:	85 c0                	test   %eax,%eax
    b653:	74 18                	je     b66d <bpmnode_sort+0x19d>
    b655:	8b 45 0c             	mov    0xc(%ebp),%eax
    b658:	c1 e0 04             	shl    $0x4,%eax
    b65b:	83 ec 04             	sub    $0x4,%esp
    b65e:	50                   	push   %eax
    b65f:	ff 75 dc             	pushl  -0x24(%ebp)
    b662:	ff 75 08             	pushl  0x8(%ebp)
    b665:	e8 71 e6 ff ff       	call   9cdb <lodepng_memcpy>
    b66a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    b66d:	83 ec 0c             	sub    $0xc,%esp
    b670:	ff 75 dc             	pushl  -0x24(%ebp)
    b673:	e8 46 e6 ff ff       	call   9cbe <lodepng_free>
    b678:	83 c4 10             	add    $0x10,%esp
}
    b67b:	90                   	nop
    b67c:	c9                   	leave  
    b67d:	c3                   	ret    

0000b67e <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    b67e:	55                   	push   %ebp
    b67f:	89 e5                	mov    %esp,%ebp
    b681:	56                   	push   %esi
    b682:	53                   	push   %ebx
    b683:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    b686:	8b 45 08             	mov    0x8(%ebp),%eax
    b689:	8b 40 1c             	mov    0x1c(%eax),%eax
    b68c:	8b 55 14             	mov    0x14(%ebp),%edx
    b68f:	c1 e2 02             	shl    $0x2,%edx
    b692:	01 d0                	add    %edx,%eax
    b694:	8b 00                	mov    (%eax),%eax
    b696:	8b 40 04             	mov    0x4(%eax),%eax
    b699:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    b69c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    b6a0:	75 66                	jne    b708 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    b6a2:	8b 45 10             	mov    0x10(%ebp),%eax
    b6a5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    b6a8:	0f 83 a0 01 00 00    	jae    b84e <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    b6ae:	8b 45 08             	mov    0x8(%ebp),%eax
    b6b1:	8b 40 18             	mov    0x18(%eax),%eax
    b6b4:	8b 55 14             	mov    0x14(%ebp),%edx
    b6b7:	c1 e2 02             	shl    $0x2,%edx
    b6ba:	01 c2                	add    %eax,%edx
    b6bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b6bf:	8b 40 1c             	mov    0x1c(%eax),%eax
    b6c2:	8b 4d 14             	mov    0x14(%ebp),%ecx
    b6c5:	c1 e1 02             	shl    $0x2,%ecx
    b6c8:	01 c8                	add    %ecx,%eax
    b6ca:	8b 00                	mov    (%eax),%eax
    b6cc:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    b6ce:	8b 45 08             	mov    0x8(%ebp),%eax
    b6d1:	8b 40 1c             	mov    0x1c(%eax),%eax
    b6d4:	8b 55 14             	mov    0x14(%ebp),%edx
    b6d7:	c1 e2 02             	shl    $0x2,%edx
    b6da:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    b6dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6e0:	8d 50 01             	lea    0x1(%eax),%edx
    b6e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6e6:	c1 e0 04             	shl    $0x4,%eax
    b6e9:	89 c1                	mov    %eax,%ecx
    b6eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    b6ee:	01 c8                	add    %ecx,%eax
    b6f0:	8b 00                	mov    (%eax),%eax
    b6f2:	6a 00                	push   $0x0
    b6f4:	52                   	push   %edx
    b6f5:	50                   	push   %eax
    b6f6:	ff 75 08             	pushl  0x8(%ebp)
    b6f9:	e8 6a fc ff ff       	call   b368 <bpmnode_create>
    b6fe:	83 c4 10             	add    $0x10,%esp
    b701:	89 03                	mov    %eax,(%ebx)
    b703:	e9 47 01 00 00       	jmp    b84f <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    b708:	8b 45 08             	mov    0x8(%ebp),%eax
    b70b:	8b 40 18             	mov    0x18(%eax),%eax
    b70e:	8b 55 14             	mov    0x14(%ebp),%edx
    b711:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    b717:	c1 e2 02             	shl    $0x2,%edx
    b71a:	01 d0                	add    %edx,%eax
    b71c:	8b 00                	mov    (%eax),%eax
    b71e:	8b 10                	mov    (%eax),%edx
    b720:	8b 45 08             	mov    0x8(%ebp),%eax
    b723:	8b 40 1c             	mov    0x1c(%eax),%eax
    b726:	8b 4d 14             	mov    0x14(%ebp),%ecx
    b729:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    b72f:	c1 e1 02             	shl    $0x2,%ecx
    b732:	01 c8                	add    %ecx,%eax
    b734:	8b 00                	mov    (%eax),%eax
    b736:	8b 00                	mov    (%eax),%eax
    b738:	01 d0                	add    %edx,%eax
    b73a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    b73d:	8b 45 08             	mov    0x8(%ebp),%eax
    b740:	8b 40 18             	mov    0x18(%eax),%eax
    b743:	8b 55 14             	mov    0x14(%ebp),%edx
    b746:	c1 e2 02             	shl    $0x2,%edx
    b749:	01 c2                	add    %eax,%edx
    b74b:	8b 45 08             	mov    0x8(%ebp),%eax
    b74e:	8b 40 1c             	mov    0x1c(%eax),%eax
    b751:	8b 4d 14             	mov    0x14(%ebp),%ecx
    b754:	c1 e1 02             	shl    $0x2,%ecx
    b757:	01 c8                	add    %ecx,%eax
    b759:	8b 00                	mov    (%eax),%eax
    b75b:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    b75d:	8b 45 10             	mov    0x10(%ebp),%eax
    b760:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    b763:	73 60                	jae    b7c5 <boundaryPM+0x147>
    b765:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b768:	c1 e0 04             	shl    $0x4,%eax
    b76b:	89 c2                	mov    %eax,%edx
    b76d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b770:	01 d0                	add    %edx,%eax
    b772:	8b 00                	mov    (%eax),%eax
    b774:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    b777:	7d 4c                	jge    b7c5 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    b779:	8b 45 08             	mov    0x8(%ebp),%eax
    b77c:	8b 40 1c             	mov    0x1c(%eax),%eax
    b77f:	8b 55 14             	mov    0x14(%ebp),%edx
    b782:	c1 e2 02             	shl    $0x2,%edx
    b785:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    b788:	8b 45 08             	mov    0x8(%ebp),%eax
    b78b:	8b 40 1c             	mov    0x1c(%eax),%eax
    b78e:	8b 55 14             	mov    0x14(%ebp),%edx
    b791:	c1 e2 02             	shl    $0x2,%edx
    b794:	01 d0                	add    %edx,%eax
    b796:	8b 00                	mov    (%eax),%eax
    b798:	8b 50 08             	mov    0x8(%eax),%edx
    b79b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b79e:	8d 48 01             	lea    0x1(%eax),%ecx
    b7a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b7a4:	c1 e0 04             	shl    $0x4,%eax
    b7a7:	89 c6                	mov    %eax,%esi
    b7a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    b7ac:	01 f0                	add    %esi,%eax
    b7ae:	8b 00                	mov    (%eax),%eax
    b7b0:	52                   	push   %edx
    b7b1:	51                   	push   %ecx
    b7b2:	50                   	push   %eax
    b7b3:	ff 75 08             	pushl  0x8(%ebp)
    b7b6:	e8 ad fb ff ff       	call   b368 <bpmnode_create>
    b7bb:	83 c4 10             	add    $0x10,%esp
    b7be:	89 03                	mov    %eax,(%ebx)
      return;
    b7c0:	e9 8a 00 00 00       	jmp    b84f <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    b7c5:	8b 45 08             	mov    0x8(%ebp),%eax
    b7c8:	8b 40 1c             	mov    0x1c(%eax),%eax
    b7cb:	8b 55 14             	mov    0x14(%ebp),%edx
    b7ce:	c1 e2 02             	shl    $0x2,%edx
    b7d1:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    b7d4:	8b 45 08             	mov    0x8(%ebp),%eax
    b7d7:	8b 40 1c             	mov    0x1c(%eax),%eax
    b7da:	8b 55 14             	mov    0x14(%ebp),%edx
    b7dd:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    b7e3:	c1 e2 02             	shl    $0x2,%edx
    b7e6:	01 d0                	add    %edx,%eax
    b7e8:	8b 00                	mov    (%eax),%eax
    b7ea:	50                   	push   %eax
    b7eb:	ff 75 f4             	pushl  -0xc(%ebp)
    b7ee:	ff 75 f0             	pushl  -0x10(%ebp)
    b7f1:	ff 75 08             	pushl  0x8(%ebp)
    b7f4:	e8 6f fb ff ff       	call   b368 <bpmnode_create>
    b7f9:	83 c4 10             	add    $0x10,%esp
    b7fc:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    b7fe:	8b 45 18             	mov    0x18(%ebp),%eax
    b801:	8d 50 01             	lea    0x1(%eax),%edx
    b804:	8b 45 10             	mov    0x10(%ebp),%eax
    b807:	83 e8 01             	sub    $0x1,%eax
    b80a:	01 c0                	add    %eax,%eax
    b80c:	39 c2                	cmp    %eax,%edx
    b80e:	7d 3f                	jge    b84f <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    b810:	8b 45 14             	mov    0x14(%ebp),%eax
    b813:	83 e8 01             	sub    $0x1,%eax
    b816:	83 ec 0c             	sub    $0xc,%esp
    b819:	ff 75 18             	pushl  0x18(%ebp)
    b81c:	50                   	push   %eax
    b81d:	ff 75 10             	pushl  0x10(%ebp)
    b820:	ff 75 0c             	pushl  0xc(%ebp)
    b823:	ff 75 08             	pushl  0x8(%ebp)
    b826:	e8 53 fe ff ff       	call   b67e <boundaryPM>
    b82b:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    b82e:	8b 45 14             	mov    0x14(%ebp),%eax
    b831:	83 e8 01             	sub    $0x1,%eax
    b834:	83 ec 0c             	sub    $0xc,%esp
    b837:	ff 75 18             	pushl  0x18(%ebp)
    b83a:	50                   	push   %eax
    b83b:	ff 75 10             	pushl  0x10(%ebp)
    b83e:	ff 75 0c             	pushl  0xc(%ebp)
    b841:	ff 75 08             	pushl  0x8(%ebp)
    b844:	e8 35 fe ff ff       	call   b67e <boundaryPM>
    b849:	83 c4 20             	add    $0x20,%esp
    b84c:	eb 01                	jmp    b84f <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    b84e:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    b84f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    b852:	5b                   	pop    %ebx
    b853:	5e                   	pop    %esi
    b854:	5d                   	pop    %ebp
    b855:	c3                   	ret    

0000b856 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    b856:	55                   	push   %ebp
    b857:	89 e5                	mov    %esp,%ebp
    b859:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    b85c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    b863:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    b86a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    b86e:	75 0a                	jne    b87a <lodepng_huffman_code_lengths+0x24>
    b870:	b8 50 00 00 00       	mov    $0x50,%eax
    b875:	e9 4d 03 00 00       	jmp    bbc7 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    b87a:	8b 45 14             	mov    0x14(%ebp),%eax
    b87d:	ba 01 00 00 00       	mov    $0x1,%edx
    b882:	89 c1                	mov    %eax,%ecx
    b884:	d3 e2                	shl    %cl,%edx
    b886:	8b 45 10             	mov    0x10(%ebp),%eax
    b889:	39 c2                	cmp    %eax,%edx
    b88b:	73 0a                	jae    b897 <lodepng_huffman_code_lengths+0x41>
    b88d:	b8 50 00 00 00       	mov    $0x50,%eax
    b892:	e9 30 03 00 00       	jmp    bbc7 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    b897:	8b 45 10             	mov    0x10(%ebp),%eax
    b89a:	c1 e0 04             	shl    $0x4,%eax
    b89d:	83 ec 0c             	sub    $0xc,%esp
    b8a0:	50                   	push   %eax
    b8a1:	e8 f7 e3 ff ff       	call   9c9d <lodepng_malloc>
    b8a6:	83 c4 10             	add    $0x10,%esp
    b8a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    b8ac:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    b8b0:	75 0a                	jne    b8bc <lodepng_huffman_code_lengths+0x66>
    b8b2:	b8 53 00 00 00       	mov    $0x53,%eax
    b8b7:	e9 0b 03 00 00       	jmp    bbc7 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    b8bc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    b8c3:	eb 50                	jmp    b915 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    b8c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b8c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b8cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8d2:	01 d0                	add    %edx,%eax
    b8d4:	8b 00                	mov    (%eax),%eax
    b8d6:	85 c0                	test   %eax,%eax
    b8d8:	74 37                	je     b911 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    b8da:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b8dd:	c1 e0 04             	shl    $0x4,%eax
    b8e0:	89 c2                	mov    %eax,%edx
    b8e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b8e5:	01 d0                	add    %edx,%eax
    b8e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    b8ea:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    b8f1:	8b 55 0c             	mov    0xc(%ebp),%edx
    b8f4:	01 ca                	add    %ecx,%edx
    b8f6:	8b 12                	mov    (%edx),%edx
    b8f8:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    b8fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b8fd:	c1 e0 04             	shl    $0x4,%eax
    b900:	89 c2                	mov    %eax,%edx
    b902:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b905:	01 c2                	add    %eax,%edx
    b907:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b90a:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    b90d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    b911:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    b915:	8b 45 10             	mov    0x10(%ebp),%eax
    b918:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    b91b:	75 a8                	jne    b8c5 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    b91d:	8b 45 10             	mov    0x10(%ebp),%eax
    b920:	c1 e0 02             	shl    $0x2,%eax
    b923:	83 ec 04             	sub    $0x4,%esp
    b926:	50                   	push   %eax
    b927:	6a 00                	push   $0x0
    b929:	ff 75 08             	pushl  0x8(%ebp)
    b92c:	e8 dd e3 ff ff       	call   9d0e <lodepng_memset>
    b931:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    b934:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    b938:	75 18                	jne    b952 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    b93a:	8b 45 08             	mov    0x8(%ebp),%eax
    b93d:	83 c0 04             	add    $0x4,%eax
    b940:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    b946:	8b 10                	mov    (%eax),%edx
    b948:	8b 45 08             	mov    0x8(%ebp),%eax
    b94b:	89 10                	mov    %edx,(%eax)
    b94d:	e9 64 02 00 00       	jmp    bbb6 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    b952:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    b956:	75 3e                	jne    b996 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    b958:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b95b:	8b 40 04             	mov    0x4(%eax),%eax
    b95e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b965:	8b 45 08             	mov    0x8(%ebp),%eax
    b968:	01 d0                	add    %edx,%eax
    b96a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    b970:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b973:	8b 40 04             	mov    0x4(%eax),%eax
    b976:	85 c0                	test   %eax,%eax
    b978:	75 07                	jne    b981 <lodepng_huffman_code_lengths+0x12b>
    b97a:	ba 04 00 00 00       	mov    $0x4,%edx
    b97f:	eb 05                	jmp    b986 <lodepng_huffman_code_lengths+0x130>
    b981:	ba 00 00 00 00       	mov    $0x0,%edx
    b986:	8b 45 08             	mov    0x8(%ebp),%eax
    b989:	01 d0                	add    %edx,%eax
    b98b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    b991:	e9 20 02 00 00       	jmp    bbb6 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    b996:	83 ec 08             	sub    $0x8,%esp
    b999:	ff 75 ec             	pushl  -0x14(%ebp)
    b99c:	ff 75 e4             	pushl  -0x1c(%ebp)
    b99f:	e8 2c fb ff ff       	call   b4d0 <bpmnode_sort>
    b9a4:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    b9a7:	8b 45 14             	mov    0x14(%ebp),%eax
    b9aa:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    b9ad:	8b 45 14             	mov    0x14(%ebp),%eax
    b9b0:	83 c0 01             	add    $0x1,%eax
    b9b3:	0f af 45 14          	imul   0x14(%ebp),%eax
    b9b7:	01 c0                	add    %eax,%eax
    b9b9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    b9bc:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    b9c3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    b9c6:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    b9c9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    b9cc:	c1 e0 04             	shl    $0x4,%eax
    b9cf:	83 ec 0c             	sub    $0xc,%esp
    b9d2:	50                   	push   %eax
    b9d3:	e8 c5 e2 ff ff       	call   9c9d <lodepng_malloc>
    b9d8:	83 c4 10             	add    $0x10,%esp
    b9db:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    b9de:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    b9e1:	c1 e0 02             	shl    $0x2,%eax
    b9e4:	83 ec 0c             	sub    $0xc,%esp
    b9e7:	50                   	push   %eax
    b9e8:	e8 b0 e2 ff ff       	call   9c9d <lodepng_malloc>
    b9ed:	83 c4 10             	add    $0x10,%esp
    b9f0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    b9f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b9f6:	c1 e0 02             	shl    $0x2,%eax
    b9f9:	83 ec 0c             	sub    $0xc,%esp
    b9fc:	50                   	push   %eax
    b9fd:	e8 9b e2 ff ff       	call   9c9d <lodepng_malloc>
    ba02:	83 c4 10             	add    $0x10,%esp
    ba05:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    ba08:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ba0b:	c1 e0 02             	shl    $0x2,%eax
    ba0e:	83 ec 0c             	sub    $0xc,%esp
    ba11:	50                   	push   %eax
    ba12:	e8 86 e2 ff ff       	call   9c9d <lodepng_malloc>
    ba17:	83 c4 10             	add    $0x10,%esp
    ba1a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    ba1d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ba20:	85 c0                	test   %eax,%eax
    ba22:	74 15                	je     ba39 <lodepng_huffman_code_lengths+0x1e3>
    ba24:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ba27:	85 c0                	test   %eax,%eax
    ba29:	74 0e                	je     ba39 <lodepng_huffman_code_lengths+0x1e3>
    ba2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ba2e:	85 c0                	test   %eax,%eax
    ba30:	74 07                	je     ba39 <lodepng_huffman_code_lengths+0x1e3>
    ba32:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ba35:	85 c0                	test   %eax,%eax
    ba37:	75 07                	jne    ba40 <lodepng_huffman_code_lengths+0x1ea>
    ba39:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    ba40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ba44:	0f 85 30 01 00 00    	jne    bb7a <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    ba4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ba51:	eb 1c                	jmp    ba6f <lodepng_huffman_code_lengths+0x219>
    ba53:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ba56:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ba59:	c1 e2 02             	shl    $0x2,%edx
    ba5c:	01 d0                	add    %edx,%eax
    ba5e:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ba61:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    ba64:	c1 e1 04             	shl    $0x4,%ecx
    ba67:	01 ca                	add    %ecx,%edx
    ba69:	89 10                	mov    %edx,(%eax)
    ba6b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ba6f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    ba72:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    ba75:	75 dc                	jne    ba53 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    ba77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ba7a:	8b 00                	mov    (%eax),%eax
    ba7c:	6a 00                	push   $0x0
    ba7e:	6a 01                	push   $0x1
    ba80:	50                   	push   %eax
    ba81:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    ba84:	50                   	push   %eax
    ba85:	e8 de f8 ff ff       	call   b368 <bpmnode_create>
    ba8a:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    ba8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ba90:	83 c0 10             	add    $0x10,%eax
    ba93:	8b 00                	mov    (%eax),%eax
    ba95:	6a 00                	push   $0x0
    ba97:	6a 02                	push   $0x2
    ba99:	50                   	push   %eax
    ba9a:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    ba9d:	50                   	push   %eax
    ba9e:	e8 c5 f8 ff ff       	call   b368 <bpmnode_create>
    baa3:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    baa6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    baad:	eb 27                	jmp    bad6 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    baaf:	8b 45 dc             	mov    -0x24(%ebp),%eax
    bab2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bab5:	c1 e2 02             	shl    $0x2,%edx
    bab8:	01 c2                	add    %eax,%edx
    baba:	8b 45 c8             	mov    -0x38(%ebp),%eax
    babd:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    babf:	8b 45 e0             	mov    -0x20(%ebp),%eax
    bac2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bac5:	c1 e2 02             	shl    $0x2,%edx
    bac8:	01 d0                	add    %edx,%eax
    baca:	8b 55 c8             	mov    -0x38(%ebp),%edx
    bacd:	83 c2 10             	add    $0x10,%edx
    bad0:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    bad2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    bad6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    bad9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    badc:	75 d1                	jne    baaf <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    bade:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    bae5:	eb 24                	jmp    bb0b <lodepng_huffman_code_lengths+0x2b5>
    bae7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    baea:	8b 55 14             	mov    0x14(%ebp),%edx
    baed:	83 ea 01             	sub    $0x1,%edx
    baf0:	83 ec 0c             	sub    $0xc,%esp
    baf3:	50                   	push   %eax
    baf4:	52                   	push   %edx
    baf5:	ff 75 ec             	pushl  -0x14(%ebp)
    baf8:	ff 75 e4             	pushl  -0x1c(%ebp)
    bafb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    bafe:	50                   	push   %eax
    baff:	e8 7a fb ff ff       	call   b67e <boundaryPM>
    bb04:	83 c4 20             	add    $0x20,%esp
    bb07:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    bb0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb0e:	83 e8 01             	sub    $0x1,%eax
    bb11:	01 c0                	add    %eax,%eax
    bb13:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    bb16:	75 cf                	jne    bae7 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    bb18:	8b 45 e0             	mov    -0x20(%ebp),%eax
    bb1b:	8b 55 14             	mov    0x14(%ebp),%edx
    bb1e:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    bb24:	c1 e2 02             	shl    $0x2,%edx
    bb27:	01 d0                	add    %edx,%eax
    bb29:	8b 00                	mov    (%eax),%eax
    bb2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bb2e:	eb 44                	jmp    bb74 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    bb30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    bb37:	eb 27                	jmp    bb60 <lodepng_huffman_code_lengths+0x30a>
    bb39:	8b 45 f0             	mov    -0x10(%ebp),%eax
    bb3c:	c1 e0 04             	shl    $0x4,%eax
    bb3f:	89 c2                	mov    %eax,%edx
    bb41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bb44:	01 d0                	add    %edx,%eax
    bb46:	8b 40 04             	mov    0x4(%eax),%eax
    bb49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bb50:	8b 45 08             	mov    0x8(%ebp),%eax
    bb53:	01 d0                	add    %edx,%eax
    bb55:	8b 10                	mov    (%eax),%edx
    bb57:	83 c2 01             	add    $0x1,%edx
    bb5a:	89 10                	mov    %edx,(%eax)
    bb5c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    bb60:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bb63:	8b 40 04             	mov    0x4(%eax),%eax
    bb66:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    bb69:	75 ce                	jne    bb39 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    bb6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bb6e:	8b 40 08             	mov    0x8(%eax),%eax
    bb71:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bb74:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    bb78:	75 b6                	jne    bb30 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    bb7a:	8b 45 c8             	mov    -0x38(%ebp),%eax
    bb7d:	83 ec 0c             	sub    $0xc,%esp
    bb80:	50                   	push   %eax
    bb81:	e8 38 e1 ff ff       	call   9cbe <lodepng_free>
    bb86:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    bb89:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb8c:	83 ec 0c             	sub    $0xc,%esp
    bb8f:	50                   	push   %eax
    bb90:	e8 29 e1 ff ff       	call   9cbe <lodepng_free>
    bb95:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    bb98:	8b 45 dc             	mov    -0x24(%ebp),%eax
    bb9b:	83 ec 0c             	sub    $0xc,%esp
    bb9e:	50                   	push   %eax
    bb9f:	e8 1a e1 ff ff       	call   9cbe <lodepng_free>
    bba4:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    bba7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    bbaa:	83 ec 0c             	sub    $0xc,%esp
    bbad:	50                   	push   %eax
    bbae:	e8 0b e1 ff ff       	call   9cbe <lodepng_free>
    bbb3:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    bbb6:	83 ec 0c             	sub    $0xc,%esp
    bbb9:	ff 75 e4             	pushl  -0x1c(%ebp)
    bbbc:	e8 fd e0 ff ff       	call   9cbe <lodepng_free>
    bbc1:	83 c4 10             	add    $0x10,%esp
  return error;
    bbc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    bbc7:	c9                   	leave  
    bbc8:	c3                   	ret    

0000bbc9 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    bbc9:	55                   	push   %ebp
    bbca:	89 e5                	mov    %esp,%ebp
    bbcc:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    bbcf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    bbd6:	eb 04                	jmp    bbdc <HuffmanTree_makeFromFrequencies+0x13>
    bbd8:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    bbdc:	8b 45 14             	mov    0x14(%ebp),%eax
    bbdf:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    bbe4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bbeb:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbee:	01 d0                	add    %edx,%eax
    bbf0:	8b 00                	mov    (%eax),%eax
    bbf2:	85 c0                	test   %eax,%eax
    bbf4:	75 08                	jne    bbfe <HuffmanTree_makeFromFrequencies+0x35>
    bbf6:	8b 45 14             	mov    0x14(%ebp),%eax
    bbf9:	3b 45 10             	cmp    0x10(%ebp),%eax
    bbfc:	7f da                	jg     bbd8 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    bbfe:	8b 45 14             	mov    0x14(%ebp),%eax
    bc01:	c1 e0 02             	shl    $0x2,%eax
    bc04:	83 ec 0c             	sub    $0xc,%esp
    bc07:	50                   	push   %eax
    bc08:	e8 90 e0 ff ff       	call   9c9d <lodepng_malloc>
    bc0d:	83 c4 10             	add    $0x10,%esp
    bc10:	89 c2                	mov    %eax,%edx
    bc12:	8b 45 08             	mov    0x8(%ebp),%eax
    bc15:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    bc18:	8b 45 08             	mov    0x8(%ebp),%eax
    bc1b:	8b 40 04             	mov    0x4(%eax),%eax
    bc1e:	85 c0                	test   %eax,%eax
    bc20:	75 07                	jne    bc29 <HuffmanTree_makeFromFrequencies+0x60>
    bc22:	b8 53 00 00 00       	mov    $0x53,%eax
    bc27:	eb 47                	jmp    bc70 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    bc29:	8b 45 08             	mov    0x8(%ebp),%eax
    bc2c:	8b 55 18             	mov    0x18(%ebp),%edx
    bc2f:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    bc32:	8b 55 14             	mov    0x14(%ebp),%edx
    bc35:	8b 45 08             	mov    0x8(%ebp),%eax
    bc38:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    bc3b:	8b 45 08             	mov    0x8(%ebp),%eax
    bc3e:	8b 40 04             	mov    0x4(%eax),%eax
    bc41:	ff 75 18             	pushl  0x18(%ebp)
    bc44:	ff 75 14             	pushl  0x14(%ebp)
    bc47:	ff 75 0c             	pushl  0xc(%ebp)
    bc4a:	50                   	push   %eax
    bc4b:	e8 06 fc ff ff       	call   b856 <lodepng_huffman_code_lengths>
    bc50:	83 c4 10             	add    $0x10,%esp
    bc53:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    bc56:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    bc5a:	75 11                	jne    bc6d <HuffmanTree_makeFromFrequencies+0xa4>
    bc5c:	83 ec 0c             	sub    $0xc,%esp
    bc5f:	ff 75 08             	pushl  0x8(%ebp)
    bc62:	e8 37 f4 ff ff       	call   b09e <HuffmanTree_makeFromLengths2>
    bc67:	83 c4 10             	add    $0x10,%esp
    bc6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    bc6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    bc70:	c9                   	leave  
    bc71:	c3                   	ret    

0000bc72 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    bc72:	55                   	push   %ebp
    bc73:	89 e5                	mov    %esp,%ebp
    bc75:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    bc78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    bc7f:	83 ec 0c             	sub    $0xc,%esp
    bc82:	68 80 04 00 00       	push   $0x480
    bc87:	e8 11 e0 ff ff       	call   9c9d <lodepng_malloc>
    bc8c:	83 c4 10             	add    $0x10,%esp
    bc8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    bc92:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bc96:	75 0a                	jne    bca2 <generateFixedLitLenTree+0x30>
    bc98:	b8 53 00 00 00       	mov    $0x53,%eax
    bc9d:	e9 d5 00 00 00       	jmp    bd77 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    bca2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bca9:	eb 19                	jmp    bcc4 <generateFixedLitLenTree+0x52>
    bcab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bcae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bcb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bcb8:	01 d0                	add    %edx,%eax
    bcba:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    bcc0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bcc4:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    bccb:	76 de                	jbe    bcab <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    bccd:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    bcd4:	eb 19                	jmp    bcef <generateFixedLitLenTree+0x7d>
    bcd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bcd9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bce0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bce3:	01 d0                	add    %edx,%eax
    bce5:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    bceb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bcef:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    bcf6:	76 de                	jbe    bcd6 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    bcf8:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    bcff:	eb 19                	jmp    bd1a <generateFixedLitLenTree+0xa8>
    bd01:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd04:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bd0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bd0e:	01 d0                	add    %edx,%eax
    bd10:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    bd16:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd1a:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    bd21:	76 de                	jbe    bd01 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    bd23:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    bd2a:	eb 19                	jmp    bd45 <generateFixedLitLenTree+0xd3>
    bd2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd2f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bd36:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bd39:	01 d0                	add    %edx,%eax
    bd3b:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    bd41:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd45:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    bd4c:	76 de                	jbe    bd2c <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    bd4e:	6a 0f                	push   $0xf
    bd50:	68 20 01 00 00       	push   $0x120
    bd55:	ff 75 ec             	pushl  -0x14(%ebp)
    bd58:	ff 75 08             	pushl  0x8(%ebp)
    bd5b:	e8 7f f5 ff ff       	call   b2df <HuffmanTree_makeFromLengths>
    bd60:	83 c4 10             	add    $0x10,%esp
    bd63:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    bd66:	83 ec 0c             	sub    $0xc,%esp
    bd69:	ff 75 ec             	pushl  -0x14(%ebp)
    bd6c:	e8 4d df ff ff       	call   9cbe <lodepng_free>
    bd71:	83 c4 10             	add    $0x10,%esp
  return error;
    bd74:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bd77:	c9                   	leave  
    bd78:	c3                   	ret    

0000bd79 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    bd79:	55                   	push   %ebp
    bd7a:	89 e5                	mov    %esp,%ebp
    bd7c:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    bd7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    bd86:	83 ec 0c             	sub    $0xc,%esp
    bd89:	68 80 00 00 00       	push   $0x80
    bd8e:	e8 0a df ff ff       	call   9c9d <lodepng_malloc>
    bd93:	83 c4 10             	add    $0x10,%esp
    bd96:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    bd99:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bd9d:	75 07                	jne    bda6 <generateFixedDistanceTree+0x2d>
    bd9f:	b8 53 00 00 00       	mov    $0x53,%eax
    bda4:	eb 4e                	jmp    bdf4 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    bda6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bdad:	eb 19                	jmp    bdc8 <generateFixedDistanceTree+0x4f>
    bdaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bdb2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bdb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bdbc:	01 d0                	add    %edx,%eax
    bdbe:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    bdc4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bdc8:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    bdcc:	75 e1                	jne    bdaf <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    bdce:	6a 0f                	push   $0xf
    bdd0:	6a 20                	push   $0x20
    bdd2:	ff 75 ec             	pushl  -0x14(%ebp)
    bdd5:	ff 75 08             	pushl  0x8(%ebp)
    bdd8:	e8 02 f5 ff ff       	call   b2df <HuffmanTree_makeFromLengths>
    bddd:	83 c4 10             	add    $0x10,%esp
    bde0:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    bde3:	83 ec 0c             	sub    $0xc,%esp
    bde6:	ff 75 ec             	pushl  -0x14(%ebp)
    bde9:	e8 d0 de ff ff       	call   9cbe <lodepng_free>
    bdee:	83 c4 10             	add    $0x10,%esp
  return error;
    bdf1:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bdf4:	c9                   	leave  
    bdf5:	c3                   	ret    

0000bdf6 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    bdf6:	55                   	push   %ebp
    bdf7:	89 e5                	mov    %esp,%ebp
    bdf9:	53                   	push   %ebx
    bdfa:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    bdfd:	6a 09                	push   $0x9
    bdff:	ff 75 08             	pushl  0x8(%ebp)
    be02:	e8 d8 eb ff ff       	call   a9df <peekBits>
    be07:	83 c4 08             	add    $0x8,%esp
    be0a:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    be0e:	8b 45 0c             	mov    0xc(%ebp),%eax
    be11:	8b 50 10             	mov    0x10(%eax),%edx
    be14:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    be18:	01 d0                	add    %edx,%eax
    be1a:	0f b6 00             	movzbl (%eax),%eax
    be1d:	0f b6 c0             	movzbl %al,%eax
    be20:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    be24:	8b 45 0c             	mov    0xc(%ebp),%eax
    be27:	8b 40 14             	mov    0x14(%eax),%eax
    be2a:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    be2e:	01 d2                	add    %edx,%edx
    be30:	01 d0                	add    %edx,%eax
    be32:	0f b7 00             	movzwl (%eax),%eax
    be35:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    be39:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    be3e:	77 16                	ja     be56 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    be40:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    be44:	50                   	push   %eax
    be45:	ff 75 08             	pushl  0x8(%ebp)
    be48:	e8 b2 eb ff ff       	call   a9ff <advanceBits>
    be4d:	83 c4 08             	add    $0x8,%esp
    return value;
    be50:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    be54:	eb 5c                	jmp    beb2 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    be56:	6a 09                	push   $0x9
    be58:	ff 75 08             	pushl  0x8(%ebp)
    be5b:	e8 9f eb ff ff       	call   a9ff <advanceBits>
    be60:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    be63:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    be67:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    be6b:	83 e8 09             	sub    $0x9,%eax
    be6e:	50                   	push   %eax
    be6f:	ff 75 08             	pushl  0x8(%ebp)
    be72:	e8 68 eb ff ff       	call   a9df <peekBits>
    be77:	83 c4 08             	add    $0x8,%esp
    be7a:	01 d8                	add    %ebx,%eax
    be7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    be7f:	8b 45 0c             	mov    0xc(%ebp),%eax
    be82:	8b 50 10             	mov    0x10(%eax),%edx
    be85:	8b 45 f0             	mov    -0x10(%ebp),%eax
    be88:	01 d0                	add    %edx,%eax
    be8a:	0f b6 00             	movzbl (%eax),%eax
    be8d:	0f b6 c0             	movzbl %al,%eax
    be90:	83 e8 09             	sub    $0x9,%eax
    be93:	50                   	push   %eax
    be94:	ff 75 08             	pushl  0x8(%ebp)
    be97:	e8 63 eb ff ff       	call   a9ff <advanceBits>
    be9c:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    be9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    bea2:	8b 40 14             	mov    0x14(%eax),%eax
    bea5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bea8:	01 d2                	add    %edx,%edx
    beaa:	01 d0                	add    %edx,%eax
    beac:	0f b7 00             	movzwl (%eax),%eax
    beaf:	0f b7 c0             	movzwl %ax,%eax
  }
}
    beb2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    beb5:	c9                   	leave  
    beb6:	c3                   	ret    

0000beb7 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    beb7:	55                   	push   %ebp
    beb8:	89 e5                	mov    %esp,%ebp
    beba:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    bebd:	83 ec 0c             	sub    $0xc,%esp
    bec0:	ff 75 08             	pushl  0x8(%ebp)
    bec3:	e8 aa fd ff ff       	call   bc72 <generateFixedLitLenTree>
    bec8:	83 c4 10             	add    $0x10,%esp
    becb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    bece:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    bed2:	74 05                	je     bed9 <getTreeInflateFixed+0x22>
    bed4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bed7:	eb 0e                	jmp    bee7 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    bed9:	83 ec 0c             	sub    $0xc,%esp
    bedc:	ff 75 0c             	pushl  0xc(%ebp)
    bedf:	e8 95 fe ff ff       	call   bd79 <generateFixedDistanceTree>
    bee4:	83 c4 10             	add    $0x10,%esp
}
    bee7:	c9                   	leave  
    bee8:	c3                   	ret    

0000bee9 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    bee9:	55                   	push   %ebp
    beea:	89 e5                	mov    %esp,%ebp
    beec:	53                   	push   %ebx
    beed:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    bef0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    bef7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    befe:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    bf05:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    bf0c:	6a 0e                	push   $0xe
    bf0e:	ff 75 10             	pushl  0x10(%ebp)
    bf11:	e8 37 e6 ff ff       	call   a54d <ensureBits17>
    bf16:	83 c4 08             	add    $0x8,%esp
    bf19:	85 c0                	test   %eax,%eax
    bf1b:	75 0a                	jne    bf27 <getTreeInflateDynamic+0x3e>
    bf1d:	b8 31 00 00 00       	mov    $0x31,%eax
    bf22:	e9 ec 04 00 00       	jmp    c413 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    bf27:	6a 05                	push   $0x5
    bf29:	ff 75 10             	pushl  0x10(%ebp)
    bf2c:	e8 f8 ea ff ff       	call   aa29 <readBits>
    bf31:	83 c4 08             	add    $0x8,%esp
    bf34:	05 01 01 00 00       	add    $0x101,%eax
    bf39:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    bf3c:	6a 05                	push   $0x5
    bf3e:	ff 75 10             	pushl  0x10(%ebp)
    bf41:	e8 e3 ea ff ff       	call   aa29 <readBits>
    bf46:	83 c4 08             	add    $0x8,%esp
    bf49:	83 c0 01             	add    $0x1,%eax
    bf4c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    bf4f:	6a 04                	push   $0x4
    bf51:	ff 75 10             	pushl  0x10(%ebp)
    bf54:	e8 d0 ea ff ff       	call   aa29 <readBits>
    bf59:	83 c4 08             	add    $0x8,%esp
    bf5c:	83 c0 04             	add    $0x4,%eax
    bf5f:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    bf62:	83 ec 0c             	sub    $0xc,%esp
    bf65:	6a 4c                	push   $0x4c
    bf67:	e8 31 dd ff ff       	call   9c9d <lodepng_malloc>
    bf6c:	83 c4 10             	add    $0x10,%esp
    bf6f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    bf72:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    bf76:	75 0a                	jne    bf82 <getTreeInflateDynamic+0x99>
    bf78:	b8 53 00 00 00       	mov    $0x53,%eax
    bf7d:	e9 91 04 00 00       	jmp    c413 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    bf82:	83 ec 0c             	sub    $0xc,%esp
    bf85:	8d 45 a8             	lea    -0x58(%ebp),%eax
    bf88:	50                   	push   %eax
    bf89:	e8 03 ec ff ff       	call   ab91 <HuffmanTree_init>
    bf8e:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    bf91:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    bf95:	0f 85 3c 04 00 00    	jne    c3d7 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    bf9b:	8b 45 10             	mov    0x10(%ebp),%eax
    bf9e:	8b 48 08             	mov    0x8(%eax),%ecx
    bfa1:	8b 55 d0             	mov    -0x30(%ebp),%edx
    bfa4:	89 d0                	mov    %edx,%eax
    bfa6:	01 c0                	add    %eax,%eax
    bfa8:	01 d0                	add    %edx,%eax
    bfaa:	89 c2                	mov    %eax,%edx
    bfac:	8b 45 10             	mov    0x10(%ebp),%eax
    bfaf:	8b 40 0c             	mov    0xc(%eax),%eax
    bfb2:	83 ec 04             	sub    $0x4,%esp
    bfb5:	51                   	push   %ecx
    bfb6:	52                   	push   %edx
    bfb7:	50                   	push   %eax
    bfb8:	e8 f7 dd ff ff       	call   9db4 <lodepng_gtofl>
    bfbd:	83 c4 10             	add    $0x10,%esp
    bfc0:	85 c0                	test   %eax,%eax
    bfc2:	74 0c                	je     bfd0 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    bfc4:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    bfcb:	e9 07 04 00 00       	jmp    c3d7 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    bfd0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    bfd7:	eb 3d                	jmp    c016 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    bfd9:	83 ec 08             	sub    $0x8,%esp
    bfdc:	6a 03                	push   $0x3
    bfde:	ff 75 10             	pushl  0x10(%ebp)
    bfe1:	e8 8b e4 ff ff       	call   a471 <ensureBits9>
    bfe6:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    bfe9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bfec:	8b 04 85 40 0a 02 00 	mov    0x20a40(,%eax,4),%eax
    bff3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bffa:	8b 45 dc             	mov    -0x24(%ebp),%eax
    bffd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    c000:	83 ec 08             	sub    $0x8,%esp
    c003:	6a 03                	push   $0x3
    c005:	ff 75 10             	pushl  0x10(%ebp)
    c008:	e8 1c ea ff ff       	call   aa29 <readBits>
    c00d:	83 c4 10             	add    $0x10,%esp
    c010:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    c012:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    c016:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c019:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c01c:	75 bb                	jne    bfd9 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    c01e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c021:	89 45 ec             	mov    %eax,-0x14(%ebp)
    c024:	eb 20                	jmp    c046 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    c026:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c029:	8b 04 85 40 0a 02 00 	mov    0x20a40(,%eax,4),%eax
    c030:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c037:	8b 45 dc             	mov    -0x24(%ebp),%eax
    c03a:	01 d0                	add    %edx,%eax
    c03c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    c042:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    c046:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    c04a:	75 da                	jne    c026 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    c04c:	6a 07                	push   $0x7
    c04e:	6a 13                	push   $0x13
    c050:	ff 75 dc             	pushl  -0x24(%ebp)
    c053:	8d 45 a8             	lea    -0x58(%ebp),%eax
    c056:	50                   	push   %eax
    c057:	e8 83 f2 ff ff       	call   b2df <HuffmanTree_makeFromLengths>
    c05c:	83 c4 10             	add    $0x10,%esp
    c05f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    c062:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    c066:	0f 85 64 03 00 00    	jne    c3d0 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    c06c:	83 ec 0c             	sub    $0xc,%esp
    c06f:	68 80 04 00 00       	push   $0x480
    c074:	e8 24 dc ff ff       	call   9c9d <lodepng_malloc>
    c079:	83 c4 10             	add    $0x10,%esp
    c07c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    c07f:	83 ec 0c             	sub    $0xc,%esp
    c082:	68 80 00 00 00       	push   $0x80
    c087:	e8 11 dc ff ff       	call   9c9d <lodepng_malloc>
    c08c:	83 c4 10             	add    $0x10,%esp
    c08f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    c092:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c096:	74 06                	je     c09e <getTreeInflateDynamic+0x1b5>
    c098:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c09c:	75 0c                	jne    c0aa <getTreeInflateDynamic+0x1c1>
    c09e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    c0a5:	e9 2d 03 00 00       	jmp    c3d7 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    c0aa:	83 ec 04             	sub    $0x4,%esp
    c0ad:	68 80 04 00 00       	push   $0x480
    c0b2:	6a 00                	push   $0x0
    c0b4:	ff 75 e8             	pushl  -0x18(%ebp)
    c0b7:	e8 52 dc ff ff       	call   9d0e <lodepng_memset>
    c0bc:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    c0bf:	83 ec 04             	sub    $0x4,%esp
    c0c2:	68 80 00 00 00       	push   $0x80
    c0c7:	6a 00                	push   $0x0
    c0c9:	ff 75 e4             	pushl  -0x1c(%ebp)
    c0cc:	e8 3d dc ff ff       	call   9d0e <lodepng_memset>
    c0d1:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    c0d4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    c0db:	e9 8d 02 00 00       	jmp    c36d <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    c0e0:	83 ec 08             	sub    $0x8,%esp
    c0e3:	6a 16                	push   $0x16
    c0e5:	ff 75 10             	pushl  0x10(%ebp)
    c0e8:	e8 8c e5 ff ff       	call   a679 <ensureBits25>
    c0ed:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    c0f0:	83 ec 08             	sub    $0x8,%esp
    c0f3:	8d 45 a8             	lea    -0x58(%ebp),%eax
    c0f6:	50                   	push   %eax
    c0f7:	ff 75 10             	pushl  0x10(%ebp)
    c0fa:	e8 f7 fc ff ff       	call   bdf6 <huffmanDecodeSymbol>
    c0ff:	83 c4 10             	add    $0x10,%esp
    c102:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    c105:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    c109:	77 3e                	ja     c149 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    c10b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c10e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c111:	73 16                	jae    c129 <getTreeInflateDynamic+0x240>
    c113:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c116:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c11d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c120:	01 c2                	add    %eax,%edx
    c122:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c125:	89 02                	mov    %eax,(%edx)
    c127:	eb 17                	jmp    c140 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    c129:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c12c:	2b 45 d8             	sub    -0x28(%ebp),%eax
    c12f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c136:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c139:	01 c2                	add    %eax,%edx
    c13b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c13e:	89 02                	mov    %eax,(%edx)
        ++i;
    c140:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    c144:	e9 0b 02 00 00       	jmp    c354 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    c149:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    c14d:	0f 85 da 00 00 00    	jne    c22d <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    c153:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    c15a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c15e:	75 0c                	jne    c16c <getTreeInflateDynamic+0x283>
    c160:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    c167:	e9 12 02 00 00       	jmp    c37e <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    c16c:	83 ec 08             	sub    $0x8,%esp
    c16f:	6a 02                	push   $0x2
    c171:	ff 75 10             	pushl  0x10(%ebp)
    c174:	e8 b0 e8 ff ff       	call   aa29 <readBits>
    c179:	83 c4 10             	add    $0x10,%esp
    c17c:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    c17f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    c182:	83 c0 01             	add    $0x1,%eax
    c185:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    c188:	76 1b                	jbe    c1a5 <getTreeInflateDynamic+0x2bc>
    c18a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c18d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    c192:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c199:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c19c:	01 d0                	add    %edx,%eax
    c19e:	8b 00                	mov    (%eax),%eax
    c1a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c1a3:	eb 1c                	jmp    c1c1 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    c1a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c1a8:	2b 45 d8             	sub    -0x28(%ebp),%eax
    c1ab:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    c1b0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c1b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c1ba:	01 d0                	add    %edx,%eax
    c1bc:	8b 00                	mov    (%eax),%eax
    c1be:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    c1c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c1c8:	eb 56                	jmp    c220 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    c1ca:	8b 55 d8             	mov    -0x28(%ebp),%edx
    c1cd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c1d0:	01 d0                	add    %edx,%eax
    c1d2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    c1d5:	77 0c                	ja     c1e3 <getTreeInflateDynamic+0x2fa>
    c1d7:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    c1de:	e9 71 01 00 00       	jmp    c354 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    c1e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c1e6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c1e9:	73 16                	jae    c201 <getTreeInflateDynamic+0x318>
    c1eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c1ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c1f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1f8:	01 c2                	add    %eax,%edx
    c1fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    c1fd:	89 02                	mov    %eax,(%edx)
    c1ff:	eb 17                	jmp    c218 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    c201:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c204:	2b 45 d8             	sub    -0x28(%ebp),%eax
    c207:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c20e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c211:	01 c2                	add    %eax,%edx
    c213:	8b 45 e0             	mov    -0x20(%ebp),%eax
    c216:	89 02                	mov    %eax,(%edx)
          ++i;
    c218:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    c21c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c220:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c223:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    c226:	72 a2                	jb     c1ca <getTreeInflateDynamic+0x2e1>
    c228:	e9 27 01 00 00       	jmp    c354 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    c22d:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    c231:	0f 85 88 00 00 00    	jne    c2bf <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    c237:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    c23e:	83 ec 08             	sub    $0x8,%esp
    c241:	6a 03                	push   $0x3
    c243:	ff 75 10             	pushl  0x10(%ebp)
    c246:	e8 de e7 ff ff       	call   aa29 <readBits>
    c24b:	83 c4 10             	add    $0x10,%esp
    c24e:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    c251:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c258:	eb 58                	jmp    c2b2 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    c25a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    c25d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c260:	01 d0                	add    %edx,%eax
    c262:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    c265:	77 0c                	ja     c273 <getTreeInflateDynamic+0x38a>
    c267:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    c26e:	e9 e1 00 00 00       	jmp    c354 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    c273:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c276:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c279:	73 17                	jae    c292 <getTreeInflateDynamic+0x3a9>
    c27b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c27e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c285:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c288:	01 d0                	add    %edx,%eax
    c28a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    c290:	eb 18                	jmp    c2aa <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    c292:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c295:	2b 45 d8             	sub    -0x28(%ebp),%eax
    c298:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c29f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c2a2:	01 d0                	add    %edx,%eax
    c2a4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    c2aa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    c2ae:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c2b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c2b5:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    c2b8:	72 a0                	jb     c25a <getTreeInflateDynamic+0x371>
    c2ba:	e9 95 00 00 00       	jmp    c354 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    c2bf:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    c2c3:	0f 85 82 00 00 00    	jne    c34b <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    c2c9:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    c2d0:	83 ec 08             	sub    $0x8,%esp
    c2d3:	6a 07                	push   $0x7
    c2d5:	ff 75 10             	pushl  0x10(%ebp)
    c2d8:	e8 4c e7 ff ff       	call   aa29 <readBits>
    c2dd:	83 c4 10             	add    $0x10,%esp
    c2e0:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    c2e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c2ea:	eb 55                	jmp    c341 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    c2ec:	8b 55 d8             	mov    -0x28(%ebp),%edx
    c2ef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c2f2:	01 d0                	add    %edx,%eax
    c2f4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    c2f7:	77 09                	ja     c302 <getTreeInflateDynamic+0x419>
    c2f9:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    c300:	eb 52                	jmp    c354 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    c302:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c305:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c308:	73 17                	jae    c321 <getTreeInflateDynamic+0x438>
    c30a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c30d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c314:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c317:	01 d0                	add    %edx,%eax
    c319:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    c31f:	eb 18                	jmp    c339 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    c321:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c324:	2b 45 d8             	sub    -0x28(%ebp),%eax
    c327:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    c32e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c331:	01 d0                	add    %edx,%eax
    c333:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    c339:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    c33d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c341:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c344:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c347:	72 a3                	jb     c2ec <getTreeInflateDynamic+0x403>
    c349:	eb 09                	jmp    c354 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    c34b:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    c352:	eb 2a                	jmp    c37e <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    c354:	8b 45 10             	mov    0x10(%ebp),%eax
    c357:	8b 50 0c             	mov    0xc(%eax),%edx
    c35a:	8b 45 10             	mov    0x10(%ebp),%eax
    c35d:	8b 40 08             	mov    0x8(%eax),%eax
    c360:	39 c2                	cmp    %eax,%edx
    c362:	7e 09                	jle    c36d <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    c364:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    c36b:	eb 11                	jmp    c37e <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    c36d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    c370:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c373:	01 d0                	add    %edx,%eax
    c375:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    c378:	0f 87 62 fd ff ff    	ja     c0e0 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    c37e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    c382:	75 4f                	jne    c3d3 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    c384:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c387:	05 00 04 00 00       	add    $0x400,%eax
    c38c:	8b 00                	mov    (%eax),%eax
    c38e:	85 c0                	test   %eax,%eax
    c390:	75 09                	jne    c39b <getTreeInflateDynamic+0x4b2>
    c392:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    c399:	eb 3c                	jmp    c3d7 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    c39b:	6a 0f                	push   $0xf
    c39d:	68 20 01 00 00       	push   $0x120
    c3a2:	ff 75 e8             	pushl  -0x18(%ebp)
    c3a5:	ff 75 08             	pushl  0x8(%ebp)
    c3a8:	e8 32 ef ff ff       	call   b2df <HuffmanTree_makeFromLengths>
    c3ad:	83 c4 10             	add    $0x10,%esp
    c3b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    c3b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    c3b7:	75 1d                	jne    c3d6 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    c3b9:	6a 0f                	push   $0xf
    c3bb:	6a 20                	push   $0x20
    c3bd:	ff 75 e4             	pushl  -0x1c(%ebp)
    c3c0:	ff 75 0c             	pushl  0xc(%ebp)
    c3c3:	e8 17 ef ff ff       	call   b2df <HuffmanTree_makeFromLengths>
    c3c8:	83 c4 10             	add    $0x10,%esp
    c3cb:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    c3ce:	eb 07                	jmp    c3d7 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    c3d0:	90                   	nop
    c3d1:	eb 04                	jmp    c3d7 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    c3d3:	90                   	nop
    c3d4:	eb 01                	jmp    c3d7 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    c3d6:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    c3d7:	83 ec 0c             	sub    $0xc,%esp
    c3da:	ff 75 dc             	pushl  -0x24(%ebp)
    c3dd:	e8 dc d8 ff ff       	call   9cbe <lodepng_free>
    c3e2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    c3e5:	83 ec 0c             	sub    $0xc,%esp
    c3e8:	ff 75 e8             	pushl  -0x18(%ebp)
    c3eb:	e8 ce d8 ff ff       	call   9cbe <lodepng_free>
    c3f0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    c3f3:	83 ec 0c             	sub    $0xc,%esp
    c3f6:	ff 75 e4             	pushl  -0x1c(%ebp)
    c3f9:	e8 c0 d8 ff ff       	call   9cbe <lodepng_free>
    c3fe:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    c401:	83 ec 0c             	sub    $0xc,%esp
    c404:	8d 45 a8             	lea    -0x58(%ebp),%eax
    c407:	50                   	push   %eax
    c408:	e8 b1 e7 ff ff       	call   abbe <HuffmanTree_cleanup>
    c40d:	83 c4 10             	add    $0x10,%esp

  return error;
    c410:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    c413:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    c416:	c9                   	leave  
    c417:	c3                   	ret    

0000c418 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    c418:	55                   	push   %ebp
    c419:	89 e5                	mov    %esp,%ebp
    c41b:	53                   	push   %ebx
    c41c:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    c41f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    c426:	8d 45 b8             	lea    -0x48(%ebp),%eax
    c429:	50                   	push   %eax
    c42a:	e8 62 e7 ff ff       	call   ab91 <HuffmanTree_init>
    c42f:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    c432:	8d 45 a0             	lea    -0x60(%ebp),%eax
    c435:	50                   	push   %eax
    c436:	e8 56 e7 ff ff       	call   ab91 <HuffmanTree_init>
    c43b:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    c43e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    c442:	75 1b                	jne    c45f <inflateHuffmanBlock+0x47>
    c444:	83 ec 08             	sub    $0x8,%esp
    c447:	8d 45 a0             	lea    -0x60(%ebp),%eax
    c44a:	50                   	push   %eax
    c44b:	8d 45 b8             	lea    -0x48(%ebp),%eax
    c44e:	50                   	push   %eax
    c44f:	e8 63 fa ff ff       	call   beb7 <getTreeInflateFixed>
    c454:	83 c4 10             	add    $0x10,%esp
    c457:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c45a:	e9 9a 02 00 00       	jmp    c6f9 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    c45f:	83 ec 04             	sub    $0x4,%esp
    c462:	ff 75 0c             	pushl  0xc(%ebp)
    c465:	8d 45 a0             	lea    -0x60(%ebp),%eax
    c468:	50                   	push   %eax
    c469:	8d 45 b8             	lea    -0x48(%ebp),%eax
    c46c:	50                   	push   %eax
    c46d:	e8 77 fa ff ff       	call   bee9 <getTreeInflateDynamic>
    c472:	83 c4 10             	add    $0x10,%esp
    c475:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    c478:	e9 7c 02 00 00       	jmp    c6f9 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    c47d:	83 ec 08             	sub    $0x8,%esp
    c480:	6a 14                	push   $0x14
    c482:	ff 75 0c             	pushl  0xc(%ebp)
    c485:	e8 ef e1 ff ff       	call   a679 <ensureBits25>
    c48a:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    c48d:	83 ec 08             	sub    $0x8,%esp
    c490:	8d 45 b8             	lea    -0x48(%ebp),%eax
    c493:	50                   	push   %eax
    c494:	ff 75 0c             	pushl  0xc(%ebp)
    c497:	e8 5a f9 ff ff       	call   bdf6 <huffmanDecodeSymbol>
    c49c:	83 c4 10             	add    $0x10,%esp
    c49f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    c4a2:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    c4a9:	77 42                	ja     c4ed <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    c4ab:	8b 45 08             	mov    0x8(%ebp),%eax
    c4ae:	8b 40 04             	mov    0x4(%eax),%eax
    c4b1:	83 c0 01             	add    $0x1,%eax
    c4b4:	83 ec 08             	sub    $0x8,%esp
    c4b7:	50                   	push   %eax
    c4b8:	ff 75 08             	pushl  0x8(%ebp)
    c4bb:	e8 37 da ff ff       	call   9ef7 <ucvector_resize>
    c4c0:	83 c4 10             	add    $0x10,%esp
    c4c3:	85 c0                	test   %eax,%eax
    c4c5:	75 0c                	jne    c4d3 <inflateHuffmanBlock+0xbb>
    c4c7:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    c4ce:	e9 33 02 00 00       	jmp    c706 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    c4d3:	8b 45 08             	mov    0x8(%ebp),%eax
    c4d6:	8b 10                	mov    (%eax),%edx
    c4d8:	8b 45 08             	mov    0x8(%ebp),%eax
    c4db:	8b 40 04             	mov    0x4(%eax),%eax
    c4de:	83 e8 01             	sub    $0x1,%eax
    c4e1:	01 d0                	add    %edx,%eax
    c4e3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    c4e6:	88 10                	mov    %dl,(%eax)
    c4e8:	e9 d9 01 00 00       	jmp    c6c6 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    c4ed:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    c4f4:	0f 86 ba 01 00 00    	jbe    c6b4 <inflateHuffmanBlock+0x29c>
    c4fa:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    c501:	0f 87 ad 01 00 00    	ja     c6b4 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    c507:	8b 45 dc             	mov    -0x24(%ebp),%eax
    c50a:	2d 01 01 00 00       	sub    $0x101,%eax
    c50f:	8b 04 85 40 08 02 00 	mov    0x20840(,%eax,4),%eax
    c516:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    c519:	8b 45 dc             	mov    -0x24(%ebp),%eax
    c51c:	2d 01 01 00 00       	sub    $0x101,%eax
    c521:	8b 04 85 c0 08 02 00 	mov    0x208c0(,%eax,4),%eax
    c528:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    c52b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    c52f:	74 1c                	je     c54d <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    c531:	8b 45 d8             	mov    -0x28(%ebp),%eax
    c534:	83 ec 08             	sub    $0x8,%esp
    c537:	50                   	push   %eax
    c538:	ff 75 0c             	pushl  0xc(%ebp)
    c53b:	e8 e9 e4 ff ff       	call   aa29 <readBits>
    c540:	83 c4 10             	add    $0x10,%esp
    c543:	89 c2                	mov    %eax,%edx
    c545:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c548:	01 d0                	add    %edx,%eax
    c54a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    c54d:	83 ec 08             	sub    $0x8,%esp
    c550:	6a 1c                	push   $0x1c
    c552:	ff 75 0c             	pushl  0xc(%ebp)
    c555:	e8 98 e2 ff ff       	call   a7f2 <ensureBits32>
    c55a:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    c55d:	83 ec 08             	sub    $0x8,%esp
    c560:	8d 45 a0             	lea    -0x60(%ebp),%eax
    c563:	50                   	push   %eax
    c564:	ff 75 0c             	pushl  0xc(%ebp)
    c567:	e8 8a f8 ff ff       	call   bdf6 <huffmanDecodeSymbol>
    c56c:	83 c4 10             	add    $0x10,%esp
    c56f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    c572:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    c576:	76 1e                	jbe    c596 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    c578:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    c57c:	77 0c                	ja     c58a <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    c57e:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    c585:	e9 7c 01 00 00       	jmp    c706 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    c58a:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    c591:	e9 70 01 00 00       	jmp    c706 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    c596:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c599:	8b 04 85 40 09 02 00 	mov    0x20940(,%eax,4),%eax
    c5a0:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    c5a3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c5a6:	8b 04 85 c0 09 02 00 	mov    0x209c0(,%eax,4),%eax
    c5ad:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    c5b0:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    c5b4:	74 15                	je     c5cb <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    c5b6:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c5b9:	83 ec 08             	sub    $0x8,%esp
    c5bc:	50                   	push   %eax
    c5bd:	ff 75 0c             	pushl  0xc(%ebp)
    c5c0:	e8 64 e4 ff ff       	call   aa29 <readBits>
    c5c5:	83 c4 10             	add    $0x10,%esp
    c5c8:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    c5cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ce:	8b 40 04             	mov    0x4(%eax),%eax
    c5d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    c5d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c5d7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    c5da:	76 0c                	jbe    c5e8 <inflateHuffmanBlock+0x1d0>
    c5dc:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    c5e3:	e9 1e 01 00 00       	jmp    c706 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    c5e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c5eb:	2b 45 f0             	sub    -0x10(%ebp),%eax
    c5ee:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    c5f1:	8b 45 08             	mov    0x8(%ebp),%eax
    c5f4:	8b 50 04             	mov    0x4(%eax),%edx
    c5f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c5fa:	01 d0                	add    %edx,%eax
    c5fc:	83 ec 08             	sub    $0x8,%esp
    c5ff:	50                   	push   %eax
    c600:	ff 75 08             	pushl  0x8(%ebp)
    c603:	e8 ef d8 ff ff       	call   9ef7 <ucvector_resize>
    c608:	83 c4 10             	add    $0x10,%esp
    c60b:	85 c0                	test   %eax,%eax
    c60d:	75 0c                	jne    c61b <inflateHuffmanBlock+0x203>
    c60f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    c616:	e9 eb 00 00 00       	jmp    c706 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    c61b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c61e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    c621:	73 6b                	jae    c68e <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    c623:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c626:	8b 55 08             	mov    0x8(%ebp),%edx
    c629:	8b 0a                	mov    (%edx),%ecx
    c62b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    c62e:	01 d1                	add    %edx,%ecx
    c630:	8b 55 08             	mov    0x8(%ebp),%edx
    c633:	8b 1a                	mov    (%edx),%ebx
    c635:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c638:	01 da                	add    %ebx,%edx
    c63a:	83 ec 04             	sub    $0x4,%esp
    c63d:	50                   	push   %eax
    c63e:	51                   	push   %ecx
    c63f:	52                   	push   %edx
    c640:	e8 96 d6 ff ff       	call   9cdb <lodepng_memcpy>
    c645:	83 c4 10             	add    $0x10,%esp
        start += distance;
    c648:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c64b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c64e:	01 d0                	add    %edx,%eax
    c650:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    c653:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c656:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c659:	eb 29                	jmp    c684 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    c65b:	8b 45 08             	mov    0x8(%ebp),%eax
    c65e:	8b 08                	mov    (%eax),%ecx
    c660:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c663:	8d 50 01             	lea    0x1(%eax),%edx
    c666:	89 55 ec             	mov    %edx,-0x14(%ebp)
    c669:	01 c1                	add    %eax,%ecx
    c66b:	8b 45 08             	mov    0x8(%ebp),%eax
    c66e:	8b 18                	mov    (%eax),%ebx
    c670:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c673:	8d 50 01             	lea    0x1(%eax),%edx
    c676:	89 55 e8             	mov    %edx,-0x18(%ebp)
    c679:	01 d8                	add    %ebx,%eax
    c67b:	0f b6 00             	movzbl (%eax),%eax
    c67e:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    c680:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    c684:	8b 45 e0             	mov    -0x20(%ebp),%eax
    c687:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    c68a:	7c cf                	jl     c65b <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    c68c:	eb 38                	jmp    c6c6 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    c68e:	8b 45 08             	mov    0x8(%ebp),%eax
    c691:	8b 10                	mov    (%eax),%edx
    c693:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c696:	01 c2                	add    %eax,%edx
    c698:	8b 45 08             	mov    0x8(%ebp),%eax
    c69b:	8b 08                	mov    (%eax),%ecx
    c69d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c6a0:	01 c8                	add    %ecx,%eax
    c6a2:	83 ec 04             	sub    $0x4,%esp
    c6a5:	ff 75 e4             	pushl  -0x1c(%ebp)
    c6a8:	52                   	push   %edx
    c6a9:	50                   	push   %eax
    c6aa:	e8 2c d6 ff ff       	call   9cdb <lodepng_memcpy>
    c6af:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    c6b2:	eb 12                	jmp    c6c6 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    c6b4:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    c6bb:	74 48                	je     c705 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    c6bd:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    c6c4:	eb 40                	jmp    c706 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    c6c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    c6c9:	8b 50 0c             	mov    0xc(%eax),%edx
    c6cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    c6cf:	8b 40 08             	mov    0x8(%eax),%eax
    c6d2:	39 c2                	cmp    %eax,%edx
    c6d4:	7e 09                	jle    c6df <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    c6d6:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    c6dd:	eb 27                	jmp    c706 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    c6df:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    c6e3:	74 14                	je     c6f9 <inflateHuffmanBlock+0x2e1>
    c6e5:	8b 45 08             	mov    0x8(%ebp),%eax
    c6e8:	8b 40 04             	mov    0x4(%eax),%eax
    c6eb:	3b 45 14             	cmp    0x14(%ebp),%eax
    c6ee:	7e 09                	jle    c6f9 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    c6f0:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    c6f7:	eb 0d                	jmp    c706 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    c6f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    c6fd:	0f 84 7a fd ff ff    	je     c47d <inflateHuffmanBlock+0x65>
    c703:	eb 01                	jmp    c706 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    c705:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    c706:	83 ec 0c             	sub    $0xc,%esp
    c709:	8d 45 b8             	lea    -0x48(%ebp),%eax
    c70c:	50                   	push   %eax
    c70d:	e8 ac e4 ff ff       	call   abbe <HuffmanTree_cleanup>
    c712:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    c715:	83 ec 0c             	sub    $0xc,%esp
    c718:	8d 45 a0             	lea    -0x60(%ebp),%eax
    c71b:	50                   	push   %eax
    c71c:	e8 9d e4 ff ff       	call   abbe <HuffmanTree_cleanup>
    c721:	83 c4 10             	add    $0x10,%esp

  return error;
    c724:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    c727:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    c72a:	c9                   	leave  
    c72b:	c3                   	ret    

0000c72c <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    c72c:	55                   	push   %ebp
    c72d:	89 e5                	mov    %esp,%ebp
    c72f:	53                   	push   %ebx
    c730:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    c733:	8b 45 0c             	mov    0xc(%ebp),%eax
    c736:	8b 40 04             	mov    0x4(%eax),%eax
    c739:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    c73c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    c743:	8b 45 0c             	mov    0xc(%ebp),%eax
    c746:	8b 40 0c             	mov    0xc(%eax),%eax
    c749:	83 c0 07             	add    $0x7,%eax
    c74c:	c1 e8 03             	shr    $0x3,%eax
    c74f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    c752:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c755:	83 c0 04             	add    $0x4,%eax
    c758:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    c75b:	7c 0a                	jl     c767 <inflateNoCompression+0x3b>
    c75d:	b8 34 00 00 00       	mov    $0x34,%eax
    c762:	e9 01 01 00 00       	jmp    c868 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    c767:	8b 45 0c             	mov    0xc(%ebp),%eax
    c76a:	8b 10                	mov    (%eax),%edx
    c76c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c76f:	01 d0                	add    %edx,%eax
    c771:	0f b6 00             	movzbl (%eax),%eax
    c774:	0f b6 d0             	movzbl %al,%edx
    c777:	8b 45 0c             	mov    0xc(%ebp),%eax
    c77a:	8b 00                	mov    (%eax),%eax
    c77c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    c77f:	83 c1 01             	add    $0x1,%ecx
    c782:	01 c8                	add    %ecx,%eax
    c784:	0f b6 00             	movzbl (%eax),%eax
    c787:	0f b6 c0             	movzbl %al,%eax
    c78a:	c1 e0 08             	shl    $0x8,%eax
    c78d:	01 d0                	add    %edx,%eax
    c78f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    c792:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    c796:	8b 45 0c             	mov    0xc(%ebp),%eax
    c799:	8b 10                	mov    (%eax),%edx
    c79b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c79e:	01 d0                	add    %edx,%eax
    c7a0:	0f b6 00             	movzbl (%eax),%eax
    c7a3:	0f b6 d0             	movzbl %al,%edx
    c7a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    c7a9:	8b 00                	mov    (%eax),%eax
    c7ab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    c7ae:	83 c1 01             	add    $0x1,%ecx
    c7b1:	01 c8                	add    %ecx,%eax
    c7b3:	0f b6 00             	movzbl (%eax),%eax
    c7b6:	0f b6 c0             	movzbl %al,%eax
    c7b9:	c1 e0 08             	shl    $0x8,%eax
    c7bc:	01 d0                	add    %edx,%eax
    c7be:	89 45 e8             	mov    %eax,-0x18(%ebp)
    c7c1:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    c7c5:	8b 45 10             	mov    0x10(%ebp),%eax
    c7c8:	8b 40 04             	mov    0x4(%eax),%eax
    c7cb:	85 c0                	test   %eax,%eax
    c7cd:	75 19                	jne    c7e8 <inflateNoCompression+0xbc>
    c7cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c7d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c7d5:	01 d0                	add    %edx,%eax
    c7d7:	3d ff ff 00 00       	cmp    $0xffff,%eax
    c7dc:	74 0a                	je     c7e8 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    c7de:	b8 15 00 00 00       	mov    $0x15,%eax
    c7e3:	e9 80 00 00 00       	jmp    c868 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    c7e8:	8b 45 08             	mov    0x8(%ebp),%eax
    c7eb:	8b 40 04             	mov    0x4(%eax),%eax
    c7ee:	89 c2                	mov    %eax,%edx
    c7f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c7f3:	01 d0                	add    %edx,%eax
    c7f5:	50                   	push   %eax
    c7f6:	ff 75 08             	pushl  0x8(%ebp)
    c7f9:	e8 f9 d6 ff ff       	call   9ef7 <ucvector_resize>
    c7fe:	83 c4 08             	add    $0x8,%esp
    c801:	85 c0                	test   %eax,%eax
    c803:	75 07                	jne    c80c <inflateNoCompression+0xe0>
    c805:	b8 53 00 00 00       	mov    $0x53,%eax
    c80a:	eb 5c                	jmp    c868 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    c80c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c80f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c812:	01 c2                	add    %eax,%edx
    c814:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c817:	39 c2                	cmp    %eax,%edx
    c819:	76 07                	jbe    c822 <inflateNoCompression+0xf6>
    c81b:	b8 17 00 00 00       	mov    $0x17,%eax
    c820:	eb 46                	jmp    c868 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    c822:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c825:	8b 55 0c             	mov    0xc(%ebp),%edx
    c828:	8b 0a                	mov    (%edx),%ecx
    c82a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c82d:	01 d1                	add    %edx,%ecx
    c82f:	8b 55 08             	mov    0x8(%ebp),%edx
    c832:	8b 1a                	mov    (%edx),%ebx
    c834:	8b 55 08             	mov    0x8(%ebp),%edx
    c837:	8b 52 04             	mov    0x4(%edx),%edx
    c83a:	2b 55 ec             	sub    -0x14(%ebp),%edx
    c83d:	01 da                	add    %ebx,%edx
    c83f:	50                   	push   %eax
    c840:	51                   	push   %ecx
    c841:	52                   	push   %edx
    c842:	e8 94 d4 ff ff       	call   9cdb <lodepng_memcpy>
    c847:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    c84a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c84d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c850:	01 d0                	add    %edx,%eax
    c852:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    c855:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c858:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    c85f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c862:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    c865:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    c868:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    c86b:	c9                   	leave  
    c86c:	c3                   	ret    

0000c86d <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    c86d:	55                   	push   %ebp
    c86e:	89 e5                	mov    %esp,%ebp
    c870:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    c873:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    c87a:	ff 75 10             	pushl  0x10(%ebp)
    c87d:	ff 75 0c             	pushl  0xc(%ebp)
    c880:	8d 45 d8             	lea    -0x28(%ebp),%eax
    c883:	50                   	push   %eax
    c884:	e8 77 db ff ff       	call   a400 <LodePNGBitReader_init>
    c889:	83 c4 0c             	add    $0xc,%esp
    c88c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    c88f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c893:	0f 84 b9 00 00 00    	je     c952 <lodepng_inflatev+0xe5>
    c899:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c89c:	e9 c1 00 00 00       	jmp    c962 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    c8a1:	6a 03                	push   $0x3
    c8a3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    c8a6:	50                   	push   %eax
    c8a7:	e8 c5 db ff ff       	call   a471 <ensureBits9>
    c8ac:	83 c4 08             	add    $0x8,%esp
    c8af:	85 c0                	test   %eax,%eax
    c8b1:	75 0a                	jne    c8bd <lodepng_inflatev+0x50>
    c8b3:	b8 34 00 00 00       	mov    $0x34,%eax
    c8b8:	e9 a5 00 00 00       	jmp    c962 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    c8bd:	6a 01                	push   $0x1
    c8bf:	8d 45 d8             	lea    -0x28(%ebp),%eax
    c8c2:	50                   	push   %eax
    c8c3:	e8 61 e1 ff ff       	call   aa29 <readBits>
    c8c8:	83 c4 08             	add    $0x8,%esp
    c8cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    c8ce:	6a 02                	push   $0x2
    c8d0:	8d 45 d8             	lea    -0x28(%ebp),%eax
    c8d3:	50                   	push   %eax
    c8d4:	e8 50 e1 ff ff       	call   aa29 <readBits>
    c8d9:	83 c4 08             	add    $0x8,%esp
    c8dc:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    c8df:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    c8e3:	75 07                	jne    c8ec <lodepng_inflatev+0x7f>
    c8e5:	b8 14 00 00 00       	mov    $0x14,%eax
    c8ea:	eb 76                	jmp    c962 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    c8ec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c8f0:	75 17                	jne    c909 <lodepng_inflatev+0x9c>
    c8f2:	ff 75 14             	pushl  0x14(%ebp)
    c8f5:	8d 45 d8             	lea    -0x28(%ebp),%eax
    c8f8:	50                   	push   %eax
    c8f9:	ff 75 08             	pushl  0x8(%ebp)
    c8fc:	e8 2b fe ff ff       	call   c72c <inflateNoCompression>
    c901:	83 c4 0c             	add    $0xc,%esp
    c904:	89 45 f0             	mov    %eax,-0x10(%ebp)
    c907:	eb 1c                	jmp    c925 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    c909:	8b 45 14             	mov    0x14(%ebp),%eax
    c90c:	8b 40 08             	mov    0x8(%eax),%eax
    c90f:	50                   	push   %eax
    c910:	ff 75 ec             	pushl  -0x14(%ebp)
    c913:	8d 45 d8             	lea    -0x28(%ebp),%eax
    c916:	50                   	push   %eax
    c917:	ff 75 08             	pushl  0x8(%ebp)
    c91a:	e8 f9 fa ff ff       	call   c418 <inflateHuffmanBlock>
    c91f:	83 c4 10             	add    $0x10,%esp
    c922:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    c925:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c929:	75 21                	jne    c94c <lodepng_inflatev+0xdf>
    c92b:	8b 45 14             	mov    0x14(%ebp),%eax
    c92e:	8b 40 08             	mov    0x8(%eax),%eax
    c931:	85 c0                	test   %eax,%eax
    c933:	74 17                	je     c94c <lodepng_inflatev+0xdf>
    c935:	8b 45 08             	mov    0x8(%ebp),%eax
    c938:	8b 50 04             	mov    0x4(%eax),%edx
    c93b:	8b 45 14             	mov    0x14(%ebp),%eax
    c93e:	8b 40 08             	mov    0x8(%eax),%eax
    c941:	39 c2                	cmp    %eax,%edx
    c943:	7e 07                	jle    c94c <lodepng_inflatev+0xdf>
    c945:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    c94c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c950:	75 0c                	jne    c95e <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    c952:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    c956:	0f 84 45 ff ff ff    	je     c8a1 <lodepng_inflatev+0x34>
    c95c:	eb 01                	jmp    c95f <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    c95e:	90                   	nop
  }

  return error;
    c95f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    c962:	c9                   	leave  
    c963:	c3                   	ret    

0000c964 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    c964:	55                   	push   %ebp
    c965:	89 e5                	mov    %esp,%ebp
    c967:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    c96a:	8b 45 0c             	mov    0xc(%ebp),%eax
    c96d:	8b 08                	mov    (%eax),%ecx
    c96f:	8b 45 08             	mov    0x8(%ebp),%eax
    c972:	8b 10                	mov    (%eax),%edx
    c974:	8d 45 e8             	lea    -0x18(%ebp),%eax
    c977:	51                   	push   %ecx
    c978:	52                   	push   %edx
    c979:	50                   	push   %eax
    c97a:	e8 df d5 ff ff       	call   9f5e <ucvector_init>
    c97f:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    c982:	ff 75 18             	pushl  0x18(%ebp)
    c985:	ff 75 14             	pushl  0x14(%ebp)
    c988:	ff 75 10             	pushl  0x10(%ebp)
    c98b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    c98e:	50                   	push   %eax
    c98f:	e8 d9 fe ff ff       	call   c86d <lodepng_inflatev>
    c994:	83 c4 10             	add    $0x10,%esp
    c997:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    c99a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    c99d:	8b 45 08             	mov    0x8(%ebp),%eax
    c9a0:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    c9a2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c9a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    c9a8:	89 10                	mov    %edx,(%eax)
  return error;
    c9aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    c9ad:	c9                   	leave  
    c9ae:	c3                   	ret    

0000c9af <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    c9af:	55                   	push   %ebp
    c9b0:	89 e5                	mov    %esp,%ebp
    c9b2:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    c9b5:	8b 45 14             	mov    0x14(%ebp),%eax
    c9b8:	8b 40 10             	mov    0x10(%eax),%eax
    c9bb:	85 c0                	test   %eax,%eax
    c9bd:	74 64                	je     ca23 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    c9bf:	8b 45 14             	mov    0x14(%ebp),%eax
    c9c2:	8b 40 10             	mov    0x10(%eax),%eax
    c9c5:	8b 55 08             	mov    0x8(%ebp),%edx
    c9c8:	8d 4a 04             	lea    0x4(%edx),%ecx
    c9cb:	8b 55 08             	mov    0x8(%ebp),%edx
    c9ce:	83 ec 0c             	sub    $0xc,%esp
    c9d1:	ff 75 14             	pushl  0x14(%ebp)
    c9d4:	ff 75 10             	pushl  0x10(%ebp)
    c9d7:	ff 75 0c             	pushl  0xc(%ebp)
    c9da:	51                   	push   %ecx
    c9db:	52                   	push   %edx
    c9dc:	ff d0                	call   *%eax
    c9de:	83 c4 20             	add    $0x20,%esp
    c9e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    c9e4:	8b 45 08             	mov    0x8(%ebp),%eax
    c9e7:	8b 50 04             	mov    0x4(%eax),%edx
    c9ea:	8b 45 08             	mov    0x8(%ebp),%eax
    c9ed:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    c9f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    c9f4:	74 28                	je     ca1e <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    c9f6:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    c9fd:	8b 45 14             	mov    0x14(%ebp),%eax
    ca00:	8b 40 08             	mov    0x8(%eax),%eax
    ca03:	85 c0                	test   %eax,%eax
    ca05:	74 17                	je     ca1e <inflatev+0x6f>
    ca07:	8b 45 08             	mov    0x8(%ebp),%eax
    ca0a:	8b 50 04             	mov    0x4(%eax),%edx
    ca0d:	8b 45 14             	mov    0x14(%ebp),%eax
    ca10:	8b 40 08             	mov    0x8(%eax),%eax
    ca13:	39 c2                	cmp    %eax,%edx
    ca15:	7e 07                	jle    ca1e <inflatev+0x6f>
    ca17:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    ca1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ca21:	eb 14                	jmp    ca37 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    ca23:	ff 75 14             	pushl  0x14(%ebp)
    ca26:	ff 75 10             	pushl  0x10(%ebp)
    ca29:	ff 75 0c             	pushl  0xc(%ebp)
    ca2c:	ff 75 08             	pushl  0x8(%ebp)
    ca2f:	e8 39 fe ff ff       	call   c86d <lodepng_inflatev>
    ca34:	83 c4 10             	add    $0x10,%esp
  }
}
    ca37:	c9                   	leave  
    ca38:	c3                   	ret    

0000ca39 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    ca39:	55                   	push   %ebp
    ca3a:	89 e5                	mov    %esp,%ebp
    ca3c:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    ca3f:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    ca46:	8b 45 0c             	mov    0xc(%ebp),%eax
    ca49:	83 e8 01             	sub    $0x1,%eax
    ca4c:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    ca4f:	eb 39                	jmp    ca8a <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    ca51:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ca54:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ca57:	01 d0                	add    %edx,%eax
    ca59:	d1 f8                	sar    %eax
    ca5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    ca5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ca61:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ca68:	8b 45 08             	mov    0x8(%ebp),%eax
    ca6b:	01 d0                	add    %edx,%eax
    ca6d:	8b 10                	mov    (%eax),%edx
    ca6f:	8b 45 10             	mov    0x10(%ebp),%eax
    ca72:	39 c2                	cmp    %eax,%edx
    ca74:	72 0b                	jb     ca81 <searchCodeIndex+0x48>
    ca76:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ca79:	83 e8 01             	sub    $0x1,%eax
    ca7c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    ca7f:	eb 09                	jmp    ca8a <searchCodeIndex+0x51>
    else left = mid + 1;
    ca81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ca84:	83 c0 01             	add    $0x1,%eax
    ca87:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    ca8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ca8d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    ca90:	7e bf                	jle    ca51 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    ca92:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ca95:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ca98:	7d 18                	jge    cab2 <searchCodeIndex+0x79>
    ca9a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ca9d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    caa4:	8b 45 08             	mov    0x8(%ebp),%eax
    caa7:	01 d0                	add    %edx,%eax
    caa9:	8b 10                	mov    (%eax),%edx
    caab:	8b 45 10             	mov    0x10(%ebp),%eax
    caae:	39 c2                	cmp    %eax,%edx
    cab0:	76 04                	jbe    cab6 <searchCodeIndex+0x7d>
    cab2:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    cab6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    cab9:	c9                   	leave  
    caba:	c3                   	ret    

0000cabb <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    cabb:	55                   	push   %ebp
    cabc:	89 e5                	mov    %esp,%ebp
    cabe:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    cac1:	ff 75 0c             	pushl  0xc(%ebp)
    cac4:	6a 1d                	push   $0x1d
    cac6:	68 40 08 02 00       	push   $0x20840
    cacb:	e8 69 ff ff ff       	call   ca39 <searchCodeIndex>
    cad0:	83 c4 0c             	add    $0xc,%esp
    cad3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    cad6:	8b 55 0c             	mov    0xc(%ebp),%edx
    cad9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    cadc:	8b 04 85 40 08 02 00 	mov    0x20840(,%eax,4),%eax
    cae3:	29 c2                	sub    %eax,%edx
    cae5:	89 d0                	mov    %edx,%eax
    cae7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    caea:	ff 75 10             	pushl  0x10(%ebp)
    caed:	6a 1e                	push   $0x1e
    caef:	68 40 09 02 00       	push   $0x20940
    caf4:	e8 40 ff ff ff       	call   ca39 <searchCodeIndex>
    caf9:	83 c4 0c             	add    $0xc,%esp
    cafc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    caff:	8b 55 10             	mov    0x10(%ebp),%edx
    cb02:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb05:	8b 04 85 40 09 02 00 	mov    0x20940(,%eax,4),%eax
    cb0c:	29 c2                	sub    %eax,%edx
    cb0e:	89 d0                	mov    %edx,%eax
    cb10:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    cb13:	8b 45 08             	mov    0x8(%ebp),%eax
    cb16:	8b 40 04             	mov    0x4(%eax),%eax
    cb19:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    cb1c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb1f:	8b 40 04             	mov    0x4(%eax),%eax
    cb22:	83 c0 04             	add    $0x4,%eax
    cb25:	50                   	push   %eax
    cb26:	ff 75 08             	pushl  0x8(%ebp)
    cb29:	e8 f0 d2 ff ff       	call   9e1e <uivector_resize>
    cb2e:	83 c4 08             	add    $0x8,%esp
    cb31:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    cb34:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cb38:	74 57                	je     cb91 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    cb3a:	8b 45 08             	mov    0x8(%ebp),%eax
    cb3d:	8b 00                	mov    (%eax),%eax
    cb3f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    cb42:	c1 e2 02             	shl    $0x2,%edx
    cb45:	01 d0                	add    %edx,%eax
    cb47:	8b 55 fc             	mov    -0x4(%ebp),%edx
    cb4a:	81 c2 01 01 00 00    	add    $0x101,%edx
    cb50:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    cb52:	8b 45 08             	mov    0x8(%ebp),%eax
    cb55:	8b 00                	mov    (%eax),%eax
    cb57:	8b 55 ec             	mov    -0x14(%ebp),%edx
    cb5a:	83 c2 01             	add    $0x1,%edx
    cb5d:	c1 e2 02             	shl    $0x2,%edx
    cb60:	01 c2                	add    %eax,%edx
    cb62:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cb65:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    cb67:	8b 45 08             	mov    0x8(%ebp),%eax
    cb6a:	8b 00                	mov    (%eax),%eax
    cb6c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    cb6f:	83 c2 02             	add    $0x2,%edx
    cb72:	c1 e2 02             	shl    $0x2,%edx
    cb75:	01 c2                	add    %eax,%edx
    cb77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb7a:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    cb7c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb7f:	8b 00                	mov    (%eax),%eax
    cb81:	8b 55 ec             	mov    -0x14(%ebp),%edx
    cb84:	83 c2 03             	add    $0x3,%edx
    cb87:	c1 e2 02             	shl    $0x2,%edx
    cb8a:	01 c2                	add    %eax,%edx
    cb8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cb8f:	89 02                	mov    %eax,(%edx)
  }
}
    cb91:	90                   	nop
    cb92:	c9                   	leave  
    cb93:	c3                   	ret    

0000cb94 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    cb94:	55                   	push   %ebp
    cb95:	89 e5                	mov    %esp,%ebp
    cb97:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    cb9a:	b8 00 00 01 00       	mov    $0x10000,%eax
    cb9f:	c1 e0 02             	shl    $0x2,%eax
    cba2:	83 ec 0c             	sub    $0xc,%esp
    cba5:	50                   	push   %eax
    cba6:	e8 f2 d0 ff ff       	call   9c9d <lodepng_malloc>
    cbab:	83 c4 10             	add    $0x10,%esp
    cbae:	89 c2                	mov    %eax,%edx
    cbb0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb3:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    cbb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    cbb8:	c1 e0 02             	shl    $0x2,%eax
    cbbb:	83 ec 0c             	sub    $0xc,%esp
    cbbe:	50                   	push   %eax
    cbbf:	e8 d9 d0 ff ff       	call   9c9d <lodepng_malloc>
    cbc4:	83 c4 10             	add    $0x10,%esp
    cbc7:	89 c2                	mov    %eax,%edx
    cbc9:	8b 45 08             	mov    0x8(%ebp),%eax
    cbcc:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    cbcf:	8b 45 0c             	mov    0xc(%ebp),%eax
    cbd2:	01 c0                	add    %eax,%eax
    cbd4:	83 ec 0c             	sub    $0xc,%esp
    cbd7:	50                   	push   %eax
    cbd8:	e8 c0 d0 ff ff       	call   9c9d <lodepng_malloc>
    cbdd:	83 c4 10             	add    $0x10,%esp
    cbe0:	89 c2                	mov    %eax,%edx
    cbe2:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe5:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    cbe8:	8b 45 0c             	mov    0xc(%ebp),%eax
    cbeb:	01 c0                	add    %eax,%eax
    cbed:	83 ec 0c             	sub    $0xc,%esp
    cbf0:	50                   	push   %eax
    cbf1:	e8 a7 d0 ff ff       	call   9c9d <lodepng_malloc>
    cbf6:	83 c4 10             	add    $0x10,%esp
    cbf9:	89 c2                	mov    %eax,%edx
    cbfb:	8b 45 08             	mov    0x8(%ebp),%eax
    cbfe:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    cc01:	b8 02 01 00 00       	mov    $0x102,%eax
    cc06:	83 c0 01             	add    $0x1,%eax
    cc09:	c1 e0 02             	shl    $0x2,%eax
    cc0c:	83 ec 0c             	sub    $0xc,%esp
    cc0f:	50                   	push   %eax
    cc10:	e8 88 d0 ff ff       	call   9c9d <lodepng_malloc>
    cc15:	83 c4 10             	add    $0x10,%esp
    cc18:	89 c2                	mov    %eax,%edx
    cc1a:	8b 45 08             	mov    0x8(%ebp),%eax
    cc1d:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    cc20:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc23:	01 c0                	add    %eax,%eax
    cc25:	83 ec 0c             	sub    $0xc,%esp
    cc28:	50                   	push   %eax
    cc29:	e8 6f d0 ff ff       	call   9c9d <lodepng_malloc>
    cc2e:	83 c4 10             	add    $0x10,%esp
    cc31:	89 c2                	mov    %eax,%edx
    cc33:	8b 45 08             	mov    0x8(%ebp),%eax
    cc36:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    cc39:	8b 45 08             	mov    0x8(%ebp),%eax
    cc3c:	8b 00                	mov    (%eax),%eax
    cc3e:	85 c0                	test   %eax,%eax
    cc40:	74 32                	je     cc74 <hash_init+0xe0>
    cc42:	8b 45 08             	mov    0x8(%ebp),%eax
    cc45:	8b 40 04             	mov    0x4(%eax),%eax
    cc48:	85 c0                	test   %eax,%eax
    cc4a:	74 28                	je     cc74 <hash_init+0xe0>
    cc4c:	8b 45 08             	mov    0x8(%ebp),%eax
    cc4f:	8b 40 08             	mov    0x8(%eax),%eax
    cc52:	85 c0                	test   %eax,%eax
    cc54:	74 1e                	je     cc74 <hash_init+0xe0>
    cc56:	8b 45 08             	mov    0x8(%ebp),%eax
    cc59:	8b 40 0c             	mov    0xc(%eax),%eax
    cc5c:	85 c0                	test   %eax,%eax
    cc5e:	74 14                	je     cc74 <hash_init+0xe0>
    cc60:	8b 45 08             	mov    0x8(%ebp),%eax
    cc63:	8b 40 10             	mov    0x10(%eax),%eax
    cc66:	85 c0                	test   %eax,%eax
    cc68:	74 0a                	je     cc74 <hash_init+0xe0>
    cc6a:	8b 45 08             	mov    0x8(%ebp),%eax
    cc6d:	8b 40 14             	mov    0x14(%eax),%eax
    cc70:	85 c0                	test   %eax,%eax
    cc72:	75 0a                	jne    cc7e <hash_init+0xea>
    return 83; /*alloc fail*/
    cc74:	b8 53 00 00 00       	mov    $0x53,%eax
    cc79:	e9 d3 00 00 00       	jmp    cd51 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    cc7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cc85:	eb 17                	jmp    cc9e <hash_init+0x10a>
    cc87:	8b 45 08             	mov    0x8(%ebp),%eax
    cc8a:	8b 00                	mov    (%eax),%eax
    cc8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cc8f:	c1 e2 02             	shl    $0x2,%edx
    cc92:	01 d0                	add    %edx,%eax
    cc94:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    cc9a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cc9e:	b8 00 00 01 00       	mov    $0x10000,%eax
    cca3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    cca6:	75 df                	jne    cc87 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    cca8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ccaf:	eb 18                	jmp    ccc9 <hash_init+0x135>
    ccb1:	8b 45 08             	mov    0x8(%ebp),%eax
    ccb4:	8b 40 08             	mov    0x8(%eax),%eax
    ccb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ccba:	c1 e2 02             	shl    $0x2,%edx
    ccbd:	01 d0                	add    %edx,%eax
    ccbf:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    ccc5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ccc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cccc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cccf:	75 e0                	jne    ccb1 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    ccd1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ccd8:	eb 17                	jmp    ccf1 <hash_init+0x15d>
    ccda:	8b 45 08             	mov    0x8(%ebp),%eax
    ccdd:	8b 40 04             	mov    0x4(%eax),%eax
    cce0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cce3:	01 d2                	add    %edx,%edx
    cce5:	01 d0                	add    %edx,%eax
    cce7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ccea:	66 89 10             	mov    %dx,(%eax)
    cced:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ccf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ccf4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ccf7:	75 e1                	jne    ccda <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    ccf9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cd00:	eb 18                	jmp    cd1a <hash_init+0x186>
    cd02:	8b 45 08             	mov    0x8(%ebp),%eax
    cd05:	8b 40 0c             	mov    0xc(%eax),%eax
    cd08:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cd0b:	c1 e2 02             	shl    $0x2,%edx
    cd0e:	01 d0                	add    %edx,%eax
    cd10:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    cd16:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cd1a:	b8 02 01 00 00       	mov    $0x102,%eax
    cd1f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    cd22:	76 de                	jbe    cd02 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    cd24:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cd2b:	eb 17                	jmp    cd44 <hash_init+0x1b0>
    cd2d:	8b 45 08             	mov    0x8(%ebp),%eax
    cd30:	8b 40 10             	mov    0x10(%eax),%eax
    cd33:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cd36:	01 d2                	add    %edx,%edx
    cd38:	01 d0                	add    %edx,%eax
    cd3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cd3d:	66 89 10             	mov    %dx,(%eax)
    cd40:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cd44:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cd47:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cd4a:	75 e1                	jne    cd2d <hash_init+0x199>

  return 0;
    cd4c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    cd51:	c9                   	leave  
    cd52:	c3                   	ret    

0000cd53 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    cd53:	55                   	push   %ebp
    cd54:	89 e5                	mov    %esp,%ebp
    cd56:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    cd59:	8b 45 08             	mov    0x8(%ebp),%eax
    cd5c:	8b 00                	mov    (%eax),%eax
    cd5e:	83 ec 0c             	sub    $0xc,%esp
    cd61:	50                   	push   %eax
    cd62:	e8 57 cf ff ff       	call   9cbe <lodepng_free>
    cd67:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    cd6a:	8b 45 08             	mov    0x8(%ebp),%eax
    cd6d:	8b 40 08             	mov    0x8(%eax),%eax
    cd70:	83 ec 0c             	sub    $0xc,%esp
    cd73:	50                   	push   %eax
    cd74:	e8 45 cf ff ff       	call   9cbe <lodepng_free>
    cd79:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    cd7c:	8b 45 08             	mov    0x8(%ebp),%eax
    cd7f:	8b 40 04             	mov    0x4(%eax),%eax
    cd82:	83 ec 0c             	sub    $0xc,%esp
    cd85:	50                   	push   %eax
    cd86:	e8 33 cf ff ff       	call   9cbe <lodepng_free>
    cd8b:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    cd8e:	8b 45 08             	mov    0x8(%ebp),%eax
    cd91:	8b 40 14             	mov    0x14(%eax),%eax
    cd94:	83 ec 0c             	sub    $0xc,%esp
    cd97:	50                   	push   %eax
    cd98:	e8 21 cf ff ff       	call   9cbe <lodepng_free>
    cd9d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    cda0:	8b 45 08             	mov    0x8(%ebp),%eax
    cda3:	8b 40 0c             	mov    0xc(%eax),%eax
    cda6:	83 ec 0c             	sub    $0xc,%esp
    cda9:	50                   	push   %eax
    cdaa:	e8 0f cf ff ff       	call   9cbe <lodepng_free>
    cdaf:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    cdb2:	8b 45 08             	mov    0x8(%ebp),%eax
    cdb5:	8b 40 10             	mov    0x10(%eax),%eax
    cdb8:	83 ec 0c             	sub    $0xc,%esp
    cdbb:	50                   	push   %eax
    cdbc:	e8 fd ce ff ff       	call   9cbe <lodepng_free>
    cdc1:	83 c4 10             	add    $0x10,%esp
}
    cdc4:	90                   	nop
    cdc5:	c9                   	leave  
    cdc6:	c3                   	ret    

0000cdc7 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    cdc7:	55                   	push   %ebp
    cdc8:	89 e5                	mov    %esp,%ebp
    cdca:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    cdcd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    cdd4:	8b 45 10             	mov    0x10(%ebp),%eax
    cdd7:	83 c0 02             	add    $0x2,%eax
    cdda:	3b 45 0c             	cmp    0xc(%ebp),%eax
    cddd:	7d 41                	jge    ce20 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    cddf:	8b 55 10             	mov    0x10(%ebp),%edx
    cde2:	8b 45 08             	mov    0x8(%ebp),%eax
    cde5:	01 d0                	add    %edx,%eax
    cde7:	0f b6 00             	movzbl (%eax),%eax
    cdea:	0f b6 c0             	movzbl %al,%eax
    cded:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    cdf0:	8b 45 10             	mov    0x10(%ebp),%eax
    cdf3:	8d 50 01             	lea    0x1(%eax),%edx
    cdf6:	8b 45 08             	mov    0x8(%ebp),%eax
    cdf9:	01 d0                	add    %edx,%eax
    cdfb:	0f b6 00             	movzbl (%eax),%eax
    cdfe:	0f b6 c0             	movzbl %al,%eax
    ce01:	c1 e0 04             	shl    $0x4,%eax
    ce04:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    ce07:	8b 45 10             	mov    0x10(%ebp),%eax
    ce0a:	8d 50 02             	lea    0x2(%eax),%edx
    ce0d:	8b 45 08             	mov    0x8(%ebp),%eax
    ce10:	01 d0                	add    %edx,%eax
    ce12:	0f b6 00             	movzbl (%eax),%eax
    ce15:	0f b6 c0             	movzbl %al,%eax
    ce18:	c1 e0 08             	shl    $0x8,%eax
    ce1b:	31 45 fc             	xor    %eax,-0x4(%ebp)
    ce1e:	eb 51                	jmp    ce71 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    ce20:	8b 45 10             	mov    0x10(%ebp),%eax
    ce23:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ce26:	7c 07                	jl     ce2f <getHash+0x68>
    ce28:	b8 00 00 00 00       	mov    $0x0,%eax
    ce2d:	eb 4a                	jmp    ce79 <getHash+0xb2>
    amount = size - pos;
    ce2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ce32:	2b 45 10             	sub    0x10(%ebp),%eax
    ce35:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    ce38:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ce3f:	eb 28                	jmp    ce69 <getHash+0xa2>
    ce41:	8b 55 10             	mov    0x10(%ebp),%edx
    ce44:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ce47:	01 d0                	add    %edx,%eax
    ce49:	89 c2                	mov    %eax,%edx
    ce4b:	8b 45 08             	mov    0x8(%ebp),%eax
    ce4e:	01 d0                	add    %edx,%eax
    ce50:	0f b6 00             	movzbl (%eax),%eax
    ce53:	0f b6 d0             	movzbl %al,%edx
    ce56:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ce59:	c1 e0 03             	shl    $0x3,%eax
    ce5c:	89 c1                	mov    %eax,%ecx
    ce5e:	d3 e2                	shl    %cl,%edx
    ce60:	89 d0                	mov    %edx,%eax
    ce62:	31 45 fc             	xor    %eax,-0x4(%ebp)
    ce65:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ce69:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ce6c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    ce6f:	75 d0                	jne    ce41 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    ce71:	b8 ff ff 00 00       	mov    $0xffff,%eax
    ce76:	23 45 fc             	and    -0x4(%ebp),%eax
}
    ce79:	c9                   	leave  
    ce7a:	c3                   	ret    

0000ce7b <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    ce7b:	55                   	push   %ebp
    ce7c:	89 e5                	mov    %esp,%ebp
    ce7e:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    ce81:	8b 55 10             	mov    0x10(%ebp),%edx
    ce84:	8b 45 08             	mov    0x8(%ebp),%eax
    ce87:	01 d0                	add    %edx,%eax
    ce89:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    ce8c:	b8 02 01 00 00       	mov    $0x102,%eax
    ce91:	89 c2                	mov    %eax,%edx
    ce93:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ce96:	01 d0                	add    %edx,%eax
    ce98:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    ce9b:	8b 55 0c             	mov    0xc(%ebp),%edx
    ce9e:	8b 45 08             	mov    0x8(%ebp),%eax
    cea1:	01 d0                	add    %edx,%eax
    cea3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    cea6:	73 0b                	jae    ceb3 <countZeros+0x38>
    cea8:	8b 55 0c             	mov    0xc(%ebp),%edx
    ceab:	8b 45 08             	mov    0x8(%ebp),%eax
    ceae:	01 d0                	add    %edx,%eax
    ceb0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    ceb3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ceb6:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    ceb9:	eb 04                	jmp    cebf <countZeros+0x44>
    cebb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    cebf:	8b 45 08             	mov    0x8(%ebp),%eax
    cec2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    cec5:	74 0a                	je     ced1 <countZeros+0x56>
    cec7:	8b 45 08             	mov    0x8(%ebp),%eax
    ceca:	0f b6 00             	movzbl (%eax),%eax
    cecd:	84 c0                	test   %al,%al
    cecf:	74 ea                	je     cebb <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    ced1:	8b 55 08             	mov    0x8(%ebp),%edx
    ced4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ced7:	29 c2                	sub    %eax,%edx
    ced9:	89 d0                	mov    %edx,%eax
}
    cedb:	c9                   	leave  
    cedc:	c3                   	ret    

0000cedd <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    cedd:	55                   	push   %ebp
    cede:	89 e5                	mov    %esp,%ebp
    cee0:	83 ec 04             	sub    $0x4,%esp
    cee3:	8b 45 14             	mov    0x14(%ebp),%eax
    cee6:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    ceea:	8b 45 08             	mov    0x8(%ebp),%eax
    ceed:	8b 40 08             	mov    0x8(%eax),%eax
    cef0:	8b 55 0c             	mov    0xc(%ebp),%edx
    cef3:	c1 e2 02             	shl    $0x2,%edx
    cef6:	01 c2                	add    %eax,%edx
    cef8:	8b 45 10             	mov    0x10(%ebp),%eax
    cefb:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    cefd:	8b 45 08             	mov    0x8(%ebp),%eax
    cf00:	8b 00                	mov    (%eax),%eax
    cf02:	8b 55 10             	mov    0x10(%ebp),%edx
    cf05:	c1 e2 02             	shl    $0x2,%edx
    cf08:	01 d0                	add    %edx,%eax
    cf0a:	8b 00                	mov    (%eax),%eax
    cf0c:	83 f8 ff             	cmp    $0xffffffff,%eax
    cf0f:	74 1f                	je     cf30 <updateHashChain+0x53>
    cf11:	8b 45 08             	mov    0x8(%ebp),%eax
    cf14:	8b 40 04             	mov    0x4(%eax),%eax
    cf17:	8b 55 0c             	mov    0xc(%ebp),%edx
    cf1a:	01 d2                	add    %edx,%edx
    cf1c:	01 c2                	add    %eax,%edx
    cf1e:	8b 45 08             	mov    0x8(%ebp),%eax
    cf21:	8b 00                	mov    (%eax),%eax
    cf23:	8b 4d 10             	mov    0x10(%ebp),%ecx
    cf26:	c1 e1 02             	shl    $0x2,%ecx
    cf29:	01 c8                	add    %ecx,%eax
    cf2b:	8b 00                	mov    (%eax),%eax
    cf2d:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    cf30:	8b 45 08             	mov    0x8(%ebp),%eax
    cf33:	8b 00                	mov    (%eax),%eax
    cf35:	8b 55 10             	mov    0x10(%ebp),%edx
    cf38:	c1 e2 02             	shl    $0x2,%edx
    cf3b:	01 c2                	add    %eax,%edx
    cf3d:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf40:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    cf42:	8b 45 08             	mov    0x8(%ebp),%eax
    cf45:	8b 40 14             	mov    0x14(%eax),%eax
    cf48:	8b 55 0c             	mov    0xc(%ebp),%edx
    cf4b:	01 d2                	add    %edx,%edx
    cf4d:	01 c2                	add    %eax,%edx
    cf4f:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    cf53:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    cf56:	8b 45 08             	mov    0x8(%ebp),%eax
    cf59:	8b 40 0c             	mov    0xc(%eax),%eax
    cf5c:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    cf60:	c1 e2 02             	shl    $0x2,%edx
    cf63:	01 d0                	add    %edx,%eax
    cf65:	8b 00                	mov    (%eax),%eax
    cf67:	83 f8 ff             	cmp    $0xffffffff,%eax
    cf6a:	74 21                	je     cf8d <updateHashChain+0xb0>
    cf6c:	8b 45 08             	mov    0x8(%ebp),%eax
    cf6f:	8b 40 10             	mov    0x10(%eax),%eax
    cf72:	8b 55 0c             	mov    0xc(%ebp),%edx
    cf75:	01 d2                	add    %edx,%edx
    cf77:	01 c2                	add    %eax,%edx
    cf79:	8b 45 08             	mov    0x8(%ebp),%eax
    cf7c:	8b 40 0c             	mov    0xc(%eax),%eax
    cf7f:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    cf83:	c1 e1 02             	shl    $0x2,%ecx
    cf86:	01 c8                	add    %ecx,%eax
    cf88:	8b 00                	mov    (%eax),%eax
    cf8a:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    cf8d:	8b 45 08             	mov    0x8(%ebp),%eax
    cf90:	8b 40 0c             	mov    0xc(%eax),%eax
    cf93:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    cf97:	c1 e2 02             	shl    $0x2,%edx
    cf9a:	01 c2                	add    %eax,%edx
    cf9c:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf9f:	89 02                	mov    %eax,(%edx)
}
    cfa1:	90                   	nop
    cfa2:	c9                   	leave  
    cfa3:	c3                   	ret    

0000cfa4 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    cfa4:	55                   	push   %ebp
    cfa5:	89 e5                	mov    %esp,%ebp
    cfa7:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    cfaa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    cfb1:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    cfb8:	77 08                	ja     cfc2 <encodeLZ77+0x1e>
    cfba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cfbd:	c1 e8 03             	shr    $0x3,%eax
    cfc0:	eb 03                	jmp    cfc5 <encodeLZ77+0x21>
    cfc2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    cfc5:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    cfc8:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    cfcf:	76 07                	jbe    cfd8 <encodeLZ77+0x34>
    cfd1:	b8 02 01 00 00       	mov    $0x102,%eax
    cfd6:	eb 05                	jmp    cfdd <encodeLZ77+0x39>
    cfd8:	b8 40 00 00 00       	mov    $0x40,%eax
    cfdd:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    cfe0:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    cfe7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    cfee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    cff5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    cffc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    d003:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    d007:	74 09                	je     d012 <encodeLZ77+0x6e>
    d009:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    d010:	76 0a                	jbe    d01c <encodeLZ77+0x78>
    d012:	b8 3c 00 00 00       	mov    $0x3c,%eax
    d017:	e9 e3 04 00 00       	jmp    d4ff <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    d01c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d01f:	83 e8 01             	sub    $0x1,%eax
    d022:	23 45 1c             	and    0x1c(%ebp),%eax
    d025:	85 c0                	test   %eax,%eax
    d027:	74 0a                	je     d033 <encodeLZ77+0x8f>
    d029:	b8 5a 00 00 00       	mov    $0x5a,%eax
    d02e:	e9 cc 04 00 00       	jmp    d4ff <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    d033:	b8 02 01 00 00       	mov    $0x102,%eax
    d038:	39 45 24             	cmp    %eax,0x24(%ebp)
    d03b:	76 08                	jbe    d045 <encodeLZ77+0xa1>
    d03d:	b8 02 01 00 00       	mov    $0x102,%eax
    d042:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    d045:	8b 45 14             	mov    0x14(%ebp),%eax
    d048:	89 45 fc             	mov    %eax,-0x4(%ebp)
    d04b:	e9 a0 04 00 00       	jmp    d4f0 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    d050:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d053:	8d 50 ff             	lea    -0x1(%eax),%edx
    d056:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d059:	21 d0                	and    %edx,%eax
    d05b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    d05e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    d065:	ff 75 fc             	pushl  -0x4(%ebp)
    d068:	ff 75 18             	pushl  0x18(%ebp)
    d06b:	ff 75 10             	pushl  0x10(%ebp)
    d06e:	e8 54 fd ff ff       	call   cdc7 <getHash>
    d073:	83 c4 0c             	add    $0xc,%esp
    d076:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    d079:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    d07d:	74 4e                	je     d0cd <encodeLZ77+0x129>
    d07f:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    d083:	75 48                	jne    d0cd <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    d085:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d089:	75 16                	jne    d0a1 <encodeLZ77+0xfd>
    d08b:	ff 75 fc             	pushl  -0x4(%ebp)
    d08e:	ff 75 18             	pushl  0x18(%ebp)
    d091:	ff 75 10             	pushl  0x10(%ebp)
    d094:	e8 e2 fd ff ff       	call   ce7b <countZeros>
    d099:	83 c4 0c             	add    $0xc,%esp
    d09c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    d09f:	eb 35                	jmp    d0d6 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    d0a1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d0a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d0a7:	01 c2                	add    %eax,%edx
    d0a9:	8b 45 18             	mov    0x18(%ebp),%eax
    d0ac:	39 c2                	cmp    %eax,%edx
    d0ae:	77 17                	ja     d0c7 <encodeLZ77+0x123>
    d0b0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d0b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d0b6:	01 d0                	add    %edx,%eax
    d0b8:	8d 50 ff             	lea    -0x1(%eax),%edx
    d0bb:	8b 45 10             	mov    0x10(%ebp),%eax
    d0be:	01 d0                	add    %edx,%eax
    d0c0:	0f b6 00             	movzbl (%eax),%eax
    d0c3:	84 c0                	test   %al,%al
    d0c5:	74 0f                	je     d0d6 <encodeLZ77+0x132>
    d0c7:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    d0cb:	eb 09                	jmp    d0d6 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    d0cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d0d4:	eb 01                	jmp    d0d7 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    d0d6:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    d0d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d0da:	0f b7 c0             	movzwl %ax,%eax
    d0dd:	50                   	push   %eax
    d0de:	ff 75 b0             	pushl  -0x50(%ebp)
    d0e1:	ff 75 b4             	pushl  -0x4c(%ebp)
    d0e4:	ff 75 0c             	pushl  0xc(%ebp)
    d0e7:	e8 f1 fd ff ff       	call   cedd <updateHashChain>
    d0ec:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    d0ef:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    d0f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    d0fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    d100:	8b 40 04             	mov    0x4(%eax),%eax
    d103:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    d106:	01 d2                	add    %edx,%edx
    d108:	01 d0                	add    %edx,%eax
    d10a:	0f b7 00             	movzwl (%eax),%eax
    d10d:	0f b7 c0             	movzwl %ax,%eax
    d110:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    d113:	ba 02 01 00 00       	mov    $0x102,%edx
    d118:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d11b:	01 c2                	add    %eax,%edx
    d11d:	8b 45 18             	mov    0x18(%ebp),%eax
    d120:	39 c2                	cmp    %eax,%edx
    d122:	0f 4e c2             	cmovle %edx,%eax
    d125:	89 c2                	mov    %eax,%edx
    d127:	8b 45 10             	mov    0x10(%ebp),%eax
    d12a:	01 d0                	add    %edx,%eax
    d12c:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    d12f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    d136:	8b 45 c8             	mov    -0x38(%ebp),%eax
    d139:	8d 50 01             	lea    0x1(%eax),%edx
    d13c:	89 55 c8             	mov    %edx,-0x38(%ebp)
    d13f:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    d142:	0f 83 67 01 00 00    	jae    d2af <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    d148:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    d14b:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    d14e:	77 08                	ja     d158 <encodeLZ77+0x1b4>
    d150:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    d153:	2b 45 cc             	sub    -0x34(%ebp),%eax
    d156:	eb 0d                	jmp    d165 <encodeLZ77+0x1c1>
    d158:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    d15b:	2b 45 cc             	sub    -0x34(%ebp),%eax
    d15e:	89 c2                	mov    %eax,%edx
    d160:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d163:	01 d0                	add    %edx,%eax
    d165:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    d168:	8b 45 a8             	mov    -0x58(%ebp),%eax
    d16b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d16e:	0f 82 3e 01 00 00    	jb     d2b2 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    d174:	8b 45 a8             	mov    -0x58(%ebp),%eax
    d177:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    d17a:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    d17e:	0f 84 a3 00 00 00    	je     d227 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    d184:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d187:	8b 45 10             	mov    0x10(%ebp),%eax
    d18a:	01 d0                	add    %edx,%eax
    d18c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    d18f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d192:	2b 45 a8             	sub    -0x58(%ebp),%eax
    d195:	89 c2                	mov    %eax,%edx
    d197:	8b 45 10             	mov    0x10(%ebp),%eax
    d19a:	01 d0                	add    %edx,%eax
    d19c:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    d19f:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    d1a3:	76 3a                	jbe    d1df <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    d1a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1a8:	8b 40 14             	mov    0x14(%eax),%eax
    d1ab:	8b 55 cc             	mov    -0x34(%ebp),%edx
    d1ae:	01 d2                	add    %edx,%edx
    d1b0:	01 d0                	add    %edx,%eax
    d1b2:	0f b7 00             	movzwl (%eax),%eax
    d1b5:	0f b7 c0             	movzwl %ax,%eax
    d1b8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    d1bb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    d1be:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    d1c1:	76 06                	jbe    d1c9 <encodeLZ77+0x225>
    d1c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d1c6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    d1c9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    d1cc:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    d1cf:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    d1d2:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    d1d5:	eb 08                	jmp    d1df <encodeLZ77+0x23b>
          ++backptr;
    d1d7:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    d1db:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    d1df:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d1e2:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    d1e5:	74 10                	je     d1f7 <encodeLZ77+0x253>
    d1e7:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d1ea:	0f b6 10             	movzbl (%eax),%edx
    d1ed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d1f0:	0f b6 00             	movzbl (%eax),%eax
    d1f3:	38 c2                	cmp    %al,%dl
    d1f5:	74 e0                	je     d1d7 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    d1f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d1fa:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    d1fd:	8b 55 10             	mov    0x10(%ebp),%edx
    d200:	01 ca                	add    %ecx,%edx
    d202:	29 d0                	sub    %edx,%eax
    d204:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    d207:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d20a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    d20d:	76 18                	jbe    d227 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    d20f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d212:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    d215:	8b 45 a8             	mov    -0x58(%ebp),%eax
    d218:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    d21b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    d21e:	3b 45 24             	cmp    0x24(%ebp),%eax
    d221:	0f 83 8e 00 00 00    	jae    d2b5 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    d227:	8b 45 0c             	mov    0xc(%ebp),%eax
    d22a:	8b 40 04             	mov    0x4(%eax),%eax
    d22d:	8b 55 cc             	mov    -0x34(%ebp),%edx
    d230:	01 d2                	add    %edx,%edx
    d232:	01 d0                	add    %edx,%eax
    d234:	0f b7 00             	movzwl (%eax),%eax
    d237:	0f b7 c0             	movzwl %ax,%eax
    d23a:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    d23d:	74 79                	je     d2b8 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    d23f:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    d243:	76 38                	jbe    d27d <encodeLZ77+0x2d9>
    d245:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d248:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    d24b:	76 30                	jbe    d27d <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    d24d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d250:	8b 40 10             	mov    0x10(%eax),%eax
    d253:	8b 55 cc             	mov    -0x34(%ebp),%edx
    d256:	01 d2                	add    %edx,%edx
    d258:	01 d0                	add    %edx,%eax
    d25a:	0f b7 00             	movzwl (%eax),%eax
    d25d:	0f b7 c0             	movzwl %ax,%eax
    d260:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    d263:	8b 45 0c             	mov    0xc(%ebp),%eax
    d266:	8b 40 14             	mov    0x14(%eax),%eax
    d269:	8b 55 cc             	mov    -0x34(%ebp),%edx
    d26c:	01 d2                	add    %edx,%edx
    d26e:	01 d0                	add    %edx,%eax
    d270:	0f b7 00             	movzwl (%eax),%eax
    d273:	0f b7 c0             	movzwl %ax,%eax
    d276:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    d279:	74 2f                	je     d2aa <encodeLZ77+0x306>
    d27b:	eb 3f                	jmp    d2bc <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    d27d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d280:	8b 40 04             	mov    0x4(%eax),%eax
    d283:	8b 55 cc             	mov    -0x34(%ebp),%edx
    d286:	01 d2                	add    %edx,%edx
    d288:	01 d0                	add    %edx,%eax
    d28a:	0f b7 00             	movzwl (%eax),%eax
    d28d:	0f b7 c0             	movzwl %ax,%eax
    d290:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    d293:	8b 45 0c             	mov    0xc(%ebp),%eax
    d296:	8b 40 08             	mov    0x8(%eax),%eax
    d299:	8b 55 cc             	mov    -0x34(%ebp),%edx
    d29c:	c1 e2 02             	shl    $0x2,%edx
    d29f:	01 d0                	add    %edx,%eax
    d2a1:	8b 10                	mov    (%eax),%edx
    d2a3:	8b 45 b0             	mov    -0x50(%ebp),%eax
    d2a6:	39 c2                	cmp    %eax,%edx
    d2a8:	75 11                	jne    d2bb <encodeLZ77+0x317>
      }
    }
    d2aa:	e9 87 fe ff ff       	jmp    d136 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    d2af:	90                   	nop
    d2b0:	eb 0a                	jmp    d2bc <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    d2b2:	90                   	nop
    d2b3:	eb 07                	jmp    d2bc <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    d2b5:	90                   	nop
    d2b6:	eb 04                	jmp    d2bc <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    d2b8:	90                   	nop
    d2b9:	eb 01                	jmp    d2bc <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    d2bb:	90                   	nop
      }
    }

    if(lazymatching) {
    d2bc:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    d2c0:	0f 84 c8 00 00 00    	je     d38e <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    d2c6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d2ca:	75 30                	jne    d2fc <encodeLZ77+0x358>
    d2cc:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    d2d0:	76 2a                	jbe    d2fc <encodeLZ77+0x358>
    d2d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d2d5:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    d2d8:	77 22                	ja     d2fc <encodeLZ77+0x358>
    d2da:	b8 02 01 00 00       	mov    $0x102,%eax
    d2df:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    d2e2:	73 18                	jae    d2fc <encodeLZ77+0x358>
        lazy = 1;
    d2e4:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    d2eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d2ee:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    d2f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    d2f4:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    d2f7:	e9 f0 01 00 00       	jmp    d4ec <encodeLZ77+0x548>
      }
      if(lazy) {
    d2fc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d300:	0f 84 88 00 00 00    	je     d38e <encodeLZ77+0x3ea>
        lazy = 0;
    d306:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    d30d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    d311:	75 0c                	jne    d31f <encodeLZ77+0x37b>
    d313:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    d31a:	e9 dd 01 00 00       	jmp    d4fc <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    d31f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    d322:	83 c0 01             	add    $0x1,%eax
    d325:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    d328:	73 2d                	jae    d357 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    d32a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d32d:	8d 50 ff             	lea    -0x1(%eax),%edx
    d330:	8b 45 10             	mov    0x10(%ebp),%eax
    d333:	01 d0                	add    %edx,%eax
    d335:	0f b6 00             	movzbl (%eax),%eax
    d338:	0f b6 c0             	movzbl %al,%eax
    d33b:	50                   	push   %eax
    d33c:	ff 75 08             	pushl  0x8(%ebp)
    d33f:	e8 6f cb ff ff       	call   9eb3 <uivector_push_back>
    d344:	83 c4 08             	add    $0x8,%esp
    d347:	85 c0                	test   %eax,%eax
    d349:	75 43                	jne    d38e <encodeLZ77+0x3ea>
    d34b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    d352:	e9 a5 01 00 00       	jmp    d4fc <encodeLZ77+0x558>
        } else {
          length = lazylength;
    d357:	8b 45 e0             	mov    -0x20(%ebp),%eax
    d35a:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    d35d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d360:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    d363:	8b 45 0c             	mov    0xc(%ebp),%eax
    d366:	8b 00                	mov    (%eax),%eax
    d368:	8b 55 b0             	mov    -0x50(%ebp),%edx
    d36b:	c1 e2 02             	shl    $0x2,%edx
    d36e:	01 d0                	add    %edx,%eax
    d370:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    d376:	8b 45 0c             	mov    0xc(%ebp),%eax
    d379:	8b 40 0c             	mov    0xc(%eax),%eax
    d37c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d37f:	c1 e2 02             	shl    $0x2,%edx
    d382:	01 d0                	add    %edx,%eax
    d384:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    d38a:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    d38e:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    d392:	76 14                	jbe    d3a8 <encodeLZ77+0x404>
    d394:	8b 45 ec             	mov    -0x14(%ebp),%eax
    d397:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d39a:	76 0c                	jbe    d3a8 <encodeLZ77+0x404>
    d39c:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    d3a3:	e9 54 01 00 00       	jmp    d4fc <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    d3a8:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    d3ac:	77 2e                	ja     d3dc <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    d3ae:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d3b1:	8b 45 10             	mov    0x10(%ebp),%eax
    d3b4:	01 d0                	add    %edx,%eax
    d3b6:	0f b6 00             	movzbl (%eax),%eax
    d3b9:	0f b6 c0             	movzbl %al,%eax
    d3bc:	50                   	push   %eax
    d3bd:	ff 75 08             	pushl  0x8(%ebp)
    d3c0:	e8 ee ca ff ff       	call   9eb3 <uivector_push_back>
    d3c5:	83 c4 08             	add    $0x8,%esp
    d3c8:	85 c0                	test   %eax,%eax
    d3ca:	0f 85 1c 01 00 00    	jne    d4ec <encodeLZ77+0x548>
    d3d0:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    d3d7:	e9 20 01 00 00       	jmp    d4fc <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    d3dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d3df:	3b 45 20             	cmp    0x20(%ebp),%eax
    d3e2:	72 0f                	jb     d3f3 <encodeLZ77+0x44f>
    d3e4:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    d3e8:	75 37                	jne    d421 <encodeLZ77+0x47d>
    d3ea:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    d3f1:	76 2e                	jbe    d421 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    d3f3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d3f6:	8b 45 10             	mov    0x10(%ebp),%eax
    d3f9:	01 d0                	add    %edx,%eax
    d3fb:	0f b6 00             	movzbl (%eax),%eax
    d3fe:	0f b6 c0             	movzbl %al,%eax
    d401:	50                   	push   %eax
    d402:	ff 75 08             	pushl  0x8(%ebp)
    d405:	e8 a9 ca ff ff       	call   9eb3 <uivector_push_back>
    d40a:	83 c4 08             	add    $0x8,%esp
    d40d:	85 c0                	test   %eax,%eax
    d40f:	0f 85 d7 00 00 00    	jne    d4ec <encodeLZ77+0x548>
    d415:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    d41c:	e9 db 00 00 00       	jmp    d4fc <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    d421:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d424:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d427:	52                   	push   %edx
    d428:	50                   	push   %eax
    d429:	ff 75 08             	pushl  0x8(%ebp)
    d42c:	e8 8a f6 ff ff       	call   cabb <addLengthDistance>
    d431:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    d434:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    d43b:	e9 a0 00 00 00       	jmp    d4e0 <encodeLZ77+0x53c>
        ++pos;
    d440:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    d444:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d447:	8d 50 ff             	lea    -0x1(%eax),%edx
    d44a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d44d:	21 d0                	and    %edx,%eax
    d44f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    d452:	ff 75 fc             	pushl  -0x4(%ebp)
    d455:	ff 75 18             	pushl  0x18(%ebp)
    d458:	ff 75 10             	pushl  0x10(%ebp)
    d45b:	e8 67 f9 ff ff       	call   cdc7 <getHash>
    d460:	83 c4 0c             	add    $0xc,%esp
    d463:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    d466:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    d46a:	74 4e                	je     d4ba <encodeLZ77+0x516>
    d46c:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    d470:	75 48                	jne    d4ba <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    d472:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d476:	75 16                	jne    d48e <encodeLZ77+0x4ea>
    d478:	ff 75 fc             	pushl  -0x4(%ebp)
    d47b:	ff 75 18             	pushl  0x18(%ebp)
    d47e:	ff 75 10             	pushl  0x10(%ebp)
    d481:	e8 f5 f9 ff ff       	call   ce7b <countZeros>
    d486:	83 c4 0c             	add    $0xc,%esp
    d489:	89 45 f0             	mov    %eax,-0x10(%ebp)
    d48c:	eb 35                	jmp    d4c3 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    d48e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d491:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d494:	01 c2                	add    %eax,%edx
    d496:	8b 45 18             	mov    0x18(%ebp),%eax
    d499:	39 c2                	cmp    %eax,%edx
    d49b:	77 17                	ja     d4b4 <encodeLZ77+0x510>
    d49d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d4a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d4a3:	01 d0                	add    %edx,%eax
    d4a5:	8d 50 ff             	lea    -0x1(%eax),%edx
    d4a8:	8b 45 10             	mov    0x10(%ebp),%eax
    d4ab:	01 d0                	add    %edx,%eax
    d4ad:	0f b6 00             	movzbl (%eax),%eax
    d4b0:	84 c0                	test   %al,%al
    d4b2:	74 0f                	je     d4c3 <encodeLZ77+0x51f>
    d4b4:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    d4b8:	eb 09                	jmp    d4c3 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    d4ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d4c1:	eb 01                	jmp    d4c4 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    d4c3:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    d4c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d4c7:	0f b7 c0             	movzwl %ax,%eax
    d4ca:	50                   	push   %eax
    d4cb:	ff 75 b0             	pushl  -0x50(%ebp)
    d4ce:	ff 75 b4             	pushl  -0x4c(%ebp)
    d4d1:	ff 75 0c             	pushl  0xc(%ebp)
    d4d4:	e8 04 fa ff ff       	call   cedd <updateHashChain>
    d4d9:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    d4dc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    d4e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d4e3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    d4e6:	0f 82 54 ff ff ff    	jb     d440 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    d4ec:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    d4f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d4f3:	3b 45 18             	cmp    0x18(%ebp),%eax
    d4f6:	0f 8c 54 fb ff ff    	jl     d050 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    d4fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d4ff:	c9                   	leave  
    d500:	c3                   	ret    

0000d501 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    d501:	55                   	push   %ebp
    d502:	89 e5                	mov    %esp,%ebp
    d504:	53                   	push   %ebx
    d505:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    d508:	8b 45 10             	mov    0x10(%ebp),%eax
    d50b:	05 fe ff 00 00       	add    $0xfffe,%eax
    d510:	ba 01 80 00 80       	mov    $0x80008001,%edx
    d515:	f7 e2                	mul    %edx
    d517:	89 d0                	mov    %edx,%eax
    d519:	c1 e8 0f             	shr    $0xf,%eax
    d51c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    d51f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    d526:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    d52d:	e9 1b 01 00 00       	jmp    d64d <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    d532:	8b 45 08             	mov    0x8(%ebp),%eax
    d535:	8b 40 04             	mov    0x4(%eax),%eax
    d538:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    d53b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    d53e:	83 e8 01             	sub    $0x1,%eax
    d541:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    d544:	0f 94 c0             	sete   %al
    d547:	0f b6 c0             	movzbl %al,%eax
    d54a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    d54d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    d554:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    d55b:	8b 45 10             	mov    0x10(%ebp),%eax
    d55e:	2b 45 f4             	sub    -0xc(%ebp),%eax
    d561:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    d566:	77 09                	ja     d571 <deflateNoCompression+0x70>
    d568:	8b 45 10             	mov    0x10(%ebp),%eax
    d56b:	2b 45 f4             	sub    -0xc(%ebp),%eax
    d56e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    d571:	b8 ff ff 00 00       	mov    $0xffff,%eax
    d576:	2b 45 f0             	sub    -0x10(%ebp),%eax
    d579:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    d57c:	8b 45 08             	mov    0x8(%ebp),%eax
    d57f:	8b 40 04             	mov    0x4(%eax),%eax
    d582:	89 c2                	mov    %eax,%edx
    d584:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d587:	01 d0                	add    %edx,%eax
    d589:	83 c0 05             	add    $0x5,%eax
    d58c:	50                   	push   %eax
    d58d:	ff 75 08             	pushl  0x8(%ebp)
    d590:	e8 62 c9 ff ff       	call   9ef7 <ucvector_resize>
    d595:	83 c4 08             	add    $0x8,%esp
    d598:	85 c0                	test   %eax,%eax
    d59a:	75 0a                	jne    d5a6 <deflateNoCompression+0xa5>
    d59c:	b8 53 00 00 00       	mov    $0x53,%eax
    d5a1:	e9 b8 00 00 00       	jmp    d65e <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    d5a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d5a9:	89 c2                	mov    %eax,%edx
    d5ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
    d5ae:	83 e0 01             	and    $0x1,%eax
    d5b1:	01 c0                	add    %eax,%eax
    d5b3:	01 c2                	add    %eax,%edx
    d5b5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    d5b8:	83 e0 02             	and    $0x2,%eax
    d5bb:	01 c0                	add    %eax,%eax
    d5bd:	01 d0                	add    %edx,%eax
    d5bf:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    d5c2:	8b 45 08             	mov    0x8(%ebp),%eax
    d5c5:	8b 10                	mov    (%eax),%edx
    d5c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d5ca:	01 c2                	add    %eax,%edx
    d5cc:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    d5d0:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    d5d2:	8b 45 08             	mov    0x8(%ebp),%eax
    d5d5:	8b 00                	mov    (%eax),%eax
    d5d7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d5da:	83 c2 01             	add    $0x1,%edx
    d5dd:	01 d0                	add    %edx,%eax
    d5df:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d5e2:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    d5e4:	8b 45 08             	mov    0x8(%ebp),%eax
    d5e7:	8b 00                	mov    (%eax),%eax
    d5e9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d5ec:	83 c2 02             	add    $0x2,%edx
    d5ef:	01 d0                	add    %edx,%eax
    d5f1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d5f4:	c1 ea 08             	shr    $0x8,%edx
    d5f7:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    d5f9:	8b 45 08             	mov    0x8(%ebp),%eax
    d5fc:	8b 00                	mov    (%eax),%eax
    d5fe:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d601:	83 c2 03             	add    $0x3,%edx
    d604:	01 d0                	add    %edx,%eax
    d606:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d609:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    d60b:	8b 45 08             	mov    0x8(%ebp),%eax
    d60e:	8b 00                	mov    (%eax),%eax
    d610:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d613:	83 c2 04             	add    $0x4,%edx
    d616:	01 d0                	add    %edx,%eax
    d618:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d61b:	c1 ea 08             	shr    $0x8,%edx
    d61e:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    d620:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d623:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    d626:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d629:	01 d1                	add    %edx,%ecx
    d62b:	8b 55 08             	mov    0x8(%ebp),%edx
    d62e:	8b 12                	mov    (%edx),%edx
    d630:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    d633:	83 c3 05             	add    $0x5,%ebx
    d636:	01 da                	add    %ebx,%edx
    d638:	50                   	push   %eax
    d639:	51                   	push   %ecx
    d63a:	52                   	push   %edx
    d63b:	e8 9b c6 ff ff       	call   9cdb <lodepng_memcpy>
    d640:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    d643:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d646:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    d649:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    d64d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d650:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    d653:	0f 85 d9 fe ff ff    	jne    d532 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    d659:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d65e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    d661:	c9                   	leave  
    d662:	c3                   	ret    

0000d663 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    d663:	55                   	push   %ebp
    d664:	89 e5                	mov    %esp,%ebp
    d666:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    d669:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    d670:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    d677:	e9 10 01 00 00       	jmp    d78c <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    d67c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d67f:	8b 00                	mov    (%eax),%eax
    d681:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d684:	c1 e2 02             	shl    $0x2,%edx
    d687:	01 d0                	add    %edx,%eax
    d689:	8b 00                	mov    (%eax),%eax
    d68b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    d68e:	8b 45 10             	mov    0x10(%ebp),%eax
    d691:	8b 40 04             	mov    0x4(%eax),%eax
    d694:	8b 55 f8             	mov    -0x8(%ebp),%edx
    d697:	c1 e2 02             	shl    $0x2,%edx
    d69a:	01 d0                	add    %edx,%eax
    d69c:	8b 00                	mov    (%eax),%eax
    d69e:	89 c1                	mov    %eax,%ecx
    d6a0:	8b 45 10             	mov    0x10(%ebp),%eax
    d6a3:	8b 00                	mov    (%eax),%eax
    d6a5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    d6a8:	c1 e2 02             	shl    $0x2,%edx
    d6ab:	01 d0                	add    %edx,%eax
    d6ad:	8b 00                	mov    (%eax),%eax
    d6af:	51                   	push   %ecx
    d6b0:	50                   	push   %eax
    d6b1:	ff 75 08             	pushl  0x8(%ebp)
    d6b4:	e8 60 cc ff ff       	call   a319 <writeBitsReversed>
    d6b9:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    d6bc:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    d6c3:	0f 86 bf 00 00 00    	jbe    d788 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    d6c9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d6cc:	2d 01 01 00 00       	sub    $0x101,%eax
    d6d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    d6d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6d7:	8b 04 85 c0 08 02 00 	mov    0x208c0(,%eax,4),%eax
    d6de:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    d6e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6e4:	8b 00                	mov    (%eax),%eax
    d6e6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    d6ea:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d6ed:	c1 e2 02             	shl    $0x2,%edx
    d6f0:	01 d0                	add    %edx,%eax
    d6f2:	8b 00                	mov    (%eax),%eax
    d6f4:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    d6f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6fa:	8b 00                	mov    (%eax),%eax
    d6fc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    d700:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d703:	c1 e2 02             	shl    $0x2,%edx
    d706:	01 d0                	add    %edx,%eax
    d708:	8b 00                	mov    (%eax),%eax
    d70a:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    d70d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d710:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    d713:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d716:	8b 04 85 c0 09 02 00 	mov    0x209c0(,%eax,4),%eax
    d71d:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    d720:	8b 45 0c             	mov    0xc(%ebp),%eax
    d723:	8b 00                	mov    (%eax),%eax
    d725:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    d729:	8b 55 fc             	mov    -0x4(%ebp),%edx
    d72c:	c1 e2 02             	shl    $0x2,%edx
    d72f:	01 d0                	add    %edx,%eax
    d731:	8b 00                	mov    (%eax),%eax
    d733:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    d736:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d739:	50                   	push   %eax
    d73a:	ff 75 ec             	pushl  -0x14(%ebp)
    d73d:	ff 75 08             	pushl  0x8(%ebp)
    d740:	e8 40 ca ff ff       	call   a185 <writeBits>
    d745:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    d748:	8b 45 14             	mov    0x14(%ebp),%eax
    d74b:	8b 40 04             	mov    0x4(%eax),%eax
    d74e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d751:	c1 e2 02             	shl    $0x2,%edx
    d754:	01 d0                	add    %edx,%eax
    d756:	8b 00                	mov    (%eax),%eax
    d758:	89 c1                	mov    %eax,%ecx
    d75a:	8b 45 14             	mov    0x14(%ebp),%eax
    d75d:	8b 00                	mov    (%eax),%eax
    d75f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d762:	c1 e2 02             	shl    $0x2,%edx
    d765:	01 d0                	add    %edx,%eax
    d767:	8b 00                	mov    (%eax),%eax
    d769:	51                   	push   %ecx
    d76a:	50                   	push   %eax
    d76b:	ff 75 08             	pushl  0x8(%ebp)
    d76e:	e8 a6 cb ff ff       	call   a319 <writeBitsReversed>
    d773:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    d776:	8b 45 e0             	mov    -0x20(%ebp),%eax
    d779:	50                   	push   %eax
    d77a:	ff 75 dc             	pushl  -0x24(%ebp)
    d77d:	ff 75 08             	pushl  0x8(%ebp)
    d780:	e8 00 ca ff ff       	call   a185 <writeBits>
    d785:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    d788:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    d78c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d78f:	8b 40 04             	mov    0x4(%eax),%eax
    d792:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    d795:	0f 85 e1 fe ff ff    	jne    d67c <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    d79b:	90                   	nop
    d79c:	c9                   	leave  
    d79d:	c3                   	ret    

0000d79e <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    d79e:	55                   	push   %ebp
    d79f:	89 e5                	mov    %esp,%ebp
    d7a1:	53                   	push   %ebx
    d7a2:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    d7a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    d7af:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    d7b6:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    d7bd:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    d7c4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    d7cb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    d7d2:	8b 45 18             	mov    0x18(%ebp),%eax
    d7d5:	2b 45 14             	sub    0x14(%ebp),%eax
    d7d8:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    d7db:	8b 45 20             	mov    0x20(%ebp),%eax
    d7de:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    d7e1:	8d 45 90             	lea    -0x70(%ebp),%eax
    d7e4:	50                   	push   %eax
    d7e5:	e8 a4 c6 ff ff       	call   9e8e <uivector_init>
    d7ea:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    d7ed:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    d7f3:	50                   	push   %eax
    d7f4:	e8 98 d3 ff ff       	call   ab91 <HuffmanTree_init>
    d7f9:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    d7fc:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    d802:	50                   	push   %eax
    d803:	e8 89 d3 ff ff       	call   ab91 <HuffmanTree_init>
    d808:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    d80b:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    d811:	50                   	push   %eax
    d812:	e8 7a d3 ff ff       	call   ab91 <HuffmanTree_init>
    d817:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    d81a:	83 ec 0c             	sub    $0xc,%esp
    d81d:	68 78 04 00 00       	push   $0x478
    d822:	e8 76 c4 ff ff       	call   9c9d <lodepng_malloc>
    d827:	83 c4 10             	add    $0x10,%esp
    d82a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    d82d:	83 ec 0c             	sub    $0xc,%esp
    d830:	6a 78                	push   $0x78
    d832:	e8 66 c4 ff ff       	call   9c9d <lodepng_malloc>
    d837:	83 c4 10             	add    $0x10,%esp
    d83a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    d83d:	83 ec 0c             	sub    $0xc,%esp
    d840:	6a 4c                	push   $0x4c
    d842:	e8 56 c4 ff ff       	call   9c9d <lodepng_malloc>
    d847:	83 c4 10             	add    $0x10,%esp
    d84a:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    d84d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    d851:	74 0c                	je     d85f <deflateDynamic+0xc1>
    d853:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    d857:	74 06                	je     d85f <deflateDynamic+0xc1>
    d859:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    d85d:	75 07                	jne    d866 <deflateDynamic+0xc8>
    d85f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    d866:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d86a:	0f 85 f6 07 00 00    	jne    e066 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    d870:	83 ec 04             	sub    $0x4,%esp
    d873:	68 78 04 00 00       	push   $0x478
    d878:	6a 00                	push   $0x0
    d87a:	ff 75 d4             	pushl  -0x2c(%ebp)
    d87d:	e8 8c c4 ff ff       	call   9d0e <lodepng_memset>
    d882:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    d885:	83 ec 04             	sub    $0x4,%esp
    d888:	6a 78                	push   $0x78
    d88a:	6a 00                	push   $0x0
    d88c:	ff 75 d0             	pushl  -0x30(%ebp)
    d88f:	e8 7a c4 ff ff       	call   9d0e <lodepng_memset>
    d894:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    d897:	83 ec 04             	sub    $0x4,%esp
    d89a:	6a 4c                	push   $0x4c
    d89c:	6a 00                	push   $0x0
    d89e:	ff 75 cc             	pushl  -0x34(%ebp)
    d8a1:	e8 68 c4 ff ff       	call   9d0e <lodepng_memset>
    d8a6:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    d8a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d8ac:	8b 40 04             	mov    0x4(%eax),%eax
    d8af:	85 c0                	test   %eax,%eax
    d8b1:	74 45                	je     d8f8 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    d8b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d8b6:	8b 58 14             	mov    0x14(%eax),%ebx
    d8b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d8bc:	8b 48 10             	mov    0x10(%eax),%ecx
    d8bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d8c2:	8b 50 0c             	mov    0xc(%eax),%edx
    d8c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d8c8:	8b 40 08             	mov    0x8(%eax),%eax
    d8cb:	83 ec 0c             	sub    $0xc,%esp
    d8ce:	53                   	push   %ebx
    d8cf:	51                   	push   %ecx
    d8d0:	52                   	push   %edx
    d8d1:	50                   	push   %eax
    d8d2:	ff 75 18             	pushl  0x18(%ebp)
    d8d5:	ff 75 14             	pushl  0x14(%ebp)
    d8d8:	ff 75 10             	pushl  0x10(%ebp)
    d8db:	ff 75 0c             	pushl  0xc(%ebp)
    d8de:	8d 45 90             	lea    -0x70(%ebp),%eax
    d8e1:	50                   	push   %eax
    d8e2:	e8 bd f6 ff ff       	call   cfa4 <encodeLZ77>
    d8e7:	83 c4 30             	add    $0x30,%esp
    d8ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    d8ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d8f1:	74 59                	je     d94c <deflateDynamic+0x1ae>
    d8f3:	e9 6e 07 00 00       	jmp    e066 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    d8f8:	83 ec 08             	sub    $0x8,%esp
    d8fb:	ff 75 c8             	pushl  -0x38(%ebp)
    d8fe:	8d 45 90             	lea    -0x70(%ebp),%eax
    d901:	50                   	push   %eax
    d902:	e8 17 c5 ff ff       	call   9e1e <uivector_resize>
    d907:	83 c4 10             	add    $0x10,%esp
    d90a:	85 c0                	test   %eax,%eax
    d90c:	75 0c                	jne    d91a <deflateDynamic+0x17c>
    d90e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    d915:	e9 4c 07 00 00       	jmp    e066 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    d91a:	8b 45 14             	mov    0x14(%ebp),%eax
    d91d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    d920:	eb 22                	jmp    d944 <deflateDynamic+0x1a6>
    d922:	8b 55 90             	mov    -0x70(%ebp),%edx
    d925:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d928:	2b 45 14             	sub    0x14(%ebp),%eax
    d92b:	c1 e0 02             	shl    $0x2,%eax
    d92e:	01 c2                	add    %eax,%edx
    d930:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    d933:	8b 45 10             	mov    0x10(%ebp),%eax
    d936:	01 c8                	add    %ecx,%eax
    d938:	0f b6 00             	movzbl (%eax),%eax
    d93b:	0f b6 c0             	movzbl %al,%eax
    d93e:	89 02                	mov    %eax,(%edx)
    d940:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    d944:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d947:	3b 45 18             	cmp    0x18(%ebp),%eax
    d94a:	7c d6                	jl     d922 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    d94c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    d953:	eb 60                	jmp    d9b5 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    d955:	8b 45 90             	mov    -0x70(%ebp),%eax
    d958:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d95b:	c1 e2 02             	shl    $0x2,%edx
    d95e:	01 d0                	add    %edx,%eax
    d960:	8b 00                	mov    (%eax),%eax
    d962:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    d965:	8b 45 c0             	mov    -0x40(%ebp),%eax
    d968:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d96f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d972:	01 d0                	add    %edx,%eax
    d974:	8b 10                	mov    (%eax),%edx
    d976:	83 c2 01             	add    $0x1,%edx
    d979:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    d97b:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    d982:	76 2d                	jbe    d9b1 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    d984:	8b 45 90             	mov    -0x70(%ebp),%eax
    d987:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d98a:	83 c2 02             	add    $0x2,%edx
    d98d:	c1 e2 02             	shl    $0x2,%edx
    d990:	01 d0                	add    %edx,%eax
    d992:	8b 00                	mov    (%eax),%eax
    d994:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    d997:	8b 45 bc             	mov    -0x44(%ebp),%eax
    d99a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d9a1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d9a4:	01 d0                	add    %edx,%eax
    d9a6:	8b 10                	mov    (%eax),%edx
    d9a8:	83 c2 01             	add    $0x1,%edx
    d9ab:	89 10                	mov    %edx,(%eax)
        i += 3;
    d9ad:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    d9b1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    d9b5:	8b 45 94             	mov    -0x6c(%ebp),%eax
    d9b8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    d9bb:	75 98                	jne    d955 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    d9bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d9c0:	05 00 04 00 00       	add    $0x400,%eax
    d9c5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    d9cb:	83 ec 0c             	sub    $0xc,%esp
    d9ce:	6a 0f                	push   $0xf
    d9d0:	68 1e 01 00 00       	push   $0x11e
    d9d5:	68 01 01 00 00       	push   $0x101
    d9da:	ff 75 d4             	pushl  -0x2c(%ebp)
    d9dd:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    d9e3:	50                   	push   %eax
    d9e4:	e8 e0 e1 ff ff       	call   bbc9 <HuffmanTree_makeFromFrequencies>
    d9e9:	83 c4 20             	add    $0x20,%esp
    d9ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    d9ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d9f3:	0f 85 66 06 00 00    	jne    e05f <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    d9f9:	83 ec 0c             	sub    $0xc,%esp
    d9fc:	6a 0f                	push   $0xf
    d9fe:	6a 1e                	push   $0x1e
    da00:	6a 02                	push   $0x2
    da02:	ff 75 d0             	pushl  -0x30(%ebp)
    da05:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    da0b:	50                   	push   %eax
    da0c:	e8 b8 e1 ff ff       	call   bbc9 <HuffmanTree_makeFromFrequencies>
    da11:	83 c4 20             	add    $0x20,%esp
    da14:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    da17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    da1b:	0f 85 41 06 00 00    	jne    e062 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    da21:	8b 45 84             	mov    -0x7c(%ebp),%eax
    da24:	ba 1e 01 00 00       	mov    $0x11e,%edx
    da29:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    da2e:	0f 47 c2             	cmova  %edx,%eax
    da31:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    da34:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    da3a:	ba 1e 00 00 00       	mov    $0x1e,%edx
    da3f:	83 f8 1e             	cmp    $0x1e,%eax
    da42:	0f 47 c2             	cmova  %edx,%eax
    da45:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    da48:	8b 55 b8             	mov    -0x48(%ebp),%edx
    da4b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    da4e:	01 d0                	add    %edx,%eax
    da50:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    da53:	8b 45 b0             	mov    -0x50(%ebp),%eax
    da56:	c1 e0 02             	shl    $0x2,%eax
    da59:	83 ec 0c             	sub    $0xc,%esp
    da5c:	50                   	push   %eax
    da5d:	e8 3b c2 ff ff       	call   9c9d <lodepng_malloc>
    da62:	83 c4 10             	add    $0x10,%esp
    da65:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    da68:	8b 45 b0             	mov    -0x50(%ebp),%eax
    da6b:	c1 e0 02             	shl    $0x2,%eax
    da6e:	83 ec 0c             	sub    $0xc,%esp
    da71:	50                   	push   %eax
    da72:	e8 26 c2 ff ff       	call   9c9d <lodepng_malloc>
    da77:	83 c4 10             	add    $0x10,%esp
    da7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    da7d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    da81:	74 06                	je     da89 <deflateDynamic+0x2eb>
    da83:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    da87:	75 0c                	jne    da95 <deflateDynamic+0x2f7>
    da89:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    da90:	e9 d1 05 00 00       	jmp    e066 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    da95:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    da9c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    daa3:	eb 25                	jmp    daca <deflateDynamic+0x32c>
    daa5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    daa8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    daaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dab2:	01 c2                	add    %eax,%edx
    dab4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    daba:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    dabd:	c1 e1 02             	shl    $0x2,%ecx
    dac0:	01 c8                	add    %ecx,%eax
    dac2:	8b 00                	mov    (%eax),%eax
    dac4:	89 02                	mov    %eax,(%edx)
    dac6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    daca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dacd:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    dad0:	75 d3                	jne    daa5 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    dad2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dad9:	eb 2a                	jmp    db05 <deflateDynamic+0x367>
    dadb:	8b 55 b8             	mov    -0x48(%ebp),%edx
    dade:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dae1:	01 d0                	add    %edx,%eax
    dae3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    daea:	8b 45 f0             	mov    -0x10(%ebp),%eax
    daed:	01 c2                	add    %eax,%edx
    daef:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    daf5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    daf8:	c1 e1 02             	shl    $0x2,%ecx
    dafb:	01 c8                	add    %ecx,%eax
    dafd:	8b 00                	mov    (%eax),%eax
    daff:	89 02                	mov    %eax,(%edx)
    db01:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    db05:	8b 45 e8             	mov    -0x18(%ebp),%eax
    db08:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    db0b:	75 ce                	jne    dadb <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    db0d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    db14:	e9 3b 02 00 00       	jmp    dd54 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    db19:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    db20:	eb 04                	jmp    db26 <deflateDynamic+0x388>
    db22:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    db26:	8b 55 e8             	mov    -0x18(%ebp),%edx
    db29:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db2c:	01 d0                	add    %edx,%eax
    db2e:	8d 50 01             	lea    0x1(%eax),%edx
    db31:	8b 45 b0             	mov    -0x50(%ebp),%eax
    db34:	39 c2                	cmp    %eax,%edx
    db36:	73 2e                	jae    db66 <deflateDynamic+0x3c8>
    db38:	8b 55 e8             	mov    -0x18(%ebp),%edx
    db3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db3e:	01 d0                	add    %edx,%eax
    db40:	83 c0 01             	add    $0x1,%eax
    db43:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    db4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    db4d:	01 d0                	add    %edx,%eax
    db4f:	8b 10                	mov    (%eax),%edx
    db51:	8b 45 e8             	mov    -0x18(%ebp),%eax
    db54:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    db5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    db5e:	01 c8                	add    %ecx,%eax
    db60:	8b 00                	mov    (%eax),%eax
    db62:	39 c2                	cmp    %eax,%edx
    db64:	74 bc                	je     db22 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    db66:	8b 45 e8             	mov    -0x18(%ebp),%eax
    db69:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    db70:	8b 45 f0             	mov    -0x10(%ebp),%eax
    db73:	01 d0                	add    %edx,%eax
    db75:	8b 00                	mov    (%eax),%eax
    db77:	85 c0                	test   %eax,%eax
    db79:	0f 85 a9 00 00 00    	jne    dc28 <deflateDynamic+0x48a>
    db7f:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    db83:	0f 86 9f 00 00 00    	jbe    dc28 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    db89:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    db8d:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    db91:	77 3a                	ja     dbcd <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    db93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    db96:	8d 50 01             	lea    0x1(%eax),%edx
    db99:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    db9c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dba3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dba6:	01 d0                	add    %edx,%eax
    dba8:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    dbae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dbb1:	8d 50 01             	lea    0x1(%eax),%edx
    dbb4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dbb7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dbbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dbc1:	01 d0                	add    %edx,%eax
    dbc3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dbc6:	83 ea 03             	sub    $0x3,%edx
    dbc9:	89 10                	mov    %edx,(%eax)
    dbcb:	eb 48                	jmp    dc15 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    dbcd:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    dbd4:	76 07                	jbe    dbdd <deflateDynamic+0x43f>
    dbd6:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    dbdd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dbe0:	8d 50 01             	lea    0x1(%eax),%edx
    dbe3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dbe6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dbed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dbf0:	01 d0                	add    %edx,%eax
    dbf2:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    dbf8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dbfb:	8d 50 01             	lea    0x1(%eax),%edx
    dbfe:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dc01:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dc08:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dc0b:	01 d0                	add    %edx,%eax
    dc0d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dc10:	83 ea 0b             	sub    $0xb,%edx
    dc13:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    dc15:	8b 55 e8             	mov    -0x18(%ebp),%edx
    dc18:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dc1b:	01 d0                	add    %edx,%eax
    dc1d:	83 e8 01             	sub    $0x1,%eax
    dc20:	89 45 e8             	mov    %eax,-0x18(%ebp)
    dc23:	e9 28 01 00 00       	jmp    dd50 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    dc28:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    dc2c:	0f 86 f6 00 00 00    	jbe    dd28 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    dc32:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dc35:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    dc3a:	f7 e2                	mul    %edx
    dc3c:	89 d0                	mov    %edx,%eax
    dc3e:	c1 e8 02             	shr    $0x2,%eax
    dc41:	89 45 ac             	mov    %eax,-0x54(%ebp)
    dc44:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    dc47:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    dc4c:	89 c8                	mov    %ecx,%eax
    dc4e:	f7 e2                	mul    %edx
    dc50:	c1 ea 02             	shr    $0x2,%edx
    dc53:	89 d0                	mov    %edx,%eax
    dc55:	01 c0                	add    %eax,%eax
    dc57:	01 d0                	add    %edx,%eax
    dc59:	01 c0                	add    %eax,%eax
    dc5b:	29 c1                	sub    %eax,%ecx
    dc5d:	89 c8                	mov    %ecx,%eax
    dc5f:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    dc62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dc65:	8d 50 01             	lea    0x1(%eax),%edx
    dc68:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dc6b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dc72:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dc75:	01 c2                	add    %eax,%edx
    dc77:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dc7a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    dc81:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc84:	01 c8                	add    %ecx,%eax
    dc86:	8b 00                	mov    (%eax),%eax
    dc88:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    dc8a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    dc91:	eb 3a                	jmp    dccd <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    dc93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dc96:	8d 50 01             	lea    0x1(%eax),%edx
    dc99:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dc9c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dca3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dca6:	01 d0                	add    %edx,%eax
    dca8:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    dcae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dcb1:	8d 50 01             	lea    0x1(%eax),%edx
    dcb4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dcb7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dcbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dcc1:	01 d0                	add    %edx,%eax
    dcc3:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    dcc9:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    dccd:	8b 45 d8             	mov    -0x28(%ebp),%eax
    dcd0:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    dcd3:	72 be                	jb     dc93 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    dcd5:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    dcd9:	76 3a                	jbe    dd15 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    dcdb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dcde:	8d 50 01             	lea    0x1(%eax),%edx
    dce1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dce4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dceb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dcee:	01 d0                	add    %edx,%eax
    dcf0:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    dcf6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dcf9:	8d 50 01             	lea    0x1(%eax),%edx
    dcfc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dcff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dd06:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dd09:	01 d0                	add    %edx,%eax
    dd0b:	8b 55 a8             	mov    -0x58(%ebp),%edx
    dd0e:	83 ea 03             	sub    $0x3,%edx
    dd11:	89 10                	mov    %edx,(%eax)
    dd13:	eb 06                	jmp    dd1b <deflateDynamic+0x57d>
        }
        else j -= rest;
    dd15:	8b 45 a8             	mov    -0x58(%ebp),%eax
    dd18:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    dd1b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    dd1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dd21:	01 d0                	add    %edx,%eax
    dd23:	89 45 e8             	mov    %eax,-0x18(%ebp)
    dd26:	eb 28                	jmp    dd50 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    dd28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dd2b:	8d 50 01             	lea    0x1(%eax),%edx
    dd2e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    dd31:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dd38:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dd3b:	01 c2                	add    %eax,%edx
    dd3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dd40:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    dd47:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dd4a:	01 c8                	add    %ecx,%eax
    dd4c:	8b 00                	mov    (%eax),%eax
    dd4e:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    dd50:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    dd54:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dd57:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    dd5a:	0f 85 b9 fd ff ff    	jne    db19 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    dd60:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dd67:	eb 42                	jmp    ddab <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    dd69:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dd6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dd73:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dd76:	01 d0                	add    %edx,%eax
    dd78:	8b 00                	mov    (%eax),%eax
    dd7a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dd81:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dd84:	01 d0                	add    %edx,%eax
    dd86:	8b 10                	mov    (%eax),%edx
    dd88:	83 c2 01             	add    $0x1,%edx
    dd8b:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    dd8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dd90:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dd97:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dd9a:	01 d0                	add    %edx,%eax
    dd9c:	8b 00                	mov    (%eax),%eax
    dd9e:	83 f8 0f             	cmp    $0xf,%eax
    dda1:	76 04                	jbe    dda7 <deflateDynamic+0x609>
    dda3:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    dda7:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ddab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ddae:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    ddb1:	75 b6                	jne    dd69 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    ddb3:	83 ec 0c             	sub    $0xc,%esp
    ddb6:	6a 07                	push   $0x7
    ddb8:	6a 13                	push   $0x13
    ddba:	6a 13                	push   $0x13
    ddbc:	ff 75 cc             	pushl  -0x34(%ebp)
    ddbf:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    ddc5:	50                   	push   %eax
    ddc6:	e8 fe dd ff ff       	call   bbc9 <HuffmanTree_makeFromFrequencies>
    ddcb:	83 c4 20             	add    $0x20,%esp
    ddce:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    ddd1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ddd5:	0f 85 8a 02 00 00    	jne    e065 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    dddb:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    dde2:	eb 04                	jmp    dde8 <deflateDynamic+0x64a>
      numcodes_cl--;
    dde4:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    dde8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ddeb:	83 f8 04             	cmp    $0x4,%eax
    ddee:	76 1e                	jbe    de0e <deflateDynamic+0x670>
    ddf0:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    ddf6:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ddf9:	83 ea 01             	sub    $0x1,%edx
    ddfc:	8b 14 95 40 0a 02 00 	mov    0x20a40(,%edx,4),%edx
    de03:	c1 e2 02             	shl    $0x2,%edx
    de06:	01 d0                	add    %edx,%eax
    de08:	8b 00                	mov    (%eax),%eax
    de0a:	85 c0                	test   %eax,%eax
    de0c:	74 d6                	je     dde4 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    de0e:	83 ec 04             	sub    $0x4,%esp
    de11:	6a 01                	push   $0x1
    de13:	ff 75 c4             	pushl  -0x3c(%ebp)
    de16:	ff 75 08             	pushl  0x8(%ebp)
    de19:	e8 67 c3 ff ff       	call   a185 <writeBits>
    de1e:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    de21:	83 ec 04             	sub    $0x4,%esp
    de24:	6a 01                	push   $0x1
    de26:	6a 00                	push   $0x0
    de28:	ff 75 08             	pushl  0x8(%ebp)
    de2b:	e8 55 c3 ff ff       	call   a185 <writeBits>
    de30:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    de33:	83 ec 04             	sub    $0x4,%esp
    de36:	6a 01                	push   $0x1
    de38:	6a 01                	push   $0x1
    de3a:	ff 75 08             	pushl  0x8(%ebp)
    de3d:	e8 43 c3 ff ff       	call   a185 <writeBits>
    de42:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    de45:	8b 45 b8             	mov    -0x48(%ebp),%eax
    de48:	2d 01 01 00 00       	sub    $0x101,%eax
    de4d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    de50:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    de53:	83 e8 01             	sub    $0x1,%eax
    de56:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    de59:	8b 45 e0             	mov    -0x20(%ebp),%eax
    de5c:	83 e8 04             	sub    $0x4,%eax
    de5f:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    de62:	83 ec 04             	sub    $0x4,%esp
    de65:	6a 05                	push   $0x5
    de67:	ff 75 a4             	pushl  -0x5c(%ebp)
    de6a:	ff 75 08             	pushl  0x8(%ebp)
    de6d:	e8 13 c3 ff ff       	call   a185 <writeBits>
    de72:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    de75:	83 ec 04             	sub    $0x4,%esp
    de78:	6a 05                	push   $0x5
    de7a:	ff 75 a0             	pushl  -0x60(%ebp)
    de7d:	ff 75 08             	pushl  0x8(%ebp)
    de80:	e8 00 c3 ff ff       	call   a185 <writeBits>
    de85:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    de88:	83 ec 04             	sub    $0x4,%esp
    de8b:	6a 04                	push   $0x4
    de8d:	ff 75 9c             	pushl  -0x64(%ebp)
    de90:	ff 75 08             	pushl  0x8(%ebp)
    de93:	e8 ed c2 ff ff       	call   a185 <writeBits>
    de98:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    de9b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dea2:	eb 2c                	jmp    ded0 <deflateDynamic+0x732>
    dea4:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    deaa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dead:	8b 04 85 40 0a 02 00 	mov    0x20a40(,%eax,4),%eax
    deb4:	c1 e0 02             	shl    $0x2,%eax
    deb7:	01 d0                	add    %edx,%eax
    deb9:	8b 00                	mov    (%eax),%eax
    debb:	83 ec 04             	sub    $0x4,%esp
    debe:	6a 03                	push   $0x3
    dec0:	50                   	push   %eax
    dec1:	ff 75 08             	pushl  0x8(%ebp)
    dec4:	e8 bc c2 ff ff       	call   a185 <writeBits>
    dec9:	83 c4 10             	add    $0x10,%esp
    decc:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ded0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ded3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    ded6:	75 cc                	jne    dea4 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    ded8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dedf:	e9 0a 01 00 00       	jmp    dfee <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    dee4:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    deea:	8b 55 e8             	mov    -0x18(%ebp),%edx
    deed:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    def4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    def7:	01 ca                	add    %ecx,%edx
    def9:	8b 12                	mov    (%edx),%edx
    defb:	c1 e2 02             	shl    $0x2,%edx
    defe:	01 d0                	add    %edx,%eax
    df00:	8b 00                	mov    (%eax),%eax
    df02:	89 c3                	mov    %eax,%ebx
    df04:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    df0a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    df0d:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    df14:	8b 55 ec             	mov    -0x14(%ebp),%edx
    df17:	01 ca                	add    %ecx,%edx
    df19:	8b 12                	mov    (%edx),%edx
    df1b:	c1 e2 02             	shl    $0x2,%edx
    df1e:	01 d0                	add    %edx,%eax
    df20:	8b 00                	mov    (%eax),%eax
    df22:	83 ec 04             	sub    $0x4,%esp
    df25:	53                   	push   %ebx
    df26:	50                   	push   %eax
    df27:	ff 75 08             	pushl  0x8(%ebp)
    df2a:	e8 ea c3 ff ff       	call   a319 <writeBitsReversed>
    df2f:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    df32:	8b 45 e8             	mov    -0x18(%ebp),%eax
    df35:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    df3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    df3f:	01 d0                	add    %edx,%eax
    df41:	8b 00                	mov    (%eax),%eax
    df43:	83 f8 10             	cmp    $0x10,%eax
    df46:	75 28                	jne    df70 <deflateDynamic+0x7d2>
    df48:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    df4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    df4f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    df56:	8b 45 ec             	mov    -0x14(%ebp),%eax
    df59:	01 d0                	add    %edx,%eax
    df5b:	8b 00                	mov    (%eax),%eax
    df5d:	83 ec 04             	sub    $0x4,%esp
    df60:	6a 02                	push   $0x2
    df62:	50                   	push   %eax
    df63:	ff 75 08             	pushl  0x8(%ebp)
    df66:	e8 1a c2 ff ff       	call   a185 <writeBits>
    df6b:	83 c4 10             	add    $0x10,%esp
    df6e:	eb 7a                	jmp    dfea <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    df70:	8b 45 e8             	mov    -0x18(%ebp),%eax
    df73:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    df7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    df7d:	01 d0                	add    %edx,%eax
    df7f:	8b 00                	mov    (%eax),%eax
    df81:	83 f8 11             	cmp    $0x11,%eax
    df84:	75 28                	jne    dfae <deflateDynamic+0x810>
    df86:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    df8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    df8d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    df94:	8b 45 ec             	mov    -0x14(%ebp),%eax
    df97:	01 d0                	add    %edx,%eax
    df99:	8b 00                	mov    (%eax),%eax
    df9b:	83 ec 04             	sub    $0x4,%esp
    df9e:	6a 03                	push   $0x3
    dfa0:	50                   	push   %eax
    dfa1:	ff 75 08             	pushl  0x8(%ebp)
    dfa4:	e8 dc c1 ff ff       	call   a185 <writeBits>
    dfa9:	83 c4 10             	add    $0x10,%esp
    dfac:	eb 3c                	jmp    dfea <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    dfae:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dfb1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dfb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dfbb:	01 d0                	add    %edx,%eax
    dfbd:	8b 00                	mov    (%eax),%eax
    dfbf:	83 f8 12             	cmp    $0x12,%eax
    dfc2:	75 26                	jne    dfea <deflateDynamic+0x84c>
    dfc4:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    dfc8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dfcb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    dfd2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dfd5:	01 d0                	add    %edx,%eax
    dfd7:	8b 00                	mov    (%eax),%eax
    dfd9:	83 ec 04             	sub    $0x4,%esp
    dfdc:	6a 07                	push   $0x7
    dfde:	50                   	push   %eax
    dfdf:	ff 75 08             	pushl  0x8(%ebp)
    dfe2:	e8 9e c1 ff ff       	call   a185 <writeBits>
    dfe7:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    dfea:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    dfee:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dff1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    dff4:	0f 85 ea fe ff ff    	jne    dee4 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    dffa:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    e000:	50                   	push   %eax
    e001:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    e007:	50                   	push   %eax
    e008:	8d 45 90             	lea    -0x70(%ebp),%eax
    e00b:	50                   	push   %eax
    e00c:	ff 75 08             	pushl  0x8(%ebp)
    e00f:	e8 4f f6 ff ff       	call   d663 <writeLZ77data>
    e014:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    e017:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    e01d:	05 00 04 00 00       	add    $0x400,%eax
    e022:	8b 00                	mov    (%eax),%eax
    e024:	85 c0                	test   %eax,%eax
    e026:	75 09                	jne    e031 <deflateDynamic+0x893>
    e028:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    e02f:	eb 35                	jmp    e066 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    e031:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    e037:	05 00 04 00 00       	add    $0x400,%eax
    e03c:	8b 00                	mov    (%eax),%eax
    e03e:	89 c2                	mov    %eax,%edx
    e040:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    e046:	05 00 04 00 00       	add    $0x400,%eax
    e04b:	8b 00                	mov    (%eax),%eax
    e04d:	83 ec 04             	sub    $0x4,%esp
    e050:	52                   	push   %edx
    e051:	50                   	push   %eax
    e052:	ff 75 08             	pushl  0x8(%ebp)
    e055:	e8 bf c2 ff ff       	call   a319 <writeBitsReversed>
    e05a:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    e05d:	eb 07                	jmp    e066 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    e05f:	90                   	nop
    e060:	eb 04                	jmp    e066 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    e062:	90                   	nop
    e063:	eb 01                	jmp    e066 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    e065:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    e066:	83 ec 0c             	sub    $0xc,%esp
    e069:	8d 45 90             	lea    -0x70(%ebp),%eax
    e06c:	50                   	push   %eax
    e06d:	e8 73 bd ff ff       	call   9de5 <uivector_cleanup>
    e072:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    e075:	83 ec 0c             	sub    $0xc,%esp
    e078:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    e07e:	50                   	push   %eax
    e07f:	e8 3a cb ff ff       	call   abbe <HuffmanTree_cleanup>
    e084:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    e087:	83 ec 0c             	sub    $0xc,%esp
    e08a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    e090:	50                   	push   %eax
    e091:	e8 28 cb ff ff       	call   abbe <HuffmanTree_cleanup>
    e096:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    e099:	83 ec 0c             	sub    $0xc,%esp
    e09c:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e0a2:	50                   	push   %eax
    e0a3:	e8 16 cb ff ff       	call   abbe <HuffmanTree_cleanup>
    e0a8:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    e0ab:	83 ec 0c             	sub    $0xc,%esp
    e0ae:	ff 75 d4             	pushl  -0x2c(%ebp)
    e0b1:	e8 08 bc ff ff       	call   9cbe <lodepng_free>
    e0b6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    e0b9:	83 ec 0c             	sub    $0xc,%esp
    e0bc:	ff 75 d0             	pushl  -0x30(%ebp)
    e0bf:	e8 fa bb ff ff       	call   9cbe <lodepng_free>
    e0c4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    e0c7:	83 ec 0c             	sub    $0xc,%esp
    e0ca:	ff 75 cc             	pushl  -0x34(%ebp)
    e0cd:	e8 ec bb ff ff       	call   9cbe <lodepng_free>
    e0d2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    e0d5:	83 ec 0c             	sub    $0xc,%esp
    e0d8:	ff 75 f0             	pushl  -0x10(%ebp)
    e0db:	e8 de bb ff ff       	call   9cbe <lodepng_free>
    e0e0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    e0e3:	83 ec 0c             	sub    $0xc,%esp
    e0e6:	ff 75 ec             	pushl  -0x14(%ebp)
    e0e9:	e8 d0 bb ff ff       	call   9cbe <lodepng_free>
    e0ee:	83 c4 10             	add    $0x10,%esp

  return error;
    e0f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e0f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e0f7:	c9                   	leave  
    e0f8:	c3                   	ret    

0000e0f9 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    e0f9:	55                   	push   %ebp
    e0fa:	89 e5                	mov    %esp,%ebp
    e0fc:	53                   	push   %ebx
    e0fd:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    e100:	8b 45 20             	mov    0x20(%ebp),%eax
    e103:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    e106:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    e10d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    e110:	50                   	push   %eax
    e111:	e8 7b ca ff ff       	call   ab91 <HuffmanTree_init>
    e116:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    e119:	8d 45 bc             	lea    -0x44(%ebp),%eax
    e11c:	50                   	push   %eax
    e11d:	e8 6f ca ff ff       	call   ab91 <HuffmanTree_init>
    e122:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    e125:	83 ec 0c             	sub    $0xc,%esp
    e128:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    e12b:	50                   	push   %eax
    e12c:	e8 41 db ff ff       	call   bc72 <generateFixedLitLenTree>
    e131:	83 c4 10             	add    $0x10,%esp
    e134:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    e137:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e13b:	75 12                	jne    e14f <deflateFixed+0x56>
    e13d:	83 ec 0c             	sub    $0xc,%esp
    e140:	8d 45 bc             	lea    -0x44(%ebp),%eax
    e143:	50                   	push   %eax
    e144:	e8 30 dc ff ff       	call   bd79 <generateFixedDistanceTree>
    e149:	83 c4 10             	add    $0x10,%esp
    e14c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    e14f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e153:	0f 85 3a 01 00 00    	jne    e293 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    e159:	83 ec 04             	sub    $0x4,%esp
    e15c:	6a 01                	push   $0x1
    e15e:	ff 75 ec             	pushl  -0x14(%ebp)
    e161:	ff 75 08             	pushl  0x8(%ebp)
    e164:	e8 1c c0 ff ff       	call   a185 <writeBits>
    e169:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    e16c:	83 ec 04             	sub    $0x4,%esp
    e16f:	6a 01                	push   $0x1
    e171:	6a 01                	push   $0x1
    e173:	ff 75 08             	pushl  0x8(%ebp)
    e176:	e8 0a c0 ff ff       	call   a185 <writeBits>
    e17b:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    e17e:	83 ec 04             	sub    $0x4,%esp
    e181:	6a 01                	push   $0x1
    e183:	6a 00                	push   $0x0
    e185:	ff 75 08             	pushl  0x8(%ebp)
    e188:	e8 f8 bf ff ff       	call   a185 <writeBits>
    e18d:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    e190:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e193:	8b 40 04             	mov    0x4(%eax),%eax
    e196:	85 c0                	test   %eax,%eax
    e198:	74 77                	je     e211 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    e19a:	83 ec 0c             	sub    $0xc,%esp
    e19d:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e1a0:	50                   	push   %eax
    e1a1:	e8 e8 bc ff ff       	call   9e8e <uivector_init>
    e1a6:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    e1a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e1ac:	8b 58 14             	mov    0x14(%eax),%ebx
    e1af:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e1b2:	8b 48 10             	mov    0x10(%eax),%ecx
    e1b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e1b8:	8b 50 0c             	mov    0xc(%eax),%edx
    e1bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e1be:	8b 40 08             	mov    0x8(%eax),%eax
    e1c1:	83 ec 0c             	sub    $0xc,%esp
    e1c4:	53                   	push   %ebx
    e1c5:	51                   	push   %ecx
    e1c6:	52                   	push   %edx
    e1c7:	50                   	push   %eax
    e1c8:	ff 75 18             	pushl  0x18(%ebp)
    e1cb:	ff 75 14             	pushl  0x14(%ebp)
    e1ce:	ff 75 10             	pushl  0x10(%ebp)
    e1d1:	ff 75 0c             	pushl  0xc(%ebp)
    e1d4:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e1d7:	50                   	push   %eax
    e1d8:	e8 c7 ed ff ff       	call   cfa4 <encodeLZ77>
    e1dd:	83 c4 30             	add    $0x30,%esp
    e1e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    e1e3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e1e7:	75 17                	jne    e200 <deflateFixed+0x107>
    e1e9:	8d 45 bc             	lea    -0x44(%ebp),%eax
    e1ec:	50                   	push   %eax
    e1ed:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    e1f0:	50                   	push   %eax
    e1f1:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e1f4:	50                   	push   %eax
    e1f5:	ff 75 08             	pushl  0x8(%ebp)
    e1f8:	e8 66 f4 ff ff       	call   d663 <writeLZ77data>
    e1fd:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    e200:	83 ec 0c             	sub    $0xc,%esp
    e203:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e206:	50                   	push   %eax
    e207:	e8 d9 bb ff ff       	call   9de5 <uivector_cleanup>
    e20c:	83 c4 10             	add    $0x10,%esp
    e20f:	eb 56                	jmp    e267 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    e211:	8b 45 14             	mov    0x14(%ebp),%eax
    e214:	89 45 f0             	mov    %eax,-0x10(%ebp)
    e217:	eb 46                	jmp    e25f <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    e219:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e21c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e21f:	8b 55 10             	mov    0x10(%ebp),%edx
    e222:	01 ca                	add    %ecx,%edx
    e224:	0f b6 12             	movzbl (%edx),%edx
    e227:	0f b6 d2             	movzbl %dl,%edx
    e22a:	c1 e2 02             	shl    $0x2,%edx
    e22d:	01 d0                	add    %edx,%eax
    e22f:	8b 00                	mov    (%eax),%eax
    e231:	89 c3                	mov    %eax,%ebx
    e233:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e236:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e239:	8b 55 10             	mov    0x10(%ebp),%edx
    e23c:	01 ca                	add    %ecx,%edx
    e23e:	0f b6 12             	movzbl (%edx),%edx
    e241:	0f b6 d2             	movzbl %dl,%edx
    e244:	c1 e2 02             	shl    $0x2,%edx
    e247:	01 d0                	add    %edx,%eax
    e249:	8b 00                	mov    (%eax),%eax
    e24b:	83 ec 04             	sub    $0x4,%esp
    e24e:	53                   	push   %ebx
    e24f:	50                   	push   %eax
    e250:	ff 75 08             	pushl  0x8(%ebp)
    e253:	e8 c1 c0 ff ff       	call   a319 <writeBitsReversed>
    e258:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    e25b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e25f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e262:	3b 45 18             	cmp    0x18(%ebp),%eax
    e265:	7c b2                	jl     e219 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    e267:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e26b:	75 26                	jne    e293 <deflateFixed+0x19a>
    e26d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e270:	05 00 04 00 00       	add    $0x400,%eax
    e275:	8b 00                	mov    (%eax),%eax
    e277:	89 c2                	mov    %eax,%edx
    e279:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e27c:	05 00 04 00 00       	add    $0x400,%eax
    e281:	8b 00                	mov    (%eax),%eax
    e283:	83 ec 04             	sub    $0x4,%esp
    e286:	52                   	push   %edx
    e287:	50                   	push   %eax
    e288:	ff 75 08             	pushl  0x8(%ebp)
    e28b:	e8 89 c0 ff ff       	call   a319 <writeBitsReversed>
    e290:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    e293:	83 ec 0c             	sub    $0xc,%esp
    e296:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    e299:	50                   	push   %eax
    e29a:	e8 1f c9 ff ff       	call   abbe <HuffmanTree_cleanup>
    e29f:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    e2a2:	83 ec 0c             	sub    $0xc,%esp
    e2a5:	8d 45 bc             	lea    -0x44(%ebp),%eax
    e2a8:	50                   	push   %eax
    e2a9:	e8 10 c9 ff ff       	call   abbe <HuffmanTree_cleanup>
    e2ae:	83 c4 10             	add    $0x10,%esp

  return error;
    e2b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e2b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e2b7:	c9                   	leave  
    e2b8:	c3                   	ret    

0000e2b9 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    e2b9:	55                   	push   %ebp
    e2ba:	89 e5                	mov    %esp,%ebp
    e2bc:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    e2bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    e2c6:	ff 75 08             	pushl  0x8(%ebp)
    e2c9:	8d 45 bc             	lea    -0x44(%ebp),%eax
    e2cc:	50                   	push   %eax
    e2cd:	e8 9e be ff ff       	call   a170 <LodePNGBitWriter_init>
    e2d2:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    e2d5:	8b 45 14             	mov    0x14(%ebp),%eax
    e2d8:	8b 00                	mov    (%eax),%eax
    e2da:	83 f8 02             	cmp    $0x2,%eax
    e2dd:	76 0a                	jbe    e2e9 <lodepng_deflatev+0x30>
    e2df:	b8 3d 00 00 00       	mov    $0x3d,%eax
    e2e4:	e9 68 01 00 00       	jmp    e451 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    e2e9:	8b 45 14             	mov    0x14(%ebp),%eax
    e2ec:	8b 00                	mov    (%eax),%eax
    e2ee:	85 c0                	test   %eax,%eax
    e2f0:	75 16                	jne    e308 <lodepng_deflatev+0x4f>
    e2f2:	ff 75 10             	pushl  0x10(%ebp)
    e2f5:	ff 75 0c             	pushl  0xc(%ebp)
    e2f8:	ff 75 08             	pushl  0x8(%ebp)
    e2fb:	e8 01 f2 ff ff       	call   d501 <deflateNoCompression>
    e300:	83 c4 0c             	add    $0xc,%esp
    e303:	e9 49 01 00 00       	jmp    e451 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    e308:	8b 45 14             	mov    0x14(%ebp),%eax
    e30b:	8b 00                	mov    (%eax),%eax
    e30d:	83 f8 01             	cmp    $0x1,%eax
    e310:	75 08                	jne    e31a <lodepng_deflatev+0x61>
    e312:	8b 45 10             	mov    0x10(%ebp),%eax
    e315:	89 45 ec             	mov    %eax,-0x14(%ebp)
    e318:	eb 2c                	jmp    e346 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    e31a:	8b 45 10             	mov    0x10(%ebp),%eax
    e31d:	c1 e8 03             	shr    $0x3,%eax
    e320:	83 c0 08             	add    $0x8,%eax
    e323:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    e326:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    e32d:	7f 07                	jg     e336 <lodepng_deflatev+0x7d>
    e32f:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    e336:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    e33d:	7e 07                	jle    e346 <lodepng_deflatev+0x8d>
    e33f:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    e346:	8b 55 10             	mov    0x10(%ebp),%edx
    e349:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e34c:	01 d0                	add    %edx,%eax
    e34e:	83 e8 01             	sub    $0x1,%eax
    e351:	99                   	cltd   
    e352:	f7 7d ec             	idivl  -0x14(%ebp)
    e355:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    e358:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e35c:	75 07                	jne    e365 <lodepng_deflatev+0xac>
    e35e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    e365:	8b 45 14             	mov    0x14(%ebp),%eax
    e368:	8b 40 08             	mov    0x8(%eax),%eax
    e36b:	83 ec 08             	sub    $0x8,%esp
    e36e:	50                   	push   %eax
    e36f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e372:	50                   	push   %eax
    e373:	e8 1c e8 ff ff       	call   cb94 <hash_init>
    e378:	83 c4 10             	add    $0x10,%esp
    e37b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    e37e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e382:	0f 85 b7 00 00 00    	jne    e43f <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    e388:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e38f:	e9 99 00 00 00       	jmp    e42d <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    e394:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e397:	83 e8 01             	sub    $0x1,%eax
    e39a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e39d:	0f 94 c0             	sete   %al
    e3a0:	0f b6 c0             	movzbl %al,%eax
    e3a3:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    e3a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e3a9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e3ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    e3b0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e3b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e3b6:	01 d0                	add    %edx,%eax
    e3b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    e3bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e3be:	3b 45 10             	cmp    0x10(%ebp),%eax
    e3c1:	7e 06                	jle    e3c9 <lodepng_deflatev+0x110>
    e3c3:	8b 45 10             	mov    0x10(%ebp),%eax
    e3c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    e3c9:	8b 45 14             	mov    0x14(%ebp),%eax
    e3cc:	8b 00                	mov    (%eax),%eax
    e3ce:	83 f8 01             	cmp    $0x1,%eax
    e3d1:	75 27                	jne    e3fa <lodepng_deflatev+0x141>
    e3d3:	83 ec 04             	sub    $0x4,%esp
    e3d6:	ff 75 e0             	pushl  -0x20(%ebp)
    e3d9:	ff 75 14             	pushl  0x14(%ebp)
    e3dc:	ff 75 e4             	pushl  -0x1c(%ebp)
    e3df:	ff 75 dc             	pushl  -0x24(%ebp)
    e3e2:	ff 75 0c             	pushl  0xc(%ebp)
    e3e5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e3e8:	50                   	push   %eax
    e3e9:	8d 45 bc             	lea    -0x44(%ebp),%eax
    e3ec:	50                   	push   %eax
    e3ed:	e8 07 fd ff ff       	call   e0f9 <deflateFixed>
    e3f2:	83 c4 20             	add    $0x20,%esp
    e3f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e3f8:	eb 2f                	jmp    e429 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    e3fa:	8b 45 14             	mov    0x14(%ebp),%eax
    e3fd:	8b 00                	mov    (%eax),%eax
    e3ff:	83 f8 02             	cmp    $0x2,%eax
    e402:	75 25                	jne    e429 <lodepng_deflatev+0x170>
    e404:	83 ec 04             	sub    $0x4,%esp
    e407:	ff 75 e0             	pushl  -0x20(%ebp)
    e40a:	ff 75 14             	pushl  0x14(%ebp)
    e40d:	ff 75 e4             	pushl  -0x1c(%ebp)
    e410:	ff 75 dc             	pushl  -0x24(%ebp)
    e413:	ff 75 0c             	pushl  0xc(%ebp)
    e416:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e419:	50                   	push   %eax
    e41a:	8d 45 bc             	lea    -0x44(%ebp),%eax
    e41d:	50                   	push   %eax
    e41e:	e8 7b f3 ff ff       	call   d79e <deflateDynamic>
    e423:	83 c4 20             	add    $0x20,%esp
    e426:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    e429:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e42d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e430:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e433:	74 0a                	je     e43f <lodepng_deflatev+0x186>
    e435:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e439:	0f 84 55 ff ff ff    	je     e394 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    e43f:	83 ec 0c             	sub    $0xc,%esp
    e442:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e445:	50                   	push   %eax
    e446:	e8 08 e9 ff ff       	call   cd53 <hash_cleanup>
    e44b:	83 c4 10             	add    $0x10,%esp

  return error;
    e44e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e451:	c9                   	leave  
    e452:	c3                   	ret    

0000e453 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    e453:	55                   	push   %ebp
    e454:	89 e5                	mov    %esp,%ebp
    e456:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    e459:	8b 45 0c             	mov    0xc(%ebp),%eax
    e45c:	8b 08                	mov    (%eax),%ecx
    e45e:	8b 45 08             	mov    0x8(%ebp),%eax
    e461:	8b 10                	mov    (%eax),%edx
    e463:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e466:	51                   	push   %ecx
    e467:	52                   	push   %edx
    e468:	50                   	push   %eax
    e469:	e8 f0 ba ff ff       	call   9f5e <ucvector_init>
    e46e:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    e471:	ff 75 18             	pushl  0x18(%ebp)
    e474:	ff 75 14             	pushl  0x14(%ebp)
    e477:	ff 75 10             	pushl  0x10(%ebp)
    e47a:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e47d:	50                   	push   %eax
    e47e:	e8 36 fe ff ff       	call   e2b9 <lodepng_deflatev>
    e483:	83 c4 10             	add    $0x10,%esp
    e486:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    e489:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e48c:	8b 45 08             	mov    0x8(%ebp),%eax
    e48f:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    e491:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e494:	8b 45 0c             	mov    0xc(%ebp),%eax
    e497:	89 10                	mov    %edx,(%eax)
  return error;
    e499:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e49c:	c9                   	leave  
    e49d:	c3                   	ret    

0000e49e <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    e49e:	55                   	push   %ebp
    e49f:	89 e5                	mov    %esp,%ebp
    e4a1:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    e4a4:	8b 45 18             	mov    0x18(%ebp),%eax
    e4a7:	8b 40 1c             	mov    0x1c(%eax),%eax
    e4aa:	85 c0                	test   %eax,%eax
    e4ac:	74 34                	je     e4e2 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    e4ae:	8b 45 18             	mov    0x18(%ebp),%eax
    e4b1:	8b 40 1c             	mov    0x1c(%eax),%eax
    e4b4:	83 ec 0c             	sub    $0xc,%esp
    e4b7:	ff 75 18             	pushl  0x18(%ebp)
    e4ba:	ff 75 14             	pushl  0x14(%ebp)
    e4bd:	ff 75 10             	pushl  0x10(%ebp)
    e4c0:	ff 75 0c             	pushl  0xc(%ebp)
    e4c3:	ff 75 08             	pushl  0x8(%ebp)
    e4c6:	ff d0                	call   *%eax
    e4c8:	83 c4 20             	add    $0x20,%esp
    e4cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    e4ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e4d2:	74 07                	je     e4db <deflate+0x3d>
    e4d4:	b8 6f 00 00 00       	mov    $0x6f,%eax
    e4d9:	eb 21                	jmp    e4fc <deflate+0x5e>
    e4db:	b8 00 00 00 00       	mov    $0x0,%eax
    e4e0:	eb 1a                	jmp    e4fc <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    e4e2:	83 ec 0c             	sub    $0xc,%esp
    e4e5:	ff 75 18             	pushl  0x18(%ebp)
    e4e8:	ff 75 14             	pushl  0x14(%ebp)
    e4eb:	ff 75 10             	pushl  0x10(%ebp)
    e4ee:	ff 75 0c             	pushl  0xc(%ebp)
    e4f1:	ff 75 08             	pushl  0x8(%ebp)
    e4f4:	e8 5a ff ff ff       	call   e453 <lodepng_deflate>
    e4f9:	83 c4 20             	add    $0x20,%esp
  }
}
    e4fc:	c9                   	leave  
    e4fd:	c3                   	ret    

0000e4fe <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    e4fe:	55                   	push   %ebp
    e4ff:	89 e5                	mov    %esp,%ebp
    e501:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    e504:	8b 45 08             	mov    0x8(%ebp),%eax
    e507:	0f b7 c0             	movzwl %ax,%eax
    e50a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    e50d:	8b 45 08             	mov    0x8(%ebp),%eax
    e510:	c1 e8 10             	shr    $0x10,%eax
    e513:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    e516:	e9 82 00 00 00       	jmp    e59d <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    e51b:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    e520:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    e527:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    e52b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    e52e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e531:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    e534:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e53b:	eb 1c                	jmp    e559 <update_adler32+0x5b>
      s1 += (*data++);
    e53d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e540:	8d 50 01             	lea    0x1(%eax),%edx
    e543:	89 55 0c             	mov    %edx,0xc(%ebp)
    e546:	0f b6 00             	movzbl (%eax),%eax
    e549:	0f b6 c0             	movzbl %al,%eax
    e54c:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    e54f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e552:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    e555:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e559:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e55c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e55f:	75 dc                	jne    e53d <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    e561:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    e564:	ba 71 80 07 80       	mov    $0x80078071,%edx
    e569:	89 c8                	mov    %ecx,%eax
    e56b:	f7 e2                	mul    %edx
    e56d:	89 d0                	mov    %edx,%eax
    e56f:	c1 e8 0f             	shr    $0xf,%eax
    e572:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    e578:	29 c1                	sub    %eax,%ecx
    e57a:	89 c8                	mov    %ecx,%eax
    e57c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    e57f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    e582:	ba 71 80 07 80       	mov    $0x80078071,%edx
    e587:	89 c8                	mov    %ecx,%eax
    e589:	f7 e2                	mul    %edx
    e58b:	89 d0                	mov    %edx,%eax
    e58d:	c1 e8 0f             	shr    $0xf,%eax
    e590:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    e596:	29 c1                	sub    %eax,%ecx
    e598:	89 c8                	mov    %ecx,%eax
    e59a:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    e59d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e5a1:	0f 85 74 ff ff ff    	jne    e51b <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    e5a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e5aa:	c1 e0 10             	shl    $0x10,%eax
    e5ad:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    e5b0:	c9                   	leave  
    e5b1:	c3                   	ret    

0000e5b2 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    e5b2:	55                   	push   %ebp
    e5b3:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    e5b5:	ff 75 0c             	pushl  0xc(%ebp)
    e5b8:	ff 75 08             	pushl  0x8(%ebp)
    e5bb:	6a 01                	push   $0x1
    e5bd:	e8 3c ff ff ff       	call   e4fe <update_adler32>
    e5c2:	83 c4 0c             	add    $0xc,%esp
}
    e5c5:	c9                   	leave  
    e5c6:	c3                   	ret    

0000e5c7 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    e5c7:	55                   	push   %ebp
    e5c8:	89 e5                	mov    %esp,%ebp
    e5ca:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e5cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    e5d4:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e5d8:	7f 0a                	jg     e5e4 <lodepng_zlib_decompressv+0x1d>
    e5da:	b8 35 00 00 00       	mov    $0x35,%eax
    e5df:	e9 27 01 00 00       	jmp    e70b <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    e5e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5e7:	0f b6 00             	movzbl (%eax),%eax
    e5ea:	0f b6 c0             	movzbl %al,%eax
    e5ed:	c1 e0 08             	shl    $0x8,%eax
    e5f0:	89 c2                	mov    %eax,%edx
    e5f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5f5:	83 c0 01             	add    $0x1,%eax
    e5f8:	0f b6 00             	movzbl (%eax),%eax
    e5fb:	0f b6 c0             	movzbl %al,%eax
    e5fe:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    e601:	ba 43 08 21 84       	mov    $0x84210843,%edx
    e606:	89 c8                	mov    %ecx,%eax
    e608:	f7 ea                	imul   %edx
    e60a:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    e60d:	c1 f8 04             	sar    $0x4,%eax
    e610:	89 c2                	mov    %eax,%edx
    e612:	89 c8                	mov    %ecx,%eax
    e614:	c1 f8 1f             	sar    $0x1f,%eax
    e617:	29 c2                	sub    %eax,%edx
    e619:	89 d0                	mov    %edx,%eax
    e61b:	89 c2                	mov    %eax,%edx
    e61d:	c1 e2 05             	shl    $0x5,%edx
    e620:	29 c2                	sub    %eax,%edx
    e622:	89 c8                	mov    %ecx,%eax
    e624:	29 d0                	sub    %edx,%eax
    e626:	85 c0                	test   %eax,%eax
    e628:	74 0a                	je     e634 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    e62a:	b8 18 00 00 00       	mov    $0x18,%eax
    e62f:	e9 d7 00 00 00       	jmp    e70b <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    e634:	8b 45 0c             	mov    0xc(%ebp),%eax
    e637:	0f b6 00             	movzbl (%eax),%eax
    e63a:	0f b6 c0             	movzbl %al,%eax
    e63d:	83 e0 0f             	and    $0xf,%eax
    e640:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    e643:	8b 45 0c             	mov    0xc(%ebp),%eax
    e646:	0f b6 00             	movzbl (%eax),%eax
    e649:	c0 e8 04             	shr    $0x4,%al
    e64c:	0f b6 c0             	movzbl %al,%eax
    e64f:	83 e0 0f             	and    $0xf,%eax
    e652:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    e655:	8b 45 0c             	mov    0xc(%ebp),%eax
    e658:	83 c0 01             	add    $0x1,%eax
    e65b:	0f b6 00             	movzbl (%eax),%eax
    e65e:	c0 e8 05             	shr    $0x5,%al
    e661:	0f b6 c0             	movzbl %al,%eax
    e664:	83 e0 01             	and    $0x1,%eax
    e667:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    e66a:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    e66e:	75 06                	jne    e676 <lodepng_zlib_decompressv+0xaf>
    e670:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e674:	76 0a                	jbe    e680 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    e676:	b8 19 00 00 00       	mov    $0x19,%eax
    e67b:	e9 8b 00 00 00       	jmp    e70b <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    e680:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e684:	74 07                	je     e68d <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    e686:	b8 1a 00 00 00       	mov    $0x1a,%eax
    e68b:	eb 7e                	jmp    e70b <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    e68d:	8b 45 10             	mov    0x10(%ebp),%eax
    e690:	8d 50 fe             	lea    -0x2(%eax),%edx
    e693:	8b 45 0c             	mov    0xc(%ebp),%eax
    e696:	83 c0 02             	add    $0x2,%eax
    e699:	ff 75 14             	pushl  0x14(%ebp)
    e69c:	52                   	push   %edx
    e69d:	50                   	push   %eax
    e69e:	ff 75 08             	pushl  0x8(%ebp)
    e6a1:	e8 09 e3 ff ff       	call   c9af <inflatev>
    e6a6:	83 c4 10             	add    $0x10,%esp
    e6a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    e6ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e6b0:	74 05                	je     e6b7 <lodepng_zlib_decompressv+0xf0>
    e6b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e6b5:	eb 54                	jmp    e70b <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    e6b7:	8b 45 14             	mov    0x14(%ebp),%eax
    e6ba:	8b 00                	mov    (%eax),%eax
    e6bc:	85 c0                	test   %eax,%eax
    e6be:	75 46                	jne    e706 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    e6c0:	8b 45 10             	mov    0x10(%ebp),%eax
    e6c3:	8d 50 fc             	lea    -0x4(%eax),%edx
    e6c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6c9:	01 d0                	add    %edx,%eax
    e6cb:	83 ec 0c             	sub    $0xc,%esp
    e6ce:	50                   	push   %eax
    e6cf:	e8 47 b9 ff ff       	call   a01b <lodepng_read32bitInt>
    e6d4:	83 c4 10             	add    $0x10,%esp
    e6d7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    e6da:	8b 45 08             	mov    0x8(%ebp),%eax
    e6dd:	8b 40 04             	mov    0x4(%eax),%eax
    e6e0:	89 c2                	mov    %eax,%edx
    e6e2:	8b 45 08             	mov    0x8(%ebp),%eax
    e6e5:	8b 00                	mov    (%eax),%eax
    e6e7:	83 ec 08             	sub    $0x8,%esp
    e6ea:	52                   	push   %edx
    e6eb:	50                   	push   %eax
    e6ec:	e8 c1 fe ff ff       	call   e5b2 <adler32>
    e6f1:	83 c4 10             	add    $0x10,%esp
    e6f4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    e6f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e6fa:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e6fd:	74 07                	je     e706 <lodepng_zlib_decompressv+0x13f>
    e6ff:	b8 3a 00 00 00       	mov    $0x3a,%eax
    e704:	eb 05                	jmp    e70b <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    e706:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e70b:	c9                   	leave  
    e70c:	c3                   	ret    

0000e70d <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    e70d:	55                   	push   %ebp
    e70e:	89 e5                	mov    %esp,%ebp
    e710:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    e713:	8b 45 0c             	mov    0xc(%ebp),%eax
    e716:	8b 08                	mov    (%eax),%ecx
    e718:	8b 45 08             	mov    0x8(%ebp),%eax
    e71b:	8b 10                	mov    (%eax),%edx
    e71d:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e720:	51                   	push   %ecx
    e721:	52                   	push   %edx
    e722:	50                   	push   %eax
    e723:	e8 36 b8 ff ff       	call   9f5e <ucvector_init>
    e728:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    e72b:	ff 75 18             	pushl  0x18(%ebp)
    e72e:	ff 75 14             	pushl  0x14(%ebp)
    e731:	ff 75 10             	pushl  0x10(%ebp)
    e734:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e737:	50                   	push   %eax
    e738:	e8 8a fe ff ff       	call   e5c7 <lodepng_zlib_decompressv>
    e73d:	83 c4 10             	add    $0x10,%esp
    e740:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    e743:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e746:	8b 45 08             	mov    0x8(%ebp),%eax
    e749:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    e74b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e74e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e751:	89 10                	mov    %edx,(%eax)
  return error;
    e753:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e756:	c9                   	leave  
    e757:	c3                   	ret    

0000e758 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    e758:	55                   	push   %ebp
    e759:	89 e5                	mov    %esp,%ebp
    e75b:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    e75e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e761:	8b 40 0c             	mov    0xc(%eax),%eax
    e764:	85 c0                	test   %eax,%eax
    e766:	74 57                	je     e7bf <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    e768:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e76b:	8b 40 0c             	mov    0xc(%eax),%eax
    e76e:	83 ec 0c             	sub    $0xc,%esp
    e771:	ff 75 1c             	pushl  0x1c(%ebp)
    e774:	ff 75 18             	pushl  0x18(%ebp)
    e777:	ff 75 14             	pushl  0x14(%ebp)
    e77a:	ff 75 0c             	pushl  0xc(%ebp)
    e77d:	ff 75 08             	pushl  0x8(%ebp)
    e780:	ff d0                	call   *%eax
    e782:	83 c4 20             	add    $0x20,%esp
    e785:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    e788:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e78c:	0f 84 98 00 00 00    	je     e82a <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    e792:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    e799:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e79c:	8b 40 08             	mov    0x8(%eax),%eax
    e79f:	85 c0                	test   %eax,%eax
    e7a1:	0f 84 83 00 00 00    	je     e82a <zlib_decompress+0xd2>
    e7a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7aa:	8b 10                	mov    (%eax),%edx
    e7ac:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e7af:	8b 40 08             	mov    0x8(%eax),%eax
    e7b2:	39 c2                	cmp    %eax,%edx
    e7b4:	7e 74                	jle    e82a <zlib_decompress+0xd2>
    e7b6:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    e7bd:	eb 6b                	jmp    e82a <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    e7bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7c2:	8b 08                	mov    (%eax),%ecx
    e7c4:	8b 45 08             	mov    0x8(%ebp),%eax
    e7c7:	8b 10                	mov    (%eax),%edx
    e7c9:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e7cc:	83 ec 04             	sub    $0x4,%esp
    e7cf:	51                   	push   %ecx
    e7d0:	52                   	push   %edx
    e7d1:	50                   	push   %eax
    e7d2:	e8 87 b7 ff ff       	call   9f5e <ucvector_init>
    e7d7:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    e7da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    e7de:	74 22                	je     e802 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    e7e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7e3:	8b 10                	mov    (%eax),%edx
    e7e5:	8b 45 10             	mov    0x10(%ebp),%eax
    e7e8:	01 d0                	add    %edx,%eax
    e7ea:	83 ec 08             	sub    $0x8,%esp
    e7ed:	50                   	push   %eax
    e7ee:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e7f1:	50                   	push   %eax
    e7f2:	e8 00 b7 ff ff       	call   9ef7 <ucvector_resize>
    e7f7:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    e7fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7fd:	8b 00                	mov    (%eax),%eax
    e7ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    e802:	ff 75 1c             	pushl  0x1c(%ebp)
    e805:	ff 75 18             	pushl  0x18(%ebp)
    e808:	ff 75 14             	pushl  0x14(%ebp)
    e80b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e80e:	50                   	push   %eax
    e80f:	e8 b3 fd ff ff       	call   e5c7 <lodepng_zlib_decompressv>
    e814:	83 c4 10             	add    $0x10,%esp
    e817:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    e81a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e81d:	8b 45 08             	mov    0x8(%ebp),%eax
    e820:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    e822:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e825:	8b 45 0c             	mov    0xc(%ebp),%eax
    e828:	89 10                	mov    %edx,(%eax)
  }
  return error;
    e82a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e82d:	c9                   	leave  
    e82e:	c3                   	ret    

0000e82f <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    e82f:	55                   	push   %ebp
    e830:	89 e5                	mov    %esp,%ebp
    e832:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    e835:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    e83c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    e843:	83 ec 0c             	sub    $0xc,%esp
    e846:	ff 75 18             	pushl  0x18(%ebp)
    e849:	ff 75 14             	pushl  0x14(%ebp)
    e84c:	ff 75 10             	pushl  0x10(%ebp)
    e84f:	8d 45 d0             	lea    -0x30(%ebp),%eax
    e852:	50                   	push   %eax
    e853:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    e856:	50                   	push   %eax
    e857:	e8 42 fc ff ff       	call   e49e <deflate>
    e85c:	83 c4 20             	add    $0x20,%esp
    e85f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    e862:	8b 45 08             	mov    0x8(%ebp),%eax
    e865:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    e86b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e86e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    e874:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e878:	75 33                	jne    e8ad <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    e87a:	8b 45 d0             	mov    -0x30(%ebp),%eax
    e87d:	8d 50 06             	lea    0x6(%eax),%edx
    e880:	8b 45 0c             	mov    0xc(%ebp),%eax
    e883:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    e885:	8b 45 0c             	mov    0xc(%ebp),%eax
    e888:	8b 00                	mov    (%eax),%eax
    e88a:	83 ec 0c             	sub    $0xc,%esp
    e88d:	50                   	push   %eax
    e88e:	e8 0a b4 ff ff       	call   9c9d <lodepng_malloc>
    e893:	83 c4 10             	add    $0x10,%esp
    e896:	89 c2                	mov    %eax,%edx
    e898:	8b 45 08             	mov    0x8(%ebp),%eax
    e89b:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    e89d:	8b 45 08             	mov    0x8(%ebp),%eax
    e8a0:	8b 00                	mov    (%eax),%eax
    e8a2:	85 c0                	test   %eax,%eax
    e8a4:	75 07                	jne    e8ad <lodepng_zlib_compress+0x7e>
    e8a6:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    e8ad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e8b1:	0f 85 e2 00 00 00    	jne    e999 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    e8b7:	8b 45 14             	mov    0x14(%ebp),%eax
    e8ba:	83 ec 08             	sub    $0x8,%esp
    e8bd:	50                   	push   %eax
    e8be:	ff 75 10             	pushl  0x10(%ebp)
    e8c1:	e8 ec fc ff ff       	call   e5b2 <adler32>
    e8c6:	83 c4 10             	add    $0x10,%esp
    e8c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    e8cc:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    e8d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    e8da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    e8e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    e8eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e8ee:	01 d0                	add    %edx,%eax
    e8f0:	8d 14 00             	lea    (%eax,%eax,1),%edx
    e8f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e8f6:	01 d0                	add    %edx,%eax
    e8f8:	c1 e0 05             	shl    $0x5,%eax
    e8fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    e8fe:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e901:	ba 85 10 42 08       	mov    $0x8421085,%edx
    e906:	89 c8                	mov    %ecx,%eax
    e908:	f7 e2                	mul    %edx
    e90a:	89 c8                	mov    %ecx,%eax
    e90c:	29 d0                	sub    %edx,%eax
    e90e:	d1 e8                	shr    %eax
    e910:	01 d0                	add    %edx,%eax
    e912:	c1 e8 04             	shr    $0x4,%eax
    e915:	89 c2                	mov    %eax,%edx
    e917:	c1 e2 05             	shl    $0x5,%edx
    e91a:	29 c2                	sub    %eax,%edx
    e91c:	89 c8                	mov    %ecx,%eax
    e91e:	29 d0                	sub    %edx,%eax
    e920:	ba 1f 00 00 00       	mov    $0x1f,%edx
    e925:	29 c2                	sub    %eax,%edx
    e927:	89 d0                	mov    %edx,%eax
    e929:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    e92c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e92f:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    e932:	8b 45 08             	mov    0x8(%ebp),%eax
    e935:	8b 00                	mov    (%eax),%eax
    e937:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e93a:	c1 ea 08             	shr    $0x8,%edx
    e93d:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    e93f:	8b 45 08             	mov    0x8(%ebp),%eax
    e942:	8b 00                	mov    (%eax),%eax
    e944:	83 c0 01             	add    $0x1,%eax
    e947:	8b 55 dc             	mov    -0x24(%ebp),%edx
    e94a:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    e94c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e953:	eb 1e                	jmp    e973 <lodepng_zlib_compress+0x144>
    e955:	8b 45 08             	mov    0x8(%ebp),%eax
    e958:	8b 00                	mov    (%eax),%eax
    e95a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e95d:	83 c2 02             	add    $0x2,%edx
    e960:	01 c2                	add    %eax,%edx
    e962:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    e965:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e968:	01 c8                	add    %ecx,%eax
    e96a:	0f b6 00             	movzbl (%eax),%eax
    e96d:	88 02                	mov    %al,(%edx)
    e96f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e973:	8b 45 d0             	mov    -0x30(%ebp),%eax
    e976:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    e979:	75 da                	jne    e955 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    e97b:	8b 45 08             	mov    0x8(%ebp),%eax
    e97e:	8b 10                	mov    (%eax),%edx
    e980:	8b 45 0c             	mov    0xc(%ebp),%eax
    e983:	8b 00                	mov    (%eax),%eax
    e985:	83 e8 04             	sub    $0x4,%eax
    e988:	01 d0                	add    %edx,%eax
    e98a:	83 ec 08             	sub    $0x8,%esp
    e98d:	ff 75 ec             	pushl  -0x14(%ebp)
    e990:	50                   	push   %eax
    e991:	e8 c8 b6 ff ff       	call   a05e <lodepng_set32bitInt>
    e996:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    e999:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e99c:	83 ec 0c             	sub    $0xc,%esp
    e99f:	50                   	push   %eax
    e9a0:	e8 19 b3 ff ff       	call   9cbe <lodepng_free>
    e9a5:	83 c4 10             	add    $0x10,%esp
  return error;
    e9a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    e9ab:	c9                   	leave  
    e9ac:	c3                   	ret    

0000e9ad <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    e9ad:	55                   	push   %ebp
    e9ae:	89 e5                	mov    %esp,%ebp
    e9b0:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    e9b3:	8b 45 18             	mov    0x18(%ebp),%eax
    e9b6:	8b 40 18             	mov    0x18(%eax),%eax
    e9b9:	85 c0                	test   %eax,%eax
    e9bb:	74 34                	je     e9f1 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    e9bd:	8b 45 18             	mov    0x18(%ebp),%eax
    e9c0:	8b 40 18             	mov    0x18(%eax),%eax
    e9c3:	83 ec 0c             	sub    $0xc,%esp
    e9c6:	ff 75 18             	pushl  0x18(%ebp)
    e9c9:	ff 75 14             	pushl  0x14(%ebp)
    e9cc:	ff 75 10             	pushl  0x10(%ebp)
    e9cf:	ff 75 0c             	pushl  0xc(%ebp)
    e9d2:	ff 75 08             	pushl  0x8(%ebp)
    e9d5:	ff d0                	call   *%eax
    e9d7:	83 c4 20             	add    $0x20,%esp
    e9da:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    e9dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e9e1:	74 07                	je     e9ea <zlib_compress+0x3d>
    e9e3:	b8 6f 00 00 00       	mov    $0x6f,%eax
    e9e8:	eb 21                	jmp    ea0b <zlib_compress+0x5e>
    e9ea:	b8 00 00 00 00       	mov    $0x0,%eax
    e9ef:	eb 1a                	jmp    ea0b <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    e9f1:	83 ec 0c             	sub    $0xc,%esp
    e9f4:	ff 75 18             	pushl  0x18(%ebp)
    e9f7:	ff 75 14             	pushl  0x14(%ebp)
    e9fa:	ff 75 10             	pushl  0x10(%ebp)
    e9fd:	ff 75 0c             	pushl  0xc(%ebp)
    ea00:	ff 75 08             	pushl  0x8(%ebp)
    ea03:	e8 27 fe ff ff       	call   e82f <lodepng_zlib_compress>
    ea08:	83 c4 20             	add    $0x20,%esp
  }
}
    ea0b:	c9                   	leave  
    ea0c:	c3                   	ret    

0000ea0d <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    ea0d:	55                   	push   %ebp
    ea0e:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    ea10:	8b 45 08             	mov    0x8(%ebp),%eax
    ea13:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    ea19:	8b 45 08             	mov    0x8(%ebp),%eax
    ea1c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    ea23:	8b 45 08             	mov    0x8(%ebp),%eax
    ea26:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    ea2d:	8b 45 08             	mov    0x8(%ebp),%eax
    ea30:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    ea37:	8b 45 08             	mov    0x8(%ebp),%eax
    ea3a:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    ea41:	8b 45 08             	mov    0x8(%ebp),%eax
    ea44:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    ea4b:	8b 45 08             	mov    0x8(%ebp),%eax
    ea4e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    ea55:	8b 45 08             	mov    0x8(%ebp),%eax
    ea58:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    ea5f:	8b 45 08             	mov    0x8(%ebp),%eax
    ea62:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    ea69:	90                   	nop
    ea6a:	5d                   	pop    %ebp
    ea6b:	c3                   	ret    

0000ea6c <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    ea6c:	55                   	push   %ebp
    ea6d:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    ea6f:	8b 45 08             	mov    0x8(%ebp),%eax
    ea72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    ea78:	8b 45 08             	mov    0x8(%ebp),%eax
    ea7b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    ea82:	8b 45 08             	mov    0x8(%ebp),%eax
    ea85:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    ea8c:	8b 45 08             	mov    0x8(%ebp),%eax
    ea8f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    ea96:	8b 45 08             	mov    0x8(%ebp),%eax
    ea99:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    eaa0:	8b 45 08             	mov    0x8(%ebp),%eax
    eaa3:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    eaaa:	90                   	nop
    eaab:	5d                   	pop    %ebp
    eaac:	c3                   	ret    

0000eaad <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    eaad:	55                   	push   %ebp
    eaae:	89 e5                	mov    %esp,%ebp
    eab0:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    eab3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    eaba:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    eac1:	eb 2a                	jmp    eaed <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    eac3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    eac6:	8b 45 08             	mov    0x8(%ebp),%eax
    eac9:	01 d0                	add    %edx,%eax
    eacb:	0f b6 00             	movzbl (%eax),%eax
    eace:	0f b6 c0             	movzbl %al,%eax
    ead1:	33 45 fc             	xor    -0x4(%ebp),%eax
    ead4:	0f b6 c0             	movzbl %al,%eax
    ead7:	8b 04 85 80 53 02 00 	mov    0x25380(,%eax,4),%eax
    eade:	8b 55 fc             	mov    -0x4(%ebp),%edx
    eae1:	c1 ea 08             	shr    $0x8,%edx
    eae4:	31 d0                	xor    %edx,%eax
    eae6:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    eae9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    eaed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    eaf0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    eaf3:	7c ce                	jl     eac3 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    eaf5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eaf8:	f7 d0                	not    %eax
}
    eafa:	c9                   	leave  
    eafb:	c3                   	ret    

0000eafc <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    eafc:	55                   	push   %ebp
    eafd:	89 e5                	mov    %esp,%ebp
    eaff:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    eb02:	8b 45 08             	mov    0x8(%ebp),%eax
    eb05:	8b 00                	mov    (%eax),%eax
    eb07:	c1 f8 03             	sar    $0x3,%eax
    eb0a:	89 c2                	mov    %eax,%edx
    eb0c:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb0f:	01 d0                	add    %edx,%eax
    eb11:	0f b6 00             	movzbl (%eax),%eax
    eb14:	0f b6 d0             	movzbl %al,%edx
    eb17:	8b 45 08             	mov    0x8(%ebp),%eax
    eb1a:	8b 00                	mov    (%eax),%eax
    eb1c:	f7 d0                	not    %eax
    eb1e:	83 e0 07             	and    $0x7,%eax
    eb21:	89 c1                	mov    %eax,%ecx
    eb23:	d3 fa                	sar    %cl,%edx
    eb25:	89 d0                	mov    %edx,%eax
    eb27:	83 e0 01             	and    $0x1,%eax
    eb2a:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    eb2d:	8b 45 08             	mov    0x8(%ebp),%eax
    eb30:	8b 00                	mov    (%eax),%eax
    eb32:	8d 50 01             	lea    0x1(%eax),%edx
    eb35:	8b 45 08             	mov    0x8(%ebp),%eax
    eb38:	89 10                	mov    %edx,(%eax)
  return result;
    eb3a:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    eb3e:	c9                   	leave  
    eb3f:	c3                   	ret    

0000eb40 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    eb40:	55                   	push   %ebp
    eb41:	89 e5                	mov    %esp,%ebp
    eb43:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    eb46:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    eb4d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    eb54:	eb 1b                	jmp    eb71 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    eb56:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    eb59:	ff 75 0c             	pushl  0xc(%ebp)
    eb5c:	ff 75 08             	pushl  0x8(%ebp)
    eb5f:	e8 98 ff ff ff       	call   eafc <readBitFromReversedStream>
    eb64:	83 c4 08             	add    $0x8,%esp
    eb67:	0f b6 c0             	movzbl %al,%eax
    eb6a:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    eb6d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    eb71:	8b 45 f8             	mov    -0x8(%ebp),%eax
    eb74:	3b 45 10             	cmp    0x10(%ebp),%eax
    eb77:	7c dd                	jl     eb56 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    eb79:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    eb7c:	c9                   	leave  
    eb7d:	c3                   	ret    

0000eb7e <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    eb7e:	55                   	push   %ebp
    eb7f:	89 e5                	mov    %esp,%ebp
    eb81:	56                   	push   %esi
    eb82:	53                   	push   %ebx
    eb83:	83 ec 04             	sub    $0x4,%esp
    eb86:	8b 45 10             	mov    0x10(%ebp),%eax
    eb89:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    eb8c:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    eb90:	75 3e                	jne    ebd0 <setBitOfReversedStream+0x52>
    eb92:	8b 45 08             	mov    0x8(%ebp),%eax
    eb95:	8b 00                	mov    (%eax),%eax
    eb97:	c1 f8 03             	sar    $0x3,%eax
    eb9a:	89 c2                	mov    %eax,%edx
    eb9c:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb9f:	01 c2                	add    %eax,%edx
    eba1:	8b 45 08             	mov    0x8(%ebp),%eax
    eba4:	8b 00                	mov    (%eax),%eax
    eba6:	c1 f8 03             	sar    $0x3,%eax
    eba9:	89 c1                	mov    %eax,%ecx
    ebab:	8b 45 0c             	mov    0xc(%ebp),%eax
    ebae:	01 c8                	add    %ecx,%eax
    ebb0:	0f b6 18             	movzbl (%eax),%ebx
    ebb3:	8b 45 08             	mov    0x8(%ebp),%eax
    ebb6:	8b 00                	mov    (%eax),%eax
    ebb8:	f7 d0                	not    %eax
    ebba:	83 e0 07             	and    $0x7,%eax
    ebbd:	be 01 00 00 00       	mov    $0x1,%esi
    ebc2:	89 c1                	mov    %eax,%ecx
    ebc4:	d3 e6                	shl    %cl,%esi
    ebc6:	89 f0                	mov    %esi,%eax
    ebc8:	f7 d0                	not    %eax
    ebca:	21 d8                	and    %ebx,%eax
    ebcc:	88 02                	mov    %al,(%edx)
    ebce:	eb 3a                	jmp    ec0a <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    ebd0:	8b 45 08             	mov    0x8(%ebp),%eax
    ebd3:	8b 00                	mov    (%eax),%eax
    ebd5:	c1 f8 03             	sar    $0x3,%eax
    ebd8:	89 c2                	mov    %eax,%edx
    ebda:	8b 45 0c             	mov    0xc(%ebp),%eax
    ebdd:	01 c2                	add    %eax,%edx
    ebdf:	8b 45 08             	mov    0x8(%ebp),%eax
    ebe2:	8b 00                	mov    (%eax),%eax
    ebe4:	c1 f8 03             	sar    $0x3,%eax
    ebe7:	89 c1                	mov    %eax,%ecx
    ebe9:	8b 45 0c             	mov    0xc(%ebp),%eax
    ebec:	01 c8                	add    %ecx,%eax
    ebee:	0f b6 18             	movzbl (%eax),%ebx
    ebf1:	8b 45 08             	mov    0x8(%ebp),%eax
    ebf4:	8b 00                	mov    (%eax),%eax
    ebf6:	f7 d0                	not    %eax
    ebf8:	83 e0 07             	and    $0x7,%eax
    ebfb:	be 01 00 00 00       	mov    $0x1,%esi
    ec00:	89 c1                	mov    %eax,%ecx
    ec02:	d3 e6                	shl    %cl,%esi
    ec04:	89 f0                	mov    %esi,%eax
    ec06:	09 d8                	or     %ebx,%eax
    ec08:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    ec0a:	8b 45 08             	mov    0x8(%ebp),%eax
    ec0d:	8b 00                	mov    (%eax),%eax
    ec0f:	8d 50 01             	lea    0x1(%eax),%edx
    ec12:	8b 45 08             	mov    0x8(%ebp),%eax
    ec15:	89 10                	mov    %edx,(%eax)
}
    ec17:	90                   	nop
    ec18:	83 c4 04             	add    $0x4,%esp
    ec1b:	5b                   	pop    %ebx
    ec1c:	5e                   	pop    %esi
    ec1d:	5d                   	pop    %ebp
    ec1e:	c3                   	ret    

0000ec1f <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    ec1f:	55                   	push   %ebp
    ec20:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    ec22:	ff 75 08             	pushl  0x8(%ebp)
    ec25:	e8 f1 b3 ff ff       	call   a01b <lodepng_read32bitInt>
    ec2a:	83 c4 04             	add    $0x4,%esp
}
    ec2d:	c9                   	leave  
    ec2e:	c3                   	ret    

0000ec2f <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    ec2f:	55                   	push   %ebp
    ec30:	89 e5                	mov    %esp,%ebp
    ec32:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    ec35:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    ec3c:	eb 1c                	jmp    ec5a <lodepng_chunk_type+0x2b>
    ec3e:	8b 55 08             	mov    0x8(%ebp),%edx
    ec41:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ec44:	01 d0                	add    %edx,%eax
    ec46:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ec49:	8d 4a 04             	lea    0x4(%edx),%ecx
    ec4c:	8b 55 0c             	mov    0xc(%ebp),%edx
    ec4f:	01 ca                	add    %ecx,%edx
    ec51:	0f b6 12             	movzbl (%edx),%edx
    ec54:	88 10                	mov    %dl,(%eax)
    ec56:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    ec5a:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    ec5e:	75 de                	jne    ec3e <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    ec60:	8b 45 08             	mov    0x8(%ebp),%eax
    ec63:	83 c0 04             	add    $0x4,%eax
    ec66:	c6 00 00             	movb   $0x0,(%eax)
}
    ec69:	90                   	nop
    ec6a:	c9                   	leave  
    ec6b:	c3                   	ret    

0000ec6c <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    ec6c:	55                   	push   %ebp
    ec6d:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    ec6f:	ff 75 0c             	pushl  0xc(%ebp)
    ec72:	e8 c2 b0 ff ff       	call   9d39 <lodepng_strlen>
    ec77:	83 c4 04             	add    $0x4,%esp
    ec7a:	83 f8 04             	cmp    $0x4,%eax
    ec7d:	74 07                	je     ec86 <lodepng_chunk_type_equals+0x1a>
    ec7f:	b8 00 00 00 00       	mov    $0x0,%eax
    ec84:	eb 79                	jmp    ecff <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    ec86:	8b 45 08             	mov    0x8(%ebp),%eax
    ec89:	83 c0 04             	add    $0x4,%eax
    ec8c:	0f b6 00             	movzbl (%eax),%eax
    ec8f:	0f b6 d0             	movzbl %al,%edx
    ec92:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec95:	0f b6 00             	movzbl (%eax),%eax
    ec98:	0f be c0             	movsbl %al,%eax
    ec9b:	39 c2                	cmp    %eax,%edx
    ec9d:	75 5b                	jne    ecfa <lodepng_chunk_type_equals+0x8e>
    ec9f:	8b 45 08             	mov    0x8(%ebp),%eax
    eca2:	83 c0 05             	add    $0x5,%eax
    eca5:	0f b6 00             	movzbl (%eax),%eax
    eca8:	0f b6 d0             	movzbl %al,%edx
    ecab:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecae:	83 c0 01             	add    $0x1,%eax
    ecb1:	0f b6 00             	movzbl (%eax),%eax
    ecb4:	0f be c0             	movsbl %al,%eax
    ecb7:	39 c2                	cmp    %eax,%edx
    ecb9:	75 3f                	jne    ecfa <lodepng_chunk_type_equals+0x8e>
    ecbb:	8b 45 08             	mov    0x8(%ebp),%eax
    ecbe:	83 c0 06             	add    $0x6,%eax
    ecc1:	0f b6 00             	movzbl (%eax),%eax
    ecc4:	0f b6 d0             	movzbl %al,%edx
    ecc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecca:	83 c0 02             	add    $0x2,%eax
    eccd:	0f b6 00             	movzbl (%eax),%eax
    ecd0:	0f be c0             	movsbl %al,%eax
    ecd3:	39 c2                	cmp    %eax,%edx
    ecd5:	75 23                	jne    ecfa <lodepng_chunk_type_equals+0x8e>
    ecd7:	8b 45 08             	mov    0x8(%ebp),%eax
    ecda:	83 c0 07             	add    $0x7,%eax
    ecdd:	0f b6 00             	movzbl (%eax),%eax
    ece0:	0f b6 d0             	movzbl %al,%edx
    ece3:	8b 45 0c             	mov    0xc(%ebp),%eax
    ece6:	83 c0 03             	add    $0x3,%eax
    ece9:	0f b6 00             	movzbl (%eax),%eax
    ecec:	0f be c0             	movsbl %al,%eax
    ecef:	39 c2                	cmp    %eax,%edx
    ecf1:	75 07                	jne    ecfa <lodepng_chunk_type_equals+0x8e>
    ecf3:	b8 01 00 00 00       	mov    $0x1,%eax
    ecf8:	eb 05                	jmp    ecff <lodepng_chunk_type_equals+0x93>
    ecfa:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ecff:	c9                   	leave  
    ed00:	c3                   	ret    

0000ed01 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    ed01:	55                   	push   %ebp
    ed02:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    ed04:	8b 45 08             	mov    0x8(%ebp),%eax
    ed07:	83 c0 04             	add    $0x4,%eax
    ed0a:	0f b6 00             	movzbl (%eax),%eax
    ed0d:	0f b6 c0             	movzbl %al,%eax
    ed10:	83 e0 20             	and    $0x20,%eax
    ed13:	85 c0                	test   %eax,%eax
    ed15:	0f 95 c0             	setne  %al
}
    ed18:	5d                   	pop    %ebp
    ed19:	c3                   	ret    

0000ed1a <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    ed1a:	55                   	push   %ebp
    ed1b:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    ed1d:	8b 45 08             	mov    0x8(%ebp),%eax
    ed20:	83 c0 06             	add    $0x6,%eax
    ed23:	0f b6 00             	movzbl (%eax),%eax
    ed26:	0f b6 c0             	movzbl %al,%eax
    ed29:	83 e0 20             	and    $0x20,%eax
    ed2c:	85 c0                	test   %eax,%eax
    ed2e:	0f 95 c0             	setne  %al
}
    ed31:	5d                   	pop    %ebp
    ed32:	c3                   	ret    

0000ed33 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    ed33:	55                   	push   %ebp
    ed34:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    ed36:	8b 45 08             	mov    0x8(%ebp),%eax
    ed39:	83 c0 07             	add    $0x7,%eax
    ed3c:	0f b6 00             	movzbl (%eax),%eax
    ed3f:	0f b6 c0             	movzbl %al,%eax
    ed42:	83 e0 20             	and    $0x20,%eax
    ed45:	85 c0                	test   %eax,%eax
    ed47:	0f 95 c0             	setne  %al
}
    ed4a:	5d                   	pop    %ebp
    ed4b:	c3                   	ret    

0000ed4c <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    ed4c:	55                   	push   %ebp
    ed4d:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    ed4f:	8b 45 08             	mov    0x8(%ebp),%eax
    ed52:	83 c0 08             	add    $0x8,%eax
}
    ed55:	5d                   	pop    %ebp
    ed56:	c3                   	ret    

0000ed57 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    ed57:	55                   	push   %ebp
    ed58:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    ed5a:	8b 45 08             	mov    0x8(%ebp),%eax
    ed5d:	83 c0 08             	add    $0x8,%eax
}
    ed60:	5d                   	pop    %ebp
    ed61:	c3                   	ret    

0000ed62 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    ed62:	55                   	push   %ebp
    ed63:	89 e5                	mov    %esp,%ebp
    ed65:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    ed68:	ff 75 08             	pushl  0x8(%ebp)
    ed6b:	e8 af fe ff ff       	call   ec1f <lodepng_chunk_length>
    ed70:	83 c4 04             	add    $0x4,%esp
    ed73:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    ed76:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ed79:	8d 50 08             	lea    0x8(%eax),%edx
    ed7c:	8b 45 08             	mov    0x8(%ebp),%eax
    ed7f:	01 d0                	add    %edx,%eax
    ed81:	50                   	push   %eax
    ed82:	e8 94 b2 ff ff       	call   a01b <lodepng_read32bitInt>
    ed87:	83 c4 04             	add    $0x4,%esp
    ed8a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    ed8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ed90:	83 c0 04             	add    $0x4,%eax
    ed93:	89 c2                	mov    %eax,%edx
    ed95:	8b 45 08             	mov    0x8(%ebp),%eax
    ed98:	83 c0 04             	add    $0x4,%eax
    ed9b:	52                   	push   %edx
    ed9c:	50                   	push   %eax
    ed9d:	e8 0b fd ff ff       	call   eaad <lodepng_crc32>
    eda2:	83 c4 08             	add    $0x8,%esp
    eda5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    eda8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    edab:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    edae:	74 07                	je     edb7 <lodepng_chunk_check_crc+0x55>
    edb0:	b8 01 00 00 00       	mov    $0x1,%eax
    edb5:	eb 05                	jmp    edbc <lodepng_chunk_check_crc+0x5a>
  else return 0;
    edb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    edbc:	c9                   	leave  
    edbd:	c3                   	ret    

0000edbe <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    edbe:	55                   	push   %ebp
    edbf:	89 e5                	mov    %esp,%ebp
    edc1:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    edc4:	ff 75 08             	pushl  0x8(%ebp)
    edc7:	e8 53 fe ff ff       	call   ec1f <lodepng_chunk_length>
    edcc:	83 c4 04             	add    $0x4,%esp
    edcf:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    edd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    edd5:	83 c0 04             	add    $0x4,%eax
    edd8:	89 c2                	mov    %eax,%edx
    edda:	8b 45 08             	mov    0x8(%ebp),%eax
    eddd:	83 c0 04             	add    $0x4,%eax
    ede0:	52                   	push   %edx
    ede1:	50                   	push   %eax
    ede2:	e8 c6 fc ff ff       	call   eaad <lodepng_crc32>
    ede7:	83 c4 08             	add    $0x8,%esp
    edea:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    eded:	8b 45 fc             	mov    -0x4(%ebp),%eax
    edf0:	8d 50 08             	lea    0x8(%eax),%edx
    edf3:	8b 45 08             	mov    0x8(%ebp),%eax
    edf6:	01 d0                	add    %edx,%eax
    edf8:	ff 75 f8             	pushl  -0x8(%ebp)
    edfb:	50                   	push   %eax
    edfc:	e8 5d b2 ff ff       	call   a05e <lodepng_set32bitInt>
    ee01:	83 c4 08             	add    $0x8,%esp
}
    ee04:	90                   	nop
    ee05:	c9                   	leave  
    ee06:	c3                   	ret    

0000ee07 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    ee07:	55                   	push   %ebp
    ee08:	89 e5                	mov    %esp,%ebp
    ee0a:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    ee0d:	8b 45 08             	mov    0x8(%ebp),%eax
    ee10:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ee13:	73 0f                	jae    ee24 <lodepng_chunk_next+0x1d>
    ee15:	8b 55 0c             	mov    0xc(%ebp),%edx
    ee18:	8b 45 08             	mov    0x8(%ebp),%eax
    ee1b:	29 c2                	sub    %eax,%edx
    ee1d:	89 d0                	mov    %edx,%eax
    ee1f:	83 f8 0b             	cmp    $0xb,%eax
    ee22:	7f 08                	jg     ee2c <lodepng_chunk_next+0x25>
    ee24:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee27:	e9 af 00 00 00       	jmp    eedb <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    ee2c:	8b 45 08             	mov    0x8(%ebp),%eax
    ee2f:	0f b6 00             	movzbl (%eax),%eax
    ee32:	3c 89                	cmp    $0x89,%al
    ee34:	75 63                	jne    ee99 <lodepng_chunk_next+0x92>
    ee36:	8b 45 08             	mov    0x8(%ebp),%eax
    ee39:	83 c0 01             	add    $0x1,%eax
    ee3c:	0f b6 00             	movzbl (%eax),%eax
    ee3f:	3c 50                	cmp    $0x50,%al
    ee41:	75 56                	jne    ee99 <lodepng_chunk_next+0x92>
    ee43:	8b 45 08             	mov    0x8(%ebp),%eax
    ee46:	83 c0 02             	add    $0x2,%eax
    ee49:	0f b6 00             	movzbl (%eax),%eax
    ee4c:	3c 4e                	cmp    $0x4e,%al
    ee4e:	75 49                	jne    ee99 <lodepng_chunk_next+0x92>
    ee50:	8b 45 08             	mov    0x8(%ebp),%eax
    ee53:	83 c0 03             	add    $0x3,%eax
    ee56:	0f b6 00             	movzbl (%eax),%eax
    ee59:	3c 47                	cmp    $0x47,%al
    ee5b:	75 3c                	jne    ee99 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    ee5d:	8b 45 08             	mov    0x8(%ebp),%eax
    ee60:	83 c0 04             	add    $0x4,%eax
    ee63:	0f b6 00             	movzbl (%eax),%eax
    ee66:	3c 0d                	cmp    $0xd,%al
    ee68:	75 2f                	jne    ee99 <lodepng_chunk_next+0x92>
    ee6a:	8b 45 08             	mov    0x8(%ebp),%eax
    ee6d:	83 c0 05             	add    $0x5,%eax
    ee70:	0f b6 00             	movzbl (%eax),%eax
    ee73:	3c 0a                	cmp    $0xa,%al
    ee75:	75 22                	jne    ee99 <lodepng_chunk_next+0x92>
    ee77:	8b 45 08             	mov    0x8(%ebp),%eax
    ee7a:	83 c0 06             	add    $0x6,%eax
    ee7d:	0f b6 00             	movzbl (%eax),%eax
    ee80:	3c 1a                	cmp    $0x1a,%al
    ee82:	75 15                	jne    ee99 <lodepng_chunk_next+0x92>
    ee84:	8b 45 08             	mov    0x8(%ebp),%eax
    ee87:	83 c0 07             	add    $0x7,%eax
    ee8a:	0f b6 00             	movzbl (%eax),%eax
    ee8d:	3c 0a                	cmp    $0xa,%al
    ee8f:	75 08                	jne    ee99 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    ee91:	8b 45 08             	mov    0x8(%ebp),%eax
    ee94:	83 c0 08             	add    $0x8,%eax
    ee97:	eb 42                	jmp    eedb <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    ee99:	ff 75 08             	pushl  0x8(%ebp)
    ee9c:	e8 7e fd ff ff       	call   ec1f <lodepng_chunk_length>
    eea1:	83 c4 04             	add    $0x4,%esp
    eea4:	89 c2                	mov    %eax,%edx
    eea6:	8d 45 f8             	lea    -0x8(%ebp),%eax
    eea9:	50                   	push   %eax
    eeaa:	6a 0c                	push   $0xc
    eeac:	52                   	push   %edx
    eead:	e8 af ae ff ff       	call   9d61 <lodepng_addofl>
    eeb2:	83 c4 0c             	add    $0xc,%esp
    eeb5:	85 c0                	test   %eax,%eax
    eeb7:	74 05                	je     eebe <lodepng_chunk_next+0xb7>
    eeb9:	8b 45 0c             	mov    0xc(%ebp),%eax
    eebc:	eb 1d                	jmp    eedb <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    eebe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    eec1:	89 c2                	mov    %eax,%edx
    eec3:	8b 45 08             	mov    0x8(%ebp),%eax
    eec6:	01 d0                	add    %edx,%eax
    eec8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    eecb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    eece:	3b 45 08             	cmp    0x8(%ebp),%eax
    eed1:	73 05                	jae    eed8 <lodepng_chunk_next+0xd1>
    eed3:	8b 45 0c             	mov    0xc(%ebp),%eax
    eed6:	eb 03                	jmp    eedb <lodepng_chunk_next+0xd4>
    return result;
    eed8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    eedb:	c9                   	leave  
    eedc:	c3                   	ret    

0000eedd <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    eedd:	55                   	push   %ebp
    eede:	89 e5                	mov    %esp,%ebp
    eee0:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    eee3:	8b 45 08             	mov    0x8(%ebp),%eax
    eee6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    eee9:	73 0f                	jae    eefa <lodepng_chunk_next_const+0x1d>
    eeeb:	8b 55 0c             	mov    0xc(%ebp),%edx
    eeee:	8b 45 08             	mov    0x8(%ebp),%eax
    eef1:	29 c2                	sub    %eax,%edx
    eef3:	89 d0                	mov    %edx,%eax
    eef5:	83 f8 0b             	cmp    $0xb,%eax
    eef8:	7f 08                	jg     ef02 <lodepng_chunk_next_const+0x25>
    eefa:	8b 45 0c             	mov    0xc(%ebp),%eax
    eefd:	e9 af 00 00 00       	jmp    efb1 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    ef02:	8b 45 08             	mov    0x8(%ebp),%eax
    ef05:	0f b6 00             	movzbl (%eax),%eax
    ef08:	3c 89                	cmp    $0x89,%al
    ef0a:	75 63                	jne    ef6f <lodepng_chunk_next_const+0x92>
    ef0c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef0f:	83 c0 01             	add    $0x1,%eax
    ef12:	0f b6 00             	movzbl (%eax),%eax
    ef15:	3c 50                	cmp    $0x50,%al
    ef17:	75 56                	jne    ef6f <lodepng_chunk_next_const+0x92>
    ef19:	8b 45 08             	mov    0x8(%ebp),%eax
    ef1c:	83 c0 02             	add    $0x2,%eax
    ef1f:	0f b6 00             	movzbl (%eax),%eax
    ef22:	3c 4e                	cmp    $0x4e,%al
    ef24:	75 49                	jne    ef6f <lodepng_chunk_next_const+0x92>
    ef26:	8b 45 08             	mov    0x8(%ebp),%eax
    ef29:	83 c0 03             	add    $0x3,%eax
    ef2c:	0f b6 00             	movzbl (%eax),%eax
    ef2f:	3c 47                	cmp    $0x47,%al
    ef31:	75 3c                	jne    ef6f <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    ef33:	8b 45 08             	mov    0x8(%ebp),%eax
    ef36:	83 c0 04             	add    $0x4,%eax
    ef39:	0f b6 00             	movzbl (%eax),%eax
    ef3c:	3c 0d                	cmp    $0xd,%al
    ef3e:	75 2f                	jne    ef6f <lodepng_chunk_next_const+0x92>
    ef40:	8b 45 08             	mov    0x8(%ebp),%eax
    ef43:	83 c0 05             	add    $0x5,%eax
    ef46:	0f b6 00             	movzbl (%eax),%eax
    ef49:	3c 0a                	cmp    $0xa,%al
    ef4b:	75 22                	jne    ef6f <lodepng_chunk_next_const+0x92>
    ef4d:	8b 45 08             	mov    0x8(%ebp),%eax
    ef50:	83 c0 06             	add    $0x6,%eax
    ef53:	0f b6 00             	movzbl (%eax),%eax
    ef56:	3c 1a                	cmp    $0x1a,%al
    ef58:	75 15                	jne    ef6f <lodepng_chunk_next_const+0x92>
    ef5a:	8b 45 08             	mov    0x8(%ebp),%eax
    ef5d:	83 c0 07             	add    $0x7,%eax
    ef60:	0f b6 00             	movzbl (%eax),%eax
    ef63:	3c 0a                	cmp    $0xa,%al
    ef65:	75 08                	jne    ef6f <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    ef67:	8b 45 08             	mov    0x8(%ebp),%eax
    ef6a:	83 c0 08             	add    $0x8,%eax
    ef6d:	eb 42                	jmp    efb1 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    ef6f:	ff 75 08             	pushl  0x8(%ebp)
    ef72:	e8 a8 fc ff ff       	call   ec1f <lodepng_chunk_length>
    ef77:	83 c4 04             	add    $0x4,%esp
    ef7a:	89 c2                	mov    %eax,%edx
    ef7c:	8d 45 f8             	lea    -0x8(%ebp),%eax
    ef7f:	50                   	push   %eax
    ef80:	6a 0c                	push   $0xc
    ef82:	52                   	push   %edx
    ef83:	e8 d9 ad ff ff       	call   9d61 <lodepng_addofl>
    ef88:	83 c4 0c             	add    $0xc,%esp
    ef8b:	85 c0                	test   %eax,%eax
    ef8d:	74 05                	je     ef94 <lodepng_chunk_next_const+0xb7>
    ef8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef92:	eb 1d                	jmp    efb1 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    ef94:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ef97:	89 c2                	mov    %eax,%edx
    ef99:	8b 45 08             	mov    0x8(%ebp),%eax
    ef9c:	01 d0                	add    %edx,%eax
    ef9e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    efa1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    efa4:	3b 45 08             	cmp    0x8(%ebp),%eax
    efa7:	73 05                	jae    efae <lodepng_chunk_next_const+0xd1>
    efa9:	8b 45 0c             	mov    0xc(%ebp),%eax
    efac:	eb 03                	jmp    efb1 <lodepng_chunk_next_const+0xd4>
    return result;
    efae:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    efb1:	c9                   	leave  
    efb2:	c3                   	ret    

0000efb3 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    efb3:	55                   	push   %ebp
    efb4:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    efb6:	8b 45 08             	mov    0x8(%ebp),%eax
    efb9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    efbc:	73 0f                	jae    efcd <lodepng_chunk_find+0x1a>
    efbe:	8b 55 0c             	mov    0xc(%ebp),%edx
    efc1:	8b 45 08             	mov    0x8(%ebp),%eax
    efc4:	29 c2                	sub    %eax,%edx
    efc6:	89 d0                	mov    %edx,%eax
    efc8:	83 f8 0b             	cmp    $0xb,%eax
    efcb:	7f 07                	jg     efd4 <lodepng_chunk_find+0x21>
    efcd:	b8 00 00 00 00       	mov    $0x0,%eax
    efd2:	eb 2a                	jmp    effe <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    efd4:	ff 75 10             	pushl  0x10(%ebp)
    efd7:	ff 75 08             	pushl  0x8(%ebp)
    efda:	e8 8d fc ff ff       	call   ec6c <lodepng_chunk_type_equals>
    efdf:	83 c4 08             	add    $0x8,%esp
    efe2:	84 c0                	test   %al,%al
    efe4:	74 05                	je     efeb <lodepng_chunk_find+0x38>
    efe6:	8b 45 08             	mov    0x8(%ebp),%eax
    efe9:	eb 13                	jmp    effe <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    efeb:	ff 75 0c             	pushl  0xc(%ebp)
    efee:	ff 75 08             	pushl  0x8(%ebp)
    eff1:	e8 11 fe ff ff       	call   ee07 <lodepng_chunk_next>
    eff6:	83 c4 08             	add    $0x8,%esp
    eff9:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    effc:	eb b8                	jmp    efb6 <lodepng_chunk_find+0x3>
}
    effe:	c9                   	leave  
    efff:	c3                   	ret    

0000f000 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    f000:	55                   	push   %ebp
    f001:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    f003:	8b 45 08             	mov    0x8(%ebp),%eax
    f006:	3b 45 0c             	cmp    0xc(%ebp),%eax
    f009:	73 0f                	jae    f01a <lodepng_chunk_find_const+0x1a>
    f00b:	8b 55 0c             	mov    0xc(%ebp),%edx
    f00e:	8b 45 08             	mov    0x8(%ebp),%eax
    f011:	29 c2                	sub    %eax,%edx
    f013:	89 d0                	mov    %edx,%eax
    f015:	83 f8 0b             	cmp    $0xb,%eax
    f018:	7f 07                	jg     f021 <lodepng_chunk_find_const+0x21>
    f01a:	b8 00 00 00 00       	mov    $0x0,%eax
    f01f:	eb 2a                	jmp    f04b <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    f021:	ff 75 10             	pushl  0x10(%ebp)
    f024:	ff 75 08             	pushl  0x8(%ebp)
    f027:	e8 40 fc ff ff       	call   ec6c <lodepng_chunk_type_equals>
    f02c:	83 c4 08             	add    $0x8,%esp
    f02f:	84 c0                	test   %al,%al
    f031:	74 05                	je     f038 <lodepng_chunk_find_const+0x38>
    f033:	8b 45 08             	mov    0x8(%ebp),%eax
    f036:	eb 13                	jmp    f04b <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    f038:	ff 75 0c             	pushl  0xc(%ebp)
    f03b:	ff 75 08             	pushl  0x8(%ebp)
    f03e:	e8 9a fe ff ff       	call   eedd <lodepng_chunk_next_const>
    f043:	83 c4 08             	add    $0x8,%esp
    f046:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    f049:	eb b8                	jmp    f003 <lodepng_chunk_find_const+0x3>
}
    f04b:	c9                   	leave  
    f04c:	c3                   	ret    

0000f04d <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    f04d:	55                   	push   %ebp
    f04e:	89 e5                	mov    %esp,%ebp
    f050:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    f053:	ff 75 10             	pushl  0x10(%ebp)
    f056:	e8 c4 fb ff ff       	call   ec1f <lodepng_chunk_length>
    f05b:	83 c4 04             	add    $0x4,%esp
    f05e:	89 c2                	mov    %eax,%edx
    f060:	8d 45 f0             	lea    -0x10(%ebp),%eax
    f063:	50                   	push   %eax
    f064:	6a 0c                	push   $0xc
    f066:	52                   	push   %edx
    f067:	e8 f5 ac ff ff       	call   9d61 <lodepng_addofl>
    f06c:	83 c4 0c             	add    $0xc,%esp
    f06f:	85 c0                	test   %eax,%eax
    f071:	74 0a                	je     f07d <lodepng_chunk_append+0x30>
    f073:	b8 4d 00 00 00       	mov    $0x4d,%eax
    f078:	e9 96 00 00 00       	jmp    f113 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    f07d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f080:	8b 45 0c             	mov    0xc(%ebp),%eax
    f083:	8b 00                	mov    (%eax),%eax
    f085:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    f088:	51                   	push   %ecx
    f089:	52                   	push   %edx
    f08a:	50                   	push   %eax
    f08b:	e8 d1 ac ff ff       	call   9d61 <lodepng_addofl>
    f090:	83 c4 0c             	add    $0xc,%esp
    f093:	85 c0                	test   %eax,%eax
    f095:	74 07                	je     f09e <lodepng_chunk_append+0x51>
    f097:	b8 4d 00 00 00       	mov    $0x4d,%eax
    f09c:	eb 75                	jmp    f113 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    f09e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f0a1:	8b 45 08             	mov    0x8(%ebp),%eax
    f0a4:	8b 00                	mov    (%eax),%eax
    f0a6:	52                   	push   %edx
    f0a7:	50                   	push   %eax
    f0a8:	e8 07 ac ff ff       	call   9cb4 <lodepng_realloc>
    f0ad:	83 c4 08             	add    $0x8,%esp
    f0b0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    f0b3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    f0b7:	75 07                	jne    f0c0 <lodepng_chunk_append+0x73>
    f0b9:	b8 53 00 00 00       	mov    $0x53,%eax
    f0be:	eb 53                	jmp    f113 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    f0c0:	8b 45 08             	mov    0x8(%ebp),%eax
    f0c3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    f0c6:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    f0c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f0cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ce:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    f0d0:	8b 45 08             	mov    0x8(%ebp),%eax
    f0d3:	8b 00                	mov    (%eax),%eax
    f0d5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    f0d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f0db:	29 d1                	sub    %edx,%ecx
    f0dd:	89 ca                	mov    %ecx,%edx
    f0df:	01 d0                	add    %edx,%eax
    f0e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    f0e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f0eb:	eb 19                	jmp    f106 <lodepng_chunk_append+0xb9>
    f0ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f0f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f0f3:	01 c2                	add    %eax,%edx
    f0f5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f0f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f0fb:	01 c8                	add    %ecx,%eax
    f0fd:	0f b6 00             	movzbl (%eax),%eax
    f100:	88 02                	mov    %al,(%edx)
    f102:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f106:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f109:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    f10c:	75 df                	jne    f0ed <lodepng_chunk_append+0xa0>

  return 0;
    f10e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f113:	c9                   	leave  
    f114:	c3                   	ret    

0000f115 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    f115:	55                   	push   %ebp
    f116:	89 e5                	mov    %esp,%ebp
    f118:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    f11b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f11e:	8b 40 04             	mov    0x4(%eax),%eax
    f121:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    f124:	8b 55 10             	mov    0x10(%ebp),%edx
    f127:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f12a:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    f12d:	51                   	push   %ecx
    f12e:	52                   	push   %edx
    f12f:	50                   	push   %eax
    f130:	e8 2c ac ff ff       	call   9d61 <lodepng_addofl>
    f135:	83 c4 0c             	add    $0xc,%esp
    f138:	85 c0                	test   %eax,%eax
    f13a:	74 07                	je     f143 <lodepng_chunk_init+0x2e>
    f13c:	b8 4d 00 00 00       	mov    $0x4d,%eax
    f141:	eb 78                	jmp    f1bb <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    f143:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f146:	8d 55 fc             	lea    -0x4(%ebp),%edx
    f149:	52                   	push   %edx
    f14a:	6a 0c                	push   $0xc
    f14c:	50                   	push   %eax
    f14d:	e8 0f ac ff ff       	call   9d61 <lodepng_addofl>
    f152:	83 c4 0c             	add    $0xc,%esp
    f155:	85 c0                	test   %eax,%eax
    f157:	74 07                	je     f160 <lodepng_chunk_init+0x4b>
    f159:	b8 4d 00 00 00       	mov    $0x4d,%eax
    f15e:	eb 5b                	jmp    f1bb <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    f160:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f163:	50                   	push   %eax
    f164:	ff 75 0c             	pushl  0xc(%ebp)
    f167:	e8 8b ad ff ff       	call   9ef7 <ucvector_resize>
    f16c:	83 c4 08             	add    $0x8,%esp
    f16f:	85 c0                	test   %eax,%eax
    f171:	75 07                	jne    f17a <lodepng_chunk_init+0x65>
    f173:	b8 53 00 00 00       	mov    $0x53,%eax
    f178:	eb 41                	jmp    f1bb <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    f17a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f17d:	8b 00                	mov    (%eax),%eax
    f17f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    f182:	2b 55 10             	sub    0x10(%ebp),%edx
    f185:	83 ea 0c             	sub    $0xc,%edx
    f188:	01 c2                	add    %eax,%edx
    f18a:	8b 45 08             	mov    0x8(%ebp),%eax
    f18d:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    f18f:	8b 45 08             	mov    0x8(%ebp),%eax
    f192:	8b 00                	mov    (%eax),%eax
    f194:	ff 75 10             	pushl  0x10(%ebp)
    f197:	50                   	push   %eax
    f198:	e8 c1 ae ff ff       	call   a05e <lodepng_set32bitInt>
    f19d:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    f1a0:	8b 45 08             	mov    0x8(%ebp),%eax
    f1a3:	8b 00                	mov    (%eax),%eax
    f1a5:	83 c0 04             	add    $0x4,%eax
    f1a8:	6a 04                	push   $0x4
    f1aa:	ff 75 14             	pushl  0x14(%ebp)
    f1ad:	50                   	push   %eax
    f1ae:	e8 28 ab ff ff       	call   9cdb <lodepng_memcpy>
    f1b3:	83 c4 0c             	add    $0xc,%esp

  return 0;
    f1b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f1bb:	c9                   	leave  
    f1bc:	c3                   	ret    

0000f1bd <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    f1bd:	55                   	push   %ebp
    f1be:	89 e5                	mov    %esp,%ebp
    f1c0:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    f1c3:	ff 75 10             	pushl  0x10(%ebp)
    f1c6:	ff 75 0c             	pushl  0xc(%ebp)
    f1c9:	ff 75 08             	pushl  0x8(%ebp)
    f1cc:	8d 45 f8             	lea    -0x8(%ebp),%eax
    f1cf:	50                   	push   %eax
    f1d0:	e8 40 ff ff ff       	call   f115 <lodepng_chunk_init>
    f1d5:	83 c4 10             	add    $0x10,%esp
    f1d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    f1db:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    f1df:	74 05                	je     f1e6 <lodepng_chunk_createv+0x29>
    f1e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f1e4:	eb 27                	jmp    f20d <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    f1e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1e9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    f1ec:	83 c2 08             	add    $0x8,%edx
    f1ef:	50                   	push   %eax
    f1f0:	ff 75 14             	pushl  0x14(%ebp)
    f1f3:	52                   	push   %edx
    f1f4:	e8 e2 aa ff ff       	call   9cdb <lodepng_memcpy>
    f1f9:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    f1fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f1ff:	50                   	push   %eax
    f200:	e8 b9 fb ff ff       	call   edbe <lodepng_chunk_generate_crc>
    f205:	83 c4 04             	add    $0x4,%esp

  return 0;
    f208:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f20d:	c9                   	leave  
    f20e:	c3                   	ret    

0000f20f <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    f20f:	55                   	push   %ebp
    f210:	89 e5                	mov    %esp,%ebp
    f212:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    f215:	8b 45 0c             	mov    0xc(%ebp),%eax
    f218:	8b 08                	mov    (%eax),%ecx
    f21a:	8b 45 08             	mov    0x8(%ebp),%eax
    f21d:	8b 10                	mov    (%eax),%edx
    f21f:	8d 45 f0             	lea    -0x10(%ebp),%eax
    f222:	51                   	push   %ecx
    f223:	52                   	push   %edx
    f224:	50                   	push   %eax
    f225:	e8 34 ad ff ff       	call   9f5e <ucvector_init>
    f22a:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    f22d:	ff 75 18             	pushl  0x18(%ebp)
    f230:	ff 75 14             	pushl  0x14(%ebp)
    f233:	ff 75 10             	pushl  0x10(%ebp)
    f236:	8d 45 f0             	lea    -0x10(%ebp),%eax
    f239:	50                   	push   %eax
    f23a:	e8 7e ff ff ff       	call   f1bd <lodepng_chunk_createv>
    f23f:	83 c4 10             	add    $0x10,%esp
    f242:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    f245:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f248:	8b 45 08             	mov    0x8(%ebp),%eax
    f24b:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    f24d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f250:	8b 45 0c             	mov    0xc(%ebp),%eax
    f253:	89 10                	mov    %edx,(%eax)
  return error;
    f255:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    f258:	c9                   	leave  
    f259:	c3                   	ret    

0000f25a <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    f25a:	55                   	push   %ebp
    f25b:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    f25d:	8b 45 08             	mov    0x8(%ebp),%eax
    f260:	83 f8 03             	cmp    $0x3,%eax
    f263:	74 6d                	je     f2d2 <checkColorValidity+0x78>
    f265:	83 f8 03             	cmp    $0x3,%eax
    f268:	77 0e                	ja     f278 <checkColorValidity+0x1e>
    f26a:	85 c0                	test   %eax,%eax
    f26c:	74 28                	je     f296 <checkColorValidity+0x3c>
    f26e:	83 f8 02             	cmp    $0x2,%eax
    f271:	74 4c                	je     f2bf <checkColorValidity+0x65>
    f273:	e9 a6 00 00 00       	jmp    f31e <checkColorValidity+0xc4>
    f278:	83 f8 06             	cmp    $0x6,%eax
    f27b:	0f 84 83 00 00 00    	je     f304 <checkColorValidity+0xaa>
    f281:	3d ff 00 00 00       	cmp    $0xff,%eax
    f286:	0f 84 8b 00 00 00    	je     f317 <checkColorValidity+0xbd>
    f28c:	83 f8 04             	cmp    $0x4,%eax
    f28f:	74 60                	je     f2f1 <checkColorValidity+0x97>
    f291:	e9 88 00 00 00       	jmp    f31e <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    f296:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    f29a:	0f 84 85 00 00 00    	je     f325 <checkColorValidity+0xcb>
    f2a0:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    f2a4:	74 7f                	je     f325 <checkColorValidity+0xcb>
    f2a6:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    f2aa:	74 79                	je     f325 <checkColorValidity+0xcb>
    f2ac:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    f2b0:	74 73                	je     f325 <checkColorValidity+0xcb>
    f2b2:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    f2b6:	74 6d                	je     f325 <checkColorValidity+0xcb>
    f2b8:	b8 25 00 00 00       	mov    $0x25,%eax
    f2bd:	eb 78                	jmp    f337 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    f2bf:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    f2c3:	74 63                	je     f328 <checkColorValidity+0xce>
    f2c5:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    f2c9:	74 5d                	je     f328 <checkColorValidity+0xce>
    f2cb:	b8 25 00 00 00       	mov    $0x25,%eax
    f2d0:	eb 65                	jmp    f337 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    f2d2:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    f2d6:	74 53                	je     f32b <checkColorValidity+0xd1>
    f2d8:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    f2dc:	74 4d                	je     f32b <checkColorValidity+0xd1>
    f2de:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    f2e2:	74 47                	je     f32b <checkColorValidity+0xd1>
    f2e4:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    f2e8:	74 41                	je     f32b <checkColorValidity+0xd1>
    f2ea:	b8 25 00 00 00       	mov    $0x25,%eax
    f2ef:	eb 46                	jmp    f337 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    f2f1:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    f2f5:	74 37                	je     f32e <checkColorValidity+0xd4>
    f2f7:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    f2fb:	74 31                	je     f32e <checkColorValidity+0xd4>
    f2fd:	b8 25 00 00 00       	mov    $0x25,%eax
    f302:	eb 33                	jmp    f337 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    f304:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    f308:	74 27                	je     f331 <checkColorValidity+0xd7>
    f30a:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    f30e:	74 21                	je     f331 <checkColorValidity+0xd7>
    f310:	b8 25 00 00 00       	mov    $0x25,%eax
    f315:	eb 20                	jmp    f337 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    f317:	b8 1f 00 00 00       	mov    $0x1f,%eax
    f31c:	eb 19                	jmp    f337 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    f31e:	b8 1f 00 00 00       	mov    $0x1f,%eax
    f323:	eb 12                	jmp    f337 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    f325:	90                   	nop
    f326:	eb 0a                	jmp    f332 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    f328:	90                   	nop
    f329:	eb 07                	jmp    f332 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    f32b:	90                   	nop
    f32c:	eb 04                	jmp    f332 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    f32e:	90                   	nop
    f32f:	eb 01                	jmp    f332 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    f331:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    f332:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f337:	5d                   	pop    %ebp
    f338:	c3                   	ret    

0000f339 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    f339:	55                   	push   %ebp
    f33a:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    f33c:	8b 45 08             	mov    0x8(%ebp),%eax
    f33f:	83 f8 03             	cmp    $0x3,%eax
    f342:	74 31                	je     f375 <getNumColorChannels+0x3c>
    f344:	83 f8 03             	cmp    $0x3,%eax
    f347:	77 0b                	ja     f354 <getNumColorChannels+0x1b>
    f349:	85 c0                	test   %eax,%eax
    f34b:	74 1a                	je     f367 <getNumColorChannels+0x2e>
    f34d:	83 f8 02             	cmp    $0x2,%eax
    f350:	74 1c                	je     f36e <getNumColorChannels+0x35>
    f352:	eb 3d                	jmp    f391 <getNumColorChannels+0x58>
    f354:	83 f8 06             	cmp    $0x6,%eax
    f357:	74 2a                	je     f383 <getNumColorChannels+0x4a>
    f359:	3d ff 00 00 00       	cmp    $0xff,%eax
    f35e:	74 2a                	je     f38a <getNumColorChannels+0x51>
    f360:	83 f8 04             	cmp    $0x4,%eax
    f363:	74 17                	je     f37c <getNumColorChannels+0x43>
    f365:	eb 2a                	jmp    f391 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    f367:	b8 01 00 00 00       	mov    $0x1,%eax
    f36c:	eb 28                	jmp    f396 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    f36e:	b8 03 00 00 00       	mov    $0x3,%eax
    f373:	eb 21                	jmp    f396 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    f375:	b8 01 00 00 00       	mov    $0x1,%eax
    f37a:	eb 1a                	jmp    f396 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    f37c:	b8 02 00 00 00       	mov    $0x2,%eax
    f381:	eb 13                	jmp    f396 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    f383:	b8 04 00 00 00       	mov    $0x4,%eax
    f388:	eb 0c                	jmp    f396 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    f38a:	b8 00 00 00 00       	mov    $0x0,%eax
    f38f:	eb 05                	jmp    f396 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    f391:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    f396:	5d                   	pop    %ebp
    f397:	c3                   	ret    

0000f398 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    f398:	55                   	push   %ebp
    f399:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    f39b:	ff 75 08             	pushl  0x8(%ebp)
    f39e:	e8 96 ff ff ff       	call   f339 <getNumColorChannels>
    f3a3:	83 c4 04             	add    $0x4,%esp
    f3a6:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    f3aa:	c9                   	leave  
    f3ab:	c3                   	ret    

0000f3ac <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    f3ac:	55                   	push   %ebp
    f3ad:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    f3af:	8b 45 08             	mov    0x8(%ebp),%eax
    f3b2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    f3b9:	8b 45 08             	mov    0x8(%ebp),%eax
    f3bc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    f3c3:	8b 45 08             	mov    0x8(%ebp),%eax
    f3c6:	8b 50 1c             	mov    0x1c(%eax),%edx
    f3c9:	8b 45 08             	mov    0x8(%ebp),%eax
    f3cc:	89 50 18             	mov    %edx,0x18(%eax)
    f3cf:	8b 45 08             	mov    0x8(%ebp),%eax
    f3d2:	8b 50 18             	mov    0x18(%eax),%edx
    f3d5:	8b 45 08             	mov    0x8(%ebp),%eax
    f3d8:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    f3db:	8b 45 08             	mov    0x8(%ebp),%eax
    f3de:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    f3e4:	8b 45 08             	mov    0x8(%ebp),%eax
    f3e7:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    f3ee:	8b 45 08             	mov    0x8(%ebp),%eax
    f3f1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    f3f8:	8b 45 08             	mov    0x8(%ebp),%eax
    f3fb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    f402:	90                   	nop
    f403:	5d                   	pop    %ebp
    f404:	c3                   	ret    

0000f405 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    f405:	55                   	push   %ebp
    f406:	89 e5                	mov    %esp,%ebp
    f408:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    f40b:	8b 45 08             	mov    0x8(%ebp),%eax
    f40e:	8b 40 08             	mov    0x8(%eax),%eax
    f411:	85 c0                	test   %eax,%eax
    f413:	75 18                	jne    f42d <lodepng_color_mode_alloc_palette+0x28>
    f415:	83 ec 0c             	sub    $0xc,%esp
    f418:	68 00 04 00 00       	push   $0x400
    f41d:	e8 7b a8 ff ff       	call   9c9d <lodepng_malloc>
    f422:	83 c4 10             	add    $0x10,%esp
    f425:	89 c2                	mov    %eax,%edx
    f427:	8b 45 08             	mov    0x8(%ebp),%eax
    f42a:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    f42d:	8b 45 08             	mov    0x8(%ebp),%eax
    f430:	8b 40 08             	mov    0x8(%eax),%eax
    f433:	85 c0                	test   %eax,%eax
    f435:	74 65                	je     f49c <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    f437:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    f43e:	eb 51                	jmp    f491 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    f440:	8b 45 08             	mov    0x8(%ebp),%eax
    f443:	8b 40 08             	mov    0x8(%eax),%eax
    f446:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f449:	c1 e2 02             	shl    $0x2,%edx
    f44c:	01 d0                	add    %edx,%eax
    f44e:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    f451:	8b 45 08             	mov    0x8(%ebp),%eax
    f454:	8b 40 08             	mov    0x8(%eax),%eax
    f457:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f45a:	c1 e2 02             	shl    $0x2,%edx
    f45d:	83 c2 01             	add    $0x1,%edx
    f460:	01 d0                	add    %edx,%eax
    f462:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    f465:	8b 45 08             	mov    0x8(%ebp),%eax
    f468:	8b 40 08             	mov    0x8(%eax),%eax
    f46b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f46e:	c1 e2 02             	shl    $0x2,%edx
    f471:	83 c2 02             	add    $0x2,%edx
    f474:	01 d0                	add    %edx,%eax
    f476:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    f479:	8b 45 08             	mov    0x8(%ebp),%eax
    f47c:	8b 40 08             	mov    0x8(%eax),%eax
    f47f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f482:	c1 e2 02             	shl    $0x2,%edx
    f485:	83 c2 03             	add    $0x3,%edx
    f488:	01 d0                	add    %edx,%eax
    f48a:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    f48d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f491:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    f498:	75 a6                	jne    f440 <lodepng_color_mode_alloc_palette+0x3b>
    f49a:	eb 01                	jmp    f49d <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    f49c:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    f49d:	c9                   	leave  
    f49e:	c3                   	ret    

0000f49f <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    f49f:	55                   	push   %ebp
    f4a0:	89 e5                	mov    %esp,%ebp
    f4a2:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    f4a5:	83 ec 0c             	sub    $0xc,%esp
    f4a8:	ff 75 08             	pushl  0x8(%ebp)
    f4ab:	e8 f3 01 00 00       	call   f6a3 <lodepng_palette_clear>
    f4b0:	83 c4 10             	add    $0x10,%esp
}
    f4b3:	90                   	nop
    f4b4:	c9                   	leave  
    f4b5:	c3                   	ret    

0000f4b6 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    f4b6:	55                   	push   %ebp
    f4b7:	89 e5                	mov    %esp,%ebp
    f4b9:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    f4bc:	83 ec 0c             	sub    $0xc,%esp
    f4bf:	ff 75 08             	pushl  0x8(%ebp)
    f4c2:	e8 d8 ff ff ff       	call   f49f <lodepng_color_mode_cleanup>
    f4c7:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    f4ca:	83 ec 04             	sub    $0x4,%esp
    f4cd:	6a 20                	push   $0x20
    f4cf:	ff 75 0c             	pushl  0xc(%ebp)
    f4d2:	ff 75 08             	pushl  0x8(%ebp)
    f4d5:	e8 01 a8 ff ff       	call   9cdb <lodepng_memcpy>
    f4da:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    f4dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4e0:	8b 40 08             	mov    0x8(%eax),%eax
    f4e3:	85 c0                	test   %eax,%eax
    f4e5:	74 5a                	je     f541 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    f4e7:	83 ec 0c             	sub    $0xc,%esp
    f4ea:	68 00 04 00 00       	push   $0x400
    f4ef:	e8 a9 a7 ff ff       	call   9c9d <lodepng_malloc>
    f4f4:	83 c4 10             	add    $0x10,%esp
    f4f7:	89 c2                	mov    %eax,%edx
    f4f9:	8b 45 08             	mov    0x8(%ebp),%eax
    f4fc:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    f4ff:	8b 45 08             	mov    0x8(%ebp),%eax
    f502:	8b 40 08             	mov    0x8(%eax),%eax
    f505:	85 c0                	test   %eax,%eax
    f507:	75 11                	jne    f51a <lodepng_color_mode_copy+0x64>
    f509:	8b 45 0c             	mov    0xc(%ebp),%eax
    f50c:	8b 40 0c             	mov    0xc(%eax),%eax
    f50f:	85 c0                	test   %eax,%eax
    f511:	74 07                	je     f51a <lodepng_color_mode_copy+0x64>
    f513:	b8 53 00 00 00       	mov    $0x53,%eax
    f518:	eb 2c                	jmp    f546 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    f51a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f51d:	8b 40 0c             	mov    0xc(%eax),%eax
    f520:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    f527:	8b 45 0c             	mov    0xc(%ebp),%eax
    f52a:	8b 50 08             	mov    0x8(%eax),%edx
    f52d:	8b 45 08             	mov    0x8(%ebp),%eax
    f530:	8b 40 08             	mov    0x8(%eax),%eax
    f533:	83 ec 04             	sub    $0x4,%esp
    f536:	51                   	push   %ecx
    f537:	52                   	push   %edx
    f538:	50                   	push   %eax
    f539:	e8 9d a7 ff ff       	call   9cdb <lodepng_memcpy>
    f53e:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    f541:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f546:	c9                   	leave  
    f547:	c3                   	ret    

0000f548 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    f548:	55                   	push   %ebp
    f549:	89 e5                	mov    %esp,%ebp
    f54b:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    f54e:	8d 45 e0             	lea    -0x20(%ebp),%eax
    f551:	50                   	push   %eax
    f552:	e8 55 fe ff ff       	call   f3ac <lodepng_color_mode_init>
    f557:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    f55a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f55d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    f560:	8b 45 10             	mov    0x10(%ebp),%eax
    f563:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    f566:	8b 45 08             	mov    0x8(%ebp),%eax
    f569:	8b 55 e0             	mov    -0x20(%ebp),%edx
    f56c:	89 10                	mov    %edx,(%eax)
    f56e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f571:	89 50 04             	mov    %edx,0x4(%eax)
    f574:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f577:	89 50 08             	mov    %edx,0x8(%eax)
    f57a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f57d:	89 50 0c             	mov    %edx,0xc(%eax)
    f580:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f583:	89 50 10             	mov    %edx,0x10(%eax)
    f586:	8b 55 f4             	mov    -0xc(%ebp),%edx
    f589:	89 50 14             	mov    %edx,0x14(%eax)
    f58c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    f58f:	89 50 18             	mov    %edx,0x18(%eax)
    f592:	8b 55 fc             	mov    -0x4(%ebp),%edx
    f595:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    f598:	8b 45 08             	mov    0x8(%ebp),%eax
    f59b:	c9                   	leave  
    f59c:	c2 04 00             	ret    $0x4

0000f59f <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    f59f:	55                   	push   %ebp
    f5a0:	89 e5                	mov    %esp,%ebp
    f5a2:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    f5a5:	8b 45 08             	mov    0x8(%ebp),%eax
    f5a8:	8b 10                	mov    (%eax),%edx
    f5aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5ad:	8b 00                	mov    (%eax),%eax
    f5af:	39 c2                	cmp    %eax,%edx
    f5b1:	74 0a                	je     f5bd <lodepng_color_mode_equal+0x1e>
    f5b3:	b8 00 00 00 00       	mov    $0x0,%eax
    f5b8:	e9 e4 00 00 00       	jmp    f6a1 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    f5bd:	8b 45 08             	mov    0x8(%ebp),%eax
    f5c0:	8b 50 04             	mov    0x4(%eax),%edx
    f5c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5c6:	8b 40 04             	mov    0x4(%eax),%eax
    f5c9:	39 c2                	cmp    %eax,%edx
    f5cb:	74 0a                	je     f5d7 <lodepng_color_mode_equal+0x38>
    f5cd:	b8 00 00 00 00       	mov    $0x0,%eax
    f5d2:	e9 ca 00 00 00       	jmp    f6a1 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    f5d7:	8b 45 08             	mov    0x8(%ebp),%eax
    f5da:	8b 50 10             	mov    0x10(%eax),%edx
    f5dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5e0:	8b 40 10             	mov    0x10(%eax),%eax
    f5e3:	39 c2                	cmp    %eax,%edx
    f5e5:	74 0a                	je     f5f1 <lodepng_color_mode_equal+0x52>
    f5e7:	b8 00 00 00 00       	mov    $0x0,%eax
    f5ec:	e9 b0 00 00 00       	jmp    f6a1 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    f5f1:	8b 45 08             	mov    0x8(%ebp),%eax
    f5f4:	8b 40 10             	mov    0x10(%eax),%eax
    f5f7:	85 c0                	test   %eax,%eax
    f5f9:	74 48                	je     f643 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    f5fb:	8b 45 08             	mov    0x8(%ebp),%eax
    f5fe:	8b 50 14             	mov    0x14(%eax),%edx
    f601:	8b 45 0c             	mov    0xc(%ebp),%eax
    f604:	8b 40 14             	mov    0x14(%eax),%eax
    f607:	39 c2                	cmp    %eax,%edx
    f609:	74 0a                	je     f615 <lodepng_color_mode_equal+0x76>
    f60b:	b8 00 00 00 00       	mov    $0x0,%eax
    f610:	e9 8c 00 00 00       	jmp    f6a1 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    f615:	8b 45 08             	mov    0x8(%ebp),%eax
    f618:	8b 50 18             	mov    0x18(%eax),%edx
    f61b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f61e:	8b 40 18             	mov    0x18(%eax),%eax
    f621:	39 c2                	cmp    %eax,%edx
    f623:	74 07                	je     f62c <lodepng_color_mode_equal+0x8d>
    f625:	b8 00 00 00 00       	mov    $0x0,%eax
    f62a:	eb 75                	jmp    f6a1 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    f62c:	8b 45 08             	mov    0x8(%ebp),%eax
    f62f:	8b 50 1c             	mov    0x1c(%eax),%edx
    f632:	8b 45 0c             	mov    0xc(%ebp),%eax
    f635:	8b 40 1c             	mov    0x1c(%eax),%eax
    f638:	39 c2                	cmp    %eax,%edx
    f63a:	74 07                	je     f643 <lodepng_color_mode_equal+0xa4>
    f63c:	b8 00 00 00 00       	mov    $0x0,%eax
    f641:	eb 5e                	jmp    f6a1 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    f643:	8b 45 08             	mov    0x8(%ebp),%eax
    f646:	8b 50 0c             	mov    0xc(%eax),%edx
    f649:	8b 45 0c             	mov    0xc(%ebp),%eax
    f64c:	8b 40 0c             	mov    0xc(%eax),%eax
    f64f:	39 c2                	cmp    %eax,%edx
    f651:	74 07                	je     f65a <lodepng_color_mode_equal+0xbb>
    f653:	b8 00 00 00 00       	mov    $0x0,%eax
    f658:	eb 47                	jmp    f6a1 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    f65a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f661:	eb 2b                	jmp    f68e <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    f663:	8b 45 08             	mov    0x8(%ebp),%eax
    f666:	8b 50 08             	mov    0x8(%eax),%edx
    f669:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f66c:	01 d0                	add    %edx,%eax
    f66e:	0f b6 10             	movzbl (%eax),%edx
    f671:	8b 45 0c             	mov    0xc(%ebp),%eax
    f674:	8b 48 08             	mov    0x8(%eax),%ecx
    f677:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f67a:	01 c8                	add    %ecx,%eax
    f67c:	0f b6 00             	movzbl (%eax),%eax
    f67f:	38 c2                	cmp    %al,%dl
    f681:	74 07                	je     f68a <lodepng_color_mode_equal+0xeb>
    f683:	b8 00 00 00 00       	mov    $0x0,%eax
    f688:	eb 17                	jmp    f6a1 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    f68a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f68e:	8b 45 08             	mov    0x8(%ebp),%eax
    f691:	8b 40 0c             	mov    0xc(%eax),%eax
    f694:	c1 e0 02             	shl    $0x2,%eax
    f697:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    f69a:	75 c7                	jne    f663 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    f69c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    f6a1:	c9                   	leave  
    f6a2:	c3                   	ret    

0000f6a3 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    f6a3:	55                   	push   %ebp
    f6a4:	89 e5                	mov    %esp,%ebp
    f6a6:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    f6a9:	8b 45 08             	mov    0x8(%ebp),%eax
    f6ac:	8b 40 08             	mov    0x8(%eax),%eax
    f6af:	85 c0                	test   %eax,%eax
    f6b1:	74 12                	je     f6c5 <lodepng_palette_clear+0x22>
    f6b3:	8b 45 08             	mov    0x8(%ebp),%eax
    f6b6:	8b 40 08             	mov    0x8(%eax),%eax
    f6b9:	83 ec 0c             	sub    $0xc,%esp
    f6bc:	50                   	push   %eax
    f6bd:	e8 fc a5 ff ff       	call   9cbe <lodepng_free>
    f6c2:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    f6c5:	8b 45 08             	mov    0x8(%ebp),%eax
    f6c8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    f6cf:	8b 45 08             	mov    0x8(%ebp),%eax
    f6d2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    f6d9:	90                   	nop
    f6da:	c9                   	leave  
    f6db:	c3                   	ret    

0000f6dc <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    f6dc:	55                   	push   %ebp
    f6dd:	89 e5                	mov    %esp,%ebp
    f6df:	53                   	push   %ebx
    f6e0:	83 ec 14             	sub    $0x14,%esp
    f6e3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    f6e6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f6e9:	8b 55 14             	mov    0x14(%ebp),%edx
    f6ec:	8b 45 18             	mov    0x18(%ebp),%eax
    f6ef:	88 5d f4             	mov    %bl,-0xc(%ebp)
    f6f2:	88 4d f0             	mov    %cl,-0x10(%ebp)
    f6f5:	88 55 ec             	mov    %dl,-0x14(%ebp)
    f6f8:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    f6fb:	8b 45 08             	mov    0x8(%ebp),%eax
    f6fe:	8b 40 08             	mov    0x8(%eax),%eax
    f701:	85 c0                	test   %eax,%eax
    f703:	75 22                	jne    f727 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    f705:	83 ec 0c             	sub    $0xc,%esp
    f708:	ff 75 08             	pushl  0x8(%ebp)
    f70b:	e8 f5 fc ff ff       	call   f405 <lodepng_color_mode_alloc_palette>
    f710:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    f713:	8b 45 08             	mov    0x8(%ebp),%eax
    f716:	8b 40 08             	mov    0x8(%eax),%eax
    f719:	85 c0                	test   %eax,%eax
    f71b:	75 0a                	jne    f727 <lodepng_palette_add+0x4b>
    f71d:	b8 53 00 00 00       	mov    $0x53,%eax
    f722:	e9 8d 00 00 00       	jmp    f7b4 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    f727:	8b 45 08             	mov    0x8(%ebp),%eax
    f72a:	8b 40 0c             	mov    0xc(%eax),%eax
    f72d:	3d ff 00 00 00       	cmp    $0xff,%eax
    f732:	7e 07                	jle    f73b <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    f734:	b8 6c 00 00 00       	mov    $0x6c,%eax
    f739:	eb 79                	jmp    f7b4 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    f73b:	8b 45 08             	mov    0x8(%ebp),%eax
    f73e:	8b 50 08             	mov    0x8(%eax),%edx
    f741:	8b 45 08             	mov    0x8(%ebp),%eax
    f744:	8b 40 0c             	mov    0xc(%eax),%eax
    f747:	c1 e0 02             	shl    $0x2,%eax
    f74a:	01 c2                	add    %eax,%edx
    f74c:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    f750:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    f752:	8b 45 08             	mov    0x8(%ebp),%eax
    f755:	8b 50 08             	mov    0x8(%eax),%edx
    f758:	8b 45 08             	mov    0x8(%ebp),%eax
    f75b:	8b 40 0c             	mov    0xc(%eax),%eax
    f75e:	c1 e0 02             	shl    $0x2,%eax
    f761:	83 c0 01             	add    $0x1,%eax
    f764:	01 c2                	add    %eax,%edx
    f766:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    f76a:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    f76c:	8b 45 08             	mov    0x8(%ebp),%eax
    f76f:	8b 50 08             	mov    0x8(%eax),%edx
    f772:	8b 45 08             	mov    0x8(%ebp),%eax
    f775:	8b 40 0c             	mov    0xc(%eax),%eax
    f778:	c1 e0 02             	shl    $0x2,%eax
    f77b:	83 c0 02             	add    $0x2,%eax
    f77e:	01 c2                	add    %eax,%edx
    f780:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    f784:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    f786:	8b 45 08             	mov    0x8(%ebp),%eax
    f789:	8b 50 08             	mov    0x8(%eax),%edx
    f78c:	8b 45 08             	mov    0x8(%ebp),%eax
    f78f:	8b 40 0c             	mov    0xc(%eax),%eax
    f792:	c1 e0 02             	shl    $0x2,%eax
    f795:	83 c0 03             	add    $0x3,%eax
    f798:	01 c2                	add    %eax,%edx
    f79a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    f79e:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    f7a0:	8b 45 08             	mov    0x8(%ebp),%eax
    f7a3:	8b 40 0c             	mov    0xc(%eax),%eax
    f7a6:	8d 50 01             	lea    0x1(%eax),%edx
    f7a9:	8b 45 08             	mov    0x8(%ebp),%eax
    f7ac:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    f7af:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f7b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f7b7:	c9                   	leave  
    f7b8:	c3                   	ret    

0000f7b9 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    f7b9:	55                   	push   %ebp
    f7ba:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    f7bc:	8b 45 08             	mov    0x8(%ebp),%eax
    f7bf:	8b 50 04             	mov    0x4(%eax),%edx
    f7c2:	8b 45 08             	mov    0x8(%ebp),%eax
    f7c5:	8b 00                	mov    (%eax),%eax
    f7c7:	52                   	push   %edx
    f7c8:	50                   	push   %eax
    f7c9:	e8 ca fb ff ff       	call   f398 <lodepng_get_bpp_lct>
    f7ce:	83 c4 08             	add    $0x8,%esp
}
    f7d1:	c9                   	leave  
    f7d2:	c3                   	ret    

0000f7d3 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    f7d3:	55                   	push   %ebp
    f7d4:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    f7d6:	8b 45 08             	mov    0x8(%ebp),%eax
    f7d9:	8b 00                	mov    (%eax),%eax
    f7db:	50                   	push   %eax
    f7dc:	e8 58 fb ff ff       	call   f339 <getNumColorChannels>
    f7e1:	83 c4 04             	add    $0x4,%esp
}
    f7e4:	c9                   	leave  
    f7e5:	c3                   	ret    

0000f7e6 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    f7e6:	55                   	push   %ebp
    f7e7:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    f7e9:	8b 45 08             	mov    0x8(%ebp),%eax
    f7ec:	8b 00                	mov    (%eax),%eax
    f7ee:	85 c0                	test   %eax,%eax
    f7f0:	74 0a                	je     f7fc <lodepng_is_greyscale_type+0x16>
    f7f2:	8b 45 08             	mov    0x8(%ebp),%eax
    f7f5:	8b 00                	mov    (%eax),%eax
    f7f7:	83 f8 04             	cmp    $0x4,%eax
    f7fa:	75 07                	jne    f803 <lodepng_is_greyscale_type+0x1d>
    f7fc:	b8 01 00 00 00       	mov    $0x1,%eax
    f801:	eb 05                	jmp    f808 <lodepng_is_greyscale_type+0x22>
    f803:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f808:	5d                   	pop    %ebp
    f809:	c3                   	ret    

0000f80a <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    f80a:	55                   	push   %ebp
    f80b:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    f80d:	8b 45 08             	mov    0x8(%ebp),%eax
    f810:	8b 00                	mov    (%eax),%eax
    f812:	83 e0 04             	and    $0x4,%eax
    f815:	85 c0                	test   %eax,%eax
    f817:	0f 95 c0             	setne  %al
    f81a:	0f b6 c0             	movzbl %al,%eax
}
    f81d:	5d                   	pop    %ebp
    f81e:	c3                   	ret    

0000f81f <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    f81f:	55                   	push   %ebp
    f820:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    f822:	8b 45 08             	mov    0x8(%ebp),%eax
    f825:	8b 00                	mov    (%eax),%eax
    f827:	83 f8 03             	cmp    $0x3,%eax
    f82a:	0f 94 c0             	sete   %al
    f82d:	0f b6 c0             	movzbl %al,%eax
}
    f830:	5d                   	pop    %ebp
    f831:	c3                   	ret    

0000f832 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    f832:	55                   	push   %ebp
    f833:	89 e5                	mov    %esp,%ebp
    f835:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    f838:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f83f:	eb 23                	jmp    f864 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    f841:	8b 45 08             	mov    0x8(%ebp),%eax
    f844:	8b 40 08             	mov    0x8(%eax),%eax
    f847:	8b 55 fc             	mov    -0x4(%ebp),%edx
    f84a:	c1 e2 02             	shl    $0x2,%edx
    f84d:	83 c2 03             	add    $0x3,%edx
    f850:	01 d0                	add    %edx,%eax
    f852:	0f b6 00             	movzbl (%eax),%eax
    f855:	3c ff                	cmp    $0xff,%al
    f857:	74 07                	je     f860 <lodepng_has_palette_alpha+0x2e>
    f859:	b8 01 00 00 00       	mov    $0x1,%eax
    f85e:	eb 14                	jmp    f874 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    f860:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    f864:	8b 45 08             	mov    0x8(%ebp),%eax
    f867:	8b 40 0c             	mov    0xc(%eax),%eax
    f86a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    f86d:	75 d2                	jne    f841 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    f86f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f874:	c9                   	leave  
    f875:	c3                   	ret    

0000f876 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    f876:	55                   	push   %ebp
    f877:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    f879:	8b 45 08             	mov    0x8(%ebp),%eax
    f87c:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    f87f:	85 c0                	test   %eax,%eax
    f881:	75 1e                	jne    f8a1 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    f883:	ff 75 08             	pushl  0x8(%ebp)
    f886:	e8 7f ff ff ff       	call   f80a <lodepng_is_alpha_type>
    f88b:	83 c4 04             	add    $0x4,%esp
    f88e:	85 c0                	test   %eax,%eax
    f890:	75 0f                	jne    f8a1 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    f892:	ff 75 08             	pushl  0x8(%ebp)
    f895:	e8 98 ff ff ff       	call   f832 <lodepng_has_palette_alpha>
    f89a:	83 c4 04             	add    $0x4,%esp
    f89d:	85 c0                	test   %eax,%eax
    f89f:	74 07                	je     f8a8 <lodepng_can_have_alpha+0x32>
    f8a1:	b8 01 00 00 00       	mov    $0x1,%eax
    f8a6:	eb 05                	jmp    f8ad <lodepng_can_have_alpha+0x37>
    f8a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f8ad:	c9                   	leave  
    f8ae:	c3                   	ret    

0000f8af <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    f8af:	55                   	push   %ebp
    f8b0:	89 e5                	mov    %esp,%ebp
    f8b2:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    f8b5:	ff 75 14             	pushl  0x14(%ebp)
    f8b8:	ff 75 10             	pushl  0x10(%ebp)
    f8bb:	e8 d8 fa ff ff       	call   f398 <lodepng_get_bpp_lct>
    f8c0:	83 c4 08             	add    $0x8,%esp
    f8c3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    f8c6:	8b 55 08             	mov    0x8(%ebp),%edx
    f8c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f8cc:	0f af c2             	imul   %edx,%eax
    f8cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    f8d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f8d5:	c1 e8 03             	shr    $0x3,%eax
    f8d8:	89 c2                	mov    %eax,%edx
    f8da:	8b 45 fc             	mov    -0x4(%ebp),%eax
    f8dd:	0f af c2             	imul   %edx,%eax
    f8e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    f8e3:	89 d1                	mov    %edx,%ecx
    f8e5:	83 e1 07             	and    $0x7,%ecx
    f8e8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    f8eb:	0f af d1             	imul   %ecx,%edx
    f8ee:	83 c2 07             	add    $0x7,%edx
    f8f1:	c1 ea 03             	shr    $0x3,%edx
    f8f4:	01 d0                	add    %edx,%eax
}
    f8f6:	c9                   	leave  
    f8f7:	c3                   	ret    

0000f8f8 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    f8f8:	55                   	push   %ebp
    f8f9:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    f8fb:	8b 45 10             	mov    0x10(%ebp),%eax
    f8fe:	8b 50 04             	mov    0x4(%eax),%edx
    f901:	8b 45 10             	mov    0x10(%ebp),%eax
    f904:	8b 00                	mov    (%eax),%eax
    f906:	52                   	push   %edx
    f907:	50                   	push   %eax
    f908:	ff 75 0c             	pushl  0xc(%ebp)
    f90b:	ff 75 08             	pushl  0x8(%ebp)
    f90e:	e8 9c ff ff ff       	call   f8af <lodepng_get_raw_size_lct>
    f913:	83 c4 10             	add    $0x10,%esp
}
    f916:	c9                   	leave  
    f917:	c3                   	ret    

0000f918 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    f918:	55                   	push   %ebp
    f919:	89 e5                	mov    %esp,%ebp
    f91b:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    f91e:	8b 45 08             	mov    0x8(%ebp),%eax
    f921:	c1 e8 03             	shr    $0x3,%eax
    f924:	0f af 45 10          	imul   0x10(%ebp),%eax
    f928:	8b 55 08             	mov    0x8(%ebp),%edx
    f92b:	83 e2 07             	and    $0x7,%edx
    f92e:	0f af 55 10          	imul   0x10(%ebp),%edx
    f932:	83 c2 07             	add    $0x7,%edx
    f935:	c1 ea 03             	shr    $0x3,%edx
    f938:	01 d0                	add    %edx,%eax
    f93a:	83 c0 01             	add    $0x1,%eax
    f93d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    f940:	8b 45 0c             	mov    0xc(%ebp),%eax
    f943:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    f947:	c9                   	leave  
    f948:	c3                   	ret    

0000f949 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    f949:	55                   	push   %ebp
    f94a:	89 e5                	mov    %esp,%ebp
    f94c:	53                   	push   %ebx
    f94d:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    f950:	ff 75 10             	pushl  0x10(%ebp)
    f953:	e8 61 fe ff ff       	call   f7b9 <lodepng_get_bpp>
    f958:	83 c4 04             	add    $0x4,%esp
    f95b:	89 c3                	mov    %eax,%ebx
    f95d:	ff 75 14             	pushl  0x14(%ebp)
    f960:	e8 54 fe ff ff       	call   f7b9 <lodepng_get_bpp>
    f965:	83 c4 04             	add    $0x4,%esp
    f968:	39 c3                	cmp    %eax,%ebx
    f96a:	76 0d                	jbe    f979 <lodepng_pixel_overflow+0x30>
    f96c:	ff 75 10             	pushl  0x10(%ebp)
    f96f:	e8 45 fe ff ff       	call   f7b9 <lodepng_get_bpp>
    f974:	83 c4 04             	add    $0x4,%esp
    f977:	eb 0b                	jmp    f984 <lodepng_pixel_overflow+0x3b>
    f979:	ff 75 14             	pushl  0x14(%ebp)
    f97c:	e8 38 fe ff ff       	call   f7b9 <lodepng_get_bpp>
    f981:	83 c4 04             	add    $0x4,%esp
    f984:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    f987:	8b 55 0c             	mov    0xc(%ebp),%edx
    f98a:	8b 45 08             	mov    0x8(%ebp),%eax
    f98d:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    f990:	51                   	push   %ecx
    f991:	52                   	push   %edx
    f992:	50                   	push   %eax
    f993:	e8 e9 a3 ff ff       	call   9d81 <lodepng_mulofl>
    f998:	83 c4 0c             	add    $0xc,%esp
    f99b:	85 c0                	test   %eax,%eax
    f99d:	74 0a                	je     f9a9 <lodepng_pixel_overflow+0x60>
    f99f:	b8 01 00 00 00       	mov    $0x1,%eax
    f9a4:	e9 b6 00 00 00       	jmp    fa5f <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    f9a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f9ac:	8d 55 f0             	lea    -0x10(%ebp),%edx
    f9af:	52                   	push   %edx
    f9b0:	6a 08                	push   $0x8
    f9b2:	50                   	push   %eax
    f9b3:	e8 c9 a3 ff ff       	call   9d81 <lodepng_mulofl>
    f9b8:	83 c4 0c             	add    $0xc,%esp
    f9bb:	85 c0                	test   %eax,%eax
    f9bd:	74 0a                	je     f9c9 <lodepng_pixel_overflow+0x80>
    f9bf:	b8 01 00 00 00       	mov    $0x1,%eax
    f9c4:	e9 96 00 00 00       	jmp    fa5f <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    f9c9:	8b 45 08             	mov    0x8(%ebp),%eax
    f9cc:	c1 e8 03             	shr    $0x3,%eax
    f9cf:	89 c2                	mov    %eax,%edx
    f9d1:	8d 45 ec             	lea    -0x14(%ebp),%eax
    f9d4:	50                   	push   %eax
    f9d5:	ff 75 f8             	pushl  -0x8(%ebp)
    f9d8:	52                   	push   %edx
    f9d9:	e8 a3 a3 ff ff       	call   9d81 <lodepng_mulofl>
    f9de:	83 c4 0c             	add    $0xc,%esp
    f9e1:	85 c0                	test   %eax,%eax
    f9e3:	74 07                	je     f9ec <lodepng_pixel_overflow+0xa3>
    f9e5:	b8 01 00 00 00       	mov    $0x1,%eax
    f9ea:	eb 73                	jmp    fa5f <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    f9ec:	8b 45 08             	mov    0x8(%ebp),%eax
    f9ef:	83 e0 07             	and    $0x7,%eax
    f9f2:	89 c2                	mov    %eax,%edx
    f9f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f9f7:	0f af c2             	imul   %edx,%eax
    f9fa:	83 c0 07             	add    $0x7,%eax
    f9fd:	c1 e8 03             	shr    $0x3,%eax
    fa00:	89 c1                	mov    %eax,%ecx
    fa02:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fa05:	8d 55 ec             	lea    -0x14(%ebp),%edx
    fa08:	52                   	push   %edx
    fa09:	51                   	push   %ecx
    fa0a:	50                   	push   %eax
    fa0b:	e8 51 a3 ff ff       	call   9d61 <lodepng_addofl>
    fa10:	83 c4 0c             	add    $0xc,%esp
    fa13:	85 c0                	test   %eax,%eax
    fa15:	74 07                	je     fa1e <lodepng_pixel_overflow+0xd5>
    fa17:	b8 01 00 00 00       	mov    $0x1,%eax
    fa1c:	eb 41                	jmp    fa5f <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    fa1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fa21:	8d 55 ec             	lea    -0x14(%ebp),%edx
    fa24:	52                   	push   %edx
    fa25:	6a 05                	push   $0x5
    fa27:	50                   	push   %eax
    fa28:	e8 34 a3 ff ff       	call   9d61 <lodepng_addofl>
    fa2d:	83 c4 0c             	add    $0xc,%esp
    fa30:	85 c0                	test   %eax,%eax
    fa32:	74 07                	je     fa3b <lodepng_pixel_overflow+0xf2>
    fa34:	b8 01 00 00 00       	mov    $0x1,%eax
    fa39:	eb 24                	jmp    fa5f <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    fa3b:	8b 55 0c             	mov    0xc(%ebp),%edx
    fa3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    fa41:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    fa44:	51                   	push   %ecx
    fa45:	52                   	push   %edx
    fa46:	50                   	push   %eax
    fa47:	e8 35 a3 ff ff       	call   9d81 <lodepng_mulofl>
    fa4c:	83 c4 0c             	add    $0xc,%esp
    fa4f:	85 c0                	test   %eax,%eax
    fa51:	74 07                	je     fa5a <lodepng_pixel_overflow+0x111>
    fa53:	b8 01 00 00 00       	mov    $0x1,%eax
    fa58:	eb 05                	jmp    fa5f <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    fa5a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fa5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    fa62:	c9                   	leave  
    fa63:	c3                   	ret    

0000fa64 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    fa64:	55                   	push   %ebp
    fa65:	89 e5                	mov    %esp,%ebp
    fa67:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    fa6a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    fa71:	eb 15                	jmp    fa88 <LodePNGUnknownChunks_init+0x24>
    fa73:	8b 45 08             	mov    0x8(%ebp),%eax
    fa76:	8b 55 fc             	mov    -0x4(%ebp),%edx
    fa79:	83 c2 30             	add    $0x30,%edx
    fa7c:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    fa83:	00 
    fa84:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    fa88:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    fa8c:	75 e5                	jne    fa73 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    fa8e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    fa95:	eb 15                	jmp    faac <LodePNGUnknownChunks_init+0x48>
    fa97:	8b 45 08             	mov    0x8(%ebp),%eax
    fa9a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    fa9d:	83 c2 34             	add    $0x34,%edx
    faa0:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    faa7:	00 
    faa8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    faac:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    fab0:	75 e5                	jne    fa97 <LodePNGUnknownChunks_init+0x33>
}
    fab2:	90                   	nop
    fab3:	c9                   	leave  
    fab4:	c3                   	ret    

0000fab5 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    fab5:	55                   	push   %ebp
    fab6:	89 e5                	mov    %esp,%ebp
    fab8:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    fabb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    fac2:	eb 1d                	jmp    fae1 <LodePNGUnknownChunks_cleanup+0x2c>
    fac4:	8b 45 08             	mov    0x8(%ebp),%eax
    fac7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    faca:	83 c2 30             	add    $0x30,%edx
    facd:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    fad1:	83 ec 0c             	sub    $0xc,%esp
    fad4:	50                   	push   %eax
    fad5:	e8 e4 a1 ff ff       	call   9cbe <lodepng_free>
    fada:	83 c4 10             	add    $0x10,%esp
    fadd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    fae1:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    fae5:	75 dd                	jne    fac4 <LodePNGUnknownChunks_cleanup+0xf>
}
    fae7:	90                   	nop
    fae8:	c9                   	leave  
    fae9:	c3                   	ret    

0000faea <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    faea:	55                   	push   %ebp
    faeb:	89 e5                	mov    %esp,%ebp
    faed:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    faf0:	83 ec 0c             	sub    $0xc,%esp
    faf3:	ff 75 08             	pushl  0x8(%ebp)
    faf6:	e8 ba ff ff ff       	call   fab5 <LodePNGUnknownChunks_cleanup>
    fafb:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    fafe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    fb05:	e9 b7 00 00 00       	jmp    fbc1 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    fb0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fb10:	83 c2 34             	add    $0x34,%edx
    fb13:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    fb17:	8b 45 08             	mov    0x8(%ebp),%eax
    fb1a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    fb1d:	83 c1 34             	add    $0x34,%ecx
    fb20:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    fb24:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb27:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fb2a:	83 c2 34             	add    $0x34,%edx
    fb2d:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    fb31:	83 ec 0c             	sub    $0xc,%esp
    fb34:	50                   	push   %eax
    fb35:	e8 63 a1 ff ff       	call   9c9d <lodepng_malloc>
    fb3a:	83 c4 10             	add    $0x10,%esp
    fb3d:	89 c1                	mov    %eax,%ecx
    fb3f:	8b 45 08             	mov    0x8(%ebp),%eax
    fb42:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fb45:	83 c2 30             	add    $0x30,%edx
    fb48:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    fb4c:	8b 45 08             	mov    0x8(%ebp),%eax
    fb4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fb52:	83 c2 30             	add    $0x30,%edx
    fb55:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    fb59:	85 c0                	test   %eax,%eax
    fb5b:	75 18                	jne    fb75 <LodePNGUnknownChunks_copy+0x8b>
    fb5d:	8b 45 08             	mov    0x8(%ebp),%eax
    fb60:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fb63:	83 c2 34             	add    $0x34,%edx
    fb66:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    fb6a:	85 c0                	test   %eax,%eax
    fb6c:	74 07                	je     fb75 <LodePNGUnknownChunks_copy+0x8b>
    fb6e:	b8 53 00 00 00       	mov    $0x53,%eax
    fb73:	eb 5b                	jmp    fbd0 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    fb75:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    fb7c:	eb 2d                	jmp    fbab <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    fb7e:	8b 45 08             	mov    0x8(%ebp),%eax
    fb81:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fb84:	83 c2 30             	add    $0x30,%edx
    fb87:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    fb8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fb8e:	01 c2                	add    %eax,%edx
    fb90:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb93:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    fb96:	83 c1 30             	add    $0x30,%ecx
    fb99:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    fb9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fba0:	01 c8                	add    %ecx,%eax
    fba2:	0f b6 00             	movzbl (%eax),%eax
    fba5:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    fba7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    fbab:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fbb1:	83 c2 34             	add    $0x34,%edx
    fbb4:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    fbb8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    fbbb:	7f c1                	jg     fb7e <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    fbbd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    fbc1:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    fbc5:	0f 85 3f ff ff ff    	jne    fb0a <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    fbcb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fbd0:	c9                   	leave  
    fbd1:	c3                   	ret    

0000fbd2 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    fbd2:	55                   	push   %ebp
    fbd3:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    fbd5:	8b 45 08             	mov    0x8(%ebp),%eax
    fbd8:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    fbdf:	8b 45 08             	mov    0x8(%ebp),%eax
    fbe2:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    fbe9:	8b 45 08             	mov    0x8(%ebp),%eax
    fbec:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    fbf3:	90                   	nop
    fbf4:	5d                   	pop    %ebp
    fbf5:	c3                   	ret    

0000fbf6 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    fbf6:	55                   	push   %ebp
    fbf7:	89 e5                	mov    %esp,%ebp
    fbf9:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    fbfc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    fc03:	eb 38                	jmp    fc3d <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    fc05:	8b 45 08             	mov    0x8(%ebp),%eax
    fc08:	8b 40 40             	mov    0x40(%eax),%eax
    fc0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fc0e:	c1 e2 02             	shl    $0x2,%edx
    fc11:	01 d0                	add    %edx,%eax
    fc13:	83 ec 0c             	sub    $0xc,%esp
    fc16:	50                   	push   %eax
    fc17:	e8 75 a3 ff ff       	call   9f91 <string_cleanup>
    fc1c:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    fc1f:	8b 45 08             	mov    0x8(%ebp),%eax
    fc22:	8b 40 44             	mov    0x44(%eax),%eax
    fc25:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fc28:	c1 e2 02             	shl    $0x2,%edx
    fc2b:	01 d0                	add    %edx,%eax
    fc2d:	83 ec 0c             	sub    $0xc,%esp
    fc30:	50                   	push   %eax
    fc31:	e8 5b a3 ff ff       	call   9f91 <string_cleanup>
    fc36:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    fc39:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    fc3d:	8b 45 08             	mov    0x8(%ebp),%eax
    fc40:	8b 40 3c             	mov    0x3c(%eax),%eax
    fc43:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    fc46:	75 bd                	jne    fc05 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    fc48:	8b 45 08             	mov    0x8(%ebp),%eax
    fc4b:	8b 40 40             	mov    0x40(%eax),%eax
    fc4e:	83 ec 0c             	sub    $0xc,%esp
    fc51:	50                   	push   %eax
    fc52:	e8 67 a0 ff ff       	call   9cbe <lodepng_free>
    fc57:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    fc5a:	8b 45 08             	mov    0x8(%ebp),%eax
    fc5d:	8b 40 44             	mov    0x44(%eax),%eax
    fc60:	83 ec 0c             	sub    $0xc,%esp
    fc63:	50                   	push   %eax
    fc64:	e8 55 a0 ff ff       	call   9cbe <lodepng_free>
    fc69:	83 c4 10             	add    $0x10,%esp
}
    fc6c:	90                   	nop
    fc6d:	c9                   	leave  
    fc6e:	c3                   	ret    

0000fc6f <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    fc6f:	55                   	push   %ebp
    fc70:	89 e5                	mov    %esp,%ebp
    fc72:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    fc75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    fc7c:	8b 45 08             	mov    0x8(%ebp),%eax
    fc7f:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    fc86:	8b 45 08             	mov    0x8(%ebp),%eax
    fc89:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    fc90:	8b 45 08             	mov    0x8(%ebp),%eax
    fc93:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    fc9a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    fca1:	eb 42                	jmp    fce5 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    fca3:	8b 45 0c             	mov    0xc(%ebp),%eax
    fca6:	8b 40 44             	mov    0x44(%eax),%eax
    fca9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fcac:	c1 e2 02             	shl    $0x2,%edx
    fcaf:	01 d0                	add    %edx,%eax
    fcb1:	8b 10                	mov    (%eax),%edx
    fcb3:	8b 45 0c             	mov    0xc(%ebp),%eax
    fcb6:	8b 40 40             	mov    0x40(%eax),%eax
    fcb9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    fcbc:	c1 e1 02             	shl    $0x2,%ecx
    fcbf:	01 c8                	add    %ecx,%eax
    fcc1:	8b 00                	mov    (%eax),%eax
    fcc3:	83 ec 04             	sub    $0x4,%esp
    fcc6:	52                   	push   %edx
    fcc7:	50                   	push   %eax
    fcc8:	ff 75 08             	pushl  0x8(%ebp)
    fccb:	e8 4d 01 00 00       	call   fe1d <lodepng_add_text>
    fcd0:	83 c4 10             	add    $0x10,%esp
    fcd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fcd6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fcda:	74 05                	je     fce1 <LodePNGText_copy+0x72>
    fcdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fcdf:	eb 14                	jmp    fcf5 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    fce1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    fce5:	8b 45 0c             	mov    0xc(%ebp),%eax
    fce8:	8b 40 3c             	mov    0x3c(%eax),%eax
    fceb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    fcee:	75 b3                	jne    fca3 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    fcf0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fcf5:	c9                   	leave  
    fcf6:	c3                   	ret    

0000fcf7 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    fcf7:	55                   	push   %ebp
    fcf8:	89 e5                	mov    %esp,%ebp
    fcfa:	53                   	push   %ebx
    fcfb:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    fcfe:	8b 45 08             	mov    0x8(%ebp),%eax
    fd01:	8b 40 3c             	mov    0x3c(%eax),%eax
    fd04:	83 c0 01             	add    $0x1,%eax
    fd07:	c1 e0 02             	shl    $0x2,%eax
    fd0a:	89 c2                	mov    %eax,%edx
    fd0c:	8b 45 08             	mov    0x8(%ebp),%eax
    fd0f:	8b 40 40             	mov    0x40(%eax),%eax
    fd12:	52                   	push   %edx
    fd13:	50                   	push   %eax
    fd14:	e8 9b 9f ff ff       	call   9cb4 <lodepng_realloc>
    fd19:	83 c4 08             	add    $0x8,%esp
    fd1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    fd1f:	8b 45 08             	mov    0x8(%ebp),%eax
    fd22:	8b 40 3c             	mov    0x3c(%eax),%eax
    fd25:	83 c0 01             	add    $0x1,%eax
    fd28:	c1 e0 02             	shl    $0x2,%eax
    fd2b:	89 c2                	mov    %eax,%edx
    fd2d:	8b 45 08             	mov    0x8(%ebp),%eax
    fd30:	8b 40 44             	mov    0x44(%eax),%eax
    fd33:	52                   	push   %edx
    fd34:	50                   	push   %eax
    fd35:	e8 7a 9f ff ff       	call   9cb4 <lodepng_realloc>
    fd3a:	83 c4 08             	add    $0x8,%esp
    fd3d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    fd40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fd44:	74 09                	je     fd4f <lodepng_add_text_sized+0x58>
    fd46:	8b 45 08             	mov    0x8(%ebp),%eax
    fd49:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fd4c:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    fd4f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fd53:	74 09                	je     fd5e <lodepng_add_text_sized+0x67>
    fd55:	8b 45 08             	mov    0x8(%ebp),%eax
    fd58:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fd5b:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    fd5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fd62:	74 06                	je     fd6a <lodepng_add_text_sized+0x73>
    fd64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fd68:	75 0a                	jne    fd74 <lodepng_add_text_sized+0x7d>
    fd6a:	b8 53 00 00 00       	mov    $0x53,%eax
    fd6f:	e9 a4 00 00 00       	jmp    fe18 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    fd74:	8b 45 08             	mov    0x8(%ebp),%eax
    fd77:	8b 40 3c             	mov    0x3c(%eax),%eax
    fd7a:	8d 50 01             	lea    0x1(%eax),%edx
    fd7d:	8b 45 08             	mov    0x8(%ebp),%eax
    fd80:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    fd83:	8b 45 08             	mov    0x8(%ebp),%eax
    fd86:	8b 50 40             	mov    0x40(%eax),%edx
    fd89:	8b 45 08             	mov    0x8(%ebp),%eax
    fd8c:	8b 40 3c             	mov    0x3c(%eax),%eax
    fd8f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    fd94:	c1 e0 02             	shl    $0x2,%eax
    fd97:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    fd9a:	83 ec 0c             	sub    $0xc,%esp
    fd9d:	ff 75 0c             	pushl  0xc(%ebp)
    fda0:	e8 54 a2 ff ff       	call   9ff9 <alloc_string>
    fda5:	83 c4 10             	add    $0x10,%esp
    fda8:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    fdaa:	8b 45 08             	mov    0x8(%ebp),%eax
    fdad:	8b 50 44             	mov    0x44(%eax),%edx
    fdb0:	8b 45 08             	mov    0x8(%ebp),%eax
    fdb3:	8b 40 3c             	mov    0x3c(%eax),%eax
    fdb6:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    fdbb:	c1 e0 02             	shl    $0x2,%eax
    fdbe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    fdc1:	83 ec 08             	sub    $0x8,%esp
    fdc4:	ff 75 14             	pushl  0x14(%ebp)
    fdc7:	ff 75 10             	pushl  0x10(%ebp)
    fdca:	e8 e5 a1 ff ff       	call   9fb4 <alloc_string_sized>
    fdcf:	83 c4 10             	add    $0x10,%esp
    fdd2:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    fdd4:	8b 45 08             	mov    0x8(%ebp),%eax
    fdd7:	8b 50 40             	mov    0x40(%eax),%edx
    fdda:	8b 45 08             	mov    0x8(%ebp),%eax
    fddd:	8b 40 3c             	mov    0x3c(%eax),%eax
    fde0:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    fde5:	c1 e0 02             	shl    $0x2,%eax
    fde8:	01 d0                	add    %edx,%eax
    fdea:	8b 00                	mov    (%eax),%eax
    fdec:	85 c0                	test   %eax,%eax
    fdee:	74 1c                	je     fe0c <lodepng_add_text_sized+0x115>
    fdf0:	8b 45 08             	mov    0x8(%ebp),%eax
    fdf3:	8b 50 44             	mov    0x44(%eax),%edx
    fdf6:	8b 45 08             	mov    0x8(%ebp),%eax
    fdf9:	8b 40 3c             	mov    0x3c(%eax),%eax
    fdfc:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    fe01:	c1 e0 02             	shl    $0x2,%eax
    fe04:	01 d0                	add    %edx,%eax
    fe06:	8b 00                	mov    (%eax),%eax
    fe08:	85 c0                	test   %eax,%eax
    fe0a:	75 07                	jne    fe13 <lodepng_add_text_sized+0x11c>
    fe0c:	b8 53 00 00 00       	mov    $0x53,%eax
    fe11:	eb 05                	jmp    fe18 <lodepng_add_text_sized+0x121>

  return 0;
    fe13:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fe18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    fe1b:	c9                   	leave  
    fe1c:	c3                   	ret    

0000fe1d <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    fe1d:	55                   	push   %ebp
    fe1e:	89 e5                	mov    %esp,%ebp
    fe20:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    fe23:	ff 75 10             	pushl  0x10(%ebp)
    fe26:	e8 0e 9f ff ff       	call   9d39 <lodepng_strlen>
    fe2b:	83 c4 04             	add    $0x4,%esp
    fe2e:	50                   	push   %eax
    fe2f:	ff 75 10             	pushl  0x10(%ebp)
    fe32:	ff 75 0c             	pushl  0xc(%ebp)
    fe35:	ff 75 08             	pushl  0x8(%ebp)
    fe38:	e8 ba fe ff ff       	call   fcf7 <lodepng_add_text_sized>
    fe3d:	83 c4 10             	add    $0x10,%esp
}
    fe40:	c9                   	leave  
    fe41:	c3                   	ret    

0000fe42 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    fe42:	55                   	push   %ebp
    fe43:	89 e5                	mov    %esp,%ebp
    fe45:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    fe48:	83 ec 0c             	sub    $0xc,%esp
    fe4b:	ff 75 08             	pushl  0x8(%ebp)
    fe4e:	e8 a3 fd ff ff       	call   fbf6 <LodePNGText_cleanup>
    fe53:	83 c4 10             	add    $0x10,%esp
}
    fe56:	90                   	nop
    fe57:	c9                   	leave  
    fe58:	c3                   	ret    

0000fe59 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    fe59:	55                   	push   %ebp
    fe5a:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    fe5c:	8b 45 08             	mov    0x8(%ebp),%eax
    fe5f:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    fe66:	8b 45 08             	mov    0x8(%ebp),%eax
    fe69:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    fe70:	8b 45 08             	mov    0x8(%ebp),%eax
    fe73:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    fe7a:	8b 45 08             	mov    0x8(%ebp),%eax
    fe7d:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    fe84:	8b 45 08             	mov    0x8(%ebp),%eax
    fe87:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    fe8e:	90                   	nop
    fe8f:	5d                   	pop    %ebp
    fe90:	c3                   	ret    

0000fe91 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    fe91:	55                   	push   %ebp
    fe92:	89 e5                	mov    %esp,%ebp
    fe94:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    fe97:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    fe9e:	eb 6c                	jmp    ff0c <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    fea0:	8b 45 08             	mov    0x8(%ebp),%eax
    fea3:	8b 40 4c             	mov    0x4c(%eax),%eax
    fea6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fea9:	c1 e2 02             	shl    $0x2,%edx
    feac:	01 d0                	add    %edx,%eax
    feae:	83 ec 0c             	sub    $0xc,%esp
    feb1:	50                   	push   %eax
    feb2:	e8 da a0 ff ff       	call   9f91 <string_cleanup>
    feb7:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    feba:	8b 45 08             	mov    0x8(%ebp),%eax
    febd:	8b 40 50             	mov    0x50(%eax),%eax
    fec0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fec3:	c1 e2 02             	shl    $0x2,%edx
    fec6:	01 d0                	add    %edx,%eax
    fec8:	83 ec 0c             	sub    $0xc,%esp
    fecb:	50                   	push   %eax
    fecc:	e8 c0 a0 ff ff       	call   9f91 <string_cleanup>
    fed1:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    fed4:	8b 45 08             	mov    0x8(%ebp),%eax
    fed7:	8b 40 54             	mov    0x54(%eax),%eax
    feda:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fedd:	c1 e2 02             	shl    $0x2,%edx
    fee0:	01 d0                	add    %edx,%eax
    fee2:	83 ec 0c             	sub    $0xc,%esp
    fee5:	50                   	push   %eax
    fee6:	e8 a6 a0 ff ff       	call   9f91 <string_cleanup>
    feeb:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    feee:	8b 45 08             	mov    0x8(%ebp),%eax
    fef1:	8b 40 58             	mov    0x58(%eax),%eax
    fef4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fef7:	c1 e2 02             	shl    $0x2,%edx
    fefa:	01 d0                	add    %edx,%eax
    fefc:	83 ec 0c             	sub    $0xc,%esp
    feff:	50                   	push   %eax
    ff00:	e8 8c a0 ff ff       	call   9f91 <string_cleanup>
    ff05:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    ff08:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ff0c:	8b 45 08             	mov    0x8(%ebp),%eax
    ff0f:	8b 40 48             	mov    0x48(%eax),%eax
    ff12:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    ff15:	75 89                	jne    fea0 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    ff17:	8b 45 08             	mov    0x8(%ebp),%eax
    ff1a:	8b 40 4c             	mov    0x4c(%eax),%eax
    ff1d:	83 ec 0c             	sub    $0xc,%esp
    ff20:	50                   	push   %eax
    ff21:	e8 98 9d ff ff       	call   9cbe <lodepng_free>
    ff26:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    ff29:	8b 45 08             	mov    0x8(%ebp),%eax
    ff2c:	8b 40 50             	mov    0x50(%eax),%eax
    ff2f:	83 ec 0c             	sub    $0xc,%esp
    ff32:	50                   	push   %eax
    ff33:	e8 86 9d ff ff       	call   9cbe <lodepng_free>
    ff38:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    ff3b:	8b 45 08             	mov    0x8(%ebp),%eax
    ff3e:	8b 40 54             	mov    0x54(%eax),%eax
    ff41:	83 ec 0c             	sub    $0xc,%esp
    ff44:	50                   	push   %eax
    ff45:	e8 74 9d ff ff       	call   9cbe <lodepng_free>
    ff4a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    ff4d:	8b 45 08             	mov    0x8(%ebp),%eax
    ff50:	8b 40 58             	mov    0x58(%eax),%eax
    ff53:	83 ec 0c             	sub    $0xc,%esp
    ff56:	50                   	push   %eax
    ff57:	e8 62 9d ff ff       	call   9cbe <lodepng_free>
    ff5c:	83 c4 10             	add    $0x10,%esp
}
    ff5f:	90                   	nop
    ff60:	c9                   	leave  
    ff61:	c3                   	ret    

0000ff62 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    ff62:	55                   	push   %ebp
    ff63:	89 e5                	mov    %esp,%ebp
    ff65:	56                   	push   %esi
    ff66:	53                   	push   %ebx
    ff67:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    ff6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    ff71:	8b 45 08             	mov    0x8(%ebp),%eax
    ff74:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    ff7b:	8b 45 08             	mov    0x8(%ebp),%eax
    ff7e:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    ff85:	8b 45 08             	mov    0x8(%ebp),%eax
    ff88:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    ff8f:	8b 45 08             	mov    0x8(%ebp),%eax
    ff92:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    ff99:	8b 45 08             	mov    0x8(%ebp),%eax
    ff9c:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    ffa3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ffaa:	eb 64                	jmp    10010 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    ffac:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffaf:	8b 40 58             	mov    0x58(%eax),%eax
    ffb2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ffb5:	c1 e2 02             	shl    $0x2,%edx
    ffb8:	01 d0                	add    %edx,%eax
    ffba:	8b 18                	mov    (%eax),%ebx
    ffbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffbf:	8b 40 54             	mov    0x54(%eax),%eax
    ffc2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ffc5:	c1 e2 02             	shl    $0x2,%edx
    ffc8:	01 d0                	add    %edx,%eax
    ffca:	8b 08                	mov    (%eax),%ecx
    ffcc:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffcf:	8b 40 50             	mov    0x50(%eax),%eax
    ffd2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ffd5:	c1 e2 02             	shl    $0x2,%edx
    ffd8:	01 d0                	add    %edx,%eax
    ffda:	8b 10                	mov    (%eax),%edx
    ffdc:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffdf:	8b 40 4c             	mov    0x4c(%eax),%eax
    ffe2:	8b 75 f4             	mov    -0xc(%ebp),%esi
    ffe5:	c1 e6 02             	shl    $0x2,%esi
    ffe8:	01 f0                	add    %esi,%eax
    ffea:	8b 00                	mov    (%eax),%eax
    ffec:	83 ec 0c             	sub    $0xc,%esp
    ffef:	53                   	push   %ebx
    fff0:	51                   	push   %ecx
    fff1:	52                   	push   %edx
    fff2:	50                   	push   %eax
    fff3:	ff 75 08             	pushl  0x8(%ebp)
    fff6:	e8 e4 01 00 00       	call   101df <lodepng_add_itext>
    fffb:	83 c4 20             	add    $0x20,%esp
    fffe:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10001:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10005:	74 05                	je     1000c <LodePNGIText_copy+0xaa>
   10007:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1000a:	eb 14                	jmp    10020 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
   1000c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10010:	8b 45 0c             	mov    0xc(%ebp),%eax
   10013:	8b 40 48             	mov    0x48(%eax),%eax
   10016:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   10019:	75 91                	jne    ffac <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
   1001b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10020:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10023:	5b                   	pop    %ebx
   10024:	5e                   	pop    %esi
   10025:	5d                   	pop    %ebp
   10026:	c3                   	ret    

00010027 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
   10027:	55                   	push   %ebp
   10028:	89 e5                	mov    %esp,%ebp
   1002a:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
   1002d:	83 ec 0c             	sub    $0xc,%esp
   10030:	ff 75 08             	pushl  0x8(%ebp)
   10033:	e8 59 fe ff ff       	call   fe91 <LodePNGIText_cleanup>
   10038:	83 c4 10             	add    $0x10,%esp
}
   1003b:	90                   	nop
   1003c:	c9                   	leave  
   1003d:	c3                   	ret    

0001003e <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
   1003e:	55                   	push   %ebp
   1003f:	89 e5                	mov    %esp,%ebp
   10041:	53                   	push   %ebx
   10042:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
   10045:	8b 45 08             	mov    0x8(%ebp),%eax
   10048:	8b 40 48             	mov    0x48(%eax),%eax
   1004b:	83 c0 01             	add    $0x1,%eax
   1004e:	c1 e0 02             	shl    $0x2,%eax
   10051:	89 c2                	mov    %eax,%edx
   10053:	8b 45 08             	mov    0x8(%ebp),%eax
   10056:	8b 40 4c             	mov    0x4c(%eax),%eax
   10059:	52                   	push   %edx
   1005a:	50                   	push   %eax
   1005b:	e8 54 9c ff ff       	call   9cb4 <lodepng_realloc>
   10060:	83 c4 08             	add    $0x8,%esp
   10063:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
   10066:	8b 45 08             	mov    0x8(%ebp),%eax
   10069:	8b 40 48             	mov    0x48(%eax),%eax
   1006c:	83 c0 01             	add    $0x1,%eax
   1006f:	c1 e0 02             	shl    $0x2,%eax
   10072:	89 c2                	mov    %eax,%edx
   10074:	8b 45 08             	mov    0x8(%ebp),%eax
   10077:	8b 40 50             	mov    0x50(%eax),%eax
   1007a:	52                   	push   %edx
   1007b:	50                   	push   %eax
   1007c:	e8 33 9c ff ff       	call   9cb4 <lodepng_realloc>
   10081:	83 c4 08             	add    $0x8,%esp
   10084:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
   10087:	8b 45 08             	mov    0x8(%ebp),%eax
   1008a:	8b 40 48             	mov    0x48(%eax),%eax
   1008d:	83 c0 01             	add    $0x1,%eax
   10090:	c1 e0 02             	shl    $0x2,%eax
   10093:	89 c2                	mov    %eax,%edx
   10095:	8b 45 08             	mov    0x8(%ebp),%eax
   10098:	8b 40 54             	mov    0x54(%eax),%eax
   1009b:	52                   	push   %edx
   1009c:	50                   	push   %eax
   1009d:	e8 12 9c ff ff       	call   9cb4 <lodepng_realloc>
   100a2:	83 c4 08             	add    $0x8,%esp
   100a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
   100a8:	8b 45 08             	mov    0x8(%ebp),%eax
   100ab:	8b 40 48             	mov    0x48(%eax),%eax
   100ae:	83 c0 01             	add    $0x1,%eax
   100b1:	c1 e0 02             	shl    $0x2,%eax
   100b4:	89 c2                	mov    %eax,%edx
   100b6:	8b 45 08             	mov    0x8(%ebp),%eax
   100b9:	8b 40 58             	mov    0x58(%eax),%eax
   100bc:	52                   	push   %edx
   100bd:	50                   	push   %eax
   100be:	e8 f1 9b ff ff       	call   9cb4 <lodepng_realloc>
   100c3:	83 c4 08             	add    $0x8,%esp
   100c6:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
   100c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   100cd:	74 09                	je     100d8 <lodepng_add_itext_sized+0x9a>
   100cf:	8b 45 08             	mov    0x8(%ebp),%eax
   100d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   100d5:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
   100d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   100dc:	74 09                	je     100e7 <lodepng_add_itext_sized+0xa9>
   100de:	8b 45 08             	mov    0x8(%ebp),%eax
   100e1:	8b 55 f0             	mov    -0x10(%ebp),%edx
   100e4:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
   100e7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   100eb:	74 09                	je     100f6 <lodepng_add_itext_sized+0xb8>
   100ed:	8b 45 08             	mov    0x8(%ebp),%eax
   100f0:	8b 55 ec             	mov    -0x14(%ebp),%edx
   100f3:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
   100f6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   100fa:	74 09                	je     10105 <lodepng_add_itext_sized+0xc7>
   100fc:	8b 45 08             	mov    0x8(%ebp),%eax
   100ff:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10102:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
   10105:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10109:	74 12                	je     1011d <lodepng_add_itext_sized+0xdf>
   1010b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1010f:	74 0c                	je     1011d <lodepng_add_itext_sized+0xdf>
   10111:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10115:	74 06                	je     1011d <lodepng_add_itext_sized+0xdf>
   10117:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1011b:	75 0a                	jne    10127 <lodepng_add_itext_sized+0xe9>
   1011d:	b8 53 00 00 00       	mov    $0x53,%eax
   10122:	e9 b3 00 00 00       	jmp    101da <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
   10127:	8b 45 08             	mov    0x8(%ebp),%eax
   1012a:	8b 40 48             	mov    0x48(%eax),%eax
   1012d:	8d 50 01             	lea    0x1(%eax),%edx
   10130:	8b 45 08             	mov    0x8(%ebp),%eax
   10133:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
   10136:	8b 45 08             	mov    0x8(%ebp),%eax
   10139:	8b 50 4c             	mov    0x4c(%eax),%edx
   1013c:	8b 45 08             	mov    0x8(%ebp),%eax
   1013f:	8b 40 48             	mov    0x48(%eax),%eax
   10142:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
   10147:	c1 e0 02             	shl    $0x2,%eax
   1014a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1014d:	83 ec 0c             	sub    $0xc,%esp
   10150:	ff 75 0c             	pushl  0xc(%ebp)
   10153:	e8 a1 9e ff ff       	call   9ff9 <alloc_string>
   10158:	83 c4 10             	add    $0x10,%esp
   1015b:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
   1015d:	8b 45 08             	mov    0x8(%ebp),%eax
   10160:	8b 50 50             	mov    0x50(%eax),%edx
   10163:	8b 45 08             	mov    0x8(%ebp),%eax
   10166:	8b 40 48             	mov    0x48(%eax),%eax
   10169:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
   1016e:	c1 e0 02             	shl    $0x2,%eax
   10171:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   10174:	83 ec 0c             	sub    $0xc,%esp
   10177:	ff 75 10             	pushl  0x10(%ebp)
   1017a:	e8 7a 9e ff ff       	call   9ff9 <alloc_string>
   1017f:	83 c4 10             	add    $0x10,%esp
   10182:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
   10184:	8b 45 08             	mov    0x8(%ebp),%eax
   10187:	8b 50 54             	mov    0x54(%eax),%edx
   1018a:	8b 45 08             	mov    0x8(%ebp),%eax
   1018d:	8b 40 48             	mov    0x48(%eax),%eax
   10190:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
   10195:	c1 e0 02             	shl    $0x2,%eax
   10198:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1019b:	83 ec 0c             	sub    $0xc,%esp
   1019e:	ff 75 14             	pushl  0x14(%ebp)
   101a1:	e8 53 9e ff ff       	call   9ff9 <alloc_string>
   101a6:	83 c4 10             	add    $0x10,%esp
   101a9:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
   101ab:	8b 45 08             	mov    0x8(%ebp),%eax
   101ae:	8b 50 58             	mov    0x58(%eax),%edx
   101b1:	8b 45 08             	mov    0x8(%ebp),%eax
   101b4:	8b 40 48             	mov    0x48(%eax),%eax
   101b7:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
   101bc:	c1 e0 02             	shl    $0x2,%eax
   101bf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   101c2:	83 ec 08             	sub    $0x8,%esp
   101c5:	ff 75 1c             	pushl  0x1c(%ebp)
   101c8:	ff 75 18             	pushl  0x18(%ebp)
   101cb:	e8 e4 9d ff ff       	call   9fb4 <alloc_string_sized>
   101d0:	83 c4 10             	add    $0x10,%esp
   101d3:	89 03                	mov    %eax,(%ebx)

  return 0;
   101d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   101da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   101dd:	c9                   	leave  
   101de:	c3                   	ret    

000101df <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
   101df:	55                   	push   %ebp
   101e0:	89 e5                	mov    %esp,%ebp
   101e2:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
   101e5:	ff 75 18             	pushl  0x18(%ebp)
   101e8:	e8 4c 9b ff ff       	call   9d39 <lodepng_strlen>
   101ed:	83 c4 04             	add    $0x4,%esp
   101f0:	83 ec 08             	sub    $0x8,%esp
   101f3:	50                   	push   %eax
   101f4:	ff 75 18             	pushl  0x18(%ebp)
   101f7:	ff 75 14             	pushl  0x14(%ebp)
   101fa:	ff 75 10             	pushl  0x10(%ebp)
   101fd:	ff 75 0c             	pushl  0xc(%ebp)
   10200:	ff 75 08             	pushl  0x8(%ebp)
   10203:	e8 36 fe ff ff       	call   1003e <lodepng_add_itext_sized>
   10208:	83 c4 20             	add    $0x20,%esp
}
   1020b:	c9                   	leave  
   1020c:	c3                   	ret    

0001020d <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
   1020d:	55                   	push   %ebp
   1020e:	89 e5                	mov    %esp,%ebp
   10210:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
   10213:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10217:	75 0a                	jne    10223 <lodepng_assign_icc+0x16>
   10219:	b8 64 00 00 00       	mov    $0x64,%eax
   1021e:	e9 81 00 00 00       	jmp    102a4 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
   10223:	83 ec 0c             	sub    $0xc,%esp
   10226:	ff 75 0c             	pushl  0xc(%ebp)
   10229:	e8 cb 9d ff ff       	call   9ff9 <alloc_string>
   1022e:	83 c4 10             	add    $0x10,%esp
   10231:	89 c2                	mov    %eax,%edx
   10233:	8b 45 08             	mov    0x8(%ebp),%eax
   10236:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
   1023c:	8b 45 14             	mov    0x14(%ebp),%eax
   1023f:	83 ec 0c             	sub    $0xc,%esp
   10242:	50                   	push   %eax
   10243:	e8 55 9a ff ff       	call   9c9d <lodepng_malloc>
   10248:	83 c4 10             	add    $0x10,%esp
   1024b:	89 c2                	mov    %eax,%edx
   1024d:	8b 45 08             	mov    0x8(%ebp),%eax
   10250:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
   10256:	8b 45 08             	mov    0x8(%ebp),%eax
   10259:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1025f:	85 c0                	test   %eax,%eax
   10261:	74 0d                	je     10270 <lodepng_assign_icc+0x63>
   10263:	8b 45 08             	mov    0x8(%ebp),%eax
   10266:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1026c:	85 c0                	test   %eax,%eax
   1026e:	75 07                	jne    10277 <lodepng_assign_icc+0x6a>
   10270:	b8 53 00 00 00       	mov    $0x53,%eax
   10275:	eb 2d                	jmp    102a4 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
   10277:	8b 55 14             	mov    0x14(%ebp),%edx
   1027a:	8b 45 08             	mov    0x8(%ebp),%eax
   1027d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   10283:	83 ec 04             	sub    $0x4,%esp
   10286:	52                   	push   %edx
   10287:	ff 75 10             	pushl  0x10(%ebp)
   1028a:	50                   	push   %eax
   1028b:	e8 4b 9a ff ff       	call   9cdb <lodepng_memcpy>
   10290:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
   10293:	8b 45 08             	mov    0x8(%ebp),%eax
   10296:	8b 55 14             	mov    0x14(%ebp),%edx
   10299:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
   1029f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   102a4:	c9                   	leave  
   102a5:	c3                   	ret    

000102a6 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
   102a6:	55                   	push   %ebp
   102a7:	89 e5                	mov    %esp,%ebp
   102a9:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
   102ac:	8b 45 08             	mov    0x8(%ebp),%eax
   102af:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   102b5:	85 c0                	test   %eax,%eax
   102b7:	74 0e                	je     102c7 <lodepng_set_icc+0x21>
   102b9:	83 ec 0c             	sub    $0xc,%esp
   102bc:	ff 75 08             	pushl  0x8(%ebp)
   102bf:	e8 26 00 00 00       	call   102ea <lodepng_clear_icc>
   102c4:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
   102c7:	8b 45 08             	mov    0x8(%ebp),%eax
   102ca:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
   102d1:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
   102d4:	ff 75 14             	pushl  0x14(%ebp)
   102d7:	ff 75 10             	pushl  0x10(%ebp)
   102da:	ff 75 0c             	pushl  0xc(%ebp)
   102dd:	ff 75 08             	pushl  0x8(%ebp)
   102e0:	e8 28 ff ff ff       	call   1020d <lodepng_assign_icc>
   102e5:	83 c4 10             	add    $0x10,%esp
}
   102e8:	c9                   	leave  
   102e9:	c3                   	ret    

000102ea <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
   102ea:	55                   	push   %ebp
   102eb:	89 e5                	mov    %esp,%ebp
   102ed:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
   102f0:	8b 45 08             	mov    0x8(%ebp),%eax
   102f3:	05 c0 00 00 00       	add    $0xc0,%eax
   102f8:	83 ec 0c             	sub    $0xc,%esp
   102fb:	50                   	push   %eax
   102fc:	e8 90 9c ff ff       	call   9f91 <string_cleanup>
   10301:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
   10304:	8b 45 08             	mov    0x8(%ebp),%eax
   10307:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1030d:	83 ec 0c             	sub    $0xc,%esp
   10310:	50                   	push   %eax
   10311:	e8 a8 99 ff ff       	call   9cbe <lodepng_free>
   10316:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
   10319:	8b 45 08             	mov    0x8(%ebp),%eax
   1031c:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
   10323:	00 00 00 
  info->iccp_profile_size = 0;
   10326:	8b 45 08             	mov    0x8(%ebp),%eax
   10329:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
   10330:	00 00 00 
  info->iccp_defined = 0;
   10333:	8b 45 08             	mov    0x8(%ebp),%eax
   10336:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
   1033d:	00 00 00 
}
   10340:	90                   	nop
   10341:	c9                   	leave  
   10342:	c3                   	ret    

00010343 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
   10343:	55                   	push   %ebp
   10344:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
   10346:	8b 45 08             	mov    0x8(%ebp),%eax
   10349:	83 c0 0c             	add    $0xc,%eax
   1034c:	50                   	push   %eax
   1034d:	e8 5a f0 ff ff       	call   f3ac <lodepng_color_mode_init>
   10352:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
   10355:	8b 45 08             	mov    0x8(%ebp),%eax
   10358:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
   1035f:	8b 45 08             	mov    0x8(%ebp),%eax
   10362:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
   10368:	8b 45 08             	mov    0x8(%ebp),%eax
   1036b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
   10372:	8b 45 08             	mov    0x8(%ebp),%eax
   10375:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
   1037c:	8b 45 08             	mov    0x8(%ebp),%eax
   1037f:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
   10386:	8b 45 08             	mov    0x8(%ebp),%eax
   10389:	8b 50 38             	mov    0x38(%eax),%edx
   1038c:	8b 45 08             	mov    0x8(%ebp),%eax
   1038f:	89 50 34             	mov    %edx,0x34(%eax)
   10392:	8b 45 08             	mov    0x8(%ebp),%eax
   10395:	8b 50 34             	mov    0x34(%eax),%edx
   10398:	8b 45 08             	mov    0x8(%ebp),%eax
   1039b:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
   1039e:	ff 75 08             	pushl  0x8(%ebp)
   103a1:	e8 2c f8 ff ff       	call   fbd2 <LodePNGText_init>
   103a6:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
   103a9:	ff 75 08             	pushl  0x8(%ebp)
   103ac:	e8 a8 fa ff ff       	call   fe59 <LodePNGIText_init>
   103b1:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
   103b4:	8b 45 08             	mov    0x8(%ebp),%eax
   103b7:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
   103be:	8b 45 08             	mov    0x8(%ebp),%eax
   103c1:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
   103c8:	8b 45 08             	mov    0x8(%ebp),%eax
   103cb:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
   103d2:	00 00 00 
  info->chrm_defined = 0;
   103d5:	8b 45 08             	mov    0x8(%ebp),%eax
   103d8:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
   103df:	00 00 00 
  info->srgb_defined = 0;
   103e2:	8b 45 08             	mov    0x8(%ebp),%eax
   103e5:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
   103ec:	00 00 00 
  info->iccp_defined = 0;
   103ef:	8b 45 08             	mov    0x8(%ebp),%eax
   103f2:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
   103f9:	00 00 00 
  info->iccp_name = NULL;
   103fc:	8b 45 08             	mov    0x8(%ebp),%eax
   103ff:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
   10406:	00 00 00 
  info->iccp_profile = NULL;
   10409:	8b 45 08             	mov    0x8(%ebp),%eax
   1040c:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
   10413:	00 00 00 

  LodePNGUnknownChunks_init(info);
   10416:	ff 75 08             	pushl  0x8(%ebp)
   10419:	e8 46 f6 ff ff       	call   fa64 <LodePNGUnknownChunks_init>
   1041e:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   10421:	90                   	nop
   10422:	c9                   	leave  
   10423:	c3                   	ret    

00010424 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
   10424:	55                   	push   %ebp
   10425:	89 e5                	mov    %esp,%ebp
   10427:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
   1042a:	8b 45 08             	mov    0x8(%ebp),%eax
   1042d:	83 c0 0c             	add    $0xc,%eax
   10430:	83 ec 0c             	sub    $0xc,%esp
   10433:	50                   	push   %eax
   10434:	e8 66 f0 ff ff       	call   f49f <lodepng_color_mode_cleanup>
   10439:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
   1043c:	83 ec 0c             	sub    $0xc,%esp
   1043f:	ff 75 08             	pushl  0x8(%ebp)
   10442:	e8 af f7 ff ff       	call   fbf6 <LodePNGText_cleanup>
   10447:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
   1044a:	83 ec 0c             	sub    $0xc,%esp
   1044d:	ff 75 08             	pushl  0x8(%ebp)
   10450:	e8 3c fa ff ff       	call   fe91 <LodePNGIText_cleanup>
   10455:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
   10458:	83 ec 0c             	sub    $0xc,%esp
   1045b:	ff 75 08             	pushl  0x8(%ebp)
   1045e:	e8 87 fe ff ff       	call   102ea <lodepng_clear_icc>
   10463:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
   10466:	83 ec 0c             	sub    $0xc,%esp
   10469:	ff 75 08             	pushl  0x8(%ebp)
   1046c:	e8 44 f6 ff ff       	call   fab5 <LodePNGUnknownChunks_cleanup>
   10471:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   10474:	90                   	nop
   10475:	c9                   	leave  
   10476:	c3                   	ret    

00010477 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
   10477:	55                   	push   %ebp
   10478:	89 e5                	mov    %esp,%ebp
   1047a:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
   1047d:	83 ec 0c             	sub    $0xc,%esp
   10480:	ff 75 08             	pushl  0x8(%ebp)
   10483:	e8 9c ff ff ff       	call   10424 <lodepng_info_cleanup>
   10488:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
   1048b:	83 ec 04             	sub    $0x4,%esp
   1048e:	68 e4 00 00 00       	push   $0xe4
   10493:	ff 75 0c             	pushl  0xc(%ebp)
   10496:	ff 75 08             	pushl  0x8(%ebp)
   10499:	e8 3d 98 ff ff       	call   9cdb <lodepng_memcpy>
   1049e:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
   104a1:	8b 45 08             	mov    0x8(%ebp),%eax
   104a4:	83 c0 0c             	add    $0xc,%eax
   104a7:	83 ec 0c             	sub    $0xc,%esp
   104aa:	50                   	push   %eax
   104ab:	e8 fc ee ff ff       	call   f3ac <lodepng_color_mode_init>
   104b0:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
   104b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   104b6:	8d 50 0c             	lea    0xc(%eax),%edx
   104b9:	8b 45 08             	mov    0x8(%ebp),%eax
   104bc:	83 c0 0c             	add    $0xc,%eax
   104bf:	83 ec 08             	sub    $0x8,%esp
   104c2:	52                   	push   %edx
   104c3:	50                   	push   %eax
   104c4:	e8 ed ef ff ff       	call   f4b6 <lodepng_color_mode_copy>
   104c9:	83 c4 10             	add    $0x10,%esp
   104cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
   104cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   104d3:	74 08                	je     104dd <lodepng_info_copy+0x66>
   104d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   104d8:	e9 b7 00 00 00       	jmp    10594 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
   104dd:	83 ec 08             	sub    $0x8,%esp
   104e0:	ff 75 0c             	pushl  0xc(%ebp)
   104e3:	ff 75 08             	pushl  0x8(%ebp)
   104e6:	e8 84 f7 ff ff       	call   fc6f <LodePNGText_copy>
   104eb:	83 c4 10             	add    $0x10,%esp
   104ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
   104f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   104f5:	74 08                	je     104ff <lodepng_info_copy+0x88>
   104f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   104fa:	e9 95 00 00 00       	jmp    10594 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
   104ff:	83 ec 08             	sub    $0x8,%esp
   10502:	ff 75 0c             	pushl  0xc(%ebp)
   10505:	ff 75 08             	pushl  0x8(%ebp)
   10508:	e8 55 fa ff ff       	call   ff62 <LodePNGIText_copy>
   1050d:	83 c4 10             	add    $0x10,%esp
   10510:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10513:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10517:	74 05                	je     1051e <lodepng_info_copy+0xa7>
   10519:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1051c:	eb 76                	jmp    10594 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
   1051e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10521:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   10527:	85 c0                	test   %eax,%eax
   10529:	74 37                	je     10562 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
   1052b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1052e:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
   10534:	8b 45 0c             	mov    0xc(%ebp),%eax
   10537:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
   1053d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10540:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   10546:	51                   	push   %ecx
   10547:	52                   	push   %edx
   10548:	50                   	push   %eax
   10549:	ff 75 08             	pushl  0x8(%ebp)
   1054c:	e8 bc fc ff ff       	call   1020d <lodepng_assign_icc>
   10551:	83 c4 10             	add    $0x10,%esp
   10554:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10557:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1055b:	74 05                	je     10562 <lodepng_info_copy+0xeb>
   1055d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10560:	eb 32                	jmp    10594 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
   10562:	83 ec 0c             	sub    $0xc,%esp
   10565:	ff 75 08             	pushl  0x8(%ebp)
   10568:	e8 f7 f4 ff ff       	call   fa64 <LodePNGUnknownChunks_init>
   1056d:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
   10570:	83 ec 08             	sub    $0x8,%esp
   10573:	ff 75 0c             	pushl  0xc(%ebp)
   10576:	ff 75 08             	pushl  0x8(%ebp)
   10579:	e8 6c f5 ff ff       	call   faea <LodePNGUnknownChunks_copy>
   1057e:	83 c4 10             	add    $0x10,%esp
   10581:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   10584:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10588:	74 05                	je     1058f <lodepng_info_copy+0x118>
   1058a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1058d:	eb 05                	jmp    10594 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
   1058f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10594:	c9                   	leave  
   10595:	c3                   	ret    

00010596 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
   10596:	55                   	push   %ebp
   10597:	89 e5                	mov    %esp,%ebp
   10599:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
   1059c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
   105a0:	74 14                	je     105b6 <addColorBits+0x20>
   105a2:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   105a6:	75 07                	jne    105af <addColorBits+0x19>
   105a8:	b8 03 00 00 00       	mov    $0x3,%eax
   105ad:	eb 0c                	jmp    105bb <addColorBits+0x25>
   105af:	b8 01 00 00 00       	mov    $0x1,%eax
   105b4:	eb 05                	jmp    105bb <addColorBits+0x25>
   105b6:	b8 07 00 00 00       	mov    $0x7,%eax
   105bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
   105be:	8b 45 0c             	mov    0xc(%ebp),%eax
   105c1:	23 45 fc             	and    -0x4(%ebp),%eax
   105c4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
   105c7:	8b 45 10             	mov    0x10(%ebp),%eax
   105ca:	ba 01 00 00 00       	mov    $0x1,%edx
   105cf:	89 c1                	mov    %eax,%ecx
   105d1:	d3 e2                	shl    %cl,%edx
   105d3:	89 d0                	mov    %edx,%eax
   105d5:	83 e8 01             	sub    $0x1,%eax
   105d8:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
   105db:	8b 45 fc             	mov    -0x4(%ebp),%eax
   105de:	2b 45 f8             	sub    -0x8(%ebp),%eax
   105e1:	0f af 45 10          	imul   0x10(%ebp),%eax
   105e5:	89 c1                	mov    %eax,%ecx
   105e7:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
   105ea:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   105ee:	75 18                	jne    10608 <addColorBits+0x72>
   105f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   105f3:	0f af 45 10          	imul   0x10(%ebp),%eax
   105f7:	c1 e8 03             	shr    $0x3,%eax
   105fa:	89 c2                	mov    %eax,%edx
   105fc:	8b 45 08             	mov    0x8(%ebp),%eax
   105ff:	01 d0                	add    %edx,%eax
   10601:	8b 55 14             	mov    0x14(%ebp),%edx
   10604:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
   10606:	eb 1e                	jmp    10626 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
   10608:	8b 45 0c             	mov    0xc(%ebp),%eax
   1060b:	0f af 45 10          	imul   0x10(%ebp),%eax
   1060f:	c1 e8 03             	shr    $0x3,%eax
   10612:	8b 55 08             	mov    0x8(%ebp),%edx
   10615:	01 c2                	add    %eax,%edx
   10617:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1061a:	01 c8                	add    %ecx,%eax
   1061c:	0f b6 08             	movzbl (%eax),%ecx
   1061f:	8b 45 14             	mov    0x14(%ebp),%eax
   10622:	09 c8                	or     %ecx,%eax
   10624:	88 02                	mov    %al,(%edx)
}
   10626:	90                   	nop
   10627:	c9                   	leave  
   10628:	c3                   	ret    

00010629 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
   10629:	55                   	push   %ebp
   1062a:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
   1062c:	8b 45 08             	mov    0x8(%ebp),%eax
   1062f:	6a 40                	push   $0x40
   10631:	6a 00                	push   $0x0
   10633:	50                   	push   %eax
   10634:	e8 d5 96 ff ff       	call   9d0e <lodepng_memset>
   10639:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
   1063c:	8b 45 08             	mov    0x8(%ebp),%eax
   1063f:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
   10646:	90                   	nop
   10647:	c9                   	leave  
   10648:	c3                   	ret    

00010649 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
   10649:	55                   	push   %ebp
   1064a:	89 e5                	mov    %esp,%ebp
   1064c:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
   1064f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10656:	eb 3b                	jmp    10693 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
   10658:	8b 45 08             	mov    0x8(%ebp),%eax
   1065b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1065e:	8b 04 90             	mov    (%eax,%edx,4),%eax
   10661:	85 c0                	test   %eax,%eax
   10663:	74 2a                	je     1068f <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
   10665:	8b 45 08             	mov    0x8(%ebp),%eax
   10668:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1066b:	8b 04 90             	mov    (%eax,%edx,4),%eax
   1066e:	83 ec 0c             	sub    $0xc,%esp
   10671:	50                   	push   %eax
   10672:	e8 d2 ff ff ff       	call   10649 <color_tree_cleanup>
   10677:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
   1067a:	8b 45 08             	mov    0x8(%ebp),%eax
   1067d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10680:	8b 04 90             	mov    (%eax,%edx,4),%eax
   10683:	83 ec 0c             	sub    $0xc,%esp
   10686:	50                   	push   %eax
   10687:	e8 32 96 ff ff       	call   9cbe <lodepng_free>
   1068c:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
   1068f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10693:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
   10697:	75 bf                	jne    10658 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
   10699:	90                   	nop
   1069a:	c9                   	leave  
   1069b:	c3                   	ret    

0001069c <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
   1069c:	55                   	push   %ebp
   1069d:	89 e5                	mov    %esp,%ebp
   1069f:	53                   	push   %ebx
   106a0:	83 ec 20             	sub    $0x20,%esp
   106a3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   106a6:	8b 4d 10             	mov    0x10(%ebp),%ecx
   106a9:	8b 55 14             	mov    0x14(%ebp),%edx
   106ac:	8b 45 18             	mov    0x18(%ebp),%eax
   106af:	88 5d e8             	mov    %bl,-0x18(%ebp)
   106b2:	88 4d e4             	mov    %cl,-0x1c(%ebp)
   106b5:	88 55 e0             	mov    %dl,-0x20(%ebp)
   106b8:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
   106bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
   106c2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   106c9:	eb 76                	jmp    10741 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
   106cb:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
   106cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
   106d2:	89 c1                	mov    %eax,%ecx
   106d4:	d3 fa                	sar    %cl,%edx
   106d6:	89 d0                	mov    %edx,%eax
   106d8:	83 e0 01             	and    $0x1,%eax
   106db:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
   106de:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   106e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   106e5:	89 c1                	mov    %eax,%ecx
   106e7:	d3 fa                	sar    %cl,%edx
   106e9:	89 d0                	mov    %edx,%eax
   106eb:	83 e0 01             	and    $0x1,%eax
   106ee:	01 d8                	add    %ebx,%eax
   106f0:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
   106f3:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
   106f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   106fa:	89 c1                	mov    %eax,%ecx
   106fc:	d3 fa                	sar    %cl,%edx
   106fe:	89 d0                	mov    %edx,%eax
   10700:	83 e0 01             	and    $0x1,%eax
   10703:	01 d8                	add    %ebx,%eax
   10705:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
   10708:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
   1070c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1070f:	89 c1                	mov    %eax,%ecx
   10711:	d3 fa                	sar    %cl,%edx
   10713:	89 d0                	mov    %edx,%eax
   10715:	83 e0 01             	and    $0x1,%eax
   10718:	01 d8                	add    %ebx,%eax
   1071a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
   1071d:	8b 45 08             	mov    0x8(%ebp),%eax
   10720:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10723:	8b 04 90             	mov    (%eax,%edx,4),%eax
   10726:	85 c0                	test   %eax,%eax
   10728:	75 07                	jne    10731 <color_tree_get+0x95>
   1072a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1072f:	eb 2a                	jmp    1075b <color_tree_get+0xbf>
    else tree = tree->children[i];
   10731:	8b 45 08             	mov    0x8(%ebp),%eax
   10734:	8b 55 f4             	mov    -0xc(%ebp),%edx
   10737:	8b 04 90             	mov    (%eax,%edx,4),%eax
   1073a:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
   1073d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   10741:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
   10745:	7e 84                	jle    106cb <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
   10747:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1074b:	74 08                	je     10755 <color_tree_get+0xb9>
   1074d:	8b 45 08             	mov    0x8(%ebp),%eax
   10750:	8b 40 40             	mov    0x40(%eax),%eax
   10753:	eb 05                	jmp    1075a <color_tree_get+0xbe>
   10755:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1075a:	90                   	nop
}
   1075b:	83 c4 20             	add    $0x20,%esp
   1075e:	5b                   	pop    %ebx
   1075f:	5d                   	pop    %ebp
   10760:	c3                   	ret    

00010761 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
   10761:	55                   	push   %ebp
   10762:	89 e5                	mov    %esp,%ebp
   10764:	53                   	push   %ebx
   10765:	83 ec 10             	sub    $0x10,%esp
   10768:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   1076b:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1076e:	8b 55 14             	mov    0x14(%ebp),%edx
   10771:	8b 45 18             	mov    0x18(%ebp),%eax
   10774:	88 5d f8             	mov    %bl,-0x8(%ebp)
   10777:	88 4d f4             	mov    %cl,-0xc(%ebp)
   1077a:	88 55 f0             	mov    %dl,-0x10(%ebp)
   1077d:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
   10780:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
   10784:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
   10788:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
   1078c:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   10790:	53                   	push   %ebx
   10791:	51                   	push   %ecx
   10792:	52                   	push   %edx
   10793:	50                   	push   %eax
   10794:	ff 75 08             	pushl  0x8(%ebp)
   10797:	e8 00 ff ff ff       	call   1069c <color_tree_get>
   1079c:	83 c4 14             	add    $0x14,%esp
   1079f:	f7 d0                	not    %eax
   107a1:	c1 e8 1f             	shr    $0x1f,%eax
   107a4:	0f b6 c0             	movzbl %al,%eax
}
   107a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   107aa:	c9                   	leave  
   107ab:	c3                   	ret    

000107ac <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
   107ac:	55                   	push   %ebp
   107ad:	89 e5                	mov    %esp,%ebp
   107af:	53                   	push   %ebx
   107b0:	83 ec 24             	sub    $0x24,%esp
   107b3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
   107b6:	8b 4d 10             	mov    0x10(%ebp),%ecx
   107b9:	8b 55 14             	mov    0x14(%ebp),%edx
   107bc:	8b 45 18             	mov    0x18(%ebp),%eax
   107bf:	88 5d e4             	mov    %bl,-0x1c(%ebp)
   107c2:	88 4d e0             	mov    %cl,-0x20(%ebp)
   107c5:	88 55 dc             	mov    %dl,-0x24(%ebp)
   107c8:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
   107cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   107d2:	e9 b0 00 00 00       	jmp    10887 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
   107d7:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   107db:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107de:	89 c1                	mov    %eax,%ecx
   107e0:	d3 fa                	sar    %cl,%edx
   107e2:	89 d0                	mov    %edx,%eax
   107e4:	83 e0 01             	and    $0x1,%eax
   107e7:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
   107ea:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
   107ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107f1:	89 c1                	mov    %eax,%ecx
   107f3:	d3 fa                	sar    %cl,%edx
   107f5:	89 d0                	mov    %edx,%eax
   107f7:	83 e0 01             	and    $0x1,%eax
   107fa:	01 d8                	add    %ebx,%eax
   107fc:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
   107ff:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
   10803:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10806:	89 c1                	mov    %eax,%ecx
   10808:	d3 fa                	sar    %cl,%edx
   1080a:	89 d0                	mov    %edx,%eax
   1080c:	83 e0 01             	and    $0x1,%eax
   1080f:	01 d8                	add    %ebx,%eax
   10811:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
   10814:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
   10818:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1081b:	89 c1                	mov    %eax,%ecx
   1081d:	d3 fa                	sar    %cl,%edx
   1081f:	89 d0                	mov    %edx,%eax
   10821:	83 e0 01             	and    $0x1,%eax
   10824:	01 d8                	add    %ebx,%eax
   10826:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
   10829:	8b 45 08             	mov    0x8(%ebp),%eax
   1082c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1082f:	8b 04 90             	mov    (%eax,%edx,4),%eax
   10832:	85 c0                	test   %eax,%eax
   10834:	75 41                	jne    10877 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
   10836:	83 ec 0c             	sub    $0xc,%esp
   10839:	6a 44                	push   $0x44
   1083b:	e8 5d 94 ff ff       	call   9c9d <lodepng_malloc>
   10840:	83 c4 10             	add    $0x10,%esp
   10843:	89 c1                	mov    %eax,%ecx
   10845:	8b 45 08             	mov    0x8(%ebp),%eax
   10848:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1084b:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
   1084e:	8b 45 08             	mov    0x8(%ebp),%eax
   10851:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10854:	8b 04 90             	mov    (%eax,%edx,4),%eax
   10857:	85 c0                	test   %eax,%eax
   10859:	75 07                	jne    10862 <color_tree_add+0xb6>
   1085b:	b8 53 00 00 00       	mov    $0x53,%eax
   10860:	eb 3d                	jmp    1089f <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
   10862:	8b 45 08             	mov    0x8(%ebp),%eax
   10865:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10868:	8b 04 90             	mov    (%eax,%edx,4),%eax
   1086b:	83 ec 0c             	sub    $0xc,%esp
   1086e:	50                   	push   %eax
   1086f:	e8 b5 fd ff ff       	call   10629 <color_tree_init>
   10874:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
   10877:	8b 45 08             	mov    0x8(%ebp),%eax
   1087a:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1087d:	8b 04 90             	mov    (%eax,%edx,4),%eax
   10880:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
   10883:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10887:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   1088b:	0f 8e 46 ff ff ff    	jle    107d7 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
   10891:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10894:	8b 45 08             	mov    0x8(%ebp),%eax
   10897:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
   1089a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1089f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   108a2:	c9                   	leave  
   108a3:	c3                   	ret    

000108a4 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
   108a4:	55                   	push   %ebp
   108a5:	89 e5                	mov    %esp,%ebp
   108a7:	53                   	push   %ebx
   108a8:	83 ec 20             	sub    $0x20,%esp
   108ab:	8b 5d 18             	mov    0x18(%ebp),%ebx
   108ae:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
   108b1:	8b 55 20             	mov    0x20(%ebp),%edx
   108b4:	8b 45 24             	mov    0x24(%ebp),%eax
   108b7:	88 5d e8             	mov    %bl,-0x18(%ebp)
   108ba:	88 4d e4             	mov    %cl,-0x1c(%ebp)
   108bd:	88 55 e0             	mov    %dl,-0x20(%ebp)
   108c0:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
   108c3:	8b 45 10             	mov    0x10(%ebp),%eax
   108c6:	8b 00                	mov    (%eax),%eax
   108c8:	85 c0                	test   %eax,%eax
   108ca:	0f 85 ad 00 00 00    	jne    1097d <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
   108d0:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   108d4:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
   108d7:	8b 45 10             	mov    0x10(%ebp),%eax
   108da:	8b 40 04             	mov    0x4(%eax),%eax
   108dd:	83 f8 08             	cmp    $0x8,%eax
   108e0:	75 13                	jne    108f5 <rgba8ToPixel+0x51>
   108e2:	8b 55 0c             	mov    0xc(%ebp),%edx
   108e5:	8b 45 08             	mov    0x8(%ebp),%eax
   108e8:	01 c2                	add    %eax,%edx
   108ea:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   108ee:	88 02                	mov    %al,(%edx)
   108f0:	e9 b4 03 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
   108f5:	8b 45 10             	mov    0x10(%ebp),%eax
   108f8:	8b 40 04             	mov    0x4(%eax),%eax
   108fb:	83 f8 10             	cmp    $0x10,%eax
   108fe:	75 2a                	jne    1092a <rgba8ToPixel+0x86>
   10900:	8b 45 0c             	mov    0xc(%ebp),%eax
   10903:	01 c0                	add    %eax,%eax
   10905:	89 c2                	mov    %eax,%edx
   10907:	8b 45 08             	mov    0x8(%ebp),%eax
   1090a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1090d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10910:	01 c0                	add    %eax,%eax
   10912:	8d 50 01             	lea    0x1(%eax),%edx
   10915:	8b 45 08             	mov    0x8(%ebp),%eax
   10918:	01 d0                	add    %edx,%eax
   1091a:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
   1091e:	88 10                	mov    %dl,(%eax)
   10920:	0f b6 00             	movzbl (%eax),%eax
   10923:	88 01                	mov    %al,(%ecx)
   10925:	e9 7f 03 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
   1092a:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
   1092e:	8b 45 10             	mov    0x10(%ebp),%eax
   10931:	8b 40 04             	mov    0x4(%eax),%eax
   10934:	b9 08 00 00 00       	mov    $0x8,%ecx
   10939:	29 c1                	sub    %eax,%ecx
   1093b:	89 c8                	mov    %ecx,%eax
   1093d:	89 c1                	mov    %eax,%ecx
   1093f:	d3 ea                	shr    %cl,%edx
   10941:	89 d0                	mov    %edx,%eax
   10943:	89 c2                	mov    %eax,%edx
   10945:	8b 45 10             	mov    0x10(%ebp),%eax
   10948:	8b 40 04             	mov    0x4(%eax),%eax
   1094b:	bb 01 00 00 00       	mov    $0x1,%ebx
   10950:	89 c1                	mov    %eax,%ecx
   10952:	d3 e3                	shl    %cl,%ebx
   10954:	89 d8                	mov    %ebx,%eax
   10956:	83 e8 01             	sub    $0x1,%eax
   10959:	21 d0                	and    %edx,%eax
   1095b:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
   1095e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
   10962:	8b 45 10             	mov    0x10(%ebp),%eax
   10965:	8b 40 04             	mov    0x4(%eax),%eax
   10968:	52                   	push   %edx
   10969:	50                   	push   %eax
   1096a:	ff 75 0c             	pushl  0xc(%ebp)
   1096d:	ff 75 08             	pushl  0x8(%ebp)
   10970:	e8 21 fc ff ff       	call   10596 <addColorBits>
   10975:	83 c4 10             	add    $0x10,%esp
   10978:	e9 2c 03 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
   1097d:	8b 45 10             	mov    0x10(%ebp),%eax
   10980:	8b 00                	mov    (%eax),%eax
   10982:	83 f8 02             	cmp    $0x2,%eax
   10985:	0f 85 ee 00 00 00    	jne    10a79 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
   1098b:	8b 45 10             	mov    0x10(%ebp),%eax
   1098e:	8b 40 04             	mov    0x4(%eax),%eax
   10991:	83 f8 08             	cmp    $0x8,%eax
   10994:	75 49                	jne    109df <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
   10996:	8b 55 0c             	mov    0xc(%ebp),%edx
   10999:	89 d0                	mov    %edx,%eax
   1099b:	01 c0                	add    %eax,%eax
   1099d:	01 d0                	add    %edx,%eax
   1099f:	89 c2                	mov    %eax,%edx
   109a1:	8b 45 08             	mov    0x8(%ebp),%eax
   109a4:	01 c2                	add    %eax,%edx
   109a6:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   109aa:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
   109ac:	8b 55 0c             	mov    0xc(%ebp),%edx
   109af:	89 d0                	mov    %edx,%eax
   109b1:	01 c0                	add    %eax,%eax
   109b3:	01 d0                	add    %edx,%eax
   109b5:	8d 50 01             	lea    0x1(%eax),%edx
   109b8:	8b 45 08             	mov    0x8(%ebp),%eax
   109bb:	01 c2                	add    %eax,%edx
   109bd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   109c1:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
   109c3:	8b 55 0c             	mov    0xc(%ebp),%edx
   109c6:	89 d0                	mov    %edx,%eax
   109c8:	01 c0                	add    %eax,%eax
   109ca:	01 d0                	add    %edx,%eax
   109cc:	8d 50 02             	lea    0x2(%eax),%edx
   109cf:	8b 45 08             	mov    0x8(%ebp),%eax
   109d2:	01 c2                	add    %eax,%edx
   109d4:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
   109d8:	88 02                	mov    %al,(%edx)
   109da:	e9 ca 02 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
   109df:	8b 55 0c             	mov    0xc(%ebp),%edx
   109e2:	89 d0                	mov    %edx,%eax
   109e4:	01 c0                	add    %eax,%eax
   109e6:	01 d0                	add    %edx,%eax
   109e8:	01 c0                	add    %eax,%eax
   109ea:	89 c2                	mov    %eax,%edx
   109ec:	8b 45 08             	mov    0x8(%ebp),%eax
   109ef:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   109f2:	8b 55 0c             	mov    0xc(%ebp),%edx
   109f5:	89 d0                	mov    %edx,%eax
   109f7:	01 c0                	add    %eax,%eax
   109f9:	01 d0                	add    %edx,%eax
   109fb:	01 c0                	add    %eax,%eax
   109fd:	8d 50 01             	lea    0x1(%eax),%edx
   10a00:	8b 45 08             	mov    0x8(%ebp),%eax
   10a03:	01 d0                	add    %edx,%eax
   10a05:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
   10a09:	88 10                	mov    %dl,(%eax)
   10a0b:	0f b6 00             	movzbl (%eax),%eax
   10a0e:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
   10a10:	8b 55 0c             	mov    0xc(%ebp),%edx
   10a13:	89 d0                	mov    %edx,%eax
   10a15:	01 c0                	add    %eax,%eax
   10a17:	01 d0                	add    %edx,%eax
   10a19:	01 c0                	add    %eax,%eax
   10a1b:	8d 50 02             	lea    0x2(%eax),%edx
   10a1e:	8b 45 08             	mov    0x8(%ebp),%eax
   10a21:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10a24:	8b 55 0c             	mov    0xc(%ebp),%edx
   10a27:	89 d0                	mov    %edx,%eax
   10a29:	01 c0                	add    %eax,%eax
   10a2b:	01 d0                	add    %edx,%eax
   10a2d:	01 c0                	add    %eax,%eax
   10a2f:	8d 50 03             	lea    0x3(%eax),%edx
   10a32:	8b 45 08             	mov    0x8(%ebp),%eax
   10a35:	01 d0                	add    %edx,%eax
   10a37:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   10a3b:	88 10                	mov    %dl,(%eax)
   10a3d:	0f b6 00             	movzbl (%eax),%eax
   10a40:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
   10a42:	8b 55 0c             	mov    0xc(%ebp),%edx
   10a45:	89 d0                	mov    %edx,%eax
   10a47:	01 c0                	add    %eax,%eax
   10a49:	01 d0                	add    %edx,%eax
   10a4b:	01 c0                	add    %eax,%eax
   10a4d:	8d 50 04             	lea    0x4(%eax),%edx
   10a50:	8b 45 08             	mov    0x8(%ebp),%eax
   10a53:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10a56:	8b 55 0c             	mov    0xc(%ebp),%edx
   10a59:	89 d0                	mov    %edx,%eax
   10a5b:	01 c0                	add    %eax,%eax
   10a5d:	01 d0                	add    %edx,%eax
   10a5f:	01 c0                	add    %eax,%eax
   10a61:	8d 50 05             	lea    0x5(%eax),%edx
   10a64:	8b 45 08             	mov    0x8(%ebp),%eax
   10a67:	01 d0                	add    %edx,%eax
   10a69:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
   10a6d:	88 10                	mov    %dl,(%eax)
   10a6f:	0f b6 00             	movzbl (%eax),%eax
   10a72:	88 01                	mov    %al,(%ecx)
   10a74:	e9 30 02 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
   10a79:	8b 45 10             	mov    0x10(%ebp),%eax
   10a7c:	8b 00                	mov    (%eax),%eax
   10a7e:	83 f8 03             	cmp    $0x3,%eax
   10a81:	75 6d                	jne    10af0 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
   10a83:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
   10a87:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
   10a8b:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   10a8f:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   10a93:	53                   	push   %ebx
   10a94:	51                   	push   %ecx
   10a95:	52                   	push   %edx
   10a96:	50                   	push   %eax
   10a97:	ff 75 14             	pushl  0x14(%ebp)
   10a9a:	e8 fd fb ff ff       	call   1069c <color_tree_get>
   10a9f:	83 c4 14             	add    $0x14,%esp
   10aa2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
   10aa5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10aa9:	79 0a                	jns    10ab5 <rgba8ToPixel+0x211>
   10aab:	b8 52 00 00 00       	mov    $0x52,%eax
   10ab0:	e9 f9 01 00 00       	jmp    10cae <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
   10ab5:	8b 45 10             	mov    0x10(%ebp),%eax
   10ab8:	8b 40 04             	mov    0x4(%eax),%eax
   10abb:	83 f8 08             	cmp    $0x8,%eax
   10abe:	75 12                	jne    10ad2 <rgba8ToPixel+0x22e>
   10ac0:	8b 55 0c             	mov    0xc(%ebp),%edx
   10ac3:	8b 45 08             	mov    0x8(%ebp),%eax
   10ac6:	01 d0                	add    %edx,%eax
   10ac8:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10acb:	88 10                	mov    %dl,(%eax)
   10acd:	e9 d7 01 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
   10ad2:	8b 55 f8             	mov    -0x8(%ebp),%edx
   10ad5:	8b 45 10             	mov    0x10(%ebp),%eax
   10ad8:	8b 40 04             	mov    0x4(%eax),%eax
   10adb:	52                   	push   %edx
   10adc:	50                   	push   %eax
   10add:	ff 75 0c             	pushl  0xc(%ebp)
   10ae0:	ff 75 08             	pushl  0x8(%ebp)
   10ae3:	e8 ae fa ff ff       	call   10596 <addColorBits>
   10ae8:	83 c4 10             	add    $0x10,%esp
   10aeb:	e9 b9 01 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
   10af0:	8b 45 10             	mov    0x10(%ebp),%eax
   10af3:	8b 00                	mov    (%eax),%eax
   10af5:	83 f8 04             	cmp    $0x4,%eax
   10af8:	0f 85 9f 00 00 00    	jne    10b9d <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
   10afe:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   10b02:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
   10b05:	8b 45 10             	mov    0x10(%ebp),%eax
   10b08:	8b 40 04             	mov    0x4(%eax),%eax
   10b0b:	83 f8 08             	cmp    $0x8,%eax
   10b0e:	75 2a                	jne    10b3a <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
   10b10:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b13:	01 c0                	add    %eax,%eax
   10b15:	89 c2                	mov    %eax,%edx
   10b17:	8b 45 08             	mov    0x8(%ebp),%eax
   10b1a:	01 c2                	add    %eax,%edx
   10b1c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   10b20:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
   10b22:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b25:	01 c0                	add    %eax,%eax
   10b27:	8d 50 01             	lea    0x1(%eax),%edx
   10b2a:	8b 45 08             	mov    0x8(%ebp),%eax
   10b2d:	01 c2                	add    %eax,%edx
   10b2f:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
   10b33:	88 02                	mov    %al,(%edx)
   10b35:	e9 6f 01 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
   10b3a:	8b 45 10             	mov    0x10(%ebp),%eax
   10b3d:	8b 40 04             	mov    0x4(%eax),%eax
   10b40:	83 f8 10             	cmp    $0x10,%eax
   10b43:	0f 85 60 01 00 00    	jne    10ca9 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
   10b49:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b4c:	c1 e0 02             	shl    $0x2,%eax
   10b4f:	89 c2                	mov    %eax,%edx
   10b51:	8b 45 08             	mov    0x8(%ebp),%eax
   10b54:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10b57:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b5a:	c1 e0 02             	shl    $0x2,%eax
   10b5d:	8d 50 01             	lea    0x1(%eax),%edx
   10b60:	8b 45 08             	mov    0x8(%ebp),%eax
   10b63:	01 d0                	add    %edx,%eax
   10b65:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
   10b69:	88 10                	mov    %dl,(%eax)
   10b6b:	0f b6 00             	movzbl (%eax),%eax
   10b6e:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
   10b70:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b73:	c1 e0 02             	shl    $0x2,%eax
   10b76:	8d 50 02             	lea    0x2(%eax),%edx
   10b79:	8b 45 08             	mov    0x8(%ebp),%eax
   10b7c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b82:	c1 e0 02             	shl    $0x2,%eax
   10b85:	8d 50 03             	lea    0x3(%eax),%edx
   10b88:	8b 45 08             	mov    0x8(%ebp),%eax
   10b8b:	01 d0                	add    %edx,%eax
   10b8d:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
   10b91:	88 10                	mov    %dl,(%eax)
   10b93:	0f b6 00             	movzbl (%eax),%eax
   10b96:	88 01                	mov    %al,(%ecx)
   10b98:	e9 0c 01 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
   10b9d:	8b 45 10             	mov    0x10(%ebp),%eax
   10ba0:	8b 00                	mov    (%eax),%eax
   10ba2:	83 f8 06             	cmp    $0x6,%eax
   10ba5:	0f 85 fe 00 00 00    	jne    10ca9 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
   10bab:	8b 45 10             	mov    0x10(%ebp),%eax
   10bae:	8b 40 04             	mov    0x4(%eax),%eax
   10bb1:	83 f8 08             	cmp    $0x8,%eax
   10bb4:	75 54                	jne    10c0a <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
   10bb6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bb9:	c1 e0 02             	shl    $0x2,%eax
   10bbc:	89 c2                	mov    %eax,%edx
   10bbe:	8b 45 08             	mov    0x8(%ebp),%eax
   10bc1:	01 c2                	add    %eax,%edx
   10bc3:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   10bc7:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
   10bc9:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bcc:	c1 e0 02             	shl    $0x2,%eax
   10bcf:	8d 50 01             	lea    0x1(%eax),%edx
   10bd2:	8b 45 08             	mov    0x8(%ebp),%eax
   10bd5:	01 c2                	add    %eax,%edx
   10bd7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   10bdb:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
   10bdd:	8b 45 0c             	mov    0xc(%ebp),%eax
   10be0:	c1 e0 02             	shl    $0x2,%eax
   10be3:	8d 50 02             	lea    0x2(%eax),%edx
   10be6:	8b 45 08             	mov    0x8(%ebp),%eax
   10be9:	01 c2                	add    %eax,%edx
   10beb:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
   10bef:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
   10bf1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bf4:	c1 e0 02             	shl    $0x2,%eax
   10bf7:	8d 50 03             	lea    0x3(%eax),%edx
   10bfa:	8b 45 08             	mov    0x8(%ebp),%eax
   10bfd:	01 c2                	add    %eax,%edx
   10bff:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
   10c03:	88 02                	mov    %al,(%edx)
   10c05:	e9 9f 00 00 00       	jmp    10ca9 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
   10c0a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c0d:	c1 e0 03             	shl    $0x3,%eax
   10c10:	89 c2                	mov    %eax,%edx
   10c12:	8b 45 08             	mov    0x8(%ebp),%eax
   10c15:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10c18:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c1b:	c1 e0 03             	shl    $0x3,%eax
   10c1e:	8d 50 01             	lea    0x1(%eax),%edx
   10c21:	8b 45 08             	mov    0x8(%ebp),%eax
   10c24:	01 d0                	add    %edx,%eax
   10c26:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
   10c2a:	88 10                	mov    %dl,(%eax)
   10c2c:	0f b6 00             	movzbl (%eax),%eax
   10c2f:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
   10c31:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c34:	c1 e0 03             	shl    $0x3,%eax
   10c37:	8d 50 02             	lea    0x2(%eax),%edx
   10c3a:	8b 45 08             	mov    0x8(%ebp),%eax
   10c3d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10c40:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c43:	c1 e0 03             	shl    $0x3,%eax
   10c46:	8d 50 03             	lea    0x3(%eax),%edx
   10c49:	8b 45 08             	mov    0x8(%ebp),%eax
   10c4c:	01 d0                	add    %edx,%eax
   10c4e:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   10c52:	88 10                	mov    %dl,(%eax)
   10c54:	0f b6 00             	movzbl (%eax),%eax
   10c57:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
   10c59:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c5c:	c1 e0 03             	shl    $0x3,%eax
   10c5f:	8d 50 04             	lea    0x4(%eax),%edx
   10c62:	8b 45 08             	mov    0x8(%ebp),%eax
   10c65:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10c68:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c6b:	c1 e0 03             	shl    $0x3,%eax
   10c6e:	8d 50 05             	lea    0x5(%eax),%edx
   10c71:	8b 45 08             	mov    0x8(%ebp),%eax
   10c74:	01 d0                	add    %edx,%eax
   10c76:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
   10c7a:	88 10                	mov    %dl,(%eax)
   10c7c:	0f b6 00             	movzbl (%eax),%eax
   10c7f:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
   10c81:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c84:	c1 e0 03             	shl    $0x3,%eax
   10c87:	8d 50 06             	lea    0x6(%eax),%edx
   10c8a:	8b 45 08             	mov    0x8(%ebp),%eax
   10c8d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10c90:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c93:	c1 e0 03             	shl    $0x3,%eax
   10c96:	8d 50 07             	lea    0x7(%eax),%edx
   10c99:	8b 45 08             	mov    0x8(%ebp),%eax
   10c9c:	01 d0                	add    %edx,%eax
   10c9e:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
   10ca2:	88 10                	mov    %dl,(%eax)
   10ca4:	0f b6 00             	movzbl (%eax),%eax
   10ca7:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
   10ca9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10cae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10cb1:	c9                   	leave  
   10cb2:	c3                   	ret    

00010cb3 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
   10cb3:	55                   	push   %ebp
   10cb4:	89 e5                	mov    %esp,%ebp
   10cb6:	53                   	push   %ebx
   10cb7:	83 ec 20             	sub    $0x20,%esp
   10cba:	8b 5d 14             	mov    0x14(%ebp),%ebx
   10cbd:	8b 4d 18             	mov    0x18(%ebp),%ecx
   10cc0:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10cc3:	8b 45 20             	mov    0x20(%ebp),%eax
   10cc6:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
   10cca:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
   10cce:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
   10cd2:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
   10cd6:	8b 45 10             	mov    0x10(%ebp),%eax
   10cd9:	8b 00                	mov    (%eax),%eax
   10cdb:	85 c0                	test   %eax,%eax
   10cdd:	75 36                	jne    10d15 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
   10cdf:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
   10ce3:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
   10ce7:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cea:	01 c0                	add    %eax,%eax
   10cec:	89 c2                	mov    %eax,%edx
   10cee:	8b 45 08             	mov    0x8(%ebp),%eax
   10cf1:	01 d0                	add    %edx,%eax
   10cf3:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
   10cf7:	66 c1 ea 08          	shr    $0x8,%dx
   10cfb:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
   10cfd:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d00:	01 c0                	add    %eax,%eax
   10d02:	8d 50 01             	lea    0x1(%eax),%edx
   10d05:	8b 45 08             	mov    0x8(%ebp),%eax
   10d08:	01 d0                	add    %edx,%eax
   10d0a:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
   10d0e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
   10d10:	e9 df 01 00 00       	jmp    10ef4 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
   10d15:	8b 45 10             	mov    0x10(%ebp),%eax
   10d18:	8b 00                	mov    (%eax),%eax
   10d1a:	83 f8 02             	cmp    $0x2,%eax
   10d1d:	0f 85 a6 00 00 00    	jne    10dc9 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
   10d23:	8b 55 0c             	mov    0xc(%ebp),%edx
   10d26:	89 d0                	mov    %edx,%eax
   10d28:	01 c0                	add    %eax,%eax
   10d2a:	01 d0                	add    %edx,%eax
   10d2c:	01 c0                	add    %eax,%eax
   10d2e:	89 c2                	mov    %eax,%edx
   10d30:	8b 45 08             	mov    0x8(%ebp),%eax
   10d33:	01 d0                	add    %edx,%eax
   10d35:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   10d39:	66 c1 ea 08          	shr    $0x8,%dx
   10d3d:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
   10d3f:	8b 55 0c             	mov    0xc(%ebp),%edx
   10d42:	89 d0                	mov    %edx,%eax
   10d44:	01 c0                	add    %eax,%eax
   10d46:	01 d0                	add    %edx,%eax
   10d48:	01 c0                	add    %eax,%eax
   10d4a:	8d 50 01             	lea    0x1(%eax),%edx
   10d4d:	8b 45 08             	mov    0x8(%ebp),%eax
   10d50:	01 d0                	add    %edx,%eax
   10d52:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   10d56:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
   10d58:	8b 55 0c             	mov    0xc(%ebp),%edx
   10d5b:	89 d0                	mov    %edx,%eax
   10d5d:	01 c0                	add    %eax,%eax
   10d5f:	01 d0                	add    %edx,%eax
   10d61:	01 c0                	add    %eax,%eax
   10d63:	8d 50 02             	lea    0x2(%eax),%edx
   10d66:	8b 45 08             	mov    0x8(%ebp),%eax
   10d69:	01 d0                	add    %edx,%eax
   10d6b:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
   10d6f:	66 c1 ea 08          	shr    $0x8,%dx
   10d73:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
   10d75:	8b 55 0c             	mov    0xc(%ebp),%edx
   10d78:	89 d0                	mov    %edx,%eax
   10d7a:	01 c0                	add    %eax,%eax
   10d7c:	01 d0                	add    %edx,%eax
   10d7e:	01 c0                	add    %eax,%eax
   10d80:	8d 50 03             	lea    0x3(%eax),%edx
   10d83:	8b 45 08             	mov    0x8(%ebp),%eax
   10d86:	01 d0                	add    %edx,%eax
   10d88:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
   10d8c:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
   10d8e:	8b 55 0c             	mov    0xc(%ebp),%edx
   10d91:	89 d0                	mov    %edx,%eax
   10d93:	01 c0                	add    %eax,%eax
   10d95:	01 d0                	add    %edx,%eax
   10d97:	01 c0                	add    %eax,%eax
   10d99:	8d 50 04             	lea    0x4(%eax),%edx
   10d9c:	8b 45 08             	mov    0x8(%ebp),%eax
   10d9f:	01 d0                	add    %edx,%eax
   10da1:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
   10da5:	66 c1 ea 08          	shr    $0x8,%dx
   10da9:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
   10dab:	8b 55 0c             	mov    0xc(%ebp),%edx
   10dae:	89 d0                	mov    %edx,%eax
   10db0:	01 c0                	add    %eax,%eax
   10db2:	01 d0                	add    %edx,%eax
   10db4:	01 c0                	add    %eax,%eax
   10db6:	8d 50 05             	lea    0x5(%eax),%edx
   10db9:	8b 45 08             	mov    0x8(%ebp),%eax
   10dbc:	01 d0                	add    %edx,%eax
   10dbe:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
   10dc2:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
   10dc4:	e9 2b 01 00 00       	jmp    10ef4 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
   10dc9:	8b 45 10             	mov    0x10(%ebp),%eax
   10dcc:	8b 00                	mov    (%eax),%eax
   10dce:	83 f8 04             	cmp    $0x4,%eax
   10dd1:	75 64                	jne    10e37 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
   10dd3:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
   10dd7:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
   10ddb:	8b 45 0c             	mov    0xc(%ebp),%eax
   10dde:	c1 e0 02             	shl    $0x2,%eax
   10de1:	89 c2                	mov    %eax,%edx
   10de3:	8b 45 08             	mov    0x8(%ebp),%eax
   10de6:	01 d0                	add    %edx,%eax
   10de8:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   10dec:	66 c1 ea 08          	shr    $0x8,%dx
   10df0:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
   10df2:	8b 45 0c             	mov    0xc(%ebp),%eax
   10df5:	c1 e0 02             	shl    $0x2,%eax
   10df8:	8d 50 01             	lea    0x1(%eax),%edx
   10dfb:	8b 45 08             	mov    0x8(%ebp),%eax
   10dfe:	01 d0                	add    %edx,%eax
   10e00:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   10e04:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
   10e06:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e09:	c1 e0 02             	shl    $0x2,%eax
   10e0c:	8d 50 02             	lea    0x2(%eax),%edx
   10e0f:	8b 45 08             	mov    0x8(%ebp),%eax
   10e12:	01 d0                	add    %edx,%eax
   10e14:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
   10e18:	66 c1 ea 08          	shr    $0x8,%dx
   10e1c:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
   10e1e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e21:	c1 e0 02             	shl    $0x2,%eax
   10e24:	8d 50 03             	lea    0x3(%eax),%edx
   10e27:	8b 45 08             	mov    0x8(%ebp),%eax
   10e2a:	01 d0                	add    %edx,%eax
   10e2c:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
   10e30:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
   10e32:	e9 bd 00 00 00       	jmp    10ef4 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
   10e37:	8b 45 10             	mov    0x10(%ebp),%eax
   10e3a:	8b 00                	mov    (%eax),%eax
   10e3c:	83 f8 06             	cmp    $0x6,%eax
   10e3f:	0f 85 af 00 00 00    	jne    10ef4 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
   10e45:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e48:	c1 e0 03             	shl    $0x3,%eax
   10e4b:	89 c2                	mov    %eax,%edx
   10e4d:	8b 45 08             	mov    0x8(%ebp),%eax
   10e50:	01 d0                	add    %edx,%eax
   10e52:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   10e56:	66 c1 ea 08          	shr    $0x8,%dx
   10e5a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
   10e5c:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e5f:	c1 e0 03             	shl    $0x3,%eax
   10e62:	8d 50 01             	lea    0x1(%eax),%edx
   10e65:	8b 45 08             	mov    0x8(%ebp),%eax
   10e68:	01 d0                	add    %edx,%eax
   10e6a:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   10e6e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
   10e70:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e73:	c1 e0 03             	shl    $0x3,%eax
   10e76:	8d 50 02             	lea    0x2(%eax),%edx
   10e79:	8b 45 08             	mov    0x8(%ebp),%eax
   10e7c:	01 d0                	add    %edx,%eax
   10e7e:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
   10e82:	66 c1 ea 08          	shr    $0x8,%dx
   10e86:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
   10e88:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e8b:	c1 e0 03             	shl    $0x3,%eax
   10e8e:	8d 50 03             	lea    0x3(%eax),%edx
   10e91:	8b 45 08             	mov    0x8(%ebp),%eax
   10e94:	01 d0                	add    %edx,%eax
   10e96:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
   10e9a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
   10e9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e9f:	c1 e0 03             	shl    $0x3,%eax
   10ea2:	8d 50 04             	lea    0x4(%eax),%edx
   10ea5:	8b 45 08             	mov    0x8(%ebp),%eax
   10ea8:	01 d0                	add    %edx,%eax
   10eaa:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
   10eae:	66 c1 ea 08          	shr    $0x8,%dx
   10eb2:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
   10eb4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10eb7:	c1 e0 03             	shl    $0x3,%eax
   10eba:	8d 50 05             	lea    0x5(%eax),%edx
   10ebd:	8b 45 08             	mov    0x8(%ebp),%eax
   10ec0:	01 d0                	add    %edx,%eax
   10ec2:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
   10ec6:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
   10ec8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ecb:	c1 e0 03             	shl    $0x3,%eax
   10ece:	8d 50 06             	lea    0x6(%eax),%edx
   10ed1:	8b 45 08             	mov    0x8(%ebp),%eax
   10ed4:	01 d0                	add    %edx,%eax
   10ed6:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
   10eda:	66 c1 ea 08          	shr    $0x8,%dx
   10ede:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
   10ee0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ee3:	c1 e0 03             	shl    $0x3,%eax
   10ee6:	8d 50 07             	lea    0x7(%eax),%edx
   10ee9:	8b 45 08             	mov    0x8(%ebp),%eax
   10eec:	01 d0                	add    %edx,%eax
   10eee:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
   10ef2:	88 10                	mov    %dl,(%eax)
  }
}
   10ef4:	90                   	nop
   10ef5:	83 c4 20             	add    $0x20,%esp
   10ef8:	5b                   	pop    %ebx
   10ef9:	5d                   	pop    %ebp
   10efa:	c3                   	ret    

00010efb <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
   10efb:	55                   	push   %ebp
   10efc:	89 e5                	mov    %esp,%ebp
   10efe:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
   10f01:	8b 45 20             	mov    0x20(%ebp),%eax
   10f04:	8b 00                	mov    (%eax),%eax
   10f06:	85 c0                	test   %eax,%eax
   10f08:	0f 85 8c 01 00 00    	jne    1109a <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
   10f0e:	8b 45 20             	mov    0x20(%ebp),%eax
   10f11:	8b 40 04             	mov    0x4(%eax),%eax
   10f14:	83 f8 08             	cmp    $0x8,%eax
   10f17:	75 59                	jne    10f72 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
   10f19:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10f1c:	8b 45 18             	mov    0x18(%ebp),%eax
   10f1f:	01 d0                	add    %edx,%eax
   10f21:	0f b6 10             	movzbl (%eax),%edx
   10f24:	8b 45 10             	mov    0x10(%ebp),%eax
   10f27:	88 10                	mov    %dl,(%eax)
   10f29:	8b 45 10             	mov    0x10(%ebp),%eax
   10f2c:	0f b6 10             	movzbl (%eax),%edx
   10f2f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f32:	88 10                	mov    %dl,(%eax)
   10f34:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f37:	0f b6 10             	movzbl (%eax),%edx
   10f3a:	8b 45 08             	mov    0x8(%ebp),%eax
   10f3d:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
   10f3f:	8b 45 20             	mov    0x20(%ebp),%eax
   10f42:	8b 40 10             	mov    0x10(%eax),%eax
   10f45:	85 c0                	test   %eax,%eax
   10f47:	74 1e                	je     10f67 <getPixelColorRGBA8+0x6c>
   10f49:	8b 45 08             	mov    0x8(%ebp),%eax
   10f4c:	0f b6 00             	movzbl (%eax),%eax
   10f4f:	0f b6 d0             	movzbl %al,%edx
   10f52:	8b 45 20             	mov    0x20(%ebp),%eax
   10f55:	8b 40 14             	mov    0x14(%eax),%eax
   10f58:	39 c2                	cmp    %eax,%edx
   10f5a:	75 0b                	jne    10f67 <getPixelColorRGBA8+0x6c>
   10f5c:	8b 45 14             	mov    0x14(%ebp),%eax
   10f5f:	c6 00 00             	movb   $0x0,(%eax)
   10f62:	e9 5e 05 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
   10f67:	8b 45 14             	mov    0x14(%ebp),%eax
   10f6a:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   10f6d:	e9 53 05 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
   10f72:	8b 45 20             	mov    0x20(%ebp),%eax
   10f75:	8b 40 04             	mov    0x4(%eax),%eax
   10f78:	83 f8 10             	cmp    $0x10,%eax
   10f7b:	0f 85 80 00 00 00    	jne    11001 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
   10f81:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10f84:	01 c0                	add    %eax,%eax
   10f86:	89 c2                	mov    %eax,%edx
   10f88:	8b 45 18             	mov    0x18(%ebp),%eax
   10f8b:	01 d0                	add    %edx,%eax
   10f8d:	0f b6 10             	movzbl (%eax),%edx
   10f90:	8b 45 10             	mov    0x10(%ebp),%eax
   10f93:	88 10                	mov    %dl,(%eax)
   10f95:	8b 45 10             	mov    0x10(%ebp),%eax
   10f98:	0f b6 10             	movzbl (%eax),%edx
   10f9b:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f9e:	88 10                	mov    %dl,(%eax)
   10fa0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fa3:	0f b6 10             	movzbl (%eax),%edx
   10fa6:	8b 45 08             	mov    0x8(%ebp),%eax
   10fa9:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
   10fab:	8b 45 20             	mov    0x20(%ebp),%eax
   10fae:	8b 40 10             	mov    0x10(%eax),%eax
   10fb1:	85 c0                	test   %eax,%eax
   10fb3:	74 41                	je     10ff6 <getPixelColorRGBA8+0xfb>
   10fb5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10fb8:	01 c0                	add    %eax,%eax
   10fba:	89 c2                	mov    %eax,%edx
   10fbc:	8b 45 18             	mov    0x18(%ebp),%eax
   10fbf:	01 d0                	add    %edx,%eax
   10fc1:	0f b6 00             	movzbl (%eax),%eax
   10fc4:	0f b6 c0             	movzbl %al,%eax
   10fc7:	c1 e0 08             	shl    $0x8,%eax
   10fca:	89 c2                	mov    %eax,%edx
   10fcc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10fcf:	01 c0                	add    %eax,%eax
   10fd1:	8d 48 01             	lea    0x1(%eax),%ecx
   10fd4:	8b 45 18             	mov    0x18(%ebp),%eax
   10fd7:	01 c8                	add    %ecx,%eax
   10fd9:	0f b6 00             	movzbl (%eax),%eax
   10fdc:	0f b6 c0             	movzbl %al,%eax
   10fdf:	01 c2                	add    %eax,%edx
   10fe1:	8b 45 20             	mov    0x20(%ebp),%eax
   10fe4:	8b 40 14             	mov    0x14(%eax),%eax
   10fe7:	39 c2                	cmp    %eax,%edx
   10fe9:	75 0b                	jne    10ff6 <getPixelColorRGBA8+0xfb>
   10feb:	8b 45 14             	mov    0x14(%ebp),%eax
   10fee:	c6 00 00             	movb   $0x0,(%eax)
   10ff1:	e9 cf 04 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
   10ff6:	8b 45 14             	mov    0x14(%ebp),%eax
   10ff9:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   10ffc:	e9 c4 04 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
   11001:	8b 45 20             	mov    0x20(%ebp),%eax
   11004:	8b 40 04             	mov    0x4(%eax),%eax
   11007:	ba 01 00 00 00       	mov    $0x1,%edx
   1100c:	89 c1                	mov    %eax,%ecx
   1100e:	d3 e2                	shl    %cl,%edx
   11010:	89 d0                	mov    %edx,%eax
   11012:	83 e8 01             	sub    $0x1,%eax
   11015:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
   11018:	8b 45 20             	mov    0x20(%ebp),%eax
   1101b:	8b 50 04             	mov    0x4(%eax),%edx
   1101e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11021:	0f af c2             	imul   %edx,%eax
   11024:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
   11027:	8b 45 20             	mov    0x20(%ebp),%eax
   1102a:	8b 40 04             	mov    0x4(%eax),%eax
   1102d:	50                   	push   %eax
   1102e:	ff 75 18             	pushl  0x18(%ebp)
   11031:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11034:	50                   	push   %eax
   11035:	e8 06 db ff ff       	call   eb40 <readBitsFromReversedStream>
   1103a:	83 c4 0c             	add    $0xc,%esp
   1103d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
   11040:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11043:	89 d0                	mov    %edx,%eax
   11045:	c1 e0 08             	shl    $0x8,%eax
   11048:	29 d0                	sub    %edx,%eax
   1104a:	ba 00 00 00 00       	mov    $0x0,%edx
   1104f:	f7 75 f8             	divl   -0x8(%ebp)
   11052:	89 c2                	mov    %eax,%edx
   11054:	8b 45 10             	mov    0x10(%ebp),%eax
   11057:	88 10                	mov    %dl,(%eax)
   11059:	8b 45 10             	mov    0x10(%ebp),%eax
   1105c:	0f b6 10             	movzbl (%eax),%edx
   1105f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11062:	88 10                	mov    %dl,(%eax)
   11064:	8b 45 0c             	mov    0xc(%ebp),%eax
   11067:	0f b6 10             	movzbl (%eax),%edx
   1106a:	8b 45 08             	mov    0x8(%ebp),%eax
   1106d:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
   1106f:	8b 45 20             	mov    0x20(%ebp),%eax
   11072:	8b 40 10             	mov    0x10(%eax),%eax
   11075:	85 c0                	test   %eax,%eax
   11077:	74 16                	je     1108f <getPixelColorRGBA8+0x194>
   11079:	8b 45 20             	mov    0x20(%ebp),%eax
   1107c:	8b 40 14             	mov    0x14(%eax),%eax
   1107f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   11082:	75 0b                	jne    1108f <getPixelColorRGBA8+0x194>
   11084:	8b 45 14             	mov    0x14(%ebp),%eax
   11087:	c6 00 00             	movb   $0x0,(%eax)
   1108a:	e9 36 04 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
   1108f:	8b 45 14             	mov    0x14(%ebp),%eax
   11092:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   11095:	e9 2b 04 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
   1109a:	8b 45 20             	mov    0x20(%ebp),%eax
   1109d:	8b 00                	mov    (%eax),%eax
   1109f:	83 f8 02             	cmp    $0x2,%eax
   110a2:	0f 85 f5 01 00 00    	jne    1129d <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
   110a8:	8b 45 20             	mov    0x20(%ebp),%eax
   110ab:	8b 40 04             	mov    0x4(%eax),%eax
   110ae:	83 f8 08             	cmp    $0x8,%eax
   110b1:	0f 85 a3 00 00 00    	jne    1115a <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
   110b7:	8b 55 1c             	mov    0x1c(%ebp),%edx
   110ba:	89 d0                	mov    %edx,%eax
   110bc:	01 c0                	add    %eax,%eax
   110be:	01 d0                	add    %edx,%eax
   110c0:	89 c2                	mov    %eax,%edx
   110c2:	8b 45 18             	mov    0x18(%ebp),%eax
   110c5:	01 d0                	add    %edx,%eax
   110c7:	0f b6 10             	movzbl (%eax),%edx
   110ca:	8b 45 08             	mov    0x8(%ebp),%eax
   110cd:	88 10                	mov    %dl,(%eax)
   110cf:	8b 55 1c             	mov    0x1c(%ebp),%edx
   110d2:	89 d0                	mov    %edx,%eax
   110d4:	01 c0                	add    %eax,%eax
   110d6:	01 d0                	add    %edx,%eax
   110d8:	8d 50 01             	lea    0x1(%eax),%edx
   110db:	8b 45 18             	mov    0x18(%ebp),%eax
   110de:	01 d0                	add    %edx,%eax
   110e0:	0f b6 10             	movzbl (%eax),%edx
   110e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   110e6:	88 10                	mov    %dl,(%eax)
   110e8:	8b 55 1c             	mov    0x1c(%ebp),%edx
   110eb:	89 d0                	mov    %edx,%eax
   110ed:	01 c0                	add    %eax,%eax
   110ef:	01 d0                	add    %edx,%eax
   110f1:	8d 50 02             	lea    0x2(%eax),%edx
   110f4:	8b 45 18             	mov    0x18(%ebp),%eax
   110f7:	01 d0                	add    %edx,%eax
   110f9:	0f b6 10             	movzbl (%eax),%edx
   110fc:	8b 45 10             	mov    0x10(%ebp),%eax
   110ff:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
   11101:	8b 45 20             	mov    0x20(%ebp),%eax
   11104:	8b 40 10             	mov    0x10(%eax),%eax
   11107:	85 c0                	test   %eax,%eax
   11109:	74 44                	je     1114f <getPixelColorRGBA8+0x254>
   1110b:	8b 45 08             	mov    0x8(%ebp),%eax
   1110e:	0f b6 00             	movzbl (%eax),%eax
   11111:	0f b6 d0             	movzbl %al,%edx
   11114:	8b 45 20             	mov    0x20(%ebp),%eax
   11117:	8b 40 14             	mov    0x14(%eax),%eax
   1111a:	39 c2                	cmp    %eax,%edx
   1111c:	75 31                	jne    1114f <getPixelColorRGBA8+0x254>
   1111e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11121:	0f b6 00             	movzbl (%eax),%eax
   11124:	0f b6 d0             	movzbl %al,%edx
   11127:	8b 45 20             	mov    0x20(%ebp),%eax
   1112a:	8b 40 18             	mov    0x18(%eax),%eax
   1112d:	39 c2                	cmp    %eax,%edx
   1112f:	75 1e                	jne    1114f <getPixelColorRGBA8+0x254>
   11131:	8b 45 10             	mov    0x10(%ebp),%eax
   11134:	0f b6 00             	movzbl (%eax),%eax
   11137:	0f b6 d0             	movzbl %al,%edx
   1113a:	8b 45 20             	mov    0x20(%ebp),%eax
   1113d:	8b 40 1c             	mov    0x1c(%eax),%eax
   11140:	39 c2                	cmp    %eax,%edx
   11142:	75 0b                	jne    1114f <getPixelColorRGBA8+0x254>
   11144:	8b 45 14             	mov    0x14(%ebp),%eax
   11147:	c6 00 00             	movb   $0x0,(%eax)
   1114a:	e9 76 03 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
   1114f:	8b 45 14             	mov    0x14(%ebp),%eax
   11152:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   11155:	e9 6b 03 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
   1115a:	8b 55 1c             	mov    0x1c(%ebp),%edx
   1115d:	89 d0                	mov    %edx,%eax
   1115f:	01 c0                	add    %eax,%eax
   11161:	01 d0                	add    %edx,%eax
   11163:	01 c0                	add    %eax,%eax
   11165:	89 c2                	mov    %eax,%edx
   11167:	8b 45 18             	mov    0x18(%ebp),%eax
   1116a:	01 d0                	add    %edx,%eax
   1116c:	0f b6 10             	movzbl (%eax),%edx
   1116f:	8b 45 08             	mov    0x8(%ebp),%eax
   11172:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
   11174:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11177:	89 d0                	mov    %edx,%eax
   11179:	01 c0                	add    %eax,%eax
   1117b:	01 d0                	add    %edx,%eax
   1117d:	01 c0                	add    %eax,%eax
   1117f:	8d 50 02             	lea    0x2(%eax),%edx
   11182:	8b 45 18             	mov    0x18(%ebp),%eax
   11185:	01 d0                	add    %edx,%eax
   11187:	0f b6 10             	movzbl (%eax),%edx
   1118a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1118d:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
   1118f:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11192:	89 d0                	mov    %edx,%eax
   11194:	01 c0                	add    %eax,%eax
   11196:	01 d0                	add    %edx,%eax
   11198:	01 c0                	add    %eax,%eax
   1119a:	8d 50 04             	lea    0x4(%eax),%edx
   1119d:	8b 45 18             	mov    0x18(%ebp),%eax
   111a0:	01 d0                	add    %edx,%eax
   111a2:	0f b6 10             	movzbl (%eax),%edx
   111a5:	8b 45 10             	mov    0x10(%ebp),%eax
   111a8:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
   111aa:	8b 45 20             	mov    0x20(%ebp),%eax
   111ad:	8b 40 10             	mov    0x10(%eax),%eax
   111b0:	85 c0                	test   %eax,%eax
   111b2:	0f 84 da 00 00 00    	je     11292 <getPixelColorRGBA8+0x397>
   111b8:	8b 55 1c             	mov    0x1c(%ebp),%edx
   111bb:	89 d0                	mov    %edx,%eax
   111bd:	01 c0                	add    %eax,%eax
   111bf:	01 d0                	add    %edx,%eax
   111c1:	01 c0                	add    %eax,%eax
   111c3:	89 c2                	mov    %eax,%edx
   111c5:	8b 45 18             	mov    0x18(%ebp),%eax
   111c8:	01 d0                	add    %edx,%eax
   111ca:	0f b6 00             	movzbl (%eax),%eax
   111cd:	0f b6 c0             	movzbl %al,%eax
   111d0:	c1 e0 08             	shl    $0x8,%eax
   111d3:	89 c1                	mov    %eax,%ecx
   111d5:	8b 55 1c             	mov    0x1c(%ebp),%edx
   111d8:	89 d0                	mov    %edx,%eax
   111da:	01 c0                	add    %eax,%eax
   111dc:	01 d0                	add    %edx,%eax
   111de:	01 c0                	add    %eax,%eax
   111e0:	8d 50 01             	lea    0x1(%eax),%edx
   111e3:	8b 45 18             	mov    0x18(%ebp),%eax
   111e6:	01 d0                	add    %edx,%eax
   111e8:	0f b6 00             	movzbl (%eax),%eax
   111eb:	0f b6 c0             	movzbl %al,%eax
   111ee:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   111f1:	8b 45 20             	mov    0x20(%ebp),%eax
   111f4:	8b 40 14             	mov    0x14(%eax),%eax
   111f7:	39 c2                	cmp    %eax,%edx
   111f9:	0f 85 93 00 00 00    	jne    11292 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
   111ff:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11202:	89 d0                	mov    %edx,%eax
   11204:	01 c0                	add    %eax,%eax
   11206:	01 d0                	add    %edx,%eax
   11208:	01 c0                	add    %eax,%eax
   1120a:	8d 50 02             	lea    0x2(%eax),%edx
   1120d:	8b 45 18             	mov    0x18(%ebp),%eax
   11210:	01 d0                	add    %edx,%eax
   11212:	0f b6 00             	movzbl (%eax),%eax
   11215:	0f b6 c0             	movzbl %al,%eax
   11218:	c1 e0 08             	shl    $0x8,%eax
   1121b:	89 c1                	mov    %eax,%ecx
   1121d:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11220:	89 d0                	mov    %edx,%eax
   11222:	01 c0                	add    %eax,%eax
   11224:	01 d0                	add    %edx,%eax
   11226:	01 c0                	add    %eax,%eax
   11228:	8d 50 03             	lea    0x3(%eax),%edx
   1122b:	8b 45 18             	mov    0x18(%ebp),%eax
   1122e:	01 d0                	add    %edx,%eax
   11230:	0f b6 00             	movzbl (%eax),%eax
   11233:	0f b6 c0             	movzbl %al,%eax
   11236:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   11239:	8b 45 20             	mov    0x20(%ebp),%eax
   1123c:	8b 40 18             	mov    0x18(%eax),%eax
   1123f:	39 c2                	cmp    %eax,%edx
   11241:	75 4f                	jne    11292 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
   11243:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11246:	89 d0                	mov    %edx,%eax
   11248:	01 c0                	add    %eax,%eax
   1124a:	01 d0                	add    %edx,%eax
   1124c:	01 c0                	add    %eax,%eax
   1124e:	8d 50 04             	lea    0x4(%eax),%edx
   11251:	8b 45 18             	mov    0x18(%ebp),%eax
   11254:	01 d0                	add    %edx,%eax
   11256:	0f b6 00             	movzbl (%eax),%eax
   11259:	0f b6 c0             	movzbl %al,%eax
   1125c:	c1 e0 08             	shl    $0x8,%eax
   1125f:	89 c1                	mov    %eax,%ecx
   11261:	8b 55 1c             	mov    0x1c(%ebp),%edx
   11264:	89 d0                	mov    %edx,%eax
   11266:	01 c0                	add    %eax,%eax
   11268:	01 d0                	add    %edx,%eax
   1126a:	01 c0                	add    %eax,%eax
   1126c:	8d 50 05             	lea    0x5(%eax),%edx
   1126f:	8b 45 18             	mov    0x18(%ebp),%eax
   11272:	01 d0                	add    %edx,%eax
   11274:	0f b6 00             	movzbl (%eax),%eax
   11277:	0f b6 c0             	movzbl %al,%eax
   1127a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1127d:	8b 45 20             	mov    0x20(%ebp),%eax
   11280:	8b 40 1c             	mov    0x1c(%eax),%eax
   11283:	39 c2                	cmp    %eax,%edx
   11285:	75 0b                	jne    11292 <getPixelColorRGBA8+0x397>
   11287:	8b 45 14             	mov    0x14(%ebp),%eax
   1128a:	c6 00 00             	movb   $0x0,(%eax)
   1128d:	e9 33 02 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
   11292:	8b 45 14             	mov    0x14(%ebp),%eax
   11295:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   11298:	e9 28 02 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
   1129d:	8b 45 20             	mov    0x20(%ebp),%eax
   112a0:	8b 00                	mov    (%eax),%eax
   112a2:	83 f8 03             	cmp    $0x3,%eax
   112a5:	0f 85 ac 00 00 00    	jne    11357 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
   112ab:	8b 45 20             	mov    0x20(%ebp),%eax
   112ae:	8b 40 04             	mov    0x4(%eax),%eax
   112b1:	83 f8 08             	cmp    $0x8,%eax
   112b4:	75 13                	jne    112c9 <getPixelColorRGBA8+0x3ce>
   112b6:	8b 55 1c             	mov    0x1c(%ebp),%edx
   112b9:	8b 45 18             	mov    0x18(%ebp),%eax
   112bc:	01 d0                	add    %edx,%eax
   112be:	0f b6 00             	movzbl (%eax),%eax
   112c1:	0f b6 c0             	movzbl %al,%eax
   112c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
   112c7:	eb 28                	jmp    112f1 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
   112c9:	8b 45 20             	mov    0x20(%ebp),%eax
   112cc:	8b 50 04             	mov    0x4(%eax),%edx
   112cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   112d2:	0f af c2             	imul   %edx,%eax
   112d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
   112d8:	8b 45 20             	mov    0x20(%ebp),%eax
   112db:	8b 40 04             	mov    0x4(%eax),%eax
   112de:	50                   	push   %eax
   112df:	ff 75 18             	pushl  0x18(%ebp)
   112e2:	8d 45 ec             	lea    -0x14(%ebp),%eax
   112e5:	50                   	push   %eax
   112e6:	e8 55 d8 ff ff       	call   eb40 <readBitsFromReversedStream>
   112eb:	83 c4 0c             	add    $0xc,%esp
   112ee:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
   112f1:	8b 45 20             	mov    0x20(%ebp),%eax
   112f4:	8b 40 08             	mov    0x8(%eax),%eax
   112f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
   112fa:	c1 e2 02             	shl    $0x2,%edx
   112fd:	01 d0                	add    %edx,%eax
   112ff:	0f b6 10             	movzbl (%eax),%edx
   11302:	8b 45 08             	mov    0x8(%ebp),%eax
   11305:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
   11307:	8b 45 20             	mov    0x20(%ebp),%eax
   1130a:	8b 40 08             	mov    0x8(%eax),%eax
   1130d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11310:	c1 e2 02             	shl    $0x2,%edx
   11313:	83 c2 01             	add    $0x1,%edx
   11316:	01 d0                	add    %edx,%eax
   11318:	0f b6 10             	movzbl (%eax),%edx
   1131b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1131e:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
   11320:	8b 45 20             	mov    0x20(%ebp),%eax
   11323:	8b 40 08             	mov    0x8(%eax),%eax
   11326:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11329:	c1 e2 02             	shl    $0x2,%edx
   1132c:	83 c2 02             	add    $0x2,%edx
   1132f:	01 d0                	add    %edx,%eax
   11331:	0f b6 10             	movzbl (%eax),%edx
   11334:	8b 45 10             	mov    0x10(%ebp),%eax
   11337:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
   11339:	8b 45 20             	mov    0x20(%ebp),%eax
   1133c:	8b 40 08             	mov    0x8(%eax),%eax
   1133f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11342:	c1 e2 02             	shl    $0x2,%edx
   11345:	83 c2 03             	add    $0x3,%edx
   11348:	01 d0                	add    %edx,%eax
   1134a:	0f b6 10             	movzbl (%eax),%edx
   1134d:	8b 45 14             	mov    0x14(%ebp),%eax
   11350:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   11352:	e9 6e 01 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
   11357:	8b 45 20             	mov    0x20(%ebp),%eax
   1135a:	8b 00                	mov    (%eax),%eax
   1135c:	83 f8 04             	cmp    $0x4,%eax
   1135f:	0f 85 95 00 00 00    	jne    113fa <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
   11365:	8b 45 20             	mov    0x20(%ebp),%eax
   11368:	8b 40 04             	mov    0x4(%eax),%eax
   1136b:	83 f8 08             	cmp    $0x8,%eax
   1136e:	75 44                	jne    113b4 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
   11370:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11373:	01 c0                	add    %eax,%eax
   11375:	89 c2                	mov    %eax,%edx
   11377:	8b 45 18             	mov    0x18(%ebp),%eax
   1137a:	01 d0                	add    %edx,%eax
   1137c:	0f b6 10             	movzbl (%eax),%edx
   1137f:	8b 45 10             	mov    0x10(%ebp),%eax
   11382:	88 10                	mov    %dl,(%eax)
   11384:	8b 45 10             	mov    0x10(%ebp),%eax
   11387:	0f b6 10             	movzbl (%eax),%edx
   1138a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1138d:	88 10                	mov    %dl,(%eax)
   1138f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11392:	0f b6 10             	movzbl (%eax),%edx
   11395:	8b 45 08             	mov    0x8(%ebp),%eax
   11398:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
   1139a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1139d:	01 c0                	add    %eax,%eax
   1139f:	8d 50 01             	lea    0x1(%eax),%edx
   113a2:	8b 45 18             	mov    0x18(%ebp),%eax
   113a5:	01 d0                	add    %edx,%eax
   113a7:	0f b6 10             	movzbl (%eax),%edx
   113aa:	8b 45 14             	mov    0x14(%ebp),%eax
   113ad:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   113af:	e9 11 01 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
   113b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   113b7:	c1 e0 02             	shl    $0x2,%eax
   113ba:	89 c2                	mov    %eax,%edx
   113bc:	8b 45 18             	mov    0x18(%ebp),%eax
   113bf:	01 d0                	add    %edx,%eax
   113c1:	0f b6 10             	movzbl (%eax),%edx
   113c4:	8b 45 10             	mov    0x10(%ebp),%eax
   113c7:	88 10                	mov    %dl,(%eax)
   113c9:	8b 45 10             	mov    0x10(%ebp),%eax
   113cc:	0f b6 10             	movzbl (%eax),%edx
   113cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   113d2:	88 10                	mov    %dl,(%eax)
   113d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   113d7:	0f b6 10             	movzbl (%eax),%edx
   113da:	8b 45 08             	mov    0x8(%ebp),%eax
   113dd:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
   113df:	8b 45 1c             	mov    0x1c(%ebp),%eax
   113e2:	c1 e0 02             	shl    $0x2,%eax
   113e5:	8d 50 02             	lea    0x2(%eax),%edx
   113e8:	8b 45 18             	mov    0x18(%ebp),%eax
   113eb:	01 d0                	add    %edx,%eax
   113ed:	0f b6 10             	movzbl (%eax),%edx
   113f0:	8b 45 14             	mov    0x14(%ebp),%eax
   113f3:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   113f5:	e9 cb 00 00 00       	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
   113fa:	8b 45 20             	mov    0x20(%ebp),%eax
   113fd:	8b 00                	mov    (%eax),%eax
   113ff:	83 f8 06             	cmp    $0x6,%eax
   11402:	0f 85 bd 00 00 00    	jne    114c5 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
   11408:	8b 45 20             	mov    0x20(%ebp),%eax
   1140b:	8b 40 04             	mov    0x4(%eax),%eax
   1140e:	83 f8 08             	cmp    $0x8,%eax
   11411:	75 59                	jne    1146c <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
   11413:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11416:	c1 e0 02             	shl    $0x2,%eax
   11419:	89 c2                	mov    %eax,%edx
   1141b:	8b 45 18             	mov    0x18(%ebp),%eax
   1141e:	01 d0                	add    %edx,%eax
   11420:	0f b6 10             	movzbl (%eax),%edx
   11423:	8b 45 08             	mov    0x8(%ebp),%eax
   11426:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
   11428:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1142b:	c1 e0 02             	shl    $0x2,%eax
   1142e:	8d 50 01             	lea    0x1(%eax),%edx
   11431:	8b 45 18             	mov    0x18(%ebp),%eax
   11434:	01 d0                	add    %edx,%eax
   11436:	0f b6 10             	movzbl (%eax),%edx
   11439:	8b 45 0c             	mov    0xc(%ebp),%eax
   1143c:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
   1143e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11441:	c1 e0 02             	shl    $0x2,%eax
   11444:	8d 50 02             	lea    0x2(%eax),%edx
   11447:	8b 45 18             	mov    0x18(%ebp),%eax
   1144a:	01 d0                	add    %edx,%eax
   1144c:	0f b6 10             	movzbl (%eax),%edx
   1144f:	8b 45 10             	mov    0x10(%ebp),%eax
   11452:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
   11454:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11457:	c1 e0 02             	shl    $0x2,%eax
   1145a:	8d 50 03             	lea    0x3(%eax),%edx
   1145d:	8b 45 18             	mov    0x18(%ebp),%eax
   11460:	01 d0                	add    %edx,%eax
   11462:	0f b6 10             	movzbl (%eax),%edx
   11465:	8b 45 14             	mov    0x14(%ebp),%eax
   11468:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
   1146a:	eb 59                	jmp    114c5 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
   1146c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1146f:	c1 e0 03             	shl    $0x3,%eax
   11472:	89 c2                	mov    %eax,%edx
   11474:	8b 45 18             	mov    0x18(%ebp),%eax
   11477:	01 d0                	add    %edx,%eax
   11479:	0f b6 10             	movzbl (%eax),%edx
   1147c:	8b 45 08             	mov    0x8(%ebp),%eax
   1147f:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
   11481:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11484:	c1 e0 03             	shl    $0x3,%eax
   11487:	8d 50 02             	lea    0x2(%eax),%edx
   1148a:	8b 45 18             	mov    0x18(%ebp),%eax
   1148d:	01 d0                	add    %edx,%eax
   1148f:	0f b6 10             	movzbl (%eax),%edx
   11492:	8b 45 0c             	mov    0xc(%ebp),%eax
   11495:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
   11497:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1149a:	c1 e0 03             	shl    $0x3,%eax
   1149d:	8d 50 04             	lea    0x4(%eax),%edx
   114a0:	8b 45 18             	mov    0x18(%ebp),%eax
   114a3:	01 d0                	add    %edx,%eax
   114a5:	0f b6 10             	movzbl (%eax),%edx
   114a8:	8b 45 10             	mov    0x10(%ebp),%eax
   114ab:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
   114ad:	8b 45 1c             	mov    0x1c(%ebp),%eax
   114b0:	c1 e0 03             	shl    $0x3,%eax
   114b3:	8d 50 06             	lea    0x6(%eax),%edx
   114b6:	8b 45 18             	mov    0x18(%ebp),%eax
   114b9:	01 d0                	add    %edx,%eax
   114bb:	0f b6 10             	movzbl (%eax),%edx
   114be:	8b 45 14             	mov    0x14(%ebp),%eax
   114c1:	88 10                	mov    %dl,(%eax)
    }
  }
}
   114c3:	eb 00                	jmp    114c5 <getPixelColorRGBA8+0x5ca>
   114c5:	90                   	nop
   114c6:	c9                   	leave  
   114c7:	c3                   	ret    

000114c8 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
   114c8:	55                   	push   %ebp
   114c9:	89 e5                	mov    %esp,%ebp
   114cb:	53                   	push   %ebx
   114cc:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
   114cf:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
   114d6:	8b 45 14             	mov    0x14(%ebp),%eax
   114d9:	8b 00                	mov    (%eax),%eax
   114db:	85 c0                	test   %eax,%eax
   114dd:	0f 85 14 02 00 00    	jne    116f7 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
   114e3:	8b 45 14             	mov    0x14(%ebp),%eax
   114e6:	8b 40 04             	mov    0x4(%eax),%eax
   114e9:	83 f8 08             	cmp    $0x8,%eax
   114ec:	0f 85 a0 00 00 00    	jne    11592 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   114f2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   114f9:	eb 39                	jmp    11534 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
   114fb:	8b 45 08             	mov    0x8(%ebp),%eax
   114fe:	83 c0 01             	add    $0x1,%eax
   11501:	8b 55 08             	mov    0x8(%ebp),%edx
   11504:	83 c2 02             	add    $0x2,%edx
   11507:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   1150a:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1150d:	01 d9                	add    %ebx,%ecx
   1150f:	0f b6 09             	movzbl (%ecx),%ecx
   11512:	88 0a                	mov    %cl,(%edx)
   11514:	0f b6 12             	movzbl (%edx),%edx
   11517:	88 10                	mov    %dl,(%eax)
   11519:	0f b6 10             	movzbl (%eax),%edx
   1151c:	8b 45 08             	mov    0x8(%ebp),%eax
   1151f:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
   11521:	8b 45 08             	mov    0x8(%ebp),%eax
   11524:	83 c0 03             	add    $0x3,%eax
   11527:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   1152a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1152e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11531:	01 45 08             	add    %eax,0x8(%ebp)
   11534:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11537:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1153a:	75 bf                	jne    114fb <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
   1153c:	8b 45 14             	mov    0x14(%ebp),%eax
   1153f:	8b 40 10             	mov    0x10(%eax),%eax
   11542:	85 c0                	test   %eax,%eax
   11544:	0f 84 48 06 00 00    	je     11b92 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
   1154a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1154d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11551:	f7 d8                	neg    %eax
   11553:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11556:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1155d:	eb 26                	jmp    11585 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
   1155f:	8b 45 08             	mov    0x8(%ebp),%eax
   11562:	0f b6 00             	movzbl (%eax),%eax
   11565:	0f b6 d0             	movzbl %al,%edx
   11568:	8b 45 14             	mov    0x14(%ebp),%eax
   1156b:	8b 40 14             	mov    0x14(%eax),%eax
   1156e:	39 c2                	cmp    %eax,%edx
   11570:	75 09                	jne    1157b <getPixelColorsRGBA8+0xb3>
   11572:	8b 45 08             	mov    0x8(%ebp),%eax
   11575:	83 c0 03             	add    $0x3,%eax
   11578:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   1157b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1157f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11582:	01 45 08             	add    %eax,0x8(%ebp)
   11585:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11588:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1158b:	75 d2                	jne    1155f <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   1158d:	e9 00 06 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
   11592:	8b 45 14             	mov    0x14(%ebp),%eax
   11595:	8b 40 04             	mov    0x4(%eax),%eax
   11598:	83 f8 10             	cmp    $0x10,%eax
   1159b:	0f 85 a5 00 00 00    	jne    11646 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   115a1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   115a8:	e9 88 00 00 00       	jmp    11635 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
   115ad:	8b 45 08             	mov    0x8(%ebp),%eax
   115b0:	83 c0 01             	add    $0x1,%eax
   115b3:	8b 55 08             	mov    0x8(%ebp),%edx
   115b6:	83 c2 02             	add    $0x2,%edx
   115b9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   115bc:	01 c9                	add    %ecx,%ecx
   115be:	89 cb                	mov    %ecx,%ebx
   115c0:	8b 4d 10             	mov    0x10(%ebp),%ecx
   115c3:	01 d9                	add    %ebx,%ecx
   115c5:	0f b6 09             	movzbl (%ecx),%ecx
   115c8:	88 0a                	mov    %cl,(%edx)
   115ca:	0f b6 12             	movzbl (%edx),%edx
   115cd:	88 10                	mov    %dl,(%eax)
   115cf:	0f b6 10             	movzbl (%eax),%edx
   115d2:	8b 45 08             	mov    0x8(%ebp),%eax
   115d5:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
   115d7:	8b 45 08             	mov    0x8(%ebp),%eax
   115da:	8d 50 03             	lea    0x3(%eax),%edx
   115dd:	8b 45 14             	mov    0x14(%ebp),%eax
   115e0:	8b 40 10             	mov    0x10(%eax),%eax
   115e3:	85 c0                	test   %eax,%eax
   115e5:	74 3d                	je     11624 <getPixelColorsRGBA8+0x15c>
   115e7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   115ea:	01 c0                	add    %eax,%eax
   115ec:	89 c1                	mov    %eax,%ecx
   115ee:	8b 45 10             	mov    0x10(%ebp),%eax
   115f1:	01 c8                	add    %ecx,%eax
   115f3:	0f b6 00             	movzbl (%eax),%eax
   115f6:	0f b6 c0             	movzbl %al,%eax
   115f9:	c1 e0 08             	shl    $0x8,%eax
   115fc:	89 c1                	mov    %eax,%ecx
   115fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11601:	01 c0                	add    %eax,%eax
   11603:	8d 58 01             	lea    0x1(%eax),%ebx
   11606:	8b 45 10             	mov    0x10(%ebp),%eax
   11609:	01 d8                	add    %ebx,%eax
   1160b:	0f b6 00             	movzbl (%eax),%eax
   1160e:	0f b6 c0             	movzbl %al,%eax
   11611:	01 c1                	add    %eax,%ecx
   11613:	8b 45 14             	mov    0x14(%ebp),%eax
   11616:	8b 40 14             	mov    0x14(%eax),%eax
   11619:	39 c1                	cmp    %eax,%ecx
   1161b:	75 07                	jne    11624 <getPixelColorsRGBA8+0x15c>
   1161d:	b8 00 00 00 00       	mov    $0x0,%eax
   11622:	eb 05                	jmp    11629 <getPixelColorsRGBA8+0x161>
   11624:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11629:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   1162b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1162f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11632:	01 45 08             	add    %eax,0x8(%ebp)
   11635:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11638:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1163b:	0f 85 6c ff ff ff    	jne    115ad <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   11641:	e9 4c 05 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
   11646:	8b 45 14             	mov    0x14(%ebp),%eax
   11649:	8b 40 04             	mov    0x4(%eax),%eax
   1164c:	ba 01 00 00 00       	mov    $0x1,%edx
   11651:	89 c1                	mov    %eax,%ecx
   11653:	d3 e2                	shl    %cl,%edx
   11655:	89 d0                	mov    %edx,%eax
   11657:	83 e8 01             	sub    $0x1,%eax
   1165a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
   1165d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11664:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1166b:	eb 79                	jmp    116e6 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
   1166d:	8b 45 14             	mov    0x14(%ebp),%eax
   11670:	8b 40 04             	mov    0x4(%eax),%eax
   11673:	50                   	push   %eax
   11674:	ff 75 10             	pushl  0x10(%ebp)
   11677:	8d 45 e0             	lea    -0x20(%ebp),%eax
   1167a:	50                   	push   %eax
   1167b:	e8 c0 d4 ff ff       	call   eb40 <readBitsFromReversedStream>
   11680:	83 c4 0c             	add    $0xc,%esp
   11683:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
   11686:	8b 45 08             	mov    0x8(%ebp),%eax
   11689:	8d 48 01             	lea    0x1(%eax),%ecx
   1168c:	8b 45 08             	mov    0x8(%ebp),%eax
   1168f:	8d 58 02             	lea    0x2(%eax),%ebx
   11692:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11695:	89 d0                	mov    %edx,%eax
   11697:	c1 e0 08             	shl    $0x8,%eax
   1169a:	29 d0                	sub    %edx,%eax
   1169c:	ba 00 00 00 00       	mov    $0x0,%edx
   116a1:	f7 75 f0             	divl   -0x10(%ebp)
   116a4:	88 03                	mov    %al,(%ebx)
   116a6:	0f b6 03             	movzbl (%ebx),%eax
   116a9:	88 01                	mov    %al,(%ecx)
   116ab:	0f b6 11             	movzbl (%ecx),%edx
   116ae:	8b 45 08             	mov    0x8(%ebp),%eax
   116b1:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
   116b3:	8b 45 08             	mov    0x8(%ebp),%eax
   116b6:	8d 50 03             	lea    0x3(%eax),%edx
   116b9:	8b 45 14             	mov    0x14(%ebp),%eax
   116bc:	8b 40 10             	mov    0x10(%eax),%eax
   116bf:	85 c0                	test   %eax,%eax
   116c1:	74 12                	je     116d5 <getPixelColorsRGBA8+0x20d>
   116c3:	8b 45 14             	mov    0x14(%ebp),%eax
   116c6:	8b 40 14             	mov    0x14(%eax),%eax
   116c9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   116cc:	75 07                	jne    116d5 <getPixelColorsRGBA8+0x20d>
   116ce:	b8 00 00 00 00       	mov    $0x0,%eax
   116d3:	eb 05                	jmp    116da <getPixelColorsRGBA8+0x212>
   116d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   116da:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   116dc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   116e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116e3:	01 45 08             	add    %eax,0x8(%ebp)
   116e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   116e9:	3b 45 0c             	cmp    0xc(%ebp),%eax
   116ec:	0f 85 7b ff ff ff    	jne    1166d <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   116f2:	e9 9b 04 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
   116f7:	8b 45 14             	mov    0x14(%ebp),%eax
   116fa:	8b 00                	mov    (%eax),%eax
   116fc:	83 f8 02             	cmp    $0x2,%eax
   116ff:	0f 85 41 02 00 00    	jne    11946 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
   11705:	8b 45 14             	mov    0x14(%ebp),%eax
   11708:	8b 40 04             	mov    0x4(%eax),%eax
   1170b:	83 f8 08             	cmp    $0x8,%eax
   1170e:	0f 85 c4 00 00 00    	jne    117d8 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11714:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1171b:	eb 31                	jmp    1174e <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
   1171d:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11720:	89 d0                	mov    %edx,%eax
   11722:	01 c0                	add    %eax,%eax
   11724:	01 d0                	add    %edx,%eax
   11726:	89 c2                	mov    %eax,%edx
   11728:	8b 45 10             	mov    0x10(%ebp),%eax
   1172b:	01 d0                	add    %edx,%eax
   1172d:	6a 03                	push   $0x3
   1172f:	50                   	push   %eax
   11730:	ff 75 08             	pushl  0x8(%ebp)
   11733:	e8 a3 85 ff ff       	call   9cdb <lodepng_memcpy>
   11738:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
   1173b:	8b 45 08             	mov    0x8(%ebp),%eax
   1173e:	83 c0 03             	add    $0x3,%eax
   11741:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11744:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11748:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1174b:	01 45 08             	add    %eax,0x8(%ebp)
   1174e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11751:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11754:	75 c7                	jne    1171d <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
   11756:	8b 45 14             	mov    0x14(%ebp),%eax
   11759:	8b 40 10             	mov    0x10(%eax),%eax
   1175c:	85 c0                	test   %eax,%eax
   1175e:	0f 84 2e 04 00 00    	je     11b92 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
   11764:	8b 45 0c             	mov    0xc(%ebp),%eax
   11767:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1176b:	f7 d8                	neg    %eax
   1176d:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11770:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11777:	eb 52                	jmp    117cb <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
   11779:	8b 45 08             	mov    0x8(%ebp),%eax
   1177c:	0f b6 00             	movzbl (%eax),%eax
   1177f:	0f b6 d0             	movzbl %al,%edx
   11782:	8b 45 14             	mov    0x14(%ebp),%eax
   11785:	8b 40 14             	mov    0x14(%eax),%eax
   11788:	39 c2                	cmp    %eax,%edx
   1178a:	75 35                	jne    117c1 <getPixelColorsRGBA8+0x2f9>
   1178c:	8b 45 08             	mov    0x8(%ebp),%eax
   1178f:	83 c0 01             	add    $0x1,%eax
   11792:	0f b6 00             	movzbl (%eax),%eax
   11795:	0f b6 d0             	movzbl %al,%edx
   11798:	8b 45 14             	mov    0x14(%ebp),%eax
   1179b:	8b 40 18             	mov    0x18(%eax),%eax
   1179e:	39 c2                	cmp    %eax,%edx
   117a0:	75 1f                	jne    117c1 <getPixelColorsRGBA8+0x2f9>
   117a2:	8b 45 08             	mov    0x8(%ebp),%eax
   117a5:	83 c0 02             	add    $0x2,%eax
   117a8:	0f b6 00             	movzbl (%eax),%eax
   117ab:	0f b6 d0             	movzbl %al,%edx
   117ae:	8b 45 14             	mov    0x14(%ebp),%eax
   117b1:	8b 40 1c             	mov    0x1c(%eax),%eax
   117b4:	39 c2                	cmp    %eax,%edx
   117b6:	75 09                	jne    117c1 <getPixelColorsRGBA8+0x2f9>
   117b8:	8b 45 08             	mov    0x8(%ebp),%eax
   117bb:	83 c0 03             	add    $0x3,%eax
   117be:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   117c1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   117c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117c8:	01 45 08             	add    %eax,0x8(%ebp)
   117cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   117ce:	3b 45 0c             	cmp    0xc(%ebp),%eax
   117d1:	75 a6                	jne    11779 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   117d3:	e9 ba 03 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   117d8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   117df:	e9 51 01 00 00       	jmp    11935 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
   117e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
   117e7:	89 d0                	mov    %edx,%eax
   117e9:	01 c0                	add    %eax,%eax
   117eb:	01 d0                	add    %edx,%eax
   117ed:	01 c0                	add    %eax,%eax
   117ef:	89 c2                	mov    %eax,%edx
   117f1:	8b 45 10             	mov    0x10(%ebp),%eax
   117f4:	01 d0                	add    %edx,%eax
   117f6:	0f b6 10             	movzbl (%eax),%edx
   117f9:	8b 45 08             	mov    0x8(%ebp),%eax
   117fc:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
   117fe:	8b 45 08             	mov    0x8(%ebp),%eax
   11801:	8d 48 01             	lea    0x1(%eax),%ecx
   11804:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11807:	89 d0                	mov    %edx,%eax
   11809:	01 c0                	add    %eax,%eax
   1180b:	01 d0                	add    %edx,%eax
   1180d:	01 c0                	add    %eax,%eax
   1180f:	8d 50 02             	lea    0x2(%eax),%edx
   11812:	8b 45 10             	mov    0x10(%ebp),%eax
   11815:	01 d0                	add    %edx,%eax
   11817:	0f b6 00             	movzbl (%eax),%eax
   1181a:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
   1181c:	8b 45 08             	mov    0x8(%ebp),%eax
   1181f:	8d 48 02             	lea    0x2(%eax),%ecx
   11822:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11825:	89 d0                	mov    %edx,%eax
   11827:	01 c0                	add    %eax,%eax
   11829:	01 d0                	add    %edx,%eax
   1182b:	01 c0                	add    %eax,%eax
   1182d:	8d 50 04             	lea    0x4(%eax),%edx
   11830:	8b 45 10             	mov    0x10(%ebp),%eax
   11833:	01 d0                	add    %edx,%eax
   11835:	0f b6 00             	movzbl (%eax),%eax
   11838:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
   1183a:	8b 45 08             	mov    0x8(%ebp),%eax
   1183d:	8d 48 03             	lea    0x3(%eax),%ecx
   11840:	8b 45 14             	mov    0x14(%ebp),%eax
   11843:	8b 40 10             	mov    0x10(%eax),%eax
   11846:	85 c0                	test   %eax,%eax
   11848:	0f 84 d6 00 00 00    	je     11924 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
   1184e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11851:	89 d0                	mov    %edx,%eax
   11853:	01 c0                	add    %eax,%eax
   11855:	01 d0                	add    %edx,%eax
   11857:	01 c0                	add    %eax,%eax
   11859:	89 c2                	mov    %eax,%edx
   1185b:	8b 45 10             	mov    0x10(%ebp),%eax
   1185e:	01 d0                	add    %edx,%eax
   11860:	0f b6 00             	movzbl (%eax),%eax
   11863:	0f b6 c0             	movzbl %al,%eax
   11866:	c1 e0 08             	shl    $0x8,%eax
   11869:	89 c3                	mov    %eax,%ebx
   1186b:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1186e:	89 d0                	mov    %edx,%eax
   11870:	01 c0                	add    %eax,%eax
   11872:	01 d0                	add    %edx,%eax
   11874:	01 c0                	add    %eax,%eax
   11876:	8d 50 01             	lea    0x1(%eax),%edx
   11879:	8b 45 10             	mov    0x10(%ebp),%eax
   1187c:	01 d0                	add    %edx,%eax
   1187e:	0f b6 00             	movzbl (%eax),%eax
   11881:	0f b6 c0             	movzbl %al,%eax
   11884:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   11887:	8b 45 14             	mov    0x14(%ebp),%eax
   1188a:	8b 40 14             	mov    0x14(%eax),%eax
   1188d:	39 c2                	cmp    %eax,%edx
   1188f:	0f 85 8f 00 00 00    	jne    11924 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
   11895:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11898:	89 d0                	mov    %edx,%eax
   1189a:	01 c0                	add    %eax,%eax
   1189c:	01 d0                	add    %edx,%eax
   1189e:	01 c0                	add    %eax,%eax
   118a0:	8d 50 02             	lea    0x2(%eax),%edx
   118a3:	8b 45 10             	mov    0x10(%ebp),%eax
   118a6:	01 d0                	add    %edx,%eax
   118a8:	0f b6 00             	movzbl (%eax),%eax
   118ab:	0f b6 c0             	movzbl %al,%eax
   118ae:	c1 e0 08             	shl    $0x8,%eax
   118b1:	89 c3                	mov    %eax,%ebx
   118b3:	8b 55 f8             	mov    -0x8(%ebp),%edx
   118b6:	89 d0                	mov    %edx,%eax
   118b8:	01 c0                	add    %eax,%eax
   118ba:	01 d0                	add    %edx,%eax
   118bc:	01 c0                	add    %eax,%eax
   118be:	8d 50 03             	lea    0x3(%eax),%edx
   118c1:	8b 45 10             	mov    0x10(%ebp),%eax
   118c4:	01 d0                	add    %edx,%eax
   118c6:	0f b6 00             	movzbl (%eax),%eax
   118c9:	0f b6 c0             	movzbl %al,%eax
   118cc:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   118cf:	8b 45 14             	mov    0x14(%ebp),%eax
   118d2:	8b 40 18             	mov    0x18(%eax),%eax
   118d5:	39 c2                	cmp    %eax,%edx
   118d7:	75 4b                	jne    11924 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
   118d9:	8b 55 f8             	mov    -0x8(%ebp),%edx
   118dc:	89 d0                	mov    %edx,%eax
   118de:	01 c0                	add    %eax,%eax
   118e0:	01 d0                	add    %edx,%eax
   118e2:	01 c0                	add    %eax,%eax
   118e4:	8d 50 04             	lea    0x4(%eax),%edx
   118e7:	8b 45 10             	mov    0x10(%ebp),%eax
   118ea:	01 d0                	add    %edx,%eax
   118ec:	0f b6 00             	movzbl (%eax),%eax
   118ef:	0f b6 c0             	movzbl %al,%eax
   118f2:	c1 e0 08             	shl    $0x8,%eax
   118f5:	89 c3                	mov    %eax,%ebx
   118f7:	8b 55 f8             	mov    -0x8(%ebp),%edx
   118fa:	89 d0                	mov    %edx,%eax
   118fc:	01 c0                	add    %eax,%eax
   118fe:	01 d0                	add    %edx,%eax
   11900:	01 c0                	add    %eax,%eax
   11902:	8d 50 05             	lea    0x5(%eax),%edx
   11905:	8b 45 10             	mov    0x10(%ebp),%eax
   11908:	01 d0                	add    %edx,%eax
   1190a:	0f b6 00             	movzbl (%eax),%eax
   1190d:	0f b6 c0             	movzbl %al,%eax
   11910:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   11913:	8b 45 14             	mov    0x14(%ebp),%eax
   11916:	8b 40 1c             	mov    0x1c(%eax),%eax
   11919:	39 c2                	cmp    %eax,%edx
   1191b:	75 07                	jne    11924 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
   1191d:	b8 00 00 00 00       	mov    $0x0,%eax
   11922:	eb 05                	jmp    11929 <getPixelColorsRGBA8+0x461>
   11924:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11929:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   1192b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1192f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11932:	01 45 08             	add    %eax,0x8(%ebp)
   11935:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11938:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1193b:	0f 85 a3 fe ff ff    	jne    117e4 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   11941:	e9 4c 02 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
   11946:	8b 45 14             	mov    0x14(%ebp),%eax
   11949:	8b 00                	mov    (%eax),%eax
   1194b:	83 f8 03             	cmp    $0x3,%eax
   1194e:	0f 85 b4 00 00 00    	jne    11a08 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
   11954:	8b 45 14             	mov    0x14(%ebp),%eax
   11957:	8b 40 04             	mov    0x4(%eax),%eax
   1195a:	83 f8 08             	cmp    $0x8,%eax
   1195d:	75 4d                	jne    119ac <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   1195f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11966:	eb 37                	jmp    1199f <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
   11968:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1196b:	8b 45 10             	mov    0x10(%ebp),%eax
   1196e:	01 d0                	add    %edx,%eax
   11970:	0f b6 00             	movzbl (%eax),%eax
   11973:	0f b6 c0             	movzbl %al,%eax
   11976:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
   11979:	8b 45 14             	mov    0x14(%ebp),%eax
   1197c:	8b 40 08             	mov    0x8(%eax),%eax
   1197f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11982:	c1 e2 02             	shl    $0x2,%edx
   11985:	01 d0                	add    %edx,%eax
   11987:	6a 04                	push   $0x4
   11989:	50                   	push   %eax
   1198a:	ff 75 08             	pushl  0x8(%ebp)
   1198d:	e8 49 83 ff ff       	call   9cdb <lodepng_memcpy>
   11992:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11995:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11999:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1199c:	01 45 08             	add    %eax,0x8(%ebp)
   1199f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   119a2:	3b 45 0c             	cmp    0xc(%ebp),%eax
   119a5:	75 c1                	jne    11968 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   119a7:	e9 e6 01 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
   119ac:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   119b3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   119ba:	eb 3f                	jmp    119fb <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
   119bc:	8b 45 14             	mov    0x14(%ebp),%eax
   119bf:	8b 40 04             	mov    0x4(%eax),%eax
   119c2:	50                   	push   %eax
   119c3:	ff 75 10             	pushl  0x10(%ebp)
   119c6:	8d 45 dc             	lea    -0x24(%ebp),%eax
   119c9:	50                   	push   %eax
   119ca:	e8 71 d1 ff ff       	call   eb40 <readBitsFromReversedStream>
   119cf:	83 c4 0c             	add    $0xc,%esp
   119d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
   119d5:	8b 45 14             	mov    0x14(%ebp),%eax
   119d8:	8b 40 08             	mov    0x8(%eax),%eax
   119db:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   119de:	c1 e2 02             	shl    $0x2,%edx
   119e1:	01 d0                	add    %edx,%eax
   119e3:	6a 04                	push   $0x4
   119e5:	50                   	push   %eax
   119e6:	ff 75 08             	pushl  0x8(%ebp)
   119e9:	e8 ed 82 ff ff       	call   9cdb <lodepng_memcpy>
   119ee:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   119f1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   119f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   119f8:	01 45 08             	add    %eax,0x8(%ebp)
   119fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   119fe:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11a01:	75 b9                	jne    119bc <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   11a03:	e9 8a 01 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
   11a08:	8b 45 14             	mov    0x14(%ebp),%eax
   11a0b:	8b 00                	mov    (%eax),%eax
   11a0d:	83 f8 04             	cmp    $0x4,%eax
   11a10:	0f 85 d1 00 00 00    	jne    11ae7 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
   11a16:	8b 45 14             	mov    0x14(%ebp),%eax
   11a19:	8b 40 04             	mov    0x4(%eax),%eax
   11a1c:	83 f8 08             	cmp    $0x8,%eax
   11a1f:	75 62                	jne    11a83 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11a21:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11a28:	eb 4c                	jmp    11a76 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
   11a2a:	8b 45 08             	mov    0x8(%ebp),%eax
   11a2d:	83 c0 01             	add    $0x1,%eax
   11a30:	8b 55 08             	mov    0x8(%ebp),%edx
   11a33:	83 c2 02             	add    $0x2,%edx
   11a36:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   11a39:	01 c9                	add    %ecx,%ecx
   11a3b:	89 cb                	mov    %ecx,%ebx
   11a3d:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11a40:	01 d9                	add    %ebx,%ecx
   11a42:	0f b6 09             	movzbl (%ecx),%ecx
   11a45:	88 0a                	mov    %cl,(%edx)
   11a47:	0f b6 12             	movzbl (%edx),%edx
   11a4a:	88 10                	mov    %dl,(%eax)
   11a4c:	0f b6 10             	movzbl (%eax),%edx
   11a4f:	8b 45 08             	mov    0x8(%ebp),%eax
   11a52:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
   11a54:	8b 45 08             	mov    0x8(%ebp),%eax
   11a57:	8d 50 03             	lea    0x3(%eax),%edx
   11a5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a5d:	01 c0                	add    %eax,%eax
   11a5f:	8d 48 01             	lea    0x1(%eax),%ecx
   11a62:	8b 45 10             	mov    0x10(%ebp),%eax
   11a65:	01 c8                	add    %ecx,%eax
   11a67:	0f b6 00             	movzbl (%eax),%eax
   11a6a:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11a6c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11a70:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a73:	01 45 08             	add    %eax,0x8(%ebp)
   11a76:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a79:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11a7c:	75 ac                	jne    11a2a <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   11a7e:	e9 0f 01 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11a83:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11a8a:	eb 4e                	jmp    11ada <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
   11a8c:	8b 45 08             	mov    0x8(%ebp),%eax
   11a8f:	83 c0 01             	add    $0x1,%eax
   11a92:	8b 55 08             	mov    0x8(%ebp),%edx
   11a95:	83 c2 02             	add    $0x2,%edx
   11a98:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   11a9b:	c1 e1 02             	shl    $0x2,%ecx
   11a9e:	89 cb                	mov    %ecx,%ebx
   11aa0:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11aa3:	01 d9                	add    %ebx,%ecx
   11aa5:	0f b6 09             	movzbl (%ecx),%ecx
   11aa8:	88 0a                	mov    %cl,(%edx)
   11aaa:	0f b6 12             	movzbl (%edx),%edx
   11aad:	88 10                	mov    %dl,(%eax)
   11aaf:	0f b6 10             	movzbl (%eax),%edx
   11ab2:	8b 45 08             	mov    0x8(%ebp),%eax
   11ab5:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
   11ab7:	8b 45 08             	mov    0x8(%ebp),%eax
   11aba:	8d 50 03             	lea    0x3(%eax),%edx
   11abd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11ac0:	c1 e0 02             	shl    $0x2,%eax
   11ac3:	8d 48 02             	lea    0x2(%eax),%ecx
   11ac6:	8b 45 10             	mov    0x10(%ebp),%eax
   11ac9:	01 c8                	add    %ecx,%eax
   11acb:	0f b6 00             	movzbl (%eax),%eax
   11ace:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11ad0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11ad4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ad7:	01 45 08             	add    %eax,0x8(%ebp)
   11ada:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11add:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11ae0:	75 aa                	jne    11a8c <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   11ae2:	e9 ab 00 00 00       	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
   11ae7:	8b 45 14             	mov    0x14(%ebp),%eax
   11aea:	8b 00                	mov    (%eax),%eax
   11aec:	83 f8 06             	cmp    $0x6,%eax
   11aef:	0f 85 9d 00 00 00    	jne    11b92 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
   11af5:	8b 45 14             	mov    0x14(%ebp),%eax
   11af8:	8b 40 04             	mov    0x4(%eax),%eax
   11afb:	83 f8 08             	cmp    $0x8,%eax
   11afe:	75 17                	jne    11b17 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
   11b00:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b03:	c1 e0 02             	shl    $0x2,%eax
   11b06:	50                   	push   %eax
   11b07:	ff 75 10             	pushl  0x10(%ebp)
   11b0a:	ff 75 08             	pushl  0x8(%ebp)
   11b0d:	e8 c9 81 ff ff       	call   9cdb <lodepng_memcpy>
   11b12:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   11b15:	eb 7b                	jmp    11b92 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11b17:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11b1e:	eb 6a                	jmp    11b8a <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
   11b20:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11b23:	c1 e0 03             	shl    $0x3,%eax
   11b26:	89 c2                	mov    %eax,%edx
   11b28:	8b 45 10             	mov    0x10(%ebp),%eax
   11b2b:	01 d0                	add    %edx,%eax
   11b2d:	0f b6 10             	movzbl (%eax),%edx
   11b30:	8b 45 08             	mov    0x8(%ebp),%eax
   11b33:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
   11b35:	8b 45 08             	mov    0x8(%ebp),%eax
   11b38:	8d 50 01             	lea    0x1(%eax),%edx
   11b3b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11b3e:	c1 e0 03             	shl    $0x3,%eax
   11b41:	8d 48 02             	lea    0x2(%eax),%ecx
   11b44:	8b 45 10             	mov    0x10(%ebp),%eax
   11b47:	01 c8                	add    %ecx,%eax
   11b49:	0f b6 00             	movzbl (%eax),%eax
   11b4c:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
   11b4e:	8b 45 08             	mov    0x8(%ebp),%eax
   11b51:	8d 50 02             	lea    0x2(%eax),%edx
   11b54:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11b57:	c1 e0 03             	shl    $0x3,%eax
   11b5a:	8d 48 04             	lea    0x4(%eax),%ecx
   11b5d:	8b 45 10             	mov    0x10(%ebp),%eax
   11b60:	01 c8                	add    %ecx,%eax
   11b62:	0f b6 00             	movzbl (%eax),%eax
   11b65:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
   11b67:	8b 45 08             	mov    0x8(%ebp),%eax
   11b6a:	8d 50 03             	lea    0x3(%eax),%edx
   11b6d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11b70:	c1 e0 03             	shl    $0x3,%eax
   11b73:	8d 48 06             	lea    0x6(%eax),%ecx
   11b76:	8b 45 10             	mov    0x10(%ebp),%eax
   11b79:	01 c8                	add    %ecx,%eax
   11b7b:	0f b6 00             	movzbl (%eax),%eax
   11b7e:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11b80:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11b84:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b87:	01 45 08             	add    %eax,0x8(%ebp)
   11b8a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11b8d:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11b90:	75 8e                	jne    11b20 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
   11b92:	90                   	nop
   11b93:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11b96:	c9                   	leave  
   11b97:	c3                   	ret    

00011b98 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
   11b98:	55                   	push   %ebp
   11b99:	89 e5                	mov    %esp,%ebp
   11b9b:	53                   	push   %ebx
   11b9c:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
   11b9f:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
   11ba6:	8b 45 14             	mov    0x14(%ebp),%eax
   11ba9:	8b 00                	mov    (%eax),%eax
   11bab:	85 c0                	test   %eax,%eax
   11bad:	0f 85 2a 01 00 00    	jne    11cdd <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
   11bb3:	8b 45 14             	mov    0x14(%ebp),%eax
   11bb6:	8b 40 04             	mov    0x4(%eax),%eax
   11bb9:	83 f8 08             	cmp    $0x8,%eax
   11bbc:	75 46                	jne    11c04 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11bbe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11bc5:	eb 30                	jmp    11bf7 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
   11bc7:	8b 45 08             	mov    0x8(%ebp),%eax
   11bca:	83 c0 01             	add    $0x1,%eax
   11bcd:	8b 55 08             	mov    0x8(%ebp),%edx
   11bd0:	83 c2 02             	add    $0x2,%edx
   11bd3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   11bd6:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11bd9:	01 d9                	add    %ebx,%ecx
   11bdb:	0f b6 09             	movzbl (%ecx),%ecx
   11bde:	88 0a                	mov    %cl,(%edx)
   11be0:	0f b6 12             	movzbl (%edx),%edx
   11be3:	88 10                	mov    %dl,(%eax)
   11be5:	0f b6 10             	movzbl (%eax),%edx
   11be8:	8b 45 08             	mov    0x8(%ebp),%eax
   11beb:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11bed:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11bf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11bf4:	01 45 08             	add    %eax,0x8(%ebp)
   11bf7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11bfa:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11bfd:	75 c8                	jne    11bc7 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11bff:	e9 a8 03 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
   11c04:	8b 45 14             	mov    0x14(%ebp),%eax
   11c07:	8b 40 04             	mov    0x4(%eax),%eax
   11c0a:	83 f8 10             	cmp    $0x10,%eax
   11c0d:	75 4a                	jne    11c59 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11c0f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11c16:	eb 34                	jmp    11c4c <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
   11c18:	8b 45 08             	mov    0x8(%ebp),%eax
   11c1b:	83 c0 01             	add    $0x1,%eax
   11c1e:	8b 55 08             	mov    0x8(%ebp),%edx
   11c21:	83 c2 02             	add    $0x2,%edx
   11c24:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   11c27:	01 c9                	add    %ecx,%ecx
   11c29:	89 cb                	mov    %ecx,%ebx
   11c2b:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11c2e:	01 d9                	add    %ebx,%ecx
   11c30:	0f b6 09             	movzbl (%ecx),%ecx
   11c33:	88 0a                	mov    %cl,(%edx)
   11c35:	0f b6 12             	movzbl (%edx),%edx
   11c38:	88 10                	mov    %dl,(%eax)
   11c3a:	0f b6 10             	movzbl (%eax),%edx
   11c3d:	8b 45 08             	mov    0x8(%ebp),%eax
   11c40:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11c42:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c49:	01 45 08             	add    %eax,0x8(%ebp)
   11c4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11c4f:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11c52:	75 c4                	jne    11c18 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11c54:	e9 53 03 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
   11c59:	8b 45 14             	mov    0x14(%ebp),%eax
   11c5c:	8b 40 04             	mov    0x4(%eax),%eax
   11c5f:	ba 01 00 00 00       	mov    $0x1,%edx
   11c64:	89 c1                	mov    %eax,%ecx
   11c66:	d3 e2                	shl    %cl,%edx
   11c68:	89 d0                	mov    %edx,%eax
   11c6a:	83 e8 01             	sub    $0x1,%eax
   11c6d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
   11c70:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11c77:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11c7e:	eb 50                	jmp    11cd0 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
   11c80:	8b 45 14             	mov    0x14(%ebp),%eax
   11c83:	8b 40 04             	mov    0x4(%eax),%eax
   11c86:	50                   	push   %eax
   11c87:	ff 75 10             	pushl  0x10(%ebp)
   11c8a:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11c8d:	50                   	push   %eax
   11c8e:	e8 ad ce ff ff       	call   eb40 <readBitsFromReversedStream>
   11c93:	83 c4 0c             	add    $0xc,%esp
   11c96:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
   11c99:	8b 45 08             	mov    0x8(%ebp),%eax
   11c9c:	8d 48 01             	lea    0x1(%eax),%ecx
   11c9f:	8b 45 08             	mov    0x8(%ebp),%eax
   11ca2:	8d 58 02             	lea    0x2(%eax),%ebx
   11ca5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11ca8:	89 d0                	mov    %edx,%eax
   11caa:	c1 e0 08             	shl    $0x8,%eax
   11cad:	29 d0                	sub    %edx,%eax
   11caf:	ba 00 00 00 00       	mov    $0x0,%edx
   11cb4:	f7 75 f0             	divl   -0x10(%ebp)
   11cb7:	88 03                	mov    %al,(%ebx)
   11cb9:	0f b6 03             	movzbl (%ebx),%eax
   11cbc:	88 01                	mov    %al,(%ecx)
   11cbe:	0f b6 11             	movzbl (%ecx),%edx
   11cc1:	8b 45 08             	mov    0x8(%ebp),%eax
   11cc4:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11cc6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11cca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ccd:	01 45 08             	add    %eax,0x8(%ebp)
   11cd0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11cd3:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11cd6:	75 a8                	jne    11c80 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11cd8:	e9 cf 02 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
   11cdd:	8b 45 14             	mov    0x14(%ebp),%eax
   11ce0:	8b 00                	mov    (%eax),%eax
   11ce2:	83 f8 02             	cmp    $0x2,%eax
   11ce5:	0f 85 9e 00 00 00    	jne    11d89 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
   11ceb:	8b 45 14             	mov    0x14(%ebp),%eax
   11cee:	8b 40 04             	mov    0x4(%eax),%eax
   11cf1:	83 f8 08             	cmp    $0x8,%eax
   11cf4:	75 1d                	jne    11d13 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
   11cf6:	8b 55 0c             	mov    0xc(%ebp),%edx
   11cf9:	89 d0                	mov    %edx,%eax
   11cfb:	01 c0                	add    %eax,%eax
   11cfd:	01 d0                	add    %edx,%eax
   11cff:	50                   	push   %eax
   11d00:	ff 75 10             	pushl  0x10(%ebp)
   11d03:	ff 75 08             	pushl  0x8(%ebp)
   11d06:	e8 d0 7f ff ff       	call   9cdb <lodepng_memcpy>
   11d0b:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11d0e:	e9 99 02 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11d13:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11d1a:	eb 60                	jmp    11d7c <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
   11d1c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11d1f:	89 d0                	mov    %edx,%eax
   11d21:	01 c0                	add    %eax,%eax
   11d23:	01 d0                	add    %edx,%eax
   11d25:	01 c0                	add    %eax,%eax
   11d27:	89 c2                	mov    %eax,%edx
   11d29:	8b 45 10             	mov    0x10(%ebp),%eax
   11d2c:	01 d0                	add    %edx,%eax
   11d2e:	0f b6 10             	movzbl (%eax),%edx
   11d31:	8b 45 08             	mov    0x8(%ebp),%eax
   11d34:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
   11d36:	8b 45 08             	mov    0x8(%ebp),%eax
   11d39:	8d 48 01             	lea    0x1(%eax),%ecx
   11d3c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11d3f:	89 d0                	mov    %edx,%eax
   11d41:	01 c0                	add    %eax,%eax
   11d43:	01 d0                	add    %edx,%eax
   11d45:	01 c0                	add    %eax,%eax
   11d47:	8d 50 02             	lea    0x2(%eax),%edx
   11d4a:	8b 45 10             	mov    0x10(%ebp),%eax
   11d4d:	01 d0                	add    %edx,%eax
   11d4f:	0f b6 00             	movzbl (%eax),%eax
   11d52:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
   11d54:	8b 45 08             	mov    0x8(%ebp),%eax
   11d57:	8d 48 02             	lea    0x2(%eax),%ecx
   11d5a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11d5d:	89 d0                	mov    %edx,%eax
   11d5f:	01 c0                	add    %eax,%eax
   11d61:	01 d0                	add    %edx,%eax
   11d63:	01 c0                	add    %eax,%eax
   11d65:	8d 50 04             	lea    0x4(%eax),%edx
   11d68:	8b 45 10             	mov    0x10(%ebp),%eax
   11d6b:	01 d0                	add    %edx,%eax
   11d6d:	0f b6 00             	movzbl (%eax),%eax
   11d70:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11d72:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11d76:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d79:	01 45 08             	add    %eax,0x8(%ebp)
   11d7c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11d7f:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11d82:	75 98                	jne    11d1c <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11d84:	e9 23 02 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
   11d89:	8b 45 14             	mov    0x14(%ebp),%eax
   11d8c:	8b 00                	mov    (%eax),%eax
   11d8e:	83 f8 03             	cmp    $0x3,%eax
   11d91:	0f 85 b4 00 00 00    	jne    11e4b <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
   11d97:	8b 45 14             	mov    0x14(%ebp),%eax
   11d9a:	8b 40 04             	mov    0x4(%eax),%eax
   11d9d:	83 f8 08             	cmp    $0x8,%eax
   11da0:	75 4d                	jne    11def <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11da2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11da9:	eb 37                	jmp    11de2 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
   11dab:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11dae:	8b 45 10             	mov    0x10(%ebp),%eax
   11db1:	01 d0                	add    %edx,%eax
   11db3:	0f b6 00             	movzbl (%eax),%eax
   11db6:	0f b6 c0             	movzbl %al,%eax
   11db9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
   11dbc:	8b 45 14             	mov    0x14(%ebp),%eax
   11dbf:	8b 40 08             	mov    0x8(%eax),%eax
   11dc2:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11dc5:	c1 e2 02             	shl    $0x2,%edx
   11dc8:	01 d0                	add    %edx,%eax
   11dca:	6a 03                	push   $0x3
   11dcc:	50                   	push   %eax
   11dcd:	ff 75 08             	pushl  0x8(%ebp)
   11dd0:	e8 06 7f ff ff       	call   9cdb <lodepng_memcpy>
   11dd5:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11dd8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11ddc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ddf:	01 45 08             	add    %eax,0x8(%ebp)
   11de2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11de5:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11de8:	75 c1                	jne    11dab <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11dea:	e9 bd 01 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
   11def:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11df6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11dfd:	eb 3f                	jmp    11e3e <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
   11dff:	8b 45 14             	mov    0x14(%ebp),%eax
   11e02:	8b 40 04             	mov    0x4(%eax),%eax
   11e05:	50                   	push   %eax
   11e06:	ff 75 10             	pushl  0x10(%ebp)
   11e09:	8d 45 dc             	lea    -0x24(%ebp),%eax
   11e0c:	50                   	push   %eax
   11e0d:	e8 2e cd ff ff       	call   eb40 <readBitsFromReversedStream>
   11e12:	83 c4 0c             	add    $0xc,%esp
   11e15:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
   11e18:	8b 45 14             	mov    0x14(%ebp),%eax
   11e1b:	8b 40 08             	mov    0x8(%eax),%eax
   11e1e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   11e21:	c1 e2 02             	shl    $0x2,%edx
   11e24:	01 d0                	add    %edx,%eax
   11e26:	6a 03                	push   $0x3
   11e28:	50                   	push   %eax
   11e29:	ff 75 08             	pushl  0x8(%ebp)
   11e2c:	e8 aa 7e ff ff       	call   9cdb <lodepng_memcpy>
   11e31:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11e34:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e3b:	01 45 08             	add    %eax,0x8(%ebp)
   11e3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11e41:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11e44:	75 b9                	jne    11dff <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11e46:	e9 61 01 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
   11e4b:	8b 45 14             	mov    0x14(%ebp),%eax
   11e4e:	8b 00                	mov    (%eax),%eax
   11e50:	83 f8 04             	cmp    $0x4,%eax
   11e53:	0f 85 a0 00 00 00    	jne    11ef9 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
   11e59:	8b 45 14             	mov    0x14(%ebp),%eax
   11e5c:	8b 40 04             	mov    0x4(%eax),%eax
   11e5f:	83 f8 08             	cmp    $0x8,%eax
   11e62:	75 4a                	jne    11eae <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11e64:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11e6b:	eb 34                	jmp    11ea1 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
   11e6d:	8b 45 08             	mov    0x8(%ebp),%eax
   11e70:	83 c0 01             	add    $0x1,%eax
   11e73:	8b 55 08             	mov    0x8(%ebp),%edx
   11e76:	83 c2 02             	add    $0x2,%edx
   11e79:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   11e7c:	01 c9                	add    %ecx,%ecx
   11e7e:	89 cb                	mov    %ecx,%ebx
   11e80:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11e83:	01 d9                	add    %ebx,%ecx
   11e85:	0f b6 09             	movzbl (%ecx),%ecx
   11e88:	88 0a                	mov    %cl,(%edx)
   11e8a:	0f b6 12             	movzbl (%edx),%edx
   11e8d:	88 10                	mov    %dl,(%eax)
   11e8f:	0f b6 10             	movzbl (%eax),%edx
   11e92:	8b 45 08             	mov    0x8(%ebp),%eax
   11e95:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11e97:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11e9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e9e:	01 45 08             	add    %eax,0x8(%ebp)
   11ea1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11ea4:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11ea7:	75 c4                	jne    11e6d <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11ea9:	e9 fe 00 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11eae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11eb5:	eb 35                	jmp    11eec <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
   11eb7:	8b 45 08             	mov    0x8(%ebp),%eax
   11eba:	83 c0 01             	add    $0x1,%eax
   11ebd:	8b 55 08             	mov    0x8(%ebp),%edx
   11ec0:	83 c2 02             	add    $0x2,%edx
   11ec3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
   11ec6:	c1 e1 02             	shl    $0x2,%ecx
   11ec9:	89 cb                	mov    %ecx,%ebx
   11ecb:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11ece:	01 d9                	add    %ebx,%ecx
   11ed0:	0f b6 09             	movzbl (%ecx),%ecx
   11ed3:	88 0a                	mov    %cl,(%edx)
   11ed5:	0f b6 12             	movzbl (%edx),%edx
   11ed8:	88 10                	mov    %dl,(%eax)
   11eda:	0f b6 10             	movzbl (%eax),%edx
   11edd:	8b 45 08             	mov    0x8(%ebp),%eax
   11ee0:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11ee2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11ee6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ee9:	01 45 08             	add    %eax,0x8(%ebp)
   11eec:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11eef:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11ef2:	75 c3                	jne    11eb7 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11ef4:	e9 b3 00 00 00       	jmp    11fac <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
   11ef9:	8b 45 14             	mov    0x14(%ebp),%eax
   11efc:	8b 00                	mov    (%eax),%eax
   11efe:	83 f8 06             	cmp    $0x6,%eax
   11f01:	0f 85 a5 00 00 00    	jne    11fac <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
   11f07:	8b 45 14             	mov    0x14(%ebp),%eax
   11f0a:	8b 40 04             	mov    0x4(%eax),%eax
   11f0d:	83 f8 08             	cmp    $0x8,%eax
   11f10:	75 38                	jne    11f4a <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11f12:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11f19:	eb 25                	jmp    11f40 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
   11f1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f1e:	c1 e0 02             	shl    $0x2,%eax
   11f21:	89 c2                	mov    %eax,%edx
   11f23:	8b 45 10             	mov    0x10(%ebp),%eax
   11f26:	01 d0                	add    %edx,%eax
   11f28:	6a 03                	push   $0x3
   11f2a:	50                   	push   %eax
   11f2b:	ff 75 08             	pushl  0x8(%ebp)
   11f2e:	e8 a8 7d ff ff       	call   9cdb <lodepng_memcpy>
   11f33:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11f36:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11f3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f3d:	01 45 08             	add    %eax,0x8(%ebp)
   11f40:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f43:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11f46:	75 d3                	jne    11f1b <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11f48:	eb 62                	jmp    11fac <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11f4a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11f51:	eb 51                	jmp    11fa4 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
   11f53:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f56:	c1 e0 03             	shl    $0x3,%eax
   11f59:	89 c2                	mov    %eax,%edx
   11f5b:	8b 45 10             	mov    0x10(%ebp),%eax
   11f5e:	01 d0                	add    %edx,%eax
   11f60:	0f b6 10             	movzbl (%eax),%edx
   11f63:	8b 45 08             	mov    0x8(%ebp),%eax
   11f66:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
   11f68:	8b 45 08             	mov    0x8(%ebp),%eax
   11f6b:	8d 50 01             	lea    0x1(%eax),%edx
   11f6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f71:	c1 e0 03             	shl    $0x3,%eax
   11f74:	8d 48 02             	lea    0x2(%eax),%ecx
   11f77:	8b 45 10             	mov    0x10(%ebp),%eax
   11f7a:	01 c8                	add    %ecx,%eax
   11f7c:	0f b6 00             	movzbl (%eax),%eax
   11f7f:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
   11f81:	8b 45 08             	mov    0x8(%ebp),%eax
   11f84:	8d 50 02             	lea    0x2(%eax),%edx
   11f87:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11f8a:	c1 e0 03             	shl    $0x3,%eax
   11f8d:	8d 48 04             	lea    0x4(%eax),%ecx
   11f90:	8b 45 10             	mov    0x10(%ebp),%eax
   11f93:	01 c8                	add    %ecx,%eax
   11f95:	0f b6 00             	movzbl (%eax),%eax
   11f98:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
   11f9a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11f9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fa1:	01 45 08             	add    %eax,0x8(%ebp)
   11fa4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11fa7:	3b 45 0c             	cmp    0xc(%ebp),%eax
   11faa:	75 a7                	jne    11f53 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
   11fac:	90                   	nop
   11fad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11fb0:	c9                   	leave  
   11fb1:	c3                   	ret    

00011fb2 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
   11fb2:	55                   	push   %ebp
   11fb3:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
   11fb5:	8b 45 20             	mov    0x20(%ebp),%eax
   11fb8:	8b 00                	mov    (%eax),%eax
   11fba:	85 c0                	test   %eax,%eax
   11fbc:	0f 85 a4 00 00 00    	jne    12066 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
   11fc2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11fc5:	01 c0                	add    %eax,%eax
   11fc7:	89 c2                	mov    %eax,%edx
   11fc9:	8b 45 18             	mov    0x18(%ebp),%eax
   11fcc:	01 d0                	add    %edx,%eax
   11fce:	0f b6 00             	movzbl (%eax),%eax
   11fd1:	0f b6 c0             	movzbl %al,%eax
   11fd4:	c1 e0 08             	shl    $0x8,%eax
   11fd7:	89 c2                	mov    %eax,%edx
   11fd9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11fdc:	01 c0                	add    %eax,%eax
   11fde:	8d 48 01             	lea    0x1(%eax),%ecx
   11fe1:	8b 45 18             	mov    0x18(%ebp),%eax
   11fe4:	01 c8                	add    %ecx,%eax
   11fe6:	0f b6 00             	movzbl (%eax),%eax
   11fe9:	0f b6 c0             	movzbl %al,%eax
   11fec:	01 c2                	add    %eax,%edx
   11fee:	8b 45 10             	mov    0x10(%ebp),%eax
   11ff1:	66 89 10             	mov    %dx,(%eax)
   11ff4:	8b 45 10             	mov    0x10(%ebp),%eax
   11ff7:	0f b7 10             	movzwl (%eax),%edx
   11ffa:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ffd:	66 89 10             	mov    %dx,(%eax)
   12000:	8b 45 0c             	mov    0xc(%ebp),%eax
   12003:	0f b7 10             	movzwl (%eax),%edx
   12006:	8b 45 08             	mov    0x8(%ebp),%eax
   12009:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
   1200c:	8b 45 20             	mov    0x20(%ebp),%eax
   1200f:	8b 40 10             	mov    0x10(%eax),%eax
   12012:	85 c0                	test   %eax,%eax
   12014:	74 43                	je     12059 <getPixelColorRGBA16+0xa7>
   12016:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12019:	01 c0                	add    %eax,%eax
   1201b:	89 c2                	mov    %eax,%edx
   1201d:	8b 45 18             	mov    0x18(%ebp),%eax
   12020:	01 d0                	add    %edx,%eax
   12022:	0f b6 00             	movzbl (%eax),%eax
   12025:	0f b6 c0             	movzbl %al,%eax
   12028:	c1 e0 08             	shl    $0x8,%eax
   1202b:	89 c2                	mov    %eax,%edx
   1202d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12030:	01 c0                	add    %eax,%eax
   12032:	8d 48 01             	lea    0x1(%eax),%ecx
   12035:	8b 45 18             	mov    0x18(%ebp),%eax
   12038:	01 c8                	add    %ecx,%eax
   1203a:	0f b6 00             	movzbl (%eax),%eax
   1203d:	0f b6 c0             	movzbl %al,%eax
   12040:	01 c2                	add    %eax,%edx
   12042:	8b 45 20             	mov    0x20(%ebp),%eax
   12045:	8b 40 14             	mov    0x14(%eax),%eax
   12048:	39 c2                	cmp    %eax,%edx
   1204a:	75 0d                	jne    12059 <getPixelColorRGBA16+0xa7>
   1204c:	8b 45 14             	mov    0x14(%ebp),%eax
   1204f:	66 c7 00 00 00       	movw   $0x0,(%eax)
   12054:	e9 48 03 00 00       	jmp    123a1 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
   12059:	8b 45 14             	mov    0x14(%ebp),%eax
   1205c:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
   12061:	e9 3b 03 00 00       	jmp    123a1 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
   12066:	8b 45 20             	mov    0x20(%ebp),%eax
   12069:	8b 00                	mov    (%eax),%eax
   1206b:	83 f8 02             	cmp    $0x2,%eax
   1206e:	0f 85 b6 01 00 00    	jne    1222a <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
   12074:	8b 55 1c             	mov    0x1c(%ebp),%edx
   12077:	89 d0                	mov    %edx,%eax
   12079:	01 c0                	add    %eax,%eax
   1207b:	01 d0                	add    %edx,%eax
   1207d:	01 c0                	add    %eax,%eax
   1207f:	89 c2                	mov    %eax,%edx
   12081:	8b 45 18             	mov    0x18(%ebp),%eax
   12084:	01 d0                	add    %edx,%eax
   12086:	0f b6 00             	movzbl (%eax),%eax
   12089:	0f b6 c0             	movzbl %al,%eax
   1208c:	c1 e0 08             	shl    $0x8,%eax
   1208f:	89 c1                	mov    %eax,%ecx
   12091:	8b 55 1c             	mov    0x1c(%ebp),%edx
   12094:	89 d0                	mov    %edx,%eax
   12096:	01 c0                	add    %eax,%eax
   12098:	01 d0                	add    %edx,%eax
   1209a:	01 c0                	add    %eax,%eax
   1209c:	8d 50 01             	lea    0x1(%eax),%edx
   1209f:	8b 45 18             	mov    0x18(%ebp),%eax
   120a2:	01 d0                	add    %edx,%eax
   120a4:	0f b6 00             	movzbl (%eax),%eax
   120a7:	0f b6 c0             	movzbl %al,%eax
   120aa:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   120ad:	8b 45 08             	mov    0x8(%ebp),%eax
   120b0:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
   120b3:	8b 55 1c             	mov    0x1c(%ebp),%edx
   120b6:	89 d0                	mov    %edx,%eax
   120b8:	01 c0                	add    %eax,%eax
   120ba:	01 d0                	add    %edx,%eax
   120bc:	01 c0                	add    %eax,%eax
   120be:	8d 50 02             	lea    0x2(%eax),%edx
   120c1:	8b 45 18             	mov    0x18(%ebp),%eax
   120c4:	01 d0                	add    %edx,%eax
   120c6:	0f b6 00             	movzbl (%eax),%eax
   120c9:	0f b6 c0             	movzbl %al,%eax
   120cc:	c1 e0 08             	shl    $0x8,%eax
   120cf:	89 c1                	mov    %eax,%ecx
   120d1:	8b 55 1c             	mov    0x1c(%ebp),%edx
   120d4:	89 d0                	mov    %edx,%eax
   120d6:	01 c0                	add    %eax,%eax
   120d8:	01 d0                	add    %edx,%eax
   120da:	01 c0                	add    %eax,%eax
   120dc:	8d 50 03             	lea    0x3(%eax),%edx
   120df:	8b 45 18             	mov    0x18(%ebp),%eax
   120e2:	01 d0                	add    %edx,%eax
   120e4:	0f b6 00             	movzbl (%eax),%eax
   120e7:	0f b6 c0             	movzbl %al,%eax
   120ea:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   120ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   120f0:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
   120f3:	8b 55 1c             	mov    0x1c(%ebp),%edx
   120f6:	89 d0                	mov    %edx,%eax
   120f8:	01 c0                	add    %eax,%eax
   120fa:	01 d0                	add    %edx,%eax
   120fc:	01 c0                	add    %eax,%eax
   120fe:	8d 50 04             	lea    0x4(%eax),%edx
   12101:	8b 45 18             	mov    0x18(%ebp),%eax
   12104:	01 d0                	add    %edx,%eax
   12106:	0f b6 00             	movzbl (%eax),%eax
   12109:	0f b6 c0             	movzbl %al,%eax
   1210c:	c1 e0 08             	shl    $0x8,%eax
   1210f:	89 c1                	mov    %eax,%ecx
   12111:	8b 55 1c             	mov    0x1c(%ebp),%edx
   12114:	89 d0                	mov    %edx,%eax
   12116:	01 c0                	add    %eax,%eax
   12118:	01 d0                	add    %edx,%eax
   1211a:	01 c0                	add    %eax,%eax
   1211c:	8d 50 05             	lea    0x5(%eax),%edx
   1211f:	8b 45 18             	mov    0x18(%ebp),%eax
   12122:	01 d0                	add    %edx,%eax
   12124:	0f b6 00             	movzbl (%eax),%eax
   12127:	0f b6 c0             	movzbl %al,%eax
   1212a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1212d:	8b 45 10             	mov    0x10(%ebp),%eax
   12130:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
   12133:	8b 45 20             	mov    0x20(%ebp),%eax
   12136:	8b 40 10             	mov    0x10(%eax),%eax
   12139:	85 c0                	test   %eax,%eax
   1213b:	0f 84 dc 00 00 00    	je     1221d <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
   12141:	8b 55 1c             	mov    0x1c(%ebp),%edx
   12144:	89 d0                	mov    %edx,%eax
   12146:	01 c0                	add    %eax,%eax
   12148:	01 d0                	add    %edx,%eax
   1214a:	01 c0                	add    %eax,%eax
   1214c:	89 c2                	mov    %eax,%edx
   1214e:	8b 45 18             	mov    0x18(%ebp),%eax
   12151:	01 d0                	add    %edx,%eax
   12153:	0f b6 00             	movzbl (%eax),%eax
   12156:	0f b6 c0             	movzbl %al,%eax
   12159:	c1 e0 08             	shl    $0x8,%eax
   1215c:	89 c1                	mov    %eax,%ecx
   1215e:	8b 55 1c             	mov    0x1c(%ebp),%edx
   12161:	89 d0                	mov    %edx,%eax
   12163:	01 c0                	add    %eax,%eax
   12165:	01 d0                	add    %edx,%eax
   12167:	01 c0                	add    %eax,%eax
   12169:	8d 50 01             	lea    0x1(%eax),%edx
   1216c:	8b 45 18             	mov    0x18(%ebp),%eax
   1216f:	01 d0                	add    %edx,%eax
   12171:	0f b6 00             	movzbl (%eax),%eax
   12174:	0f b6 c0             	movzbl %al,%eax
   12177:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1217a:	8b 45 20             	mov    0x20(%ebp),%eax
   1217d:	8b 40 14             	mov    0x14(%eax),%eax
   12180:	39 c2                	cmp    %eax,%edx
   12182:	0f 85 95 00 00 00    	jne    1221d <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
   12188:	8b 55 1c             	mov    0x1c(%ebp),%edx
   1218b:	89 d0                	mov    %edx,%eax
   1218d:	01 c0                	add    %eax,%eax
   1218f:	01 d0                	add    %edx,%eax
   12191:	01 c0                	add    %eax,%eax
   12193:	8d 50 02             	lea    0x2(%eax),%edx
   12196:	8b 45 18             	mov    0x18(%ebp),%eax
   12199:	01 d0                	add    %edx,%eax
   1219b:	0f b6 00             	movzbl (%eax),%eax
   1219e:	0f b6 c0             	movzbl %al,%eax
   121a1:	c1 e0 08             	shl    $0x8,%eax
   121a4:	89 c1                	mov    %eax,%ecx
   121a6:	8b 55 1c             	mov    0x1c(%ebp),%edx
   121a9:	89 d0                	mov    %edx,%eax
   121ab:	01 c0                	add    %eax,%eax
   121ad:	01 d0                	add    %edx,%eax
   121af:	01 c0                	add    %eax,%eax
   121b1:	8d 50 03             	lea    0x3(%eax),%edx
   121b4:	8b 45 18             	mov    0x18(%ebp),%eax
   121b7:	01 d0                	add    %edx,%eax
   121b9:	0f b6 00             	movzbl (%eax),%eax
   121bc:	0f b6 c0             	movzbl %al,%eax
   121bf:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   121c2:	8b 45 20             	mov    0x20(%ebp),%eax
   121c5:	8b 40 18             	mov    0x18(%eax),%eax
   121c8:	39 c2                	cmp    %eax,%edx
   121ca:	75 51                	jne    1221d <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
   121cc:	8b 55 1c             	mov    0x1c(%ebp),%edx
   121cf:	89 d0                	mov    %edx,%eax
   121d1:	01 c0                	add    %eax,%eax
   121d3:	01 d0                	add    %edx,%eax
   121d5:	01 c0                	add    %eax,%eax
   121d7:	8d 50 04             	lea    0x4(%eax),%edx
   121da:	8b 45 18             	mov    0x18(%ebp),%eax
   121dd:	01 d0                	add    %edx,%eax
   121df:	0f b6 00             	movzbl (%eax),%eax
   121e2:	0f b6 c0             	movzbl %al,%eax
   121e5:	c1 e0 08             	shl    $0x8,%eax
   121e8:	89 c1                	mov    %eax,%ecx
   121ea:	8b 55 1c             	mov    0x1c(%ebp),%edx
   121ed:	89 d0                	mov    %edx,%eax
   121ef:	01 c0                	add    %eax,%eax
   121f1:	01 d0                	add    %edx,%eax
   121f3:	01 c0                	add    %eax,%eax
   121f5:	8d 50 05             	lea    0x5(%eax),%edx
   121f8:	8b 45 18             	mov    0x18(%ebp),%eax
   121fb:	01 d0                	add    %edx,%eax
   121fd:	0f b6 00             	movzbl (%eax),%eax
   12200:	0f b6 c0             	movzbl %al,%eax
   12203:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   12206:	8b 45 20             	mov    0x20(%ebp),%eax
   12209:	8b 40 1c             	mov    0x1c(%eax),%eax
   1220c:	39 c2                	cmp    %eax,%edx
   1220e:	75 0d                	jne    1221d <getPixelColorRGBA16+0x26b>
   12210:	8b 45 14             	mov    0x14(%ebp),%eax
   12213:	66 c7 00 00 00       	movw   $0x0,(%eax)
   12218:	e9 84 01 00 00       	jmp    123a1 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
   1221d:	8b 45 14             	mov    0x14(%ebp),%eax
   12220:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
   12225:	e9 77 01 00 00       	jmp    123a1 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
   1222a:	8b 45 20             	mov    0x20(%ebp),%eax
   1222d:	8b 00                	mov    (%eax),%eax
   1222f:	83 f8 04             	cmp    $0x4,%eax
   12232:	0f 85 86 00 00 00    	jne    122be <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
   12238:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1223b:	c1 e0 02             	shl    $0x2,%eax
   1223e:	89 c2                	mov    %eax,%edx
   12240:	8b 45 18             	mov    0x18(%ebp),%eax
   12243:	01 d0                	add    %edx,%eax
   12245:	0f b6 00             	movzbl (%eax),%eax
   12248:	0f b6 c0             	movzbl %al,%eax
   1224b:	c1 e0 08             	shl    $0x8,%eax
   1224e:	89 c2                	mov    %eax,%edx
   12250:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12253:	c1 e0 02             	shl    $0x2,%eax
   12256:	8d 48 01             	lea    0x1(%eax),%ecx
   12259:	8b 45 18             	mov    0x18(%ebp),%eax
   1225c:	01 c8                	add    %ecx,%eax
   1225e:	0f b6 00             	movzbl (%eax),%eax
   12261:	0f b6 c0             	movzbl %al,%eax
   12264:	01 c2                	add    %eax,%edx
   12266:	8b 45 10             	mov    0x10(%ebp),%eax
   12269:	66 89 10             	mov    %dx,(%eax)
   1226c:	8b 45 10             	mov    0x10(%ebp),%eax
   1226f:	0f b7 10             	movzwl (%eax),%edx
   12272:	8b 45 0c             	mov    0xc(%ebp),%eax
   12275:	66 89 10             	mov    %dx,(%eax)
   12278:	8b 45 0c             	mov    0xc(%ebp),%eax
   1227b:	0f b7 10             	movzwl (%eax),%edx
   1227e:	8b 45 08             	mov    0x8(%ebp),%eax
   12281:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
   12284:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12287:	c1 e0 02             	shl    $0x2,%eax
   1228a:	8d 50 02             	lea    0x2(%eax),%edx
   1228d:	8b 45 18             	mov    0x18(%ebp),%eax
   12290:	01 d0                	add    %edx,%eax
   12292:	0f b6 00             	movzbl (%eax),%eax
   12295:	0f b6 c0             	movzbl %al,%eax
   12298:	c1 e0 08             	shl    $0x8,%eax
   1229b:	89 c2                	mov    %eax,%edx
   1229d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   122a0:	c1 e0 02             	shl    $0x2,%eax
   122a3:	8d 48 03             	lea    0x3(%eax),%ecx
   122a6:	8b 45 18             	mov    0x18(%ebp),%eax
   122a9:	01 c8                	add    %ecx,%eax
   122ab:	0f b6 00             	movzbl (%eax),%eax
   122ae:	0f b6 c0             	movzbl %al,%eax
   122b1:	01 c2                	add    %eax,%edx
   122b3:	8b 45 14             	mov    0x14(%ebp),%eax
   122b6:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
   122b9:	e9 e3 00 00 00       	jmp    123a1 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
   122be:	8b 45 20             	mov    0x20(%ebp),%eax
   122c1:	8b 00                	mov    (%eax),%eax
   122c3:	83 f8 06             	cmp    $0x6,%eax
   122c6:	0f 85 d5 00 00 00    	jne    123a1 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
   122cc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   122cf:	c1 e0 03             	shl    $0x3,%eax
   122d2:	89 c2                	mov    %eax,%edx
   122d4:	8b 45 18             	mov    0x18(%ebp),%eax
   122d7:	01 d0                	add    %edx,%eax
   122d9:	0f b6 00             	movzbl (%eax),%eax
   122dc:	0f b6 c0             	movzbl %al,%eax
   122df:	c1 e0 08             	shl    $0x8,%eax
   122e2:	89 c2                	mov    %eax,%edx
   122e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   122e7:	c1 e0 03             	shl    $0x3,%eax
   122ea:	8d 48 01             	lea    0x1(%eax),%ecx
   122ed:	8b 45 18             	mov    0x18(%ebp),%eax
   122f0:	01 c8                	add    %ecx,%eax
   122f2:	0f b6 00             	movzbl (%eax),%eax
   122f5:	0f b6 c0             	movzbl %al,%eax
   122f8:	01 c2                	add    %eax,%edx
   122fa:	8b 45 08             	mov    0x8(%ebp),%eax
   122fd:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
   12300:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12303:	c1 e0 03             	shl    $0x3,%eax
   12306:	8d 50 02             	lea    0x2(%eax),%edx
   12309:	8b 45 18             	mov    0x18(%ebp),%eax
   1230c:	01 d0                	add    %edx,%eax
   1230e:	0f b6 00             	movzbl (%eax),%eax
   12311:	0f b6 c0             	movzbl %al,%eax
   12314:	c1 e0 08             	shl    $0x8,%eax
   12317:	89 c2                	mov    %eax,%edx
   12319:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1231c:	c1 e0 03             	shl    $0x3,%eax
   1231f:	8d 48 03             	lea    0x3(%eax),%ecx
   12322:	8b 45 18             	mov    0x18(%ebp),%eax
   12325:	01 c8                	add    %ecx,%eax
   12327:	0f b6 00             	movzbl (%eax),%eax
   1232a:	0f b6 c0             	movzbl %al,%eax
   1232d:	01 c2                	add    %eax,%edx
   1232f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12332:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
   12335:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12338:	c1 e0 03             	shl    $0x3,%eax
   1233b:	8d 50 04             	lea    0x4(%eax),%edx
   1233e:	8b 45 18             	mov    0x18(%ebp),%eax
   12341:	01 d0                	add    %edx,%eax
   12343:	0f b6 00             	movzbl (%eax),%eax
   12346:	0f b6 c0             	movzbl %al,%eax
   12349:	c1 e0 08             	shl    $0x8,%eax
   1234c:	89 c2                	mov    %eax,%edx
   1234e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12351:	c1 e0 03             	shl    $0x3,%eax
   12354:	8d 48 05             	lea    0x5(%eax),%ecx
   12357:	8b 45 18             	mov    0x18(%ebp),%eax
   1235a:	01 c8                	add    %ecx,%eax
   1235c:	0f b6 00             	movzbl (%eax),%eax
   1235f:	0f b6 c0             	movzbl %al,%eax
   12362:	01 c2                	add    %eax,%edx
   12364:	8b 45 10             	mov    0x10(%ebp),%eax
   12367:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
   1236a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1236d:	c1 e0 03             	shl    $0x3,%eax
   12370:	8d 50 06             	lea    0x6(%eax),%edx
   12373:	8b 45 18             	mov    0x18(%ebp),%eax
   12376:	01 d0                	add    %edx,%eax
   12378:	0f b6 00             	movzbl (%eax),%eax
   1237b:	0f b6 c0             	movzbl %al,%eax
   1237e:	c1 e0 08             	shl    $0x8,%eax
   12381:	89 c2                	mov    %eax,%edx
   12383:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12386:	c1 e0 03             	shl    $0x3,%eax
   12389:	8d 48 07             	lea    0x7(%eax),%ecx
   1238c:	8b 45 18             	mov    0x18(%ebp),%eax
   1238f:	01 c8                	add    %ecx,%eax
   12391:	0f b6 00             	movzbl (%eax),%eax
   12394:	0f b6 c0             	movzbl %al,%eax
   12397:	01 c2                	add    %eax,%edx
   12399:	8b 45 14             	mov    0x14(%ebp),%eax
   1239c:	66 89 10             	mov    %dx,(%eax)
  }
}
   1239f:	eb 00                	jmp    123a1 <getPixelColorRGBA16+0x3ef>
   123a1:	90                   	nop
   123a2:	5d                   	pop    %ebp
   123a3:	c3                   	ret    

000123a4 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
   123a4:	55                   	push   %ebp
   123a5:	89 e5                	mov    %esp,%ebp
   123a7:	56                   	push   %esi
   123a8:	53                   	push   %ebx
   123a9:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
   123ac:	8b 55 18             	mov    0x18(%ebp),%edx
   123af:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123b2:	0f af c2             	imul   %edx,%eax
   123b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
   123b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
   123bf:	8b 45 14             	mov    0x14(%ebp),%eax
   123c2:	8b 00                	mov    (%eax),%eax
   123c4:	83 f8 03             	cmp    $0x3,%eax
   123c7:	75 14                	jne    123dd <lodepng_convert+0x39>
   123c9:	8b 45 14             	mov    0x14(%ebp),%eax
   123cc:	8b 40 08             	mov    0x8(%eax),%eax
   123cf:	85 c0                	test   %eax,%eax
   123d1:	75 0a                	jne    123dd <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
   123d3:	b8 6b 00 00 00       	mov    $0x6b,%eax
   123d8:	e9 19 03 00 00       	jmp    126f6 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
   123dd:	ff 75 14             	pushl  0x14(%ebp)
   123e0:	ff 75 10             	pushl  0x10(%ebp)
   123e3:	e8 b7 d1 ff ff       	call   f59f <lodepng_color_mode_equal>
   123e8:	83 c4 08             	add    $0x8,%esp
   123eb:	85 c0                	test   %eax,%eax
   123ed:	74 2f                	je     1241e <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
   123ef:	ff 75 14             	pushl  0x14(%ebp)
   123f2:	ff 75 1c             	pushl  0x1c(%ebp)
   123f5:	ff 75 18             	pushl  0x18(%ebp)
   123f8:	e8 fb d4 ff ff       	call   f8f8 <lodepng_get_raw_size>
   123fd:	83 c4 0c             	add    $0xc,%esp
   12400:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
   12403:	ff 75 dc             	pushl  -0x24(%ebp)
   12406:	ff 75 0c             	pushl  0xc(%ebp)
   12409:	ff 75 08             	pushl  0x8(%ebp)
   1240c:	e8 ca 78 ff ff       	call   9cdb <lodepng_memcpy>
   12411:	83 c4 0c             	add    $0xc,%esp
    return 0;
   12414:	b8 00 00 00 00       	mov    $0x0,%eax
   12419:	e9 d8 02 00 00       	jmp    126f6 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
   1241e:	8b 45 10             	mov    0x10(%ebp),%eax
   12421:	8b 00                	mov    (%eax),%eax
   12423:	83 f8 03             	cmp    $0x3,%eax
   12426:	0f 85 16 01 00 00    	jne    12542 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
   1242c:	8b 45 10             	mov    0x10(%ebp),%eax
   1242f:	8b 40 0c             	mov    0xc(%eax),%eax
   12432:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
   12435:	8b 45 10             	mov    0x10(%ebp),%eax
   12438:	8b 40 08             	mov    0x8(%eax),%eax
   1243b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
   1243e:	8b 45 10             	mov    0x10(%ebp),%eax
   12441:	8b 40 04             	mov    0x4(%eax),%eax
   12444:	ba 01 00 00 00       	mov    $0x1,%edx
   12449:	89 c1                	mov    %eax,%ecx
   1244b:	d3 e2                	shl    %cl,%edx
   1244d:	89 d0                	mov    %edx,%eax
   1244f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
   12452:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12456:	75 5b                	jne    124b3 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
   12458:	8b 45 14             	mov    0x14(%ebp),%eax
   1245b:	8b 40 0c             	mov    0xc(%eax),%eax
   1245e:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
   12461:	8b 45 14             	mov    0x14(%ebp),%eax
   12464:	8b 40 08             	mov    0x8(%eax),%eax
   12467:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
   1246a:	8b 45 14             	mov    0x14(%ebp),%eax
   1246d:	8b 00                	mov    (%eax),%eax
   1246f:	83 f8 03             	cmp    $0x3,%eax
   12472:	75 3f                	jne    124b3 <lodepng_convert+0x10f>
   12474:	8b 45 14             	mov    0x14(%ebp),%eax
   12477:	8b 50 04             	mov    0x4(%eax),%edx
   1247a:	8b 45 10             	mov    0x10(%ebp),%eax
   1247d:	8b 40 04             	mov    0x4(%eax),%eax
   12480:	39 c2                	cmp    %eax,%edx
   12482:	75 2f                	jne    124b3 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
   12484:	ff 75 14             	pushl  0x14(%ebp)
   12487:	ff 75 1c             	pushl  0x1c(%ebp)
   1248a:	ff 75 18             	pushl  0x18(%ebp)
   1248d:	e8 66 d4 ff ff       	call   f8f8 <lodepng_get_raw_size>
   12492:	83 c4 0c             	add    $0xc,%esp
   12495:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
   12498:	ff 75 d8             	pushl  -0x28(%ebp)
   1249b:	ff 75 0c             	pushl  0xc(%ebp)
   1249e:	ff 75 08             	pushl  0x8(%ebp)
   124a1:	e8 35 78 ff ff       	call   9cdb <lodepng_memcpy>
   124a6:	83 c4 0c             	add    $0xc,%esp
        return 0;
   124a9:	b8 00 00 00 00       	mov    $0x0,%eax
   124ae:	e9 43 02 00 00       	jmp    126f6 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
   124b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   124b6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   124b9:	7d 06                	jge    124c1 <lodepng_convert+0x11d>
   124bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   124be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
   124c1:	8d 45 90             	lea    -0x70(%ebp),%eax
   124c4:	50                   	push   %eax
   124c5:	e8 5f e1 ff ff       	call   10629 <color_tree_init>
   124ca:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
   124cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   124d4:	eb 61                	jmp    12537 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
   124d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124d9:	c1 e0 02             	shl    $0x2,%eax
   124dc:	89 c2                	mov    %eax,%edx
   124de:	8b 45 e8             	mov    -0x18(%ebp),%eax
   124e1:	01 d0                	add    %edx,%eax
   124e3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
   124e6:	8b 75 f4             	mov    -0xc(%ebp),%esi
   124e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   124ec:	83 c0 03             	add    $0x3,%eax
   124ef:	0f b6 00             	movzbl (%eax),%eax
   124f2:	0f b6 d8             	movzbl %al,%ebx
   124f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   124f8:	83 c0 02             	add    $0x2,%eax
   124fb:	0f b6 00             	movzbl (%eax),%eax
   124fe:	0f b6 c8             	movzbl %al,%ecx
   12501:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   12504:	83 c0 01             	add    $0x1,%eax
   12507:	0f b6 00             	movzbl (%eax),%eax
   1250a:	0f b6 d0             	movzbl %al,%edx
   1250d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   12510:	0f b6 00             	movzbl (%eax),%eax
   12513:	0f b6 c0             	movzbl %al,%eax
   12516:	83 ec 08             	sub    $0x8,%esp
   12519:	56                   	push   %esi
   1251a:	53                   	push   %ebx
   1251b:	51                   	push   %ecx
   1251c:	52                   	push   %edx
   1251d:	50                   	push   %eax
   1251e:	8d 45 90             	lea    -0x70(%ebp),%eax
   12521:	50                   	push   %eax
   12522:	e8 85 e2 ff ff       	call   107ac <color_tree_add>
   12527:	83 c4 20             	add    $0x20,%esp
   1252a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
   1252d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12531:	75 0e                	jne    12541 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
   12533:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12537:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1253a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1253d:	75 97                	jne    124d6 <lodepng_convert+0x132>
   1253f:	eb 01                	jmp    12542 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
   12541:	90                   	nop
    }
  }

  if(!error) {
   12542:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12546:	0f 85 8e 01 00 00    	jne    126da <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
   1254c:	8b 45 14             	mov    0x14(%ebp),%eax
   1254f:	8b 40 04             	mov    0x4(%eax),%eax
   12552:	83 f8 10             	cmp    $0x10,%eax
   12555:	0f 85 99 00 00 00    	jne    125f4 <lodepng_convert+0x250>
   1255b:	8b 45 10             	mov    0x10(%ebp),%eax
   1255e:	8b 40 04             	mov    0x4(%eax),%eax
   12561:	83 f8 10             	cmp    $0x10,%eax
   12564:	0f 85 8a 00 00 00    	jne    125f4 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
   1256a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12571:	eb 74                	jmp    125e7 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
   12573:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
   12579:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
   1257f:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
   12585:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
   1258b:	83 ec 04             	sub    $0x4,%esp
   1258e:	ff 75 14             	pushl  0x14(%ebp)
   12591:	ff 75 f4             	pushl  -0xc(%ebp)
   12594:	ff 75 0c             	pushl  0xc(%ebp)
   12597:	8d 45 88             	lea    -0x78(%ebp),%eax
   1259a:	50                   	push   %eax
   1259b:	8d 45 8a             	lea    -0x76(%ebp),%eax
   1259e:	50                   	push   %eax
   1259f:	8d 45 8c             	lea    -0x74(%ebp),%eax
   125a2:	50                   	push   %eax
   125a3:	8d 45 8e             	lea    -0x72(%ebp),%eax
   125a6:	50                   	push   %eax
   125a7:	e8 06 fa ff ff       	call   11fb2 <getPixelColorRGBA16>
   125ac:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
   125af:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
   125b3:	0f b7 d8             	movzwl %ax,%ebx
   125b6:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
   125ba:	0f b7 c8             	movzwl %ax,%ecx
   125bd:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
   125c1:	0f b7 d0             	movzwl %ax,%edx
   125c4:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
   125c8:	0f b7 c0             	movzwl %ax,%eax
   125cb:	83 ec 04             	sub    $0x4,%esp
   125ce:	53                   	push   %ebx
   125cf:	51                   	push   %ecx
   125d0:	52                   	push   %edx
   125d1:	50                   	push   %eax
   125d2:	ff 75 10             	pushl  0x10(%ebp)
   125d5:	ff 75 f4             	pushl  -0xc(%ebp)
   125d8:	ff 75 08             	pushl  0x8(%ebp)
   125db:	e8 d3 e6 ff ff       	call   10cb3 <rgba16ToPixel>
   125e0:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
   125e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   125e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   125ea:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   125ed:	75 84                	jne    12573 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
   125ef:	e9 e6 00 00 00       	jmp    126da <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
   125f4:	8b 45 10             	mov    0x10(%ebp),%eax
   125f7:	8b 40 04             	mov    0x4(%eax),%eax
   125fa:	83 f8 08             	cmp    $0x8,%eax
   125fd:	75 23                	jne    12622 <lodepng_convert+0x27e>
   125ff:	8b 45 10             	mov    0x10(%ebp),%eax
   12602:	8b 00                	mov    (%eax),%eax
   12604:	83 f8 06             	cmp    $0x6,%eax
   12607:	75 19                	jne    12622 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
   12609:	ff 75 14             	pushl  0x14(%ebp)
   1260c:	ff 75 0c             	pushl  0xc(%ebp)
   1260f:	ff 75 e0             	pushl  -0x20(%ebp)
   12612:	ff 75 08             	pushl  0x8(%ebp)
   12615:	e8 ae ee ff ff       	call   114c8 <getPixelColorsRGBA8>
   1261a:	83 c4 10             	add    $0x10,%esp
   1261d:	e9 b8 00 00 00       	jmp    126da <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
   12622:	8b 45 10             	mov    0x10(%ebp),%eax
   12625:	8b 40 04             	mov    0x4(%eax),%eax
   12628:	83 f8 08             	cmp    $0x8,%eax
   1262b:	75 23                	jne    12650 <lodepng_convert+0x2ac>
   1262d:	8b 45 10             	mov    0x10(%ebp),%eax
   12630:	8b 00                	mov    (%eax),%eax
   12632:	83 f8 02             	cmp    $0x2,%eax
   12635:	75 19                	jne    12650 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
   12637:	ff 75 14             	pushl  0x14(%ebp)
   1263a:	ff 75 0c             	pushl  0xc(%ebp)
   1263d:	ff 75 e0             	pushl  -0x20(%ebp)
   12640:	ff 75 08             	pushl  0x8(%ebp)
   12643:	e8 50 f5 ff ff       	call   11b98 <getPixelColorsRGB8>
   12648:	83 c4 10             	add    $0x10,%esp
   1264b:	e9 8a 00 00 00       	jmp    126da <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
   12650:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
   12654:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
   12658:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
   1265c:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
   12660:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12667:	eb 66                	jmp    126cf <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
   12669:	83 ec 04             	sub    $0x4,%esp
   1266c:	ff 75 14             	pushl  0x14(%ebp)
   1266f:	ff 75 f4             	pushl  -0xc(%ebp)
   12672:	ff 75 0c             	pushl  0xc(%ebp)
   12675:	8d 45 84             	lea    -0x7c(%ebp),%eax
   12678:	50                   	push   %eax
   12679:	8d 45 85             	lea    -0x7b(%ebp),%eax
   1267c:	50                   	push   %eax
   1267d:	8d 45 86             	lea    -0x7a(%ebp),%eax
   12680:	50                   	push   %eax
   12681:	8d 45 87             	lea    -0x79(%ebp),%eax
   12684:	50                   	push   %eax
   12685:	e8 71 e8 ff ff       	call   10efb <getPixelColorRGBA8>
   1268a:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
   1268d:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
   12691:	0f b6 d8             	movzbl %al,%ebx
   12694:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
   12698:	0f b6 c8             	movzbl %al,%ecx
   1269b:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
   1269f:	0f b6 d0             	movzbl %al,%edx
   126a2:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
   126a6:	0f b6 c0             	movzbl %al,%eax
   126a9:	53                   	push   %ebx
   126aa:	51                   	push   %ecx
   126ab:	52                   	push   %edx
   126ac:	50                   	push   %eax
   126ad:	8d 45 90             	lea    -0x70(%ebp),%eax
   126b0:	50                   	push   %eax
   126b1:	ff 75 10             	pushl  0x10(%ebp)
   126b4:	ff 75 f4             	pushl  -0xc(%ebp)
   126b7:	ff 75 08             	pushl  0x8(%ebp)
   126ba:	e8 e5 e1 ff ff       	call   108a4 <rgba8ToPixel>
   126bf:	83 c4 20             	add    $0x20,%esp
   126c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
   126c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   126c9:	75 0e                	jne    126d9 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
   126cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   126cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   126d2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   126d5:	75 92                	jne    12669 <lodepng_convert+0x2c5>
   126d7:	eb 01                	jmp    126da <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
   126d9:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
   126da:	8b 45 10             	mov    0x10(%ebp),%eax
   126dd:	8b 00                	mov    (%eax),%eax
   126df:	83 f8 03             	cmp    $0x3,%eax
   126e2:	75 0f                	jne    126f3 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
   126e4:	83 ec 0c             	sub    $0xc,%esp
   126e7:	8d 45 90             	lea    -0x70(%ebp),%eax
   126ea:	50                   	push   %eax
   126eb:	e8 59 df ff ff       	call   10649 <color_tree_cleanup>
   126f0:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   126f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   126f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
   126f9:	5b                   	pop    %ebx
   126fa:	5e                   	pop    %esi
   126fb:	5d                   	pop    %ebp
   126fc:	c3                   	ret    

000126fd <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
   126fd:	55                   	push   %ebp
   126fe:	89 e5                	mov    %esp,%ebp
   12700:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
   12703:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1270a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12711:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
   12718:	8b 45 24             	mov    0x24(%ebp),%eax
   1271b:	8b 40 04             	mov    0x4(%eax),%eax
   1271e:	ba 01 00 00 00       	mov    $0x1,%edx
   12723:	89 c1                	mov    %eax,%ecx
   12725:	d3 e2                	shl    %cl,%edx
   12727:	89 d0                	mov    %edx,%eax
   12729:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1272c:	b8 ff ff 00 00       	mov    $0xffff,%eax
   12731:	ba 00 00 00 00       	mov    $0x0,%edx
   12736:	f7 f1                	div    %ecx
   12738:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
   1273b:	8b 45 20             	mov    0x20(%ebp),%eax
   1273e:	8b 40 04             	mov    0x4(%eax),%eax
   12741:	ba 10 00 00 00       	mov    $0x10,%edx
   12746:	29 c2                	sub    %eax,%edx
   12748:	89 d0                	mov    %edx,%eax
   1274a:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
   1274d:	8b 45 24             	mov    0x24(%ebp),%eax
   12750:	8b 00                	mov    (%eax),%eax
   12752:	85 c0                	test   %eax,%eax
   12754:	74 0a                	je     12760 <lodepng_convert_rgb+0x63>
   12756:	8b 45 24             	mov    0x24(%ebp),%eax
   12759:	8b 00                	mov    (%eax),%eax
   1275b:	83 f8 04             	cmp    $0x4,%eax
   1275e:	75 1b                	jne    1277b <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
   12760:	8b 45 14             	mov    0x14(%ebp),%eax
   12763:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12767:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1276a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1276d:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12770:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12773:	89 45 fc             	mov    %eax,-0x4(%ebp)
   12776:	e9 c2 00 00 00       	jmp    1283d <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
   1277b:	8b 45 24             	mov    0x24(%ebp),%eax
   1277e:	8b 00                	mov    (%eax),%eax
   12780:	83 f8 02             	cmp    $0x2,%eax
   12783:	74 0a                	je     1278f <lodepng_convert_rgb+0x92>
   12785:	8b 45 24             	mov    0x24(%ebp),%eax
   12788:	8b 00                	mov    (%eax),%eax
   1278a:	83 f8 06             	cmp    $0x6,%eax
   1278d:	75 23                	jne    127b2 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
   1278f:	8b 45 14             	mov    0x14(%ebp),%eax
   12792:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12796:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
   12799:	8b 45 18             	mov    0x18(%ebp),%eax
   1279c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   127a0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
   127a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   127a6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   127aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
   127ad:	e9 8b 00 00 00       	jmp    1283d <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
   127b2:	8b 45 24             	mov    0x24(%ebp),%eax
   127b5:	8b 00                	mov    (%eax),%eax
   127b7:	83 f8 03             	cmp    $0x3,%eax
   127ba:	75 77                	jne    12833 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
   127bc:	8b 45 24             	mov    0x24(%ebp),%eax
   127bf:	8b 40 0c             	mov    0xc(%eax),%eax
   127c2:	3b 45 14             	cmp    0x14(%ebp),%eax
   127c5:	77 0a                	ja     127d1 <lodepng_convert_rgb+0xd4>
   127c7:	b8 52 00 00 00       	mov    $0x52,%eax
   127cc:	e9 cb 01 00 00       	jmp    1299c <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
   127d1:	8b 45 24             	mov    0x24(%ebp),%eax
   127d4:	8b 40 08             	mov    0x8(%eax),%eax
   127d7:	8b 55 14             	mov    0x14(%ebp),%edx
   127da:	c1 e2 02             	shl    $0x2,%edx
   127dd:	01 d0                	add    %edx,%eax
   127df:	0f b6 00             	movzbl (%eax),%eax
   127e2:	0f b6 d0             	movzbl %al,%edx
   127e5:	89 d0                	mov    %edx,%eax
   127e7:	c1 e0 08             	shl    $0x8,%eax
   127ea:	01 d0                	add    %edx,%eax
   127ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
   127ef:	8b 45 24             	mov    0x24(%ebp),%eax
   127f2:	8b 40 08             	mov    0x8(%eax),%eax
   127f5:	8b 55 14             	mov    0x14(%ebp),%edx
   127f8:	c1 e2 02             	shl    $0x2,%edx
   127fb:	83 c2 01             	add    $0x1,%edx
   127fe:	01 d0                	add    %edx,%eax
   12800:	0f b6 00             	movzbl (%eax),%eax
   12803:	0f b6 d0             	movzbl %al,%edx
   12806:	89 d0                	mov    %edx,%eax
   12808:	c1 e0 08             	shl    $0x8,%eax
   1280b:	01 d0                	add    %edx,%eax
   1280d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
   12810:	8b 45 24             	mov    0x24(%ebp),%eax
   12813:	8b 40 08             	mov    0x8(%eax),%eax
   12816:	8b 55 14             	mov    0x14(%ebp),%edx
   12819:	c1 e2 02             	shl    $0x2,%edx
   1281c:	83 c2 02             	add    $0x2,%edx
   1281f:	01 d0                	add    %edx,%eax
   12821:	0f b6 00             	movzbl (%eax),%eax
   12824:	0f b6 d0             	movzbl %al,%edx
   12827:	89 d0                	mov    %edx,%eax
   12829:	c1 e0 08             	shl    $0x8,%eax
   1282c:	01 d0                	add    %edx,%eax
   1282e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12831:	eb 0a                	jmp    1283d <lodepng_convert_rgb+0x140>
  } else {
    return 31;
   12833:	b8 1f 00 00 00       	mov    $0x1f,%eax
   12838:	e9 5f 01 00 00       	jmp    1299c <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
   1283d:	8b 45 20             	mov    0x20(%ebp),%eax
   12840:	8b 00                	mov    (%eax),%eax
   12842:	85 c0                	test   %eax,%eax
   12844:	74 0a                	je     12850 <lodepng_convert_rgb+0x153>
   12846:	8b 45 20             	mov    0x20(%ebp),%eax
   12849:	8b 00                	mov    (%eax),%eax
   1284b:	83 f8 04             	cmp    $0x4,%eax
   1284e:	75 14                	jne    12864 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
   12850:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12853:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12856:	89 c1                	mov    %eax,%ecx
   12858:	d3 ea                	shr    %cl,%edx
   1285a:	8b 45 08             	mov    0x8(%ebp),%eax
   1285d:	89 10                	mov    %edx,(%eax)
   1285f:	e9 33 01 00 00       	jmp    12997 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
   12864:	8b 45 20             	mov    0x20(%ebp),%eax
   12867:	8b 00                	mov    (%eax),%eax
   12869:	83 f8 02             	cmp    $0x2,%eax
   1286c:	74 0a                	je     12878 <lodepng_convert_rgb+0x17b>
   1286e:	8b 45 20             	mov    0x20(%ebp),%eax
   12871:	8b 00                	mov    (%eax),%eax
   12873:	83 f8 06             	cmp    $0x6,%eax
   12876:	75 32                	jne    128aa <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
   12878:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1287b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1287e:	89 c1                	mov    %eax,%ecx
   12880:	d3 ea                	shr    %cl,%edx
   12882:	8b 45 08             	mov    0x8(%ebp),%eax
   12885:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
   12887:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1288a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1288d:	89 c1                	mov    %eax,%ecx
   1288f:	d3 ea                	shr    %cl,%edx
   12891:	8b 45 0c             	mov    0xc(%ebp),%eax
   12894:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
   12896:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12899:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1289c:	89 c1                	mov    %eax,%ecx
   1289e:	d3 ea                	shr    %cl,%edx
   128a0:	8b 45 10             	mov    0x10(%ebp),%eax
   128a3:	89 10                	mov    %edx,(%eax)
   128a5:	e9 ed 00 00 00       	jmp    12997 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
   128aa:	8b 45 20             	mov    0x20(%ebp),%eax
   128ad:	8b 00                	mov    (%eax),%eax
   128af:	83 f8 03             	cmp    $0x3,%eax
   128b2:	0f 85 d8 00 00 00    	jne    12990 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
   128b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   128bb:	c1 e8 08             	shr    $0x8,%eax
   128be:	89 c2                	mov    %eax,%edx
   128c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   128c3:	0f b6 c0             	movzbl %al,%eax
   128c6:	39 c2                	cmp    %eax,%edx
   128c8:	75 24                	jne    128ee <lodepng_convert_rgb+0x1f1>
   128ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
   128cd:	c1 e8 08             	shr    $0x8,%eax
   128d0:	89 c2                	mov    %eax,%edx
   128d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   128d5:	0f b6 c0             	movzbl %al,%eax
   128d8:	39 c2                	cmp    %eax,%edx
   128da:	75 12                	jne    128ee <lodepng_convert_rgb+0x1f1>
   128dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   128df:	c1 e8 08             	shr    $0x8,%eax
   128e2:	89 c2                	mov    %eax,%edx
   128e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   128e7:	0f b6 c0             	movzbl %al,%eax
   128ea:	39 c2                	cmp    %eax,%edx
   128ec:	74 0a                	je     128f8 <lodepng_convert_rgb+0x1fb>
   128ee:	b8 52 00 00 00       	mov    $0x52,%eax
   128f3:	e9 a4 00 00 00       	jmp    1299c <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
   128f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   128ff:	eb 79                	jmp    1297a <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
   12901:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12904:	c1 e0 02             	shl    $0x2,%eax
   12907:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
   1290a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1290d:	c1 e8 08             	shr    $0x8,%eax
   12910:	89 c1                	mov    %eax,%ecx
   12912:	8b 45 20             	mov    0x20(%ebp),%eax
   12915:	8b 50 08             	mov    0x8(%eax),%edx
   12918:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1291b:	01 d0                	add    %edx,%eax
   1291d:	0f b6 00             	movzbl (%eax),%eax
   12920:	0f b6 c0             	movzbl %al,%eax
   12923:	39 c1                	cmp    %eax,%ecx
   12925:	75 4f                	jne    12976 <lodepng_convert_rgb+0x279>
   12927:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1292a:	c1 e8 08             	shr    $0x8,%eax
   1292d:	89 c1                	mov    %eax,%ecx
   1292f:	8b 45 20             	mov    0x20(%ebp),%eax
   12932:	8b 40 08             	mov    0x8(%eax),%eax
   12935:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   12938:	83 c2 01             	add    $0x1,%edx
   1293b:	01 d0                	add    %edx,%eax
   1293d:	0f b6 00             	movzbl (%eax),%eax
   12940:	0f b6 c0             	movzbl %al,%eax
   12943:	39 c1                	cmp    %eax,%ecx
   12945:	75 2f                	jne    12976 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
   12947:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1294a:	c1 e8 08             	shr    $0x8,%eax
   1294d:	89 c1                	mov    %eax,%ecx
   1294f:	8b 45 20             	mov    0x20(%ebp),%eax
   12952:	8b 40 08             	mov    0x8(%eax),%eax
   12955:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   12958:	83 c2 02             	add    $0x2,%edx
   1295b:	01 d0                	add    %edx,%eax
   1295d:	0f b6 00             	movzbl (%eax),%eax
   12960:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
   12963:	39 c1                	cmp    %eax,%ecx
   12965:	75 0f                	jne    12976 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
   12967:	8b 45 08             	mov    0x8(%ebp),%eax
   1296a:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1296d:	89 10                	mov    %edx,(%eax)
        return 0;
   1296f:	b8 00 00 00 00       	mov    $0x0,%eax
   12974:	eb 26                	jmp    1299c <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
   12976:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1297a:	8b 45 20             	mov    0x20(%ebp),%eax
   1297d:	8b 40 0c             	mov    0xc(%eax),%eax
   12980:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   12983:	0f 87 78 ff ff ff    	ja     12901 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
   12989:	b8 52 00 00 00       	mov    $0x52,%eax
   1298e:	eb 0c                	jmp    1299c <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
   12990:	b8 1f 00 00 00       	mov    $0x1f,%eax
   12995:	eb 05                	jmp    1299c <lodepng_convert_rgb+0x29f>
  }

  return 0;
   12997:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1299c:	c9                   	leave  
   1299d:	c3                   	ret    

0001299e <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
   1299e:	55                   	push   %ebp
   1299f:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
   129a1:	8b 45 08             	mov    0x8(%ebp),%eax
   129a4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
   129aa:	8b 45 08             	mov    0x8(%ebp),%eax
   129ad:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
   129b4:	8b 45 08             	mov    0x8(%ebp),%eax
   129b7:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
   129bd:	8b 45 08             	mov    0x8(%ebp),%eax
   129c0:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
   129c4:	8b 45 08             	mov    0x8(%ebp),%eax
   129c7:	66 89 50 0a          	mov    %dx,0xa(%eax)
   129cb:	8b 45 08             	mov    0x8(%ebp),%eax
   129ce:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
   129d2:	8b 45 08             	mov    0x8(%ebp),%eax
   129d5:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
   129d9:	8b 45 08             	mov    0x8(%ebp),%eax
   129dc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
   129e3:	8b 45 08             	mov    0x8(%ebp),%eax
   129e6:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
   129ed:	8b 45 08             	mov    0x8(%ebp),%eax
   129f0:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
   129f7:	00 00 00 
  stats->numpixels = 0;
   129fa:	8b 45 08             	mov    0x8(%ebp),%eax
   129fd:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
   12a04:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
   12a07:	8b 45 08             	mov    0x8(%ebp),%eax
   12a0a:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
   12a11:	00 00 00 
  stats->allow_greyscale = 1;
   12a14:	8b 45 08             	mov    0x8(%ebp),%eax
   12a17:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
   12a1e:	00 00 00 
}
   12a21:	90                   	nop
   12a22:	5d                   	pop    %ebp
   12a23:	c3                   	ret    

00012a24 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
   12a24:	55                   	push   %ebp
   12a25:	89 e5                	mov    %esp,%ebp
   12a27:	53                   	push   %ebx
   12a28:	83 ec 04             	sub    $0x4,%esp
   12a2b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a2e:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
   12a31:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
   12a35:	74 06                	je     12a3d <getValueRequiredBits+0x19>
   12a37:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
   12a3b:	75 07                	jne    12a44 <getValueRequiredBits+0x20>
   12a3d:	b8 01 00 00 00       	mov    $0x1,%eax
   12a42:	eb 6b                	jmp    12aaf <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
   12a44:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
   12a48:	0f b6 d9             	movzbl %cl,%ebx
   12a4b:	89 da                	mov    %ebx,%edx
   12a4d:	89 d0                	mov    %edx,%eax
   12a4f:	c1 e0 04             	shl    $0x4,%eax
   12a52:	89 c2                	mov    %eax,%edx
   12a54:	89 d0                	mov    %edx,%eax
   12a56:	c1 e0 04             	shl    $0x4,%eax
   12a59:	29 d0                	sub    %edx,%eax
   12a5b:	01 d8                	add    %ebx,%eax
   12a5d:	66 c1 e8 08          	shr    $0x8,%ax
   12a61:	c0 e8 04             	shr    $0x4,%al
   12a64:	89 c2                	mov    %eax,%edx
   12a66:	c1 e2 04             	shl    $0x4,%edx
   12a69:	01 c2                	add    %eax,%edx
   12a6b:	89 c8                	mov    %ecx,%eax
   12a6d:	29 d0                	sub    %edx,%eax
   12a6f:	84 c0                	test   %al,%al
   12a71:	75 37                	jne    12aaa <getValueRequiredBits+0x86>
   12a73:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
   12a77:	0f b6 d1             	movzbl %cl,%edx
   12a7a:	89 d0                	mov    %edx,%eax
   12a7c:	01 c0                	add    %eax,%eax
   12a7e:	01 d0                	add    %edx,%eax
   12a80:	c1 e0 06             	shl    $0x6,%eax
   12a83:	01 d0                	add    %edx,%eax
   12a85:	66 c1 e8 08          	shr    $0x8,%ax
   12a89:	c0 e8 06             	shr    $0x6,%al
   12a8c:	ba 55 00 00 00       	mov    $0x55,%edx
   12a91:	0f af c2             	imul   %edx,%eax
   12a94:	29 c1                	sub    %eax,%ecx
   12a96:	89 c8                	mov    %ecx,%eax
   12a98:	84 c0                	test   %al,%al
   12a9a:	75 07                	jne    12aa3 <getValueRequiredBits+0x7f>
   12a9c:	b8 02 00 00 00       	mov    $0x2,%eax
   12aa1:	eb 0c                	jmp    12aaf <getValueRequiredBits+0x8b>
   12aa3:	b8 04 00 00 00       	mov    $0x4,%eax
   12aa8:	eb 05                	jmp    12aaf <getValueRequiredBits+0x8b>
  return 8;
   12aaa:	b8 08 00 00 00       	mov    $0x8,%eax
}
   12aaf:	83 c4 04             	add    $0x4,%esp
   12ab2:	5b                   	pop    %ebx
   12ab3:	5d                   	pop    %ebp
   12ab4:	c3                   	ret    

00012ab5 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
   12ab5:	55                   	push   %ebp
   12ab6:	89 e5                	mov    %esp,%ebp
   12ab8:	56                   	push   %esi
   12ab9:	53                   	push   %ebx
   12aba:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
   12ac0:	8b 55 10             	mov    0x10(%ebp),%edx
   12ac3:	8b 45 14             	mov    0x14(%ebp),%eax
   12ac6:	0f af c2             	imul   %edx,%eax
   12ac9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
   12acc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
   12ad3:	ff 75 18             	pushl  0x18(%ebp)
   12ad6:	e8 0b cd ff ff       	call   f7e6 <lodepng_is_greyscale_type>
   12adb:	83 c4 04             	add    $0x4,%esp
   12ade:	85 c0                	test   %eax,%eax
   12ae0:	0f 95 c0             	setne  %al
   12ae3:	0f b6 c0             	movzbl %al,%eax
   12ae6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
   12ae9:	ff 75 18             	pushl  0x18(%ebp)
   12aec:	e8 85 cd ff ff       	call   f876 <lodepng_can_have_alpha>
   12af1:	83 c4 04             	add    $0x4,%esp
   12af4:	85 c0                	test   %eax,%eax
   12af6:	0f 94 c0             	sete   %al
   12af9:	0f b6 c0             	movzbl %al,%eax
   12afc:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
   12aff:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
   12b06:	ff 75 18             	pushl  0x18(%ebp)
   12b09:	e8 ab cc ff ff       	call   f7b9 <lodepng_get_bpp>
   12b0e:	83 c4 04             	add    $0x4,%esp
   12b11:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
   12b14:	8b 45 08             	mov    0x8(%ebp),%eax
   12b17:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   12b1d:	83 f8 01             	cmp    $0x1,%eax
   12b20:	75 0d                	jne    12b2f <lodepng_compute_color_stats+0x7a>
   12b22:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
   12b26:	75 07                	jne    12b2f <lodepng_compute_color_stats+0x7a>
   12b28:	b8 01 00 00 00       	mov    $0x1,%eax
   12b2d:	eb 05                	jmp    12b34 <lodepng_compute_color_stats+0x7f>
   12b2f:	b8 00 00 00 00       	mov    $0x0,%eax
   12b34:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
   12b37:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
   12b3e:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
   12b45:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
   12b49:	77 26                	ja     12b71 <lodepng_compute_color_stats+0xbc>
   12b4b:	8b 45 08             	mov    0x8(%ebp),%eax
   12b4e:	8b 50 14             	mov    0x14(%eax),%edx
   12b51:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12b54:	bb 01 00 00 00       	mov    $0x1,%ebx
   12b59:	89 c1                	mov    %eax,%ecx
   12b5b:	d3 e3                	shl    %cl,%ebx
   12b5d:	89 d8                	mov    %ebx,%eax
   12b5f:	01 d0                	add    %edx,%eax
   12b61:	ba 01 01 00 00       	mov    $0x101,%edx
   12b66:	3d 01 01 00 00       	cmp    $0x101,%eax
   12b6b:	0f 47 c2             	cmova  %edx,%eax
   12b6e:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
   12b71:	8b 45 08             	mov    0x8(%ebp),%eax
   12b74:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   12b7a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   12b7d:	01 c2                	add    %eax,%edx
   12b7f:	8b 45 08             	mov    0x8(%ebp),%eax
   12b82:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
   12b88:	8b 45 08             	mov    0x8(%ebp),%eax
   12b8b:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
   12b91:	85 c0                	test   %eax,%eax
   12b93:	75 07                	jne    12b9c <lodepng_compute_color_stats+0xe7>
   12b95:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
   12b9c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12ba2:	50                   	push   %eax
   12ba3:	e8 81 da ff ff       	call   10629 <color_tree_init>
   12ba8:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
   12bab:	8b 45 08             	mov    0x8(%ebp),%eax
   12bae:	8b 40 10             	mov    0x10(%eax),%eax
   12bb1:	85 c0                	test   %eax,%eax
   12bb3:	74 07                	je     12bbc <lodepng_compute_color_stats+0x107>
   12bb5:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
   12bbc:	8b 45 08             	mov    0x8(%ebp),%eax
   12bbf:	8b 00                	mov    (%eax),%eax
   12bc1:	85 c0                	test   %eax,%eax
   12bc3:	74 07                	je     12bcc <lodepng_compute_color_stats+0x117>
   12bc5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
   12bcc:	8b 45 08             	mov    0x8(%ebp),%eax
   12bcf:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   12bd5:	83 f8 10             	cmp    $0x10,%eax
   12bd8:	75 07                	jne    12be1 <lodepng_compute_color_stats+0x12c>
   12bda:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
   12be1:	8b 45 08             	mov    0x8(%ebp),%eax
   12be4:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   12bea:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12bed:	72 07                	jb     12bf6 <lodepng_compute_color_stats+0x141>
   12bef:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
   12bf6:	8b 45 08             	mov    0x8(%ebp),%eax
   12bf9:	8b 40 14             	mov    0x14(%eax),%eax
   12bfc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
   12bff:	72 07                	jb     12c08 <lodepng_compute_color_stats+0x153>
   12c01:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
   12c08:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12c0c:	0f 85 82 00 00 00    	jne    12c94 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
   12c12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12c19:	eb 6c                	jmp    12c87 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
   12c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12c1e:	c1 e0 02             	shl    $0x2,%eax
   12c21:	8d 50 10             	lea    0x10(%eax),%edx
   12c24:	8b 45 08             	mov    0x8(%ebp),%eax
   12c27:	01 d0                	add    %edx,%eax
   12c29:	83 c0 08             	add    $0x8,%eax
   12c2c:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
   12c2f:	8b 75 f4             	mov    -0xc(%ebp),%esi
   12c32:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12c35:	83 c0 03             	add    $0x3,%eax
   12c38:	0f b6 00             	movzbl (%eax),%eax
   12c3b:	0f b6 d8             	movzbl %al,%ebx
   12c3e:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12c41:	83 c0 02             	add    $0x2,%eax
   12c44:	0f b6 00             	movzbl (%eax),%eax
   12c47:	0f b6 c8             	movzbl %al,%ecx
   12c4a:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12c4d:	83 c0 01             	add    $0x1,%eax
   12c50:	0f b6 00             	movzbl (%eax),%eax
   12c53:	0f b6 d0             	movzbl %al,%edx
   12c56:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12c59:	0f b6 00             	movzbl (%eax),%eax
   12c5c:	0f b6 c0             	movzbl %al,%eax
   12c5f:	83 ec 08             	sub    $0x8,%esp
   12c62:	56                   	push   %esi
   12c63:	53                   	push   %ebx
   12c64:	51                   	push   %ecx
   12c65:	52                   	push   %edx
   12c66:	50                   	push   %eax
   12c67:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12c6d:	50                   	push   %eax
   12c6e:	e8 39 db ff ff       	call   107ac <color_tree_add>
   12c73:	83 c4 20             	add    $0x20,%esp
   12c76:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
   12c79:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12c7d:	0f 85 22 09 00 00    	jne    135a5 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
   12c83:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12c87:	8b 45 08             	mov    0x8(%ebp),%eax
   12c8a:	8b 50 14             	mov    0x14(%eax),%edx
   12c8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12c90:	39 c2                	cmp    %eax,%edx
   12c92:	77 87                	ja     12c1b <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
   12c94:	8b 45 18             	mov    0x18(%ebp),%eax
   12c97:	8b 40 04             	mov    0x4(%eax),%eax
   12c9a:	83 f8 10             	cmp    $0x10,%eax
   12c9d:	0f 85 1e 01 00 00    	jne    12dc1 <lodepng_compute_color_stats+0x30c>
   12ca3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   12ca7:	0f 85 14 01 00 00    	jne    12dc1 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
   12cad:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
   12cb4:	00 00 
   12cb6:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
   12cbd:	00 00 
   12cbf:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
   12cc6:	00 00 
   12cc8:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
   12ccf:	00 00 
    for(i = 0; i != numpixels; ++i) {
   12cd1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12cd8:	e9 d8 00 00 00       	jmp    12db5 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
   12cdd:	83 ec 04             	sub    $0x4,%esp
   12ce0:	ff 75 18             	pushl  0x18(%ebp)
   12ce3:	ff 75 f4             	pushl  -0xc(%ebp)
   12ce6:	ff 75 0c             	pushl  0xc(%ebp)
   12ce9:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
   12cef:	50                   	push   %eax
   12cf0:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
   12cf6:	50                   	push   %eax
   12cf7:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
   12cfd:	50                   	push   %eax
   12cfe:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
   12d04:	50                   	push   %eax
   12d05:	e8 a8 f2 ff ff       	call   11fb2 <getPixelColorRGBA16>
   12d0a:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
   12d0d:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
   12d14:	66 c1 e8 08          	shr    $0x8,%ax
   12d18:	89 c2                	mov    %eax,%edx
   12d1a:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
   12d21:	31 d0                	xor    %edx,%eax
   12d23:	0f b7 c0             	movzwl %ax,%eax
   12d26:	0f b6 c0             	movzbl %al,%eax
   12d29:	85 c0                	test   %eax,%eax
   12d2b:	75 60                	jne    12d8d <lodepng_compute_color_stats+0x2d8>
   12d2d:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
   12d34:	66 c1 e8 08          	shr    $0x8,%ax
   12d38:	89 c2                	mov    %eax,%edx
   12d3a:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
   12d41:	31 d0                	xor    %edx,%eax
   12d43:	0f b7 c0             	movzwl %ax,%eax
   12d46:	0f b6 c0             	movzbl %al,%eax
   12d49:	85 c0                	test   %eax,%eax
   12d4b:	75 40                	jne    12d8d <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
   12d4d:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
   12d54:	66 c1 e8 08          	shr    $0x8,%ax
   12d58:	89 c2                	mov    %eax,%edx
   12d5a:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
   12d61:	31 d0                	xor    %edx,%eax
   12d63:	0f b7 c0             	movzwl %ax,%eax
   12d66:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
   12d69:	85 c0                	test   %eax,%eax
   12d6b:	75 20                	jne    12d8d <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
   12d6d:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
   12d74:	66 c1 e8 08          	shr    $0x8,%ax
   12d78:	89 c2                	mov    %eax,%edx
   12d7a:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
   12d81:	31 d0                	xor    %edx,%eax
   12d83:	0f b7 c0             	movzwl %ax,%eax
   12d86:	0f b6 c0             	movzbl %al,%eax
   12d89:	85 c0                	test   %eax,%eax
   12d8b:	74 24                	je     12db1 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
   12d8d:	8b 45 08             	mov    0x8(%ebp),%eax
   12d90:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
   12d97:	00 00 00 
        sixteen = 1;
   12d9a:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
   12da1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
   12da8:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
   12daf:	eb 10                	jmp    12dc1 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
   12db1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12db5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12db8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   12dbb:	0f 85 1c ff ff ff    	jne    12cdd <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
   12dc1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   12dc5:	0f 84 bd 02 00 00    	je     13088 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
   12dcb:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
   12dd2:	00 00 
   12dd4:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
   12ddb:	00 00 
   12ddd:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
   12de4:	00 00 
   12de6:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
   12ded:	00 00 

    for(i = 0; i != numpixels; ++i) {
   12def:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12df6:	e9 b1 01 00 00       	jmp    12fac <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
   12dfb:	83 ec 04             	sub    $0x4,%esp
   12dfe:	ff 75 18             	pushl  0x18(%ebp)
   12e01:	ff 75 f4             	pushl  -0xc(%ebp)
   12e04:	ff 75 0c             	pushl  0xc(%ebp)
   12e07:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
   12e0d:	50                   	push   %eax
   12e0e:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
   12e14:	50                   	push   %eax
   12e15:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
   12e1b:	50                   	push   %eax
   12e1c:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
   12e22:	50                   	push   %eax
   12e23:	e8 8a f1 ff ff       	call   11fb2 <getPixelColorRGBA16>
   12e28:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
   12e2b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12e2f:	75 36                	jne    12e67 <lodepng_compute_color_stats+0x3b2>
   12e31:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
   12e38:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
   12e3f:	66 39 c2             	cmp    %ax,%dx
   12e42:	75 13                	jne    12e57 <lodepng_compute_color_stats+0x3a2>
   12e44:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
   12e4b:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
   12e52:	66 39 c2             	cmp    %ax,%dx
   12e55:	74 10                	je     12e67 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
   12e57:	8b 45 08             	mov    0x8(%ebp),%eax
   12e5a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
   12e60:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
   12e67:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12e6b:	0f 85 1f 01 00 00    	jne    12f90 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
   12e71:	8b 45 08             	mov    0x8(%ebp),%eax
   12e74:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   12e78:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
   12e7f:	66 39 c2             	cmp    %ax,%dx
   12e82:	75 2d                	jne    12eb1 <lodepng_compute_color_stats+0x3fc>
   12e84:	8b 45 08             	mov    0x8(%ebp),%eax
   12e87:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
   12e8b:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
   12e92:	66 39 c2             	cmp    %ax,%dx
   12e95:	75 1a                	jne    12eb1 <lodepng_compute_color_stats+0x3fc>
   12e97:	8b 45 08             	mov    0x8(%ebp),%eax
   12e9a:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
   12e9e:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
   12ea5:	66 39 c2             	cmp    %ax,%dx
   12ea8:	75 07                	jne    12eb1 <lodepng_compute_color_stats+0x3fc>
   12eaa:	b8 01 00 00 00       	mov    $0x1,%eax
   12eaf:	eb 05                	jmp    12eb6 <lodepng_compute_color_stats+0x401>
   12eb1:	b8 00 00 00 00       	mov    $0x0,%eax
   12eb6:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
   12eb9:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   12ec0:	66 83 f8 ff          	cmp    $0xffff,%ax
   12ec4:	74 3c                	je     12f02 <lodepng_compute_color_stats+0x44d>
   12ec6:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   12ecd:	66 85 c0             	test   %ax,%ax
   12ed0:	75 10                	jne    12ee2 <lodepng_compute_color_stats+0x42d>
   12ed2:	8b 45 08             	mov    0x8(%ebp),%eax
   12ed5:	8b 40 04             	mov    0x4(%eax),%eax
   12ed8:	85 c0                	test   %eax,%eax
   12eda:	74 26                	je     12f02 <lodepng_compute_color_stats+0x44d>
   12edc:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12ee0:	75 20                	jne    12f02 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
   12ee2:	8b 45 08             	mov    0x8(%ebp),%eax
   12ee5:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   12eec:	8b 45 08             	mov    0x8(%ebp),%eax
   12eef:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   12ef6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
   12efd:	e9 8e 00 00 00       	jmp    12f90 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
   12f02:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   12f09:	66 85 c0             	test   %ax,%ax
   12f0c:	75 4a                	jne    12f58 <lodepng_compute_color_stats+0x4a3>
   12f0e:	8b 45 08             	mov    0x8(%ebp),%eax
   12f11:	8b 40 10             	mov    0x10(%eax),%eax
   12f14:	85 c0                	test   %eax,%eax
   12f16:	75 40                	jne    12f58 <lodepng_compute_color_stats+0x4a3>
   12f18:	8b 45 08             	mov    0x8(%ebp),%eax
   12f1b:	8b 40 04             	mov    0x4(%eax),%eax
   12f1e:	85 c0                	test   %eax,%eax
   12f20:	75 36                	jne    12f58 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
   12f22:	8b 45 08             	mov    0x8(%ebp),%eax
   12f25:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
   12f2c:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
   12f33:	8b 45 08             	mov    0x8(%ebp),%eax
   12f36:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
   12f3a:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
   12f41:	8b 45 08             	mov    0x8(%ebp),%eax
   12f44:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
   12f48:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
   12f4f:	8b 45 08             	mov    0x8(%ebp),%eax
   12f52:	66 89 50 0c          	mov    %dx,0xc(%eax)
   12f56:	eb 38                	jmp    12f90 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
   12f58:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   12f5f:	66 83 f8 ff          	cmp    $0xffff,%ax
   12f63:	75 2b                	jne    12f90 <lodepng_compute_color_stats+0x4db>
   12f65:	8b 45 08             	mov    0x8(%ebp),%eax
   12f68:	8b 40 04             	mov    0x4(%eax),%eax
   12f6b:	85 c0                	test   %eax,%eax
   12f6d:	74 21                	je     12f90 <lodepng_compute_color_stats+0x4db>
   12f6f:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12f73:	74 1b                	je     12f90 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
   12f75:	8b 45 08             	mov    0x8(%ebp),%eax
   12f78:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   12f7f:	8b 45 08             	mov    0x8(%ebp),%eax
   12f82:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   12f89:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
   12f90:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12f94:	74 12                	je     12fa8 <lodepng_compute_color_stats+0x4f3>
   12f96:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12f9a:	74 0c                	je     12fa8 <lodepng_compute_color_stats+0x4f3>
   12f9c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12fa0:	74 06                	je     12fa8 <lodepng_compute_color_stats+0x4f3>
   12fa2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   12fa6:	75 12                	jne    12fba <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
   12fa8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12fac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12faf:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   12fb2:	0f 85 43 fe ff ff    	jne    12dfb <lodepng_compute_color_stats+0x346>
   12fb8:	eb 01                	jmp    12fbb <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
   12fba:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
   12fbb:	8b 45 08             	mov    0x8(%ebp),%eax
   12fbe:	8b 40 04             	mov    0x4(%eax),%eax
   12fc1:	85 c0                	test   %eax,%eax
   12fc3:	0f 84 e0 05 00 00    	je     135a9 <lodepng_compute_color_stats+0xaf4>
   12fc9:	8b 45 08             	mov    0x8(%ebp),%eax
   12fcc:	8b 40 10             	mov    0x10(%eax),%eax
   12fcf:	85 c0                	test   %eax,%eax
   12fd1:	0f 85 d2 05 00 00    	jne    135a9 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
   12fd7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12fde:	e9 94 00 00 00       	jmp    13077 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
   12fe3:	83 ec 04             	sub    $0x4,%esp
   12fe6:	ff 75 18             	pushl  0x18(%ebp)
   12fe9:	ff 75 f4             	pushl  -0xc(%ebp)
   12fec:	ff 75 0c             	pushl  0xc(%ebp)
   12fef:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
   12ff5:	50                   	push   %eax
   12ff6:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
   12ffc:	50                   	push   %eax
   12ffd:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
   13003:	50                   	push   %eax
   13004:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
   1300a:	50                   	push   %eax
   1300b:	e8 a2 ef ff ff       	call   11fb2 <getPixelColorRGBA16>
   13010:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
   13013:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   1301a:	66 85 c0             	test   %ax,%ax
   1301d:	74 54                	je     13073 <lodepng_compute_color_stats+0x5be>
   1301f:	8b 45 08             	mov    0x8(%ebp),%eax
   13022:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   13026:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
   1302d:	66 39 c2             	cmp    %ax,%dx
   13030:	75 41                	jne    13073 <lodepng_compute_color_stats+0x5be>
   13032:	8b 45 08             	mov    0x8(%ebp),%eax
   13035:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
   13039:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
   13040:	66 39 c2             	cmp    %ax,%dx
   13043:	75 2e                	jne    13073 <lodepng_compute_color_stats+0x5be>
   13045:	8b 45 08             	mov    0x8(%ebp),%eax
   13048:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
   1304c:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
   13053:	66 39 c2             	cmp    %ax,%dx
   13056:	75 1b                	jne    13073 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
   13058:	8b 45 08             	mov    0x8(%ebp),%eax
   1305b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   13062:	8b 45 08             	mov    0x8(%ebp),%eax
   13065:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   1306c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
   13073:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13077:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1307a:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   1307d:	0f 85 60 ff ff ff    	jne    12fe3 <lodepng_compute_color_stats+0x52e>
   13083:	e9 21 05 00 00       	jmp    135a9 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
   13088:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
   1308f:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
   13096:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
   1309d:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
   130a4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   130ab:	e9 ab 03 00 00       	jmp    1345b <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
   130b0:	83 ec 04             	sub    $0x4,%esp
   130b3:	ff 75 18             	pushl  0x18(%ebp)
   130b6:	ff 75 f4             	pushl  -0xc(%ebp)
   130b9:	ff 75 0c             	pushl  0xc(%ebp)
   130bc:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
   130c2:	50                   	push   %eax
   130c3:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
   130c9:	50                   	push   %eax
   130ca:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
   130d0:	50                   	push   %eax
   130d1:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
   130d7:	50                   	push   %eax
   130d8:	e8 1e de ff ff       	call   10efb <getPixelColorRGBA8>
   130dd:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
   130e0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   130e4:	75 41                	jne    13127 <lodepng_compute_color_stats+0x672>
   130e6:	8b 45 08             	mov    0x8(%ebp),%eax
   130e9:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   130ef:	83 f8 07             	cmp    $0x7,%eax
   130f2:	77 33                	ja     13127 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
   130f4:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   130fb:	0f b6 c0             	movzbl %al,%eax
   130fe:	83 ec 0c             	sub    $0xc,%esp
   13101:	50                   	push   %eax
   13102:	e8 1d f9 ff ff       	call   12a24 <getValueRequiredBits>
   13107:	83 c4 10             	add    $0x10,%esp
   1310a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
   1310d:	8b 45 08             	mov    0x8(%ebp),%eax
   13110:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   13116:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   13119:	73 0c                	jae    13127 <lodepng_compute_color_stats+0x672>
   1311b:	8b 45 08             	mov    0x8(%ebp),%eax
   1311e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   13121:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
   13127:	8b 45 08             	mov    0x8(%ebp),%eax
   1312a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   13130:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   13133:	0f 93 c0             	setae  %al
   13136:	0f b6 c0             	movzbl %al,%eax
   13139:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
   1313c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13140:	75 4f                	jne    13191 <lodepng_compute_color_stats+0x6dc>
   13142:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
   13149:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   13150:	38 c2                	cmp    %al,%dl
   13152:	75 12                	jne    13166 <lodepng_compute_color_stats+0x6b1>
   13154:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
   1315b:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   13162:	38 c2                	cmp    %al,%dl
   13164:	74 2b                	je     13191 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
   13166:	8b 45 08             	mov    0x8(%ebp),%eax
   13169:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
   1316f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
   13176:	8b 45 08             	mov    0x8(%ebp),%eax
   13179:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   1317f:	83 f8 07             	cmp    $0x7,%eax
   13182:	77 0d                	ja     13191 <lodepng_compute_color_stats+0x6dc>
   13184:	8b 45 08             	mov    0x8(%ebp),%eax
   13187:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
   1318e:	00 00 00 
      }

      if(!alpha_done) {
   13191:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   13195:	0f 85 65 01 00 00    	jne    13300 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
   1319b:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   131a2:	0f b6 d0             	movzbl %al,%edx
   131a5:	8b 45 08             	mov    0x8(%ebp),%eax
   131a8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   131ac:	66 39 c2             	cmp    %ax,%dx
   131af:	75 33                	jne    131e4 <lodepng_compute_color_stats+0x72f>
   131b1:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   131b8:	0f b6 d0             	movzbl %al,%edx
   131bb:	8b 45 08             	mov    0x8(%ebp),%eax
   131be:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   131c2:	66 39 c2             	cmp    %ax,%dx
   131c5:	75 1d                	jne    131e4 <lodepng_compute_color_stats+0x72f>
   131c7:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   131ce:	0f b6 d0             	movzbl %al,%edx
   131d1:	8b 45 08             	mov    0x8(%ebp),%eax
   131d4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   131d8:	66 39 c2             	cmp    %ax,%dx
   131db:	75 07                	jne    131e4 <lodepng_compute_color_stats+0x72f>
   131dd:	b8 01 00 00 00       	mov    $0x1,%eax
   131e2:	eb 05                	jmp    131e9 <lodepng_compute_color_stats+0x734>
   131e4:	b8 00 00 00 00       	mov    $0x0,%eax
   131e9:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
   131ec:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   131f3:	3c ff                	cmp    $0xff,%al
   131f5:	74 5a                	je     13251 <lodepng_compute_color_stats+0x79c>
   131f7:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   131fe:	84 c0                	test   %al,%al
   13200:	75 10                	jne    13212 <lodepng_compute_color_stats+0x75d>
   13202:	8b 45 08             	mov    0x8(%ebp),%eax
   13205:	8b 40 04             	mov    0x4(%eax),%eax
   13208:	85 c0                	test   %eax,%eax
   1320a:	74 45                	je     13251 <lodepng_compute_color_stats+0x79c>
   1320c:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   13210:	75 3f                	jne    13251 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
   13212:	8b 45 08             	mov    0x8(%ebp),%eax
   13215:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   1321c:	8b 45 08             	mov    0x8(%ebp),%eax
   1321f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   13226:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
   1322d:	8b 45 08             	mov    0x8(%ebp),%eax
   13230:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   13236:	83 f8 07             	cmp    $0x7,%eax
   13239:	0f 87 c1 00 00 00    	ja     13300 <lodepng_compute_color_stats+0x84b>
   1323f:	8b 45 08             	mov    0x8(%ebp),%eax
   13242:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
   13249:	00 00 00 
   1324c:	e9 af 00 00 00       	jmp    13300 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
   13251:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   13258:	84 c0                	test   %al,%al
   1325a:	75 53                	jne    132af <lodepng_compute_color_stats+0x7fa>
   1325c:	8b 45 08             	mov    0x8(%ebp),%eax
   1325f:	8b 40 10             	mov    0x10(%eax),%eax
   13262:	85 c0                	test   %eax,%eax
   13264:	75 49                	jne    132af <lodepng_compute_color_stats+0x7fa>
   13266:	8b 45 08             	mov    0x8(%ebp),%eax
   13269:	8b 40 04             	mov    0x4(%eax),%eax
   1326c:	85 c0                	test   %eax,%eax
   1326e:	75 3f                	jne    132af <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
   13270:	8b 45 08             	mov    0x8(%ebp),%eax
   13273:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
   1327a:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   13281:	0f b6 d0             	movzbl %al,%edx
   13284:	8b 45 08             	mov    0x8(%ebp),%eax
   13287:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
   1328b:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   13292:	0f b6 d0             	movzbl %al,%edx
   13295:	8b 45 08             	mov    0x8(%ebp),%eax
   13298:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
   1329c:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   132a3:	0f b6 d0             	movzbl %al,%edx
   132a6:	8b 45 08             	mov    0x8(%ebp),%eax
   132a9:	66 89 50 0c          	mov    %dx,0xc(%eax)
   132ad:	eb 51                	jmp    13300 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
   132af:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   132b6:	3c ff                	cmp    $0xff,%al
   132b8:	75 46                	jne    13300 <lodepng_compute_color_stats+0x84b>
   132ba:	8b 45 08             	mov    0x8(%ebp),%eax
   132bd:	8b 40 04             	mov    0x4(%eax),%eax
   132c0:	85 c0                	test   %eax,%eax
   132c2:	74 3c                	je     13300 <lodepng_compute_color_stats+0x84b>
   132c4:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   132c8:	74 36                	je     13300 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
   132ca:	8b 45 08             	mov    0x8(%ebp),%eax
   132cd:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   132d4:	8b 45 08             	mov    0x8(%ebp),%eax
   132d7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   132de:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
   132e5:	8b 45 08             	mov    0x8(%ebp),%eax
   132e8:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   132ee:	83 f8 07             	cmp    $0x7,%eax
   132f1:	77 0d                	ja     13300 <lodepng_compute_color_stats+0x84b>
   132f3:	8b 45 08             	mov    0x8(%ebp),%eax
   132f6:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
   132fd:	00 00 00 
        }
      }

      if(!numcolors_done) {
   13300:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13304:	0f 85 35 01 00 00    	jne    1343f <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
   1330a:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   13311:	0f b6 d8             	movzbl %al,%ebx
   13314:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   1331b:	0f b6 c8             	movzbl %al,%ecx
   1331e:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   13325:	0f b6 d0             	movzbl %al,%edx
   13328:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   1332f:	0f b6 c0             	movzbl %al,%eax
   13332:	83 ec 0c             	sub    $0xc,%esp
   13335:	53                   	push   %ebx
   13336:	51                   	push   %ecx
   13337:	52                   	push   %edx
   13338:	50                   	push   %eax
   13339:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   1333f:	50                   	push   %eax
   13340:	e8 1c d4 ff ff       	call   10761 <color_tree_has>
   13345:	83 c4 20             	add    $0x20,%esp
   13348:	85 c0                	test   %eax,%eax
   1334a:	0f 85 ef 00 00 00    	jne    1343f <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
   13350:	8b 45 08             	mov    0x8(%ebp),%eax
   13353:	8b 70 14             	mov    0x14(%eax),%esi
   13356:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   1335d:	0f b6 d8             	movzbl %al,%ebx
   13360:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   13367:	0f b6 c8             	movzbl %al,%ecx
   1336a:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   13371:	0f b6 d0             	movzbl %al,%edx
   13374:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   1337b:	0f b6 c0             	movzbl %al,%eax
   1337e:	83 ec 08             	sub    $0x8,%esp
   13381:	56                   	push   %esi
   13382:	53                   	push   %ebx
   13383:	51                   	push   %ecx
   13384:	52                   	push   %edx
   13385:	50                   	push   %eax
   13386:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   1338c:	50                   	push   %eax
   1338d:	e8 1a d4 ff ff       	call   107ac <color_tree_add>
   13392:	83 c4 20             	add    $0x20,%esp
   13395:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
   13398:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1339c:	0f 85 06 02 00 00    	jne    135a8 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
   133a2:	8b 45 08             	mov    0x8(%ebp),%eax
   133a5:	8b 40 14             	mov    0x14(%eax),%eax
   133a8:	3d ff 00 00 00       	cmp    $0xff,%eax
   133ad:	77 6f                	ja     1341e <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
   133af:	8b 45 08             	mov    0x8(%ebp),%eax
   133b2:	83 c0 18             	add    $0x18,%eax
   133b5:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
   133b8:	8b 45 08             	mov    0x8(%ebp),%eax
   133bb:	8b 40 14             	mov    0x14(%eax),%eax
   133be:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
   133c1:	8b 45 b8             	mov    -0x48(%ebp),%eax
   133c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   133cb:	8b 45 bc             	mov    -0x44(%ebp),%eax
   133ce:	01 c2                	add    %eax,%edx
   133d0:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   133d7:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
   133d9:	8b 45 b8             	mov    -0x48(%ebp),%eax
   133dc:	c1 e0 02             	shl    $0x2,%eax
   133df:	8d 50 01             	lea    0x1(%eax),%edx
   133e2:	8b 45 bc             	mov    -0x44(%ebp),%eax
   133e5:	01 c2                	add    %eax,%edx
   133e7:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   133ee:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
   133f0:	8b 45 b8             	mov    -0x48(%ebp),%eax
   133f3:	c1 e0 02             	shl    $0x2,%eax
   133f6:	8d 50 02             	lea    0x2(%eax),%edx
   133f9:	8b 45 bc             	mov    -0x44(%ebp),%eax
   133fc:	01 c2                	add    %eax,%edx
   133fe:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   13405:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
   13407:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1340a:	c1 e0 02             	shl    $0x2,%eax
   1340d:	8d 50 03             	lea    0x3(%eax),%edx
   13410:	8b 45 bc             	mov    -0x44(%ebp),%eax
   13413:	01 c2                	add    %eax,%edx
   13415:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   1341c:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
   1341e:	8b 45 08             	mov    0x8(%ebp),%eax
   13421:	8b 40 14             	mov    0x14(%eax),%eax
   13424:	8d 50 01             	lea    0x1(%eax),%edx
   13427:	8b 45 08             	mov    0x8(%ebp),%eax
   1342a:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
   1342d:	8b 45 08             	mov    0x8(%ebp),%eax
   13430:	8b 40 14             	mov    0x14(%eax),%eax
   13433:	3b 45 d8             	cmp    -0x28(%ebp),%eax
   13436:	0f 93 c0             	setae  %al
   13439:	0f b6 c0             	movzbl %al,%eax
   1343c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
   1343f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   13443:	74 12                	je     13457 <lodepng_compute_color_stats+0x9a2>
   13445:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13449:	74 0c                	je     13457 <lodepng_compute_color_stats+0x9a2>
   1344b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1344f:	74 06                	je     13457 <lodepng_compute_color_stats+0x9a2>
   13451:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13455:	75 12                	jne    13469 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
   13457:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1345b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1345e:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   13461:	0f 85 49 fc ff ff    	jne    130b0 <lodepng_compute_color_stats+0x5fb>
   13467:	eb 01                	jmp    1346a <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
   13469:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
   1346a:	8b 45 08             	mov    0x8(%ebp),%eax
   1346d:	8b 40 04             	mov    0x4(%eax),%eax
   13470:	85 c0                	test   %eax,%eax
   13472:	0f 84 dd 00 00 00    	je     13555 <lodepng_compute_color_stats+0xaa0>
   13478:	8b 45 08             	mov    0x8(%ebp),%eax
   1347b:	8b 40 10             	mov    0x10(%eax),%eax
   1347e:	85 c0                	test   %eax,%eax
   13480:	0f 85 cf 00 00 00    	jne    13555 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
   13486:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1348d:	e9 b7 00 00 00       	jmp    13549 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
   13492:	83 ec 04             	sub    $0x4,%esp
   13495:	ff 75 18             	pushl  0x18(%ebp)
   13498:	ff 75 f4             	pushl  -0xc(%ebp)
   1349b:	ff 75 0c             	pushl  0xc(%ebp)
   1349e:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
   134a4:	50                   	push   %eax
   134a5:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
   134ab:	50                   	push   %eax
   134ac:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
   134b2:	50                   	push   %eax
   134b3:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
   134b9:	50                   	push   %eax
   134ba:	e8 3c da ff ff       	call   10efb <getPixelColorRGBA8>
   134bf:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
   134c2:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   134c9:	84 c0                	test   %al,%al
   134cb:	74 78                	je     13545 <lodepng_compute_color_stats+0xa90>
   134cd:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   134d4:	0f b6 d0             	movzbl %al,%edx
   134d7:	8b 45 08             	mov    0x8(%ebp),%eax
   134da:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   134de:	66 39 c2             	cmp    %ax,%dx
   134e1:	75 62                	jne    13545 <lodepng_compute_color_stats+0xa90>
   134e3:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   134ea:	0f b6 d0             	movzbl %al,%edx
   134ed:	8b 45 08             	mov    0x8(%ebp),%eax
   134f0:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   134f4:	66 39 c2             	cmp    %ax,%dx
   134f7:	75 4c                	jne    13545 <lodepng_compute_color_stats+0xa90>
   134f9:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   13500:	0f b6 d0             	movzbl %al,%edx
   13503:	8b 45 08             	mov    0x8(%ebp),%eax
   13506:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   1350a:	66 39 c2             	cmp    %ax,%dx
   1350d:	75 36                	jne    13545 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
   1350f:	8b 45 08             	mov    0x8(%ebp),%eax
   13512:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   13519:	8b 45 08             	mov    0x8(%ebp),%eax
   1351c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   13523:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
   1352a:	8b 45 08             	mov    0x8(%ebp),%eax
   1352d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   13533:	83 f8 07             	cmp    $0x7,%eax
   13536:	77 0d                	ja     13545 <lodepng_compute_color_stats+0xa90>
   13538:	8b 45 08             	mov    0x8(%ebp),%eax
   1353b:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
   13542:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
   13545:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13549:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1354c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   1354f:	0f 85 3d ff ff ff    	jne    13492 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
   13555:	8b 45 08             	mov    0x8(%ebp),%eax
   13558:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   1355c:	8b 45 08             	mov    0x8(%ebp),%eax
   1355f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   13563:	c1 e0 08             	shl    $0x8,%eax
   13566:	01 c2                	add    %eax,%edx
   13568:	8b 45 08             	mov    0x8(%ebp),%eax
   1356b:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
   1356f:	8b 45 08             	mov    0x8(%ebp),%eax
   13572:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
   13576:	8b 45 08             	mov    0x8(%ebp),%eax
   13579:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   1357d:	c1 e0 08             	shl    $0x8,%eax
   13580:	01 c2                	add    %eax,%edx
   13582:	8b 45 08             	mov    0x8(%ebp),%eax
   13585:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
   13589:	8b 45 08             	mov    0x8(%ebp),%eax
   1358c:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
   13590:	8b 45 08             	mov    0x8(%ebp),%eax
   13593:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   13597:	c1 e0 08             	shl    $0x8,%eax
   1359a:	01 c2                	add    %eax,%edx
   1359c:	8b 45 08             	mov    0x8(%ebp),%eax
   1359f:	66 89 50 0c          	mov    %dx,0xc(%eax)
   135a3:	eb 04                	jmp    135a9 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
   135a5:	90                   	nop
   135a6:	eb 01                	jmp    135a9 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
   135a8:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
   135a9:	83 ec 0c             	sub    $0xc,%esp
   135ac:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   135b2:	50                   	push   %eax
   135b3:	e8 91 d0 ff ff       	call   10649 <color_tree_cleanup>
   135b8:	83 c4 10             	add    $0x10,%esp
  return error;
   135bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   135be:	8d 65 f8             	lea    -0x8(%ebp),%esp
   135c1:	5b                   	pop    %ebx
   135c2:	5e                   	pop    %esi
   135c3:	5d                   	pop    %ebp
   135c4:	c3                   	ret    

000135c5 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
   135c5:	55                   	push   %ebp
   135c6:	89 e5                	mov    %esp,%ebp
   135c8:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
   135cb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
   135d2:	8d 45 cc             	lea    -0x34(%ebp),%eax
   135d5:	50                   	push   %eax
   135d6:	e8 d1 bd ff ff       	call   f3ac <lodepng_color_mode_init>
   135db:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
   135de:	8b 45 0c             	mov    0xc(%ebp),%eax
   135e1:	c1 e8 08             	shr    $0x8,%eax
   135e4:	88 45 ec             	mov    %al,-0x14(%ebp)
   135e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   135ea:	88 45 ed             	mov    %al,-0x13(%ebp)
   135ed:	8b 45 10             	mov    0x10(%ebp),%eax
   135f0:	c1 e8 08             	shr    $0x8,%eax
   135f3:	88 45 ee             	mov    %al,-0x12(%ebp)
   135f6:	8b 45 10             	mov    0x10(%ebp),%eax
   135f9:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
   135fc:	8b 45 14             	mov    0x14(%ebp),%eax
   135ff:	c1 e8 08             	shr    $0x8,%eax
   13602:	88 45 f0             	mov    %al,-0x10(%ebp)
   13605:	8b 45 14             	mov    0x14(%ebp),%eax
   13608:	88 45 f1             	mov    %al,-0xf(%ebp)
   1360b:	8b 45 18             	mov    0x18(%ebp),%eax
   1360e:	c1 e8 08             	shr    $0x8,%eax
   13611:	88 45 f2             	mov    %al,-0xe(%ebp)
   13614:	8b 45 18             	mov    0x18(%ebp),%eax
   13617:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
   1361a:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
   13621:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
   13628:	83 ec 0c             	sub    $0xc,%esp
   1362b:	8d 45 cc             	lea    -0x34(%ebp),%eax
   1362e:	50                   	push   %eax
   1362f:	6a 01                	push   $0x1
   13631:	6a 01                	push   $0x1
   13633:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13636:	50                   	push   %eax
   13637:	ff 75 08             	pushl  0x8(%ebp)
   1363a:	e8 76 f4 ff ff       	call   12ab5 <lodepng_compute_color_stats>
   1363f:	83 c4 20             	add    $0x20,%esp
   13642:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
   13645:	83 ec 0c             	sub    $0xc,%esp
   13648:	8d 45 cc             	lea    -0x34(%ebp),%eax
   1364b:	50                   	push   %eax
   1364c:	e8 4e be ff ff       	call   f49f <lodepng_color_mode_cleanup>
   13651:	83 c4 10             	add    $0x10,%esp
  return error;
   13654:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13657:	c9                   	leave  
   13658:	c3                   	ret    

00013659 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
   13659:	55                   	push   %ebp
   1365a:	89 e5                	mov    %esp,%ebp
   1365c:	56                   	push   %esi
   1365d:	53                   	push   %ebx
   1365e:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
   13661:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
   13668:	8b 45 10             	mov    0x10(%ebp),%eax
   1366b:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
   13671:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
   13674:	8b 45 10             	mov    0x10(%ebp),%eax
   13677:	8b 40 10             	mov    0x10(%eax),%eax
   1367a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
   1367d:	8b 45 10             	mov    0x10(%ebp),%eax
   13680:	8b 40 04             	mov    0x4(%eax),%eax
   13683:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
   13686:	8b 45 10             	mov    0x10(%ebp),%eax
   13689:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   1368f:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
   13692:	8b 45 08             	mov    0x8(%ebp),%eax
   13695:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
   1369c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   136a0:	74 21                	je     136c3 <auto_choose_color+0x6a>
   136a2:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
   136a6:	7f 1b                	jg     136c3 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
   136a8:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
   136af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
   136b6:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   136ba:	77 07                	ja     136c3 <auto_choose_color+0x6a>
   136bc:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
   136c3:	8b 45 10             	mov    0x10(%ebp),%eax
   136c6:	8b 00                	mov    (%eax),%eax
   136c8:	85 c0                	test   %eax,%eax
   136ca:	0f 94 c0             	sete   %al
   136cd:	0f b6 c0             	movzbl %al,%eax
   136d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
   136d3:	8b 45 10             	mov    0x10(%ebp),%eax
   136d6:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
   136dc:	85 c0                	test   %eax,%eax
   136de:	75 07                	jne    136e7 <auto_choose_color+0x8e>
   136e0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
   136e7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   136eb:	75 0d                	jne    136fa <auto_choose_color+0xa1>
   136ed:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   136f1:	77 07                	ja     136fa <auto_choose_color+0xa1>
   136f3:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
   136fa:	8b 45 10             	mov    0x10(%ebp),%eax
   136fd:	8b 40 14             	mov    0x14(%eax),%eax
   13700:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
   13703:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
   13707:	7e 21                	jle    1372a <auto_choose_color+0xd1>
   13709:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
   1370d:	7e 14                	jle    13723 <auto_choose_color+0xca>
   1370f:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
   13713:	7f 07                	jg     1371c <auto_choose_color+0xc3>
   13715:	b8 04 00 00 00       	mov    $0x4,%eax
   1371a:	eb 13                	jmp    1372f <auto_choose_color+0xd6>
   1371c:	b8 08 00 00 00       	mov    $0x8,%eax
   13721:	eb 0c                	jmp    1372f <auto_choose_color+0xd6>
   13723:	b8 02 00 00 00       	mov    $0x2,%eax
   13728:	eb 05                	jmp    1372f <auto_choose_color+0xd6>
   1372a:	b8 01 00 00 00       	mov    $0x1,%eax
   1372f:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
   13732:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
   13739:	7f 13                	jg     1374e <auto_choose_color+0xf5>
   1373b:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
   1373f:	77 0d                	ja     1374e <auto_choose_color+0xf5>
   13741:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   13745:	74 07                	je     1374e <auto_choose_color+0xf5>
   13747:	b8 01 00 00 00       	mov    $0x1,%eax
   1374c:	eb 05                	jmp    13753 <auto_choose_color+0xfa>
   1374e:	b8 00 00 00 00       	mov    $0x0,%eax
   13753:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
   13756:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13759:	01 c0                	add    %eax,%eax
   1375b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
   1375e:	7e 07                	jle    13767 <auto_choose_color+0x10e>
   13760:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
   13767:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1376b:	74 15                	je     13782 <auto_choose_color+0x129>
   1376d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13771:	75 0f                	jne    13782 <auto_choose_color+0x129>
   13773:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13776:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   13779:	77 07                	ja     13782 <auto_choose_color+0x129>
   1377b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
   13782:	8b 45 10             	mov    0x10(%ebp),%eax
   13785:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
   1378b:	85 c0                	test   %eax,%eax
   1378d:	75 07                	jne    13796 <auto_choose_color+0x13d>
   1378f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
   13796:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1379a:	0f 84 0a 01 00 00    	je     138aa <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
   137a0:	8b 45 10             	mov    0x10(%ebp),%eax
   137a3:	83 c0 18             	add    $0x18,%eax
   137a6:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
   137a9:	83 ec 0c             	sub    $0xc,%esp
   137ac:	ff 75 08             	pushl  0x8(%ebp)
   137af:	e8 ef be ff ff       	call   f6a3 <lodepng_palette_clear>
   137b4:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
   137b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   137be:	eb 6e                	jmp    1382e <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
   137c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   137c3:	c1 e0 02             	shl    $0x2,%eax
   137c6:	8d 50 03             	lea    0x3(%eax),%edx
   137c9:	8b 45 cc             	mov    -0x34(%ebp),%eax
   137cc:	01 d0                	add    %edx,%eax
   137ce:	0f b6 00             	movzbl (%eax),%eax
   137d1:	0f b6 d8             	movzbl %al,%ebx
   137d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   137d7:	c1 e0 02             	shl    $0x2,%eax
   137da:	8d 50 02             	lea    0x2(%eax),%edx
   137dd:	8b 45 cc             	mov    -0x34(%ebp),%eax
   137e0:	01 d0                	add    %edx,%eax
   137e2:	0f b6 00             	movzbl (%eax),%eax
   137e5:	0f b6 c8             	movzbl %al,%ecx
   137e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   137eb:	c1 e0 02             	shl    $0x2,%eax
   137ee:	8d 50 01             	lea    0x1(%eax),%edx
   137f1:	8b 45 cc             	mov    -0x34(%ebp),%eax
   137f4:	01 d0                	add    %edx,%eax
   137f6:	0f b6 00             	movzbl (%eax),%eax
   137f9:	0f b6 d0             	movzbl %al,%edx
   137fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   137ff:	c1 e0 02             	shl    $0x2,%eax
   13802:	89 c6                	mov    %eax,%esi
   13804:	8b 45 cc             	mov    -0x34(%ebp),%eax
   13807:	01 f0                	add    %esi,%eax
   13809:	0f b6 00             	movzbl (%eax),%eax
   1380c:	0f b6 c0             	movzbl %al,%eax
   1380f:	83 ec 0c             	sub    $0xc,%esp
   13812:	53                   	push   %ebx
   13813:	51                   	push   %ecx
   13814:	52                   	push   %edx
   13815:	50                   	push   %eax
   13816:	ff 75 08             	pushl  0x8(%ebp)
   13819:	e8 be be ff ff       	call   f6dc <lodepng_palette_add>
   1381e:	83 c4 20             	add    $0x20,%esp
   13821:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
   13824:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13828:	75 13                	jne    1383d <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
   1382a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1382e:	8b 45 10             	mov    0x10(%ebp),%eax
   13831:	8b 50 14             	mov    0x14(%eax),%edx
   13834:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13837:	39 c2                	cmp    %eax,%edx
   13839:	75 85                	jne    137c0 <auto_choose_color+0x167>
   1383b:	eb 01                	jmp    1383e <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
   1383d:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
   1383e:	8b 45 08             	mov    0x8(%ebp),%eax
   13841:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
   13847:	8b 45 08             	mov    0x8(%ebp),%eax
   1384a:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1384d:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
   13850:	8b 45 0c             	mov    0xc(%ebp),%eax
   13853:	8b 00                	mov    (%eax),%eax
   13855:	83 f8 03             	cmp    $0x3,%eax
   13858:	0f 85 ec 00 00 00    	jne    1394a <auto_choose_color+0x2f1>
   1385e:	8b 45 0c             	mov    0xc(%ebp),%eax
   13861:	8b 50 0c             	mov    0xc(%eax),%edx
   13864:	8b 45 08             	mov    0x8(%ebp),%eax
   13867:	8b 40 0c             	mov    0xc(%eax),%eax
   1386a:	39 c2                	cmp    %eax,%edx
   1386c:	0f 8c d8 00 00 00    	jl     1394a <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
   13872:	8b 45 0c             	mov    0xc(%ebp),%eax
   13875:	8b 50 04             	mov    0x4(%eax),%edx
   13878:	8b 45 08             	mov    0x8(%ebp),%eax
   1387b:	8b 40 04             	mov    0x4(%eax),%eax
   1387e:	39 c2                	cmp    %eax,%edx
   13880:	0f 85 c4 00 00 00    	jne    1394a <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
   13886:	83 ec 0c             	sub    $0xc,%esp
   13889:	ff 75 08             	pushl  0x8(%ebp)
   1388c:	e8 0e bc ff ff       	call   f49f <lodepng_color_mode_cleanup>
   13891:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
   13894:	83 ec 08             	sub    $0x8,%esp
   13897:	ff 75 0c             	pushl  0xc(%ebp)
   1389a:	ff 75 08             	pushl  0x8(%ebp)
   1389d:	e8 14 bc ff ff       	call   f4b6 <lodepng_color_mode_copy>
   138a2:	83 c4 10             	add    $0x10,%esp
   138a5:	e9 a0 00 00 00       	jmp    1394a <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
   138aa:	8b 45 08             	mov    0x8(%ebp),%eax
   138ad:	8b 55 dc             	mov    -0x24(%ebp),%edx
   138b0:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
   138b3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   138b7:	74 14                	je     138cd <auto_choose_color+0x274>
   138b9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   138bd:	74 07                	je     138c6 <auto_choose_color+0x26d>
   138bf:	b8 04 00 00 00       	mov    $0x4,%eax
   138c4:	eb 19                	jmp    138df <auto_choose_color+0x286>
   138c6:	b8 06 00 00 00       	mov    $0x6,%eax
   138cb:	eb 12                	jmp    138df <auto_choose_color+0x286>
   138cd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   138d1:	74 07                	je     138da <auto_choose_color+0x281>
   138d3:	b8 00 00 00 00       	mov    $0x0,%eax
   138d8:	eb 05                	jmp    138df <auto_choose_color+0x286>
   138da:	b8 02 00 00 00       	mov    $0x2,%eax
   138df:	8b 55 08             	mov    0x8(%ebp),%edx
   138e2:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
   138e4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   138e8:	74 60                	je     1394a <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
   138ea:	8b 45 08             	mov    0x8(%ebp),%eax
   138ed:	8b 40 04             	mov    0x4(%eax),%eax
   138f0:	ba 01 00 00 00       	mov    $0x1,%edx
   138f5:	89 c1                	mov    %eax,%ecx
   138f7:	d3 e2                	shl    %cl,%edx
   138f9:	89 d0                	mov    %edx,%eax
   138fb:	83 e8 01             	sub    $0x1,%eax
   138fe:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
   13901:	8b 45 10             	mov    0x10(%ebp),%eax
   13904:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   13908:	0f b7 c0             	movzwl %ax,%eax
   1390b:	23 45 c8             	and    -0x38(%ebp),%eax
   1390e:	89 c2                	mov    %eax,%edx
   13910:	8b 45 08             	mov    0x8(%ebp),%eax
   13913:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
   13916:	8b 45 10             	mov    0x10(%ebp),%eax
   13919:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   1391d:	0f b7 c0             	movzwl %ax,%eax
   13920:	23 45 c8             	and    -0x38(%ebp),%eax
   13923:	89 c2                	mov    %eax,%edx
   13925:	8b 45 08             	mov    0x8(%ebp),%eax
   13928:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
   1392b:	8b 45 10             	mov    0x10(%ebp),%eax
   1392e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   13932:	0f b7 c0             	movzwl %ax,%eax
   13935:	23 45 c8             	and    -0x38(%ebp),%eax
   13938:	89 c2                	mov    %eax,%edx
   1393a:	8b 45 08             	mov    0x8(%ebp),%eax
   1393d:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
   13940:	8b 45 08             	mov    0x8(%ebp),%eax
   13943:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
   1394a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1394d:	8d 65 f8             	lea    -0x8(%ebp),%esp
   13950:	5b                   	pop    %ebx
   13951:	5e                   	pop    %esi
   13952:	5d                   	pop    %ebp
   13953:	c3                   	ret    

00013954 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
   13954:	55                   	push   %ebp
   13955:	89 e5                	mov    %esp,%ebp
   13957:	83 ec 1c             	sub    $0x1c,%esp
   1395a:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1395d:	8b 55 0c             	mov    0xc(%ebp),%edx
   13960:	8b 45 10             	mov    0x10(%ebp),%eax
   13963:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
   13967:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
   1396b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
   1396f:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   13973:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
   13977:	29 c2                	sub    %eax,%edx
   13979:	89 d0                	mov    %edx,%eax
   1397b:	99                   	cltd   
   1397c:	31 d0                	xor    %edx,%eax
   1397e:	29 d0                	sub    %edx,%eax
   13980:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
   13984:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
   13988:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
   1398c:	29 c2                	sub    %eax,%edx
   1398e:	89 d0                	mov    %edx,%eax
   13990:	99                   	cltd   
   13991:	31 d0                	xor    %edx,%eax
   13993:	29 d0                	sub    %edx,%eax
   13995:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
   13999:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
   1399d:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
   139a1:	01 c2                	add    %eax,%edx
   139a3:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
   139a7:	29 c2                	sub    %eax,%edx
   139a9:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
   139ad:	29 c2                	sub    %eax,%edx
   139af:	89 d0                	mov    %edx,%eax
   139b1:	99                   	cltd   
   139b2:	31 d0                	xor    %edx,%eax
   139b4:	29 d0                	sub    %edx,%eax
   139b6:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
   139ba:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   139be:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
   139c2:	7d 10                	jge    139d4 <paethPredictor+0x80>
   139c4:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
   139c8:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
   139cc:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   139d0:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
   139d4:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
   139d8:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
   139dc:	7d 06                	jge    139e4 <paethPredictor+0x90>
   139de:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   139e2:	eb 04                	jmp    139e8 <paethPredictor+0x94>
   139e4:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
   139e8:	c9                   	leave  
   139e9:	c3                   	ret    

000139ea <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
   139ea:	55                   	push   %ebp
   139eb:	89 e5                	mov    %esp,%ebp
   139ed:	56                   	push   %esi
   139ee:	53                   	push   %ebx
   139ef:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
   139f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   139f9:	e9 e2 00 00 00       	jmp    13ae0 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
   139fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a01:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13a08:	8b 45 08             	mov    0x8(%ebp),%eax
   13a0b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   13a0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a11:	8b 14 85 14 0b 02 00 	mov    0x20b14(,%eax,4),%edx
   13a18:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13a1b:	01 c2                	add    %eax,%edx
   13a1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a20:	8b 04 85 dc 0a 02 00 	mov    0x20adc(,%eax,4),%eax
   13a27:	29 c2                	sub    %eax,%edx
   13a29:	89 d0                	mov    %edx,%eax
   13a2b:	8d 58 ff             	lea    -0x1(%eax),%ebx
   13a2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a31:	8b 34 85 14 0b 02 00 	mov    0x20b14(,%eax,4),%esi
   13a38:	89 d8                	mov    %ebx,%eax
   13a3a:	ba 00 00 00 00       	mov    $0x0,%edx
   13a3f:	f7 f6                	div    %esi
   13a41:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
   13a43:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a46:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13a50:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   13a53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a56:	8b 14 85 30 0b 02 00 	mov    0x20b30(,%eax,4),%edx
   13a5d:	8b 45 20             	mov    0x20(%ebp),%eax
   13a60:	01 c2                	add    %eax,%edx
   13a62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a65:	8b 04 85 f8 0a 02 00 	mov    0x20af8(,%eax,4),%eax
   13a6c:	29 c2                	sub    %eax,%edx
   13a6e:	89 d0                	mov    %edx,%eax
   13a70:	8d 58 ff             	lea    -0x1(%eax),%ebx
   13a73:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a76:	8b 34 85 30 0b 02 00 	mov    0x20b30(,%eax,4),%esi
   13a7d:	89 d8                	mov    %ebx,%eax
   13a7f:	ba 00 00 00 00       	mov    $0x0,%edx
   13a84:	f7 f6                	div    %esi
   13a86:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
   13a88:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a8b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13a92:	8b 45 08             	mov    0x8(%ebp),%eax
   13a95:	01 d0                	add    %edx,%eax
   13a97:	8b 00                	mov    (%eax),%eax
   13a99:	85 c0                	test   %eax,%eax
   13a9b:	75 15                	jne    13ab2 <Adam7_getpassvalues+0xc8>
   13a9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13aa0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13aa7:	8b 45 0c             	mov    0xc(%ebp),%eax
   13aaa:	01 d0                	add    %edx,%eax
   13aac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
   13ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ab5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13abc:	8b 45 0c             	mov    0xc(%ebp),%eax
   13abf:	01 d0                	add    %edx,%eax
   13ac1:	8b 00                	mov    (%eax),%eax
   13ac3:	85 c0                	test   %eax,%eax
   13ac5:	75 15                	jne    13adc <Adam7_getpassvalues+0xf2>
   13ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13aca:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13ad1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ad4:	01 d0                	add    %edx,%eax
   13ad6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
   13adc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13ae0:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   13ae4:	0f 85 14 ff ff ff    	jne    139fe <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   13aea:	8b 45 18             	mov    0x18(%ebp),%eax
   13aed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   13af3:	8b 45 18             	mov    0x18(%ebp),%eax
   13af6:	8b 10                	mov    (%eax),%edx
   13af8:	8b 45 14             	mov    0x14(%ebp),%eax
   13afb:	89 10                	mov    %edx,(%eax)
   13afd:	8b 45 14             	mov    0x14(%ebp),%eax
   13b00:	8b 10                	mov    (%eax),%edx
   13b02:	8b 45 10             	mov    0x10(%ebp),%eax
   13b05:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
   13b07:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13b0e:	e9 40 01 00 00       	jmp    13c53 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
   13b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b16:	83 c0 01             	add    $0x1,%eax
   13b19:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13b20:	8b 45 10             	mov    0x10(%ebp),%eax
   13b23:	01 c2                	add    %eax,%edx
   13b25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b28:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13b2f:	8b 45 10             	mov    0x10(%ebp),%eax
   13b32:	01 c8                	add    %ecx,%eax
   13b34:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
   13b36:	89 c6                	mov    %eax,%esi
   13b38:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b3b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13b42:	8b 45 08             	mov    0x8(%ebp),%eax
   13b45:	01 c8                	add    %ecx,%eax
   13b47:	8b 00                	mov    (%eax),%eax
   13b49:	85 c0                	test   %eax,%eax
   13b4b:	74 49                	je     13b96 <Adam7_getpassvalues+0x1ac>
   13b4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b50:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13b57:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b5a:	01 c8                	add    %ecx,%eax
   13b5c:	8b 00                	mov    (%eax),%eax
   13b5e:	85 c0                	test   %eax,%eax
   13b60:	74 34                	je     13b96 <Adam7_getpassvalues+0x1ac>
   13b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b65:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13b6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b6f:	01 c8                	add    %ecx,%eax
   13b71:	8b 08                	mov    (%eax),%ecx
   13b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b76:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
   13b7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13b80:	01 d8                	add    %ebx,%eax
   13b82:	8b 00                	mov    (%eax),%eax
   13b84:	0f af 45 24          	imul   0x24(%ebp),%eax
   13b88:	83 c0 07             	add    $0x7,%eax
   13b8b:	c1 e8 03             	shr    $0x3,%eax
   13b8e:	83 c0 01             	add    $0x1,%eax
   13b91:	0f af c1             	imul   %ecx,%eax
   13b94:	eb 05                	jmp    13b9b <Adam7_getpassvalues+0x1b1>
   13b96:	b8 00 00 00 00       	mov    $0x0,%eax
   13b9b:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
   13b9d:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
   13b9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ba2:	83 c0 01             	add    $0x1,%eax
   13ba5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13bac:	8b 45 14             	mov    0x14(%ebp),%eax
   13baf:	01 c2                	add    %eax,%edx
   13bb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13bb4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13bbb:	8b 45 14             	mov    0x14(%ebp),%eax
   13bbe:	01 c8                	add    %ecx,%eax
   13bc0:	8b 00                	mov    (%eax),%eax
   13bc2:	89 c6                	mov    %eax,%esi
   13bc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13bc7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13bce:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bd1:	01 c8                	add    %ecx,%eax
   13bd3:	8b 08                	mov    (%eax),%ecx
   13bd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13bd8:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
   13bdf:	8b 45 08             	mov    0x8(%ebp),%eax
   13be2:	01 d8                	add    %ebx,%eax
   13be4:	8b 00                	mov    (%eax),%eax
   13be6:	0f af 45 24          	imul   0x24(%ebp),%eax
   13bea:	83 c0 07             	add    $0x7,%eax
   13bed:	c1 e8 03             	shr    $0x3,%eax
   13bf0:	0f af c1             	imul   %ecx,%eax
   13bf3:	01 f0                	add    %esi,%eax
   13bf5:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
   13bf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13bfa:	83 c0 01             	add    $0x1,%eax
   13bfd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13c04:	8b 45 18             	mov    0x18(%ebp),%eax
   13c07:	01 c2                	add    %eax,%edx
   13c09:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c0c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13c13:	8b 45 18             	mov    0x18(%ebp),%eax
   13c16:	01 c8                	add    %ecx,%eax
   13c18:	8b 00                	mov    (%eax),%eax
   13c1a:	89 c6                	mov    %eax,%esi
   13c1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c1f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13c26:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c29:	01 c8                	add    %ecx,%eax
   13c2b:	8b 08                	mov    (%eax),%ecx
   13c2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c30:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
   13c37:	8b 45 08             	mov    0x8(%ebp),%eax
   13c3a:	01 d8                	add    %ebx,%eax
   13c3c:	8b 00                	mov    (%eax),%eax
   13c3e:	0f af c1             	imul   %ecx,%eax
   13c41:	0f af 45 24          	imul   0x24(%ebp),%eax
   13c45:	83 c0 07             	add    $0x7,%eax
   13c48:	c1 e8 03             	shr    $0x3,%eax
   13c4b:	01 f0                	add    %esi,%eax
   13c4d:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
   13c4f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13c53:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   13c57:	0f 85 b6 fe ff ff    	jne    13b13 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
   13c5d:	90                   	nop
   13c5e:	83 c4 10             	add    $0x10,%esp
   13c61:	5b                   	pop    %ebx
   13c62:	5e                   	pop    %esi
   13c63:	5d                   	pop    %ebp
   13c64:	c3                   	ret    

00013c65 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
   13c65:	55                   	push   %ebp
   13c66:	89 e5                	mov    %esp,%ebp
   13c68:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
   13c6b:	8b 45 10             	mov    0x10(%ebp),%eax
   13c6e:	05 98 00 00 00       	add    $0x98,%eax
   13c73:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
   13c76:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
   13c7a:	74 06                	je     13c82 <lodepng_inspect+0x1d>
   13c7c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   13c80:	75 17                	jne    13c99 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
   13c82:	8b 45 10             	mov    0x10(%ebp),%eax
   13c85:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
   13c8c:	00 00 00 
   13c8f:	b8 30 00 00 00       	mov    $0x30,%eax
   13c94:	e9 ce 02 00 00       	jmp    13f67 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
   13c99:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
   13c9d:	7f 17                	jg     13cb6 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
   13c9f:	8b 45 10             	mov    0x10(%ebp),%eax
   13ca2:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
   13ca9:	00 00 00 
   13cac:	b8 1b 00 00 00       	mov    $0x1b,%eax
   13cb1:	e9 b1 02 00 00       	jmp    13f67 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
   13cb6:	83 ec 0c             	sub    $0xc,%esp
   13cb9:	ff 75 f4             	pushl  -0xc(%ebp)
   13cbc:	e8 63 c7 ff ff       	call   10424 <lodepng_info_cleanup>
   13cc1:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
   13cc4:	83 ec 0c             	sub    $0xc,%esp
   13cc7:	ff 75 f4             	pushl  -0xc(%ebp)
   13cca:	e8 74 c6 ff ff       	call   10343 <lodepng_info_init>
   13ccf:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
   13cd2:	8b 45 14             	mov    0x14(%ebp),%eax
   13cd5:	0f b6 00             	movzbl (%eax),%eax
   13cd8:	3c 89                	cmp    $0x89,%al
   13cda:	75 5b                	jne    13d37 <lodepng_inspect+0xd2>
   13cdc:	8b 45 14             	mov    0x14(%ebp),%eax
   13cdf:	83 c0 01             	add    $0x1,%eax
   13ce2:	0f b6 00             	movzbl (%eax),%eax
   13ce5:	3c 50                	cmp    $0x50,%al
   13ce7:	75 4e                	jne    13d37 <lodepng_inspect+0xd2>
   13ce9:	8b 45 14             	mov    0x14(%ebp),%eax
   13cec:	83 c0 02             	add    $0x2,%eax
   13cef:	0f b6 00             	movzbl (%eax),%eax
   13cf2:	3c 4e                	cmp    $0x4e,%al
   13cf4:	75 41                	jne    13d37 <lodepng_inspect+0xd2>
   13cf6:	8b 45 14             	mov    0x14(%ebp),%eax
   13cf9:	83 c0 03             	add    $0x3,%eax
   13cfc:	0f b6 00             	movzbl (%eax),%eax
   13cff:	3c 47                	cmp    $0x47,%al
   13d01:	75 34                	jne    13d37 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
   13d03:	8b 45 14             	mov    0x14(%ebp),%eax
   13d06:	83 c0 04             	add    $0x4,%eax
   13d09:	0f b6 00             	movzbl (%eax),%eax
   13d0c:	3c 0d                	cmp    $0xd,%al
   13d0e:	75 27                	jne    13d37 <lodepng_inspect+0xd2>
   13d10:	8b 45 14             	mov    0x14(%ebp),%eax
   13d13:	83 c0 05             	add    $0x5,%eax
   13d16:	0f b6 00             	movzbl (%eax),%eax
   13d19:	3c 0a                	cmp    $0xa,%al
   13d1b:	75 1a                	jne    13d37 <lodepng_inspect+0xd2>
   13d1d:	8b 45 14             	mov    0x14(%ebp),%eax
   13d20:	83 c0 06             	add    $0x6,%eax
   13d23:	0f b6 00             	movzbl (%eax),%eax
   13d26:	3c 1a                	cmp    $0x1a,%al
   13d28:	75 0d                	jne    13d37 <lodepng_inspect+0xd2>
   13d2a:	8b 45 14             	mov    0x14(%ebp),%eax
   13d2d:	83 c0 07             	add    $0x7,%eax
   13d30:	0f b6 00             	movzbl (%eax),%eax
   13d33:	3c 0a                	cmp    $0xa,%al
   13d35:	74 17                	je     13d4e <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
   13d37:	8b 45 10             	mov    0x10(%ebp),%eax
   13d3a:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
   13d41:	00 00 00 
   13d44:	b8 1c 00 00 00       	mov    $0x1c,%eax
   13d49:	e9 19 02 00 00       	jmp    13f67 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
   13d4e:	8b 45 14             	mov    0x14(%ebp),%eax
   13d51:	83 c0 08             	add    $0x8,%eax
   13d54:	83 ec 0c             	sub    $0xc,%esp
   13d57:	50                   	push   %eax
   13d58:	e8 c2 ae ff ff       	call   ec1f <lodepng_chunk_length>
   13d5d:	83 c4 10             	add    $0x10,%esp
   13d60:	83 f8 0d             	cmp    $0xd,%eax
   13d63:	74 17                	je     13d7c <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
   13d65:	8b 45 10             	mov    0x10(%ebp),%eax
   13d68:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
   13d6f:	00 00 00 
   13d72:	b8 5e 00 00 00       	mov    $0x5e,%eax
   13d77:	e9 eb 01 00 00       	jmp    13f67 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
   13d7c:	8b 45 14             	mov    0x14(%ebp),%eax
   13d7f:	83 c0 08             	add    $0x8,%eax
   13d82:	83 ec 08             	sub    $0x8,%esp
   13d85:	68 4c 0b 02 00       	push   $0x20b4c
   13d8a:	50                   	push   %eax
   13d8b:	e8 dc ae ff ff       	call   ec6c <lodepng_chunk_type_equals>
   13d90:	83 c4 10             	add    $0x10,%esp
   13d93:	84 c0                	test   %al,%al
   13d95:	75 17                	jne    13dae <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
   13d97:	8b 45 10             	mov    0x10(%ebp),%eax
   13d9a:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
   13da1:	00 00 00 
   13da4:	b8 1d 00 00 00       	mov    $0x1d,%eax
   13da9:	e9 b9 01 00 00       	jmp    13f67 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
   13dae:	8b 45 14             	mov    0x14(%ebp),%eax
   13db1:	83 c0 10             	add    $0x10,%eax
   13db4:	83 ec 0c             	sub    $0xc,%esp
   13db7:	50                   	push   %eax
   13db8:	e8 5e 62 ff ff       	call   a01b <lodepng_read32bitInt>
   13dbd:	83 c4 10             	add    $0x10,%esp
   13dc0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
   13dc3:	8b 45 14             	mov    0x14(%ebp),%eax
   13dc6:	83 c0 14             	add    $0x14,%eax
   13dc9:	83 ec 0c             	sub    $0xc,%esp
   13dcc:	50                   	push   %eax
   13dcd:	e8 49 62 ff ff       	call   a01b <lodepng_read32bitInt>
   13dd2:	83 c4 10             	add    $0x10,%esp
   13dd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
   13dd8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13ddc:	74 08                	je     13de6 <lodepng_inspect+0x181>
   13dde:	8b 45 08             	mov    0x8(%ebp),%eax
   13de1:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13de4:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
   13de6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13dea:	74 08                	je     13df4 <lodepng_inspect+0x18f>
   13dec:	8b 45 0c             	mov    0xc(%ebp),%eax
   13def:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13df2:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
   13df4:	8b 45 14             	mov    0x14(%ebp),%eax
   13df7:	83 c0 18             	add    $0x18,%eax
   13dfa:	0f b6 00             	movzbl (%eax),%eax
   13dfd:	0f b6 d0             	movzbl %al,%edx
   13e00:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e03:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
   13e06:	8b 45 14             	mov    0x14(%ebp),%eax
   13e09:	83 c0 19             	add    $0x19,%eax
   13e0c:	0f b6 00             	movzbl (%eax),%eax
   13e0f:	0f b6 d0             	movzbl %al,%edx
   13e12:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e15:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
   13e18:	8b 45 14             	mov    0x14(%ebp),%eax
   13e1b:	83 c0 1a             	add    $0x1a,%eax
   13e1e:	0f b6 00             	movzbl (%eax),%eax
   13e21:	0f b6 d0             	movzbl %al,%edx
   13e24:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e27:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
   13e29:	8b 45 14             	mov    0x14(%ebp),%eax
   13e2c:	83 c0 1b             	add    $0x1b,%eax
   13e2f:	0f b6 00             	movzbl (%eax),%eax
   13e32:	0f b6 d0             	movzbl %al,%edx
   13e35:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e38:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
   13e3b:	8b 45 14             	mov    0x14(%ebp),%eax
   13e3e:	83 c0 1c             	add    $0x1c,%eax
   13e41:	0f b6 00             	movzbl (%eax),%eax
   13e44:	0f b6 d0             	movzbl %al,%edx
   13e47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e4a:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
   13e4d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13e51:	74 06                	je     13e59 <lodepng_inspect+0x1f4>
   13e53:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13e57:	75 17                	jne    13e70 <lodepng_inspect+0x20b>
   13e59:	8b 45 10             	mov    0x10(%ebp),%eax
   13e5c:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
   13e63:	00 00 00 
   13e66:	b8 5d 00 00 00       	mov    $0x5d,%eax
   13e6b:	e9 f7 00 00 00       	jmp    13f67 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
   13e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e73:	8b 50 10             	mov    0x10(%eax),%edx
   13e76:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13e79:	8b 40 0c             	mov    0xc(%eax),%eax
   13e7c:	83 ec 08             	sub    $0x8,%esp
   13e7f:	52                   	push   %edx
   13e80:	50                   	push   %eax
   13e81:	e8 d4 b3 ff ff       	call   f25a <checkColorValidity>
   13e86:	83 c4 10             	add    $0x10,%esp
   13e89:	89 c2                	mov    %eax,%edx
   13e8b:	8b 45 10             	mov    0x10(%ebp),%eax
   13e8e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
   13e94:	8b 45 10             	mov    0x10(%ebp),%eax
   13e97:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13e9d:	85 c0                	test   %eax,%eax
   13e9f:	74 0e                	je     13eaf <lodepng_inspect+0x24a>
   13ea1:	8b 45 10             	mov    0x10(%ebp),%eax
   13ea4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13eaa:	e9 b8 00 00 00       	jmp    13f67 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
   13eaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13eb2:	8b 00                	mov    (%eax),%eax
   13eb4:	85 c0                	test   %eax,%eax
   13eb6:	74 17                	je     13ecf <lodepng_inspect+0x26a>
   13eb8:	8b 45 10             	mov    0x10(%ebp),%eax
   13ebb:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
   13ec2:	00 00 00 
   13ec5:	b8 20 00 00 00       	mov    $0x20,%eax
   13eca:	e9 98 00 00 00       	jmp    13f67 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
   13ecf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ed2:	8b 40 04             	mov    0x4(%eax),%eax
   13ed5:	85 c0                	test   %eax,%eax
   13ed7:	74 14                	je     13eed <lodepng_inspect+0x288>
   13ed9:	8b 45 10             	mov    0x10(%ebp),%eax
   13edc:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
   13ee3:	00 00 00 
   13ee6:	b8 21 00 00 00       	mov    $0x21,%eax
   13eeb:	eb 7a                	jmp    13f67 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
   13eed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ef0:	8b 40 08             	mov    0x8(%eax),%eax
   13ef3:	83 f8 01             	cmp    $0x1,%eax
   13ef6:	76 14                	jbe    13f0c <lodepng_inspect+0x2a7>
   13ef8:	8b 45 10             	mov    0x10(%ebp),%eax
   13efb:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
   13f02:	00 00 00 
   13f05:	b8 22 00 00 00       	mov    $0x22,%eax
   13f0a:	eb 5b                	jmp    13f67 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
   13f0c:	8b 45 10             	mov    0x10(%ebp),%eax
   13f0f:	8b 40 18             	mov    0x18(%eax),%eax
   13f12:	85 c0                	test   %eax,%eax
   13f14:	75 48                	jne    13f5e <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
   13f16:	8b 45 14             	mov    0x14(%ebp),%eax
   13f19:	83 c0 1d             	add    $0x1d,%eax
   13f1c:	83 ec 0c             	sub    $0xc,%esp
   13f1f:	50                   	push   %eax
   13f20:	e8 f6 60 ff ff       	call   a01b <lodepng_read32bitInt>
   13f25:	83 c4 10             	add    $0x10,%esp
   13f28:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
   13f2b:	8b 45 14             	mov    0x14(%ebp),%eax
   13f2e:	83 c0 0c             	add    $0xc,%eax
   13f31:	83 ec 08             	sub    $0x8,%esp
   13f34:	6a 11                	push   $0x11
   13f36:	50                   	push   %eax
   13f37:	e8 71 ab ff ff       	call   eaad <lodepng_crc32>
   13f3c:	83 c4 10             	add    $0x10,%esp
   13f3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
   13f42:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f45:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13f48:	74 14                	je     13f5e <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
   13f4a:	8b 45 10             	mov    0x10(%ebp),%eax
   13f4d:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   13f54:	00 00 00 
   13f57:	b8 39 00 00 00       	mov    $0x39,%eax
   13f5c:	eb 09                	jmp    13f67 <lodepng_inspect+0x302>
    }
  }

  return state->error;
   13f5e:	8b 45 10             	mov    0x10(%ebp),%eax
   13f61:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13f67:	c9                   	leave  
   13f68:	c3                   	ret    

00013f69 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
   13f69:	55                   	push   %ebp
   13f6a:	89 e5                	mov    %esp,%ebp
   13f6c:	56                   	push   %esi
   13f6d:	53                   	push   %ebx
   13f6e:	83 ec 44             	sub    $0x44,%esp
   13f71:	8b 45 18             	mov    0x18(%ebp),%eax
   13f74:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
   13f77:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
   13f7b:	83 f8 04             	cmp    $0x4,%eax
   13f7e:	0f 87 81 07 00 00    	ja     14705 <unfilterScanline+0x79c>
   13f84:	8b 04 85 54 0b 02 00 	mov    0x20b54(,%eax,4),%eax
   13f8b:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
   13f8d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13f94:	eb 19                	jmp    13faf <unfilterScanline+0x46>
   13f96:	8b 55 f4             	mov    -0xc(%ebp),%edx
   13f99:	8b 45 08             	mov    0x8(%ebp),%eax
   13f9c:	01 c2                	add    %eax,%edx
   13f9e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   13fa1:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fa4:	01 c8                	add    %ecx,%eax
   13fa6:	0f b6 00             	movzbl (%eax),%eax
   13fa9:	88 02                	mov    %al,(%edx)
   13fab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13faf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13fb2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   13fb5:	75 df                	jne    13f96 <unfilterScanline+0x2d>
      break;
   13fb7:	e9 50 07 00 00       	jmp    1470c <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
   13fbc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13fc3:	eb 19                	jmp    13fde <unfilterScanline+0x75>
   13fc5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   13fc8:	8b 45 08             	mov    0x8(%ebp),%eax
   13fcb:	01 c2                	add    %eax,%edx
   13fcd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   13fd0:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fd3:	01 c8                	add    %ecx,%eax
   13fd5:	0f b6 00             	movzbl (%eax),%eax
   13fd8:	88 02                	mov    %al,(%edx)
   13fda:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13fe1:	3b 45 14             	cmp    0x14(%ebp),%eax
   13fe4:	75 df                	jne    13fc5 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
   13fe6:	8b 45 14             	mov    0x14(%ebp),%eax
   13fe9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   13fec:	eb 2b                	jmp    14019 <unfilterScanline+0xb0>
   13fee:	8b 55 f4             	mov    -0xc(%ebp),%edx
   13ff1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff4:	01 c2                	add    %eax,%edx
   13ff6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   13ff9:	8b 45 0c             	mov    0xc(%ebp),%eax
   13ffc:	01 c8                	add    %ecx,%eax
   13ffe:	0f b6 08             	movzbl (%eax),%ecx
   14001:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14004:	2b 45 14             	sub    0x14(%ebp),%eax
   14007:	89 c3                	mov    %eax,%ebx
   14009:	8b 45 08             	mov    0x8(%ebp),%eax
   1400c:	01 d8                	add    %ebx,%eax
   1400e:	0f b6 00             	movzbl (%eax),%eax
   14011:	01 c8                	add    %ecx,%eax
   14013:	88 02                	mov    %al,(%edx)
   14015:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14019:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1401c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   1401f:	7c cd                	jl     13fee <unfilterScanline+0x85>
      break;
   14021:	e9 e6 06 00 00       	jmp    1470c <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
   14026:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1402a:	74 3c                	je     14068 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
   1402c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14033:	eb 26                	jmp    1405b <unfilterScanline+0xf2>
   14035:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14038:	8b 45 08             	mov    0x8(%ebp),%eax
   1403b:	01 d0                	add    %edx,%eax
   1403d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14040:	8b 55 0c             	mov    0xc(%ebp),%edx
   14043:	01 ca                	add    %ecx,%edx
   14045:	0f b6 0a             	movzbl (%edx),%ecx
   14048:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1404b:	8b 55 10             	mov    0x10(%ebp),%edx
   1404e:	01 da                	add    %ebx,%edx
   14050:	0f b6 12             	movzbl (%edx),%edx
   14053:	01 ca                	add    %ecx,%edx
   14055:	88 10                	mov    %dl,(%eax)
   14057:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1405b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1405e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   14061:	75 d2                	jne    14035 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
   14063:	e9 a4 06 00 00       	jmp    1470c <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
   14068:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1406f:	eb 19                	jmp    1408a <unfilterScanline+0x121>
   14071:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14074:	8b 45 08             	mov    0x8(%ebp),%eax
   14077:	01 c2                	add    %eax,%edx
   14079:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1407c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1407f:	01 c8                	add    %ecx,%eax
   14081:	0f b6 00             	movzbl (%eax),%eax
   14084:	88 02                	mov    %al,(%edx)
   14086:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1408a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1408d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   14090:	75 df                	jne    14071 <unfilterScanline+0x108>
      }
      break;
   14092:	e9 75 06 00 00       	jmp    1470c <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
   14097:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1409b:	0f 84 8e 00 00 00    	je     1412f <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
   140a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   140a8:	eb 28                	jmp    140d2 <unfilterScanline+0x169>
   140aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
   140ad:	8b 45 08             	mov    0x8(%ebp),%eax
   140b0:	01 d0                	add    %edx,%eax
   140b2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   140b5:	8b 55 0c             	mov    0xc(%ebp),%edx
   140b8:	01 ca                	add    %ecx,%edx
   140ba:	0f b6 12             	movzbl (%edx),%edx
   140bd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   140c0:	8b 4d 10             	mov    0x10(%ebp),%ecx
   140c3:	01 d9                	add    %ebx,%ecx
   140c5:	0f b6 09             	movzbl (%ecx),%ecx
   140c8:	d0 e9                	shr    %cl
   140ca:	01 ca                	add    %ecx,%edx
   140cc:	88 10                	mov    %dl,(%eax)
   140ce:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   140d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   140d5:	3b 45 14             	cmp    0x14(%ebp),%eax
   140d8:	75 d0                	jne    140aa <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
   140da:	8b 45 14             	mov    0x14(%ebp),%eax
   140dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
   140e0:	eb 40                	jmp    14122 <unfilterScanline+0x1b9>
   140e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   140e5:	8b 45 08             	mov    0x8(%ebp),%eax
   140e8:	01 c2                	add    %eax,%edx
   140ea:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   140ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   140f0:	01 c8                	add    %ecx,%eax
   140f2:	0f b6 08             	movzbl (%eax),%ecx
   140f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   140f8:	2b 45 14             	sub    0x14(%ebp),%eax
   140fb:	89 c3                	mov    %eax,%ebx
   140fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14100:	01 d8                	add    %ebx,%eax
   14102:	0f b6 00             	movzbl (%eax),%eax
   14105:	0f b6 d8             	movzbl %al,%ebx
   14108:	8b 75 f4             	mov    -0xc(%ebp),%esi
   1410b:	8b 45 10             	mov    0x10(%ebp),%eax
   1410e:	01 f0                	add    %esi,%eax
   14110:	0f b6 00             	movzbl (%eax),%eax
   14113:	0f b6 c0             	movzbl %al,%eax
   14116:	01 d8                	add    %ebx,%eax
   14118:	d1 f8                	sar    %eax
   1411a:	01 c8                	add    %ecx,%eax
   1411c:	88 02                	mov    %al,(%edx)
   1411e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14122:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14125:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   14128:	7c b8                	jl     140e2 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
   1412a:	e9 dd 05 00 00       	jmp    1470c <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
   1412f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14136:	eb 19                	jmp    14151 <unfilterScanline+0x1e8>
   14138:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1413b:	8b 45 08             	mov    0x8(%ebp),%eax
   1413e:	01 c2                	add    %eax,%edx
   14140:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14143:	8b 45 0c             	mov    0xc(%ebp),%eax
   14146:	01 c8                	add    %ecx,%eax
   14148:	0f b6 00             	movzbl (%eax),%eax
   1414b:	88 02                	mov    %al,(%edx)
   1414d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14151:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14154:	3b 45 14             	cmp    0x14(%ebp),%eax
   14157:	75 df                	jne    14138 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
   14159:	8b 45 14             	mov    0x14(%ebp),%eax
   1415c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1415f:	eb 2d                	jmp    1418e <unfilterScanline+0x225>
   14161:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14164:	8b 45 08             	mov    0x8(%ebp),%eax
   14167:	01 c2                	add    %eax,%edx
   14169:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1416c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1416f:	01 c8                	add    %ecx,%eax
   14171:	0f b6 08             	movzbl (%eax),%ecx
   14174:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14177:	2b 45 14             	sub    0x14(%ebp),%eax
   1417a:	89 c3                	mov    %eax,%ebx
   1417c:	8b 45 08             	mov    0x8(%ebp),%eax
   1417f:	01 d8                	add    %ebx,%eax
   14181:	0f b6 00             	movzbl (%eax),%eax
   14184:	d0 e8                	shr    %al
   14186:	01 c8                	add    %ecx,%eax
   14188:	88 02                	mov    %al,(%edx)
   1418a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1418e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14191:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   14194:	7c cb                	jl     14161 <unfilterScanline+0x1f8>
      }
      break;
   14196:	e9 71 05 00 00       	jmp    1470c <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
   1419b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1419f:	0f 84 f9 04 00 00    	je     1469e <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
   141a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   141ac:	eb 26                	jmp    141d4 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
   141ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
   141b1:	8b 45 08             	mov    0x8(%ebp),%eax
   141b4:	01 d0                	add    %edx,%eax
   141b6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   141b9:	8b 55 0c             	mov    0xc(%ebp),%edx
   141bc:	01 ca                	add    %ecx,%edx
   141be:	0f b6 0a             	movzbl (%edx),%ecx
   141c1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   141c4:	8b 55 10             	mov    0x10(%ebp),%edx
   141c7:	01 da                	add    %ebx,%edx
   141c9:	0f b6 12             	movzbl (%edx),%edx
   141cc:	01 ca                	add    %ecx,%edx
   141ce:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
   141d0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   141d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   141d7:	3b 45 14             	cmp    0x14(%ebp),%eax
   141da:	75 d2                	jne    141ae <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
   141dc:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
   141e0:	0f 8e db 01 00 00    	jle    143c1 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
   141e6:	e9 c2 01 00 00       	jmp    143ad <unfilterScanline+0x444>
            size_t j = i - bytewidth;
   141eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   141ee:	2b 45 14             	sub    0x14(%ebp),%eax
   141f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
   141f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   141f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   141fa:	01 d0                	add    %edx,%eax
   141fc:	0f b6 00             	movzbl (%eax),%eax
   141ff:	88 45 ef             	mov    %al,-0x11(%ebp)
   14202:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14205:	8d 50 01             	lea    0x1(%eax),%edx
   14208:	8b 45 0c             	mov    0xc(%ebp),%eax
   1420b:	01 d0                	add    %edx,%eax
   1420d:	0f b6 00             	movzbl (%eax),%eax
   14210:	88 45 ee             	mov    %al,-0x12(%ebp)
   14213:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14216:	8d 50 02             	lea    0x2(%eax),%edx
   14219:	8b 45 0c             	mov    0xc(%ebp),%eax
   1421c:	01 d0                	add    %edx,%eax
   1421e:	0f b6 00             	movzbl (%eax),%eax
   14221:	88 45 ed             	mov    %al,-0x13(%ebp)
   14224:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14227:	8d 50 03             	lea    0x3(%eax),%edx
   1422a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1422d:	01 d0                	add    %edx,%eax
   1422f:	0f b6 00             	movzbl (%eax),%eax
   14232:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
   14235:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14238:	8b 45 08             	mov    0x8(%ebp),%eax
   1423b:	01 d0                	add    %edx,%eax
   1423d:	0f b6 00             	movzbl (%eax),%eax
   14240:	88 45 eb             	mov    %al,-0x15(%ebp)
   14243:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14246:	8d 50 01             	lea    0x1(%eax),%edx
   14249:	8b 45 08             	mov    0x8(%ebp),%eax
   1424c:	01 d0                	add    %edx,%eax
   1424e:	0f b6 00             	movzbl (%eax),%eax
   14251:	88 45 ea             	mov    %al,-0x16(%ebp)
   14254:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14257:	8d 50 02             	lea    0x2(%eax),%edx
   1425a:	8b 45 08             	mov    0x8(%ebp),%eax
   1425d:	01 d0                	add    %edx,%eax
   1425f:	0f b6 00             	movzbl (%eax),%eax
   14262:	88 45 e9             	mov    %al,-0x17(%ebp)
   14265:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14268:	8d 50 03             	lea    0x3(%eax),%edx
   1426b:	8b 45 08             	mov    0x8(%ebp),%eax
   1426e:	01 d0                	add    %edx,%eax
   14270:	0f b6 00             	movzbl (%eax),%eax
   14273:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
   14276:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14279:	8b 45 10             	mov    0x10(%ebp),%eax
   1427c:	01 d0                	add    %edx,%eax
   1427e:	0f b6 00             	movzbl (%eax),%eax
   14281:	88 45 e7             	mov    %al,-0x19(%ebp)
   14284:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14287:	8d 50 01             	lea    0x1(%eax),%edx
   1428a:	8b 45 10             	mov    0x10(%ebp),%eax
   1428d:	01 d0                	add    %edx,%eax
   1428f:	0f b6 00             	movzbl (%eax),%eax
   14292:	88 45 e6             	mov    %al,-0x1a(%ebp)
   14295:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14298:	8d 50 02             	lea    0x2(%eax),%edx
   1429b:	8b 45 10             	mov    0x10(%ebp),%eax
   1429e:	01 d0                	add    %edx,%eax
   142a0:	0f b6 00             	movzbl (%eax),%eax
   142a3:	88 45 e5             	mov    %al,-0x1b(%ebp)
   142a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142a9:	8d 50 03             	lea    0x3(%eax),%edx
   142ac:	8b 45 10             	mov    0x10(%ebp),%eax
   142af:	01 d0                	add    %edx,%eax
   142b1:	0f b6 00             	movzbl (%eax),%eax
   142b4:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
   142b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
   142ba:	8b 45 10             	mov    0x10(%ebp),%eax
   142bd:	01 d0                	add    %edx,%eax
   142bf:	0f b6 00             	movzbl (%eax),%eax
   142c2:	88 45 e3             	mov    %al,-0x1d(%ebp)
   142c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142c8:	8d 50 01             	lea    0x1(%eax),%edx
   142cb:	8b 45 10             	mov    0x10(%ebp),%eax
   142ce:	01 d0                	add    %edx,%eax
   142d0:	0f b6 00             	movzbl (%eax),%eax
   142d3:	88 45 e2             	mov    %al,-0x1e(%ebp)
   142d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142d9:	8d 50 02             	lea    0x2(%eax),%edx
   142dc:	8b 45 10             	mov    0x10(%ebp),%eax
   142df:	01 d0                	add    %edx,%eax
   142e1:	0f b6 00             	movzbl (%eax),%eax
   142e4:	88 45 e1             	mov    %al,-0x1f(%ebp)
   142e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142ea:	8d 50 03             	lea    0x3(%eax),%edx
   142ed:	8b 45 10             	mov    0x10(%ebp),%eax
   142f0:	01 d0                	add    %edx,%eax
   142f2:	0f b6 00             	movzbl (%eax),%eax
   142f5:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
   142f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   142fb:	8b 45 08             	mov    0x8(%ebp),%eax
   142fe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   14301:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
   14305:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   14309:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   1430d:	51                   	push   %ecx
   1430e:	52                   	push   %edx
   1430f:	50                   	push   %eax
   14310:	e8 3f f6 ff ff       	call   13954 <paethPredictor>
   14315:	83 c4 0c             	add    $0xc,%esp
   14318:	89 c2                	mov    %eax,%edx
   1431a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   1431e:	01 d0                	add    %edx,%eax
   14320:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
   14322:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14325:	8d 50 01             	lea    0x1(%eax),%edx
   14328:	8b 45 08             	mov    0x8(%ebp),%eax
   1432b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1432e:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
   14332:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   14336:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
   1433a:	51                   	push   %ecx
   1433b:	52                   	push   %edx
   1433c:	50                   	push   %eax
   1433d:	e8 12 f6 ff ff       	call   13954 <paethPredictor>
   14342:	83 c4 0c             	add    $0xc,%esp
   14345:	89 c2                	mov    %eax,%edx
   14347:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
   1434b:	01 d0                	add    %edx,%eax
   1434d:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
   1434f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14352:	8d 50 02             	lea    0x2(%eax),%edx
   14355:	8b 45 08             	mov    0x8(%ebp),%eax
   14358:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1435b:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
   1435f:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   14363:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
   14367:	51                   	push   %ecx
   14368:	52                   	push   %edx
   14369:	50                   	push   %eax
   1436a:	e8 e5 f5 ff ff       	call   13954 <paethPredictor>
   1436f:	83 c4 0c             	add    $0xc,%esp
   14372:	89 c2                	mov    %eax,%edx
   14374:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
   14378:	01 d0                	add    %edx,%eax
   1437a:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
   1437c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1437f:	8d 50 03             	lea    0x3(%eax),%edx
   14382:	8b 45 08             	mov    0x8(%ebp),%eax
   14385:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   14388:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
   1438c:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   14390:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   14394:	51                   	push   %ecx
   14395:	52                   	push   %edx
   14396:	50                   	push   %eax
   14397:	e8 b8 f5 ff ff       	call   13954 <paethPredictor>
   1439c:	83 c4 0c             	add    $0xc,%esp
   1439f:	89 c2                	mov    %eax,%edx
   143a1:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   143a5:	01 d0                	add    %edx,%eax
   143a7:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
   143a9:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   143ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143b0:	83 c0 03             	add    $0x3,%eax
   143b3:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   143b6:	0f 8c 2f fe ff ff    	jl     141eb <unfilterScanline+0x282>
   143bc:	e9 d3 02 00 00       	jmp    14694 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
   143c1:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
   143c5:	0f 8e 6a 01 00 00    	jle    14535 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
   143cb:	e9 51 01 00 00       	jmp    14521 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
   143d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143d3:	2b 45 14             	sub    0x14(%ebp),%eax
   143d6:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
   143d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   143dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   143df:	01 d0                	add    %edx,%eax
   143e1:	0f b6 00             	movzbl (%eax),%eax
   143e4:	88 45 db             	mov    %al,-0x25(%ebp)
   143e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143ea:	8d 50 01             	lea    0x1(%eax),%edx
   143ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   143f0:	01 d0                	add    %edx,%eax
   143f2:	0f b6 00             	movzbl (%eax),%eax
   143f5:	88 45 da             	mov    %al,-0x26(%ebp)
   143f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143fb:	8d 50 02             	lea    0x2(%eax),%edx
   143fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   14401:	01 d0                	add    %edx,%eax
   14403:	0f b6 00             	movzbl (%eax),%eax
   14406:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
   14409:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1440c:	8b 45 08             	mov    0x8(%ebp),%eax
   1440f:	01 d0                	add    %edx,%eax
   14411:	0f b6 00             	movzbl (%eax),%eax
   14414:	88 45 d8             	mov    %al,-0x28(%ebp)
   14417:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1441a:	8d 50 01             	lea    0x1(%eax),%edx
   1441d:	8b 45 08             	mov    0x8(%ebp),%eax
   14420:	01 d0                	add    %edx,%eax
   14422:	0f b6 00             	movzbl (%eax),%eax
   14425:	88 45 d7             	mov    %al,-0x29(%ebp)
   14428:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1442b:	8d 50 02             	lea    0x2(%eax),%edx
   1442e:	8b 45 08             	mov    0x8(%ebp),%eax
   14431:	01 d0                	add    %edx,%eax
   14433:	0f b6 00             	movzbl (%eax),%eax
   14436:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
   14439:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1443c:	8b 45 10             	mov    0x10(%ebp),%eax
   1443f:	01 d0                	add    %edx,%eax
   14441:	0f b6 00             	movzbl (%eax),%eax
   14444:	88 45 d5             	mov    %al,-0x2b(%ebp)
   14447:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1444a:	8d 50 01             	lea    0x1(%eax),%edx
   1444d:	8b 45 10             	mov    0x10(%ebp),%eax
   14450:	01 d0                	add    %edx,%eax
   14452:	0f b6 00             	movzbl (%eax),%eax
   14455:	88 45 d4             	mov    %al,-0x2c(%ebp)
   14458:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1445b:	8d 50 02             	lea    0x2(%eax),%edx
   1445e:	8b 45 10             	mov    0x10(%ebp),%eax
   14461:	01 d0                	add    %edx,%eax
   14463:	0f b6 00             	movzbl (%eax),%eax
   14466:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
   14469:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1446c:	8b 45 10             	mov    0x10(%ebp),%eax
   1446f:	01 d0                	add    %edx,%eax
   14471:	0f b6 00             	movzbl (%eax),%eax
   14474:	88 45 d2             	mov    %al,-0x2e(%ebp)
   14477:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1447a:	8d 50 01             	lea    0x1(%eax),%edx
   1447d:	8b 45 10             	mov    0x10(%ebp),%eax
   14480:	01 d0                	add    %edx,%eax
   14482:	0f b6 00             	movzbl (%eax),%eax
   14485:	88 45 d1             	mov    %al,-0x2f(%ebp)
   14488:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1448b:	8d 50 02             	lea    0x2(%eax),%edx
   1448e:	8b 45 10             	mov    0x10(%ebp),%eax
   14491:	01 d0                	add    %edx,%eax
   14493:	0f b6 00             	movzbl (%eax),%eax
   14496:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
   14499:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1449c:	8b 45 08             	mov    0x8(%ebp),%eax
   1449f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   144a2:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
   144a6:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
   144aa:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
   144ae:	51                   	push   %ecx
   144af:	52                   	push   %edx
   144b0:	50                   	push   %eax
   144b1:	e8 9e f4 ff ff       	call   13954 <paethPredictor>
   144b6:	83 c4 0c             	add    $0xc,%esp
   144b9:	89 c2                	mov    %eax,%edx
   144bb:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
   144bf:	01 d0                	add    %edx,%eax
   144c1:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
   144c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144c6:	8d 50 01             	lea    0x1(%eax),%edx
   144c9:	8b 45 08             	mov    0x8(%ebp),%eax
   144cc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   144cf:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
   144d3:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
   144d7:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
   144db:	51                   	push   %ecx
   144dc:	52                   	push   %edx
   144dd:	50                   	push   %eax
   144de:	e8 71 f4 ff ff       	call   13954 <paethPredictor>
   144e3:	83 c4 0c             	add    $0xc,%esp
   144e6:	89 c2                	mov    %eax,%edx
   144e8:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
   144ec:	01 d0                	add    %edx,%eax
   144ee:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
   144f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144f3:	8d 50 02             	lea    0x2(%eax),%edx
   144f6:	8b 45 08             	mov    0x8(%ebp),%eax
   144f9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   144fc:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
   14500:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
   14504:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
   14508:	51                   	push   %ecx
   14509:	52                   	push   %edx
   1450a:	50                   	push   %eax
   1450b:	e8 44 f4 ff ff       	call   13954 <paethPredictor>
   14510:	83 c4 0c             	add    $0xc,%esp
   14513:	89 c2                	mov    %eax,%edx
   14515:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
   14519:	01 d0                	add    %edx,%eax
   1451b:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
   1451d:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
   14521:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14524:	83 c0 02             	add    $0x2,%eax
   14527:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   1452a:	0f 8c a0 fe ff ff    	jl     143d0 <unfilterScanline+0x467>
   14530:	e9 5f 01 00 00       	jmp    14694 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
   14535:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
   14539:	0f 8e 55 01 00 00    	jle    14694 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
   1453f:	e9 e0 00 00 00       	jmp    14624 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
   14544:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14547:	2b 45 14             	sub    0x14(%ebp),%eax
   1454a:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
   1454d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14550:	8b 45 0c             	mov    0xc(%ebp),%eax
   14553:	01 d0                	add    %edx,%eax
   14555:	0f b6 00             	movzbl (%eax),%eax
   14558:	88 45 cb             	mov    %al,-0x35(%ebp)
   1455b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1455e:	8d 50 01             	lea    0x1(%eax),%edx
   14561:	8b 45 0c             	mov    0xc(%ebp),%eax
   14564:	01 d0                	add    %edx,%eax
   14566:	0f b6 00             	movzbl (%eax),%eax
   14569:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
   1456c:	8b 55 cc             	mov    -0x34(%ebp),%edx
   1456f:	8b 45 08             	mov    0x8(%ebp),%eax
   14572:	01 d0                	add    %edx,%eax
   14574:	0f b6 00             	movzbl (%eax),%eax
   14577:	88 45 c9             	mov    %al,-0x37(%ebp)
   1457a:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1457d:	8d 50 01             	lea    0x1(%eax),%edx
   14580:	8b 45 08             	mov    0x8(%ebp),%eax
   14583:	01 d0                	add    %edx,%eax
   14585:	0f b6 00             	movzbl (%eax),%eax
   14588:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
   1458b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1458e:	8b 45 10             	mov    0x10(%ebp),%eax
   14591:	01 d0                	add    %edx,%eax
   14593:	0f b6 00             	movzbl (%eax),%eax
   14596:	88 45 c7             	mov    %al,-0x39(%ebp)
   14599:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1459c:	8d 50 01             	lea    0x1(%eax),%edx
   1459f:	8b 45 10             	mov    0x10(%ebp),%eax
   145a2:	01 d0                	add    %edx,%eax
   145a4:	0f b6 00             	movzbl (%eax),%eax
   145a7:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
   145aa:	8b 55 cc             	mov    -0x34(%ebp),%edx
   145ad:	8b 45 10             	mov    0x10(%ebp),%eax
   145b0:	01 d0                	add    %edx,%eax
   145b2:	0f b6 00             	movzbl (%eax),%eax
   145b5:	88 45 c5             	mov    %al,-0x3b(%ebp)
   145b8:	8b 45 cc             	mov    -0x34(%ebp),%eax
   145bb:	8d 50 01             	lea    0x1(%eax),%edx
   145be:	8b 45 10             	mov    0x10(%ebp),%eax
   145c1:	01 d0                	add    %edx,%eax
   145c3:	0f b6 00             	movzbl (%eax),%eax
   145c6:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
   145c9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   145cc:	8b 45 08             	mov    0x8(%ebp),%eax
   145cf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   145d2:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
   145d6:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
   145da:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
   145de:	51                   	push   %ecx
   145df:	52                   	push   %edx
   145e0:	50                   	push   %eax
   145e1:	e8 6e f3 ff ff       	call   13954 <paethPredictor>
   145e6:	83 c4 0c             	add    $0xc,%esp
   145e9:	89 c2                	mov    %eax,%edx
   145eb:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
   145ef:	01 d0                	add    %edx,%eax
   145f1:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
   145f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145f6:	8d 50 01             	lea    0x1(%eax),%edx
   145f9:	8b 45 08             	mov    0x8(%ebp),%eax
   145fc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   145ff:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
   14603:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
   14607:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
   1460b:	51                   	push   %ecx
   1460c:	52                   	push   %edx
   1460d:	50                   	push   %eax
   1460e:	e8 41 f3 ff ff       	call   13954 <paethPredictor>
   14613:	83 c4 0c             	add    $0xc,%esp
   14616:	89 c2                	mov    %eax,%edx
   14618:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
   1461c:	01 d0                	add    %edx,%eax
   1461e:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
   14620:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
   14624:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14627:	83 c0 01             	add    $0x1,%eax
   1462a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   1462d:	0f 8c 11 ff ff ff    	jl     14544 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
   14633:	eb 5f                	jmp    14694 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
   14635:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14638:	8b 45 08             	mov    0x8(%ebp),%eax
   1463b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1463e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14641:	8b 45 0c             	mov    0xc(%ebp),%eax
   14644:	01 d0                	add    %edx,%eax
   14646:	0f b6 00             	movzbl (%eax),%eax
   14649:	88 45 b7             	mov    %al,-0x49(%ebp)
   1464c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1464f:	2b 45 14             	sub    0x14(%ebp),%eax
   14652:	89 c2                	mov    %eax,%edx
   14654:	8b 45 10             	mov    0x10(%ebp),%eax
   14657:	01 d0                	add    %edx,%eax
   14659:	0f b6 00             	movzbl (%eax),%eax
   1465c:	0f b6 c8             	movzbl %al,%ecx
   1465f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14662:	8b 45 10             	mov    0x10(%ebp),%eax
   14665:	01 d0                	add    %edx,%eax
   14667:	0f b6 00             	movzbl (%eax),%eax
   1466a:	0f b6 d0             	movzbl %al,%edx
   1466d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14670:	2b 45 14             	sub    0x14(%ebp),%eax
   14673:	89 c6                	mov    %eax,%esi
   14675:	8b 45 08             	mov    0x8(%ebp),%eax
   14678:	01 f0                	add    %esi,%eax
   1467a:	0f b6 00             	movzbl (%eax),%eax
   1467d:	0f b6 c0             	movzbl %al,%eax
   14680:	51                   	push   %ecx
   14681:	52                   	push   %edx
   14682:	50                   	push   %eax
   14683:	e8 cc f2 ff ff       	call   13954 <paethPredictor>
   14688:	83 c4 0c             	add    $0xc,%esp
   1468b:	02 45 b7             	add    -0x49(%ebp),%al
   1468e:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
   14690:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14694:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14697:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   1469a:	75 99                	jne    14635 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
   1469c:	eb 6e                	jmp    1470c <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
   1469e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   146a5:	eb 19                	jmp    146c0 <unfilterScanline+0x757>
          recon[i] = scanline[i];
   146a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   146aa:	8b 45 08             	mov    0x8(%ebp),%eax
   146ad:	01 c2                	add    %eax,%edx
   146af:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   146b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   146b5:	01 c8                	add    %ecx,%eax
   146b7:	0f b6 00             	movzbl (%eax),%eax
   146ba:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
   146bc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   146c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146c3:	3b 45 14             	cmp    0x14(%ebp),%eax
   146c6:	75 df                	jne    146a7 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
   146c8:	8b 45 14             	mov    0x14(%ebp),%eax
   146cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
   146ce:	eb 2b                	jmp    146fb <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
   146d0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   146d3:	8b 45 08             	mov    0x8(%ebp),%eax
   146d6:	01 c2                	add    %eax,%edx
   146d8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   146db:	8b 45 0c             	mov    0xc(%ebp),%eax
   146de:	01 c8                	add    %ecx,%eax
   146e0:	0f b6 08             	movzbl (%eax),%ecx
   146e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146e6:	2b 45 14             	sub    0x14(%ebp),%eax
   146e9:	89 c3                	mov    %eax,%ebx
   146eb:	8b 45 08             	mov    0x8(%ebp),%eax
   146ee:	01 d8                	add    %ebx,%eax
   146f0:	0f b6 00             	movzbl (%eax),%eax
   146f3:	01 c8                	add    %ecx,%eax
   146f5:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
   146f7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   146fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146fe:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   14701:	7c cd                	jl     146d0 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
   14703:	eb 07                	jmp    1470c <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
   14705:	b8 24 00 00 00       	mov    $0x24,%eax
   1470a:	eb 05                	jmp    14711 <unfilterScanline+0x7a8>
  }
  return 0;
   1470c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14711:	8d 65 f8             	lea    -0x8(%ebp),%esp
   14714:	5b                   	pop    %ebx
   14715:	5e                   	pop    %esi
   14716:	5d                   	pop    %ebp
   14717:	c3                   	ret    

00014718 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   14718:	55                   	push   %ebp
   14719:	89 e5                	mov    %esp,%ebp
   1471b:	53                   	push   %ebx
   1471c:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
   1471f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   14726:	8b 45 18             	mov    0x18(%ebp),%eax
   14729:	83 c0 07             	add    $0x7,%eax
   1472c:	c1 e8 03             	shr    $0x3,%eax
   1472f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   14732:	ff 75 18             	pushl  0x18(%ebp)
   14735:	6a 01                	push   $0x1
   14737:	ff 75 10             	pushl  0x10(%ebp)
   1473a:	e8 d9 b1 ff ff       	call   f918 <lodepng_get_raw_size_idat>
   1473f:	83 c4 0c             	add    $0xc,%esp
   14742:	83 e8 01             	sub    $0x1,%eax
   14745:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
   14748:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1474f:	eb 6d                	jmp    147be <unfilter+0xa6>
    size_t outindex = linebytes * y;
   14751:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14754:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   14758:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   1475b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1475e:	83 c0 01             	add    $0x1,%eax
   14761:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   14765:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
   14768:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1476b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1476e:	01 d0                	add    %edx,%eax
   14770:	0f b6 00             	movzbl (%eax),%eax
   14773:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
   14776:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
   1477a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1477d:	8d 4a 01             	lea    0x1(%edx),%ecx
   14780:	8b 55 0c             	mov    0xc(%ebp),%edx
   14783:	01 d1                	add    %edx,%ecx
   14785:	8b 5d e8             	mov    -0x18(%ebp),%ebx
   14788:	8b 55 08             	mov    0x8(%ebp),%edx
   1478b:	01 da                	add    %ebx,%edx
   1478d:	ff 75 ec             	pushl  -0x14(%ebp)
   14790:	50                   	push   %eax
   14791:	ff 75 f0             	pushl  -0x10(%ebp)
   14794:	ff 75 f4             	pushl  -0xc(%ebp)
   14797:	51                   	push   %ecx
   14798:	52                   	push   %edx
   14799:	e8 cb f7 ff ff       	call   13f69 <unfilterScanline>
   1479e:	83 c4 18             	add    $0x18,%esp
   147a1:	89 45 dc             	mov    %eax,-0x24(%ebp)
   147a4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   147a8:	74 05                	je     147af <unfilter+0x97>
   147aa:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147ad:	eb 1c                	jmp    147cb <unfilter+0xb3>

    prevline = &out[outindex];
   147af:	8b 55 e8             	mov    -0x18(%ebp),%edx
   147b2:	8b 45 08             	mov    0x8(%ebp),%eax
   147b5:	01 d0                	add    %edx,%eax
   147b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
   147ba:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   147be:	8b 45 f8             	mov    -0x8(%ebp),%eax
   147c1:	3b 45 14             	cmp    0x14(%ebp),%eax
   147c4:	72 8b                	jb     14751 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
   147c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   147cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   147ce:	c9                   	leave  
   147cf:	c3                   	ret    

000147d0 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   147d0:	55                   	push   %ebp
   147d1:	89 e5                	mov    %esp,%ebp
   147d3:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   147d9:	ff 75 18             	pushl  0x18(%ebp)
   147dc:	ff 75 14             	pushl  0x14(%ebp)
   147df:	ff 75 10             	pushl  0x10(%ebp)
   147e2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   147e8:	50                   	push   %eax
   147e9:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   147ef:	50                   	push   %eax
   147f0:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   147f6:	50                   	push   %eax
   147f7:	8d 45 94             	lea    -0x6c(%ebp),%eax
   147fa:	50                   	push   %eax
   147fb:	8d 45 b0             	lea    -0x50(%ebp),%eax
   147fe:	50                   	push   %eax
   147ff:	e8 e6 f1 ff ff       	call   139ea <Adam7_getpassvalues>
   14804:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   14807:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   1480b:	0f 86 0a 01 00 00    	jbe    1491b <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
   14811:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   14818:	e9 ef 00 00 00       	jmp    1490c <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   1481d:	8b 45 18             	mov    0x18(%ebp),%eax
   14820:	c1 e8 03             	shr    $0x3,%eax
   14823:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   14826:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1482d:	e9 c6 00 00 00       	jmp    148f8 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   14832:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   14839:	e9 a6 00 00 00       	jmp    148e4 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   1483e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14841:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   14848:	89 c1                	mov    %eax,%ecx
   1484a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1484d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   14851:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   14855:	89 c2                	mov    %eax,%edx
   14857:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1485a:	01 c2                	add    %eax,%edx
   1485c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1485f:	0f af c2             	imul   %edx,%eax
   14862:	01 c8                	add    %ecx,%eax
   14864:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
   14867:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1486a:	8b 14 85 f8 0a 02 00 	mov    0x20af8(,%eax,4),%edx
   14871:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14874:	8b 04 85 30 0b 02 00 	mov    0x20b30(,%eax,4),%eax
   1487b:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1487f:	01 d0                	add    %edx,%eax
   14881:	0f af 45 10          	imul   0x10(%ebp),%eax
   14885:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
   14887:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1488a:	8b 04 85 14 0b 02 00 	mov    0x20b14(,%eax,4),%eax
   14891:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   14895:	01 c2                	add    %eax,%edx
   14897:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1489a:	8b 04 85 dc 0a 02 00 	mov    0x20adc(,%eax,4),%eax
   148a1:	01 c2                	add    %eax,%edx
   148a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   148a6:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
   148a9:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   148ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   148b3:	eb 23                	jmp    148d8 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   148b5:	8b 55 d8             	mov    -0x28(%ebp),%edx
   148b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148bb:	01 c2                	add    %eax,%edx
   148bd:	8b 45 08             	mov    0x8(%ebp),%eax
   148c0:	01 c2                	add    %eax,%edx
   148c2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   148c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148c8:	01 c1                	add    %eax,%ecx
   148ca:	8b 45 0c             	mov    0xc(%ebp),%eax
   148cd:	01 c8                	add    %ecx,%eax
   148cf:	0f b6 00             	movzbl (%eax),%eax
   148d2:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   148d4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   148d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   148db:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   148de:	72 d5                	jb     148b5 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   148e0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   148e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   148e7:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   148eb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   148ee:	0f 87 4a ff ff ff    	ja     1483e <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   148f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   148f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   148fb:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   148ff:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14902:	0f 87 2a ff ff ff    	ja     14832 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   14908:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1490c:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   14910:	0f 85 07 ff ff ff    	jne    1481d <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   14916:	e9 22 01 00 00       	jmp    14a3d <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1491b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   14922:	e9 0c 01 00 00       	jmp    14a33 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   14927:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1492a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1492e:	0f af 45 18          	imul   0x18(%ebp),%eax
   14932:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   14935:	8b 45 18             	mov    0x18(%ebp),%eax
   14938:	0f af 45 10          	imul   0x10(%ebp),%eax
   1493c:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1493f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14946:	e9 d4 00 00 00       	jmp    14a1f <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   1494b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14952:	e9 b4 00 00 00       	jmp    14a0b <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   14957:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1495a:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   14961:	c1 e0 03             	shl    $0x3,%eax
   14964:	89 c1                	mov    %eax,%ecx
   14966:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14969:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   1496d:	89 c2                	mov    %eax,%edx
   1496f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14972:	0f af 45 18          	imul   0x18(%ebp),%eax
   14976:	01 d0                	add    %edx,%eax
   14978:	01 c8                	add    %ecx,%eax
   1497a:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
   14980:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14983:	8b 14 85 f8 0a 02 00 	mov    0x20af8(,%eax,4),%edx
   1498a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1498d:	8b 04 85 30 0b 02 00 	mov    0x20b30(,%eax,4),%eax
   14994:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   14998:	01 d0                	add    %edx,%eax
   1499a:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   1499e:	89 c2                	mov    %eax,%edx
   149a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   149a3:	8b 0c 85 dc 0a 02 00 	mov    0x20adc(,%eax,4),%ecx
   149aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   149ad:	8b 04 85 14 0b 02 00 	mov    0x20b14(,%eax,4),%eax
   149b4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   149b8:	01 c8                	add    %ecx,%eax
   149ba:	0f af 45 18          	imul   0x18(%ebp),%eax
   149be:	01 d0                	add    %edx,%eax
   149c0:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   149c6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   149cd:	eb 30                	jmp    149ff <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   149cf:	ff 75 0c             	pushl  0xc(%ebp)
   149d2:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   149d8:	50                   	push   %eax
   149d9:	e8 1e a1 ff ff       	call   eafc <readBitFromReversedStream>
   149de:	83 c4 08             	add    $0x8,%esp
   149e1:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   149e4:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   149e8:	50                   	push   %eax
   149e9:	ff 75 08             	pushl  0x8(%ebp)
   149ec:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   149f2:	50                   	push   %eax
   149f3:	e8 86 a1 ff ff       	call   eb7e <setBitOfReversedStream>
   149f8:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
   149fb:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   149ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14a02:	3b 45 18             	cmp    0x18(%ebp),%eax
   14a05:	72 c8                	jb     149cf <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   14a07:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14a0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14a0e:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   14a12:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14a15:	0f 87 3c ff ff ff    	ja     14957 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   14a1b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14a1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14a22:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   14a26:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14a29:	0f 87 1c ff ff ff    	ja     1494b <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   14a2f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   14a33:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   14a37:	0f 85 ea fe ff ff    	jne    14927 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   14a3d:	90                   	nop
   14a3e:	c9                   	leave  
   14a3f:	c3                   	ret    

00014a40 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
   14a40:	55                   	push   %ebp
   14a41:	89 e5                	mov    %esp,%ebp
   14a43:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
   14a46:	8b 45 14             	mov    0x14(%ebp),%eax
   14a49:	2b 45 10             	sub    0x10(%ebp),%eax
   14a4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
   14a4f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14a56:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
   14a5d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   14a64:	eb 4a                	jmp    14ab0 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
   14a66:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   14a6d:	eb 2a                	jmp    14a99 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   14a6f:	ff 75 0c             	pushl  0xc(%ebp)
   14a72:	8d 45 ec             	lea    -0x14(%ebp),%eax
   14a75:	50                   	push   %eax
   14a76:	e8 81 a0 ff ff       	call   eafc <readBitFromReversedStream>
   14a7b:	83 c4 08             	add    $0x8,%esp
   14a7e:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   14a81:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   14a85:	50                   	push   %eax
   14a86:	ff 75 08             	pushl  0x8(%ebp)
   14a89:	8d 45 e8             	lea    -0x18(%ebp),%eax
   14a8c:	50                   	push   %eax
   14a8d:	e8 ec a0 ff ff       	call   eb7e <setBitOfReversedStream>
   14a92:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
   14a95:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   14a99:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14a9c:	3b 45 10             	cmp    0x10(%ebp),%eax
   14a9f:	7c ce                	jl     14a6f <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
   14aa1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14aa7:	01 d0                	add    %edx,%eax
   14aa9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
   14aac:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   14ab0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14ab3:	3b 45 18             	cmp    0x18(%ebp),%eax
   14ab6:	72 ae                	jb     14a66 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
   14ab8:	90                   	nop
   14ab9:	c9                   	leave  
   14aba:	c3                   	ret    

00014abb <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
   14abb:	55                   	push   %ebp
   14abc:	89 e5                	mov    %esp,%ebp
   14abe:	57                   	push   %edi
   14abf:	56                   	push   %esi
   14ac0:	53                   	push   %ebx
   14ac1:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   14ac7:	8b 45 18             	mov    0x18(%ebp),%eax
   14aca:	83 c0 0c             	add    $0xc,%eax
   14acd:	50                   	push   %eax
   14ace:	e8 e6 ac ff ff       	call   f7b9 <lodepng_get_bpp>
   14ad3:	83 c4 04             	add    $0x4,%esp
   14ad6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
   14ad9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14add:	75 0a                	jne    14ae9 <postProcessScanlines+0x2e>
   14adf:	b8 1f 00 00 00       	mov    $0x1f,%eax
   14ae4:	e9 c3 01 00 00       	jmp    14cac <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
   14ae9:	8b 45 18             	mov    0x18(%ebp),%eax
   14aec:	8b 40 08             	mov    0x8(%eax),%eax
   14aef:	85 c0                	test   %eax,%eax
   14af1:	0f 85 a8 00 00 00    	jne    14b9f <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   14af7:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
   14afb:	77 76                	ja     14b73 <postProcessScanlines+0xb8>
   14afd:	8b 45 10             	mov    0x10(%ebp),%eax
   14b00:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14b04:	89 c2                	mov    %eax,%edx
   14b06:	8b 45 10             	mov    0x10(%ebp),%eax
   14b09:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14b0d:	83 c0 07             	add    $0x7,%eax
   14b10:	c1 e8 03             	shr    $0x3,%eax
   14b13:	c1 e0 03             	shl    $0x3,%eax
   14b16:	39 c2                	cmp    %eax,%edx
   14b18:	74 59                	je     14b73 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
   14b1a:	ff 75 ec             	pushl  -0x14(%ebp)
   14b1d:	ff 75 14             	pushl  0x14(%ebp)
   14b20:	ff 75 10             	pushl  0x10(%ebp)
   14b23:	ff 75 0c             	pushl  0xc(%ebp)
   14b26:	ff 75 0c             	pushl  0xc(%ebp)
   14b29:	e8 ea fb ff ff       	call   14718 <unfilter>
   14b2e:	83 c4 14             	add    $0x14,%esp
   14b31:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14b34:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   14b38:	74 08                	je     14b42 <postProcessScanlines+0x87>
   14b3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b3d:	e9 6a 01 00 00       	jmp    14cac <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
   14b42:	8b 45 10             	mov    0x10(%ebp),%eax
   14b45:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14b49:	83 c0 07             	add    $0x7,%eax
   14b4c:	c1 e8 03             	shr    $0x3,%eax
   14b4f:	c1 e0 03             	shl    $0x3,%eax
   14b52:	89 c2                	mov    %eax,%edx
   14b54:	8b 45 10             	mov    0x10(%ebp),%eax
   14b57:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14b5b:	ff 75 14             	pushl  0x14(%ebp)
   14b5e:	52                   	push   %edx
   14b5f:	50                   	push   %eax
   14b60:	ff 75 0c             	pushl  0xc(%ebp)
   14b63:	ff 75 08             	pushl  0x8(%ebp)
   14b66:	e8 d5 fe ff ff       	call   14a40 <removePaddingBits>
   14b6b:	83 c4 14             	add    $0x14,%esp
   14b6e:	e9 34 01 00 00       	jmp    14ca7 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
   14b73:	ff 75 ec             	pushl  -0x14(%ebp)
   14b76:	ff 75 14             	pushl  0x14(%ebp)
   14b79:	ff 75 10             	pushl  0x10(%ebp)
   14b7c:	ff 75 0c             	pushl  0xc(%ebp)
   14b7f:	ff 75 08             	pushl  0x8(%ebp)
   14b82:	e8 91 fb ff ff       	call   14718 <unfilter>
   14b87:	83 c4 14             	add    $0x14,%esp
   14b8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   14b8d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   14b91:	0f 84 10 01 00 00    	je     14ca7 <postProcessScanlines+0x1ec>
   14b97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14b9a:	e9 0d 01 00 00       	jmp    14cac <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   14b9f:	ff 75 ec             	pushl  -0x14(%ebp)
   14ba2:	ff 75 14             	pushl  0x14(%ebp)
   14ba5:	ff 75 10             	pushl  0x10(%ebp)
   14ba8:	8d 45 88             	lea    -0x78(%ebp),%eax
   14bab:	50                   	push   %eax
   14bac:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
   14bb2:	50                   	push   %eax
   14bb3:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
   14bb9:	50                   	push   %eax
   14bba:	8d 45 a8             	lea    -0x58(%ebp),%eax
   14bbd:	50                   	push   %eax
   14bbe:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   14bc1:	50                   	push   %eax
   14bc2:	e8 23 ee ff ff       	call   139ea <Adam7_getpassvalues>
   14bc7:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
   14bca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14bd1:	e9 b0 00 00 00       	jmp    14c86 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
   14bd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14bd9:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
   14bdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14be0:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
   14be4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   14be7:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
   14bee:	89 cb                	mov    %ecx,%ebx
   14bf0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   14bf3:	01 cb                	add    %ecx,%ebx
   14bf5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   14bf8:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
   14bff:	89 ce                	mov    %ecx,%esi
   14c01:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   14c04:	01 f1                	add    %esi,%ecx
   14c06:	ff 75 ec             	pushl  -0x14(%ebp)
   14c09:	52                   	push   %edx
   14c0a:	50                   	push   %eax
   14c0b:	53                   	push   %ebx
   14c0c:	51                   	push   %ecx
   14c0d:	e8 06 fb ff ff       	call   14718 <unfilter>
   14c12:	83 c4 14             	add    $0x14,%esp
   14c15:	89 45 e0             	mov    %eax,-0x20(%ebp)
   14c18:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14c1c:	74 08                	je     14c26 <postProcessScanlines+0x16b>
   14c1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14c21:	e9 86 00 00 00       	jmp    14cac <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
   14c26:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
   14c2a:	77 56                	ja     14c82 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
   14c2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c2f:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
   14c33:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14c36:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
   14c3a:	0f af 55 ec          	imul   -0x14(%ebp),%edx
   14c3e:	83 c2 07             	add    $0x7,%edx
   14c41:	c1 ea 03             	shr    $0x3,%edx
   14c44:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
   14c47:	89 d6                	mov    %edx,%esi
   14c49:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14c4c:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
   14c50:	0f af 55 ec          	imul   -0x14(%ebp),%edx
   14c54:	89 d3                	mov    %edx,%ebx
   14c56:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14c59:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
   14c60:	89 d1                	mov    %edx,%ecx
   14c62:	8b 55 0c             	mov    0xc(%ebp),%edx
   14c65:	01 d1                	add    %edx,%ecx
   14c67:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14c6a:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
   14c6e:	89 d7                	mov    %edx,%edi
   14c70:	8b 55 0c             	mov    0xc(%ebp),%edx
   14c73:	01 fa                	add    %edi,%edx
   14c75:	50                   	push   %eax
   14c76:	56                   	push   %esi
   14c77:	53                   	push   %ebx
   14c78:	51                   	push   %ecx
   14c79:	52                   	push   %edx
   14c7a:	e8 c1 fd ff ff       	call   14a40 <removePaddingBits>
   14c7f:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
   14c82:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14c86:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
   14c8a:	0f 85 46 ff ff ff    	jne    14bd6 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
   14c90:	ff 75 ec             	pushl  -0x14(%ebp)
   14c93:	ff 75 14             	pushl  0x14(%ebp)
   14c96:	ff 75 10             	pushl  0x10(%ebp)
   14c99:	ff 75 0c             	pushl  0xc(%ebp)
   14c9c:	ff 75 08             	pushl  0x8(%ebp)
   14c9f:	e8 2c fb ff ff       	call   147d0 <Adam7_deinterlace>
   14ca4:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
   14ca7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14cac:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14caf:	5b                   	pop    %ebx
   14cb0:	5e                   	pop    %esi
   14cb1:	5f                   	pop    %edi
   14cb2:	5d                   	pop    %ebp
   14cb3:	c3                   	ret    

00014cb4 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
   14cb4:	55                   	push   %ebp
   14cb5:	89 e5                	mov    %esp,%ebp
   14cb7:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
   14cba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
   14cc1:	8b 45 10             	mov    0x10(%ebp),%eax
   14cc4:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
   14cc9:	f7 e2                	mul    %edx
   14ccb:	89 d0                	mov    %edx,%eax
   14ccd:	d1 e8                	shr    %eax
   14ccf:	89 c2                	mov    %eax,%edx
   14cd1:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd4:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
   14cd7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cda:	8b 40 0c             	mov    0xc(%eax),%eax
   14cdd:	85 c0                	test   %eax,%eax
   14cdf:	74 0d                	je     14cee <readChunk_PLTE+0x3a>
   14ce1:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce4:	8b 40 0c             	mov    0xc(%eax),%eax
   14ce7:	3d 00 01 00 00       	cmp    $0x100,%eax
   14cec:	7e 0a                	jle    14cf8 <readChunk_PLTE+0x44>
   14cee:	b8 26 00 00 00       	mov    $0x26,%eax
   14cf3:	e9 da 00 00 00       	jmp    14dd2 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
   14cf8:	83 ec 0c             	sub    $0xc,%esp
   14cfb:	ff 75 08             	pushl  0x8(%ebp)
   14cfe:	e8 02 a7 ff ff       	call   f405 <lodepng_color_mode_alloc_palette>
   14d03:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
   14d06:	8b 45 08             	mov    0x8(%ebp),%eax
   14d09:	8b 40 08             	mov    0x8(%eax),%eax
   14d0c:	85 c0                	test   %eax,%eax
   14d0e:	75 1e                	jne    14d2e <readChunk_PLTE+0x7a>
   14d10:	8b 45 08             	mov    0x8(%ebp),%eax
   14d13:	8b 40 0c             	mov    0xc(%eax),%eax
   14d16:	85 c0                	test   %eax,%eax
   14d18:	74 14                	je     14d2e <readChunk_PLTE+0x7a>
    color->palettesize = 0;
   14d1a:	8b 45 08             	mov    0x8(%ebp),%eax
   14d1d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
   14d24:	b8 53 00 00 00       	mov    $0x53,%eax
   14d29:	e9 a4 00 00 00       	jmp    14dd2 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
   14d2e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14d35:	e9 84 00 00 00       	jmp    14dbe <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
   14d3a:	8b 45 08             	mov    0x8(%ebp),%eax
   14d3d:	8b 40 08             	mov    0x8(%eax),%eax
   14d40:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14d43:	c1 e2 02             	shl    $0x2,%edx
   14d46:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   14d49:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14d4c:	8d 50 01             	lea    0x1(%eax),%edx
   14d4f:	89 55 f4             	mov    %edx,-0xc(%ebp)
   14d52:	8b 55 0c             	mov    0xc(%ebp),%edx
   14d55:	01 d0                	add    %edx,%eax
   14d57:	0f b6 00             	movzbl (%eax),%eax
   14d5a:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
   14d5c:	8b 45 08             	mov    0x8(%ebp),%eax
   14d5f:	8b 40 08             	mov    0x8(%eax),%eax
   14d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14d65:	c1 e2 02             	shl    $0x2,%edx
   14d68:	83 c2 01             	add    $0x1,%edx
   14d6b:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   14d6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14d71:	8d 50 01             	lea    0x1(%eax),%edx
   14d74:	89 55 f4             	mov    %edx,-0xc(%ebp)
   14d77:	8b 55 0c             	mov    0xc(%ebp),%edx
   14d7a:	01 d0                	add    %edx,%eax
   14d7c:	0f b6 00             	movzbl (%eax),%eax
   14d7f:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
   14d81:	8b 45 08             	mov    0x8(%ebp),%eax
   14d84:	8b 40 08             	mov    0x8(%eax),%eax
   14d87:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14d8a:	c1 e2 02             	shl    $0x2,%edx
   14d8d:	83 c2 02             	add    $0x2,%edx
   14d90:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   14d93:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14d96:	8d 50 01             	lea    0x1(%eax),%edx
   14d99:	89 55 f4             	mov    %edx,-0xc(%ebp)
   14d9c:	8b 55 0c             	mov    0xc(%ebp),%edx
   14d9f:	01 d0                	add    %edx,%eax
   14da1:	0f b6 00             	movzbl (%eax),%eax
   14da4:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
   14da6:	8b 45 08             	mov    0x8(%ebp),%eax
   14da9:	8b 40 08             	mov    0x8(%eax),%eax
   14dac:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14daf:	c1 e2 02             	shl    $0x2,%edx
   14db2:	83 c2 03             	add    $0x3,%edx
   14db5:	01 d0                	add    %edx,%eax
   14db7:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
   14dba:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14dbe:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc1:	8b 40 0c             	mov    0xc(%eax),%eax
   14dc4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14dc7:	0f 85 6d ff ff ff    	jne    14d3a <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
   14dcd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14dd2:	c9                   	leave  
   14dd3:	c3                   	ret    

00014dd4 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
   14dd4:	55                   	push   %ebp
   14dd5:	89 e5                	mov    %esp,%ebp
   14dd7:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
   14dda:	8b 45 08             	mov    0x8(%ebp),%eax
   14ddd:	8b 00                	mov    (%eax),%eax
   14ddf:	83 f8 03             	cmp    $0x3,%eax
   14de2:	75 4d                	jne    14e31 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
   14de4:	8b 45 08             	mov    0x8(%ebp),%eax
   14de7:	8b 40 0c             	mov    0xc(%eax),%eax
   14dea:	3b 45 10             	cmp    0x10(%ebp),%eax
   14ded:	7d 0a                	jge    14df9 <readChunk_tRNS+0x25>
   14def:	b8 27 00 00 00       	mov    $0x27,%eax
   14df4:	e9 3c 01 00 00       	jmp    14f35 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
   14df9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   14e00:	eb 22                	jmp    14e24 <readChunk_tRNS+0x50>
   14e02:	8b 45 08             	mov    0x8(%ebp),%eax
   14e05:	8b 40 08             	mov    0x8(%eax),%eax
   14e08:	8b 55 fc             	mov    -0x4(%ebp),%edx
   14e0b:	c1 e2 02             	shl    $0x2,%edx
   14e0e:	83 c2 03             	add    $0x3,%edx
   14e11:	01 c2                	add    %eax,%edx
   14e13:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   14e16:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14e19:	01 c8                	add    %ecx,%eax
   14e1b:	0f b6 00             	movzbl (%eax),%eax
   14e1e:	88 02                	mov    %al,(%edx)
   14e20:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   14e24:	8b 45 10             	mov    0x10(%ebp),%eax
   14e27:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   14e2a:	75 d6                	jne    14e02 <readChunk_tRNS+0x2e>
   14e2c:	e9 ff 00 00 00       	jmp    14f30 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
   14e31:	8b 45 08             	mov    0x8(%ebp),%eax
   14e34:	8b 00                	mov    (%eax),%eax
   14e36:	85 c0                	test   %eax,%eax
   14e38:	75 59                	jne    14e93 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
   14e3a:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   14e3e:	74 0a                	je     14e4a <readChunk_tRNS+0x76>
   14e40:	b8 1e 00 00 00       	mov    $0x1e,%eax
   14e45:	e9 eb 00 00 00       	jmp    14f35 <readChunk_tRNS+0x161>

    color->key_defined = 1;
   14e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e4d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
   14e54:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e57:	0f b6 00             	movzbl (%eax),%eax
   14e5a:	0f b6 c0             	movzbl %al,%eax
   14e5d:	c1 e0 08             	shl    $0x8,%eax
   14e60:	89 c2                	mov    %eax,%edx
   14e62:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e65:	83 c0 01             	add    $0x1,%eax
   14e68:	0f b6 00             	movzbl (%eax),%eax
   14e6b:	0f b6 c0             	movzbl %al,%eax
   14e6e:	01 c2                	add    %eax,%edx
   14e70:	8b 45 08             	mov    0x8(%ebp),%eax
   14e73:	89 50 1c             	mov    %edx,0x1c(%eax)
   14e76:	8b 45 08             	mov    0x8(%ebp),%eax
   14e79:	8b 50 1c             	mov    0x1c(%eax),%edx
   14e7c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e7f:	89 50 18             	mov    %edx,0x18(%eax)
   14e82:	8b 45 08             	mov    0x8(%ebp),%eax
   14e85:	8b 50 18             	mov    0x18(%eax),%edx
   14e88:	8b 45 08             	mov    0x8(%ebp),%eax
   14e8b:	89 50 14             	mov    %edx,0x14(%eax)
   14e8e:	e9 9d 00 00 00       	jmp    14f30 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
   14e93:	8b 45 08             	mov    0x8(%ebp),%eax
   14e96:	8b 00                	mov    (%eax),%eax
   14e98:	83 f8 02             	cmp    $0x2,%eax
   14e9b:	0f 85 88 00 00 00    	jne    14f29 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
   14ea1:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
   14ea5:	74 0a                	je     14eb1 <readChunk_tRNS+0xdd>
   14ea7:	b8 29 00 00 00       	mov    $0x29,%eax
   14eac:	e9 84 00 00 00       	jmp    14f35 <readChunk_tRNS+0x161>

    color->key_defined = 1;
   14eb1:	8b 45 08             	mov    0x8(%ebp),%eax
   14eb4:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
   14ebb:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ebe:	0f b6 00             	movzbl (%eax),%eax
   14ec1:	0f b6 c0             	movzbl %al,%eax
   14ec4:	c1 e0 08             	shl    $0x8,%eax
   14ec7:	89 c2                	mov    %eax,%edx
   14ec9:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ecc:	83 c0 01             	add    $0x1,%eax
   14ecf:	0f b6 00             	movzbl (%eax),%eax
   14ed2:	0f b6 c0             	movzbl %al,%eax
   14ed5:	01 c2                	add    %eax,%edx
   14ed7:	8b 45 08             	mov    0x8(%ebp),%eax
   14eda:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
   14edd:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ee0:	83 c0 02             	add    $0x2,%eax
   14ee3:	0f b6 00             	movzbl (%eax),%eax
   14ee6:	0f b6 c0             	movzbl %al,%eax
   14ee9:	c1 e0 08             	shl    $0x8,%eax
   14eec:	89 c2                	mov    %eax,%edx
   14eee:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ef1:	83 c0 03             	add    $0x3,%eax
   14ef4:	0f b6 00             	movzbl (%eax),%eax
   14ef7:	0f b6 c0             	movzbl %al,%eax
   14efa:	01 c2                	add    %eax,%edx
   14efc:	8b 45 08             	mov    0x8(%ebp),%eax
   14eff:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
   14f02:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f05:	83 c0 04             	add    $0x4,%eax
   14f08:	0f b6 00             	movzbl (%eax),%eax
   14f0b:	0f b6 c0             	movzbl %al,%eax
   14f0e:	c1 e0 08             	shl    $0x8,%eax
   14f11:	89 c2                	mov    %eax,%edx
   14f13:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f16:	83 c0 05             	add    $0x5,%eax
   14f19:	0f b6 00             	movzbl (%eax),%eax
   14f1c:	0f b6 c0             	movzbl %al,%eax
   14f1f:	01 c2                	add    %eax,%edx
   14f21:	8b 45 08             	mov    0x8(%ebp),%eax
   14f24:	89 50 1c             	mov    %edx,0x1c(%eax)
   14f27:	eb 07                	jmp    14f30 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
   14f29:	b8 2a 00 00 00       	mov    $0x2a,%eax
   14f2e:	eb 05                	jmp    14f35 <readChunk_tRNS+0x161>

  return 0; /* OK */
   14f30:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14f35:	c9                   	leave  
   14f36:	c3                   	ret    

00014f37 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   14f37:	55                   	push   %ebp
   14f38:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
   14f3a:	8b 45 08             	mov    0x8(%ebp),%eax
   14f3d:	8b 40 0c             	mov    0xc(%eax),%eax
   14f40:	83 f8 03             	cmp    $0x3,%eax
   14f43:	75 63                	jne    14fa8 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
   14f45:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
   14f49:	74 0a                	je     14f55 <readChunk_bKGD+0x1e>
   14f4b:	b8 2b 00 00 00       	mov    $0x2b,%eax
   14f50:	e9 63 01 00 00       	jmp    150b8 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
   14f55:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f58:	0f b6 00             	movzbl (%eax),%eax
   14f5b:	0f b6 d0             	movzbl %al,%edx
   14f5e:	8b 45 08             	mov    0x8(%ebp),%eax
   14f61:	8b 40 18             	mov    0x18(%eax),%eax
   14f64:	39 c2                	cmp    %eax,%edx
   14f66:	7c 0a                	jl     14f72 <readChunk_bKGD+0x3b>
   14f68:	b8 67 00 00 00       	mov    $0x67,%eax
   14f6d:	e9 46 01 00 00       	jmp    150b8 <readChunk_bKGD+0x181>

    info->background_defined = 1;
   14f72:	8b 45 08             	mov    0x8(%ebp),%eax
   14f75:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
   14f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f7f:	0f b6 00             	movzbl (%eax),%eax
   14f82:	0f b6 d0             	movzbl %al,%edx
   14f85:	8b 45 08             	mov    0x8(%ebp),%eax
   14f88:	89 50 38             	mov    %edx,0x38(%eax)
   14f8b:	8b 45 08             	mov    0x8(%ebp),%eax
   14f8e:	8b 50 38             	mov    0x38(%eax),%edx
   14f91:	8b 45 08             	mov    0x8(%ebp),%eax
   14f94:	89 50 34             	mov    %edx,0x34(%eax)
   14f97:	8b 45 08             	mov    0x8(%ebp),%eax
   14f9a:	8b 50 34             	mov    0x34(%eax),%edx
   14f9d:	8b 45 08             	mov    0x8(%ebp),%eax
   14fa0:	89 50 30             	mov    %edx,0x30(%eax)
   14fa3:	e9 0b 01 00 00       	jmp    150b3 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   14fa8:	8b 45 08             	mov    0x8(%ebp),%eax
   14fab:	8b 40 0c             	mov    0xc(%eax),%eax
   14fae:	85 c0                	test   %eax,%eax
   14fb0:	74 0b                	je     14fbd <readChunk_bKGD+0x86>
   14fb2:	8b 45 08             	mov    0x8(%ebp),%eax
   14fb5:	8b 40 0c             	mov    0xc(%eax),%eax
   14fb8:	83 f8 04             	cmp    $0x4,%eax
   14fbb:	75 59                	jne    15016 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
   14fbd:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   14fc1:	74 0a                	je     14fcd <readChunk_bKGD+0x96>
   14fc3:	b8 2c 00 00 00       	mov    $0x2c,%eax
   14fc8:	e9 eb 00 00 00       	jmp    150b8 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
   14fcd:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd0:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
   14fd7:	8b 45 0c             	mov    0xc(%ebp),%eax
   14fda:	0f b6 00             	movzbl (%eax),%eax
   14fdd:	0f b6 c0             	movzbl %al,%eax
   14fe0:	c1 e0 08             	shl    $0x8,%eax
   14fe3:	89 c2                	mov    %eax,%edx
   14fe5:	8b 45 0c             	mov    0xc(%ebp),%eax
   14fe8:	83 c0 01             	add    $0x1,%eax
   14feb:	0f b6 00             	movzbl (%eax),%eax
   14fee:	0f b6 c0             	movzbl %al,%eax
   14ff1:	01 c2                	add    %eax,%edx
   14ff3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ff6:	89 50 38             	mov    %edx,0x38(%eax)
   14ff9:	8b 45 08             	mov    0x8(%ebp),%eax
   14ffc:	8b 50 38             	mov    0x38(%eax),%edx
   14fff:	8b 45 08             	mov    0x8(%ebp),%eax
   15002:	89 50 34             	mov    %edx,0x34(%eax)
   15005:	8b 45 08             	mov    0x8(%ebp),%eax
   15008:	8b 50 34             	mov    0x34(%eax),%edx
   1500b:	8b 45 08             	mov    0x8(%ebp),%eax
   1500e:	89 50 30             	mov    %edx,0x30(%eax)
   15011:	e9 9d 00 00 00       	jmp    150b3 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   15016:	8b 45 08             	mov    0x8(%ebp),%eax
   15019:	8b 40 0c             	mov    0xc(%eax),%eax
   1501c:	83 f8 02             	cmp    $0x2,%eax
   1501f:	74 0f                	je     15030 <readChunk_bKGD+0xf9>
   15021:	8b 45 08             	mov    0x8(%ebp),%eax
   15024:	8b 40 0c             	mov    0xc(%eax),%eax
   15027:	83 f8 06             	cmp    $0x6,%eax
   1502a:	0f 85 83 00 00 00    	jne    150b3 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
   15030:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
   15034:	74 07                	je     1503d <readChunk_bKGD+0x106>
   15036:	b8 2d 00 00 00       	mov    $0x2d,%eax
   1503b:	eb 7b                	jmp    150b8 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
   1503d:	8b 45 08             	mov    0x8(%ebp),%eax
   15040:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
   15047:	8b 45 0c             	mov    0xc(%ebp),%eax
   1504a:	0f b6 00             	movzbl (%eax),%eax
   1504d:	0f b6 c0             	movzbl %al,%eax
   15050:	c1 e0 08             	shl    $0x8,%eax
   15053:	89 c2                	mov    %eax,%edx
   15055:	8b 45 0c             	mov    0xc(%ebp),%eax
   15058:	83 c0 01             	add    $0x1,%eax
   1505b:	0f b6 00             	movzbl (%eax),%eax
   1505e:	0f b6 c0             	movzbl %al,%eax
   15061:	01 c2                	add    %eax,%edx
   15063:	8b 45 08             	mov    0x8(%ebp),%eax
   15066:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
   15069:	8b 45 0c             	mov    0xc(%ebp),%eax
   1506c:	83 c0 02             	add    $0x2,%eax
   1506f:	0f b6 00             	movzbl (%eax),%eax
   15072:	0f b6 c0             	movzbl %al,%eax
   15075:	c1 e0 08             	shl    $0x8,%eax
   15078:	89 c2                	mov    %eax,%edx
   1507a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1507d:	83 c0 03             	add    $0x3,%eax
   15080:	0f b6 00             	movzbl (%eax),%eax
   15083:	0f b6 c0             	movzbl %al,%eax
   15086:	01 c2                	add    %eax,%edx
   15088:	8b 45 08             	mov    0x8(%ebp),%eax
   1508b:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
   1508e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15091:	83 c0 04             	add    $0x4,%eax
   15094:	0f b6 00             	movzbl (%eax),%eax
   15097:	0f b6 c0             	movzbl %al,%eax
   1509a:	c1 e0 08             	shl    $0x8,%eax
   1509d:	89 c2                	mov    %eax,%edx
   1509f:	8b 45 0c             	mov    0xc(%ebp),%eax
   150a2:	83 c0 05             	add    $0x5,%eax
   150a5:	0f b6 00             	movzbl (%eax),%eax
   150a8:	0f b6 c0             	movzbl %al,%eax
   150ab:	01 c2                	add    %eax,%edx
   150ad:	8b 45 08             	mov    0x8(%ebp),%eax
   150b0:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
   150b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
   150b8:	5d                   	pop    %ebp
   150b9:	c3                   	ret    

000150ba <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   150ba:	55                   	push   %ebp
   150bb:	89 e5                	mov    %esp,%ebp
   150bd:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
   150c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
   150c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   150ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
   150d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   150d9:	0f 85 06 01 00 00    	jne    151e5 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
   150df:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
   150e6:	eb 04                	jmp    150ec <readChunk_tEXt+0x32>
   150e8:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   150ec:	8b 45 10             	mov    0x10(%ebp),%eax
   150ef:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   150f2:	73 0f                	jae    15103 <readChunk_tEXt+0x49>
   150f4:	8b 55 0c             	mov    0xc(%ebp),%edx
   150f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150fa:	01 d0                	add    %edx,%eax
   150fc:	0f b6 00             	movzbl (%eax),%eax
   150ff:	84 c0                	test   %al,%al
   15101:	75 e5                	jne    150e8 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
   15103:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15107:	74 06                	je     1510f <readChunk_tEXt+0x55>
   15109:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
   1510d:	76 0c                	jbe    1511b <readChunk_tEXt+0x61>
   1510f:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
   15116:	e9 ca 00 00 00       	jmp    151e5 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
   1511b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1511e:	83 c0 01             	add    $0x1,%eax
   15121:	83 ec 0c             	sub    $0xc,%esp
   15124:	50                   	push   %eax
   15125:	e8 73 4b ff ff       	call   9c9d <lodepng_malloc>
   1512a:	83 c4 10             	add    $0x10,%esp
   1512d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
   15130:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15134:	75 0c                	jne    15142 <readChunk_tEXt+0x88>
   15136:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   1513d:	e9 a3 00 00 00       	jmp    151e5 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
   15142:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15145:	83 ec 04             	sub    $0x4,%esp
   15148:	50                   	push   %eax
   15149:	ff 75 0c             	pushl  0xc(%ebp)
   1514c:	ff 75 f0             	pushl  -0x10(%ebp)
   1514f:	e8 87 4b ff ff       	call   9cdb <lodepng_memcpy>
   15154:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
   15157:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1515a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1515d:	01 d0                	add    %edx,%eax
   1515f:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
   15162:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15165:	83 c0 01             	add    $0x1,%eax
   15168:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
   1516b:	8b 45 10             	mov    0x10(%ebp),%eax
   1516e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15171:	72 08                	jb     1517b <readChunk_tEXt+0xc1>
   15173:	8b 45 10             	mov    0x10(%ebp),%eax
   15176:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15179:	eb 05                	jmp    15180 <readChunk_tEXt+0xc6>
   1517b:	b8 00 00 00 00       	mov    $0x0,%eax
   15180:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
   15183:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15186:	83 c0 01             	add    $0x1,%eax
   15189:	83 ec 0c             	sub    $0xc,%esp
   1518c:	50                   	push   %eax
   1518d:	e8 0b 4b ff ff       	call   9c9d <lodepng_malloc>
   15192:	83 c4 10             	add    $0x10,%esp
   15195:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
   15198:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1519c:	75 09                	jne    151a7 <readChunk_tEXt+0xed>
   1519e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   151a5:	eb 3e                	jmp    151e5 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
   151a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   151aa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   151ad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   151b0:	01 ca                	add    %ecx,%edx
   151b2:	83 ec 04             	sub    $0x4,%esp
   151b5:	50                   	push   %eax
   151b6:	52                   	push   %edx
   151b7:	ff 75 ec             	pushl  -0x14(%ebp)
   151ba:	e8 1c 4b ff ff       	call   9cdb <lodepng_memcpy>
   151bf:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
   151c2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   151c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   151c8:	01 d0                	add    %edx,%eax
   151ca:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
   151cd:	83 ec 04             	sub    $0x4,%esp
   151d0:	ff 75 ec             	pushl  -0x14(%ebp)
   151d3:	ff 75 f0             	pushl  -0x10(%ebp)
   151d6:	ff 75 08             	pushl  0x8(%ebp)
   151d9:	e8 3f ac ff ff       	call   fe1d <lodepng_add_text>
   151de:	83 c4 10             	add    $0x10,%esp
   151e1:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
   151e4:	90                   	nop
  }

  lodepng_free(key);
   151e5:	83 ec 0c             	sub    $0xc,%esp
   151e8:	ff 75 f0             	pushl  -0x10(%ebp)
   151eb:	e8 ce 4a ff ff       	call   9cbe <lodepng_free>
   151f0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
   151f3:	83 ec 0c             	sub    $0xc,%esp
   151f6:	ff 75 ec             	pushl  -0x14(%ebp)
   151f9:	e8 c0 4a ff ff       	call   9cbe <lodepng_free>
   151fe:	83 c4 10             	add    $0x10,%esp

  return error;
   15201:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   15204:	c9                   	leave  
   15205:	c3                   	ret    

00015206 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   15206:	55                   	push   %ebp
   15207:	89 e5                	mov    %esp,%ebp
   15209:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
   1520c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   15213:	8b 45 0c             	mov    0xc(%ebp),%eax
   15216:	8b 10                	mov    (%eax),%edx
   15218:	89 55 d0             	mov    %edx,-0x30(%ebp)
   1521b:	8b 50 04             	mov    0x4(%eax),%edx
   1521e:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   15221:	8b 50 08             	mov    0x8(%eax),%edx
   15224:	89 55 d8             	mov    %edx,-0x28(%ebp)
   15227:	8b 50 0c             	mov    0xc(%eax),%edx
   1522a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1522d:	8b 50 10             	mov    0x10(%eax),%edx
   15230:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15233:	8b 40 14             	mov    0x14(%eax),%eax
   15236:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
   15239:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
   15240:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
   15247:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
   1524e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15252:	0f 85 48 01 00 00    	jne    153a0 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   15258:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1525f:	eb 04                	jmp    15265 <readChunk_zTXt+0x5f>
   15261:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15265:	8b 45 14             	mov    0x14(%ebp),%eax
   15268:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1526b:	73 0f                	jae    1527c <readChunk_zTXt+0x76>
   1526d:	8b 55 10             	mov    0x10(%ebp),%edx
   15270:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15273:	01 d0                	add    %edx,%eax
   15275:	0f b6 00             	movzbl (%eax),%eax
   15278:	84 c0                	test   %al,%al
   1527a:	75 e5                	jne    15261 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
   1527c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1527f:	8d 50 02             	lea    0x2(%eax),%edx
   15282:	8b 45 14             	mov    0x14(%ebp),%eax
   15285:	39 c2                	cmp    %eax,%edx
   15287:	72 0c                	jb     15295 <readChunk_zTXt+0x8f>
   15289:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   15290:	e9 0b 01 00 00       	jmp    153a0 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
   15295:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15299:	74 06                	je     152a1 <readChunk_zTXt+0x9b>
   1529b:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   1529f:	76 0c                	jbe    152ad <readChunk_zTXt+0xa7>
   152a1:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
   152a8:	e9 f3 00 00 00       	jmp    153a0 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
   152ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152b0:	83 c0 01             	add    $0x1,%eax
   152b3:	83 ec 0c             	sub    $0xc,%esp
   152b6:	50                   	push   %eax
   152b7:	e8 e1 49 ff ff       	call   9c9d <lodepng_malloc>
   152bc:	83 c4 10             	add    $0x10,%esp
   152bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
   152c2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   152c6:	75 0c                	jne    152d4 <readChunk_zTXt+0xce>
   152c8:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   152cf:	e9 cc 00 00 00       	jmp    153a0 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
   152d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152d7:	83 ec 04             	sub    $0x4,%esp
   152da:	50                   	push   %eax
   152db:	ff 75 10             	pushl  0x10(%ebp)
   152de:	ff 75 ec             	pushl  -0x14(%ebp)
   152e1:	e8 f5 49 ff ff       	call   9cdb <lodepng_memcpy>
   152e6:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
   152e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
   152ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152ef:	01 d0                	add    %edx,%eax
   152f1:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
   152f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152f7:	8d 50 01             	lea    0x1(%eax),%edx
   152fa:	8b 45 10             	mov    0x10(%ebp),%eax
   152fd:	01 d0                	add    %edx,%eax
   152ff:	0f b6 00             	movzbl (%eax),%eax
   15302:	84 c0                	test   %al,%al
   15304:	74 0c                	je     15312 <readChunk_zTXt+0x10c>
   15306:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
   1530d:	e9 8e 00 00 00       	jmp    153a0 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
   15312:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15315:	83 c0 02             	add    $0x2,%eax
   15318:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
   1531b:	8b 45 14             	mov    0x14(%ebp),%eax
   1531e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   15321:	76 09                	jbe    1532c <readChunk_zTXt+0x126>
   15323:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   1532a:	eb 74                	jmp    153a0 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
   1532c:	8b 45 14             	mov    0x14(%ebp),%eax
   1532f:	2b 45 e8             	sub    -0x18(%ebp),%eax
   15332:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
   15335:	8b 45 0c             	mov    0xc(%ebp),%eax
   15338:	8b 40 30             	mov    0x30(%eax),%eax
   1533b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
   1533e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15341:	8b 4d 10             	mov    0x10(%ebp),%ecx
   15344:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15347:	01 d1                	add    %edx,%ecx
   15349:	83 ec 08             	sub    $0x8,%esp
   1534c:	8d 55 d0             	lea    -0x30(%ebp),%edx
   1534f:	52                   	push   %edx
   15350:	50                   	push   %eax
   15351:	51                   	push   %ecx
   15352:	6a 00                	push   $0x0
   15354:	8d 45 c8             	lea    -0x38(%ebp),%eax
   15357:	50                   	push   %eax
   15358:	8d 45 cc             	lea    -0x34(%ebp),%eax
   1535b:	50                   	push   %eax
   1535c:	e8 f7 93 ff ff       	call   e758 <zlib_decompress>
   15361:	83 c4 20             	add    $0x20,%esp
   15364:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
   15367:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1536b:	74 11                	je     1537e <readChunk_zTXt+0x178>
   1536d:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15370:	8b 45 c8             	mov    -0x38(%ebp),%eax
   15373:	39 c2                	cmp    %eax,%edx
   15375:	7d 07                	jge    1537e <readChunk_zTXt+0x178>
   15377:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
   1537e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15382:	75 1b                	jne    1539f <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
   15384:	8b 55 c8             	mov    -0x38(%ebp),%edx
   15387:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1538a:	52                   	push   %edx
   1538b:	50                   	push   %eax
   1538c:	ff 75 ec             	pushl  -0x14(%ebp)
   1538f:	ff 75 08             	pushl  0x8(%ebp)
   15392:	e8 60 a9 ff ff       	call   fcf7 <lodepng_add_text_sized>
   15397:	83 c4 10             	add    $0x10,%esp
   1539a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
   1539d:	eb 01                	jmp    153a0 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
   1539f:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
   153a0:	83 ec 0c             	sub    $0xc,%esp
   153a3:	ff 75 ec             	pushl  -0x14(%ebp)
   153a6:	e8 13 49 ff ff       	call   9cbe <lodepng_free>
   153ab:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
   153ae:	8b 45 cc             	mov    -0x34(%ebp),%eax
   153b1:	83 ec 0c             	sub    $0xc,%esp
   153b4:	50                   	push   %eax
   153b5:	e8 04 49 ff ff       	call   9cbe <lodepng_free>
   153ba:	83 c4 10             	add    $0x10,%esp

  return error;
   153bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   153c0:	c9                   	leave  
   153c1:	c3                   	ret    

000153c2 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   153c2:	55                   	push   %ebp
   153c3:	89 e5                	mov    %esp,%ebp
   153c5:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
   153c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   153cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   153d2:	8b 10                	mov    (%eax),%edx
   153d4:	89 55 c0             	mov    %edx,-0x40(%ebp)
   153d7:	8b 50 04             	mov    0x4(%eax),%edx
   153da:	89 55 c4             	mov    %edx,-0x3c(%ebp)
   153dd:	8b 50 08             	mov    0x8(%eax),%edx
   153e0:	89 55 c8             	mov    %edx,-0x38(%ebp)
   153e3:	8b 50 0c             	mov    0xc(%eax),%edx
   153e6:	89 55 cc             	mov    %edx,-0x34(%ebp)
   153e9:	8b 50 10             	mov    0x10(%eax),%edx
   153ec:	89 55 d0             	mov    %edx,-0x30(%ebp)
   153ef:	8b 40 14             	mov    0x14(%eax),%eax
   153f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
   153f5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   153fc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15403:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
   1540a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1540e:	0f 85 d5 02 00 00    	jne    156e9 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
   15414:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
   15418:	7f 0c                	jg     15426 <readChunk_iTXt+0x64>
   1541a:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
   15421:	e9 c3 02 00 00       	jmp    156e9 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   15426:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1542d:	eb 04                	jmp    15433 <readChunk_iTXt+0x71>
   1542f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15433:	8b 45 14             	mov    0x14(%ebp),%eax
   15436:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   15439:	73 0f                	jae    1544a <readChunk_iTXt+0x88>
   1543b:	8b 55 10             	mov    0x10(%ebp),%edx
   1543e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15441:	01 d0                	add    %edx,%eax
   15443:	0f b6 00             	movzbl (%eax),%eax
   15446:	84 c0                	test   %al,%al
   15448:	75 e5                	jne    1542f <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
   1544a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1544d:	8d 50 03             	lea    0x3(%eax),%edx
   15450:	8b 45 14             	mov    0x14(%ebp),%eax
   15453:	39 c2                	cmp    %eax,%edx
   15455:	72 0c                	jb     15463 <readChunk_iTXt+0xa1>
   15457:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   1545e:	e9 86 02 00 00       	jmp    156e9 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
   15463:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   15467:	74 06                	je     1546f <readChunk_iTXt+0xad>
   15469:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   1546d:	76 0c                	jbe    1547b <readChunk_iTXt+0xb9>
   1546f:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
   15476:	e9 6e 02 00 00       	jmp    156e9 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
   1547b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1547e:	83 c0 01             	add    $0x1,%eax
   15481:	83 ec 0c             	sub    $0xc,%esp
   15484:	50                   	push   %eax
   15485:	e8 13 48 ff ff       	call   9c9d <lodepng_malloc>
   1548a:	83 c4 10             	add    $0x10,%esp
   1548d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
   15490:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15494:	75 0c                	jne    154a2 <readChunk_iTXt+0xe0>
   15496:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   1549d:	e9 47 02 00 00       	jmp    156e9 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
   154a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154a5:	83 ec 04             	sub    $0x4,%esp
   154a8:	50                   	push   %eax
   154a9:	ff 75 10             	pushl  0x10(%ebp)
   154ac:	ff 75 e8             	pushl  -0x18(%ebp)
   154af:	e8 27 48 ff ff       	call   9cdb <lodepng_memcpy>
   154b4:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
   154b7:	8b 55 e8             	mov    -0x18(%ebp),%edx
   154ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154bd:	01 d0                	add    %edx,%eax
   154bf:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
   154c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154c5:	8d 50 01             	lea    0x1(%eax),%edx
   154c8:	8b 45 10             	mov    0x10(%ebp),%eax
   154cb:	01 d0                	add    %edx,%eax
   154cd:	0f b6 00             	movzbl (%eax),%eax
   154d0:	0f b6 c0             	movzbl %al,%eax
   154d3:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
   154d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154d9:	8d 50 02             	lea    0x2(%eax),%edx
   154dc:	8b 45 10             	mov    0x10(%ebp),%eax
   154df:	01 d0                	add    %edx,%eax
   154e1:	0f b6 00             	movzbl (%eax),%eax
   154e4:	84 c0                	test   %al,%al
   154e6:	74 0c                	je     154f4 <readChunk_iTXt+0x132>
   154e8:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
   154ef:	e9 f5 01 00 00       	jmp    156e9 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
   154f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154f7:	83 c0 03             	add    $0x3,%eax
   154fa:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
   154fd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
   15504:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15507:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1550a:	eb 08                	jmp    15514 <readChunk_iTXt+0x152>
   1550c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15510:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15514:	8b 45 14             	mov    0x14(%ebp),%eax
   15517:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1551a:	73 0f                	jae    1552b <readChunk_iTXt+0x169>
   1551c:	8b 55 10             	mov    0x10(%ebp),%edx
   1551f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15522:	01 d0                	add    %edx,%eax
   15524:	0f b6 00             	movzbl (%eax),%eax
   15527:	84 c0                	test   %al,%al
   15529:	75 e1                	jne    1550c <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
   1552b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1552e:	83 c0 01             	add    $0x1,%eax
   15531:	83 ec 0c             	sub    $0xc,%esp
   15534:	50                   	push   %eax
   15535:	e8 63 47 ff ff       	call   9c9d <lodepng_malloc>
   1553a:	83 c4 10             	add    $0x10,%esp
   1553d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
   15540:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   15544:	75 0c                	jne    15552 <readChunk_iTXt+0x190>
   15546:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   1554d:	e9 97 01 00 00       	jmp    156e9 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
   15552:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15555:	8b 4d 10             	mov    0x10(%ebp),%ecx
   15558:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1555b:	01 ca                	add    %ecx,%edx
   1555d:	83 ec 04             	sub    $0x4,%esp
   15560:	50                   	push   %eax
   15561:	52                   	push   %edx
   15562:	ff 75 e4             	pushl  -0x1c(%ebp)
   15565:	e8 71 47 ff ff       	call   9cdb <lodepng_memcpy>
   1556a:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
   1556d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15570:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15573:	01 d0                	add    %edx,%eax
   15575:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
   15578:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1557b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1557e:	01 d0                	add    %edx,%eax
   15580:	83 c0 01             	add    $0x1,%eax
   15583:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
   15586:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
   1558d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15590:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15593:	eb 08                	jmp    1559d <readChunk_iTXt+0x1db>
   15595:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15599:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1559d:	8b 45 14             	mov    0x14(%ebp),%eax
   155a0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   155a3:	73 0f                	jae    155b4 <readChunk_iTXt+0x1f2>
   155a5:	8b 55 10             	mov    0x10(%ebp),%edx
   155a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155ab:	01 d0                	add    %edx,%eax
   155ad:	0f b6 00             	movzbl (%eax),%eax
   155b0:	84 c0                	test   %al,%al
   155b2:	75 e1                	jne    15595 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
   155b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155b7:	83 c0 01             	add    $0x1,%eax
   155ba:	83 ec 0c             	sub    $0xc,%esp
   155bd:	50                   	push   %eax
   155be:	e8 da 46 ff ff       	call   9c9d <lodepng_malloc>
   155c3:	83 c4 10             	add    $0x10,%esp
   155c6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
   155c9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   155cd:	75 0c                	jne    155db <readChunk_iTXt+0x219>
   155cf:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   155d6:	e9 0e 01 00 00       	jmp    156e9 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
   155db:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155de:	8b 4d 10             	mov    0x10(%ebp),%ecx
   155e1:	8b 55 d8             	mov    -0x28(%ebp),%edx
   155e4:	01 ca                	add    %ecx,%edx
   155e6:	83 ec 04             	sub    $0x4,%esp
   155e9:	50                   	push   %eax
   155ea:	52                   	push   %edx
   155eb:	ff 75 e0             	pushl  -0x20(%ebp)
   155ee:	e8 e8 46 ff ff       	call   9cdb <lodepng_memcpy>
   155f3:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
   155f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   155f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155fc:	01 d0                	add    %edx,%eax
   155fe:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
   15601:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15604:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15607:	01 d0                	add    %edx,%eax
   15609:	83 c0 01             	add    $0x1,%eax
   1560c:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
   1560f:	8b 45 14             	mov    0x14(%ebp),%eax
   15612:	3b 45 d8             	cmp    -0x28(%ebp),%eax
   15615:	72 08                	jb     1561f <readChunk_iTXt+0x25d>
   15617:	8b 45 14             	mov    0x14(%ebp),%eax
   1561a:	2b 45 d8             	sub    -0x28(%ebp),%eax
   1561d:	eb 05                	jmp    15624 <readChunk_iTXt+0x262>
   1561f:	b8 00 00 00 00       	mov    $0x0,%eax
   15624:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
   15627:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   1562b:	0f 84 90 00 00 00    	je     156c1 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
   15631:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
   15638:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
   1563f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15642:	8b 40 30             	mov    0x30(%eax),%eax
   15645:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
   15648:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1564b:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1564e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15651:	01 d1                	add    %edx,%ecx
   15653:	83 ec 08             	sub    $0x8,%esp
   15656:	8d 55 c0             	lea    -0x40(%ebp),%edx
   15659:	52                   	push   %edx
   1565a:	50                   	push   %eax
   1565b:	51                   	push   %ecx
   1565c:	6a 00                	push   $0x0
   1565e:	8d 45 b8             	lea    -0x48(%ebp),%eax
   15661:	50                   	push   %eax
   15662:	8d 45 bc             	lea    -0x44(%ebp),%eax
   15665:	50                   	push   %eax
   15666:	e8 ed 90 ff ff       	call   e758 <zlib_decompress>
   1566b:	83 c4 20             	add    $0x20,%esp
   1566e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
   15671:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15675:	74 11                	je     15688 <readChunk_iTXt+0x2c6>
   15677:	8b 55 c8             	mov    -0x38(%ebp),%edx
   1567a:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1567d:	39 c2                	cmp    %eax,%edx
   1567f:	7d 07                	jge    15688 <readChunk_iTXt+0x2c6>
   15681:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
   15688:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1568c:	75 22                	jne    156b0 <readChunk_iTXt+0x2ee>
   1568e:	8b 55 b8             	mov    -0x48(%ebp),%edx
   15691:	8b 45 bc             	mov    -0x44(%ebp),%eax
   15694:	83 ec 08             	sub    $0x8,%esp
   15697:	52                   	push   %edx
   15698:	50                   	push   %eax
   15699:	ff 75 e0             	pushl  -0x20(%ebp)
   1569c:	ff 75 e4             	pushl  -0x1c(%ebp)
   1569f:	ff 75 e8             	pushl  -0x18(%ebp)
   156a2:	ff 75 08             	pushl  0x8(%ebp)
   156a5:	e8 94 a9 ff ff       	call   1003e <lodepng_add_itext_sized>
   156aa:	83 c4 20             	add    $0x20,%esp
   156ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
   156b0:	8b 45 bc             	mov    -0x44(%ebp),%eax
   156b3:	83 ec 0c             	sub    $0xc,%esp
   156b6:	50                   	push   %eax
   156b7:	e8 02 46 ff ff       	call   9cbe <lodepng_free>
   156bc:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
   156bf:	eb 27                	jmp    156e8 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
   156c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   156c4:	8b 4d 10             	mov    0x10(%ebp),%ecx
   156c7:	8b 55 d8             	mov    -0x28(%ebp),%edx
   156ca:	01 ca                	add    %ecx,%edx
   156cc:	83 ec 08             	sub    $0x8,%esp
   156cf:	50                   	push   %eax
   156d0:	52                   	push   %edx
   156d1:	ff 75 e0             	pushl  -0x20(%ebp)
   156d4:	ff 75 e4             	pushl  -0x1c(%ebp)
   156d7:	ff 75 e8             	pushl  -0x18(%ebp)
   156da:	ff 75 08             	pushl  0x8(%ebp)
   156dd:	e8 5c a9 ff ff       	call   1003e <lodepng_add_itext_sized>
   156e2:	83 c4 20             	add    $0x20,%esp
   156e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
   156e8:	90                   	nop
  }

  lodepng_free(key);
   156e9:	83 ec 0c             	sub    $0xc,%esp
   156ec:	ff 75 e8             	pushl  -0x18(%ebp)
   156ef:	e8 ca 45 ff ff       	call   9cbe <lodepng_free>
   156f4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
   156f7:	83 ec 0c             	sub    $0xc,%esp
   156fa:	ff 75 e4             	pushl  -0x1c(%ebp)
   156fd:	e8 bc 45 ff ff       	call   9cbe <lodepng_free>
   15702:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
   15705:	83 ec 0c             	sub    $0xc,%esp
   15708:	ff 75 e0             	pushl  -0x20(%ebp)
   1570b:	e8 ae 45 ff ff       	call   9cbe <lodepng_free>
   15710:	83 c4 10             	add    $0x10,%esp

  return error;
   15713:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   15716:	c9                   	leave  
   15717:	c3                   	ret    

00015718 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   15718:	55                   	push   %ebp
   15719:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
   1571b:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
   1571f:	74 0a                	je     1572b <readChunk_tIME+0x13>
   15721:	b8 49 00 00 00       	mov    $0x49,%eax
   15726:	e9 8b 00 00 00       	jmp    157b6 <readChunk_tIME+0x9e>

  info->time_defined = 1;
   1572b:	8b 45 08             	mov    0x8(%ebp),%eax
   1572e:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
   15735:	8b 45 0c             	mov    0xc(%ebp),%eax
   15738:	0f b6 00             	movzbl (%eax),%eax
   1573b:	0f b6 c0             	movzbl %al,%eax
   1573e:	c1 e0 08             	shl    $0x8,%eax
   15741:	89 c2                	mov    %eax,%edx
   15743:	8b 45 0c             	mov    0xc(%ebp),%eax
   15746:	83 c0 01             	add    $0x1,%eax
   15749:	0f b6 00             	movzbl (%eax),%eax
   1574c:	0f b6 c0             	movzbl %al,%eax
   1574f:	01 c2                	add    %eax,%edx
   15751:	8b 45 08             	mov    0x8(%ebp),%eax
   15754:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
   15757:	8b 45 0c             	mov    0xc(%ebp),%eax
   1575a:	83 c0 02             	add    $0x2,%eax
   1575d:	0f b6 00             	movzbl (%eax),%eax
   15760:	0f b6 d0             	movzbl %al,%edx
   15763:	8b 45 08             	mov    0x8(%ebp),%eax
   15766:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
   15769:	8b 45 0c             	mov    0xc(%ebp),%eax
   1576c:	83 c0 03             	add    $0x3,%eax
   1576f:	0f b6 00             	movzbl (%eax),%eax
   15772:	0f b6 d0             	movzbl %al,%edx
   15775:	8b 45 08             	mov    0x8(%ebp),%eax
   15778:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
   1577b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1577e:	83 c0 04             	add    $0x4,%eax
   15781:	0f b6 00             	movzbl (%eax),%eax
   15784:	0f b6 d0             	movzbl %al,%edx
   15787:	8b 45 08             	mov    0x8(%ebp),%eax
   1578a:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
   1578d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15790:	83 c0 05             	add    $0x5,%eax
   15793:	0f b6 00             	movzbl (%eax),%eax
   15796:	0f b6 d0             	movzbl %al,%edx
   15799:	8b 45 08             	mov    0x8(%ebp),%eax
   1579c:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
   1579f:	8b 45 0c             	mov    0xc(%ebp),%eax
   157a2:	83 c0 06             	add    $0x6,%eax
   157a5:	0f b6 00             	movzbl (%eax),%eax
   157a8:	0f b6 d0             	movzbl %al,%edx
   157ab:	8b 45 08             	mov    0x8(%ebp),%eax
   157ae:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
   157b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   157b6:	5d                   	pop    %ebp
   157b7:	c3                   	ret    

000157b8 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   157b8:	55                   	push   %ebp
   157b9:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
   157bb:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
   157bf:	74 0a                	je     157cb <readChunk_pHYs+0x13>
   157c1:	b8 4a 00 00 00       	mov    $0x4a,%eax
   157c6:	e9 ba 00 00 00       	jmp    15885 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
   157cb:	8b 45 08             	mov    0x8(%ebp),%eax
   157ce:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
   157d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   157d8:	0f b6 00             	movzbl (%eax),%eax
   157db:	0f b6 c0             	movzbl %al,%eax
   157de:	c1 e0 08             	shl    $0x8,%eax
   157e1:	89 c2                	mov    %eax,%edx
   157e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   157e6:	83 c0 01             	add    $0x1,%eax
   157e9:	0f b6 00             	movzbl (%eax),%eax
   157ec:	0f b6 c0             	movzbl %al,%eax
   157ef:	01 d0                	add    %edx,%eax
   157f1:	c1 e0 08             	shl    $0x8,%eax
   157f4:	89 c2                	mov    %eax,%edx
   157f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   157f9:	83 c0 02             	add    $0x2,%eax
   157fc:	0f b6 00             	movzbl (%eax),%eax
   157ff:	0f b6 c0             	movzbl %al,%eax
   15802:	01 d0                	add    %edx,%eax
   15804:	c1 e0 08             	shl    $0x8,%eax
   15807:	89 c2                	mov    %eax,%edx
   15809:	8b 45 0c             	mov    0xc(%ebp),%eax
   1580c:	83 c0 03             	add    $0x3,%eax
   1580f:	0f b6 00             	movzbl (%eax),%eax
   15812:	0f b6 c0             	movzbl %al,%eax
   15815:	01 c2                	add    %eax,%edx
   15817:	8b 45 08             	mov    0x8(%ebp),%eax
   1581a:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
   1581d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15820:	83 c0 04             	add    $0x4,%eax
   15823:	0f b6 00             	movzbl (%eax),%eax
   15826:	0f b6 c0             	movzbl %al,%eax
   15829:	c1 e0 08             	shl    $0x8,%eax
   1582c:	89 c2                	mov    %eax,%edx
   1582e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15831:	83 c0 05             	add    $0x5,%eax
   15834:	0f b6 00             	movzbl (%eax),%eax
   15837:	0f b6 c0             	movzbl %al,%eax
   1583a:	01 d0                	add    %edx,%eax
   1583c:	c1 e0 08             	shl    $0x8,%eax
   1583f:	89 c2                	mov    %eax,%edx
   15841:	8b 45 0c             	mov    0xc(%ebp),%eax
   15844:	83 c0 06             	add    $0x6,%eax
   15847:	0f b6 00             	movzbl (%eax),%eax
   1584a:	0f b6 c0             	movzbl %al,%eax
   1584d:	01 d0                	add    %edx,%eax
   1584f:	c1 e0 08             	shl    $0x8,%eax
   15852:	89 c2                	mov    %eax,%edx
   15854:	8b 45 0c             	mov    0xc(%ebp),%eax
   15857:	83 c0 07             	add    $0x7,%eax
   1585a:	0f b6 00             	movzbl (%eax),%eax
   1585d:	0f b6 c0             	movzbl %al,%eax
   15860:	01 c2                	add    %eax,%edx
   15862:	8b 45 08             	mov    0x8(%ebp),%eax
   15865:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
   1586b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1586e:	83 c0 08             	add    $0x8,%eax
   15871:	0f b6 00             	movzbl (%eax),%eax
   15874:	0f b6 d0             	movzbl %al,%edx
   15877:	8b 45 08             	mov    0x8(%ebp),%eax
   1587a:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
   15880:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15885:	5d                   	pop    %ebp
   15886:	c3                   	ret    

00015887 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   15887:	55                   	push   %ebp
   15888:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
   1588a:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
   1588e:	74 07                	je     15897 <readChunk_gAMA+0x10>
   15890:	b8 60 00 00 00       	mov    $0x60,%eax
   15895:	eb 5d                	jmp    158f4 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
   15897:	8b 45 08             	mov    0x8(%ebp),%eax
   1589a:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
   158a1:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
   158a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   158a7:	0f b6 00             	movzbl (%eax),%eax
   158aa:	0f b6 c0             	movzbl %al,%eax
   158ad:	c1 e0 08             	shl    $0x8,%eax
   158b0:	89 c2                	mov    %eax,%edx
   158b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   158b5:	83 c0 01             	add    $0x1,%eax
   158b8:	0f b6 00             	movzbl (%eax),%eax
   158bb:	0f b6 c0             	movzbl %al,%eax
   158be:	01 d0                	add    %edx,%eax
   158c0:	c1 e0 08             	shl    $0x8,%eax
   158c3:	89 c2                	mov    %eax,%edx
   158c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   158c8:	83 c0 02             	add    $0x2,%eax
   158cb:	0f b6 00             	movzbl (%eax),%eax
   158ce:	0f b6 c0             	movzbl %al,%eax
   158d1:	01 d0                	add    %edx,%eax
   158d3:	c1 e0 08             	shl    $0x8,%eax
   158d6:	89 c2                	mov    %eax,%edx
   158d8:	8b 45 0c             	mov    0xc(%ebp),%eax
   158db:	83 c0 03             	add    $0x3,%eax
   158de:	0f b6 00             	movzbl (%eax),%eax
   158e1:	0f b6 c0             	movzbl %al,%eax
   158e4:	01 c2                	add    %eax,%edx
   158e6:	8b 45 08             	mov    0x8(%ebp),%eax
   158e9:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
   158ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
   158f4:	5d                   	pop    %ebp
   158f5:	c3                   	ret    

000158f6 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   158f6:	55                   	push   %ebp
   158f7:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
   158f9:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
   158fd:	74 0a                	je     15909 <readChunk_cHRM+0x13>
   158ff:	b8 61 00 00 00       	mov    $0x61,%eax
   15904:	e9 7f 02 00 00       	jmp    15b88 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
   15909:	8b 45 08             	mov    0x8(%ebp),%eax
   1590c:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   15913:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
   15916:	8b 45 0c             	mov    0xc(%ebp),%eax
   15919:	0f b6 00             	movzbl (%eax),%eax
   1591c:	0f b6 c0             	movzbl %al,%eax
   1591f:	c1 e0 08             	shl    $0x8,%eax
   15922:	89 c2                	mov    %eax,%edx
   15924:	8b 45 0c             	mov    0xc(%ebp),%eax
   15927:	83 c0 01             	add    $0x1,%eax
   1592a:	0f b6 00             	movzbl (%eax),%eax
   1592d:	0f b6 c0             	movzbl %al,%eax
   15930:	01 d0                	add    %edx,%eax
   15932:	c1 e0 08             	shl    $0x8,%eax
   15935:	89 c2                	mov    %eax,%edx
   15937:	8b 45 0c             	mov    0xc(%ebp),%eax
   1593a:	83 c0 02             	add    $0x2,%eax
   1593d:	0f b6 00             	movzbl (%eax),%eax
   15940:	0f b6 c0             	movzbl %al,%eax
   15943:	01 d0                	add    %edx,%eax
   15945:	c1 e0 08             	shl    $0x8,%eax
   15948:	89 c2                	mov    %eax,%edx
   1594a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1594d:	83 c0 03             	add    $0x3,%eax
   15950:	0f b6 00             	movzbl (%eax),%eax
   15953:	0f b6 c0             	movzbl %al,%eax
   15956:	01 c2                	add    %eax,%edx
   15958:	8b 45 08             	mov    0x8(%ebp),%eax
   1595b:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
   15961:	8b 45 0c             	mov    0xc(%ebp),%eax
   15964:	83 c0 04             	add    $0x4,%eax
   15967:	0f b6 00             	movzbl (%eax),%eax
   1596a:	0f b6 c0             	movzbl %al,%eax
   1596d:	c1 e0 08             	shl    $0x8,%eax
   15970:	89 c2                	mov    %eax,%edx
   15972:	8b 45 0c             	mov    0xc(%ebp),%eax
   15975:	83 c0 05             	add    $0x5,%eax
   15978:	0f b6 00             	movzbl (%eax),%eax
   1597b:	0f b6 c0             	movzbl %al,%eax
   1597e:	01 d0                	add    %edx,%eax
   15980:	c1 e0 08             	shl    $0x8,%eax
   15983:	89 c2                	mov    %eax,%edx
   15985:	8b 45 0c             	mov    0xc(%ebp),%eax
   15988:	83 c0 06             	add    $0x6,%eax
   1598b:	0f b6 00             	movzbl (%eax),%eax
   1598e:	0f b6 c0             	movzbl %al,%eax
   15991:	01 d0                	add    %edx,%eax
   15993:	c1 e0 08             	shl    $0x8,%eax
   15996:	89 c2                	mov    %eax,%edx
   15998:	8b 45 0c             	mov    0xc(%ebp),%eax
   1599b:	83 c0 07             	add    $0x7,%eax
   1599e:	0f b6 00             	movzbl (%eax),%eax
   159a1:	0f b6 c0             	movzbl %al,%eax
   159a4:	01 c2                	add    %eax,%edx
   159a6:	8b 45 08             	mov    0x8(%ebp),%eax
   159a9:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
   159af:	8b 45 0c             	mov    0xc(%ebp),%eax
   159b2:	83 c0 08             	add    $0x8,%eax
   159b5:	0f b6 00             	movzbl (%eax),%eax
   159b8:	0f b6 c0             	movzbl %al,%eax
   159bb:	c1 e0 08             	shl    $0x8,%eax
   159be:	89 c2                	mov    %eax,%edx
   159c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   159c3:	83 c0 09             	add    $0x9,%eax
   159c6:	0f b6 00             	movzbl (%eax),%eax
   159c9:	0f b6 c0             	movzbl %al,%eax
   159cc:	01 d0                	add    %edx,%eax
   159ce:	c1 e0 08             	shl    $0x8,%eax
   159d1:	89 c2                	mov    %eax,%edx
   159d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   159d6:	83 c0 0a             	add    $0xa,%eax
   159d9:	0f b6 00             	movzbl (%eax),%eax
   159dc:	0f b6 c0             	movzbl %al,%eax
   159df:	01 d0                	add    %edx,%eax
   159e1:	c1 e0 08             	shl    $0x8,%eax
   159e4:	89 c2                	mov    %eax,%edx
   159e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   159e9:	83 c0 0b             	add    $0xb,%eax
   159ec:	0f b6 00             	movzbl (%eax),%eax
   159ef:	0f b6 c0             	movzbl %al,%eax
   159f2:	01 c2                	add    %eax,%edx
   159f4:	8b 45 08             	mov    0x8(%ebp),%eax
   159f7:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
   159fd:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a00:	83 c0 0c             	add    $0xc,%eax
   15a03:	0f b6 00             	movzbl (%eax),%eax
   15a06:	0f b6 c0             	movzbl %al,%eax
   15a09:	c1 e0 08             	shl    $0x8,%eax
   15a0c:	89 c2                	mov    %eax,%edx
   15a0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a11:	83 c0 0d             	add    $0xd,%eax
   15a14:	0f b6 00             	movzbl (%eax),%eax
   15a17:	0f b6 c0             	movzbl %al,%eax
   15a1a:	01 d0                	add    %edx,%eax
   15a1c:	c1 e0 08             	shl    $0x8,%eax
   15a1f:	89 c2                	mov    %eax,%edx
   15a21:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a24:	83 c0 0e             	add    $0xe,%eax
   15a27:	0f b6 00             	movzbl (%eax),%eax
   15a2a:	0f b6 c0             	movzbl %al,%eax
   15a2d:	01 d0                	add    %edx,%eax
   15a2f:	c1 e0 08             	shl    $0x8,%eax
   15a32:	89 c2                	mov    %eax,%edx
   15a34:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a37:	83 c0 0f             	add    $0xf,%eax
   15a3a:	0f b6 00             	movzbl (%eax),%eax
   15a3d:	0f b6 c0             	movzbl %al,%eax
   15a40:	01 c2                	add    %eax,%edx
   15a42:	8b 45 08             	mov    0x8(%ebp),%eax
   15a45:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
   15a4b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a4e:	83 c0 10             	add    $0x10,%eax
   15a51:	0f b6 00             	movzbl (%eax),%eax
   15a54:	0f b6 c0             	movzbl %al,%eax
   15a57:	c1 e0 08             	shl    $0x8,%eax
   15a5a:	89 c2                	mov    %eax,%edx
   15a5c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a5f:	83 c0 11             	add    $0x11,%eax
   15a62:	0f b6 00             	movzbl (%eax),%eax
   15a65:	0f b6 c0             	movzbl %al,%eax
   15a68:	01 d0                	add    %edx,%eax
   15a6a:	c1 e0 08             	shl    $0x8,%eax
   15a6d:	89 c2                	mov    %eax,%edx
   15a6f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a72:	83 c0 12             	add    $0x12,%eax
   15a75:	0f b6 00             	movzbl (%eax),%eax
   15a78:	0f b6 c0             	movzbl %al,%eax
   15a7b:	01 d0                	add    %edx,%eax
   15a7d:	c1 e0 08             	shl    $0x8,%eax
   15a80:	89 c2                	mov    %eax,%edx
   15a82:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a85:	83 c0 13             	add    $0x13,%eax
   15a88:	0f b6 00             	movzbl (%eax),%eax
   15a8b:	0f b6 c0             	movzbl %al,%eax
   15a8e:	01 c2                	add    %eax,%edx
   15a90:	8b 45 08             	mov    0x8(%ebp),%eax
   15a93:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
   15a99:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a9c:	83 c0 14             	add    $0x14,%eax
   15a9f:	0f b6 00             	movzbl (%eax),%eax
   15aa2:	0f b6 c0             	movzbl %al,%eax
   15aa5:	c1 e0 08             	shl    $0x8,%eax
   15aa8:	89 c2                	mov    %eax,%edx
   15aaa:	8b 45 0c             	mov    0xc(%ebp),%eax
   15aad:	83 c0 15             	add    $0x15,%eax
   15ab0:	0f b6 00             	movzbl (%eax),%eax
   15ab3:	0f b6 c0             	movzbl %al,%eax
   15ab6:	01 d0                	add    %edx,%eax
   15ab8:	c1 e0 08             	shl    $0x8,%eax
   15abb:	89 c2                	mov    %eax,%edx
   15abd:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ac0:	83 c0 16             	add    $0x16,%eax
   15ac3:	0f b6 00             	movzbl (%eax),%eax
   15ac6:	0f b6 c0             	movzbl %al,%eax
   15ac9:	01 d0                	add    %edx,%eax
   15acb:	c1 e0 08             	shl    $0x8,%eax
   15ace:	89 c2                	mov    %eax,%edx
   15ad0:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ad3:	83 c0 17             	add    $0x17,%eax
   15ad6:	0f b6 00             	movzbl (%eax),%eax
   15ad9:	0f b6 c0             	movzbl %al,%eax
   15adc:	01 c2                	add    %eax,%edx
   15ade:	8b 45 08             	mov    0x8(%ebp),%eax
   15ae1:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
   15ae7:	8b 45 0c             	mov    0xc(%ebp),%eax
   15aea:	83 c0 18             	add    $0x18,%eax
   15aed:	0f b6 00             	movzbl (%eax),%eax
   15af0:	0f b6 c0             	movzbl %al,%eax
   15af3:	c1 e0 08             	shl    $0x8,%eax
   15af6:	89 c2                	mov    %eax,%edx
   15af8:	8b 45 0c             	mov    0xc(%ebp),%eax
   15afb:	83 c0 19             	add    $0x19,%eax
   15afe:	0f b6 00             	movzbl (%eax),%eax
   15b01:	0f b6 c0             	movzbl %al,%eax
   15b04:	01 d0                	add    %edx,%eax
   15b06:	c1 e0 08             	shl    $0x8,%eax
   15b09:	89 c2                	mov    %eax,%edx
   15b0b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b0e:	83 c0 1a             	add    $0x1a,%eax
   15b11:	0f b6 00             	movzbl (%eax),%eax
   15b14:	0f b6 c0             	movzbl %al,%eax
   15b17:	01 d0                	add    %edx,%eax
   15b19:	c1 e0 08             	shl    $0x8,%eax
   15b1c:	89 c2                	mov    %eax,%edx
   15b1e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b21:	83 c0 1b             	add    $0x1b,%eax
   15b24:	0f b6 00             	movzbl (%eax),%eax
   15b27:	0f b6 c0             	movzbl %al,%eax
   15b2a:	01 c2                	add    %eax,%edx
   15b2c:	8b 45 08             	mov    0x8(%ebp),%eax
   15b2f:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
   15b35:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b38:	83 c0 1c             	add    $0x1c,%eax
   15b3b:	0f b6 00             	movzbl (%eax),%eax
   15b3e:	0f b6 c0             	movzbl %al,%eax
   15b41:	c1 e0 08             	shl    $0x8,%eax
   15b44:	89 c2                	mov    %eax,%edx
   15b46:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b49:	83 c0 1d             	add    $0x1d,%eax
   15b4c:	0f b6 00             	movzbl (%eax),%eax
   15b4f:	0f b6 c0             	movzbl %al,%eax
   15b52:	01 d0                	add    %edx,%eax
   15b54:	c1 e0 08             	shl    $0x8,%eax
   15b57:	89 c2                	mov    %eax,%edx
   15b59:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b5c:	83 c0 1e             	add    $0x1e,%eax
   15b5f:	0f b6 00             	movzbl (%eax),%eax
   15b62:	0f b6 c0             	movzbl %al,%eax
   15b65:	01 d0                	add    %edx,%eax
   15b67:	c1 e0 08             	shl    $0x8,%eax
   15b6a:	89 c2                	mov    %eax,%edx
   15b6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b6f:	83 c0 1f             	add    $0x1f,%eax
   15b72:	0f b6 00             	movzbl (%eax),%eax
   15b75:	0f b6 c0             	movzbl %al,%eax
   15b78:	01 c2                	add    %eax,%edx
   15b7a:	8b 45 08             	mov    0x8(%ebp),%eax
   15b7d:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
   15b83:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15b88:	5d                   	pop    %ebp
   15b89:	c3                   	ret    

00015b8a <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   15b8a:	55                   	push   %ebp
   15b8b:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
   15b8d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
   15b91:	74 07                	je     15b9a <readChunk_sRGB+0x10>
   15b93:	b8 62 00 00 00       	mov    $0x62,%eax
   15b98:	eb 24                	jmp    15bbe <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
   15b9a:	8b 45 08             	mov    0x8(%ebp),%eax
   15b9d:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
   15ba4:	00 00 00 
  info->srgb_intent = data[0];
   15ba7:	8b 45 0c             	mov    0xc(%ebp),%eax
   15baa:	0f b6 00             	movzbl (%eax),%eax
   15bad:	0f b6 d0             	movzbl %al,%edx
   15bb0:	8b 45 08             	mov    0x8(%ebp),%eax
   15bb3:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
   15bb9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15bbe:	5d                   	pop    %ebp
   15bbf:	c3                   	ret    

00015bc0 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   15bc0:	55                   	push   %ebp
   15bc1:	89 e5                	mov    %esp,%ebp
   15bc3:	53                   	push   %ebx
   15bc4:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   15bc7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
   15bce:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   15bd5:	8b 45 0c             	mov    0xc(%ebp),%eax
   15bd8:	8b 10                	mov    (%eax),%edx
   15bda:	89 55 cc             	mov    %edx,-0x34(%ebp)
   15bdd:	8b 50 04             	mov    0x4(%eax),%edx
   15be0:	89 55 d0             	mov    %edx,-0x30(%ebp)
   15be3:	8b 50 08             	mov    0x8(%eax),%edx
   15be6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   15be9:	8b 50 0c             	mov    0xc(%eax),%edx
   15bec:	89 55 d8             	mov    %edx,-0x28(%ebp)
   15bef:	8b 50 10             	mov    0x10(%eax),%edx
   15bf2:	89 55 dc             	mov    %edx,-0x24(%ebp)
   15bf5:	8b 40 14             	mov    0x14(%eax),%eax
   15bf8:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
   15bfb:	8b 45 08             	mov    0x8(%ebp),%eax
   15bfe:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
   15c05:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
   15c08:	8b 45 08             	mov    0x8(%ebp),%eax
   15c0b:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15c11:	85 c0                	test   %eax,%eax
   15c13:	74 0e                	je     15c23 <readChunk_iCCP+0x63>
   15c15:	83 ec 0c             	sub    $0xc,%esp
   15c18:	ff 75 08             	pushl  0x8(%ebp)
   15c1b:	e8 ca a6 ff ff       	call   102ea <lodepng_clear_icc>
   15c20:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   15c23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15c2a:	eb 04                	jmp    15c30 <readChunk_iCCP+0x70>
   15c2c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15c30:	8b 45 14             	mov    0x14(%ebp),%eax
   15c33:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   15c36:	73 0f                	jae    15c47 <readChunk_iCCP+0x87>
   15c38:	8b 55 10             	mov    0x10(%ebp),%edx
   15c3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15c3e:	01 d0                	add    %edx,%eax
   15c40:	0f b6 00             	movzbl (%eax),%eax
   15c43:	84 c0                	test   %al,%al
   15c45:	75 e5                	jne    15c2c <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
   15c47:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15c4a:	8d 50 02             	lea    0x2(%eax),%edx
   15c4d:	8b 45 14             	mov    0x14(%ebp),%eax
   15c50:	39 c2                	cmp    %eax,%edx
   15c52:	72 0a                	jb     15c5e <readChunk_iCCP+0x9e>
   15c54:	b8 4b 00 00 00       	mov    $0x4b,%eax
   15c59:	e9 46 01 00 00       	jmp    15da4 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
   15c5e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   15c62:	74 06                	je     15c6a <readChunk_iCCP+0xaa>
   15c64:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   15c68:	76 0a                	jbe    15c74 <readChunk_iCCP+0xb4>
   15c6a:	b8 59 00 00 00       	mov    $0x59,%eax
   15c6f:	e9 30 01 00 00       	jmp    15da4 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
   15c74:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15c77:	83 c0 01             	add    $0x1,%eax
   15c7a:	83 ec 0c             	sub    $0xc,%esp
   15c7d:	50                   	push   %eax
   15c7e:	e8 1a 40 ff ff       	call   9c9d <lodepng_malloc>
   15c83:	83 c4 10             	add    $0x10,%esp
   15c86:	89 c2                	mov    %eax,%edx
   15c88:	8b 45 08             	mov    0x8(%ebp),%eax
   15c8b:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
   15c91:	8b 45 08             	mov    0x8(%ebp),%eax
   15c94:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15c9a:	85 c0                	test   %eax,%eax
   15c9c:	75 0a                	jne    15ca8 <readChunk_iCCP+0xe8>
   15c9e:	b8 53 00 00 00       	mov    $0x53,%eax
   15ca3:	e9 fc 00 00 00       	jmp    15da4 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
   15ca8:	8b 45 08             	mov    0x8(%ebp),%eax
   15cab:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   15cb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15cb4:	01 d0                	add    %edx,%eax
   15cb6:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
   15cb9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15cc0:	eb 1f                	jmp    15ce1 <readChunk_iCCP+0x121>
   15cc2:	8b 45 08             	mov    0x8(%ebp),%eax
   15cc5:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   15ccb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15cce:	01 d0                	add    %edx,%eax
   15cd0:	8b 4d 10             	mov    0x10(%ebp),%ecx
   15cd3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15cd6:	01 ca                	add    %ecx,%edx
   15cd8:	0f b6 12             	movzbl (%edx),%edx
   15cdb:	88 10                	mov    %dl,(%eax)
   15cdd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15ce1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ce4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   15ce7:	75 d9                	jne    15cc2 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
   15ce9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15cec:	8d 50 01             	lea    0x1(%eax),%edx
   15cef:	8b 45 10             	mov    0x10(%ebp),%eax
   15cf2:	01 d0                	add    %edx,%eax
   15cf4:	0f b6 00             	movzbl (%eax),%eax
   15cf7:	84 c0                	test   %al,%al
   15cf9:	74 0a                	je     15d05 <readChunk_iCCP+0x145>
   15cfb:	b8 48 00 00 00       	mov    $0x48,%eax
   15d00:	e9 9f 00 00 00       	jmp    15da4 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
   15d05:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d08:	83 c0 02             	add    $0x2,%eax
   15d0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
   15d0e:	8b 45 14             	mov    0x14(%ebp),%eax
   15d11:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   15d14:	76 0a                	jbe    15d20 <readChunk_iCCP+0x160>
   15d16:	b8 4b 00 00 00       	mov    $0x4b,%eax
   15d1b:	e9 84 00 00 00       	jmp    15da4 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
   15d20:	8b 45 14             	mov    0x14(%ebp),%eax
   15d23:	2b 45 e8             	sub    -0x18(%ebp),%eax
   15d26:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
   15d29:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d2c:	8b 40 34             	mov    0x34(%eax),%eax
   15d2f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
   15d32:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d35:	8b 4d 10             	mov    0x10(%ebp),%ecx
   15d38:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15d3b:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
   15d3e:	8b 55 08             	mov    0x8(%ebp),%edx
   15d41:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
   15d47:	83 ec 08             	sub    $0x8,%esp
   15d4a:	8d 55 cc             	lea    -0x34(%ebp),%edx
   15d4d:	52                   	push   %edx
   15d4e:	50                   	push   %eax
   15d4f:	53                   	push   %ebx
   15d50:	6a 00                	push   $0x0
   15d52:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   15d55:	50                   	push   %eax
   15d56:	51                   	push   %ecx
   15d57:	e8 fc 89 ff ff       	call   e758 <zlib_decompress>
   15d5c:	83 c4 20             	add    $0x20,%esp
   15d5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
   15d62:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15d66:	74 11                	je     15d79 <readChunk_iCCP+0x1b9>
   15d68:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15d6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d6e:	39 c2                	cmp    %eax,%edx
   15d70:	7d 07                	jge    15d79 <readChunk_iCCP+0x1b9>
   15d72:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
   15d79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d7c:	89 c2                	mov    %eax,%edx
   15d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   15d81:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
   15d87:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15d8b:	75 14                	jne    15da1 <readChunk_iCCP+0x1e1>
   15d8d:	8b 45 08             	mov    0x8(%ebp),%eax
   15d90:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
   15d96:	85 c0                	test   %eax,%eax
   15d98:	75 07                	jne    15da1 <readChunk_iCCP+0x1e1>
   15d9a:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
   15da1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   15da4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15da7:	c9                   	leave  
   15da8:	c3                   	ret    

00015da9 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
   15da9:	55                   	push   %ebp
   15daa:	89 e5                	mov    %esp,%ebp
   15dac:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
   15daf:	8b 55 0c             	mov    0xc(%ebp),%edx
   15db2:	8b 45 10             	mov    0x10(%ebp),%eax
   15db5:	01 d0                	add    %edx,%eax
   15db7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
   15dba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
   15dc1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
   15dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
   15dcb:	83 c0 04             	add    $0x4,%eax
   15dce:	3b 45 14             	cmp    0x14(%ebp),%eax
   15dd1:	7e 0a                	jle    15ddd <lodepng_inspect_chunk+0x34>
   15dd3:	b8 1e 00 00 00       	mov    $0x1e,%eax
   15dd8:	e9 43 03 00 00       	jmp    16120 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
   15ddd:	ff 75 ec             	pushl  -0x14(%ebp)
   15de0:	e8 3a 8e ff ff       	call   ec1f <lodepng_chunk_length>
   15de5:	83 c4 04             	add    $0x4,%esp
   15de8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
   15deb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15dee:	85 c0                	test   %eax,%eax
   15df0:	79 0a                	jns    15dfc <lodepng_inspect_chunk+0x53>
   15df2:	b8 3f 00 00 00       	mov    $0x3f,%eax
   15df7:	e9 24 03 00 00       	jmp    16120 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
   15dfc:	ff 75 ec             	pushl  -0x14(%ebp)
   15dff:	e8 53 8f ff ff       	call   ed57 <lodepng_chunk_data_const>
   15e04:	83 c4 04             	add    $0x4,%esp
   15e07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
   15e0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15e0d:	8d 50 04             	lea    0x4(%eax),%edx
   15e10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e13:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15e16:	8b 55 14             	mov    0x14(%ebp),%edx
   15e19:	8b 45 10             	mov    0x10(%ebp),%eax
   15e1c:	01 d0                	add    %edx,%eax
   15e1e:	39 c1                	cmp    %eax,%ecx
   15e20:	76 0a                	jbe    15e2c <lodepng_inspect_chunk+0x83>
   15e22:	b8 1e 00 00 00       	mov    $0x1e,%eax
   15e27:	e9 f4 02 00 00       	jmp    16120 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   15e2c:	68 68 0b 02 00       	push   $0x20b68
   15e31:	ff 75 ec             	pushl  -0x14(%ebp)
   15e34:	e8 33 8e ff ff       	call   ec6c <lodepng_chunk_type_equals>
   15e39:	83 c4 08             	add    $0x8,%esp
   15e3c:	84 c0                	test   %al,%al
   15e3e:	74 24                	je     15e64 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   15e40:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15e43:	8b 55 08             	mov    0x8(%ebp),%edx
   15e46:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   15e4c:	83 ec 04             	sub    $0x4,%esp
   15e4f:	50                   	push   %eax
   15e50:	ff 75 e4             	pushl  -0x1c(%ebp)
   15e53:	52                   	push   %edx
   15e54:	e8 5b ee ff ff       	call   14cb4 <readChunk_PLTE>
   15e59:	83 c4 10             	add    $0x10,%esp
   15e5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15e5f:	e9 8a 02 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   15e64:	83 ec 08             	sub    $0x8,%esp
   15e67:	68 6d 0b 02 00       	push   $0x20b6d
   15e6c:	ff 75 ec             	pushl  -0x14(%ebp)
   15e6f:	e8 f8 8d ff ff       	call   ec6c <lodepng_chunk_type_equals>
   15e74:	83 c4 10             	add    $0x10,%esp
   15e77:	84 c0                	test   %al,%al
   15e79:	74 24                	je     15e9f <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   15e7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15e7e:	8b 55 08             	mov    0x8(%ebp),%edx
   15e81:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   15e87:	83 ec 04             	sub    $0x4,%esp
   15e8a:	50                   	push   %eax
   15e8b:	ff 75 e4             	pushl  -0x1c(%ebp)
   15e8e:	52                   	push   %edx
   15e8f:	e8 40 ef ff ff       	call   14dd4 <readChunk_tRNS>
   15e94:	83 c4 10             	add    $0x10,%esp
   15e97:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15e9a:	e9 4f 02 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   15e9f:	83 ec 08             	sub    $0x8,%esp
   15ea2:	68 72 0b 02 00       	push   $0x20b72
   15ea7:	ff 75 ec             	pushl  -0x14(%ebp)
   15eaa:	e8 bd 8d ff ff       	call   ec6c <lodepng_chunk_type_equals>
   15eaf:	83 c4 10             	add    $0x10,%esp
   15eb2:	84 c0                	test   %al,%al
   15eb4:	74 24                	je     15eda <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
   15eb6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15eb9:	8b 55 08             	mov    0x8(%ebp),%edx
   15ebc:	81 c2 98 00 00 00    	add    $0x98,%edx
   15ec2:	83 ec 04             	sub    $0x4,%esp
   15ec5:	50                   	push   %eax
   15ec6:	ff 75 e4             	pushl  -0x1c(%ebp)
   15ec9:	52                   	push   %edx
   15eca:	e8 68 f0 ff ff       	call   14f37 <readChunk_bKGD>
   15ecf:	83 c4 10             	add    $0x10,%esp
   15ed2:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15ed5:	e9 14 02 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   15eda:	83 ec 08             	sub    $0x8,%esp
   15edd:	68 77 0b 02 00       	push   $0x20b77
   15ee2:	ff 75 ec             	pushl  -0x14(%ebp)
   15ee5:	e8 82 8d ff ff       	call   ec6c <lodepng_chunk_type_equals>
   15eea:	83 c4 10             	add    $0x10,%esp
   15eed:	84 c0                	test   %al,%al
   15eef:	74 24                	je     15f15 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
   15ef1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15ef4:	8b 55 08             	mov    0x8(%ebp),%edx
   15ef7:	81 c2 98 00 00 00    	add    $0x98,%edx
   15efd:	83 ec 04             	sub    $0x4,%esp
   15f00:	50                   	push   %eax
   15f01:	ff 75 e4             	pushl  -0x1c(%ebp)
   15f04:	52                   	push   %edx
   15f05:	e8 b0 f1 ff ff       	call   150ba <readChunk_tEXt>
   15f0a:	83 c4 10             	add    $0x10,%esp
   15f0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15f10:	e9 d9 01 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   15f15:	83 ec 08             	sub    $0x8,%esp
   15f18:	68 7c 0b 02 00       	push   $0x20b7c
   15f1d:	ff 75 ec             	pushl  -0x14(%ebp)
   15f20:	e8 47 8d ff ff       	call   ec6c <lodepng_chunk_type_equals>
   15f25:	83 c4 10             	add    $0x10,%esp
   15f28:	84 c0                	test   %al,%al
   15f2a:	74 25                	je     15f51 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   15f2c:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15f2f:	8b 45 08             	mov    0x8(%ebp),%eax
   15f32:	8b 4d 08             	mov    0x8(%ebp),%ecx
   15f35:	81 c1 98 00 00 00    	add    $0x98,%ecx
   15f3b:	52                   	push   %edx
   15f3c:	ff 75 e4             	pushl  -0x1c(%ebp)
   15f3f:	50                   	push   %eax
   15f40:	51                   	push   %ecx
   15f41:	e8 c0 f2 ff ff       	call   15206 <readChunk_zTXt>
   15f46:	83 c4 10             	add    $0x10,%esp
   15f49:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15f4c:	e9 9d 01 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   15f51:	83 ec 08             	sub    $0x8,%esp
   15f54:	68 81 0b 02 00       	push   $0x20b81
   15f59:	ff 75 ec             	pushl  -0x14(%ebp)
   15f5c:	e8 0b 8d ff ff       	call   ec6c <lodepng_chunk_type_equals>
   15f61:	83 c4 10             	add    $0x10,%esp
   15f64:	84 c0                	test   %al,%al
   15f66:	74 25                	je     15f8d <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   15f68:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15f6b:	8b 45 08             	mov    0x8(%ebp),%eax
   15f6e:	8b 4d 08             	mov    0x8(%ebp),%ecx
   15f71:	81 c1 98 00 00 00    	add    $0x98,%ecx
   15f77:	52                   	push   %edx
   15f78:	ff 75 e4             	pushl  -0x1c(%ebp)
   15f7b:	50                   	push   %eax
   15f7c:	51                   	push   %ecx
   15f7d:	e8 40 f4 ff ff       	call   153c2 <readChunk_iTXt>
   15f82:	83 c4 10             	add    $0x10,%esp
   15f85:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15f88:	e9 61 01 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   15f8d:	83 ec 08             	sub    $0x8,%esp
   15f90:	68 86 0b 02 00       	push   $0x20b86
   15f95:	ff 75 ec             	pushl  -0x14(%ebp)
   15f98:	e8 cf 8c ff ff       	call   ec6c <lodepng_chunk_type_equals>
   15f9d:	83 c4 10             	add    $0x10,%esp
   15fa0:	84 c0                	test   %al,%al
   15fa2:	74 24                	je     15fc8 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
   15fa4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fa7:	8b 55 08             	mov    0x8(%ebp),%edx
   15faa:	81 c2 98 00 00 00    	add    $0x98,%edx
   15fb0:	83 ec 04             	sub    $0x4,%esp
   15fb3:	50                   	push   %eax
   15fb4:	ff 75 e4             	pushl  -0x1c(%ebp)
   15fb7:	52                   	push   %edx
   15fb8:	e8 5b f7 ff ff       	call   15718 <readChunk_tIME>
   15fbd:	83 c4 10             	add    $0x10,%esp
   15fc0:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15fc3:	e9 26 01 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   15fc8:	83 ec 08             	sub    $0x8,%esp
   15fcb:	68 8b 0b 02 00       	push   $0x20b8b
   15fd0:	ff 75 ec             	pushl  -0x14(%ebp)
   15fd3:	e8 94 8c ff ff       	call   ec6c <lodepng_chunk_type_equals>
   15fd8:	83 c4 10             	add    $0x10,%esp
   15fdb:	84 c0                	test   %al,%al
   15fdd:	74 24                	je     16003 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
   15fdf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fe2:	8b 55 08             	mov    0x8(%ebp),%edx
   15fe5:	81 c2 98 00 00 00    	add    $0x98,%edx
   15feb:	83 ec 04             	sub    $0x4,%esp
   15fee:	50                   	push   %eax
   15fef:	ff 75 e4             	pushl  -0x1c(%ebp)
   15ff2:	52                   	push   %edx
   15ff3:	e8 c0 f7 ff ff       	call   157b8 <readChunk_pHYs>
   15ff8:	83 c4 10             	add    $0x10,%esp
   15ffb:	89 45 f0             	mov    %eax,-0x10(%ebp)
   15ffe:	e9 eb 00 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   16003:	83 ec 08             	sub    $0x8,%esp
   16006:	68 90 0b 02 00       	push   $0x20b90
   1600b:	ff 75 ec             	pushl  -0x14(%ebp)
   1600e:	e8 59 8c ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16013:	83 c4 10             	add    $0x10,%esp
   16016:	84 c0                	test   %al,%al
   16018:	74 24                	je     1603e <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
   1601a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1601d:	8b 55 08             	mov    0x8(%ebp),%edx
   16020:	81 c2 98 00 00 00    	add    $0x98,%edx
   16026:	83 ec 04             	sub    $0x4,%esp
   16029:	50                   	push   %eax
   1602a:	ff 75 e4             	pushl  -0x1c(%ebp)
   1602d:	52                   	push   %edx
   1602e:	e8 54 f8 ff ff       	call   15887 <readChunk_gAMA>
   16033:	83 c4 10             	add    $0x10,%esp
   16036:	89 45 f0             	mov    %eax,-0x10(%ebp)
   16039:	e9 b0 00 00 00       	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   1603e:	83 ec 08             	sub    $0x8,%esp
   16041:	68 95 0b 02 00       	push   $0x20b95
   16046:	ff 75 ec             	pushl  -0x14(%ebp)
   16049:	e8 1e 8c ff ff       	call   ec6c <lodepng_chunk_type_equals>
   1604e:	83 c4 10             	add    $0x10,%esp
   16051:	84 c0                	test   %al,%al
   16053:	74 21                	je     16076 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
   16055:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16058:	8b 55 08             	mov    0x8(%ebp),%edx
   1605b:	81 c2 98 00 00 00    	add    $0x98,%edx
   16061:	83 ec 04             	sub    $0x4,%esp
   16064:	50                   	push   %eax
   16065:	ff 75 e4             	pushl  -0x1c(%ebp)
   16068:	52                   	push   %edx
   16069:	e8 88 f8 ff ff       	call   158f6 <readChunk_cHRM>
   1606e:	83 c4 10             	add    $0x10,%esp
   16071:	89 45 f0             	mov    %eax,-0x10(%ebp)
   16074:	eb 78                	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   16076:	83 ec 08             	sub    $0x8,%esp
   16079:	68 9a 0b 02 00       	push   $0x20b9a
   1607e:	ff 75 ec             	pushl  -0x14(%ebp)
   16081:	e8 e6 8b ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16086:	83 c4 10             	add    $0x10,%esp
   16089:	84 c0                	test   %al,%al
   1608b:	74 21                	je     160ae <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
   1608d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16090:	8b 55 08             	mov    0x8(%ebp),%edx
   16093:	81 c2 98 00 00 00    	add    $0x98,%edx
   16099:	83 ec 04             	sub    $0x4,%esp
   1609c:	50                   	push   %eax
   1609d:	ff 75 e4             	pushl  -0x1c(%ebp)
   160a0:	52                   	push   %edx
   160a1:	e8 e4 fa ff ff       	call   15b8a <readChunk_sRGB>
   160a6:	83 c4 10             	add    $0x10,%esp
   160a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
   160ac:	eb 40                	jmp    160ee <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   160ae:	83 ec 08             	sub    $0x8,%esp
   160b1:	68 9f 0b 02 00       	push   $0x20b9f
   160b6:	ff 75 ec             	pushl  -0x14(%ebp)
   160b9:	e8 ae 8b ff ff       	call   ec6c <lodepng_chunk_type_equals>
   160be:	83 c4 10             	add    $0x10,%esp
   160c1:	84 c0                	test   %al,%al
   160c3:	74 22                	je     160e7 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   160c5:	8b 55 e8             	mov    -0x18(%ebp),%edx
   160c8:	8b 45 08             	mov    0x8(%ebp),%eax
   160cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
   160ce:	81 c1 98 00 00 00    	add    $0x98,%ecx
   160d4:	52                   	push   %edx
   160d5:	ff 75 e4             	pushl  -0x1c(%ebp)
   160d8:	50                   	push   %eax
   160d9:	51                   	push   %ecx
   160da:	e8 e1 fa ff ff       	call   15bc0 <readChunk_iCCP>
   160df:	83 c4 10             	add    $0x10,%esp
   160e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
   160e5:	eb 07                	jmp    160ee <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
   160e7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
   160ee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   160f2:	75 29                	jne    1611d <lodepng_inspect_chunk+0x374>
   160f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   160f8:	75 23                	jne    1611d <lodepng_inspect_chunk+0x374>
   160fa:	8b 45 08             	mov    0x8(%ebp),%eax
   160fd:	8b 40 18             	mov    0x18(%eax),%eax
   16100:	85 c0                	test   %eax,%eax
   16102:	75 19                	jne    1611d <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
   16104:	83 ec 0c             	sub    $0xc,%esp
   16107:	ff 75 ec             	pushl  -0x14(%ebp)
   1610a:	e8 53 8c ff ff       	call   ed62 <lodepng_chunk_check_crc>
   1610f:	83 c4 10             	add    $0x10,%esp
   16112:	85 c0                	test   %eax,%eax
   16114:	74 07                	je     1611d <lodepng_inspect_chunk+0x374>
   16116:	b8 39 00 00 00       	mov    $0x39,%eax
   1611b:	eb 03                	jmp    16120 <lodepng_inspect_chunk+0x377>
  }

  return error;
   1611d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   16120:	c9                   	leave  
   16121:	c3                   	ret    

00016122 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
   16122:	55                   	push   %ebp
   16123:	89 e5                	mov    %esp,%ebp
   16125:	56                   	push   %esi
   16126:	53                   	push   %ebx
   16127:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
   1612a:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
   1612e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
   16135:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
   1613c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   16143:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
   1614a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
   16151:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
   16158:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
   1615f:	8b 45 08             	mov    0x8(%ebp),%eax
   16162:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   16168:	8b 45 10             	mov    0x10(%ebp),%eax
   1616b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   16171:	8b 45 10             	mov    0x10(%ebp),%eax
   16174:	8b 10                	mov    (%eax),%edx
   16176:	8b 45 0c             	mov    0xc(%ebp),%eax
   16179:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
   1617b:	83 ec 0c             	sub    $0xc,%esp
   1617e:	ff 75 1c             	pushl  0x1c(%ebp)
   16181:	ff 75 18             	pushl  0x18(%ebp)
   16184:	ff 75 14             	pushl  0x14(%ebp)
   16187:	ff 75 10             	pushl  0x10(%ebp)
   1618a:	ff 75 0c             	pushl  0xc(%ebp)
   1618d:	e8 d3 da ff ff       	call   13c65 <lodepng_inspect>
   16192:	83 c4 20             	add    $0x20,%esp
   16195:	89 c2                	mov    %eax,%edx
   16197:	8b 45 14             	mov    0x14(%ebp),%eax
   1619a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
   161a0:	8b 45 14             	mov    0x14(%ebp),%eax
   161a3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   161a9:	85 c0                	test   %eax,%eax
   161ab:	0f 85 24 0a 00 00    	jne    16bd5 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
   161b1:	8b 45 14             	mov    0x14(%ebp),%eax
   161b4:	8d 58 78             	lea    0x78(%eax),%ebx
   161b7:	8b 45 14             	mov    0x14(%ebp),%eax
   161ba:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   161c0:	8b 45 10             	mov    0x10(%ebp),%eax
   161c3:	8b 10                	mov    (%eax),%edx
   161c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   161c8:	8b 00                	mov    (%eax),%eax
   161ca:	53                   	push   %ebx
   161cb:	51                   	push   %ecx
   161cc:	52                   	push   %edx
   161cd:	50                   	push   %eax
   161ce:	e8 76 97 ff ff       	call   f949 <lodepng_pixel_overflow>
   161d3:	83 c4 10             	add    $0x10,%esp
   161d6:	85 c0                	test   %eax,%eax
   161d8:	74 12                	je     161ec <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
   161da:	8b 45 14             	mov    0x14(%ebp),%eax
   161dd:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
   161e4:	00 00 00 
   161e7:	e9 ea 09 00 00       	jmp    16bd6 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
   161ec:	83 ec 0c             	sub    $0xc,%esp
   161ef:	ff 75 1c             	pushl  0x1c(%ebp)
   161f2:	e8 a6 3a ff ff       	call   9c9d <lodepng_malloc>
   161f7:	83 c4 10             	add    $0x10,%esp
   161fa:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
   161fd:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   16201:	75 12                	jne    16215 <decodeGeneric+0xf3>
   16203:	8b 45 14             	mov    0x14(%ebp),%eax
   16206:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1620d:	00 00 00 
   16210:	e9 c1 09 00 00       	jmp    16bd6 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
   16215:	8b 45 18             	mov    0x18(%ebp),%eax
   16218:	83 c0 21             	add    $0x21,%eax
   1621b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   1621e:	e9 81 06 00 00       	jmp    168a4 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
   16223:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16226:	8b 45 18             	mov    0x18(%ebp),%eax
   16229:	29 c2                	sub    %eax,%edx
   1622b:	89 d0                	mov    %edx,%eax
   1622d:	83 c0 0c             	add    $0xc,%eax
   16230:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   16233:	7f 08                	jg     1623d <decodeGeneric+0x11b>
   16235:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16238:	3b 45 18             	cmp    0x18(%ebp),%eax
   1623b:	73 20                	jae    1625d <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   1623d:	8b 45 14             	mov    0x14(%ebp),%eax
   16240:	8b 40 20             	mov    0x20(%eax),%eax
   16243:	85 c0                	test   %eax,%eax
   16245:	0f 85 72 06 00 00    	jne    168bd <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
   1624b:	8b 45 14             	mov    0x14(%ebp),%eax
   1624e:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
   16255:	00 00 00 
   16258:	e9 6a 06 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
   1625d:	83 ec 0c             	sub    $0xc,%esp
   16260:	ff 75 f0             	pushl  -0x10(%ebp)
   16263:	e8 b7 89 ff ff       	call   ec1f <lodepng_chunk_length>
   16268:	83 c4 10             	add    $0x10,%esp
   1626b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
   1626e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   16271:	85 c0                	test   %eax,%eax
   16273:	79 20                	jns    16295 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   16275:	8b 45 14             	mov    0x14(%ebp),%eax
   16278:	8b 40 20             	mov    0x20(%eax),%eax
   1627b:	85 c0                	test   %eax,%eax
   1627d:	0f 85 3d 06 00 00    	jne    168c0 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
   16283:	8b 45 14             	mov    0x14(%ebp),%eax
   16286:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
   1628d:	00 00 00 
   16290:	e9 32 06 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
   16295:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16298:	8b 45 18             	mov    0x18(%ebp),%eax
   1629b:	29 c2                	sub    %eax,%edx
   1629d:	89 d0                	mov    %edx,%eax
   1629f:	89 c2                	mov    %eax,%edx
   162a1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   162a4:	01 d0                	add    %edx,%eax
   162a6:	83 c0 0c             	add    $0xc,%eax
   162a9:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   162ac:	7f 10                	jg     162be <decodeGeneric+0x19c>
   162ae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   162b1:	8d 50 0c             	lea    0xc(%eax),%edx
   162b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   162b7:	01 d0                	add    %edx,%eax
   162b9:	3b 45 18             	cmp    0x18(%ebp),%eax
   162bc:	73 12                	jae    162d0 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
   162be:	8b 45 14             	mov    0x14(%ebp),%eax
   162c1:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
   162c8:	00 00 00 
   162cb:	e9 f7 05 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
   162d0:	83 ec 0c             	sub    $0xc,%esp
   162d3:	ff 75 f0             	pushl  -0x10(%ebp)
   162d6:	e8 7c 8a ff ff       	call   ed57 <lodepng_chunk_data_const>
   162db:	83 c4 10             	add    $0x10,%esp
   162de:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
   162e1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
   162e8:	83 ec 08             	sub    $0x8,%esp
   162eb:	68 a4 0b 02 00       	push   $0x20ba4
   162f0:	ff 75 f0             	pushl  -0x10(%ebp)
   162f3:	e8 74 89 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   162f8:	83 c4 10             	add    $0x10,%esp
   162fb:	84 c0                	test   %al,%al
   162fd:	74 79                	je     16378 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
   162ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   16302:	83 ec 04             	sub    $0x4,%esp
   16305:	8d 55 bc             	lea    -0x44(%ebp),%edx
   16308:	52                   	push   %edx
   16309:	50                   	push   %eax
   1630a:	ff 75 ec             	pushl  -0x14(%ebp)
   1630d:	e8 4f 3a ff ff       	call   9d61 <lodepng_addofl>
   16312:	83 c4 10             	add    $0x10,%esp
   16315:	85 c0                	test   %eax,%eax
   16317:	74 12                	je     1632b <decodeGeneric+0x209>
   16319:	8b 45 14             	mov    0x14(%ebp),%eax
   1631c:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   16323:	00 00 00 
   16326:	e9 9c 05 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
   1632b:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1632e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   16331:	7e 13                	jle    16346 <decodeGeneric+0x224>
   16333:	8b 45 14             	mov    0x14(%ebp),%eax
   16336:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   1633d:	00 00 00 
   16340:	90                   	nop
   16341:	e9 81 05 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
   16346:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   16349:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1634c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1634f:	01 ca                	add    %ecx,%edx
   16351:	83 ec 04             	sub    $0x4,%esp
   16354:	50                   	push   %eax
   16355:	ff 75 d0             	pushl  -0x30(%ebp)
   16358:	52                   	push   %edx
   16359:	e8 7d 39 ff ff       	call   9cdb <lodepng_memcpy>
   1635e:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
   16361:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16364:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   16367:	01 d0                	add    %edx,%eax
   16369:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
   1636c:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
   16373:	e9 db 04 00 00       	jmp    16853 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
   16378:	83 ec 08             	sub    $0x8,%esp
   1637b:	68 a9 0b 02 00       	push   $0x20ba9
   16380:	ff 75 f0             	pushl  -0x10(%ebp)
   16383:	e8 e4 88 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16388:	83 c4 10             	add    $0x10,%esp
   1638b:	84 c0                	test   %al,%al
   1638d:	74 09                	je     16398 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
   1638f:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
   16393:	e9 bb 04 00 00       	jmp    16853 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   16398:	83 ec 08             	sub    $0x8,%esp
   1639b:	68 68 0b 02 00       	push   $0x20b68
   163a0:	ff 75 f0             	pushl  -0x10(%ebp)
   163a3:	e8 c4 88 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   163a8:	83 c4 10             	add    $0x10,%esp
   163ab:	84 c0                	test   %al,%al
   163ad:	74 44                	je     163f3 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   163af:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   163b2:	8b 55 14             	mov    0x14(%ebp),%edx
   163b5:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   163bb:	83 ec 04             	sub    $0x4,%esp
   163be:	50                   	push   %eax
   163bf:	ff 75 d0             	pushl  -0x30(%ebp)
   163c2:	52                   	push   %edx
   163c3:	e8 ec e8 ff ff       	call   14cb4 <readChunk_PLTE>
   163c8:	83 c4 10             	add    $0x10,%esp
   163cb:	89 c2                	mov    %eax,%edx
   163cd:	8b 45 14             	mov    0x14(%ebp),%eax
   163d0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   163d6:	8b 45 14             	mov    0x14(%ebp),%eax
   163d9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   163df:	85 c0                	test   %eax,%eax
   163e1:	0f 85 dc 04 00 00    	jne    168c3 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
   163e7:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
   163ee:	e9 60 04 00 00       	jmp    16853 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   163f3:	83 ec 08             	sub    $0x8,%esp
   163f6:	68 6d 0b 02 00       	push   $0x20b6d
   163fb:	ff 75 f0             	pushl  -0x10(%ebp)
   163fe:	e8 69 88 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16403:	83 c4 10             	add    $0x10,%esp
   16406:	84 c0                	test   %al,%al
   16408:	74 3d                	je     16447 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   1640a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1640d:	8b 55 14             	mov    0x14(%ebp),%edx
   16410:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   16416:	83 ec 04             	sub    $0x4,%esp
   16419:	50                   	push   %eax
   1641a:	ff 75 d0             	pushl  -0x30(%ebp)
   1641d:	52                   	push   %edx
   1641e:	e8 b1 e9 ff ff       	call   14dd4 <readChunk_tRNS>
   16423:	83 c4 10             	add    $0x10,%esp
   16426:	89 c2                	mov    %eax,%edx
   16428:	8b 45 14             	mov    0x14(%ebp),%eax
   1642b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   16431:	8b 45 14             	mov    0x14(%ebp),%eax
   16434:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1643a:	85 c0                	test   %eax,%eax
   1643c:	0f 84 11 04 00 00    	je     16853 <decodeGeneric+0x731>
   16442:	e9 80 04 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   16447:	83 ec 08             	sub    $0x8,%esp
   1644a:	68 72 0b 02 00       	push   $0x20b72
   1644f:	ff 75 f0             	pushl  -0x10(%ebp)
   16452:	e8 15 88 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16457:	83 c4 10             	add    $0x10,%esp
   1645a:	84 c0                	test   %al,%al
   1645c:	74 3d                	je     1649b <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
   1645e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   16461:	8b 55 14             	mov    0x14(%ebp),%edx
   16464:	81 c2 98 00 00 00    	add    $0x98,%edx
   1646a:	83 ec 04             	sub    $0x4,%esp
   1646d:	50                   	push   %eax
   1646e:	ff 75 d0             	pushl  -0x30(%ebp)
   16471:	52                   	push   %edx
   16472:	e8 c0 ea ff ff       	call   14f37 <readChunk_bKGD>
   16477:	83 c4 10             	add    $0x10,%esp
   1647a:	89 c2                	mov    %eax,%edx
   1647c:	8b 45 14             	mov    0x14(%ebp),%eax
   1647f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   16485:	8b 45 14             	mov    0x14(%ebp),%eax
   16488:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1648e:	85 c0                	test   %eax,%eax
   16490:	0f 84 bd 03 00 00    	je     16853 <decodeGeneric+0x731>
   16496:	e9 2c 04 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   1649b:	83 ec 08             	sub    $0x8,%esp
   1649e:	68 77 0b 02 00       	push   $0x20b77
   164a3:	ff 75 f0             	pushl  -0x10(%ebp)
   164a6:	e8 c1 87 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   164ab:	83 c4 10             	add    $0x10,%esp
   164ae:	84 c0                	test   %al,%al
   164b0:	74 4b                	je     164fd <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
   164b2:	8b 45 14             	mov    0x14(%ebp),%eax
   164b5:	8b 40 28             	mov    0x28(%eax),%eax
   164b8:	85 c0                	test   %eax,%eax
   164ba:	0f 84 93 03 00 00    	je     16853 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
   164c0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   164c3:	8b 55 14             	mov    0x14(%ebp),%edx
   164c6:	81 c2 98 00 00 00    	add    $0x98,%edx
   164cc:	83 ec 04             	sub    $0x4,%esp
   164cf:	50                   	push   %eax
   164d0:	ff 75 d0             	pushl  -0x30(%ebp)
   164d3:	52                   	push   %edx
   164d4:	e8 e1 eb ff ff       	call   150ba <readChunk_tEXt>
   164d9:	83 c4 10             	add    $0x10,%esp
   164dc:	89 c2                	mov    %eax,%edx
   164de:	8b 45 14             	mov    0x14(%ebp),%eax
   164e1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   164e7:	8b 45 14             	mov    0x14(%ebp),%eax
   164ea:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   164f0:	85 c0                	test   %eax,%eax
   164f2:	0f 84 5b 03 00 00    	je     16853 <decodeGeneric+0x731>
   164f8:	e9 ca 03 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   164fd:	83 ec 08             	sub    $0x8,%esp
   16500:	68 7c 0b 02 00       	push   $0x20b7c
   16505:	ff 75 f0             	pushl  -0x10(%ebp)
   16508:	e8 5f 87 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   1650d:	83 c4 10             	add    $0x10,%esp
   16510:	84 c0                	test   %al,%al
   16512:	74 4c                	je     16560 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
   16514:	8b 45 14             	mov    0x14(%ebp),%eax
   16517:	8b 40 28             	mov    0x28(%eax),%eax
   1651a:	85 c0                	test   %eax,%eax
   1651c:	0f 84 31 03 00 00    	je     16853 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   16522:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   16525:	8b 45 14             	mov    0x14(%ebp),%eax
   16528:	8b 4d 14             	mov    0x14(%ebp),%ecx
   1652b:	81 c1 98 00 00 00    	add    $0x98,%ecx
   16531:	52                   	push   %edx
   16532:	ff 75 d0             	pushl  -0x30(%ebp)
   16535:	50                   	push   %eax
   16536:	51                   	push   %ecx
   16537:	e8 ca ec ff ff       	call   15206 <readChunk_zTXt>
   1653c:	83 c4 10             	add    $0x10,%esp
   1653f:	89 c2                	mov    %eax,%edx
   16541:	8b 45 14             	mov    0x14(%ebp),%eax
   16544:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   1654a:	8b 45 14             	mov    0x14(%ebp),%eax
   1654d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16553:	85 c0                	test   %eax,%eax
   16555:	0f 84 f8 02 00 00    	je     16853 <decodeGeneric+0x731>
   1655b:	e9 67 03 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   16560:	83 ec 08             	sub    $0x8,%esp
   16563:	68 81 0b 02 00       	push   $0x20b81
   16568:	ff 75 f0             	pushl  -0x10(%ebp)
   1656b:	e8 fc 86 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16570:	83 c4 10             	add    $0x10,%esp
   16573:	84 c0                	test   %al,%al
   16575:	74 4c                	je     165c3 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
   16577:	8b 45 14             	mov    0x14(%ebp),%eax
   1657a:	8b 40 28             	mov    0x28(%eax),%eax
   1657d:	85 c0                	test   %eax,%eax
   1657f:	0f 84 ce 02 00 00    	je     16853 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   16585:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   16588:	8b 45 14             	mov    0x14(%ebp),%eax
   1658b:	8b 4d 14             	mov    0x14(%ebp),%ecx
   1658e:	81 c1 98 00 00 00    	add    $0x98,%ecx
   16594:	52                   	push   %edx
   16595:	ff 75 d0             	pushl  -0x30(%ebp)
   16598:	50                   	push   %eax
   16599:	51                   	push   %ecx
   1659a:	e8 23 ee ff ff       	call   153c2 <readChunk_iTXt>
   1659f:	83 c4 10             	add    $0x10,%esp
   165a2:	89 c2                	mov    %eax,%edx
   165a4:	8b 45 14             	mov    0x14(%ebp),%eax
   165a7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   165ad:	8b 45 14             	mov    0x14(%ebp),%eax
   165b0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   165b6:	85 c0                	test   %eax,%eax
   165b8:	0f 84 95 02 00 00    	je     16853 <decodeGeneric+0x731>
   165be:	e9 04 03 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   165c3:	83 ec 08             	sub    $0x8,%esp
   165c6:	68 86 0b 02 00       	push   $0x20b86
   165cb:	ff 75 f0             	pushl  -0x10(%ebp)
   165ce:	e8 99 86 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   165d3:	83 c4 10             	add    $0x10,%esp
   165d6:	84 c0                	test   %al,%al
   165d8:	74 3d                	je     16617 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
   165da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   165dd:	8b 55 14             	mov    0x14(%ebp),%edx
   165e0:	81 c2 98 00 00 00    	add    $0x98,%edx
   165e6:	83 ec 04             	sub    $0x4,%esp
   165e9:	50                   	push   %eax
   165ea:	ff 75 d0             	pushl  -0x30(%ebp)
   165ed:	52                   	push   %edx
   165ee:	e8 25 f1 ff ff       	call   15718 <readChunk_tIME>
   165f3:	83 c4 10             	add    $0x10,%esp
   165f6:	89 c2                	mov    %eax,%edx
   165f8:	8b 45 14             	mov    0x14(%ebp),%eax
   165fb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   16601:	8b 45 14             	mov    0x14(%ebp),%eax
   16604:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1660a:	85 c0                	test   %eax,%eax
   1660c:	0f 84 41 02 00 00    	je     16853 <decodeGeneric+0x731>
   16612:	e9 b0 02 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   16617:	83 ec 08             	sub    $0x8,%esp
   1661a:	68 8b 0b 02 00       	push   $0x20b8b
   1661f:	ff 75 f0             	pushl  -0x10(%ebp)
   16622:	e8 45 86 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16627:	83 c4 10             	add    $0x10,%esp
   1662a:	84 c0                	test   %al,%al
   1662c:	74 3d                	je     1666b <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
   1662e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   16631:	8b 55 14             	mov    0x14(%ebp),%edx
   16634:	81 c2 98 00 00 00    	add    $0x98,%edx
   1663a:	83 ec 04             	sub    $0x4,%esp
   1663d:	50                   	push   %eax
   1663e:	ff 75 d0             	pushl  -0x30(%ebp)
   16641:	52                   	push   %edx
   16642:	e8 71 f1 ff ff       	call   157b8 <readChunk_pHYs>
   16647:	83 c4 10             	add    $0x10,%esp
   1664a:	89 c2                	mov    %eax,%edx
   1664c:	8b 45 14             	mov    0x14(%ebp),%eax
   1664f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   16655:	8b 45 14             	mov    0x14(%ebp),%eax
   16658:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1665e:	85 c0                	test   %eax,%eax
   16660:	0f 84 ed 01 00 00    	je     16853 <decodeGeneric+0x731>
   16666:	e9 5c 02 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   1666b:	83 ec 08             	sub    $0x8,%esp
   1666e:	68 90 0b 02 00       	push   $0x20b90
   16673:	ff 75 f0             	pushl  -0x10(%ebp)
   16676:	e8 f1 85 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   1667b:	83 c4 10             	add    $0x10,%esp
   1667e:	84 c0                	test   %al,%al
   16680:	74 3d                	je     166bf <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
   16682:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   16685:	8b 55 14             	mov    0x14(%ebp),%edx
   16688:	81 c2 98 00 00 00    	add    $0x98,%edx
   1668e:	83 ec 04             	sub    $0x4,%esp
   16691:	50                   	push   %eax
   16692:	ff 75 d0             	pushl  -0x30(%ebp)
   16695:	52                   	push   %edx
   16696:	e8 ec f1 ff ff       	call   15887 <readChunk_gAMA>
   1669b:	83 c4 10             	add    $0x10,%esp
   1669e:	89 c2                	mov    %eax,%edx
   166a0:	8b 45 14             	mov    0x14(%ebp),%eax
   166a3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   166a9:	8b 45 14             	mov    0x14(%ebp),%eax
   166ac:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   166b2:	85 c0                	test   %eax,%eax
   166b4:	0f 84 99 01 00 00    	je     16853 <decodeGeneric+0x731>
   166ba:	e9 08 02 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   166bf:	83 ec 08             	sub    $0x8,%esp
   166c2:	68 95 0b 02 00       	push   $0x20b95
   166c7:	ff 75 f0             	pushl  -0x10(%ebp)
   166ca:	e8 9d 85 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   166cf:	83 c4 10             	add    $0x10,%esp
   166d2:	84 c0                	test   %al,%al
   166d4:	74 3d                	je     16713 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   166d6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   166d9:	8b 55 14             	mov    0x14(%ebp),%edx
   166dc:	81 c2 98 00 00 00    	add    $0x98,%edx
   166e2:	83 ec 04             	sub    $0x4,%esp
   166e5:	50                   	push   %eax
   166e6:	ff 75 d0             	pushl  -0x30(%ebp)
   166e9:	52                   	push   %edx
   166ea:	e8 07 f2 ff ff       	call   158f6 <readChunk_cHRM>
   166ef:	83 c4 10             	add    $0x10,%esp
   166f2:	89 c2                	mov    %eax,%edx
   166f4:	8b 45 14             	mov    0x14(%ebp),%eax
   166f7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   166fd:	8b 45 14             	mov    0x14(%ebp),%eax
   16700:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16706:	85 c0                	test   %eax,%eax
   16708:	0f 84 45 01 00 00    	je     16853 <decodeGeneric+0x731>
   1670e:	e9 b4 01 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   16713:	83 ec 08             	sub    $0x8,%esp
   16716:	68 9a 0b 02 00       	push   $0x20b9a
   1671b:	ff 75 f0             	pushl  -0x10(%ebp)
   1671e:	e8 49 85 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16723:	83 c4 10             	add    $0x10,%esp
   16726:	84 c0                	test   %al,%al
   16728:	74 3d                	je     16767 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   1672a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1672d:	8b 55 14             	mov    0x14(%ebp),%edx
   16730:	81 c2 98 00 00 00    	add    $0x98,%edx
   16736:	83 ec 04             	sub    $0x4,%esp
   16739:	50                   	push   %eax
   1673a:	ff 75 d0             	pushl  -0x30(%ebp)
   1673d:	52                   	push   %edx
   1673e:	e8 47 f4 ff ff       	call   15b8a <readChunk_sRGB>
   16743:	83 c4 10             	add    $0x10,%esp
   16746:	89 c2                	mov    %eax,%edx
   16748:	8b 45 14             	mov    0x14(%ebp),%eax
   1674b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   16751:	8b 45 14             	mov    0x14(%ebp),%eax
   16754:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1675a:	85 c0                	test   %eax,%eax
   1675c:	0f 84 f1 00 00 00    	je     16853 <decodeGeneric+0x731>
   16762:	e9 60 01 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   16767:	83 ec 08             	sub    $0x8,%esp
   1676a:	68 9f 0b 02 00       	push   $0x20b9f
   1676f:	ff 75 f0             	pushl  -0x10(%ebp)
   16772:	e8 f5 84 ff ff       	call   ec6c <lodepng_chunk_type_equals>
   16777:	83 c4 10             	add    $0x10,%esp
   1677a:	84 c0                	test   %al,%al
   1677c:	74 3e                	je     167bc <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   1677e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   16781:	8b 45 14             	mov    0x14(%ebp),%eax
   16784:	8b 4d 14             	mov    0x14(%ebp),%ecx
   16787:	81 c1 98 00 00 00    	add    $0x98,%ecx
   1678d:	52                   	push   %edx
   1678e:	ff 75 d0             	pushl  -0x30(%ebp)
   16791:	50                   	push   %eax
   16792:	51                   	push   %ecx
   16793:	e8 28 f4 ff ff       	call   15bc0 <readChunk_iCCP>
   16798:	83 c4 10             	add    $0x10,%esp
   1679b:	89 c2                	mov    %eax,%edx
   1679d:	8b 45 14             	mov    0x14(%ebp),%eax
   167a0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   167a6:	8b 45 14             	mov    0x14(%ebp),%eax
   167a9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   167af:	85 c0                	test   %eax,%eax
   167b1:	0f 84 9c 00 00 00    	je     16853 <decodeGeneric+0x731>
   167b7:	e9 0b 01 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   167bc:	8b 45 14             	mov    0x14(%ebp),%eax
   167bf:	8b 40 1c             	mov    0x1c(%eax),%eax
   167c2:	85 c0                	test   %eax,%eax
   167c4:	75 24                	jne    167ea <decodeGeneric+0x6c8>
   167c6:	83 ec 0c             	sub    $0xc,%esp
   167c9:	ff 75 f0             	pushl  -0x10(%ebp)
   167cc:	e8 30 85 ff ff       	call   ed01 <lodepng_chunk_ancillary>
   167d1:	83 c4 10             	add    $0x10,%esp
   167d4:	84 c0                	test   %al,%al
   167d6:	75 12                	jne    167ea <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   167d8:	8b 45 14             	mov    0x14(%ebp),%eax
   167db:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   167e2:	00 00 00 
   167e5:	e9 dd 00 00 00       	jmp    168c7 <decodeGeneric+0x7a5>
      }

      unknown = 1;
   167ea:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   167f1:	8b 45 14             	mov    0x14(%ebp),%eax
   167f4:	8b 40 2c             	mov    0x2c(%eax),%eax
   167f7:	85 c0                	test   %eax,%eax
   167f9:	74 58                	je     16853 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   167fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   167fe:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   16801:	83 c0 58             	add    $0x58,%eax
   16804:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1680b:	8b 45 14             	mov    0x14(%ebp),%eax
   1680e:	01 d0                	add    %edx,%eax
   16810:	8d 50 10             	lea    0x10(%eax),%edx
   16813:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16816:	83 e8 01             	sub    $0x1,%eax
   16819:	83 c0 54             	add    $0x54,%eax
   1681c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   16823:	8b 45 14             	mov    0x14(%ebp),%eax
   16826:	01 c8                	add    %ecx,%eax
   16828:	83 c0 14             	add    $0x14,%eax
   1682b:	83 ec 04             	sub    $0x4,%esp
   1682e:	ff 75 f0             	pushl  -0x10(%ebp)
   16831:	52                   	push   %edx
   16832:	50                   	push   %eax
   16833:	e8 15 88 ff ff       	call   f04d <lodepng_chunk_append>
   16838:	83 c4 10             	add    $0x10,%esp
   1683b:	89 c2                	mov    %eax,%edx
   1683d:	8b 45 14             	mov    0x14(%ebp),%eax
   16840:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   16846:	8b 45 14             	mov    0x14(%ebp),%eax
   16849:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1684f:	85 c0                	test   %eax,%eax
   16851:	75 73                	jne    168c6 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   16853:	8b 45 14             	mov    0x14(%ebp),%eax
   16856:	8b 40 18             	mov    0x18(%eax),%eax
   16859:	85 c0                	test   %eax,%eax
   1685b:	75 27                	jne    16884 <decodeGeneric+0x762>
   1685d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   16861:	75 21                	jne    16884 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   16863:	83 ec 0c             	sub    $0xc,%esp
   16866:	ff 75 f0             	pushl  -0x10(%ebp)
   16869:	e8 f4 84 ff ff       	call   ed62 <lodepng_chunk_check_crc>
   1686e:	83 c4 10             	add    $0x10,%esp
   16871:	85 c0                	test   %eax,%eax
   16873:	74 0f                	je     16884 <decodeGeneric+0x762>
   16875:	8b 45 14             	mov    0x14(%ebp),%eax
   16878:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   1687f:	00 00 00 
   16882:	eb 43                	jmp    168c7 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   16884:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   16888:	75 1a                	jne    168a4 <decodeGeneric+0x782>
   1688a:	8b 55 1c             	mov    0x1c(%ebp),%edx
   1688d:	8b 45 18             	mov    0x18(%ebp),%eax
   16890:	01 d0                	add    %edx,%eax
   16892:	83 ec 08             	sub    $0x8,%esp
   16895:	50                   	push   %eax
   16896:	ff 75 f0             	pushl  -0x10(%ebp)
   16899:	e8 3f 86 ff ff       	call   eedd <lodepng_chunk_next_const>
   1689e:	83 c4 10             	add    $0x10,%esp
   168a1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   168a4:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   168a8:	75 1d                	jne    168c7 <decodeGeneric+0x7a5>
   168aa:	8b 45 14             	mov    0x14(%ebp),%eax
   168ad:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   168b3:	85 c0                	test   %eax,%eax
   168b5:	0f 84 68 f9 ff ff    	je     16223 <decodeGeneric+0x101>
   168bb:	eb 0a                	jmp    168c7 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   168bd:	90                   	nop
   168be:	eb 07                	jmp    168c7 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   168c0:	90                   	nop
   168c1:	eb 04                	jmp    168c7 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   168c3:	90                   	nop
   168c4:	eb 01                	jmp    168c7 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   168c6:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   168c7:	8b 45 14             	mov    0x14(%ebp),%eax
   168ca:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   168d0:	85 c0                	test   %eax,%eax
   168d2:	75 28                	jne    168fc <decodeGeneric+0x7da>
   168d4:	8b 45 14             	mov    0x14(%ebp),%eax
   168d7:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   168dd:	83 f8 03             	cmp    $0x3,%eax
   168e0:	75 1a                	jne    168fc <decodeGeneric+0x7da>
   168e2:	8b 45 14             	mov    0x14(%ebp),%eax
   168e5:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   168eb:	85 c0                	test   %eax,%eax
   168ed:	75 0d                	jne    168fc <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   168ef:	8b 45 14             	mov    0x14(%ebp),%eax
   168f2:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   168f9:	00 00 00 
  }

  if(!state->error) {
   168fc:	8b 45 14             	mov    0x14(%ebp),%eax
   168ff:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16905:	85 c0                	test   %eax,%eax
   16907:	0f 85 d2 01 00 00    	jne    16adf <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   1690d:	8b 45 14             	mov    0x14(%ebp),%eax
   16910:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   16916:	85 c0                	test   %eax,%eax
   16918:	75 3a                	jne    16954 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   1691a:	8b 45 14             	mov    0x14(%ebp),%eax
   1691d:	05 a4 00 00 00       	add    $0xa4,%eax
   16922:	83 ec 0c             	sub    $0xc,%esp
   16925:	50                   	push   %eax
   16926:	e8 8e 8e ff ff       	call   f7b9 <lodepng_get_bpp>
   1692b:	83 c4 10             	add    $0x10,%esp
   1692e:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   16931:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   16934:	8b 45 10             	mov    0x10(%ebp),%eax
   16937:	8b 10                	mov    (%eax),%edx
   16939:	8b 45 0c             	mov    0xc(%ebp),%eax
   1693c:	8b 00                	mov    (%eax),%eax
   1693e:	83 ec 04             	sub    $0x4,%esp
   16941:	51                   	push   %ecx
   16942:	52                   	push   %edx
   16943:	50                   	push   %eax
   16944:	e8 cf 8f ff ff       	call   f918 <lodepng_get_raw_size_idat>
   16949:	83 c4 10             	add    $0x10,%esp
   1694c:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1694f:	e9 60 01 00 00       	jmp    16ab4 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   16954:	8b 45 14             	mov    0x14(%ebp),%eax
   16957:	05 a4 00 00 00       	add    $0xa4,%eax
   1695c:	83 ec 0c             	sub    $0xc,%esp
   1695f:	50                   	push   %eax
   16960:	e8 54 8e ff ff       	call   f7b9 <lodepng_get_bpp>
   16965:	83 c4 10             	add    $0x10,%esp
   16968:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   1696b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   16972:	8b 45 c8             	mov    -0x38(%ebp),%eax
   16975:	8b 55 10             	mov    0x10(%ebp),%edx
   16978:	8b 12                	mov    (%edx),%edx
   1697a:	83 c2 07             	add    $0x7,%edx
   1697d:	89 d1                	mov    %edx,%ecx
   1697f:	c1 e9 03             	shr    $0x3,%ecx
   16982:	8b 55 0c             	mov    0xc(%ebp),%edx
   16985:	8b 12                	mov    (%edx),%edx
   16987:	83 c2 07             	add    $0x7,%edx
   1698a:	c1 ea 03             	shr    $0x3,%edx
   1698d:	83 ec 04             	sub    $0x4,%esp
   16990:	50                   	push   %eax
   16991:	51                   	push   %ecx
   16992:	52                   	push   %edx
   16993:	e8 80 8f ff ff       	call   f918 <lodepng_get_raw_size_idat>
   16998:	83 c4 10             	add    $0x10,%esp
   1699b:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   1699e:	8b 45 0c             	mov    0xc(%ebp),%eax
   169a1:	8b 00                	mov    (%eax),%eax
   169a3:	83 f8 04             	cmp    $0x4,%eax
   169a6:	76 2c                	jbe    169d4 <decodeGeneric+0x8b2>
   169a8:	8b 45 c8             	mov    -0x38(%ebp),%eax
   169ab:	8b 55 10             	mov    0x10(%ebp),%edx
   169ae:	8b 12                	mov    (%edx),%edx
   169b0:	83 c2 07             	add    $0x7,%edx
   169b3:	89 d1                	mov    %edx,%ecx
   169b5:	c1 e9 03             	shr    $0x3,%ecx
   169b8:	8b 55 0c             	mov    0xc(%ebp),%edx
   169bb:	8b 12                	mov    (%edx),%edx
   169bd:	83 c2 03             	add    $0x3,%edx
   169c0:	c1 ea 03             	shr    $0x3,%edx
   169c3:	83 ec 04             	sub    $0x4,%esp
   169c6:	50                   	push   %eax
   169c7:	51                   	push   %ecx
   169c8:	52                   	push   %edx
   169c9:	e8 4a 8f ff ff       	call   f918 <lodepng_get_raw_size_idat>
   169ce:	83 c4 10             	add    $0x10,%esp
   169d1:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   169d4:	8b 45 c8             	mov    -0x38(%ebp),%eax
   169d7:	8b 55 10             	mov    0x10(%ebp),%edx
   169da:	8b 12                	mov    (%edx),%edx
   169dc:	83 c2 03             	add    $0x3,%edx
   169df:	89 d1                	mov    %edx,%ecx
   169e1:	c1 e9 03             	shr    $0x3,%ecx
   169e4:	8b 55 0c             	mov    0xc(%ebp),%edx
   169e7:	8b 12                	mov    (%edx),%edx
   169e9:	83 c2 03             	add    $0x3,%edx
   169ec:	c1 ea 02             	shr    $0x2,%edx
   169ef:	83 ec 04             	sub    $0x4,%esp
   169f2:	50                   	push   %eax
   169f3:	51                   	push   %ecx
   169f4:	52                   	push   %edx
   169f5:	e8 1e 8f ff ff       	call   f918 <lodepng_get_raw_size_idat>
   169fa:	83 c4 10             	add    $0x10,%esp
   169fd:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   16a00:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a03:	8b 00                	mov    (%eax),%eax
   16a05:	83 f8 02             	cmp    $0x2,%eax
   16a08:	76 2c                	jbe    16a36 <decodeGeneric+0x914>
   16a0a:	8b 45 c8             	mov    -0x38(%ebp),%eax
   16a0d:	8b 55 10             	mov    0x10(%ebp),%edx
   16a10:	8b 12                	mov    (%edx),%edx
   16a12:	83 c2 03             	add    $0x3,%edx
   16a15:	89 d1                	mov    %edx,%ecx
   16a17:	c1 e9 02             	shr    $0x2,%ecx
   16a1a:	8b 55 0c             	mov    0xc(%ebp),%edx
   16a1d:	8b 12                	mov    (%edx),%edx
   16a1f:	83 c2 01             	add    $0x1,%edx
   16a22:	c1 ea 02             	shr    $0x2,%edx
   16a25:	83 ec 04             	sub    $0x4,%esp
   16a28:	50                   	push   %eax
   16a29:	51                   	push   %ecx
   16a2a:	52                   	push   %edx
   16a2b:	e8 e8 8e ff ff       	call   f918 <lodepng_get_raw_size_idat>
   16a30:	83 c4 10             	add    $0x10,%esp
   16a33:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   16a36:	8b 45 c8             	mov    -0x38(%ebp),%eax
   16a39:	8b 55 10             	mov    0x10(%ebp),%edx
   16a3c:	8b 12                	mov    (%edx),%edx
   16a3e:	83 c2 01             	add    $0x1,%edx
   16a41:	89 d1                	mov    %edx,%ecx
   16a43:	c1 e9 02             	shr    $0x2,%ecx
   16a46:	8b 55 0c             	mov    0xc(%ebp),%edx
   16a49:	8b 12                	mov    (%edx),%edx
   16a4b:	83 c2 01             	add    $0x1,%edx
   16a4e:	d1 ea                	shr    %edx
   16a50:	83 ec 04             	sub    $0x4,%esp
   16a53:	50                   	push   %eax
   16a54:	51                   	push   %ecx
   16a55:	52                   	push   %edx
   16a56:	e8 bd 8e ff ff       	call   f918 <lodepng_get_raw_size_idat>
   16a5b:	83 c4 10             	add    $0x10,%esp
   16a5e:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   16a61:	8b 45 0c             	mov    0xc(%ebp),%eax
   16a64:	8b 00                	mov    (%eax),%eax
   16a66:	83 f8 01             	cmp    $0x1,%eax
   16a69:	76 27                	jbe    16a92 <decodeGeneric+0x970>
   16a6b:	8b 45 c8             	mov    -0x38(%ebp),%eax
   16a6e:	8b 55 10             	mov    0x10(%ebp),%edx
   16a71:	8b 12                	mov    (%edx),%edx
   16a73:	83 c2 01             	add    $0x1,%edx
   16a76:	89 d1                	mov    %edx,%ecx
   16a78:	d1 e9                	shr    %ecx
   16a7a:	8b 55 0c             	mov    0xc(%ebp),%edx
   16a7d:	8b 12                	mov    (%edx),%edx
   16a7f:	d1 ea                	shr    %edx
   16a81:	83 ec 04             	sub    $0x4,%esp
   16a84:	50                   	push   %eax
   16a85:	51                   	push   %ecx
   16a86:	52                   	push   %edx
   16a87:	e8 8c 8e ff ff       	call   f918 <lodepng_get_raw_size_idat>
   16a8c:	83 c4 10             	add    $0x10,%esp
   16a8f:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   16a92:	8b 55 c8             	mov    -0x38(%ebp),%edx
   16a95:	8b 45 10             	mov    0x10(%ebp),%eax
   16a98:	8b 00                	mov    (%eax),%eax
   16a9a:	d1 e8                	shr    %eax
   16a9c:	89 c1                	mov    %eax,%ecx
   16a9e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16aa1:	8b 00                	mov    (%eax),%eax
   16aa3:	83 ec 04             	sub    $0x4,%esp
   16aa6:	52                   	push   %edx
   16aa7:	51                   	push   %ecx
   16aa8:	50                   	push   %eax
   16aa9:	e8 6a 8e ff ff       	call   f918 <lodepng_get_raw_size_idat>
   16aae:	83 c4 10             	add    $0x10,%esp
   16ab1:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   16ab4:	8b 45 14             	mov    0x14(%ebp),%eax
   16ab7:	83 ec 08             	sub    $0x8,%esp
   16aba:	50                   	push   %eax
   16abb:	ff 75 ec             	pushl  -0x14(%ebp)
   16abe:	ff 75 d8             	pushl  -0x28(%ebp)
   16ac1:	ff 75 e8             	pushl  -0x18(%ebp)
   16ac4:	8d 45 c0             	lea    -0x40(%ebp),%eax
   16ac7:	50                   	push   %eax
   16ac8:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   16acb:	50                   	push   %eax
   16acc:	e8 87 7c ff ff       	call   e758 <zlib_decompress>
   16ad1:	83 c4 20             	add    $0x20,%esp
   16ad4:	89 c2                	mov    %eax,%edx
   16ad6:	8b 45 14             	mov    0x14(%ebp),%eax
   16ad9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   16adf:	8b 45 14             	mov    0x14(%ebp),%eax
   16ae2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16ae8:	85 c0                	test   %eax,%eax
   16aea:	75 15                	jne    16b01 <decodeGeneric+0x9df>
   16aec:	8b 45 c0             	mov    -0x40(%ebp),%eax
   16aef:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   16af2:	74 0d                	je     16b01 <decodeGeneric+0x9df>
   16af4:	8b 45 14             	mov    0x14(%ebp),%eax
   16af7:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   16afe:	00 00 00 
  lodepng_free(idat);
   16b01:	83 ec 0c             	sub    $0xc,%esp
   16b04:	ff 75 d8             	pushl  -0x28(%ebp)
   16b07:	e8 b2 31 ff ff       	call   9cbe <lodepng_free>
   16b0c:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   16b0f:	8b 45 14             	mov    0x14(%ebp),%eax
   16b12:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16b18:	85 c0                	test   %eax,%eax
   16b1a:	75 4f                	jne    16b6b <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   16b1c:	8b 45 14             	mov    0x14(%ebp),%eax
   16b1f:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   16b25:	8b 45 10             	mov    0x10(%ebp),%eax
   16b28:	8b 10                	mov    (%eax),%edx
   16b2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   16b2d:	8b 00                	mov    (%eax),%eax
   16b2f:	83 ec 04             	sub    $0x4,%esp
   16b32:	51                   	push   %ecx
   16b33:	52                   	push   %edx
   16b34:	50                   	push   %eax
   16b35:	e8 be 8d ff ff       	call   f8f8 <lodepng_get_raw_size>
   16b3a:	83 c4 10             	add    $0x10,%esp
   16b3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   16b40:	83 ec 0c             	sub    $0xc,%esp
   16b43:	ff 75 e4             	pushl  -0x1c(%ebp)
   16b46:	e8 52 31 ff ff       	call   9c9d <lodepng_malloc>
   16b4b:	83 c4 10             	add    $0x10,%esp
   16b4e:	89 c2                	mov    %eax,%edx
   16b50:	8b 45 08             	mov    0x8(%ebp),%eax
   16b53:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   16b55:	8b 45 08             	mov    0x8(%ebp),%eax
   16b58:	8b 00                	mov    (%eax),%eax
   16b5a:	85 c0                	test   %eax,%eax
   16b5c:	75 0d                	jne    16b6b <decodeGeneric+0xa49>
   16b5e:	8b 45 14             	mov    0x14(%ebp),%eax
   16b61:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   16b68:	00 00 00 
  }
  if(!state->error) {
   16b6b:	8b 45 14             	mov    0x14(%ebp),%eax
   16b6e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16b74:	85 c0                	test   %eax,%eax
   16b76:	75 4c                	jne    16bc4 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   16b78:	8b 45 08             	mov    0x8(%ebp),%eax
   16b7b:	8b 00                	mov    (%eax),%eax
   16b7d:	83 ec 04             	sub    $0x4,%esp
   16b80:	ff 75 e4             	pushl  -0x1c(%ebp)
   16b83:	6a 00                	push   $0x0
   16b85:	50                   	push   %eax
   16b86:	e8 83 31 ff ff       	call   9d0e <lodepng_memset>
   16b8b:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   16b8e:	8b 45 14             	mov    0x14(%ebp),%eax
   16b91:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   16b97:	8b 45 10             	mov    0x10(%ebp),%eax
   16b9a:	8b 18                	mov    (%eax),%ebx
   16b9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   16b9f:	8b 08                	mov    (%eax),%ecx
   16ba1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   16ba4:	8b 45 08             	mov    0x8(%ebp),%eax
   16ba7:	8b 00                	mov    (%eax),%eax
   16ba9:	83 ec 0c             	sub    $0xc,%esp
   16bac:	56                   	push   %esi
   16bad:	53                   	push   %ebx
   16bae:	51                   	push   %ecx
   16baf:	52                   	push   %edx
   16bb0:	50                   	push   %eax
   16bb1:	e8 05 df ff ff       	call   14abb <postProcessScanlines>
   16bb6:	83 c4 20             	add    $0x20,%esp
   16bb9:	89 c2                	mov    %eax,%edx
   16bbb:	8b 45 14             	mov    0x14(%ebp),%eax
   16bbe:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   16bc4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16bc7:	83 ec 0c             	sub    $0xc,%esp
   16bca:	50                   	push   %eax
   16bcb:	e8 ee 30 ff ff       	call   9cbe <lodepng_free>
   16bd0:	83 c4 10             	add    $0x10,%esp
   16bd3:	eb 01                	jmp    16bd6 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   16bd5:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   16bd6:	8d 65 f8             	lea    -0x8(%ebp),%esp
   16bd9:	5b                   	pop    %ebx
   16bda:	5e                   	pop    %esi
   16bdb:	5d                   	pop    %ebp
   16bdc:	c3                   	ret    

00016bdd <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   16bdd:	55                   	push   %ebp
   16bde:	89 e5                	mov    %esp,%ebp
   16be0:	56                   	push   %esi
   16be1:	53                   	push   %ebx
   16be2:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   16be5:	8b 45 08             	mov    0x8(%ebp),%eax
   16be8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   16bee:	83 ec 08             	sub    $0x8,%esp
   16bf1:	ff 75 1c             	pushl  0x1c(%ebp)
   16bf4:	ff 75 18             	pushl  0x18(%ebp)
   16bf7:	ff 75 14             	pushl  0x14(%ebp)
   16bfa:	ff 75 10             	pushl  0x10(%ebp)
   16bfd:	ff 75 0c             	pushl  0xc(%ebp)
   16c00:	ff 75 08             	pushl  0x8(%ebp)
   16c03:	e8 1a f5 ff ff       	call   16122 <decodeGeneric>
   16c08:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   16c0b:	8b 45 14             	mov    0x14(%ebp),%eax
   16c0e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16c14:	85 c0                	test   %eax,%eax
   16c16:	74 0e                	je     16c26 <lodepng_decode+0x49>
   16c18:	8b 45 14             	mov    0x14(%ebp),%eax
   16c1b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16c21:	e9 55 01 00 00       	jmp    16d7b <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   16c26:	8b 45 14             	mov    0x14(%ebp),%eax
   16c29:	8b 40 24             	mov    0x24(%eax),%eax
   16c2c:	85 c0                	test   %eax,%eax
   16c2e:	74 20                	je     16c50 <lodepng_decode+0x73>
   16c30:	8b 45 14             	mov    0x14(%ebp),%eax
   16c33:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   16c39:	8b 45 14             	mov    0x14(%ebp),%eax
   16c3c:	83 c0 78             	add    $0x78,%eax
   16c3f:	83 ec 08             	sub    $0x8,%esp
   16c42:	52                   	push   %edx
   16c43:	50                   	push   %eax
   16c44:	e8 56 89 ff ff       	call   f59f <lodepng_color_mode_equal>
   16c49:	83 c4 10             	add    $0x10,%esp
   16c4c:	85 c0                	test   %eax,%eax
   16c4e:	74 54                	je     16ca4 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   16c50:	8b 45 14             	mov    0x14(%ebp),%eax
   16c53:	8b 40 24             	mov    0x24(%eax),%eax
   16c56:	85 c0                	test   %eax,%eax
   16c58:	0f 85 13 01 00 00    	jne    16d71 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   16c5e:	8b 45 14             	mov    0x14(%ebp),%eax
   16c61:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   16c67:	8b 45 14             	mov    0x14(%ebp),%eax
   16c6a:	83 c0 78             	add    $0x78,%eax
   16c6d:	83 ec 08             	sub    $0x8,%esp
   16c70:	52                   	push   %edx
   16c71:	50                   	push   %eax
   16c72:	e8 3f 88 ff ff       	call   f4b6 <lodepng_color_mode_copy>
   16c77:	83 c4 10             	add    $0x10,%esp
   16c7a:	89 c2                	mov    %eax,%edx
   16c7c:	8b 45 14             	mov    0x14(%ebp),%eax
   16c7f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   16c85:	8b 45 14             	mov    0x14(%ebp),%eax
   16c88:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16c8e:	85 c0                	test   %eax,%eax
   16c90:	0f 84 db 00 00 00    	je     16d71 <lodepng_decode+0x194>
   16c96:	8b 45 14             	mov    0x14(%ebp),%eax
   16c99:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16c9f:	e9 d7 00 00 00       	jmp    16d7b <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   16ca4:	8b 45 08             	mov    0x8(%ebp),%eax
   16ca7:	8b 00                	mov    (%eax),%eax
   16ca9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   16cac:	8b 45 14             	mov    0x14(%ebp),%eax
   16caf:	8b 40 78             	mov    0x78(%eax),%eax
   16cb2:	83 f8 02             	cmp    $0x2,%eax
   16cb5:	74 20                	je     16cd7 <lodepng_decode+0xfa>
   16cb7:	8b 45 14             	mov    0x14(%ebp),%eax
   16cba:	8b 40 78             	mov    0x78(%eax),%eax
   16cbd:	83 f8 06             	cmp    $0x6,%eax
   16cc0:	74 15                	je     16cd7 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   16cc2:	8b 45 14             	mov    0x14(%ebp),%eax
   16cc5:	8b 40 7c             	mov    0x7c(%eax),%eax
   16cc8:	83 f8 08             	cmp    $0x8,%eax
   16ccb:	74 0a                	je     16cd7 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   16ccd:	b8 38 00 00 00       	mov    $0x38,%eax
   16cd2:	e9 a4 00 00 00       	jmp    16d7b <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   16cd7:	8b 45 14             	mov    0x14(%ebp),%eax
   16cda:	8d 48 78             	lea    0x78(%eax),%ecx
   16cdd:	8b 45 10             	mov    0x10(%ebp),%eax
   16ce0:	8b 10                	mov    (%eax),%edx
   16ce2:	8b 45 0c             	mov    0xc(%ebp),%eax
   16ce5:	8b 00                	mov    (%eax),%eax
   16ce7:	83 ec 04             	sub    $0x4,%esp
   16cea:	51                   	push   %ecx
   16ceb:	52                   	push   %edx
   16cec:	50                   	push   %eax
   16ced:	e8 06 8c ff ff       	call   f8f8 <lodepng_get_raw_size>
   16cf2:	83 c4 10             	add    $0x10,%esp
   16cf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   16cf8:	83 ec 0c             	sub    $0xc,%esp
   16cfb:	ff 75 f0             	pushl  -0x10(%ebp)
   16cfe:	e8 9a 2f ff ff       	call   9c9d <lodepng_malloc>
   16d03:	83 c4 10             	add    $0x10,%esp
   16d06:	89 c2                	mov    %eax,%edx
   16d08:	8b 45 08             	mov    0x8(%ebp),%eax
   16d0b:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   16d0d:	8b 45 08             	mov    0x8(%ebp),%eax
   16d10:	8b 00                	mov    (%eax),%eax
   16d12:	85 c0                	test   %eax,%eax
   16d14:	75 0f                	jne    16d25 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   16d16:	8b 45 14             	mov    0x14(%ebp),%eax
   16d19:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   16d20:	00 00 00 
   16d23:	eb 3c                	jmp    16d61 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   16d25:	8b 45 10             	mov    0x10(%ebp),%eax
   16d28:	8b 08                	mov    (%eax),%ecx
   16d2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   16d2d:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   16d2f:	8b 45 14             	mov    0x14(%ebp),%eax
   16d32:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   16d38:	8b 45 14             	mov    0x14(%ebp),%eax
   16d3b:	8d 58 78             	lea    0x78(%eax),%ebx
   16d3e:	8b 45 08             	mov    0x8(%ebp),%eax
   16d41:	8b 00                	mov    (%eax),%eax
   16d43:	83 ec 08             	sub    $0x8,%esp
   16d46:	51                   	push   %ecx
   16d47:	52                   	push   %edx
   16d48:	56                   	push   %esi
   16d49:	53                   	push   %ebx
   16d4a:	ff 75 f4             	pushl  -0xc(%ebp)
   16d4d:	50                   	push   %eax
   16d4e:	e8 51 b6 ff ff       	call   123a4 <lodepng_convert>
   16d53:	83 c4 20             	add    $0x20,%esp
   16d56:	89 c2                	mov    %eax,%edx
   16d58:	8b 45 14             	mov    0x14(%ebp),%eax
   16d5b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   16d61:	83 ec 0c             	sub    $0xc,%esp
   16d64:	ff 75 f4             	pushl  -0xc(%ebp)
   16d67:	e8 52 2f ff ff       	call   9cbe <lodepng_free>
   16d6c:	83 c4 10             	add    $0x10,%esp
   16d6f:	eb 01                	jmp    16d72 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   16d71:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   16d72:	8b 45 14             	mov    0x14(%ebp),%eax
   16d75:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   16d7b:	8d 65 f8             	lea    -0x8(%ebp),%esp
   16d7e:	5b                   	pop    %ebx
   16d7f:	5e                   	pop    %esi
   16d80:	5d                   	pop    %ebp
   16d81:	c3                   	ret    

00016d82 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   16d82:	55                   	push   %ebp
   16d83:	89 e5                	mov    %esp,%ebp
   16d85:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   16d8b:	83 ec 0c             	sub    $0xc,%esp
   16d8e:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   16d94:	50                   	push   %eax
   16d95:	e8 d9 01 00 00       	call   16f73 <lodepng_state_init>
   16d9a:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   16d9d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16da0:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   16da6:	8b 45 20             	mov    0x20(%ebp),%eax
   16da9:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   16daf:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   16db6:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   16db9:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   16dc0:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   16dc3:	83 ec 08             	sub    $0x8,%esp
   16dc6:	ff 75 18             	pushl  0x18(%ebp)
   16dc9:	ff 75 14             	pushl  0x14(%ebp)
   16dcc:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   16dd2:	50                   	push   %eax
   16dd3:	ff 75 10             	pushl  0x10(%ebp)
   16dd6:	ff 75 0c             	pushl  0xc(%ebp)
   16dd9:	ff 75 08             	pushl  0x8(%ebp)
   16ddc:	e8 fc fd ff ff       	call   16bdd <lodepng_decode>
   16de1:	83 c4 20             	add    $0x20,%esp
   16de4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   16de7:	83 ec 0c             	sub    $0xc,%esp
   16dea:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   16df0:	50                   	push   %eax
   16df1:	e8 d7 01 00 00       	call   16fcd <lodepng_state_cleanup>
   16df6:	83 c4 10             	add    $0x10,%esp
  return error;
   16df9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   16dfc:	c9                   	leave  
   16dfd:	c3                   	ret    

00016dfe <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   16dfe:	55                   	push   %ebp
   16dff:	89 e5                	mov    %esp,%ebp
   16e01:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   16e04:	83 ec 04             	sub    $0x4,%esp
   16e07:	6a 08                	push   $0x8
   16e09:	6a 06                	push   $0x6
   16e0b:	ff 75 18             	pushl  0x18(%ebp)
   16e0e:	ff 75 14             	pushl  0x14(%ebp)
   16e11:	ff 75 10             	pushl  0x10(%ebp)
   16e14:	ff 75 0c             	pushl  0xc(%ebp)
   16e17:	ff 75 08             	pushl  0x8(%ebp)
   16e1a:	e8 63 ff ff ff       	call   16d82 <lodepng_decode_memory>
   16e1f:	83 c4 20             	add    $0x20,%esp
}
   16e22:	c9                   	leave  
   16e23:	c3                   	ret    

00016e24 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   16e24:	55                   	push   %ebp
   16e25:	89 e5                	mov    %esp,%ebp
   16e27:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   16e2a:	83 ec 04             	sub    $0x4,%esp
   16e2d:	6a 08                	push   $0x8
   16e2f:	6a 02                	push   $0x2
   16e31:	ff 75 18             	pushl  0x18(%ebp)
   16e34:	ff 75 14             	pushl  0x14(%ebp)
   16e37:	ff 75 10             	pushl  0x10(%ebp)
   16e3a:	ff 75 0c             	pushl  0xc(%ebp)
   16e3d:	ff 75 08             	pushl  0x8(%ebp)
   16e40:	e8 3d ff ff ff       	call   16d82 <lodepng_decode_memory>
   16e45:	83 c4 20             	add    $0x20,%esp
}
   16e48:	c9                   	leave  
   16e49:	c3                   	ret    

00016e4a <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   16e4a:	55                   	push   %ebp
   16e4b:	89 e5                	mov    %esp,%ebp
   16e4d:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   16e50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   16e57:	8b 45 08             	mov    0x8(%ebp),%eax
   16e5a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   16e60:	8b 45 10             	mov    0x10(%ebp),%eax
   16e63:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   16e69:	8b 45 10             	mov    0x10(%ebp),%eax
   16e6c:	8b 10                	mov    (%eax),%edx
   16e6e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16e71:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   16e73:	83 ec 04             	sub    $0x4,%esp
   16e76:	ff 75 14             	pushl  0x14(%ebp)
   16e79:	8d 45 ec             	lea    -0x14(%ebp),%eax
   16e7c:	50                   	push   %eax
   16e7d:	8d 45 f0             	lea    -0x10(%ebp),%eax
   16e80:	50                   	push   %eax
   16e81:	e8 70 32 ff ff       	call   a0f6 <lodepng_load_file>
   16e86:	83 c4 10             	add    $0x10,%esp
   16e89:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   16e8c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16e90:	75 25                	jne    16eb7 <lodepng_decode_file+0x6d>
   16e92:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16e95:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16e98:	83 ec 04             	sub    $0x4,%esp
   16e9b:	ff 75 1c             	pushl  0x1c(%ebp)
   16e9e:	ff 75 18             	pushl  0x18(%ebp)
   16ea1:	52                   	push   %edx
   16ea2:	50                   	push   %eax
   16ea3:	ff 75 10             	pushl  0x10(%ebp)
   16ea6:	ff 75 0c             	pushl  0xc(%ebp)
   16ea9:	ff 75 08             	pushl  0x8(%ebp)
   16eac:	e8 d1 fe ff ff       	call   16d82 <lodepng_decode_memory>
   16eb1:	83 c4 20             	add    $0x20,%esp
   16eb4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   16eb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16eba:	83 ec 0c             	sub    $0xc,%esp
   16ebd:	50                   	push   %eax
   16ebe:	e8 fb 2d ff ff       	call   9cbe <lodepng_free>
   16ec3:	83 c4 10             	add    $0x10,%esp
  return error;
   16ec6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   16ec9:	c9                   	leave  
   16eca:	c3                   	ret    

00016ecb <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   16ecb:	55                   	push   %ebp
   16ecc:	89 e5                	mov    %esp,%ebp
   16ece:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   16ed1:	83 ec 08             	sub    $0x8,%esp
   16ed4:	6a 08                	push   $0x8
   16ed6:	6a 06                	push   $0x6
   16ed8:	ff 75 14             	pushl  0x14(%ebp)
   16edb:	ff 75 10             	pushl  0x10(%ebp)
   16ede:	ff 75 0c             	pushl  0xc(%ebp)
   16ee1:	ff 75 08             	pushl  0x8(%ebp)
   16ee4:	e8 61 ff ff ff       	call   16e4a <lodepng_decode_file>
   16ee9:	83 c4 20             	add    $0x20,%esp
}
   16eec:	c9                   	leave  
   16eed:	c3                   	ret    

00016eee <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   16eee:	55                   	push   %ebp
   16eef:	89 e5                	mov    %esp,%ebp
   16ef1:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   16ef4:	83 ec 08             	sub    $0x8,%esp
   16ef7:	6a 08                	push   $0x8
   16ef9:	6a 02                	push   $0x2
   16efb:	ff 75 14             	pushl  0x14(%ebp)
   16efe:	ff 75 10             	pushl  0x10(%ebp)
   16f01:	ff 75 0c             	pushl  0xc(%ebp)
   16f04:	ff 75 08             	pushl  0x8(%ebp)
   16f07:	e8 3e ff ff ff       	call   16e4a <lodepng_decode_file>
   16f0c:	83 c4 20             	add    $0x20,%esp
}
   16f0f:	c9                   	leave  
   16f10:	c3                   	ret    

00016f11 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   16f11:	55                   	push   %ebp
   16f12:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   16f14:	8b 45 08             	mov    0x8(%ebp),%eax
   16f17:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   16f1e:	8b 45 08             	mov    0x8(%ebp),%eax
   16f21:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   16f28:	8b 45 08             	mov    0x8(%ebp),%eax
   16f2b:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   16f32:	8b 45 08             	mov    0x8(%ebp),%eax
   16f35:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   16f3c:	8b 45 08             	mov    0x8(%ebp),%eax
   16f3f:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   16f46:	8b 45 08             	mov    0x8(%ebp),%eax
   16f49:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   16f50:	8b 45 08             	mov    0x8(%ebp),%eax
   16f53:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   16f5a:	8b 45 08             	mov    0x8(%ebp),%eax
   16f5d:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   16f64:	8b 45 08             	mov    0x8(%ebp),%eax
   16f67:	50                   	push   %eax
   16f68:	e8 ff 7a ff ff       	call   ea6c <lodepng_decompress_settings_init>
   16f6d:	83 c4 04             	add    $0x4,%esp
}
   16f70:	90                   	nop
   16f71:	c9                   	leave  
   16f72:	c3                   	ret    

00016f73 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   16f73:	55                   	push   %ebp
   16f74:	89 e5                	mov    %esp,%ebp
   16f76:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   16f79:	8b 45 08             	mov    0x8(%ebp),%eax
   16f7c:	50                   	push   %eax
   16f7d:	e8 8f ff ff ff       	call   16f11 <lodepng_decoder_settings_init>
   16f82:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   16f85:	8b 45 08             	mov    0x8(%ebp),%eax
   16f88:	83 c0 38             	add    $0x38,%eax
   16f8b:	83 ec 0c             	sub    $0xc,%esp
   16f8e:	50                   	push   %eax
   16f8f:	e8 fc 30 00 00       	call   1a090 <lodepng_encoder_settings_init>
   16f94:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   16f97:	8b 45 08             	mov    0x8(%ebp),%eax
   16f9a:	83 c0 78             	add    $0x78,%eax
   16f9d:	83 ec 0c             	sub    $0xc,%esp
   16fa0:	50                   	push   %eax
   16fa1:	e8 06 84 ff ff       	call   f3ac <lodepng_color_mode_init>
   16fa6:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   16fa9:	8b 45 08             	mov    0x8(%ebp),%eax
   16fac:	05 98 00 00 00       	add    $0x98,%eax
   16fb1:	83 ec 0c             	sub    $0xc,%esp
   16fb4:	50                   	push   %eax
   16fb5:	e8 89 93 ff ff       	call   10343 <lodepng_info_init>
   16fba:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   16fbd:	8b 45 08             	mov    0x8(%ebp),%eax
   16fc0:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   16fc7:	00 00 00 
}
   16fca:	90                   	nop
   16fcb:	c9                   	leave  
   16fcc:	c3                   	ret    

00016fcd <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   16fcd:	55                   	push   %ebp
   16fce:	89 e5                	mov    %esp,%ebp
   16fd0:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   16fd3:	8b 45 08             	mov    0x8(%ebp),%eax
   16fd6:	83 c0 78             	add    $0x78,%eax
   16fd9:	83 ec 0c             	sub    $0xc,%esp
   16fdc:	50                   	push   %eax
   16fdd:	e8 bd 84 ff ff       	call   f49f <lodepng_color_mode_cleanup>
   16fe2:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   16fe5:	8b 45 08             	mov    0x8(%ebp),%eax
   16fe8:	05 98 00 00 00       	add    $0x98,%eax
   16fed:	83 ec 0c             	sub    $0xc,%esp
   16ff0:	50                   	push   %eax
   16ff1:	e8 2e 94 ff ff       	call   10424 <lodepng_info_cleanup>
   16ff6:	83 c4 10             	add    $0x10,%esp
}
   16ff9:	90                   	nop
   16ffa:	c9                   	leave  
   16ffb:	c3                   	ret    

00016ffc <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   16ffc:	55                   	push   %ebp
   16ffd:	89 e5                	mov    %esp,%ebp
   16fff:	57                   	push   %edi
   17000:	56                   	push   %esi
   17001:	53                   	push   %ebx
   17002:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   17005:	83 ec 0c             	sub    $0xc,%esp
   17008:	ff 75 08             	pushl  0x8(%ebp)
   1700b:	e8 bd ff ff ff       	call   16fcd <lodepng_state_cleanup>
   17010:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   17013:	8b 55 08             	mov    0x8(%ebp),%edx
   17016:	8b 45 0c             	mov    0xc(%ebp),%eax
   17019:	89 c3                	mov    %eax,%ebx
   1701b:	b8 60 00 00 00       	mov    $0x60,%eax
   17020:	89 d7                	mov    %edx,%edi
   17022:	89 de                	mov    %ebx,%esi
   17024:	89 c1                	mov    %eax,%ecx
   17026:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   17028:	8b 45 08             	mov    0x8(%ebp),%eax
   1702b:	83 c0 78             	add    $0x78,%eax
   1702e:	83 ec 0c             	sub    $0xc,%esp
   17031:	50                   	push   %eax
   17032:	e8 75 83 ff ff       	call   f3ac <lodepng_color_mode_init>
   17037:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   1703a:	8b 45 08             	mov    0x8(%ebp),%eax
   1703d:	05 98 00 00 00       	add    $0x98,%eax
   17042:	83 ec 0c             	sub    $0xc,%esp
   17045:	50                   	push   %eax
   17046:	e8 f8 92 ff ff       	call   10343 <lodepng_info_init>
   1704b:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   1704e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17051:	8d 50 78             	lea    0x78(%eax),%edx
   17054:	8b 45 08             	mov    0x8(%ebp),%eax
   17057:	83 c0 78             	add    $0x78,%eax
   1705a:	83 ec 08             	sub    $0x8,%esp
   1705d:	52                   	push   %edx
   1705e:	50                   	push   %eax
   1705f:	e8 52 84 ff ff       	call   f4b6 <lodepng_color_mode_copy>
   17064:	83 c4 10             	add    $0x10,%esp
   17067:	89 c2                	mov    %eax,%edx
   17069:	8b 45 08             	mov    0x8(%ebp),%eax
   1706c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   17072:	8b 45 08             	mov    0x8(%ebp),%eax
   17075:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1707b:	85 c0                	test   %eax,%eax
   1707d:	75 36                	jne    170b5 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   1707f:	8b 45 0c             	mov    0xc(%ebp),%eax
   17082:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   17088:	8b 45 08             	mov    0x8(%ebp),%eax
   1708b:	05 98 00 00 00       	add    $0x98,%eax
   17090:	83 ec 08             	sub    $0x8,%esp
   17093:	52                   	push   %edx
   17094:	50                   	push   %eax
   17095:	e8 dd 93 ff ff       	call   10477 <lodepng_info_copy>
   1709a:	83 c4 10             	add    $0x10,%esp
   1709d:	89 c2                	mov    %eax,%edx
   1709f:	8b 45 08             	mov    0x8(%ebp),%eax
   170a2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   170a8:	8b 45 08             	mov    0x8(%ebp),%eax
   170ab:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   170b1:	85 c0                	test   %eax,%eax
   170b3:	eb 01                	jmp    170b6 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   170b5:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   170b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
   170b9:	5b                   	pop    %ebx
   170ba:	5e                   	pop    %esi
   170bb:	5f                   	pop    %edi
   170bc:	5d                   	pop    %ebp
   170bd:	c3                   	ret    

000170be <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   170be:	55                   	push   %ebp
   170bf:	89 e5                	mov    %esp,%ebp
   170c1:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   170c4:	8b 45 08             	mov    0x8(%ebp),%eax
   170c7:	8b 40 04             	mov    0x4(%eax),%eax
   170ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   170cd:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   170d1:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   170d5:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   170d9:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   170dd:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   170e1:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   170e5:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   170e9:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   170ed:	8b 45 08             	mov    0x8(%ebp),%eax
   170f0:	8b 40 04             	mov    0x4(%eax),%eax
   170f3:	83 c0 08             	add    $0x8,%eax
   170f6:	50                   	push   %eax
   170f7:	ff 75 08             	pushl  0x8(%ebp)
   170fa:	e8 f8 2d ff ff       	call   9ef7 <ucvector_resize>
   170ff:	83 c4 08             	add    $0x8,%esp
   17102:	85 c0                	test   %eax,%eax
   17104:	75 07                	jne    1710d <writeSignature+0x4f>
   17106:	b8 53 00 00 00       	mov    $0x53,%eax
   1710b:	eb 1e                	jmp    1712b <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   1710d:	8b 45 08             	mov    0x8(%ebp),%eax
   17110:	8b 10                	mov    (%eax),%edx
   17112:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17115:	01 c2                	add    %eax,%edx
   17117:	6a 08                	push   $0x8
   17119:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1711c:	50                   	push   %eax
   1711d:	52                   	push   %edx
   1711e:	e8 b8 2b ff ff       	call   9cdb <lodepng_memcpy>
   17123:	83 c4 0c             	add    $0xc,%esp
  return 0;
   17126:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1712b:	c9                   	leave  
   1712c:	c3                   	ret    

0001712d <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   1712d:	55                   	push   %ebp
   1712e:	89 e5                	mov    %esp,%ebp
   17130:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   17133:	68 4c 0b 02 00       	push   $0x20b4c
   17138:	6a 0d                	push   $0xd
   1713a:	ff 75 08             	pushl  0x8(%ebp)
   1713d:	8d 45 f4             	lea    -0xc(%ebp),%eax
   17140:	50                   	push   %eax
   17141:	e8 cf 7f ff ff       	call   f115 <lodepng_chunk_init>
   17146:	83 c4 10             	add    $0x10,%esp
   17149:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1714c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   17150:	74 05                	je     17157 <addChunk_IHDR+0x2a>
   17152:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17155:	eb 6d                	jmp    171c4 <addChunk_IHDR+0x97>
  data = chunk + 8;
   17157:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1715a:	83 c0 08             	add    $0x8,%eax
   1715d:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   17160:	ff 75 0c             	pushl  0xc(%ebp)
   17163:	ff 75 f8             	pushl  -0x8(%ebp)
   17166:	e8 f3 2e ff ff       	call   a05e <lodepng_set32bitInt>
   1716b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   1716e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17171:	83 c0 04             	add    $0x4,%eax
   17174:	ff 75 10             	pushl  0x10(%ebp)
   17177:	50                   	push   %eax
   17178:	e8 e1 2e ff ff       	call   a05e <lodepng_set32bitInt>
   1717d:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   17180:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17183:	83 c0 08             	add    $0x8,%eax
   17186:	8b 55 18             	mov    0x18(%ebp),%edx
   17189:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   1718b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1718e:	83 c0 09             	add    $0x9,%eax
   17191:	8b 55 14             	mov    0x14(%ebp),%edx
   17194:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   17196:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17199:	83 c0 0a             	add    $0xa,%eax
   1719c:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   1719f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   171a2:	83 c0 0b             	add    $0xb,%eax
   171a5:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   171a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   171ab:	83 c0 0c             	add    $0xc,%eax
   171ae:	8b 55 1c             	mov    0x1c(%ebp),%edx
   171b1:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   171b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   171b6:	50                   	push   %eax
   171b7:	e8 02 7c ff ff       	call   edbe <lodepng_chunk_generate_crc>
   171bc:	83 c4 04             	add    $0x4,%esp
  return 0;
   171bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
   171c4:	c9                   	leave  
   171c5:	c3                   	ret    

000171c6 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   171c6:	55                   	push   %ebp
   171c7:	89 e5                	mov    %esp,%ebp
   171c9:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   171cc:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   171d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   171d6:	8b 50 0c             	mov    0xc(%eax),%edx
   171d9:	89 d0                	mov    %edx,%eax
   171db:	01 c0                	add    %eax,%eax
   171dd:	01 d0                	add    %edx,%eax
   171df:	68 68 0b 02 00       	push   $0x20b68
   171e4:	50                   	push   %eax
   171e5:	ff 75 08             	pushl  0x8(%ebp)
   171e8:	8d 45 f0             	lea    -0x10(%ebp),%eax
   171eb:	50                   	push   %eax
   171ec:	e8 24 7f ff ff       	call   f115 <lodepng_chunk_init>
   171f1:	83 c4 10             	add    $0x10,%esp
   171f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
   171f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   171fb:	74 08                	je     17205 <addChunk_PLTE+0x3f>
   171fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17200:	e9 95 00 00 00       	jmp    1729a <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   17205:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1720c:	eb 70                	jmp    1727e <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   1720e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   17211:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17214:	8d 50 01             	lea    0x1(%eax),%edx
   17217:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1721a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1721d:	8b 45 0c             	mov    0xc(%ebp),%eax
   17220:	8b 40 08             	mov    0x8(%eax),%eax
   17223:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   17226:	c1 e1 02             	shl    $0x2,%ecx
   17229:	01 c8                	add    %ecx,%eax
   1722b:	0f b6 00             	movzbl (%eax),%eax
   1722e:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   17230:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   17233:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17236:	8d 50 01             	lea    0x1(%eax),%edx
   17239:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1723c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1723f:	8b 45 0c             	mov    0xc(%ebp),%eax
   17242:	8b 40 08             	mov    0x8(%eax),%eax
   17245:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   17248:	c1 e1 02             	shl    $0x2,%ecx
   1724b:	83 c1 01             	add    $0x1,%ecx
   1724e:	01 c8                	add    %ecx,%eax
   17250:	0f b6 00             	movzbl (%eax),%eax
   17253:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   17255:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   17258:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1725b:	8d 50 01             	lea    0x1(%eax),%edx
   1725e:	89 55 f8             	mov    %edx,-0x8(%ebp)
   17261:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   17264:	8b 45 0c             	mov    0xc(%ebp),%eax
   17267:	8b 40 08             	mov    0x8(%eax),%eax
   1726a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   1726d:	c1 e1 02             	shl    $0x2,%ecx
   17270:	83 c1 02             	add    $0x2,%ecx
   17273:	01 c8                	add    %ecx,%eax
   17275:	0f b6 00             	movzbl (%eax),%eax
   17278:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   1727a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1727e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17281:	8b 40 0c             	mov    0xc(%eax),%eax
   17284:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   17287:	75 85                	jne    1720e <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   17289:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1728c:	50                   	push   %eax
   1728d:	e8 2c 7b ff ff       	call   edbe <lodepng_chunk_generate_crc>
   17292:	83 c4 04             	add    $0x4,%esp
  return 0;
   17295:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1729a:	c9                   	leave  
   1729b:	c3                   	ret    

0001729c <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   1729c:	55                   	push   %ebp
   1729d:	89 e5                	mov    %esp,%ebp
   1729f:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   172a2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   172a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   172ac:	8b 00                	mov    (%eax),%eax
   172ae:	83 f8 03             	cmp    $0x3,%eax
   172b1:	0f 85 ae 00 00 00    	jne    17365 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   172b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   172ba:	8b 40 0c             	mov    0xc(%eax),%eax
   172bd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   172c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   172c3:	8b 40 0c             	mov    0xc(%eax),%eax
   172c6:	89 45 fc             	mov    %eax,-0x4(%ebp)
   172c9:	eb 23                	jmp    172ee <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   172cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   172ce:	8b 40 08             	mov    0x8(%eax),%eax
   172d1:	8b 55 fc             	mov    -0x4(%ebp),%edx
   172d4:	83 ea 01             	sub    $0x1,%edx
   172d7:	c1 e2 02             	shl    $0x2,%edx
   172da:	83 c2 03             	add    $0x3,%edx
   172dd:	01 d0                	add    %edx,%eax
   172df:	0f b6 00             	movzbl (%eax),%eax
   172e2:	3c ff                	cmp    $0xff,%al
   172e4:	75 10                	jne    172f6 <addChunk_tRNS+0x5a>
      --amount;
   172e6:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   172ea:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   172ee:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   172f2:	75 d7                	jne    172cb <addChunk_tRNS+0x2f>
   172f4:	eb 01                	jmp    172f7 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   172f6:	90                   	nop
      --amount;
    }
    if(amount) {
   172f7:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   172fb:	0f 84 63 01 00 00    	je     17464 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   17301:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17304:	68 6d 0b 02 00       	push   $0x20b6d
   17309:	50                   	push   %eax
   1730a:	ff 75 08             	pushl  0x8(%ebp)
   1730d:	8d 45 e8             	lea    -0x18(%ebp),%eax
   17310:	50                   	push   %eax
   17311:	e8 ff 7d ff ff       	call   f115 <lodepng_chunk_init>
   17316:	83 c4 10             	add    $0x10,%esp
   17319:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1731c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17320:	74 08                	je     1732a <addChunk_tRNS+0x8e>
   17322:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17325:	e9 52 01 00 00       	jmp    1747c <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   1732a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   17331:	eb 25                	jmp    17358 <addChunk_tRNS+0xbc>
   17333:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17336:	8b 55 fc             	mov    -0x4(%ebp),%edx
   17339:	83 c2 08             	add    $0x8,%edx
   1733c:	01 c2                	add    %eax,%edx
   1733e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17341:	8b 40 08             	mov    0x8(%eax),%eax
   17344:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   17347:	c1 e1 02             	shl    $0x2,%ecx
   1734a:	83 c1 03             	add    $0x3,%ecx
   1734d:	01 c8                	add    %ecx,%eax
   1734f:	0f b6 00             	movzbl (%eax),%eax
   17352:	88 02                	mov    %al,(%edx)
   17354:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   17358:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1735b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1735e:	75 d3                	jne    17333 <addChunk_tRNS+0x97>
   17360:	e9 ff 00 00 00       	jmp    17464 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   17365:	8b 45 0c             	mov    0xc(%ebp),%eax
   17368:	8b 00                	mov    (%eax),%eax
   1736a:	85 c0                	test   %eax,%eax
   1736c:	75 59                	jne    173c7 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   1736e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17371:	8b 40 10             	mov    0x10(%eax),%eax
   17374:	85 c0                	test   %eax,%eax
   17376:	0f 84 e8 00 00 00    	je     17464 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   1737c:	68 6d 0b 02 00       	push   $0x20b6d
   17381:	6a 02                	push   $0x2
   17383:	ff 75 08             	pushl  0x8(%ebp)
   17386:	8d 45 e8             	lea    -0x18(%ebp),%eax
   17389:	50                   	push   %eax
   1738a:	e8 86 7d ff ff       	call   f115 <lodepng_chunk_init>
   1738f:	83 c4 10             	add    $0x10,%esp
   17392:	89 45 f0             	mov    %eax,-0x10(%ebp)
   17395:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   17399:	74 08                	je     173a3 <addChunk_tRNS+0x107>
   1739b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1739e:	e9 d9 00 00 00       	jmp    1747c <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   173a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   173a6:	8d 50 08             	lea    0x8(%eax),%edx
   173a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   173ac:	8b 40 14             	mov    0x14(%eax),%eax
   173af:	c1 e8 08             	shr    $0x8,%eax
   173b2:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   173b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   173b7:	8d 50 09             	lea    0x9(%eax),%edx
   173ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   173bd:	8b 40 14             	mov    0x14(%eax),%eax
   173c0:	88 02                	mov    %al,(%edx)
   173c2:	e9 9d 00 00 00       	jmp    17464 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   173c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   173ca:	8b 00                	mov    (%eax),%eax
   173cc:	83 f8 02             	cmp    $0x2,%eax
   173cf:	0f 85 8f 00 00 00    	jne    17464 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   173d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   173d8:	8b 40 10             	mov    0x10(%eax),%eax
   173db:	85 c0                	test   %eax,%eax
   173dd:	0f 84 81 00 00 00    	je     17464 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   173e3:	68 6d 0b 02 00       	push   $0x20b6d
   173e8:	6a 06                	push   $0x6
   173ea:	ff 75 08             	pushl  0x8(%ebp)
   173ed:	8d 45 e8             	lea    -0x18(%ebp),%eax
   173f0:	50                   	push   %eax
   173f1:	e8 1f 7d ff ff       	call   f115 <lodepng_chunk_init>
   173f6:	83 c4 10             	add    $0x10,%esp
   173f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
   173fc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   17400:	74 05                	je     17407 <addChunk_tRNS+0x16b>
   17402:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17405:	eb 75                	jmp    1747c <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   17407:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1740a:	8d 50 08             	lea    0x8(%eax),%edx
   1740d:	8b 45 0c             	mov    0xc(%ebp),%eax
   17410:	8b 40 14             	mov    0x14(%eax),%eax
   17413:	c1 e8 08             	shr    $0x8,%eax
   17416:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   17418:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1741b:	8d 50 09             	lea    0x9(%eax),%edx
   1741e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17421:	8b 40 14             	mov    0x14(%eax),%eax
   17424:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   17426:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17429:	8d 50 0a             	lea    0xa(%eax),%edx
   1742c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1742f:	8b 40 18             	mov    0x18(%eax),%eax
   17432:	c1 e8 08             	shr    $0x8,%eax
   17435:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   17437:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1743a:	8d 50 0b             	lea    0xb(%eax),%edx
   1743d:	8b 45 0c             	mov    0xc(%ebp),%eax
   17440:	8b 40 18             	mov    0x18(%eax),%eax
   17443:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   17445:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17448:	8d 50 0c             	lea    0xc(%eax),%edx
   1744b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1744e:	8b 40 1c             	mov    0x1c(%eax),%eax
   17451:	c1 e8 08             	shr    $0x8,%eax
   17454:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   17456:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17459:	8d 50 0d             	lea    0xd(%eax),%edx
   1745c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1745f:	8b 40 1c             	mov    0x1c(%eax),%eax
   17462:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   17464:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17467:	85 c0                	test   %eax,%eax
   17469:	74 0c                	je     17477 <addChunk_tRNS+0x1db>
   1746b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1746e:	50                   	push   %eax
   1746f:	e8 4a 79 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   17474:	83 c4 04             	add    $0x4,%esp
  return 0;
   17477:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1747c:	c9                   	leave  
   1747d:	c3                   	ret    

0001747e <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   1747e:	55                   	push   %ebp
   1747f:	89 e5                	mov    %esp,%ebp
   17481:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   17484:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   1748b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   17492:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   17499:	83 ec 0c             	sub    $0xc,%esp
   1749c:	ff 75 14             	pushl  0x14(%ebp)
   1749f:	ff 75 10             	pushl  0x10(%ebp)
   174a2:	ff 75 0c             	pushl  0xc(%ebp)
   174a5:	8d 45 ec             	lea    -0x14(%ebp),%eax
   174a8:	50                   	push   %eax
   174a9:	8d 45 f0             	lea    -0x10(%ebp),%eax
   174ac:	50                   	push   %eax
   174ad:	e8 fb 74 ff ff       	call   e9ad <zlib_compress>
   174b2:	83 c4 20             	add    $0x20,%esp
   174b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   174b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   174bc:	75 1b                	jne    174d9 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   174be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   174c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   174c4:	50                   	push   %eax
   174c5:	68 a4 0b 02 00       	push   $0x20ba4
   174ca:	52                   	push   %edx
   174cb:	ff 75 08             	pushl  0x8(%ebp)
   174ce:	e8 ea 7c ff ff       	call   f1bd <lodepng_chunk_createv>
   174d3:	83 c4 10             	add    $0x10,%esp
   174d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   174d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   174dc:	83 ec 0c             	sub    $0xc,%esp
   174df:	50                   	push   %eax
   174e0:	e8 d9 27 ff ff       	call   9cbe <lodepng_free>
   174e5:	83 c4 10             	add    $0x10,%esp
  return error;
   174e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   174eb:	c9                   	leave  
   174ec:	c3                   	ret    

000174ed <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   174ed:	55                   	push   %ebp
   174ee:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   174f0:	6a 00                	push   $0x0
   174f2:	68 a9 0b 02 00       	push   $0x20ba9
   174f7:	6a 00                	push   $0x0
   174f9:	ff 75 08             	pushl  0x8(%ebp)
   174fc:	e8 bc 7c ff ff       	call   f1bd <lodepng_chunk_createv>
   17501:	83 c4 10             	add    $0x10,%esp
}
   17504:	c9                   	leave  
   17505:	c3                   	ret    

00017506 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   17506:	55                   	push   %ebp
   17507:	89 e5                	mov    %esp,%ebp
   17509:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   1750c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   17513:	ff 75 0c             	pushl  0xc(%ebp)
   17516:	e8 1e 28 ff ff       	call   9d39 <lodepng_strlen>
   1751b:	83 c4 04             	add    $0x4,%esp
   1751e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17521:	ff 75 10             	pushl  0x10(%ebp)
   17524:	e8 10 28 ff ff       	call   9d39 <lodepng_strlen>
   17529:	83 c4 04             	add    $0x4,%esp
   1752c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   1752f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17532:	8d 50 01             	lea    0x1(%eax),%edx
   17535:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17538:	01 d0                	add    %edx,%eax
   1753a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1753d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   17541:	7e 06                	jle    17549 <addChunk_tEXt+0x43>
   17543:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   17547:	7e 07                	jle    17550 <addChunk_tEXt+0x4a>
   17549:	b8 59 00 00 00       	mov    $0x59,%eax
   1754e:	eb 74                	jmp    175c4 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   17550:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17553:	68 77 0b 02 00       	push   $0x20b77
   17558:	50                   	push   %eax
   17559:	ff 75 08             	pushl  0x8(%ebp)
   1755c:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1755f:	50                   	push   %eax
   17560:	e8 b0 7b ff ff       	call   f115 <lodepng_chunk_init>
   17565:	83 c4 10             	add    $0x10,%esp
   17568:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1756b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1756f:	74 05                	je     17576 <addChunk_tEXt+0x70>
   17571:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17574:	eb 4e                	jmp    175c4 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   17576:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17579:	83 c0 08             	add    $0x8,%eax
   1757c:	ff 75 fc             	pushl  -0x4(%ebp)
   1757f:	ff 75 0c             	pushl  0xc(%ebp)
   17582:	50                   	push   %eax
   17583:	e8 53 27 ff ff       	call   9cdb <lodepng_memcpy>
   17588:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   1758b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1758e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   17591:	83 c2 08             	add    $0x8,%edx
   17594:	01 d0                	add    %edx,%eax
   17596:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   17599:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1759c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1759f:	83 c2 09             	add    $0x9,%edx
   175a2:	01 d0                	add    %edx,%eax
   175a4:	ff 75 f8             	pushl  -0x8(%ebp)
   175a7:	ff 75 10             	pushl  0x10(%ebp)
   175aa:	50                   	push   %eax
   175ab:	e8 2b 27 ff ff       	call   9cdb <lodepng_memcpy>
   175b0:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   175b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   175b6:	50                   	push   %eax
   175b7:	e8 02 78 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   175bc:	83 c4 04             	add    $0x4,%esp
  return 0;
   175bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
   175c4:	c9                   	leave  
   175c5:	c3                   	ret    

000175c6 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   175c6:	55                   	push   %ebp
   175c7:	89 e5                	mov    %esp,%ebp
   175c9:	53                   	push   %ebx
   175ca:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   175cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   175d4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   175db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   175e2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   175e9:	ff 75 10             	pushl  0x10(%ebp)
   175ec:	e8 48 27 ff ff       	call   9d39 <lodepng_strlen>
   175f1:	83 c4 04             	add    $0x4,%esp
   175f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   175f7:	ff 75 0c             	pushl  0xc(%ebp)
   175fa:	e8 3a 27 ff ff       	call   9d39 <lodepng_strlen>
   175ff:	83 c4 04             	add    $0x4,%esp
   17602:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   17605:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   17609:	7e 06                	jle    17611 <addChunk_zTXt+0x4b>
   1760b:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   1760f:	7e 0a                	jle    1761b <addChunk_zTXt+0x55>
   17611:	b8 59 00 00 00       	mov    $0x59,%eax
   17616:	e9 c8 00 00 00       	jmp    176e3 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   1761b:	83 ec 0c             	sub    $0xc,%esp
   1761e:	ff 75 14             	pushl  0x14(%ebp)
   17621:	ff 75 f0             	pushl  -0x10(%ebp)
   17624:	ff 75 10             	pushl  0x10(%ebp)
   17627:	8d 45 dc             	lea    -0x24(%ebp),%eax
   1762a:	50                   	push   %eax
   1762b:	8d 45 e0             	lea    -0x20(%ebp),%eax
   1762e:	50                   	push   %eax
   1762f:	e8 79 73 ff ff       	call   e9ad <zlib_compress>
   17634:	83 c4 20             	add    $0x20,%esp
   17637:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   1763a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1763e:	75 29                	jne    17669 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   17640:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17643:	8d 50 02             	lea    0x2(%eax),%edx
   17646:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17649:	01 d0                	add    %edx,%eax
   1764b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   1764e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17651:	68 7c 0b 02 00       	push   $0x20b7c
   17656:	50                   	push   %eax
   17657:	ff 75 08             	pushl  0x8(%ebp)
   1765a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   1765d:	50                   	push   %eax
   1765e:	e8 b2 7a ff ff       	call   f115 <lodepng_chunk_init>
   17663:	83 c4 10             	add    $0x10,%esp
   17666:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   17669:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1766d:	75 62                	jne    176d1 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   1766f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17672:	83 c0 08             	add    $0x8,%eax
   17675:	83 ec 04             	sub    $0x4,%esp
   17678:	ff 75 ec             	pushl  -0x14(%ebp)
   1767b:	ff 75 0c             	pushl  0xc(%ebp)
   1767e:	50                   	push   %eax
   1767f:	e8 57 26 ff ff       	call   9cdb <lodepng_memcpy>
   17684:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   17687:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1768a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1768d:	83 c2 08             	add    $0x8,%edx
   17690:	01 d0                	add    %edx,%eax
   17692:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   17695:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17698:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1769b:	83 c2 09             	add    $0x9,%edx
   1769e:	01 d0                	add    %edx,%eax
   176a0:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   176a3:	8b 55 dc             	mov    -0x24(%ebp),%edx
   176a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   176a9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   176ac:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   176af:	83 c3 0a             	add    $0xa,%ebx
   176b2:	01 d9                	add    %ebx,%ecx
   176b4:	83 ec 04             	sub    $0x4,%esp
   176b7:	52                   	push   %edx
   176b8:	50                   	push   %eax
   176b9:	51                   	push   %ecx
   176ba:	e8 1c 26 ff ff       	call   9cdb <lodepng_memcpy>
   176bf:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   176c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   176c5:	83 ec 0c             	sub    $0xc,%esp
   176c8:	50                   	push   %eax
   176c9:	e8 f0 76 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   176ce:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   176d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   176d4:	83 ec 0c             	sub    $0xc,%esp
   176d7:	50                   	push   %eax
   176d8:	e8 e1 25 ff ff       	call   9cbe <lodepng_free>
   176dd:	83 c4 10             	add    $0x10,%esp
  return error;
   176e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   176e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   176e6:	c9                   	leave  
   176e7:	c3                   	ret    

000176e8 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   176e8:	55                   	push   %ebp
   176e9:	89 e5                	mov    %esp,%ebp
   176eb:	53                   	push   %ebx
   176ec:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   176ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   176f6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   176fd:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   17704:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   1770b:	ff 75 1c             	pushl  0x1c(%ebp)
   1770e:	e8 26 26 ff ff       	call   9d39 <lodepng_strlen>
   17713:	83 c4 04             	add    $0x4,%esp
   17716:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   17719:	ff 75 10             	pushl  0x10(%ebp)
   1771c:	e8 18 26 ff ff       	call   9d39 <lodepng_strlen>
   17721:	83 c4 04             	add    $0x4,%esp
   17724:	89 45 ec             	mov    %eax,-0x14(%ebp)
   17727:	ff 75 14             	pushl  0x14(%ebp)
   1772a:	e8 0a 26 ff ff       	call   9d39 <lodepng_strlen>
   1772f:	83 c4 04             	add    $0x4,%esp
   17732:	89 45 e8             	mov    %eax,-0x18(%ebp)
   17735:	ff 75 18             	pushl  0x18(%ebp)
   17738:	e8 fc 25 ff ff       	call   9d39 <lodepng_strlen>
   1773d:	83 c4 04             	add    $0x4,%esp
   17740:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   17743:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   17747:	7e 06                	jle    1774f <addChunk_iTXt+0x67>
   17749:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   1774d:	7e 0a                	jle    17759 <addChunk_iTXt+0x71>
   1774f:	b8 59 00 00 00       	mov    $0x59,%eax
   17754:	e9 9a 01 00 00       	jmp    178f3 <addChunk_iTXt+0x20b>

  if(compress) {
   17759:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1775d:	74 1f                	je     1777e <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   1775f:	83 ec 0c             	sub    $0xc,%esp
   17762:	ff 75 20             	pushl  0x20(%ebp)
   17765:	ff 75 f0             	pushl  -0x10(%ebp)
   17768:	ff 75 1c             	pushl  0x1c(%ebp)
   1776b:	8d 45 d0             	lea    -0x30(%ebp),%eax
   1776e:	50                   	push   %eax
   1776f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   17772:	50                   	push   %eax
   17773:	e8 35 72 ff ff       	call   e9ad <zlib_compress>
   17778:	83 c4 20             	add    $0x20,%esp
   1777b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   1777e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17782:	75 44                	jne    177c8 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   17784:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17787:	8d 50 03             	lea    0x3(%eax),%edx
   1778a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1778d:	01 d0                	add    %edx,%eax
   1778f:	8d 50 01             	lea    0x1(%eax),%edx
   17792:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17795:	01 d0                	add    %edx,%eax
   17797:	8d 50 01             	lea    0x1(%eax),%edx
   1779a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1779e:	74 05                	je     177a5 <addChunk_iTXt+0xbd>
   177a0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   177a3:	eb 03                	jmp    177a8 <addChunk_iTXt+0xc0>
   177a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   177a8:	01 d0                	add    %edx,%eax
   177aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   177ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
   177b0:	68 81 0b 02 00       	push   $0x20b81
   177b5:	50                   	push   %eax
   177b6:	ff 75 08             	pushl  0x8(%ebp)
   177b9:	8d 45 d8             	lea    -0x28(%ebp),%eax
   177bc:	50                   	push   %eax
   177bd:	e8 53 79 ff ff       	call   f115 <lodepng_chunk_init>
   177c2:	83 c4 10             	add    $0x10,%esp
   177c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   177c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   177cc:	0f 85 0f 01 00 00    	jne    178e1 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   177d2:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   177d9:	8b 55 d8             	mov    -0x28(%ebp),%edx
   177dc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   177df:	01 d0                	add    %edx,%eax
   177e1:	83 ec 04             	sub    $0x4,%esp
   177e4:	ff 75 ec             	pushl  -0x14(%ebp)
   177e7:	ff 75 10             	pushl  0x10(%ebp)
   177ea:	50                   	push   %eax
   177eb:	e8 eb 24 ff ff       	call   9cdb <lodepng_memcpy>
   177f0:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   177f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   177f6:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   177f9:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   177fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   177ff:	8d 50 01             	lea    0x1(%eax),%edx
   17802:	89 55 dc             	mov    %edx,-0x24(%ebp)
   17805:	01 c8                	add    %ecx,%eax
   17807:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   1780a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1780d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17810:	8d 50 01             	lea    0x1(%eax),%edx
   17813:	89 55 dc             	mov    %edx,-0x24(%ebp)
   17816:	01 c8                	add    %ecx,%eax
   17818:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1781c:	0f 95 c2             	setne  %dl
   1781f:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   17821:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   17824:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17827:	8d 50 01             	lea    0x1(%eax),%edx
   1782a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1782d:	01 c8                	add    %ecx,%eax
   1782f:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   17832:	8b 55 d8             	mov    -0x28(%ebp),%edx
   17835:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17838:	01 d0                	add    %edx,%eax
   1783a:	83 ec 04             	sub    $0x4,%esp
   1783d:	ff 75 e8             	pushl  -0x18(%ebp)
   17840:	ff 75 14             	pushl  0x14(%ebp)
   17843:	50                   	push   %eax
   17844:	e8 92 24 ff ff       	call   9cdb <lodepng_memcpy>
   17849:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   1784c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1784f:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   17852:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   17855:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17858:	8d 50 01             	lea    0x1(%eax),%edx
   1785b:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1785e:	01 c8                	add    %ecx,%eax
   17860:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   17863:	8b 55 d8             	mov    -0x28(%ebp),%edx
   17866:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17869:	01 d0                	add    %edx,%eax
   1786b:	83 ec 04             	sub    $0x4,%esp
   1786e:	ff 75 e4             	pushl  -0x1c(%ebp)
   17871:	ff 75 18             	pushl  0x18(%ebp)
   17874:	50                   	push   %eax
   17875:	e8 61 24 ff ff       	call   9cdb <lodepng_memcpy>
   1787a:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   1787d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17880:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   17883:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   17886:	8b 45 dc             	mov    -0x24(%ebp),%eax
   17889:	8d 50 01             	lea    0x1(%eax),%edx
   1788c:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1788f:	01 c8                	add    %ecx,%eax
   17891:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   17894:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   17898:	74 1e                	je     178b8 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   1789a:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1789d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   178a0:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   178a3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   178a6:	01 d9                	add    %ebx,%ecx
   178a8:	83 ec 04             	sub    $0x4,%esp
   178ab:	52                   	push   %edx
   178ac:	50                   	push   %eax
   178ad:	51                   	push   %ecx
   178ae:	e8 28 24 ff ff       	call   9cdb <lodepng_memcpy>
   178b3:	83 c4 10             	add    $0x10,%esp
   178b6:	eb 1a                	jmp    178d2 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   178b8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   178bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   178be:	01 d0                	add    %edx,%eax
   178c0:	83 ec 04             	sub    $0x4,%esp
   178c3:	ff 75 f0             	pushl  -0x10(%ebp)
   178c6:	ff 75 1c             	pushl  0x1c(%ebp)
   178c9:	50                   	push   %eax
   178ca:	e8 0c 24 ff ff       	call   9cdb <lodepng_memcpy>
   178cf:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   178d2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   178d5:	83 ec 0c             	sub    $0xc,%esp
   178d8:	50                   	push   %eax
   178d9:	e8 e0 74 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   178de:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   178e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   178e4:	83 ec 0c             	sub    $0xc,%esp
   178e7:	50                   	push   %eax
   178e8:	e8 d1 23 ff ff       	call   9cbe <lodepng_free>
   178ed:	83 c4 10             	add    $0x10,%esp
  return error;
   178f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   178f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   178f6:	c9                   	leave  
   178f7:	c3                   	ret    

000178f8 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   178f8:	55                   	push   %ebp
   178f9:	89 e5                	mov    %esp,%ebp
   178fb:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   178fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   17905:	8b 45 0c             	mov    0xc(%ebp),%eax
   17908:	8b 40 0c             	mov    0xc(%eax),%eax
   1790b:	85 c0                	test   %eax,%eax
   1790d:	74 0b                	je     1791a <addChunk_bKGD+0x22>
   1790f:	8b 45 0c             	mov    0xc(%ebp),%eax
   17912:	8b 40 0c             	mov    0xc(%eax),%eax
   17915:	83 f8 04             	cmp    $0x4,%eax
   17918:	75 4b                	jne    17965 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   1791a:	68 72 0b 02 00       	push   $0x20b72
   1791f:	6a 02                	push   $0x2
   17921:	ff 75 08             	pushl  0x8(%ebp)
   17924:	8d 45 f0             	lea    -0x10(%ebp),%eax
   17927:	50                   	push   %eax
   17928:	e8 e8 77 ff ff       	call   f115 <lodepng_chunk_init>
   1792d:	83 c4 10             	add    $0x10,%esp
   17930:	89 45 f4             	mov    %eax,-0xc(%ebp)
   17933:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17937:	74 08                	je     17941 <addChunk_bKGD+0x49>
   17939:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1793c:	e9 19 01 00 00       	jmp    17a5a <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   17941:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17944:	8d 50 08             	lea    0x8(%eax),%edx
   17947:	8b 45 0c             	mov    0xc(%ebp),%eax
   1794a:	8b 40 30             	mov    0x30(%eax),%eax
   1794d:	c1 e8 08             	shr    $0x8,%eax
   17950:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   17952:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17955:	8d 50 09             	lea    0x9(%eax),%edx
   17958:	8b 45 0c             	mov    0xc(%ebp),%eax
   1795b:	8b 40 30             	mov    0x30(%eax),%eax
   1795e:	88 02                	mov    %al,(%edx)
   17960:	e9 dd 00 00 00       	jmp    17a42 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   17965:	8b 45 0c             	mov    0xc(%ebp),%eax
   17968:	8b 40 0c             	mov    0xc(%eax),%eax
   1796b:	83 f8 02             	cmp    $0x2,%eax
   1796e:	74 0f                	je     1797f <addChunk_bKGD+0x87>
   17970:	8b 45 0c             	mov    0xc(%ebp),%eax
   17973:	8b 40 0c             	mov    0xc(%eax),%eax
   17976:	83 f8 06             	cmp    $0x6,%eax
   17979:	0f 85 86 00 00 00    	jne    17a05 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   1797f:	68 72 0b 02 00       	push   $0x20b72
   17984:	6a 06                	push   $0x6
   17986:	ff 75 08             	pushl  0x8(%ebp)
   17989:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1798c:	50                   	push   %eax
   1798d:	e8 83 77 ff ff       	call   f115 <lodepng_chunk_init>
   17992:	83 c4 10             	add    $0x10,%esp
   17995:	89 45 f8             	mov    %eax,-0x8(%ebp)
   17998:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1799c:	74 08                	je     179a6 <addChunk_bKGD+0xae>
   1799e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   179a1:	e9 b4 00 00 00       	jmp    17a5a <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   179a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   179a9:	8d 50 08             	lea    0x8(%eax),%edx
   179ac:	8b 45 0c             	mov    0xc(%ebp),%eax
   179af:	8b 40 30             	mov    0x30(%eax),%eax
   179b2:	c1 e8 08             	shr    $0x8,%eax
   179b5:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   179b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   179ba:	8d 50 09             	lea    0x9(%eax),%edx
   179bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   179c0:	8b 40 30             	mov    0x30(%eax),%eax
   179c3:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   179c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   179c8:	8d 50 0a             	lea    0xa(%eax),%edx
   179cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   179ce:	8b 40 34             	mov    0x34(%eax),%eax
   179d1:	c1 e8 08             	shr    $0x8,%eax
   179d4:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   179d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   179d9:	8d 50 0b             	lea    0xb(%eax),%edx
   179dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   179df:	8b 40 34             	mov    0x34(%eax),%eax
   179e2:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   179e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   179e7:	8d 50 0c             	lea    0xc(%eax),%edx
   179ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   179ed:	8b 40 38             	mov    0x38(%eax),%eax
   179f0:	c1 e8 08             	shr    $0x8,%eax
   179f3:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   179f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   179f8:	8d 50 0d             	lea    0xd(%eax),%edx
   179fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   179fe:	8b 40 38             	mov    0x38(%eax),%eax
   17a01:	88 02                	mov    %al,(%edx)
   17a03:	eb 3d                	jmp    17a42 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   17a05:	8b 45 0c             	mov    0xc(%ebp),%eax
   17a08:	8b 40 0c             	mov    0xc(%eax),%eax
   17a0b:	83 f8 03             	cmp    $0x3,%eax
   17a0e:	75 32                	jne    17a42 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   17a10:	68 72 0b 02 00       	push   $0x20b72
   17a15:	6a 01                	push   $0x1
   17a17:	ff 75 08             	pushl  0x8(%ebp)
   17a1a:	8d 45 f0             	lea    -0x10(%ebp),%eax
   17a1d:	50                   	push   %eax
   17a1e:	e8 f2 76 ff ff       	call   f115 <lodepng_chunk_init>
   17a23:	83 c4 10             	add    $0x10,%esp
   17a26:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17a29:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   17a2d:	74 05                	je     17a34 <addChunk_bKGD+0x13c>
   17a2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17a32:	eb 26                	jmp    17a5a <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   17a34:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17a37:	8d 50 08             	lea    0x8(%eax),%edx
   17a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   17a3d:	8b 40 30             	mov    0x30(%eax),%eax
   17a40:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   17a42:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17a45:	85 c0                	test   %eax,%eax
   17a47:	74 0c                	je     17a55 <addChunk_bKGD+0x15d>
   17a49:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17a4c:	50                   	push   %eax
   17a4d:	e8 6c 73 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   17a52:	83 c4 04             	add    $0x4,%esp
  return 0;
   17a55:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17a5a:	c9                   	leave  
   17a5b:	c3                   	ret    

00017a5c <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   17a5c:	55                   	push   %ebp
   17a5d:	89 e5                	mov    %esp,%ebp
   17a5f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   17a62:	68 86 0b 02 00       	push   $0x20b86
   17a67:	6a 07                	push   $0x7
   17a69:	ff 75 08             	pushl  0x8(%ebp)
   17a6c:	8d 45 f8             	lea    -0x8(%ebp),%eax
   17a6f:	50                   	push   %eax
   17a70:	e8 a0 76 ff ff       	call   f115 <lodepng_chunk_init>
   17a75:	83 c4 10             	add    $0x10,%esp
   17a78:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17a7b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   17a7f:	74 05                	je     17a86 <addChunk_tIME+0x2a>
   17a81:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17a84:	eb 74                	jmp    17afa <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   17a86:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17a89:	8d 50 08             	lea    0x8(%eax),%edx
   17a8c:	8b 45 0c             	mov    0xc(%ebp),%eax
   17a8f:	8b 00                	mov    (%eax),%eax
   17a91:	c1 e8 08             	shr    $0x8,%eax
   17a94:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   17a96:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17a99:	8d 50 09             	lea    0x9(%eax),%edx
   17a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   17a9f:	8b 00                	mov    (%eax),%eax
   17aa1:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   17aa3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17aa6:	8d 50 0a             	lea    0xa(%eax),%edx
   17aa9:	8b 45 0c             	mov    0xc(%ebp),%eax
   17aac:	8b 40 04             	mov    0x4(%eax),%eax
   17aaf:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   17ab1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17ab4:	8d 50 0b             	lea    0xb(%eax),%edx
   17ab7:	8b 45 0c             	mov    0xc(%ebp),%eax
   17aba:	8b 40 08             	mov    0x8(%eax),%eax
   17abd:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   17abf:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17ac2:	8d 50 0c             	lea    0xc(%eax),%edx
   17ac5:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ac8:	8b 40 0c             	mov    0xc(%eax),%eax
   17acb:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   17acd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17ad0:	8d 50 0d             	lea    0xd(%eax),%edx
   17ad3:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ad6:	8b 40 10             	mov    0x10(%eax),%eax
   17ad9:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   17adb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17ade:	8d 50 0e             	lea    0xe(%eax),%edx
   17ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ae4:	8b 40 14             	mov    0x14(%eax),%eax
   17ae7:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   17ae9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17aec:	50                   	push   %eax
   17aed:	e8 cc 72 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   17af2:	83 c4 04             	add    $0x4,%esp
  return 0;
   17af5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17afa:	c9                   	leave  
   17afb:	c3                   	ret    

00017afc <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   17afc:	55                   	push   %ebp
   17afd:	89 e5                	mov    %esp,%ebp
   17aff:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   17b02:	68 8b 0b 02 00       	push   $0x20b8b
   17b07:	6a 09                	push   $0x9
   17b09:	ff 75 08             	pushl  0x8(%ebp)
   17b0c:	8d 45 f8             	lea    -0x8(%ebp),%eax
   17b0f:	50                   	push   %eax
   17b10:	e8 00 76 ff ff       	call   f115 <lodepng_chunk_init>
   17b15:	83 c4 10             	add    $0x10,%esp
   17b18:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17b1b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   17b1f:	74 05                	je     17b26 <addChunk_pHYs+0x2a>
   17b21:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17b24:	eb 51                	jmp    17b77 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   17b26:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b29:	8b 40 7c             	mov    0x7c(%eax),%eax
   17b2c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17b2f:	83 c2 08             	add    $0x8,%edx
   17b32:	50                   	push   %eax
   17b33:	52                   	push   %edx
   17b34:	e8 25 25 ff ff       	call   a05e <lodepng_set32bitInt>
   17b39:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   17b3c:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b3f:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   17b45:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17b48:	83 c2 0c             	add    $0xc,%edx
   17b4b:	50                   	push   %eax
   17b4c:	52                   	push   %edx
   17b4d:	e8 0c 25 ff ff       	call   a05e <lodepng_set32bitInt>
   17b52:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   17b55:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17b58:	8d 50 10             	lea    0x10(%eax),%edx
   17b5b:	8b 45 0c             	mov    0xc(%ebp),%eax
   17b5e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17b64:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   17b66:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17b69:	50                   	push   %eax
   17b6a:	e8 4f 72 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   17b6f:	83 c4 04             	add    $0x4,%esp
  return 0;
   17b72:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17b77:	c9                   	leave  
   17b78:	c3                   	ret    

00017b79 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   17b79:	55                   	push   %ebp
   17b7a:	89 e5                	mov    %esp,%ebp
   17b7c:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   17b7f:	68 90 0b 02 00       	push   $0x20b90
   17b84:	6a 04                	push   $0x4
   17b86:	ff 75 08             	pushl  0x8(%ebp)
   17b89:	8d 45 f8             	lea    -0x8(%ebp),%eax
   17b8c:	50                   	push   %eax
   17b8d:	e8 83 75 ff ff       	call   f115 <lodepng_chunk_init>
   17b92:	83 c4 10             	add    $0x10,%esp
   17b95:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17b98:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   17b9c:	74 05                	je     17ba3 <addChunk_gAMA+0x2a>
   17b9e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17ba1:	eb 2a                	jmp    17bcd <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   17ba3:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ba6:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   17bac:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17baf:	83 c2 08             	add    $0x8,%edx
   17bb2:	50                   	push   %eax
   17bb3:	52                   	push   %edx
   17bb4:	e8 a5 24 ff ff       	call   a05e <lodepng_set32bitInt>
   17bb9:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   17bbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17bbf:	50                   	push   %eax
   17bc0:	e8 f9 71 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   17bc5:	83 c4 04             	add    $0x4,%esp
  return 0;
   17bc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17bcd:	c9                   	leave  
   17bce:	c3                   	ret    

00017bcf <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   17bcf:	55                   	push   %ebp
   17bd0:	89 e5                	mov    %esp,%ebp
   17bd2:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   17bd5:	68 95 0b 02 00       	push   $0x20b95
   17bda:	6a 20                	push   $0x20
   17bdc:	ff 75 08             	pushl  0x8(%ebp)
   17bdf:	8d 45 f8             	lea    -0x8(%ebp),%eax
   17be2:	50                   	push   %eax
   17be3:	e8 2d 75 ff ff       	call   f115 <lodepng_chunk_init>
   17be8:	83 c4 10             	add    $0x10,%esp
   17beb:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17bee:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   17bf2:	74 08                	je     17bfc <addChunk_cHRM+0x2d>
   17bf4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17bf7:	e9 d9 00 00 00       	jmp    17cd5 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   17bfc:	8b 45 0c             	mov    0xc(%ebp),%eax
   17bff:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   17c05:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17c08:	83 c2 08             	add    $0x8,%edx
   17c0b:	50                   	push   %eax
   17c0c:	52                   	push   %edx
   17c0d:	e8 4c 24 ff ff       	call   a05e <lodepng_set32bitInt>
   17c12:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   17c15:	8b 45 0c             	mov    0xc(%ebp),%eax
   17c18:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   17c1e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17c21:	83 c2 0c             	add    $0xc,%edx
   17c24:	50                   	push   %eax
   17c25:	52                   	push   %edx
   17c26:	e8 33 24 ff ff       	call   a05e <lodepng_set32bitInt>
   17c2b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   17c2e:	8b 45 0c             	mov    0xc(%ebp),%eax
   17c31:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   17c37:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17c3a:	83 c2 10             	add    $0x10,%edx
   17c3d:	50                   	push   %eax
   17c3e:	52                   	push   %edx
   17c3f:	e8 1a 24 ff ff       	call   a05e <lodepng_set32bitInt>
   17c44:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   17c47:	8b 45 0c             	mov    0xc(%ebp),%eax
   17c4a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   17c50:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17c53:	83 c2 14             	add    $0x14,%edx
   17c56:	50                   	push   %eax
   17c57:	52                   	push   %edx
   17c58:	e8 01 24 ff ff       	call   a05e <lodepng_set32bitInt>
   17c5d:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   17c60:	8b 45 0c             	mov    0xc(%ebp),%eax
   17c63:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   17c69:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17c6c:	83 c2 18             	add    $0x18,%edx
   17c6f:	50                   	push   %eax
   17c70:	52                   	push   %edx
   17c71:	e8 e8 23 ff ff       	call   a05e <lodepng_set32bitInt>
   17c76:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   17c79:	8b 45 0c             	mov    0xc(%ebp),%eax
   17c7c:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   17c82:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17c85:	83 c2 1c             	add    $0x1c,%edx
   17c88:	50                   	push   %eax
   17c89:	52                   	push   %edx
   17c8a:	e8 cf 23 ff ff       	call   a05e <lodepng_set32bitInt>
   17c8f:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   17c92:	8b 45 0c             	mov    0xc(%ebp),%eax
   17c95:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   17c9b:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17c9e:	83 c2 20             	add    $0x20,%edx
   17ca1:	50                   	push   %eax
   17ca2:	52                   	push   %edx
   17ca3:	e8 b6 23 ff ff       	call   a05e <lodepng_set32bitInt>
   17ca8:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   17cab:	8b 45 0c             	mov    0xc(%ebp),%eax
   17cae:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   17cb4:	8b 55 f8             	mov    -0x8(%ebp),%edx
   17cb7:	83 c2 24             	add    $0x24,%edx
   17cba:	50                   	push   %eax
   17cbb:	52                   	push   %edx
   17cbc:	e8 9d 23 ff ff       	call   a05e <lodepng_set32bitInt>
   17cc1:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   17cc4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17cc7:	50                   	push   %eax
   17cc8:	e8 f1 70 ff ff       	call   edbe <lodepng_chunk_generate_crc>
   17ccd:	83 c4 04             	add    $0x4,%esp
  return 0;
   17cd0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17cd5:	c9                   	leave  
   17cd6:	c3                   	ret    

00017cd7 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   17cd7:	55                   	push   %ebp
   17cd8:	89 e5                	mov    %esp,%ebp
   17cda:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   17cdd:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ce0:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   17ce6:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   17ce9:	8d 45 ff             	lea    -0x1(%ebp),%eax
   17cec:	50                   	push   %eax
   17ced:	68 9a 0b 02 00       	push   $0x20b9a
   17cf2:	6a 01                	push   $0x1
   17cf4:	ff 75 08             	pushl  0x8(%ebp)
   17cf7:	e8 c1 74 ff ff       	call   f1bd <lodepng_chunk_createv>
   17cfc:	83 c4 10             	add    $0x10,%esp
}
   17cff:	c9                   	leave  
   17d00:	c3                   	ret    

00017d01 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   17d01:	55                   	push   %ebp
   17d02:	89 e5                	mov    %esp,%ebp
   17d04:	53                   	push   %ebx
   17d05:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   17d08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   17d0f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   17d16:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   17d1d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   17d24:	8b 45 0c             	mov    0xc(%ebp),%eax
   17d27:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   17d2d:	50                   	push   %eax
   17d2e:	e8 06 20 ff ff       	call   9d39 <lodepng_strlen>
   17d33:	83 c4 04             	add    $0x4,%esp
   17d36:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   17d39:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   17d3d:	7e 06                	jle    17d45 <addChunk_iCCP+0x44>
   17d3f:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   17d43:	7e 0a                	jle    17d4f <addChunk_iCCP+0x4e>
   17d45:	b8 59 00 00 00       	mov    $0x59,%eax
   17d4a:	e9 df 00 00 00       	jmp    17e2e <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   17d4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   17d52:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   17d58:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   17d5a:	8b 45 0c             	mov    0xc(%ebp),%eax
   17d5d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   17d63:	83 ec 0c             	sub    $0xc,%esp
   17d66:	ff 75 10             	pushl  0x10(%ebp)
   17d69:	52                   	push   %edx
   17d6a:	50                   	push   %eax
   17d6b:	8d 45 e0             	lea    -0x20(%ebp),%eax
   17d6e:	50                   	push   %eax
   17d6f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   17d72:	50                   	push   %eax
   17d73:	e8 35 6c ff ff       	call   e9ad <zlib_compress>
   17d78:	83 c4 20             	add    $0x20,%esp
   17d7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   17d7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17d82:	75 29                	jne    17dad <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   17d84:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17d87:	8d 50 02             	lea    0x2(%eax),%edx
   17d8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   17d8d:	01 d0                	add    %edx,%eax
   17d8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   17d92:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17d95:	68 9f 0b 02 00       	push   $0x20b9f
   17d9a:	50                   	push   %eax
   17d9b:	ff 75 08             	pushl  0x8(%ebp)
   17d9e:	8d 45 e8             	lea    -0x18(%ebp),%eax
   17da1:	50                   	push   %eax
   17da2:	e8 6e 73 ff ff       	call   f115 <lodepng_chunk_init>
   17da7:	83 c4 10             	add    $0x10,%esp
   17daa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   17dad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17db1:	75 69                	jne    17e1c <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   17db3:	8b 45 0c             	mov    0xc(%ebp),%eax
   17db6:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   17dbc:	8b 55 e8             	mov    -0x18(%ebp),%edx
   17dbf:	83 c2 08             	add    $0x8,%edx
   17dc2:	83 ec 04             	sub    $0x4,%esp
   17dc5:	ff 75 f0             	pushl  -0x10(%ebp)
   17dc8:	50                   	push   %eax
   17dc9:	52                   	push   %edx
   17dca:	e8 0c 1f ff ff       	call   9cdb <lodepng_memcpy>
   17dcf:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   17dd2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17dd5:	8b 55 f0             	mov    -0x10(%ebp),%edx
   17dd8:	83 c2 08             	add    $0x8,%edx
   17ddb:	01 d0                	add    %edx,%eax
   17ddd:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   17de0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17de3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   17de6:	83 c2 09             	add    $0x9,%edx
   17de9:	01 d0                	add    %edx,%eax
   17deb:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   17dee:	8b 55 e0             	mov    -0x20(%ebp),%edx
   17df1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17df4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   17df7:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   17dfa:	83 c3 0a             	add    $0xa,%ebx
   17dfd:	01 d9                	add    %ebx,%ecx
   17dff:	83 ec 04             	sub    $0x4,%esp
   17e02:	52                   	push   %edx
   17e03:	50                   	push   %eax
   17e04:	51                   	push   %ecx
   17e05:	e8 d1 1e ff ff       	call   9cdb <lodepng_memcpy>
   17e0a:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   17e0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17e10:	83 ec 0c             	sub    $0xc,%esp
   17e13:	50                   	push   %eax
   17e14:	e8 a5 6f ff ff       	call   edbe <lodepng_chunk_generate_crc>
   17e19:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   17e1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17e1f:	83 ec 0c             	sub    $0xc,%esp
   17e22:	50                   	push   %eax
   17e23:	e8 96 1e ff ff       	call   9cbe <lodepng_free>
   17e28:	83 c4 10             	add    $0x10,%esp
  return error;
   17e2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   17e2e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   17e31:	c9                   	leave  
   17e32:	c3                   	ret    

00017e33 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   17e33:	55                   	push   %ebp
   17e34:	89 e5                	mov    %esp,%ebp
   17e36:	56                   	push   %esi
   17e37:	53                   	push   %ebx
   17e38:	83 ec 14             	sub    $0x14,%esp
   17e3b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   17e3e:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   17e41:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   17e45:	83 f8 04             	cmp    $0x4,%eax
   17e48:	0f 87 41 03 00 00    	ja     1818f <filterScanline+0x35c>
   17e4e:	8b 04 85 b0 0b 02 00 	mov    0x20bb0(,%eax,4),%eax
   17e55:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   17e57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17e5e:	eb 19                	jmp    17e79 <filterScanline+0x46>
   17e60:	8b 55 f4             	mov    -0xc(%ebp),%edx
   17e63:	8b 45 08             	mov    0x8(%ebp),%eax
   17e66:	01 c2                	add    %eax,%edx
   17e68:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   17e6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   17e6e:	01 c8                	add    %ecx,%eax
   17e70:	0f b6 00             	movzbl (%eax),%eax
   17e73:	88 02                	mov    %al,(%edx)
   17e75:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17e79:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17e7c:	3b 45 14             	cmp    0x14(%ebp),%eax
   17e7f:	75 df                	jne    17e60 <filterScanline+0x2d>
      break;
   17e81:	e9 0a 03 00 00       	jmp    18190 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   17e86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17e8d:	eb 19                	jmp    17ea8 <filterScanline+0x75>
   17e8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   17e92:	8b 45 08             	mov    0x8(%ebp),%eax
   17e95:	01 c2                	add    %eax,%edx
   17e97:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   17e9a:	8b 45 0c             	mov    0xc(%ebp),%eax
   17e9d:	01 c8                	add    %ecx,%eax
   17e9f:	0f b6 00             	movzbl (%eax),%eax
   17ea2:	88 02                	mov    %al,(%edx)
   17ea4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17ea8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17eab:	3b 45 18             	cmp    0x18(%ebp),%eax
   17eae:	75 df                	jne    17e8f <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   17eb0:	8b 45 18             	mov    0x18(%ebp),%eax
   17eb3:	89 45 f4             	mov    %eax,-0xc(%ebp)
   17eb6:	eb 2d                	jmp    17ee5 <filterScanline+0xb2>
   17eb8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   17ebb:	8b 45 08             	mov    0x8(%ebp),%eax
   17ebe:	01 c2                	add    %eax,%edx
   17ec0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   17ec3:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ec6:	01 c8                	add    %ecx,%eax
   17ec8:	0f b6 08             	movzbl (%eax),%ecx
   17ecb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17ece:	2b 45 18             	sub    0x18(%ebp),%eax
   17ed1:	89 c3                	mov    %eax,%ebx
   17ed3:	8b 45 0c             	mov    0xc(%ebp),%eax
   17ed6:	01 d8                	add    %ebx,%eax
   17ed8:	0f b6 00             	movzbl (%eax),%eax
   17edb:	29 c1                	sub    %eax,%ecx
   17edd:	89 c8                	mov    %ecx,%eax
   17edf:	88 02                	mov    %al,(%edx)
   17ee1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17ee5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17ee8:	3b 45 14             	cmp    0x14(%ebp),%eax
   17eeb:	7c cb                	jl     17eb8 <filterScanline+0x85>
      break;
   17eed:	e9 9e 02 00 00       	jmp    18190 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   17ef2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   17ef6:	74 3e                	je     17f36 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   17ef8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17eff:	eb 28                	jmp    17f29 <filterScanline+0xf6>
   17f01:	8b 55 f4             	mov    -0xc(%ebp),%edx
   17f04:	8b 45 08             	mov    0x8(%ebp),%eax
   17f07:	01 d0                	add    %edx,%eax
   17f09:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   17f0c:	8b 55 0c             	mov    0xc(%ebp),%edx
   17f0f:	01 ca                	add    %ecx,%edx
   17f11:	0f b6 0a             	movzbl (%edx),%ecx
   17f14:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   17f17:	8b 55 10             	mov    0x10(%ebp),%edx
   17f1a:	01 da                	add    %ebx,%edx
   17f1c:	0f b6 12             	movzbl (%edx),%edx
   17f1f:	29 d1                	sub    %edx,%ecx
   17f21:	89 ca                	mov    %ecx,%edx
   17f23:	88 10                	mov    %dl,(%eax)
   17f25:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17f29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17f2c:	3b 45 14             	cmp    0x14(%ebp),%eax
   17f2f:	75 d0                	jne    17f01 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   17f31:	e9 5a 02 00 00       	jmp    18190 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   17f36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17f3d:	eb 19                	jmp    17f58 <filterScanline+0x125>
   17f3f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   17f42:	8b 45 08             	mov    0x8(%ebp),%eax
   17f45:	01 c2                	add    %eax,%edx
   17f47:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   17f4a:	8b 45 0c             	mov    0xc(%ebp),%eax
   17f4d:	01 c8                	add    %ecx,%eax
   17f4f:	0f b6 00             	movzbl (%eax),%eax
   17f52:	88 02                	mov    %al,(%edx)
   17f54:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17f58:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17f5b:	3b 45 14             	cmp    0x14(%ebp),%eax
   17f5e:	75 df                	jne    17f3f <filterScanline+0x10c>
      }
      break;
   17f60:	e9 2b 02 00 00       	jmp    18190 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   17f65:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   17f69:	0f 84 90 00 00 00    	je     17fff <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   17f6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17f76:	eb 28                	jmp    17fa0 <filterScanline+0x16d>
   17f78:	8b 55 f4             	mov    -0xc(%ebp),%edx
   17f7b:	8b 45 08             	mov    0x8(%ebp),%eax
   17f7e:	01 d0                	add    %edx,%eax
   17f80:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   17f83:	8b 55 0c             	mov    0xc(%ebp),%edx
   17f86:	01 ca                	add    %ecx,%edx
   17f88:	0f b6 12             	movzbl (%edx),%edx
   17f8b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   17f8e:	8b 4d 10             	mov    0x10(%ebp),%ecx
   17f91:	01 d9                	add    %ebx,%ecx
   17f93:	0f b6 09             	movzbl (%ecx),%ecx
   17f96:	d0 e9                	shr    %cl
   17f98:	29 ca                	sub    %ecx,%edx
   17f9a:	88 10                	mov    %dl,(%eax)
   17f9c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17fa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17fa3:	3b 45 18             	cmp    0x18(%ebp),%eax
   17fa6:	75 d0                	jne    17f78 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   17fa8:	8b 45 18             	mov    0x18(%ebp),%eax
   17fab:	89 45 f4             	mov    %eax,-0xc(%ebp)
   17fae:	eb 42                	jmp    17ff2 <filterScanline+0x1bf>
   17fb0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   17fb3:	8b 45 08             	mov    0x8(%ebp),%eax
   17fb6:	01 c2                	add    %eax,%edx
   17fb8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   17fbb:	8b 45 0c             	mov    0xc(%ebp),%eax
   17fbe:	01 c8                	add    %ecx,%eax
   17fc0:	0f b6 08             	movzbl (%eax),%ecx
   17fc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17fc6:	2b 45 18             	sub    0x18(%ebp),%eax
   17fc9:	89 c3                	mov    %eax,%ebx
   17fcb:	8b 45 0c             	mov    0xc(%ebp),%eax
   17fce:	01 d8                	add    %ebx,%eax
   17fd0:	0f b6 00             	movzbl (%eax),%eax
   17fd3:	0f b6 d8             	movzbl %al,%ebx
   17fd6:	8b 75 f4             	mov    -0xc(%ebp),%esi
   17fd9:	8b 45 10             	mov    0x10(%ebp),%eax
   17fdc:	01 f0                	add    %esi,%eax
   17fde:	0f b6 00             	movzbl (%eax),%eax
   17fe1:	0f b6 c0             	movzbl %al,%eax
   17fe4:	01 d8                	add    %ebx,%eax
   17fe6:	d1 f8                	sar    %eax
   17fe8:	29 c1                	sub    %eax,%ecx
   17fea:	89 c8                	mov    %ecx,%eax
   17fec:	88 02                	mov    %al,(%edx)
   17fee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17ff2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17ff5:	3b 45 14             	cmp    0x14(%ebp),%eax
   17ff8:	7c b6                	jl     17fb0 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   17ffa:	e9 91 01 00 00       	jmp    18190 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   17fff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   18006:	eb 19                	jmp    18021 <filterScanline+0x1ee>
   18008:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1800b:	8b 45 08             	mov    0x8(%ebp),%eax
   1800e:	01 c2                	add    %eax,%edx
   18010:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   18013:	8b 45 0c             	mov    0xc(%ebp),%eax
   18016:	01 c8                	add    %ecx,%eax
   18018:	0f b6 00             	movzbl (%eax),%eax
   1801b:	88 02                	mov    %al,(%edx)
   1801d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   18021:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18024:	3b 45 18             	cmp    0x18(%ebp),%eax
   18027:	75 df                	jne    18008 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   18029:	8b 45 18             	mov    0x18(%ebp),%eax
   1802c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1802f:	eb 2f                	jmp    18060 <filterScanline+0x22d>
   18031:	8b 55 f4             	mov    -0xc(%ebp),%edx
   18034:	8b 45 08             	mov    0x8(%ebp),%eax
   18037:	01 c2                	add    %eax,%edx
   18039:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1803c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1803f:	01 c8                	add    %ecx,%eax
   18041:	0f b6 08             	movzbl (%eax),%ecx
   18044:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18047:	2b 45 18             	sub    0x18(%ebp),%eax
   1804a:	89 c3                	mov    %eax,%ebx
   1804c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1804f:	01 d8                	add    %ebx,%eax
   18051:	0f b6 00             	movzbl (%eax),%eax
   18054:	d0 e8                	shr    %al
   18056:	29 c1                	sub    %eax,%ecx
   18058:	89 c8                	mov    %ecx,%eax
   1805a:	88 02                	mov    %al,(%edx)
   1805c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   18060:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18063:	3b 45 14             	cmp    0x14(%ebp),%eax
   18066:	7c c9                	jl     18031 <filterScanline+0x1fe>
      }
      break;
   18068:	e9 23 01 00 00       	jmp    18190 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   1806d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   18071:	0f 84 af 00 00 00    	je     18126 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   18077:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1807e:	eb 28                	jmp    180a8 <filterScanline+0x275>
   18080:	8b 55 f4             	mov    -0xc(%ebp),%edx
   18083:	8b 45 08             	mov    0x8(%ebp),%eax
   18086:	01 d0                	add    %edx,%eax
   18088:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1808b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1808e:	01 ca                	add    %ecx,%edx
   18090:	0f b6 0a             	movzbl (%edx),%ecx
   18093:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   18096:	8b 55 10             	mov    0x10(%ebp),%edx
   18099:	01 da                	add    %ebx,%edx
   1809b:	0f b6 12             	movzbl (%edx),%edx
   1809e:	29 d1                	sub    %edx,%ecx
   180a0:	89 ca                	mov    %ecx,%edx
   180a2:	88 10                	mov    %dl,(%eax)
   180a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   180a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   180ab:	3b 45 18             	cmp    0x18(%ebp),%eax
   180ae:	75 d0                	jne    18080 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   180b0:	8b 45 18             	mov    0x18(%ebp),%eax
   180b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
   180b6:	eb 64                	jmp    1811c <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   180b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   180bb:	8b 45 08             	mov    0x8(%ebp),%eax
   180be:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   180c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   180c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   180c7:	01 d0                	add    %edx,%eax
   180c9:	0f b6 00             	movzbl (%eax),%eax
   180cc:	88 45 e7             	mov    %al,-0x19(%ebp)
   180cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   180d2:	2b 45 18             	sub    0x18(%ebp),%eax
   180d5:	89 c2                	mov    %eax,%edx
   180d7:	8b 45 10             	mov    0x10(%ebp),%eax
   180da:	01 d0                	add    %edx,%eax
   180dc:	0f b6 00             	movzbl (%eax),%eax
   180df:	0f b6 c8             	movzbl %al,%ecx
   180e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   180e5:	8b 45 10             	mov    0x10(%ebp),%eax
   180e8:	01 d0                	add    %edx,%eax
   180ea:	0f b6 00             	movzbl (%eax),%eax
   180ed:	0f b6 d0             	movzbl %al,%edx
   180f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   180f3:	2b 45 18             	sub    0x18(%ebp),%eax
   180f6:	89 c6                	mov    %eax,%esi
   180f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   180fb:	01 f0                	add    %esi,%eax
   180fd:	0f b6 00             	movzbl (%eax),%eax
   18100:	0f b6 c0             	movzbl %al,%eax
   18103:	51                   	push   %ecx
   18104:	52                   	push   %edx
   18105:	50                   	push   %eax
   18106:	e8 49 b8 ff ff       	call   13954 <paethPredictor>
   1810b:	83 c4 0c             	add    $0xc,%esp
   1810e:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   18112:	29 c1                	sub    %eax,%ecx
   18114:	89 c8                	mov    %ecx,%eax
   18116:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   18118:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1811c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1811f:	3b 45 14             	cmp    0x14(%ebp),%eax
   18122:	7c 94                	jl     180b8 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   18124:	eb 6a                	jmp    18190 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   18126:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1812d:	eb 19                	jmp    18148 <filterScanline+0x315>
   1812f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   18132:	8b 45 08             	mov    0x8(%ebp),%eax
   18135:	01 c2                	add    %eax,%edx
   18137:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1813a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1813d:	01 c8                	add    %ecx,%eax
   1813f:	0f b6 00             	movzbl (%eax),%eax
   18142:	88 02                	mov    %al,(%edx)
   18144:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   18148:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1814b:	3b 45 18             	cmp    0x18(%ebp),%eax
   1814e:	75 df                	jne    1812f <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   18150:	8b 45 18             	mov    0x18(%ebp),%eax
   18153:	89 45 f4             	mov    %eax,-0xc(%ebp)
   18156:	eb 2d                	jmp    18185 <filterScanline+0x352>
   18158:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1815b:	8b 45 08             	mov    0x8(%ebp),%eax
   1815e:	01 c2                	add    %eax,%edx
   18160:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   18163:	8b 45 0c             	mov    0xc(%ebp),%eax
   18166:	01 c8                	add    %ecx,%eax
   18168:	0f b6 08             	movzbl (%eax),%ecx
   1816b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1816e:	2b 45 18             	sub    0x18(%ebp),%eax
   18171:	89 c3                	mov    %eax,%ebx
   18173:	8b 45 0c             	mov    0xc(%ebp),%eax
   18176:	01 d8                	add    %ebx,%eax
   18178:	0f b6 00             	movzbl (%eax),%eax
   1817b:	29 c1                	sub    %eax,%ecx
   1817d:	89 c8                	mov    %ecx,%eax
   1817f:	88 02                	mov    %al,(%edx)
   18181:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   18185:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18188:	3b 45 14             	cmp    0x14(%ebp),%eax
   1818b:	7c cb                	jl     18158 <filterScanline+0x325>
      }
      break;
   1818d:	eb 01                	jmp    18190 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   1818f:	90                   	nop
  }
}
   18190:	8d 65 f8             	lea    -0x8(%ebp),%esp
   18193:	5b                   	pop    %ebx
   18194:	5e                   	pop    %esi
   18195:	5d                   	pop    %ebp
   18196:	c3                   	ret    

00018197 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   18197:	55                   	push   %ebp
   18198:	89 e5                	mov    %esp,%ebp
   1819a:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   1819d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   181a4:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   181ab:	7e 08                	jle    181b5 <ilog2+0x1e>
   181ad:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   181b1:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   181b5:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   181bc:	7e 08                	jle    181c6 <ilog2+0x2f>
   181be:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   181c2:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   181c6:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   181ca:	7e 08                	jle    181d4 <ilog2+0x3d>
   181cc:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   181d0:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   181d4:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   181d8:	7e 08                	jle    181e2 <ilog2+0x4b>
   181da:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   181de:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   181e2:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   181e6:	7e 04                	jle    181ec <ilog2+0x55>
   181e8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   181ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   181ef:	c9                   	leave  
   181f0:	c3                   	ret    

000181f1 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   181f1:	55                   	push   %ebp
   181f2:	89 e5                	mov    %esp,%ebp
   181f4:	56                   	push   %esi
   181f5:	53                   	push   %ebx
   181f6:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   181f9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   181fd:	75 07                	jne    18206 <ilog2i+0x15>
   181ff:	b8 00 00 00 00       	mov    $0x0,%eax
   18204:	eb 30                	jmp    18236 <ilog2i+0x45>
  l = ilog2(i);
   18206:	ff 75 08             	pushl  0x8(%ebp)
   18209:	e8 89 ff ff ff       	call   18197 <ilog2>
   1820e:	83 c4 04             	add    $0x4,%esp
   18211:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   18214:	8b 45 08             	mov    0x8(%ebp),%eax
   18217:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1821b:	89 c3                	mov    %eax,%ebx
   1821d:	8b 55 08             	mov    0x8(%ebp),%edx
   18220:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18223:	be 01 00 00 00       	mov    $0x1,%esi
   18228:	89 c1                	mov    %eax,%ecx
   1822a:	d3 e6                	shl    %cl,%esi
   1822c:	89 f0                	mov    %esi,%eax
   1822e:	29 c2                	sub    %eax,%edx
   18230:	89 d0                	mov    %edx,%eax
   18232:	01 c0                	add    %eax,%eax
   18234:	01 d8                	add    %ebx,%eax
}
   18236:	8d 65 f8             	lea    -0x8(%ebp),%esp
   18239:	5b                   	pop    %ebx
   1823a:	5e                   	pop    %esi
   1823b:	5d                   	pop    %ebp
   1823c:	c3                   	ret    

0001823d <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   1823d:	55                   	push   %ebp
   1823e:	89 e5                	mov    %esp,%ebp
   18240:	53                   	push   %ebx
   18241:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   18247:	ff 75 18             	pushl  0x18(%ebp)
   1824a:	e8 6a 75 ff ff       	call   f7b9 <lodepng_get_bpp>
   1824f:	83 c4 04             	add    $0x4,%esp
   18252:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   18255:	ff 75 b8             	pushl  -0x48(%ebp)
   18258:	6a 01                	push   $0x1
   1825a:	ff 75 10             	pushl  0x10(%ebp)
   1825d:	e8 b6 76 ff ff       	call   f918 <lodepng_get_raw_size_idat>
   18262:	83 c4 0c             	add    $0xc,%esp
   18265:	83 e8 01             	sub    $0x1,%eax
   18268:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   1826b:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1826e:	83 c0 07             	add    $0x7,%eax
   18271:	c1 e8 03             	shr    $0x3,%eax
   18274:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   18277:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   1827e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   18285:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18288:	8b 40 2c             	mov    0x2c(%eax),%eax
   1828b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   1828e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18291:	8b 40 28             	mov    0x28(%eax),%eax
   18294:	85 c0                	test   %eax,%eax
   18296:	74 1c                	je     182b4 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   18298:	8b 45 18             	mov    0x18(%ebp),%eax
   1829b:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   1829d:	83 f8 03             	cmp    $0x3,%eax
   182a0:	74 0b                	je     182ad <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   182a2:	8b 45 18             	mov    0x18(%ebp),%eax
   182a5:	8b 40 04             	mov    0x4(%eax),%eax
   182a8:	83 f8 07             	cmp    $0x7,%eax
   182ab:	77 07                	ja     182b4 <filter+0x77>
   182ad:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   182b4:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   182b8:	75 0a                	jne    182c4 <filter+0x87>
   182ba:	b8 1f 00 00 00       	mov    $0x1f,%eax
   182bf:	e9 5b 07 00 00       	jmp    18a1f <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   182c4:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   182c8:	77 7b                	ja     18345 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   182ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   182cd:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   182d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   182d7:	eb 5f                	jmp    18338 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   182d9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   182dc:	83 c0 01             	add    $0x1,%eax
   182df:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   182e3:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   182e6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   182e9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   182ed:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   182f0:	8b 55 9c             	mov    -0x64(%ebp),%edx
   182f3:	8b 45 08             	mov    0x8(%ebp),%eax
   182f6:	01 c2                	add    %eax,%edx
   182f8:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   182fc:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   182fe:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   18302:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   18305:	8b 55 0c             	mov    0xc(%ebp),%edx
   18308:	01 d1                	add    %edx,%ecx
   1830a:	8b 55 9c             	mov    -0x64(%ebp),%edx
   1830d:	8d 5a 01             	lea    0x1(%edx),%ebx
   18310:	8b 55 08             	mov    0x8(%ebp),%edx
   18313:	01 da                	add    %ebx,%edx
   18315:	50                   	push   %eax
   18316:	ff 75 b0             	pushl  -0x50(%ebp)
   18319:	ff 75 b4             	pushl  -0x4c(%ebp)
   1831c:	ff 75 f4             	pushl  -0xc(%ebp)
   1831f:	51                   	push   %ecx
   18320:	52                   	push   %edx
   18321:	e8 0d fb ff ff       	call   17e33 <filterScanline>
   18326:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   18329:	8b 55 98             	mov    -0x68(%ebp),%edx
   1832c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1832f:	01 d0                	add    %edx,%eax
   18331:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   18334:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   18338:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1833b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1833e:	75 99                	jne    182d9 <filter+0x9c>
   18340:	e9 d7 06 00 00       	jmp    18a1c <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   18345:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   18349:	0f 85 e3 01 00 00    	jne    18532 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   1834f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   18356:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   1835a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   1835e:	eb 2d                	jmp    1838d <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   18360:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   18364:	83 ec 0c             	sub    $0xc,%esp
   18367:	ff 75 b4             	pushl  -0x4c(%ebp)
   1836a:	e8 2e 19 ff ff       	call   9c9d <lodepng_malloc>
   1836f:	83 c4 10             	add    $0x10,%esp
   18372:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   18376:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1837a:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   1837e:	85 c0                	test   %eax,%eax
   18380:	75 07                	jne    18389 <filter+0x14c>
   18382:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   18389:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   1838d:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   18391:	75 cd                	jne    18360 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   18393:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   18397:	0f 85 6c 01 00 00    	jne    18509 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   1839d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   183a4:	e9 54 01 00 00       	jmp    184fd <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   183a9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   183ad:	e9 d5 00 00 00       	jmp    18487 <filter+0x24a>
          size_t sum = 0;
   183b2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   183b9:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   183bd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   183c0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   183c4:	89 c1                	mov    %eax,%ecx
   183c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   183c9:	01 c1                	add    %eax,%ecx
   183cb:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   183cf:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   183d3:	83 ec 08             	sub    $0x8,%esp
   183d6:	52                   	push   %edx
   183d7:	ff 75 b0             	pushl  -0x50(%ebp)
   183da:	ff 75 b4             	pushl  -0x4c(%ebp)
   183dd:	ff 75 f4             	pushl  -0xc(%ebp)
   183e0:	51                   	push   %ecx
   183e1:	50                   	push   %eax
   183e2:	e8 4c fa ff ff       	call   17e33 <filterScanline>
   183e7:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   183ea:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   183ee:	75 2d                	jne    1841d <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   183f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   183f7:	eb 1a                	jmp    18413 <filter+0x1d6>
   183f9:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   183fd:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   18401:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18404:	01 d0                	add    %edx,%eax
   18406:	0f b6 00             	movzbl (%eax),%eax
   18409:	0f b6 c0             	movzbl %al,%eax
   1840c:	01 45 d8             	add    %eax,-0x28(%ebp)
   1840f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   18413:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18416:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   18419:	75 de                	jne    183f9 <filter+0x1bc>
   1841b:	eb 4b                	jmp    18468 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   1841d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   18424:	eb 3a                	jmp    18460 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   18426:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1842a:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   1842e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18431:	01 d0                	add    %edx,%eax
   18433:	0f b6 00             	movzbl (%eax),%eax
   18436:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   18439:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   1843d:	84 c0                	test   %al,%al
   1843f:	78 06                	js     18447 <filter+0x20a>
   18441:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   18445:	eb 0d                	jmp    18454 <filter+0x217>
   18447:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   1844b:	ba ff 00 00 00       	mov    $0xff,%edx
   18450:	29 c2                	sub    %eax,%edx
   18452:	89 d0                	mov    %edx,%eax
   18454:	8b 55 d8             	mov    -0x28(%ebp),%edx
   18457:	01 d0                	add    %edx,%eax
   18459:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   1845c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   18460:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18463:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   18466:	75 be                	jne    18426 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   18468:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   1846c:	74 08                	je     18476 <filter+0x239>
   1846e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   18471:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   18474:	7d 0d                	jge    18483 <filter+0x246>
            bestType = type;
   18476:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1847a:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   1847d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   18480:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   18483:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   18487:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   1848b:	0f 85 21 ff ff ff    	jne    183b2 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   18491:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18494:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   18498:	89 c2                	mov    %eax,%edx
   1849a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1849d:	01 d0                	add    %edx,%eax
   1849f:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   184a2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   184a5:	83 c0 01             	add    $0x1,%eax
   184a8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   184ac:	89 c2                	mov    %eax,%edx
   184ae:	8b 45 08             	mov    0x8(%ebp),%eax
   184b1:	01 c2                	add    %eax,%edx
   184b3:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   184b7:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   184b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   184c0:	eb 2f                	jmp    184f1 <filter+0x2b4>
   184c2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   184c5:	83 c0 01             	add    $0x1,%eax
   184c8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   184cc:	89 c2                	mov    %eax,%edx
   184ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
   184d1:	01 d0                	add    %edx,%eax
   184d3:	8d 50 01             	lea    0x1(%eax),%edx
   184d6:	8b 45 08             	mov    0x8(%ebp),%eax
   184d9:	01 c2                	add    %eax,%edx
   184db:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   184df:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   184e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   184e6:	01 c8                	add    %ecx,%eax
   184e8:	0f b6 00             	movzbl (%eax),%eax
   184eb:	88 02                	mov    %al,(%edx)
   184ed:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   184f1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   184f4:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   184f7:	75 c9                	jne    184c2 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   184f9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   184fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18500:	3b 45 14             	cmp    0x14(%ebp),%eax
   18503:	0f 85 a0 fe ff ff    	jne    183a9 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   18509:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   1850d:	eb 18                	jmp    18527 <filter+0x2ea>
   1850f:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   18513:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   18517:	83 ec 0c             	sub    $0xc,%esp
   1851a:	50                   	push   %eax
   1851b:	e8 9e 17 ff ff       	call   9cbe <lodepng_free>
   18520:	83 c4 10             	add    $0x10,%esp
   18523:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   18527:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   1852b:	75 e2                	jne    1850f <filter+0x2d2>
   1852d:	e9 ea 04 00 00       	jmp    18a1c <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   18532:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   18536:	0f 85 17 02 00 00    	jne    18753 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   1853c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   18543:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   1854a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   18551:	eb 33                	jmp    18586 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   18553:	83 ec 0c             	sub    $0xc,%esp
   18556:	ff 75 b4             	pushl  -0x4c(%ebp)
   18559:	e8 3f 17 ff ff       	call   9c9d <lodepng_malloc>
   1855e:	83 c4 10             	add    $0x10,%esp
   18561:	89 c2                	mov    %eax,%edx
   18563:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18566:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   1856d:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18570:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   18577:	85 c0                	test   %eax,%eax
   18579:	75 07                	jne    18582 <filter+0x345>
   1857b:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   18582:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   18586:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   1858a:	75 c7                	jne    18553 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   1858c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   18590:	0f 85 8f 01 00 00    	jne    18725 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   18596:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1859d:	e9 77 01 00 00       	jmp    18719 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   185a2:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   185a9:	e9 f4 00 00 00       	jmp    186a2 <filter+0x465>
          size_t sum = 0;
   185ae:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   185b5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   185b8:	0f b6 d0             	movzbl %al,%edx
   185bb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   185be:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   185c2:	89 c1                	mov    %eax,%ecx
   185c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   185c7:	01 c1                	add    %eax,%ecx
   185c9:	8b 45 d0             	mov    -0x30(%ebp),%eax
   185cc:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   185d3:	83 ec 08             	sub    $0x8,%esp
   185d6:	52                   	push   %edx
   185d7:	ff 75 b0             	pushl  -0x50(%ebp)
   185da:	ff 75 b4             	pushl  -0x4c(%ebp)
   185dd:	ff 75 f4             	pushl  -0xc(%ebp)
   185e0:	51                   	push   %ecx
   185e1:	50                   	push   %eax
   185e2:	e8 4c f8 ff ff       	call   17e33 <filterScanline>
   185e7:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   185ea:	83 ec 04             	sub    $0x4,%esp
   185ed:	68 00 04 00 00       	push   $0x400
   185f2:	6a 00                	push   $0x0
   185f4:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   185fa:	50                   	push   %eax
   185fb:	e8 0e 17 ff ff       	call   9d0e <lodepng_memset>
   18600:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   18603:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1860a:	eb 2a                	jmp    18636 <filter+0x3f9>
   1860c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1860f:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   18616:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18619:	01 d0                	add    %edx,%eax
   1861b:	0f b6 00             	movzbl (%eax),%eax
   1861e:	0f b6 c0             	movzbl %al,%eax
   18621:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   18628:	83 c2 01             	add    $0x1,%edx
   1862b:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   18632:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   18636:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18639:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1863c:	75 ce                	jne    1860c <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   1863e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18641:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   18648:	8d 50 01             	lea    0x1(%eax),%edx
   1864b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1864e:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   18655:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1865c:	eb 1d                	jmp    1867b <filter+0x43e>
            sum += ilog2i(count[x]);
   1865e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18661:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   18668:	83 ec 0c             	sub    $0xc,%esp
   1866b:	50                   	push   %eax
   1866c:	e8 80 fb ff ff       	call   181f1 <ilog2i>
   18671:	83 c4 10             	add    $0x10,%esp
   18674:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   18677:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1867b:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   18682:	75 da                	jne    1865e <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   18684:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   18688:	74 08                	je     18692 <filter+0x455>
   1868a:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1868d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   18690:	7e 0c                	jle    1869e <filter+0x461>
            bestType = type;
   18692:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18695:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   18698:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1869b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   1869e:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   186a2:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   186a6:	0f 85 02 ff ff ff    	jne    185ae <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   186ac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   186af:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   186b3:	89 c2                	mov    %eax,%edx
   186b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   186b8:	01 d0                	add    %edx,%eax
   186ba:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   186bd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   186c0:	83 c0 01             	add    $0x1,%eax
   186c3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   186c7:	89 c2                	mov    %eax,%edx
   186c9:	8b 45 08             	mov    0x8(%ebp),%eax
   186cc:	01 d0                	add    %edx,%eax
   186ce:	8b 55 cc             	mov    -0x34(%ebp),%edx
   186d1:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   186d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   186da:	eb 31                	jmp    1870d <filter+0x4d0>
   186dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   186df:	83 c0 01             	add    $0x1,%eax
   186e2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   186e6:	89 c2                	mov    %eax,%edx
   186e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   186eb:	01 d0                	add    %edx,%eax
   186ed:	8d 50 01             	lea    0x1(%eax),%edx
   186f0:	8b 45 08             	mov    0x8(%ebp),%eax
   186f3:	01 c2                	add    %eax,%edx
   186f5:	8b 45 cc             	mov    -0x34(%ebp),%eax
   186f8:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   186ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18702:	01 c8                	add    %ecx,%eax
   18704:	0f b6 00             	movzbl (%eax),%eax
   18707:	88 02                	mov    %al,(%edx)
   18709:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1870d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18710:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   18713:	75 c7                	jne    186dc <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   18715:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   18719:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1871c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1871f:	0f 85 7d fe ff ff    	jne    185a2 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   18725:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   1872c:	eb 1a                	jmp    18748 <filter+0x50b>
   1872e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18731:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   18738:	83 ec 0c             	sub    $0xc,%esp
   1873b:	50                   	push   %eax
   1873c:	e8 7d 15 ff ff       	call   9cbe <lodepng_free>
   18741:	83 c4 10             	add    $0x10,%esp
   18744:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   18748:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   1874c:	75 e0                	jne    1872e <filter+0x4f1>
   1874e:	e9 c9 02 00 00       	jmp    18a1c <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   18753:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   18757:	0f 85 89 00 00 00    	jne    187e6 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   1875d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   18764:	eb 73                	jmp    187d9 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   18766:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18769:	83 c0 01             	add    $0x1,%eax
   1876c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   18770:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   18773:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18776:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1877a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   1877d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18780:	8b 50 30             	mov    0x30(%eax),%edx
   18783:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18786:	01 d0                	add    %edx,%eax
   18788:	0f b6 00             	movzbl (%eax),%eax
   1878b:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   1878e:	8b 55 a8             	mov    -0x58(%ebp),%edx
   18791:	8b 45 08             	mov    0x8(%ebp),%eax
   18794:	01 c2                	add    %eax,%edx
   18796:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   1879a:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   1879c:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   187a0:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   187a3:	8b 55 0c             	mov    0xc(%ebp),%edx
   187a6:	01 d1                	add    %edx,%ecx
   187a8:	8b 55 a8             	mov    -0x58(%ebp),%edx
   187ab:	8d 5a 01             	lea    0x1(%edx),%ebx
   187ae:	8b 55 08             	mov    0x8(%ebp),%edx
   187b1:	01 da                	add    %ebx,%edx
   187b3:	83 ec 08             	sub    $0x8,%esp
   187b6:	50                   	push   %eax
   187b7:	ff 75 b0             	pushl  -0x50(%ebp)
   187ba:	ff 75 b4             	pushl  -0x4c(%ebp)
   187bd:	ff 75 f4             	pushl  -0xc(%ebp)
   187c0:	51                   	push   %ecx
   187c1:	52                   	push   %edx
   187c2:	e8 6c f6 ff ff       	call   17e33 <filterScanline>
   187c7:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   187ca:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   187cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   187d0:	01 d0                	add    %edx,%eax
   187d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   187d5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   187d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   187dc:	3b 45 14             	cmp    0x14(%ebp),%eax
   187df:	75 85                	jne    18766 <filter+0x529>
   187e1:	e9 36 02 00 00       	jmp    18a1c <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   187e6:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   187ea:	0f 85 25 02 00 00    	jne    18a15 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   187f0:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   187f7:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   187fe:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   18805:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18808:	83 ec 04             	sub    $0x4,%esp
   1880b:	6a 24                	push   $0x24
   1880d:	50                   	push   %eax
   1880e:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   18814:	50                   	push   %eax
   18815:	e8 c1 14 ff ff       	call   9cdb <lodepng_memcpy>
   1881a:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   1881d:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   18824:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   18827:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   1882e:	00 00 00 
    zlibsettings.custom_deflate = 0;
   18831:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   18838:	00 00 00 
    for(type = 0; type != 5; ++type) {
   1883b:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   18842:	eb 33                	jmp    18877 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   18844:	83 ec 0c             	sub    $0xc,%esp
   18847:	ff 75 b4             	pushl  -0x4c(%ebp)
   1884a:	e8 4e 14 ff ff       	call   9c9d <lodepng_malloc>
   1884f:	83 c4 10             	add    $0x10,%esp
   18852:	89 c2                	mov    %eax,%edx
   18854:	8b 45 c0             	mov    -0x40(%ebp),%eax
   18857:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   1885e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   18861:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   18868:	85 c0                	test   %eax,%eax
   1886a:	75 07                	jne    18873 <filter+0x636>
   1886c:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   18873:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   18877:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1887b:	75 c7                	jne    18844 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   1887d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   18881:	0f 85 63 01 00 00    	jne    189ea <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   18887:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1888e:	e9 4b 01 00 00       	jmp    189de <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   18893:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1889a:	e9 c8 00 00 00       	jmp    18967 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   1889f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   188a2:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   188a5:	8b 45 c0             	mov    -0x40(%ebp),%eax
   188a8:	0f b6 d0             	movzbl %al,%edx
   188ab:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   188ae:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   188b2:	89 c1                	mov    %eax,%ecx
   188b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   188b7:	01 c1                	add    %eax,%ecx
   188b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
   188bc:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   188c3:	83 ec 08             	sub    $0x8,%esp
   188c6:	52                   	push   %edx
   188c7:	ff 75 b0             	pushl  -0x50(%ebp)
   188ca:	ff 75 b4             	pushl  -0x4c(%ebp)
   188cd:	ff 75 f4             	pushl  -0xc(%ebp)
   188d0:	51                   	push   %ecx
   188d1:	50                   	push   %eax
   188d2:	e8 5c f5 ff ff       	call   17e33 <filterScanline>
   188d7:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   188da:	8b 45 c0             	mov    -0x40(%ebp),%eax
   188dd:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   188e4:	00 00 00 00 
          dummy = 0;
   188e8:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   188ef:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   188f2:	8b 55 ac             	mov    -0x54(%ebp),%edx
   188f5:	8b 45 c0             	mov    -0x40(%ebp),%eax
   188f8:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   188ff:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   18905:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   18908:	c1 e3 02             	shl    $0x2,%ebx
   1890b:	01 cb                	add    %ecx,%ebx
   1890d:	83 ec 0c             	sub    $0xc,%esp
   18910:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   18916:	51                   	push   %ecx
   18917:	52                   	push   %edx
   18918:	50                   	push   %eax
   18919:	53                   	push   %ebx
   1891a:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   18920:	50                   	push   %eax
   18921:	e8 87 60 ff ff       	call   e9ad <zlib_compress>
   18926:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   18929:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   1892f:	83 ec 0c             	sub    $0xc,%esp
   18932:	50                   	push   %eax
   18933:	e8 86 13 ff ff       	call   9cbe <lodepng_free>
   18938:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   1893b:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   1893f:	74 0f                	je     18950 <filter+0x713>
   18941:	8b 45 c0             	mov    -0x40(%ebp),%eax
   18944:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   1894b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   1894e:	7d 13                	jge    18963 <filter+0x726>
            bestType = type;
   18950:	8b 45 c0             	mov    -0x40(%ebp),%eax
   18953:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   18956:	8b 45 c0             	mov    -0x40(%ebp),%eax
   18959:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   18960:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   18963:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   18967:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1896b:	0f 85 2e ff ff ff    	jne    1889f <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   18971:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18974:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   18978:	89 c2                	mov    %eax,%edx
   1897a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1897d:	01 d0                	add    %edx,%eax
   1897f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   18982:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   18985:	83 c0 01             	add    $0x1,%eax
   18988:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1898c:	89 c2                	mov    %eax,%edx
   1898e:	8b 45 08             	mov    0x8(%ebp),%eax
   18991:	01 d0                	add    %edx,%eax
   18993:	8b 55 bc             	mov    -0x44(%ebp),%edx
   18996:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   18998:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1899f:	eb 31                	jmp    189d2 <filter+0x795>
   189a1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   189a4:	83 c0 01             	add    $0x1,%eax
   189a7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   189ab:	89 c2                	mov    %eax,%edx
   189ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   189b0:	01 d0                	add    %edx,%eax
   189b2:	8d 50 01             	lea    0x1(%eax),%edx
   189b5:	8b 45 08             	mov    0x8(%ebp),%eax
   189b8:	01 c2                	add    %eax,%edx
   189ba:	8b 45 bc             	mov    -0x44(%ebp),%eax
   189bd:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   189c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   189c7:	01 c8                	add    %ecx,%eax
   189c9:	0f b6 00             	movzbl (%eax),%eax
   189cc:	88 02                	mov    %al,(%edx)
   189ce:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   189d2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   189d5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   189d8:	75 c7                	jne    189a1 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   189da:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   189de:	8b 45 ec             	mov    -0x14(%ebp),%eax
   189e1:	3b 45 14             	cmp    0x14(%ebp),%eax
   189e4:	0f 85 a9 fe ff ff    	jne    18893 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   189ea:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   189f1:	eb 1a                	jmp    18a0d <filter+0x7d0>
   189f3:	8b 45 c0             	mov    -0x40(%ebp),%eax
   189f6:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   189fd:	83 ec 0c             	sub    $0xc,%esp
   18a00:	50                   	push   %eax
   18a01:	e8 b8 12 ff ff       	call   9cbe <lodepng_free>
   18a06:	83 c4 10             	add    $0x10,%esp
   18a09:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   18a0d:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   18a11:	75 e0                	jne    189f3 <filter+0x7b6>
   18a13:	eb 07                	jmp    18a1c <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   18a15:	b8 58 00 00 00       	mov    $0x58,%eax
   18a1a:	eb 03                	jmp    18a1f <filter+0x7e2>

  return error;
   18a1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   18a1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   18a22:	c9                   	leave  
   18a23:	c3                   	ret    

00018a24 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   18a24:	55                   	push   %ebp
   18a25:	89 e5                	mov    %esp,%ebp
   18a27:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   18a2a:	8b 45 10             	mov    0x10(%ebp),%eax
   18a2d:	2b 45 14             	sub    0x14(%ebp),%eax
   18a30:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   18a33:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   18a3a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   18a41:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   18a48:	eb 65                	jmp    18aaf <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   18a4a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   18a51:	eb 2a                	jmp    18a7d <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   18a53:	ff 75 0c             	pushl  0xc(%ebp)
   18a56:	8d 45 e8             	lea    -0x18(%ebp),%eax
   18a59:	50                   	push   %eax
   18a5a:	e8 9d 60 ff ff       	call   eafc <readBitFromReversedStream>
   18a5f:	83 c4 08             	add    $0x8,%esp
   18a62:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   18a65:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   18a69:	50                   	push   %eax
   18a6a:	ff 75 08             	pushl  0x8(%ebp)
   18a6d:	8d 45 ec             	lea    -0x14(%ebp),%eax
   18a70:	50                   	push   %eax
   18a71:	e8 08 61 ff ff       	call   eb7e <setBitOfReversedStream>
   18a76:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   18a79:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   18a7d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18a80:	3b 45 14             	cmp    0x14(%ebp),%eax
   18a83:	7c ce                	jl     18a53 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   18a85:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   18a8c:	eb 15                	jmp    18aa3 <addPaddingBits+0x7f>
   18a8e:	6a 00                	push   $0x0
   18a90:	ff 75 08             	pushl  0x8(%ebp)
   18a93:	8d 45 ec             	lea    -0x14(%ebp),%eax
   18a96:	50                   	push   %eax
   18a97:	e8 e2 60 ff ff       	call   eb7e <setBitOfReversedStream>
   18a9c:	83 c4 0c             	add    $0xc,%esp
   18a9f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   18aa3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18aa6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   18aa9:	75 e3                	jne    18a8e <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   18aab:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   18aaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18ab2:	3b 45 18             	cmp    0x18(%ebp),%eax
   18ab5:	75 93                	jne    18a4a <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   18ab7:	90                   	nop
   18ab8:	c9                   	leave  
   18ab9:	c3                   	ret    

00018aba <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   18aba:	55                   	push   %ebp
   18abb:	89 e5                	mov    %esp,%ebp
   18abd:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   18ac3:	ff 75 18             	pushl  0x18(%ebp)
   18ac6:	ff 75 14             	pushl  0x14(%ebp)
   18ac9:	ff 75 10             	pushl  0x10(%ebp)
   18acc:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   18ad2:	50                   	push   %eax
   18ad3:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   18ad9:	50                   	push   %eax
   18ada:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   18ae0:	50                   	push   %eax
   18ae1:	8d 45 94             	lea    -0x6c(%ebp),%eax
   18ae4:	50                   	push   %eax
   18ae5:	8d 45 b0             	lea    -0x50(%ebp),%eax
   18ae8:	50                   	push   %eax
   18ae9:	e8 fc ae ff ff       	call   139ea <Adam7_getpassvalues>
   18aee:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   18af1:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   18af5:	0f 86 0a 01 00 00    	jbe    18c05 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   18afb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   18b02:	e9 ef 00 00 00       	jmp    18bf6 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   18b07:	8b 45 18             	mov    0x18(%ebp),%eax
   18b0a:	c1 e8 03             	shr    $0x3,%eax
   18b0d:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   18b10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   18b17:	e9 c6 00 00 00       	jmp    18be2 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   18b1c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   18b23:	e9 a6 00 00 00       	jmp    18bce <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   18b28:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18b2b:	8b 14 85 f8 0a 02 00 	mov    0x20af8(,%eax,4),%edx
   18b32:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18b35:	8b 04 85 30 0b 02 00 	mov    0x20b30(,%eax,4),%eax
   18b3c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   18b40:	01 d0                	add    %edx,%eax
   18b42:	0f af 45 10          	imul   0x10(%ebp),%eax
   18b46:	89 c2                	mov    %eax,%edx
   18b48:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18b4b:	8b 04 85 14 0b 02 00 	mov    0x20b14(,%eax,4),%eax
   18b52:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   18b56:	01 c2                	add    %eax,%edx
   18b58:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18b5b:	8b 04 85 dc 0a 02 00 	mov    0x20adc(,%eax,4),%eax
   18b62:	01 c2                	add    %eax,%edx
   18b64:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18b67:	0f af c2             	imul   %edx,%eax
   18b6a:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   18b6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18b70:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   18b77:	89 c1                	mov    %eax,%ecx
   18b79:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18b7c:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   18b80:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   18b84:	89 c2                	mov    %eax,%edx
   18b86:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18b89:	01 c2                	add    %eax,%edx
   18b8b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18b8e:	0f af c2             	imul   %edx,%eax
   18b91:	01 c8                	add    %ecx,%eax
   18b93:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   18b96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   18b9d:	eb 23                	jmp    18bc2 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   18b9f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   18ba2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18ba5:	01 c2                	add    %eax,%edx
   18ba7:	8b 45 08             	mov    0x8(%ebp),%eax
   18baa:	01 c2                	add    %eax,%edx
   18bac:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   18baf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18bb2:	01 c1                	add    %eax,%ecx
   18bb4:	8b 45 0c             	mov    0xc(%ebp),%eax
   18bb7:	01 c8                	add    %ecx,%eax
   18bb9:	0f b6 00             	movzbl (%eax),%eax
   18bbc:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   18bbe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   18bc2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18bc5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   18bc8:	72 d5                	jb     18b9f <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   18bca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   18bce:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18bd1:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   18bd5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   18bd8:	0f 87 4a ff ff ff    	ja     18b28 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   18bde:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   18be2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18be5:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   18be9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   18bec:	0f 87 2a ff ff ff    	ja     18b1c <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   18bf2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   18bf6:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   18bfa:	0f 85 07 ff ff ff    	jne    18b07 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   18c00:	e9 22 01 00 00       	jmp    18d27 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   18c05:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   18c0c:	e9 0c 01 00 00       	jmp    18d1d <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   18c11:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18c14:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   18c18:	0f af 45 18          	imul   0x18(%ebp),%eax
   18c1c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   18c1f:	8b 45 18             	mov    0x18(%ebp),%eax
   18c22:	0f af 45 10          	imul   0x10(%ebp),%eax
   18c26:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   18c29:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   18c30:	e9 d4 00 00 00       	jmp    18d09 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   18c35:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   18c3c:	e9 b4 00 00 00       	jmp    18cf5 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   18c41:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18c44:	8b 14 85 f8 0a 02 00 	mov    0x20af8(,%eax,4),%edx
   18c4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18c4e:	8b 04 85 30 0b 02 00 	mov    0x20b30(,%eax,4),%eax
   18c55:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   18c59:	01 d0                	add    %edx,%eax
   18c5b:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   18c5f:	89 c2                	mov    %eax,%edx
   18c61:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18c64:	8b 0c 85 dc 0a 02 00 	mov    0x20adc(,%eax,4),%ecx
   18c6b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18c6e:	8b 04 85 14 0b 02 00 	mov    0x20b14(,%eax,4),%eax
   18c75:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   18c79:	01 c8                	add    %ecx,%eax
   18c7b:	0f af 45 18          	imul   0x18(%ebp),%eax
   18c7f:	01 d0                	add    %edx,%eax
   18c81:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   18c87:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18c8a:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   18c91:	c1 e0 03             	shl    $0x3,%eax
   18c94:	89 c1                	mov    %eax,%ecx
   18c96:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18c99:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   18c9d:	89 c2                	mov    %eax,%edx
   18c9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18ca2:	0f af 45 18          	imul   0x18(%ebp),%eax
   18ca6:	01 d0                	add    %edx,%eax
   18ca8:	01 c8                	add    %ecx,%eax
   18caa:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   18cb0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   18cb7:	eb 30                	jmp    18ce9 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   18cb9:	ff 75 0c             	pushl  0xc(%ebp)
   18cbc:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   18cc2:	50                   	push   %eax
   18cc3:	e8 34 5e ff ff       	call   eafc <readBitFromReversedStream>
   18cc8:	83 c4 08             	add    $0x8,%esp
   18ccb:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   18cce:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   18cd2:	50                   	push   %eax
   18cd3:	ff 75 08             	pushl  0x8(%ebp)
   18cd6:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   18cdc:	50                   	push   %eax
   18cdd:	e8 9c 5e ff ff       	call   eb7e <setBitOfReversedStream>
   18ce2:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   18ce5:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   18ce9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18cec:	3b 45 18             	cmp    0x18(%ebp),%eax
   18cef:	72 c8                	jb     18cb9 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   18cf1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   18cf5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18cf8:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   18cfc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   18cff:	0f 87 3c ff ff ff    	ja     18c41 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   18d05:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   18d09:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18d0c:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   18d10:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   18d13:	0f 87 1c ff ff ff    	ja     18c35 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   18d19:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   18d1d:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   18d21:	0f 85 ea fe ff ff    	jne    18c11 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   18d27:	90                   	nop
   18d28:	c9                   	leave  
   18d29:	c3                   	ret    

00018d2a <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   18d2a:	55                   	push   %ebp
   18d2b:	89 e5                	mov    %esp,%ebp
   18d2d:	57                   	push   %edi
   18d2e:	56                   	push   %esi
   18d2f:	53                   	push   %ebx
   18d30:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   18d36:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18d39:	83 c0 0c             	add    $0xc,%eax
   18d3c:	50                   	push   %eax
   18d3d:	e8 77 6a ff ff       	call   f7b9 <lodepng_get_bpp>
   18d42:	83 c4 04             	add    $0x4,%esp
   18d45:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   18d48:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   18d4f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18d52:	8b 40 08             	mov    0x8(%eax),%eax
   18d55:	85 c0                	test   %eax,%eax
   18d57:	0f 85 49 01 00 00    	jne    18ea6 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   18d5d:	8b 45 14             	mov    0x14(%ebp),%eax
   18d60:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   18d64:	83 c0 07             	add    $0x7,%eax
   18d67:	c1 e8 03             	shr    $0x3,%eax
   18d6a:	83 c0 01             	add    $0x1,%eax
   18d6d:	0f af 45 18          	imul   0x18(%ebp),%eax
   18d71:	89 c2                	mov    %eax,%edx
   18d73:	8b 45 0c             	mov    0xc(%ebp),%eax
   18d76:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   18d78:	8b 45 0c             	mov    0xc(%ebp),%eax
   18d7b:	8b 00                	mov    (%eax),%eax
   18d7d:	83 ec 0c             	sub    $0xc,%esp
   18d80:	50                   	push   %eax
   18d81:	e8 17 0f ff ff       	call   9c9d <lodepng_malloc>
   18d86:	83 c4 10             	add    $0x10,%esp
   18d89:	89 c2                	mov    %eax,%edx
   18d8b:	8b 45 08             	mov    0x8(%ebp),%eax
   18d8e:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   18d90:	8b 45 08             	mov    0x8(%ebp),%eax
   18d93:	8b 00                	mov    (%eax),%eax
   18d95:	85 c0                	test   %eax,%eax
   18d97:	75 10                	jne    18da9 <preProcessScanlines+0x7f>
   18d99:	8b 45 0c             	mov    0xc(%ebp),%eax
   18d9c:	8b 00                	mov    (%eax),%eax
   18d9e:	85 c0                	test   %eax,%eax
   18da0:	74 07                	je     18da9 <preProcessScanlines+0x7f>
   18da2:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   18da9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   18dad:	0f 85 fb 02 00 00    	jne    190ae <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   18db3:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   18db7:	0f 87 bd 00 00 00    	ja     18e7a <preProcessScanlines+0x150>
   18dbd:	8b 45 14             	mov    0x14(%ebp),%eax
   18dc0:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   18dc4:	89 c2                	mov    %eax,%edx
   18dc6:	8b 45 14             	mov    0x14(%ebp),%eax
   18dc9:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   18dcd:	83 c0 07             	add    $0x7,%eax
   18dd0:	c1 e8 03             	shr    $0x3,%eax
   18dd3:	c1 e0 03             	shl    $0x3,%eax
   18dd6:	39 c2                	cmp    %eax,%edx
   18dd8:	0f 84 9c 00 00 00    	je     18e7a <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   18dde:	8b 45 14             	mov    0x14(%ebp),%eax
   18de1:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   18de5:	83 c0 07             	add    $0x7,%eax
   18de8:	c1 e8 03             	shr    $0x3,%eax
   18deb:	0f af 45 18          	imul   0x18(%ebp),%eax
   18def:	83 ec 0c             	sub    $0xc,%esp
   18df2:	50                   	push   %eax
   18df3:	e8 a5 0e ff ff       	call   9c9d <lodepng_malloc>
   18df8:	83 c4 10             	add    $0x10,%esp
   18dfb:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   18dfe:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   18e02:	75 07                	jne    18e0b <preProcessScanlines+0xe1>
   18e04:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   18e0b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   18e0f:	75 56                	jne    18e67 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   18e11:	8b 45 14             	mov    0x14(%ebp),%eax
   18e14:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   18e18:	89 c2                	mov    %eax,%edx
   18e1a:	8b 45 14             	mov    0x14(%ebp),%eax
   18e1d:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   18e21:	83 c0 07             	add    $0x7,%eax
   18e24:	c1 e8 03             	shr    $0x3,%eax
   18e27:	c1 e0 03             	shl    $0x3,%eax
   18e2a:	83 ec 0c             	sub    $0xc,%esp
   18e2d:	ff 75 18             	pushl  0x18(%ebp)
   18e30:	52                   	push   %edx
   18e31:	50                   	push   %eax
   18e32:	ff 75 10             	pushl  0x10(%ebp)
   18e35:	ff 75 d8             	pushl  -0x28(%ebp)
   18e38:	e8 e7 fb ff ff       	call   18a24 <addPaddingBits>
   18e3d:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   18e40:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18e43:	8d 50 0c             	lea    0xc(%eax),%edx
   18e46:	8b 45 08             	mov    0x8(%ebp),%eax
   18e49:	8b 00                	mov    (%eax),%eax
   18e4b:	83 ec 08             	sub    $0x8,%esp
   18e4e:	ff 75 20             	pushl  0x20(%ebp)
   18e51:	52                   	push   %edx
   18e52:	ff 75 18             	pushl  0x18(%ebp)
   18e55:	ff 75 14             	pushl  0x14(%ebp)
   18e58:	ff 75 d8             	pushl  -0x28(%ebp)
   18e5b:	50                   	push   %eax
   18e5c:	e8 dc f3 ff ff       	call   1823d <filter>
   18e61:	83 c4 20             	add    $0x20,%esp
   18e64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   18e67:	83 ec 0c             	sub    $0xc,%esp
   18e6a:	ff 75 d8             	pushl  -0x28(%ebp)
   18e6d:	e8 4c 0e ff ff       	call   9cbe <lodepng_free>
   18e72:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   18e75:	e9 34 02 00 00       	jmp    190ae <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   18e7a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18e7d:	8d 50 0c             	lea    0xc(%eax),%edx
   18e80:	8b 45 08             	mov    0x8(%ebp),%eax
   18e83:	8b 00                	mov    (%eax),%eax
   18e85:	83 ec 08             	sub    $0x8,%esp
   18e88:	ff 75 20             	pushl  0x20(%ebp)
   18e8b:	52                   	push   %edx
   18e8c:	ff 75 18             	pushl  0x18(%ebp)
   18e8f:	ff 75 14             	pushl  0x14(%ebp)
   18e92:	ff 75 10             	pushl  0x10(%ebp)
   18e95:	50                   	push   %eax
   18e96:	e8 a2 f3 ff ff       	call   1823d <filter>
   18e9b:	83 c4 20             	add    $0x20,%esp
   18e9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   18ea1:	e9 08 02 00 00       	jmp    190ae <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   18ea6:	ff 75 dc             	pushl  -0x24(%ebp)
   18ea9:	ff 75 18             	pushl  0x18(%ebp)
   18eac:	ff 75 14             	pushl  0x14(%ebp)
   18eaf:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   18eb5:	50                   	push   %eax
   18eb6:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   18ebc:	50                   	push   %eax
   18ebd:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   18ec3:	50                   	push   %eax
   18ec4:	8d 45 98             	lea    -0x68(%ebp),%eax
   18ec7:	50                   	push   %eax
   18ec8:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   18ecb:	50                   	push   %eax
   18ecc:	e8 19 ab ff ff       	call   139ea <Adam7_getpassvalues>
   18ed1:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   18ed4:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   18eda:	8b 45 0c             	mov    0xc(%ebp),%eax
   18edd:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   18edf:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ee2:	8b 00                	mov    (%eax),%eax
   18ee4:	83 ec 0c             	sub    $0xc,%esp
   18ee7:	50                   	push   %eax
   18ee8:	e8 b0 0d ff ff       	call   9c9d <lodepng_malloc>
   18eed:	83 c4 10             	add    $0x10,%esp
   18ef0:	89 c2                	mov    %eax,%edx
   18ef2:	8b 45 08             	mov    0x8(%ebp),%eax
   18ef5:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   18ef7:	8b 45 08             	mov    0x8(%ebp),%eax
   18efa:	8b 00                	mov    (%eax),%eax
   18efc:	85 c0                	test   %eax,%eax
   18efe:	75 07                	jne    18f07 <preProcessScanlines+0x1dd>
   18f00:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   18f07:	8b 45 94             	mov    -0x6c(%ebp),%eax
   18f0a:	83 ec 0c             	sub    $0xc,%esp
   18f0d:	50                   	push   %eax
   18f0e:	e8 8a 0d ff ff       	call   9c9d <lodepng_malloc>
   18f13:	83 c4 10             	add    $0x10,%esp
   18f16:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   18f19:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   18f1d:	75 0e                	jne    18f2d <preProcessScanlines+0x203>
   18f1f:	8b 45 94             	mov    -0x6c(%ebp),%eax
   18f22:	85 c0                	test   %eax,%eax
   18f24:	74 07                	je     18f2d <preProcessScanlines+0x203>
   18f26:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   18f2d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   18f31:	0f 85 69 01 00 00    	jne    190a0 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   18f37:	83 ec 0c             	sub    $0xc,%esp
   18f3a:	ff 75 dc             	pushl  -0x24(%ebp)
   18f3d:	ff 75 18             	pushl  0x18(%ebp)
   18f40:	ff 75 14             	pushl  0x14(%ebp)
   18f43:	ff 75 10             	pushl  0x10(%ebp)
   18f46:	ff 75 d4             	pushl  -0x2c(%ebp)
   18f49:	e8 6c fb ff ff       	call   18aba <Adam7_interlace>
   18f4e:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   18f51:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   18f58:	e9 36 01 00 00       	jmp    19093 <preProcessScanlines+0x369>
        if(bpp < 8) {
   18f5d:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   18f61:	0f 87 d6 00 00 00    	ja     1903d <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   18f67:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18f6a:	83 c0 01             	add    $0x1,%eax
   18f6d:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   18f74:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18f77:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   18f7e:	29 c2                	sub    %eax,%edx
   18f80:	89 d0                	mov    %edx,%eax
   18f82:	83 ec 0c             	sub    $0xc,%esp
   18f85:	50                   	push   %eax
   18f86:	e8 12 0d ff ff       	call   9c9d <lodepng_malloc>
   18f8b:	83 c4 10             	add    $0x10,%esp
   18f8e:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   18f91:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   18f95:	75 0c                	jne    18fa3 <preProcessScanlines+0x279>
   18f97:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   18f9e:	e9 fd 00 00 00       	jmp    190a0 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   18fa3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18fa6:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   18faa:	8b 55 e0             	mov    -0x20(%ebp),%edx
   18fad:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   18fb1:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   18fb5:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   18fb7:	8b 55 e0             	mov    -0x20(%ebp),%edx
   18fba:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   18fbe:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   18fc2:	83 c2 07             	add    $0x7,%edx
   18fc5:	c1 ea 03             	shr    $0x3,%edx
   18fc8:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   18fcb:	89 d1                	mov    %edx,%ecx
   18fcd:	8b 55 e0             	mov    -0x20(%ebp),%edx
   18fd0:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   18fd7:	89 d6                	mov    %edx,%esi
   18fd9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   18fdc:	01 f2                	add    %esi,%edx
   18fde:	83 ec 0c             	sub    $0xc,%esp
   18fe1:	50                   	push   %eax
   18fe2:	53                   	push   %ebx
   18fe3:	51                   	push   %ecx
   18fe4:	52                   	push   %edx
   18fe5:	ff 75 d0             	pushl  -0x30(%ebp)
   18fe8:	e8 37 fa ff ff       	call   18a24 <addPaddingBits>
   18fed:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   18ff0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   18ff3:	8d 58 0c             	lea    0xc(%eax),%ebx
   18ff6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18ff9:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   18ffd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19000:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   19004:	8b 4d 08             	mov    0x8(%ebp),%ecx
   19007:	8b 31                	mov    (%ecx),%esi
   19009:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1900c:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   19013:	01 f1                	add    %esi,%ecx
   19015:	83 ec 08             	sub    $0x8,%esp
   19018:	ff 75 20             	pushl  0x20(%ebp)
   1901b:	53                   	push   %ebx
   1901c:	52                   	push   %edx
   1901d:	50                   	push   %eax
   1901e:	ff 75 d0             	pushl  -0x30(%ebp)
   19021:	51                   	push   %ecx
   19022:	e8 16 f2 ff ff       	call   1823d <filter>
   19027:	83 c4 20             	add    $0x20,%esp
   1902a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   1902d:	83 ec 0c             	sub    $0xc,%esp
   19030:	ff 75 d0             	pushl  -0x30(%ebp)
   19033:	e8 86 0c ff ff       	call   9cbe <lodepng_free>
   19038:	83 c4 10             	add    $0x10,%esp
   1903b:	eb 4c                	jmp    19089 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   1903d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19040:	8d 70 0c             	lea    0xc(%eax),%esi
   19043:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19046:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   1904a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1904d:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   19051:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   19054:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   1905b:	89 cb                	mov    %ecx,%ebx
   1905d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   19060:	01 cb                	add    %ecx,%ebx
   19062:	8b 4d 08             	mov    0x8(%ebp),%ecx
   19065:	8b 39                	mov    (%ecx),%edi
   19067:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1906a:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   19071:	01 f9                	add    %edi,%ecx
   19073:	83 ec 08             	sub    $0x8,%esp
   19076:	ff 75 20             	pushl  0x20(%ebp)
   19079:	56                   	push   %esi
   1907a:	52                   	push   %edx
   1907b:	50                   	push   %eax
   1907c:	53                   	push   %ebx
   1907d:	51                   	push   %ecx
   1907e:	e8 ba f1 ff ff       	call   1823d <filter>
   19083:	83 c4 20             	add    $0x20,%esp
   19086:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   19089:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1908d:	75 10                	jne    1909f <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   1908f:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   19093:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   19097:	0f 85 c0 fe ff ff    	jne    18f5d <preProcessScanlines+0x233>
   1909d:	eb 01                	jmp    190a0 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   1909f:	90                   	nop
      }
    }

    lodepng_free(adam7);
   190a0:	83 ec 0c             	sub    $0xc,%esp
   190a3:	ff 75 d4             	pushl  -0x2c(%ebp)
   190a6:	e8 13 0c ff ff       	call   9cbe <lodepng_free>
   190ab:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   190ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   190b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
   190b4:	5b                   	pop    %ebx
   190b5:	5e                   	pop    %esi
   190b6:	5f                   	pop    %edi
   190b7:	5d                   	pop    %ebp
   190b8:	c3                   	ret    

000190b9 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   190b9:	55                   	push   %ebp
   190ba:	89 e5                	mov    %esp,%ebp
   190bc:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   190bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   190c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   190c5:	eb 47                	jmp    1910e <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   190c7:	8b 45 08             	mov    0x8(%ebp),%eax
   190ca:	8d 50 04             	lea    0x4(%eax),%edx
   190cd:	8b 45 08             	mov    0x8(%ebp),%eax
   190d0:	ff 75 fc             	pushl  -0x4(%ebp)
   190d3:	52                   	push   %edx
   190d4:	50                   	push   %eax
   190d5:	e8 73 5f ff ff       	call   f04d <lodepng_chunk_append>
   190da:	83 c4 0c             	add    $0xc,%esp
   190dd:	89 45 f8             	mov    %eax,-0x8(%ebp)
   190e0:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   190e4:	74 05                	je     190eb <addUnknownChunks+0x32>
   190e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   190e9:	eb 37                	jmp    19122 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   190eb:	8b 45 08             	mov    0x8(%ebp),%eax
   190ee:	8b 50 04             	mov    0x4(%eax),%edx
   190f1:	8b 45 08             	mov    0x8(%ebp),%eax
   190f4:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   190f7:	8b 55 10             	mov    0x10(%ebp),%edx
   190fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   190fd:	01 d0                	add    %edx,%eax
   190ff:	50                   	push   %eax
   19100:	ff 75 fc             	pushl  -0x4(%ebp)
   19103:	e8 ff 5c ff ff       	call   ee07 <lodepng_chunk_next>
   19108:	83 c4 08             	add    $0x8,%esp
   1910b:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   1910e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   19111:	8b 45 0c             	mov    0xc(%ebp),%eax
   19114:	29 c2                	sub    %eax,%edx
   19116:	89 d0                	mov    %edx,%eax
   19118:	3b 45 10             	cmp    0x10(%ebp),%eax
   1911b:	7c aa                	jl     190c7 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   1911d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   19122:	c9                   	leave  
   19123:	c3                   	ret    

00019124 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   19124:	55                   	push   %ebp
   19125:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   19127:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   1912b:	77 07                	ja     19134 <isGrayICCProfile+0x10>
   1912d:	b8 00 00 00 00       	mov    $0x0,%eax
   19132:	eb 40                	jmp    19174 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   19134:	8b 45 08             	mov    0x8(%ebp),%eax
   19137:	83 c0 10             	add    $0x10,%eax
   1913a:	0f b6 00             	movzbl (%eax),%eax
   1913d:	3c 47                	cmp    $0x47,%al
   1913f:	75 2e                	jne    1916f <isGrayICCProfile+0x4b>
   19141:	8b 45 08             	mov    0x8(%ebp),%eax
   19144:	83 c0 11             	add    $0x11,%eax
   19147:	0f b6 00             	movzbl (%eax),%eax
   1914a:	3c 52                	cmp    $0x52,%al
   1914c:	75 21                	jne    1916f <isGrayICCProfile+0x4b>
   1914e:	8b 45 08             	mov    0x8(%ebp),%eax
   19151:	83 c0 12             	add    $0x12,%eax
   19154:	0f b6 00             	movzbl (%eax),%eax
   19157:	3c 41                	cmp    $0x41,%al
   19159:	75 14                	jne    1916f <isGrayICCProfile+0x4b>
   1915b:	8b 45 08             	mov    0x8(%ebp),%eax
   1915e:	83 c0 13             	add    $0x13,%eax
   19161:	0f b6 00             	movzbl (%eax),%eax
   19164:	3c 59                	cmp    $0x59,%al
   19166:	75 07                	jne    1916f <isGrayICCProfile+0x4b>
   19168:	b8 01 00 00 00       	mov    $0x1,%eax
   1916d:	eb 05                	jmp    19174 <isGrayICCProfile+0x50>
   1916f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   19174:	5d                   	pop    %ebp
   19175:	c3                   	ret    

00019176 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   19176:	55                   	push   %ebp
   19177:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   19179:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   1917d:	77 07                	ja     19186 <isRGBICCProfile+0x10>
   1917f:	b8 00 00 00 00       	mov    $0x0,%eax
   19184:	eb 40                	jmp    191c6 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   19186:	8b 45 08             	mov    0x8(%ebp),%eax
   19189:	83 c0 10             	add    $0x10,%eax
   1918c:	0f b6 00             	movzbl (%eax),%eax
   1918f:	3c 52                	cmp    $0x52,%al
   19191:	75 2e                	jne    191c1 <isRGBICCProfile+0x4b>
   19193:	8b 45 08             	mov    0x8(%ebp),%eax
   19196:	83 c0 11             	add    $0x11,%eax
   19199:	0f b6 00             	movzbl (%eax),%eax
   1919c:	3c 47                	cmp    $0x47,%al
   1919e:	75 21                	jne    191c1 <isRGBICCProfile+0x4b>
   191a0:	8b 45 08             	mov    0x8(%ebp),%eax
   191a3:	83 c0 12             	add    $0x12,%eax
   191a6:	0f b6 00             	movzbl (%eax),%eax
   191a9:	3c 42                	cmp    $0x42,%al
   191ab:	75 14                	jne    191c1 <isRGBICCProfile+0x4b>
   191ad:	8b 45 08             	mov    0x8(%ebp),%eax
   191b0:	83 c0 13             	add    $0x13,%eax
   191b3:	0f b6 00             	movzbl (%eax),%eax
   191b6:	3c 20                	cmp    $0x20,%al
   191b8:	75 07                	jne    191c1 <isRGBICCProfile+0x4b>
   191ba:	b8 01 00 00 00       	mov    $0x1,%eax
   191bf:	eb 05                	jmp    191c6 <isRGBICCProfile+0x50>
   191c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   191c6:	5d                   	pop    %ebp
   191c7:	c3                   	ret    

000191c8 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   191c8:	55                   	push   %ebp
   191c9:	89 e5                	mov    %esp,%ebp
   191cb:	57                   	push   %edi
   191cc:	56                   	push   %esi
   191cd:	53                   	push   %ebx
   191ce:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   191d4:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   191db:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   191e2:	8d 45 b0             	lea    -0x50(%ebp),%eax
   191e5:	6a 00                	push   $0x0
   191e7:	6a 00                	push   $0x0
   191e9:	50                   	push   %eax
   191ea:	e8 6f 0d ff ff       	call   9f5e <ucvector_init>
   191ef:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   191f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   191f5:	05 98 00 00 00       	add    $0x98,%eax
   191fa:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   191fd:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19203:	50                   	push   %eax
   19204:	e8 3a 71 ff ff       	call   10343 <lodepng_info_init>
   19209:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   1920c:	8b 45 08             	mov    0x8(%ebp),%eax
   1920f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   19215:	8b 45 0c             	mov    0xc(%ebp),%eax
   19218:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   1921e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19221:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   19228:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   1922b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1922e:	8b 40 0c             	mov    0xc(%eax),%eax
   19231:	83 f8 03             	cmp    $0x3,%eax
   19234:	74 0a                	je     19240 <lodepng_encode+0x78>
   19236:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19239:	8b 40 6c             	mov    0x6c(%eax),%eax
   1923c:	85 c0                	test   %eax,%eax
   1923e:	74 29                	je     19269 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   19240:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19243:	8b 40 18             	mov    0x18(%eax),%eax
   19246:	85 c0                	test   %eax,%eax
   19248:	74 0d                	je     19257 <lodepng_encode+0x8f>
   1924a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1924d:	8b 40 18             	mov    0x18(%eax),%eax
   19250:	3d 00 01 00 00       	cmp    $0x100,%eax
   19255:	7e 12                	jle    19269 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   19257:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1925a:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   19261:	00 00 00 
    goto cleanup;
   19264:	e9 78 0c 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   19269:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1926c:	8b 40 38             	mov    0x38(%eax),%eax
   1926f:	83 f8 02             	cmp    $0x2,%eax
   19272:	76 12                	jbe    19286 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   19274:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19277:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   1927e:	00 00 00 
    goto cleanup;
   19281:	e9 5b 0c 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   19286:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19289:	8b 40 08             	mov    0x8(%eax),%eax
   1928c:	83 f8 01             	cmp    $0x1,%eax
   1928f:	76 12                	jbe    192a3 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   19291:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19294:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   1929b:	00 00 00 
    goto cleanup;
   1929e:	e9 3e 0c 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   192a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   192a6:	8b 50 10             	mov    0x10(%eax),%edx
   192a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   192ac:	8b 40 0c             	mov    0xc(%eax),%eax
   192af:	52                   	push   %edx
   192b0:	50                   	push   %eax
   192b1:	e8 a4 5f ff ff       	call   f25a <checkColorValidity>
   192b6:	83 c4 08             	add    $0x8,%esp
   192b9:	89 c2                	mov    %eax,%edx
   192bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   192be:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   192c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   192c7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   192cd:	85 c0                	test   %eax,%eax
   192cf:	0f 85 c6 0b 00 00    	jne    19e9b <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   192d5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   192d8:	8b 50 7c             	mov    0x7c(%eax),%edx
   192db:	8b 45 1c             	mov    0x1c(%ebp),%eax
   192de:	8b 40 78             	mov    0x78(%eax),%eax
   192e1:	52                   	push   %edx
   192e2:	50                   	push   %eax
   192e3:	e8 72 5f ff ff       	call   f25a <checkColorValidity>
   192e8:	83 c4 08             	add    $0x8,%esp
   192eb:	89 c2                	mov    %eax,%edx
   192ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
   192f0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   192f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   192f9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   192ff:	85 c0                	test   %eax,%eax
   19301:	0f 85 97 0b 00 00    	jne    19e9e <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   19307:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1930a:	05 98 00 00 00       	add    $0x98,%eax
   1930f:	83 ec 08             	sub    $0x8,%esp
   19312:	50                   	push   %eax
   19313:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19319:	50                   	push   %eax
   1931a:	e8 58 71 ff ff       	call   10477 <lodepng_info_copy>
   1931f:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   19322:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19325:	8b 40 5c             	mov    0x5c(%eax),%eax
   19328:	85 c0                	test   %eax,%eax
   1932a:	0f 84 3c 02 00 00    	je     1956c <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   19330:	83 ec 0c             	sub    $0xc,%esp
   19333:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   19339:	50                   	push   %eax
   1933a:	e8 5f 96 ff ff       	call   1299e <lodepng_color_stats_init>
   1933f:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   19342:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19345:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   1934b:	85 c0                	test   %eax,%eax
   1934d:	74 2d                	je     1937c <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   1934f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19352:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   19358:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1935b:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   19361:	83 ec 08             	sub    $0x8,%esp
   19364:	52                   	push   %edx
   19365:	50                   	push   %eax
   19366:	e8 b9 fd ff ff       	call   19124 <isGrayICCProfile>
   1936b:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   1936e:	85 c0                	test   %eax,%eax
   19370:	74 0a                	je     1937c <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   19372:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   19379:	00 00 00 
    }
    if(info_png->iccp_defined &&
   1937c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1937f:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   19385:	85 c0                	test   %eax,%eax
   19387:	74 2d                	je     193b6 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   19389:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1938c:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   19392:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19395:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1939b:	83 ec 08             	sub    $0x8,%esp
   1939e:	52                   	push   %edx
   1939f:	50                   	push   %eax
   193a0:	e8 d1 fd ff ff       	call   19176 <isRGBICCProfile>
   193a5:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   193a8:	85 c0                	test   %eax,%eax
   193aa:	74 0a                	je     193b6 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   193ac:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   193b3:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   193b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   193b9:	83 c0 78             	add    $0x78,%eax
   193bc:	83 ec 0c             	sub    $0xc,%esp
   193bf:	50                   	push   %eax
   193c0:	ff 75 18             	pushl  0x18(%ebp)
   193c3:	ff 75 14             	pushl  0x14(%ebp)
   193c6:	ff 75 10             	pushl  0x10(%ebp)
   193c9:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   193cf:	50                   	push   %eax
   193d0:	e8 e0 96 ff ff       	call   12ab5 <lodepng_compute_color_stats>
   193d5:	83 c4 20             	add    $0x20,%esp
   193d8:	89 c2                	mov    %eax,%edx
   193da:	8b 45 1c             	mov    0x1c(%ebp),%eax
   193dd:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   193e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   193e6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   193ec:	85 c0                	test   %eax,%eax
   193ee:	0f 85 ad 0a 00 00    	jne    19ea1 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   193f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   193f7:	8b 40 2c             	mov    0x2c(%eax),%eax
   193fa:	85 c0                	test   %eax,%eax
   193fc:	0f 84 be 00 00 00    	je     194c0 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   19402:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   19409:	00 00 00 
   1940c:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   19413:	00 00 00 
   19416:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   1941d:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   19420:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   19426:	83 ec 04             	sub    $0x4,%esp
   19429:	6a 10                	push   $0x10
   1942b:	6a 02                	push   $0x2
   1942d:	50                   	push   %eax
   1942e:	e8 15 61 ff ff       	call   f548 <lodepng_color_mode_make>
   19433:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   19436:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19439:	8d 58 0c             	lea    0xc(%eax),%ebx
   1943c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1943f:	8b 48 38             	mov    0x38(%eax),%ecx
   19442:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19445:	8b 50 34             	mov    0x34(%eax),%edx
   19448:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1944b:	8b 40 30             	mov    0x30(%eax),%eax
   1944e:	53                   	push   %ebx
   1944f:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   19455:	53                   	push   %ebx
   19456:	51                   	push   %ecx
   19457:	52                   	push   %edx
   19458:	50                   	push   %eax
   19459:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   1945f:	50                   	push   %eax
   19460:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   19466:	50                   	push   %eax
   19467:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   1946d:	50                   	push   %eax
   1946e:	e8 8a 92 ff ff       	call   126fd <lodepng_convert_rgb>
   19473:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   19476:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   1947c:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   19482:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   19488:	83 ec 0c             	sub    $0xc,%esp
   1948b:	68 ff ff 00 00       	push   $0xffff
   19490:	51                   	push   %ecx
   19491:	52                   	push   %edx
   19492:	50                   	push   %eax
   19493:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   19499:	50                   	push   %eax
   1949a:	e8 26 a1 ff ff       	call   135c5 <lodepng_color_stats_add>
   1949f:	83 c4 20             	add    $0x20,%esp
   194a2:	89 c2                	mov    %eax,%edx
   194a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   194a7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   194ad:	8b 45 1c             	mov    0x1c(%ebp),%eax
   194b0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   194b6:	85 c0                	test   %eax,%eax
   194b8:	74 06                	je     194c0 <lodepng_encode+0x2f8>
   194ba:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   194bb:	e9 e1 09 00 00       	jmp    19ea1 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   194c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   194c3:	8d 50 78             	lea    0x78(%eax),%edx
   194c6:	83 ec 04             	sub    $0x4,%esp
   194c9:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   194cf:	50                   	push   %eax
   194d0:	52                   	push   %edx
   194d1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   194d7:	83 c0 0c             	add    $0xc,%eax
   194da:	50                   	push   %eax
   194db:	e8 79 a1 ff ff       	call   13659 <auto_choose_color>
   194e0:	83 c4 10             	add    $0x10,%esp
   194e3:	89 c2                	mov    %eax,%edx
   194e5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   194e8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   194ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
   194f1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   194f7:	85 c0                	test   %eax,%eax
   194f9:	0f 85 a5 09 00 00    	jne    19ea4 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   194ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19502:	8b 40 2c             	mov    0x2c(%eax),%eax
   19505:	85 c0                	test   %eax,%eax
   19507:	74 63                	je     1956c <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   19509:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1950c:	8d 58 0c             	lea    0xc(%eax),%ebx
   1950f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19512:	8b 48 38             	mov    0x38(%eax),%ecx
   19515:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19518:	8b 50 34             	mov    0x34(%eax),%edx
   1951b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1951e:	8b 40 30             	mov    0x30(%eax),%eax
   19521:	53                   	push   %ebx
   19522:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   19528:	83 c3 0c             	add    $0xc,%ebx
   1952b:	53                   	push   %ebx
   1952c:	51                   	push   %ecx
   1952d:	52                   	push   %edx
   1952e:	50                   	push   %eax
   1952f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19535:	83 c0 38             	add    $0x38,%eax
   19538:	50                   	push   %eax
   19539:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1953f:	83 c0 34             	add    $0x34,%eax
   19542:	50                   	push   %eax
   19543:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19549:	83 c0 30             	add    $0x30,%eax
   1954c:	50                   	push   %eax
   1954d:	e8 ab 91 ff ff       	call   126fd <lodepng_convert_rgb>
   19552:	83 c4 20             	add    $0x20,%esp
   19555:	85 c0                	test   %eax,%eax
   19557:	74 13                	je     1956c <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   19559:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1955c:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   19563:	00 00 00 
        goto cleanup;
   19566:	90                   	nop
   19567:	e9 75 09 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   1956c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1956f:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   19575:	85 c0                	test   %eax,%eax
   19577:	0f 84 b2 00 00 00    	je     1962f <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   1957d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19580:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   19586:	8b 45 dc             	mov    -0x24(%ebp),%eax
   19589:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1958f:	83 ec 08             	sub    $0x8,%esp
   19592:	52                   	push   %edx
   19593:	50                   	push   %eax
   19594:	e8 8b fb ff ff       	call   19124 <isGrayICCProfile>
   19599:	83 c4 10             	add    $0x10,%esp
   1959c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   1959f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   195a2:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   195a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   195ab:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   195b1:	83 ec 08             	sub    $0x8,%esp
   195b4:	52                   	push   %edx
   195b5:	50                   	push   %eax
   195b6:	e8 bb fb ff ff       	call   19176 <isRGBICCProfile>
   195bb:	83 c4 10             	add    $0x10,%esp
   195be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   195c1:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   195c7:	85 c0                	test   %eax,%eax
   195c9:	74 0b                	je     195d6 <lodepng_encode+0x40e>
   195cb:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   195d1:	83 f8 04             	cmp    $0x4,%eax
   195d4:	75 07                	jne    195dd <lodepng_encode+0x415>
   195d6:	b8 01 00 00 00       	mov    $0x1,%eax
   195db:	eb 05                	jmp    195e2 <lodepng_encode+0x41a>
   195dd:	b8 00 00 00 00       	mov    $0x0,%eax
   195e2:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   195e5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   195e9:	75 18                	jne    19603 <lodepng_encode+0x43b>
   195eb:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   195ef:	75 12                	jne    19603 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   195f1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   195f4:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   195fb:	00 00 00 
      goto cleanup;
   195fe:	e9 de 08 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   19603:	8b 45 d8             	mov    -0x28(%ebp),%eax
   19606:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   19609:	74 24                	je     1962f <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   1960b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1960e:	8b 40 5c             	mov    0x5c(%eax),%eax
   19611:	85 c0                	test   %eax,%eax
   19613:	74 07                	je     1961c <lodepng_encode+0x454>
   19615:	ba 66 00 00 00       	mov    $0x66,%edx
   1961a:	eb 05                	jmp    19621 <lodepng_encode+0x459>
   1961c:	ba 65 00 00 00       	mov    $0x65,%edx
   19621:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19624:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   1962a:	e9 b2 08 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   1962f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19632:	83 c0 78             	add    $0x78,%eax
   19635:	83 ec 08             	sub    $0x8,%esp
   19638:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   1963e:	83 c2 0c             	add    $0xc,%edx
   19641:	52                   	push   %edx
   19642:	50                   	push   %eax
   19643:	e8 57 5f ff ff       	call   f59f <lodepng_color_mode_equal>
   19648:	83 c4 10             	add    $0x10,%esp
   1964b:	85 c0                	test   %eax,%eax
   1964d:	0f 85 f8 00 00 00    	jne    1974b <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   19653:	8b 55 14             	mov    0x14(%ebp),%edx
   19656:	8b 45 18             	mov    0x18(%ebp),%eax
   19659:	89 d3                	mov    %edx,%ebx
   1965b:	0f af d8             	imul   %eax,%ebx
   1965e:	83 ec 0c             	sub    $0xc,%esp
   19661:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19667:	83 c0 0c             	add    $0xc,%eax
   1966a:	50                   	push   %eax
   1966b:	e8 49 61 ff ff       	call   f7b9 <lodepng_get_bpp>
   19670:	83 c4 10             	add    $0x10,%esp
   19673:	0f af c3             	imul   %ebx,%eax
   19676:	83 c0 07             	add    $0x7,%eax
   19679:	c1 e8 03             	shr    $0x3,%eax
   1967c:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   1967f:	83 ec 0c             	sub    $0xc,%esp
   19682:	ff 75 cc             	pushl  -0x34(%ebp)
   19685:	e8 13 06 ff ff       	call   9c9d <lodepng_malloc>
   1968a:	83 c4 10             	add    $0x10,%esp
   1968d:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   19690:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   19694:	75 13                	jne    196a9 <lodepng_encode+0x4e1>
   19696:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   1969a:	74 0d                	je     196a9 <lodepng_encode+0x4e1>
   1969c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1969f:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   196a6:	00 00 00 
    if(!state->error) {
   196a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   196ac:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   196b2:	85 c0                	test   %eax,%eax
   196b4:	75 33                	jne    196e9 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   196b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   196b9:	83 c0 78             	add    $0x78,%eax
   196bc:	83 ec 08             	sub    $0x8,%esp
   196bf:	ff 75 18             	pushl  0x18(%ebp)
   196c2:	ff 75 14             	pushl  0x14(%ebp)
   196c5:	50                   	push   %eax
   196c6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   196cc:	83 c0 0c             	add    $0xc,%eax
   196cf:	50                   	push   %eax
   196d0:	ff 75 10             	pushl  0x10(%ebp)
   196d3:	ff 75 c8             	pushl  -0x38(%ebp)
   196d6:	e8 c9 8c ff ff       	call   123a4 <lodepng_convert>
   196db:	83 c4 20             	add    $0x20,%esp
   196de:	89 c2                	mov    %eax,%edx
   196e0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   196e3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   196e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   196ec:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   196f2:	85 c0                	test   %eax,%eax
   196f4:	75 35                	jne    1972b <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   196f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   196f9:	83 c0 38             	add    $0x38,%eax
   196fc:	83 ec 04             	sub    $0x4,%esp
   196ff:	50                   	push   %eax
   19700:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19706:	50                   	push   %eax
   19707:	ff 75 18             	pushl  0x18(%ebp)
   1970a:	ff 75 14             	pushl  0x14(%ebp)
   1970d:	ff 75 c8             	pushl  -0x38(%ebp)
   19710:	8d 45 bc             	lea    -0x44(%ebp),%eax
   19713:	50                   	push   %eax
   19714:	8d 45 c0             	lea    -0x40(%ebp),%eax
   19717:	50                   	push   %eax
   19718:	e8 0d f6 ff ff       	call   18d2a <preProcessScanlines>
   1971d:	83 c4 20             	add    $0x20,%esp
   19720:	89 c2                	mov    %eax,%edx
   19722:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19725:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   1972b:	83 ec 0c             	sub    $0xc,%esp
   1972e:	ff 75 c8             	pushl  -0x38(%ebp)
   19731:	e8 88 05 ff ff       	call   9cbe <lodepng_free>
   19736:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   19739:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1973c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19742:	85 c0                	test   %eax,%eax
   19744:	74 4b                	je     19791 <lodepng_encode+0x5c9>
   19746:	e9 96 07 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   1974b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1974e:	83 c0 38             	add    $0x38,%eax
   19751:	83 ec 04             	sub    $0x4,%esp
   19754:	50                   	push   %eax
   19755:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1975b:	50                   	push   %eax
   1975c:	ff 75 18             	pushl  0x18(%ebp)
   1975f:	ff 75 14             	pushl  0x14(%ebp)
   19762:	ff 75 10             	pushl  0x10(%ebp)
   19765:	8d 45 bc             	lea    -0x44(%ebp),%eax
   19768:	50                   	push   %eax
   19769:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1976c:	50                   	push   %eax
   1976d:	e8 b8 f5 ff ff       	call   18d2a <preProcessScanlines>
   19772:	83 c4 20             	add    $0x20,%esp
   19775:	89 c2                	mov    %eax,%edx
   19777:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1977a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   19780:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19783:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19789:	85 c0                	test   %eax,%eax
   1978b:	0f 85 16 07 00 00    	jne    19ea7 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   19791:	83 ec 0c             	sub    $0xc,%esp
   19794:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19797:	50                   	push   %eax
   19798:	e8 21 d9 ff ff       	call   170be <writeSignature>
   1979d:	83 c4 10             	add    $0x10,%esp
   197a0:	89 c2                	mov    %eax,%edx
   197a2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   197a5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   197ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   197ae:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   197b4:	85 c0                	test   %eax,%eax
   197b6:	0f 85 ee 06 00 00    	jne    19eaa <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   197bc:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   197c2:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   197c8:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   197ce:	83 ec 08             	sub    $0x8,%esp
   197d1:	51                   	push   %ecx
   197d2:	52                   	push   %edx
   197d3:	50                   	push   %eax
   197d4:	ff 75 18             	pushl  0x18(%ebp)
   197d7:	ff 75 14             	pushl  0x14(%ebp)
   197da:	8d 45 b0             	lea    -0x50(%ebp),%eax
   197dd:	50                   	push   %eax
   197de:	e8 4a d9 ff ff       	call   1712d <addChunk_IHDR>
   197e3:	83 c4 20             	add    $0x20,%esp
   197e6:	89 c2                	mov    %eax,%edx
   197e8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   197eb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   197f1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   197f4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   197fa:	85 c0                	test   %eax,%eax
   197fc:	0f 85 ab 06 00 00    	jne    19ead <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   19802:	8b 45 98             	mov    -0x68(%ebp),%eax
   19805:	85 c0                	test   %eax,%eax
   19807:	74 33                	je     1983c <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   19809:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   1980c:	8b 45 98             	mov    -0x68(%ebp),%eax
   1980f:	83 ec 04             	sub    $0x4,%esp
   19812:	52                   	push   %edx
   19813:	50                   	push   %eax
   19814:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19817:	50                   	push   %eax
   19818:	e8 9c f8 ff ff       	call   190b9 <addUnknownChunks>
   1981d:	83 c4 10             	add    $0x10,%esp
   19820:	89 c2                	mov    %eax,%edx
   19822:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19825:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1982b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1982e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19834:	85 c0                	test   %eax,%eax
   19836:	0f 85 74 06 00 00    	jne    19eb0 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   1983c:	8b 45 88             	mov    -0x78(%ebp),%eax
   1983f:	85 c0                	test   %eax,%eax
   19841:	74 39                	je     1987c <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   19843:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19846:	83 c0 38             	add    $0x38,%eax
   19849:	83 ec 04             	sub    $0x4,%esp
   1984c:	50                   	push   %eax
   1984d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19853:	50                   	push   %eax
   19854:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19857:	50                   	push   %eax
   19858:	e8 a4 e4 ff ff       	call   17d01 <addChunk_iCCP>
   1985d:	83 c4 10             	add    $0x10,%esp
   19860:	89 c2                	mov    %eax,%edx
   19862:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19865:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1986b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1986e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19874:	85 c0                	test   %eax,%eax
   19876:	0f 85 37 06 00 00    	jne    19eb3 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   1987c:	8b 45 80             	mov    -0x80(%ebp),%eax
   1987f:	85 c0                	test   %eax,%eax
   19881:	74 32                	je     198b5 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   19883:	83 ec 08             	sub    $0x8,%esp
   19886:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1988c:	50                   	push   %eax
   1988d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19890:	50                   	push   %eax
   19891:	e8 41 e4 ff ff       	call   17cd7 <addChunk_sRGB>
   19896:	83 c4 10             	add    $0x10,%esp
   19899:	89 c2                	mov    %eax,%edx
   1989b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1989e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   198a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   198a7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   198ad:	85 c0                	test   %eax,%eax
   198af:	0f 85 01 06 00 00    	jne    19eb6 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   198b5:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   198bb:	85 c0                	test   %eax,%eax
   198bd:	74 32                	je     198f1 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   198bf:	83 ec 08             	sub    $0x8,%esp
   198c2:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   198c8:	50                   	push   %eax
   198c9:	8d 45 b0             	lea    -0x50(%ebp),%eax
   198cc:	50                   	push   %eax
   198cd:	e8 a7 e2 ff ff       	call   17b79 <addChunk_gAMA>
   198d2:	83 c4 10             	add    $0x10,%esp
   198d5:	89 c2                	mov    %eax,%edx
   198d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   198da:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   198e0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   198e3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   198e9:	85 c0                	test   %eax,%eax
   198eb:	0f 85 c8 05 00 00    	jne    19eb9 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   198f1:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   198f7:	85 c0                	test   %eax,%eax
   198f9:	74 32                	je     1992d <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   198fb:	83 ec 08             	sub    $0x8,%esp
   198fe:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19904:	50                   	push   %eax
   19905:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19908:	50                   	push   %eax
   19909:	e8 c1 e2 ff ff       	call   17bcf <addChunk_cHRM>
   1990e:	83 c4 10             	add    $0x10,%esp
   19911:	89 c2                	mov    %eax,%edx
   19913:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19916:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1991c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1991f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19925:	85 c0                	test   %eax,%eax
   19927:	0f 85 8f 05 00 00    	jne    19ebc <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   1992d:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   19933:	83 f8 03             	cmp    $0x3,%eax
   19936:	75 35                	jne    1996d <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   19938:	83 ec 08             	sub    $0x8,%esp
   1993b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19941:	83 c0 0c             	add    $0xc,%eax
   19944:	50                   	push   %eax
   19945:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19948:	50                   	push   %eax
   19949:	e8 78 d8 ff ff       	call   171c6 <addChunk_PLTE>
   1994e:	83 c4 10             	add    $0x10,%esp
   19951:	89 c2                	mov    %eax,%edx
   19953:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19956:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1995c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1995f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19965:	85 c0                	test   %eax,%eax
   19967:	0f 85 52 05 00 00    	jne    19ebf <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   1996d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19970:	8b 40 6c             	mov    0x6c(%eax),%eax
   19973:	85 c0                	test   %eax,%eax
   19975:	74 4b                	je     199c2 <lodepng_encode+0x7fa>
   19977:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1997d:	83 f8 02             	cmp    $0x2,%eax
   19980:	74 0b                	je     1998d <lodepng_encode+0x7c5>
   19982:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   19988:	83 f8 06             	cmp    $0x6,%eax
   1998b:	75 35                	jne    199c2 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   1998d:	83 ec 08             	sub    $0x8,%esp
   19990:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19996:	83 c0 0c             	add    $0xc,%eax
   19999:	50                   	push   %eax
   1999a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1999d:	50                   	push   %eax
   1999e:	e8 23 d8 ff ff       	call   171c6 <addChunk_PLTE>
   199a3:	83 c4 10             	add    $0x10,%esp
   199a6:	89 c2                	mov    %eax,%edx
   199a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   199ab:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   199b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   199b4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   199ba:	85 c0                	test   %eax,%eax
   199bc:	0f 85 00 05 00 00    	jne    19ec2 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   199c2:	83 ec 08             	sub    $0x8,%esp
   199c5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   199cb:	83 c0 0c             	add    $0xc,%eax
   199ce:	50                   	push   %eax
   199cf:	8d 45 b0             	lea    -0x50(%ebp),%eax
   199d2:	50                   	push   %eax
   199d3:	e8 c4 d8 ff ff       	call   1729c <addChunk_tRNS>
   199d8:	83 c4 10             	add    $0x10,%esp
   199db:	89 c2                	mov    %eax,%edx
   199dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   199e0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   199e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   199e9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   199ef:	85 c0                	test   %eax,%eax
   199f1:	0f 85 ce 04 00 00    	jne    19ec5 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   199f7:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   199fd:	85 c0                	test   %eax,%eax
   199ff:	74 32                	je     19a33 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   19a01:	83 ec 08             	sub    $0x8,%esp
   19a04:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19a0a:	50                   	push   %eax
   19a0b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19a0e:	50                   	push   %eax
   19a0f:	e8 e4 de ff ff       	call   178f8 <addChunk_bKGD>
   19a14:	83 c4 10             	add    $0x10,%esp
   19a17:	89 c2                	mov    %eax,%edx
   19a19:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19a1c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   19a22:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19a25:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19a2b:	85 c0                	test   %eax,%eax
   19a2d:	0f 85 95 04 00 00    	jne    19ec8 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   19a33:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   19a39:	85 c0                	test   %eax,%eax
   19a3b:	74 32                	je     19a6f <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   19a3d:	83 ec 08             	sub    $0x8,%esp
   19a40:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19a46:	50                   	push   %eax
   19a47:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19a4a:	50                   	push   %eax
   19a4b:	e8 ac e0 ff ff       	call   17afc <addChunk_pHYs>
   19a50:	83 c4 10             	add    $0x10,%esp
   19a53:	89 c2                	mov    %eax,%edx
   19a55:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19a58:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   19a5e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19a61:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19a67:	85 c0                	test   %eax,%eax
   19a69:	0f 85 5c 04 00 00    	jne    19ecb <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   19a6f:	8b 45 9c             	mov    -0x64(%ebp),%eax
   19a72:	85 c0                	test   %eax,%eax
   19a74:	74 33                	je     19aa9 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   19a76:	8b 55 a8             	mov    -0x58(%ebp),%edx
   19a79:	8b 45 9c             	mov    -0x64(%ebp),%eax
   19a7c:	83 ec 04             	sub    $0x4,%esp
   19a7f:	52                   	push   %edx
   19a80:	50                   	push   %eax
   19a81:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19a84:	50                   	push   %eax
   19a85:	e8 2f f6 ff ff       	call   190b9 <addUnknownChunks>
   19a8a:	83 c4 10             	add    $0x10,%esp
   19a8d:	89 c2                	mov    %eax,%edx
   19a8f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19a92:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   19a98:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19a9b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19aa1:	85 c0                	test   %eax,%eax
   19aa3:	0f 85 25 04 00 00    	jne    19ece <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   19aa9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19aac:	8d 48 38             	lea    0x38(%eax),%ecx
   19aaf:	8b 55 bc             	mov    -0x44(%ebp),%edx
   19ab2:	8b 45 c0             	mov    -0x40(%ebp),%eax
   19ab5:	51                   	push   %ecx
   19ab6:	52                   	push   %edx
   19ab7:	50                   	push   %eax
   19ab8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19abb:	50                   	push   %eax
   19abc:	e8 bd d9 ff ff       	call   1747e <addChunk_IDAT>
   19ac1:	83 c4 10             	add    $0x10,%esp
   19ac4:	89 c2                	mov    %eax,%edx
   19ac6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19ac9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   19acf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19ad2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19ad8:	85 c0                	test   %eax,%eax
   19ada:	0f 85 f1 03 00 00    	jne    19ed1 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   19ae0:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   19ae6:	85 c0                	test   %eax,%eax
   19ae8:	74 35                	je     19b1f <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   19aea:	83 ec 08             	sub    $0x8,%esp
   19aed:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19af3:	83 c0 60             	add    $0x60,%eax
   19af6:	50                   	push   %eax
   19af7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19afa:	50                   	push   %eax
   19afb:	e8 5c df ff ff       	call   17a5c <addChunk_tIME>
   19b00:	83 c4 10             	add    $0x10,%esp
   19b03:	89 c2                	mov    %eax,%edx
   19b05:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19b08:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   19b0e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19b11:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19b17:	85 c0                	test   %eax,%eax
   19b19:	0f 85 b5 03 00 00    	jne    19ed4 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   19b1f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   19b26:	e9 12 01 00 00       	jmp    19c3d <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   19b2b:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   19b31:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19b34:	c1 e2 02             	shl    $0x2,%edx
   19b37:	01 d0                	add    %edx,%eax
   19b39:	8b 00                	mov    (%eax),%eax
   19b3b:	83 ec 0c             	sub    $0xc,%esp
   19b3e:	50                   	push   %eax
   19b3f:	e8 f5 01 ff ff       	call   9d39 <lodepng_strlen>
   19b44:	83 c4 10             	add    $0x10,%esp
   19b47:	83 f8 4f             	cmp    $0x4f,%eax
   19b4a:	7e 12                	jle    19b5e <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   19b4c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19b4f:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   19b56:	00 00 00 
        goto cleanup;
   19b59:	e9 83 03 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   19b5e:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   19b64:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19b67:	c1 e2 02             	shl    $0x2,%edx
   19b6a:	01 d0                	add    %edx,%eax
   19b6c:	8b 00                	mov    (%eax),%eax
   19b6e:	83 ec 0c             	sub    $0xc,%esp
   19b71:	50                   	push   %eax
   19b72:	e8 c2 01 ff ff       	call   9d39 <lodepng_strlen>
   19b77:	83 c4 10             	add    $0x10,%esp
   19b7a:	85 c0                	test   %eax,%eax
   19b7c:	7f 12                	jg     19b90 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   19b7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19b81:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   19b88:	00 00 00 
        goto cleanup;
   19b8b:	e9 51 03 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   19b90:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19b93:	8b 40 74             	mov    0x74(%eax),%eax
   19b96:	85 c0                	test   %eax,%eax
   19b98:	74 52                	je     19bec <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   19b9a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19b9d:	8d 48 38             	lea    0x38(%eax),%ecx
   19ba0:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   19ba6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19ba9:	c1 e2 02             	shl    $0x2,%edx
   19bac:	01 d0                	add    %edx,%eax
   19bae:	8b 10                	mov    (%eax),%edx
   19bb0:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   19bb6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   19bb9:	c1 e3 02             	shl    $0x2,%ebx
   19bbc:	01 d8                	add    %ebx,%eax
   19bbe:	8b 00                	mov    (%eax),%eax
   19bc0:	51                   	push   %ecx
   19bc1:	52                   	push   %edx
   19bc2:	50                   	push   %eax
   19bc3:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19bc6:	50                   	push   %eax
   19bc7:	e8 fa d9 ff ff       	call   175c6 <addChunk_zTXt>
   19bcc:	83 c4 10             	add    $0x10,%esp
   19bcf:	89 c2                	mov    %eax,%edx
   19bd1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19bd4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   19bda:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19bdd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19be3:	85 c0                	test   %eax,%eax
   19be5:	74 52                	je     19c39 <lodepng_encode+0xa71>
   19be7:	e9 f5 02 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   19bec:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   19bf2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19bf5:	c1 e2 02             	shl    $0x2,%edx
   19bf8:	01 d0                	add    %edx,%eax
   19bfa:	8b 10                	mov    (%eax),%edx
   19bfc:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   19c02:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   19c05:	c1 e1 02             	shl    $0x2,%ecx
   19c08:	01 c8                	add    %ecx,%eax
   19c0a:	8b 00                	mov    (%eax),%eax
   19c0c:	83 ec 04             	sub    $0x4,%esp
   19c0f:	52                   	push   %edx
   19c10:	50                   	push   %eax
   19c11:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19c14:	50                   	push   %eax
   19c15:	e8 ec d8 ff ff       	call   17506 <addChunk_tEXt>
   19c1a:	83 c4 10             	add    $0x10,%esp
   19c1d:	89 c2                	mov    %eax,%edx
   19c1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19c22:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   19c28:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19c2b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19c31:	85 c0                	test   %eax,%eax
   19c33:	0f 85 9e 02 00 00    	jne    19ed7 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   19c39:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   19c3d:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   19c43:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   19c46:	0f 85 df fe ff ff    	jne    19b2b <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   19c4c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19c4f:	8b 40 70             	mov    0x70(%eax),%eax
   19c52:	85 c0                	test   %eax,%eax
   19c54:	0f 84 e3 00 00 00    	je     19d3d <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   19c5a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   19c61:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   19c68:	e9 85 00 00 00       	jmp    19cf2 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   19c6d:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   19c73:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19c76:	c1 e2 02             	shl    $0x2,%edx
   19c79:	01 d0                	add    %edx,%eax
   19c7b:	8b 00                	mov    (%eax),%eax
   19c7d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   19c80:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   19c83:	0f b6 00             	movzbl (%eax),%eax
   19c86:	3c 4c                	cmp    $0x4c,%al
   19c88:	75 64                	jne    19cee <lodepng_encode+0xb26>
   19c8a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   19c8d:	83 c0 01             	add    $0x1,%eax
   19c90:	0f b6 00             	movzbl (%eax),%eax
   19c93:	3c 6f                	cmp    $0x6f,%al
   19c95:	75 57                	jne    19cee <lodepng_encode+0xb26>
   19c97:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   19c9a:	83 c0 02             	add    $0x2,%eax
   19c9d:	0f b6 00             	movzbl (%eax),%eax
   19ca0:	3c 64                	cmp    $0x64,%al
   19ca2:	75 4a                	jne    19cee <lodepng_encode+0xb26>
   19ca4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   19ca7:	83 c0 03             	add    $0x3,%eax
   19caa:	0f b6 00             	movzbl (%eax),%eax
   19cad:	3c 65                	cmp    $0x65,%al
   19caf:	75 3d                	jne    19cee <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   19cb1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   19cb4:	83 c0 04             	add    $0x4,%eax
   19cb7:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   19cba:	3c 50                	cmp    $0x50,%al
   19cbc:	75 30                	jne    19cee <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   19cbe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   19cc1:	83 c0 05             	add    $0x5,%eax
   19cc4:	0f b6 00             	movzbl (%eax),%eax
   19cc7:	3c 4e                	cmp    $0x4e,%al
   19cc9:	75 23                	jne    19cee <lodepng_encode+0xb26>
   19ccb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   19cce:	83 c0 06             	add    $0x6,%eax
   19cd1:	0f b6 00             	movzbl (%eax),%eax
   19cd4:	3c 47                	cmp    $0x47,%al
   19cd6:	75 16                	jne    19cee <lodepng_encode+0xb26>
   19cd8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   19cdb:	83 c0 07             	add    $0x7,%eax
   19cde:	0f b6 00             	movzbl (%eax),%eax
   19ce1:	84 c0                	test   %al,%al
   19ce3:	75 09                	jne    19cee <lodepng_encode+0xb26>
          already_added_id_text = 1;
   19ce5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   19cec:	eb 13                	jmp    19d01 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   19cee:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   19cf2:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   19cf8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   19cfb:	0f 85 6c ff ff ff    	jne    19c6d <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   19d01:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   19d05:	75 36                	jne    19d3d <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   19d07:	a1 60 53 02 00       	mov    0x25360,%eax
   19d0c:	83 ec 04             	sub    $0x4,%esp
   19d0f:	50                   	push   %eax
   19d10:	68 c4 0b 02 00       	push   $0x20bc4
   19d15:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19d18:	50                   	push   %eax
   19d19:	e8 e8 d7 ff ff       	call   17506 <addChunk_tEXt>
   19d1e:	83 c4 10             	add    $0x10,%esp
   19d21:	89 c2                	mov    %eax,%edx
   19d23:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19d26:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   19d2c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19d2f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19d35:	85 c0                	test   %eax,%eax
   19d37:	0f 85 9d 01 00 00    	jne    19eda <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   19d3d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   19d44:	e9 e6 00 00 00       	jmp    19e2f <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   19d49:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   19d4f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19d52:	c1 e2 02             	shl    $0x2,%edx
   19d55:	01 d0                	add    %edx,%eax
   19d57:	8b 00                	mov    (%eax),%eax
   19d59:	83 ec 0c             	sub    $0xc,%esp
   19d5c:	50                   	push   %eax
   19d5d:	e8 d7 ff fe ff       	call   9d39 <lodepng_strlen>
   19d62:	83 c4 10             	add    $0x10,%esp
   19d65:	83 f8 4f             	cmp    $0x4f,%eax
   19d68:	7e 12                	jle    19d7c <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   19d6a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19d6d:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   19d74:	00 00 00 
        goto cleanup;
   19d77:	e9 65 01 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   19d7c:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   19d82:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19d85:	c1 e2 02             	shl    $0x2,%edx
   19d88:	01 d0                	add    %edx,%eax
   19d8a:	8b 00                	mov    (%eax),%eax
   19d8c:	83 ec 0c             	sub    $0xc,%esp
   19d8f:	50                   	push   %eax
   19d90:	e8 a4 ff fe ff       	call   9d39 <lodepng_strlen>
   19d95:	83 c4 10             	add    $0x10,%esp
   19d98:	85 c0                	test   %eax,%eax
   19d9a:	7f 12                	jg     19dae <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   19d9c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19d9f:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   19da6:	00 00 00 
        goto cleanup;
   19da9:	e9 33 01 00 00       	jmp    19ee1 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   19dae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19db1:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   19db4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   19dba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19dbd:	c1 e2 02             	shl    $0x2,%edx
   19dc0:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   19dc2:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   19dc4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   19dca:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19dcd:	c1 e2 02             	shl    $0x2,%edx
   19dd0:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   19dd2:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   19dd4:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   19dda:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19ddd:	c1 e2 02             	shl    $0x2,%edx
   19de0:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   19de2:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   19de4:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   19dea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   19ded:	c1 e2 02             	shl    $0x2,%edx
   19df0:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   19df2:	8b 10                	mov    (%eax),%edx
   19df4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19df7:	8b 40 74             	mov    0x74(%eax),%eax
   19dfa:	83 ec 04             	sub    $0x4,%esp
   19dfd:	57                   	push   %edi
   19dfe:	56                   	push   %esi
   19dff:	53                   	push   %ebx
   19e00:	51                   	push   %ecx
   19e01:	52                   	push   %edx
   19e02:	50                   	push   %eax
   19e03:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19e06:	50                   	push   %eax
   19e07:	e8 dc d8 ff ff       	call   176e8 <addChunk_iTXt>
   19e0c:	83 c4 20             	add    $0x20,%esp
   19e0f:	89 c2                	mov    %eax,%edx
   19e11:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19e14:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   19e1a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19e1d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19e23:	85 c0                	test   %eax,%eax
   19e25:	0f 85 b2 00 00 00    	jne    19edd <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   19e2b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   19e2f:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   19e35:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   19e38:	0f 85 0b ff ff ff    	jne    19d49 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   19e3e:	8b 45 a0             	mov    -0x60(%ebp),%eax
   19e41:	85 c0                	test   %eax,%eax
   19e43:	74 2f                	je     19e74 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   19e45:	8b 55 ac             	mov    -0x54(%ebp),%edx
   19e48:	8b 45 a0             	mov    -0x60(%ebp),%eax
   19e4b:	83 ec 04             	sub    $0x4,%esp
   19e4e:	52                   	push   %edx
   19e4f:	50                   	push   %eax
   19e50:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19e53:	50                   	push   %eax
   19e54:	e8 60 f2 ff ff       	call   190b9 <addUnknownChunks>
   19e59:	83 c4 10             	add    $0x10,%esp
   19e5c:	89 c2                	mov    %eax,%edx
   19e5e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19e61:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   19e67:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19e6a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19e70:	85 c0                	test   %eax,%eax
   19e72:	75 6c                	jne    19ee0 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   19e74:	83 ec 0c             	sub    $0xc,%esp
   19e77:	8d 45 b0             	lea    -0x50(%ebp),%eax
   19e7a:	50                   	push   %eax
   19e7b:	e8 6d d6 ff ff       	call   174ed <addChunk_IEND>
   19e80:	83 c4 10             	add    $0x10,%esp
   19e83:	89 c2                	mov    %eax,%edx
   19e85:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19e88:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   19e8e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19e91:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   19e97:	85 c0                	test   %eax,%eax
   19e99:	eb 46                	jmp    19ee1 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   19e9b:	90                   	nop
   19e9c:	eb 43                	jmp    19ee1 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   19e9e:	90                   	nop
   19e9f:	eb 40                	jmp    19ee1 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   19ea1:	90                   	nop
   19ea2:	eb 3d                	jmp    19ee1 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   19ea4:	90                   	nop
   19ea5:	eb 3a                	jmp    19ee1 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   19ea7:	90                   	nop
   19ea8:	eb 37                	jmp    19ee1 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   19eaa:	90                   	nop
   19eab:	eb 34                	jmp    19ee1 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   19ead:	90                   	nop
   19eae:	eb 31                	jmp    19ee1 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   19eb0:	90                   	nop
   19eb1:	eb 2e                	jmp    19ee1 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   19eb3:	90                   	nop
   19eb4:	eb 2b                	jmp    19ee1 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   19eb6:	90                   	nop
   19eb7:	eb 28                	jmp    19ee1 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   19eb9:	90                   	nop
   19eba:	eb 25                	jmp    19ee1 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   19ebc:	90                   	nop
   19ebd:	eb 22                	jmp    19ee1 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   19ebf:	90                   	nop
   19ec0:	eb 1f                	jmp    19ee1 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   19ec2:	90                   	nop
   19ec3:	eb 1c                	jmp    19ee1 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   19ec5:	90                   	nop
   19ec6:	eb 19                	jmp    19ee1 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   19ec8:	90                   	nop
   19ec9:	eb 16                	jmp    19ee1 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   19ecb:	90                   	nop
   19ecc:	eb 13                	jmp    19ee1 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   19ece:	90                   	nop
   19ecf:	eb 10                	jmp    19ee1 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   19ed1:	90                   	nop
   19ed2:	eb 0d                	jmp    19ee1 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   19ed4:	90                   	nop
   19ed5:	eb 0a                	jmp    19ee1 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   19ed7:	90                   	nop
   19ed8:	eb 07                	jmp    19ee1 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   19eda:	90                   	nop
   19edb:	eb 04                	jmp    19ee1 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   19edd:	90                   	nop
   19ede:	eb 01                	jmp    19ee1 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   19ee0:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   19ee1:	83 ec 0c             	sub    $0xc,%esp
   19ee4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   19eea:	50                   	push   %eax
   19eeb:	e8 34 65 ff ff       	call   10424 <lodepng_info_cleanup>
   19ef0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   19ef3:	8b 45 c0             	mov    -0x40(%ebp),%eax
   19ef6:	83 ec 0c             	sub    $0xc,%esp
   19ef9:	50                   	push   %eax
   19efa:	e8 bf fd fe ff       	call   9cbe <lodepng_free>
   19eff:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   19f02:	8b 55 b0             	mov    -0x50(%ebp),%edx
   19f05:	8b 45 08             	mov    0x8(%ebp),%eax
   19f08:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   19f0a:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   19f0d:	8b 45 0c             	mov    0xc(%ebp),%eax
   19f10:	89 10                	mov    %edx,(%eax)

  return state->error;
   19f12:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19f15:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   19f1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   19f1e:	5b                   	pop    %ebx
   19f1f:	5e                   	pop    %esi
   19f20:	5f                   	pop    %edi
   19f21:	5d                   	pop    %ebp
   19f22:	c3                   	ret    

00019f23 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   19f23:	55                   	push   %ebp
   19f24:	89 e5                	mov    %esp,%ebp
   19f26:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   19f2c:	83 ec 0c             	sub    $0xc,%esp
   19f2f:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   19f35:	50                   	push   %eax
   19f36:	e8 38 d0 ff ff       	call   16f73 <lodepng_state_init>
   19f3b:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   19f3e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19f41:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   19f47:	8b 45 20             	mov    0x20(%ebp),%eax
   19f4a:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   19f50:	8b 45 1c             	mov    0x1c(%ebp),%eax
   19f53:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   19f59:	8b 45 20             	mov    0x20(%ebp),%eax
   19f5c:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   19f62:	83 ec 08             	sub    $0x8,%esp
   19f65:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   19f6b:	50                   	push   %eax
   19f6c:	ff 75 18             	pushl  0x18(%ebp)
   19f6f:	ff 75 14             	pushl  0x14(%ebp)
   19f72:	ff 75 10             	pushl  0x10(%ebp)
   19f75:	ff 75 0c             	pushl  0xc(%ebp)
   19f78:	ff 75 08             	pushl  0x8(%ebp)
   19f7b:	e8 48 f2 ff ff       	call   191c8 <lodepng_encode>
   19f80:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   19f83:	8b 45 f0             	mov    -0x10(%ebp),%eax
   19f86:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   19f89:	83 ec 0c             	sub    $0xc,%esp
   19f8c:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   19f92:	50                   	push   %eax
   19f93:	e8 35 d0 ff ff       	call   16fcd <lodepng_state_cleanup>
   19f98:	83 c4 10             	add    $0x10,%esp
  return error;
   19f9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   19f9e:	c9                   	leave  
   19f9f:	c3                   	ret    

00019fa0 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   19fa0:	55                   	push   %ebp
   19fa1:	89 e5                	mov    %esp,%ebp
   19fa3:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   19fa6:	83 ec 04             	sub    $0x4,%esp
   19fa9:	6a 08                	push   $0x8
   19fab:	6a 06                	push   $0x6
   19fad:	ff 75 18             	pushl  0x18(%ebp)
   19fb0:	ff 75 14             	pushl  0x14(%ebp)
   19fb3:	ff 75 10             	pushl  0x10(%ebp)
   19fb6:	ff 75 0c             	pushl  0xc(%ebp)
   19fb9:	ff 75 08             	pushl  0x8(%ebp)
   19fbc:	e8 62 ff ff ff       	call   19f23 <lodepng_encode_memory>
   19fc1:	83 c4 20             	add    $0x20,%esp
}
   19fc4:	c9                   	leave  
   19fc5:	c3                   	ret    

00019fc6 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   19fc6:	55                   	push   %ebp
   19fc7:	89 e5                	mov    %esp,%ebp
   19fc9:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   19fcc:	83 ec 04             	sub    $0x4,%esp
   19fcf:	6a 08                	push   $0x8
   19fd1:	6a 02                	push   $0x2
   19fd3:	ff 75 18             	pushl  0x18(%ebp)
   19fd6:	ff 75 14             	pushl  0x14(%ebp)
   19fd9:	ff 75 10             	pushl  0x10(%ebp)
   19fdc:	ff 75 0c             	pushl  0xc(%ebp)
   19fdf:	ff 75 08             	pushl  0x8(%ebp)
   19fe2:	e8 3c ff ff ff       	call   19f23 <lodepng_encode_memory>
   19fe7:	83 c4 20             	add    $0x20,%esp
}
   19fea:	c9                   	leave  
   19feb:	c3                   	ret    

00019fec <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   19fec:	55                   	push   %ebp
   19fed:	89 e5                	mov    %esp,%ebp
   19fef:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   19ff2:	83 ec 04             	sub    $0x4,%esp
   19ff5:	ff 75 1c             	pushl  0x1c(%ebp)
   19ff8:	ff 75 18             	pushl  0x18(%ebp)
   19ffb:	ff 75 14             	pushl  0x14(%ebp)
   19ffe:	ff 75 10             	pushl  0x10(%ebp)
   1a001:	ff 75 0c             	pushl  0xc(%ebp)
   1a004:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1a007:	50                   	push   %eax
   1a008:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1a00b:	50                   	push   %eax
   1a00c:	e8 12 ff ff ff       	call   19f23 <lodepng_encode_memory>
   1a011:	83 c4 20             	add    $0x20,%esp
   1a014:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   1a017:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1a01b:	75 19                	jne    1a036 <lodepng_encode_file+0x4a>
   1a01d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1a020:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1a023:	83 ec 04             	sub    $0x4,%esp
   1a026:	ff 75 08             	pushl  0x8(%ebp)
   1a029:	52                   	push   %edx
   1a02a:	50                   	push   %eax
   1a02b:	e8 36 01 ff ff       	call   a166 <lodepng_save_file>
   1a030:	83 c4 10             	add    $0x10,%esp
   1a033:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   1a036:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1a039:	83 ec 0c             	sub    $0xc,%esp
   1a03c:	50                   	push   %eax
   1a03d:	e8 7c fc fe ff       	call   9cbe <lodepng_free>
   1a042:	83 c4 10             	add    $0x10,%esp
  return error;
   1a045:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1a048:	c9                   	leave  
   1a049:	c3                   	ret    

0001a04a <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   1a04a:	55                   	push   %ebp
   1a04b:	89 e5                	mov    %esp,%ebp
   1a04d:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   1a050:	83 ec 08             	sub    $0x8,%esp
   1a053:	6a 08                	push   $0x8
   1a055:	6a 06                	push   $0x6
   1a057:	ff 75 14             	pushl  0x14(%ebp)
   1a05a:	ff 75 10             	pushl  0x10(%ebp)
   1a05d:	ff 75 0c             	pushl  0xc(%ebp)
   1a060:	ff 75 08             	pushl  0x8(%ebp)
   1a063:	e8 84 ff ff ff       	call   19fec <lodepng_encode_file>
   1a068:	83 c4 20             	add    $0x20,%esp
}
   1a06b:	c9                   	leave  
   1a06c:	c3                   	ret    

0001a06d <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   1a06d:	55                   	push   %ebp
   1a06e:	89 e5                	mov    %esp,%ebp
   1a070:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   1a073:	83 ec 08             	sub    $0x8,%esp
   1a076:	6a 08                	push   $0x8
   1a078:	6a 02                	push   $0x2
   1a07a:	ff 75 14             	pushl  0x14(%ebp)
   1a07d:	ff 75 10             	pushl  0x10(%ebp)
   1a080:	ff 75 0c             	pushl  0xc(%ebp)
   1a083:	ff 75 08             	pushl  0x8(%ebp)
   1a086:	e8 61 ff ff ff       	call   19fec <lodepng_encode_file>
   1a08b:	83 c4 20             	add    $0x20,%esp
}
   1a08e:	c9                   	leave  
   1a08f:	c3                   	ret    

0001a090 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   1a090:	55                   	push   %ebp
   1a091:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   1a093:	8b 45 08             	mov    0x8(%ebp),%eax
   1a096:	50                   	push   %eax
   1a097:	e8 71 49 ff ff       	call   ea0d <lodepng_compress_settings_init>
   1a09c:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   1a09f:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0a2:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   1a0a9:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0ac:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   1a0b3:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0b6:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   1a0bd:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0c0:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   1a0c7:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0ca:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   1a0d1:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0d4:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   1a0db:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0de:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   1a0e5:	90                   	nop
   1a0e6:	c9                   	leave  
   1a0e7:	c3                   	ret    

0001a0e8 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   1a0e8:	55                   	push   %ebp
   1a0e9:	89 e5                	mov    %esp,%ebp
  switch(code) {
   1a0eb:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   1a0ef:	0f 87 c1 03 00 00    	ja     1a4b6 <lodepng_error_text+0x3ce>
   1a0f5:	8b 45 08             	mov    0x8(%ebp),%eax
   1a0f8:	c1 e0 02             	shl    $0x2,%eax
   1a0fb:	05 00 1f 02 00       	add    $0x21f00,%eax
   1a100:	8b 00                	mov    (%eax),%eax
   1a102:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   1a104:	b8 cc 0b 02 00       	mov    $0x20bcc,%eax
   1a109:	e9 ad 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   1a10e:	b8 e9 0b 02 00       	mov    $0x20be9,%eax
   1a113:	e9 a3 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   1a118:	b8 fc 0b 02 00       	mov    $0x20bfc,%eax
   1a11d:	e9 99 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   1a122:	b8 34 0c 02 00       	mov    $0x20c34,%eax
   1a127:	e9 8f 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   1a12c:	b8 6c 0c 02 00       	mov    $0x20c6c,%eax
   1a131:	e9 85 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   1a136:	b8 6c 0c 02 00       	mov    $0x20c6c,%eax
   1a13b:	e9 7b 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   1a140:	b8 6c 0c 02 00       	mov    $0x20c6c,%eax
   1a145:	e9 71 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   1a14a:	b8 9c 0c 02 00       	mov    $0x20c9c,%eax
   1a14f:	e9 67 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   1a154:	b8 d0 0c 02 00       	mov    $0x20cd0,%eax
   1a159:	e9 5d 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   1a15e:	b8 04 0d 02 00       	mov    $0x20d04,%eax
   1a163:	e9 53 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   1a168:	b8 d0 0c 02 00       	mov    $0x20cd0,%eax
   1a16d:	e9 49 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   1a172:	b8 2c 0d 02 00       	mov    $0x20d2c,%eax
   1a177:	e9 3f 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   1a17c:	b8 64 0d 02 00       	mov    $0x20d64,%eax
   1a181:	e9 35 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   1a186:	b8 d0 0c 02 00       	mov    $0x20cd0,%eax
   1a18b:	e9 2b 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   1a190:	b8 9c 0d 02 00       	mov    $0x20d9c,%eax
   1a195:	e9 21 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   1a19a:	b8 cc 0d 02 00       	mov    $0x20dcc,%eax
   1a19f:	e9 17 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   1a1a4:	b8 ec 0d 02 00       	mov    $0x20dec,%eax
   1a1a9:	e9 0d 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   1a1ae:	b8 18 0e 02 00       	mov    $0x20e18,%eax
   1a1b3:	e9 03 03 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   1a1b8:	b8 58 0e 02 00       	mov    $0x20e58,%eax
   1a1bd:	e9 f9 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   1a1c2:	b8 80 0e 02 00       	mov    $0x20e80,%eax
   1a1c7:	e9 ef 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   1a1cc:	b8 b4 0e 02 00       	mov    $0x20eb4,%eax
   1a1d1:	e9 e5 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   1a1d6:	b8 d8 0e 02 00       	mov    $0x20ed8,%eax
   1a1db:	e9 db 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   1a1e0:	b8 10 0f 02 00       	mov    $0x20f10,%eax
   1a1e5:	e9 d1 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   1a1ea:	b8 30 0f 02 00       	mov    $0x20f30,%eax
   1a1ef:	e9 c7 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   1a1f4:	b8 4f 0f 02 00       	mov    $0x20f4f,%eax
   1a1f9:	e9 bd 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   1a1fe:	b8 69 0f 02 00       	mov    $0x20f69,%eax
   1a203:	e9 b3 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   1a208:	b8 88 0f 02 00       	mov    $0x20f88,%eax
   1a20d:	e9 a9 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   1a212:	b8 c4 0f 02 00       	mov    $0x20fc4,%eax
   1a217:	e9 9f 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   1a21c:	b8 e8 0f 02 00       	mov    $0x20fe8,%eax
   1a221:	e9 95 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   1a226:	b8 14 10 02 00       	mov    $0x21014,%eax
   1a22b:	e9 8b 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   1a230:	b8 38 10 02 00       	mov    $0x21038,%eax
   1a235:	e9 81 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   1a23a:	b8 78 10 02 00       	mov    $0x21078,%eax
   1a23f:	e9 77 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   1a244:	b8 a8 10 02 00       	mov    $0x210a8,%eax
   1a249:	e9 6d 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   1a24e:	b8 d0 10 02 00       	mov    $0x210d0,%eax
   1a253:	e9 63 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   1a258:	b8 14 11 02 00       	mov    $0x21114,%eax
   1a25d:	e9 59 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   1a262:	b8 40 11 02 00       	mov    $0x21140,%eax
   1a267:	e9 4f 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   1a26c:	b8 70 11 02 00       	mov    $0x21170,%eax
   1a271:	e9 45 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   1a276:	b8 98 11 02 00       	mov    $0x21198,%eax
   1a27b:	e9 3b 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   1a280:	b8 e0 11 02 00       	mov    $0x211e0,%eax
   1a285:	e9 31 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   1a28a:	b8 e0 11 02 00       	mov    $0x211e0,%eax
   1a28f:	e9 27 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   1a294:	b8 1c 12 02 00       	mov    $0x2121c,%eax
   1a299:	e9 1d 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   1a29e:	b8 50 12 02 00       	mov    $0x21250,%eax
   1a2a3:	e9 13 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   1a2a8:	b8 73 12 02 00       	mov    $0x21273,%eax
   1a2ad:	e9 09 02 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   1a2b2:	b8 90 12 02 00       	mov    $0x21290,%eax
   1a2b7:	e9 ff 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   1a2bc:	b8 cc 12 02 00       	mov    $0x212cc,%eax
   1a2c1:	e9 f5 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   1a2c6:	b8 fc 12 02 00       	mov    $0x212fc,%eax
   1a2cb:	e9 eb 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   1a2d0:	b8 48 13 02 00       	mov    $0x21348,%eax
   1a2d5:	e9 e1 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   1a2da:	b8 80 13 02 00       	mov    $0x21380,%eax
   1a2df:	e9 d7 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   1a2e4:	b8 c0 13 02 00       	mov    $0x213c0,%eax
   1a2e9:	e9 cd 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   1a2ee:	b8 ec 13 02 00       	mov    $0x213ec,%eax
   1a2f3:	e9 c3 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   1a2f8:	b8 38 14 02 00       	mov    $0x21438,%eax
   1a2fd:	e9 b9 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   1a302:	b8 8c 14 02 00       	mov    $0x2148c,%eax
   1a307:	e9 af 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   1a30c:	b8 c0 14 02 00       	mov    $0x214c0,%eax
   1a311:	e9 a5 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   1a316:	b8 10 15 02 00       	mov    $0x21510,%eax
   1a31b:	e9 9b 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   1a320:	b8 4c 15 02 00       	mov    $0x2154c,%eax
   1a325:	e9 91 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   1a32a:	b8 ac 15 02 00       	mov    $0x215ac,%eax
   1a32f:	e9 87 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   1a334:	b8 0c 16 02 00       	mov    $0x2160c,%eax
   1a339:	e9 7d 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   1a33e:	b8 68 16 02 00       	mov    $0x21668,%eax
   1a343:	e9 73 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   1a348:	b8 ac 16 02 00       	mov    $0x216ac,%eax
   1a34d:	e9 69 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   1a352:	b8 e8 16 02 00       	mov    $0x216e8,%eax
   1a357:	e9 5f 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   1a35c:	b8 45 17 02 00       	mov    $0x21745,%eax
   1a361:	e9 55 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   1a366:	b8 5d 17 02 00       	mov    $0x2175d,%eax
   1a36b:	e9 4b 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   1a370:	b8 78 17 02 00       	mov    $0x21778,%eax
   1a375:	e9 41 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   1a37a:	b8 b4 17 02 00       	mov    $0x217b4,%eax
   1a37f:	e9 37 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   1a384:	b8 e4 17 02 00       	mov    $0x217e4,%eax
   1a389:	e9 2d 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   1a38e:	b8 04 18 02 00       	mov    $0x21804,%eax
   1a393:	e9 23 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   1a398:	b8 24 18 02 00       	mov    $0x21824,%eax
   1a39d:	e9 19 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   1a3a2:	b8 44 18 02 00       	mov    $0x21844,%eax
   1a3a7:	e9 0f 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   1a3ac:	b8 68 18 02 00       	mov    $0x21868,%eax
   1a3b1:	e9 05 01 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   1a3b6:	b8 90 18 02 00       	mov    $0x21890,%eax
   1a3bb:	e9 fb 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   1a3c0:	b8 ed 18 02 00       	mov    $0x218ed,%eax
   1a3c5:	e9 f1 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   1a3ca:	b8 08 19 02 00       	mov    $0x21908,%eax
   1a3cf:	e9 e7 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   1a3d4:	b8 44 19 02 00       	mov    $0x21944,%eax
   1a3d9:	e9 dd 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   1a3de:	b8 78 19 02 00       	mov    $0x21978,%eax
   1a3e3:	e9 d3 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   1a3e8:	b8 cc 19 02 00       	mov    $0x219cc,%eax
   1a3ed:	e9 c9 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   1a3f2:	b8 18 1a 02 00       	mov    $0x21a18,%eax
   1a3f7:	e9 bf 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   1a3fc:	b8 54 1a 02 00       	mov    $0x21a54,%eax
   1a401:	e9 b5 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   1a406:	b8 78 1a 02 00       	mov    $0x21a78,%eax
   1a40b:	e9 ab 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   1a410:	b8 98 1a 02 00       	mov    $0x21a98,%eax
   1a415:	e9 a1 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   1a41a:	b8 c0 1a 02 00       	mov    $0x21ac0,%eax
   1a41f:	e9 97 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   1a424:	b8 e0 1a 02 00       	mov    $0x21ae0,%eax
   1a429:	e9 8d 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   1a42e:	b8 0c 1b 02 00       	mov    $0x21b0c,%eax
   1a433:	e9 83 00 00 00       	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   1a438:	b8 3b 1b 02 00       	mov    $0x21b3b,%eax
   1a43d:	eb 7c                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   1a43f:	b8 53 1b 02 00       	mov    $0x21b53,%eax
   1a444:	eb 75                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   1a446:	b8 6b 1b 02 00       	mov    $0x21b6b,%eax
   1a44b:	eb 6e                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   1a44d:	b8 83 1b 02 00       	mov    $0x21b83,%eax
   1a452:	eb 67                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   1a454:	b8 a4 1b 02 00       	mov    $0x21ba4,%eax
   1a459:	eb 60                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   1a45b:	b8 f4 1b 02 00       	mov    $0x21bf4,%eax
   1a460:	eb 59                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   1a462:	b8 48 1c 02 00       	mov    $0x21c48,%eax
   1a467:	eb 52                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   1a469:	b8 9c 1c 02 00       	mov    $0x21c9c,%eax
   1a46e:	eb 4b                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   1a470:	b8 e4 1c 02 00       	mov    $0x21ce4,%eax
   1a475:	eb 44                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   1a477:	b8 28 1d 02 00       	mov    $0x21d28,%eax
   1a47c:	eb 3d                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   1a47e:	b8 44 1d 02 00       	mov    $0x21d44,%eax
   1a483:	eb 36                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   1a485:	b8 7c 1d 02 00       	mov    $0x21d7c,%eax
   1a48a:	eb 2f                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   1a48c:	b8 d0 1d 02 00       	mov    $0x21dd0,%eax
   1a491:	eb 28                	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   1a493:	b8 00 1e 02 00       	mov    $0x21e00,%eax
   1a498:	eb 21                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   1a49a:	b8 50 1e 02 00       	mov    $0x21e50,%eax
   1a49f:	eb 1a                	jmp    1a4bb <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   1a4a1:	b8 7c 1e 02 00       	mov    $0x21e7c,%eax
   1a4a6:	eb 13                	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   1a4a8:	b8 a8 1e 02 00       	mov    $0x21ea8,%eax
   1a4ad:	eb 0c                	jmp    1a4bb <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   1a4af:	b8 cc 1e 02 00       	mov    $0x21ecc,%eax
   1a4b4:	eb 05                	jmp    1a4bb <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   1a4b6:	b8 eb 1e 02 00       	mov    $0x21eeb,%eax
}
   1a4bb:	5d                   	pop    %ebp
   1a4bc:	c3                   	ret    

0001a4bd <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   1a4bd:	55                   	push   %ebp
   1a4be:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   1a4c0:	8b 45 08             	mov    0x8(%ebp),%eax
   1a4c3:	8b 40 28             	mov    0x28(%eax),%eax
   1a4c6:	83 f8 01             	cmp    $0x1,%eax
   1a4c9:	75 08                	jne    1a4d3 <GetImage+0x16>
   1a4cb:	8b 45 08             	mov    0x8(%ebp),%eax
   1a4ce:	8b 40 54             	mov    0x54(%eax),%eax
   1a4d1:	eb 09                	jmp    1a4dc <GetImage+0x1f>
   1a4d3:	8b 45 08             	mov    0x8(%ebp),%eax
   1a4d6:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   1a4dc:	5d                   	pop    %ebp
   1a4dd:	c3                   	ret    

0001a4de <GetWidth>:

int GetWidth(Context* ctx){
   1a4de:	55                   	push   %ebp
   1a4df:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   1a4e1:	8b 45 08             	mov    0x8(%ebp),%eax
   1a4e4:	8b 40 10             	mov    0x10(%eax),%eax
}
   1a4e7:	5d                   	pop    %ebp
   1a4e8:	c3                   	ret    

0001a4e9 <GetHeight>:

int GetHeight(Context* ctx){
   1a4e9:	55                   	push   %ebp
   1a4ea:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   1a4ec:	8b 45 08             	mov    0x8(%ebp),%eax
   1a4ef:	8b 40 14             	mov    0x14(%eax),%eax
}
   1a4f2:	5d                   	pop    %ebp
   1a4f3:	c3                   	ret    

0001a4f4 <GetImageSize>:

uint GetImageSize(Context* ctx){
   1a4f4:	55                   	push   %ebp
   1a4f5:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   1a4f7:	8b 45 08             	mov    0x8(%ebp),%eax
   1a4fa:	8b 50 10             	mov    0x10(%eax),%edx
   1a4fd:	8b 45 08             	mov    0x8(%ebp),%eax
   1a500:	8b 40 14             	mov    0x14(%eax),%eax
   1a503:	0f af d0             	imul   %eax,%edx
   1a506:	8b 45 08             	mov    0x8(%ebp),%eax
   1a509:	8b 40 28             	mov    0x28(%eax),%eax
   1a50c:	0f af c2             	imul   %edx,%eax
}
   1a50f:	5d                   	pop    %ebp
   1a510:	c3                   	ret    

0001a511 <_Clip>:

uchar _Clip(const int x){
   1a511:	55                   	push   %ebp
   1a512:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   1a514:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1a518:	78 15                	js     1a52f <_Clip+0x1e>
   1a51a:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   1a521:	7f 05                	jg     1a528 <_Clip+0x17>
   1a523:	8b 45 08             	mov    0x8(%ebp),%eax
   1a526:	eb 0c                	jmp    1a534 <_Clip+0x23>
   1a528:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1a52d:	eb 05                	jmp    1a534 <_Clip+0x23>
   1a52f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1a534:	5d                   	pop    %ebp
   1a535:	c3                   	ret    

0001a536 <_Skip>:

void _Skip(Context* ctx, int c){
   1a536:	55                   	push   %ebp
   1a537:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   1a539:	8b 45 08             	mov    0x8(%ebp),%eax
   1a53c:	8b 50 04             	mov    0x4(%eax),%edx
   1a53f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1a542:	01 c2                	add    %eax,%edx
   1a544:	8b 45 08             	mov    0x8(%ebp),%eax
   1a547:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   1a54a:	8b 45 08             	mov    0x8(%ebp),%eax
   1a54d:	8b 40 08             	mov    0x8(%eax),%eax
   1a550:	2b 45 0c             	sub    0xc(%ebp),%eax
   1a553:	89 c2                	mov    %eax,%edx
   1a555:	8b 45 08             	mov    0x8(%ebp),%eax
   1a558:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   1a55b:	8b 45 08             	mov    0x8(%ebp),%eax
   1a55e:	8b 40 0c             	mov    0xc(%eax),%eax
   1a561:	2b 45 0c             	sub    0xc(%ebp),%eax
   1a564:	89 c2                	mov    %eax,%edx
   1a566:	8b 45 08             	mov    0x8(%ebp),%eax
   1a569:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   1a56c:	8b 45 08             	mov    0x8(%ebp),%eax
   1a56f:	8b 40 08             	mov    0x8(%eax),%eax
   1a572:	85 c0                	test   %eax,%eax
   1a574:	79 09                	jns    1a57f <_Skip+0x49>
   1a576:	8b 45 08             	mov    0x8(%ebp),%eax
   1a579:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   1a57f:	90                   	nop
   1a580:	5d                   	pop    %ebp
   1a581:	c3                   	ret    

0001a582 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   1a582:	55                   	push   %ebp
   1a583:	89 e5                	mov    %esp,%ebp
   1a585:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   1a588:	8b 45 08             	mov    0x8(%ebp),%eax
   1a58b:	8b 40 08             	mov    0x8(%eax),%eax
   1a58e:	83 f8 01             	cmp    $0x1,%eax
   1a591:	7f 0b                	jg     1a59e <_DecodeLength+0x1c>
   1a593:	8b 45 08             	mov    0x8(%ebp),%eax
   1a596:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1a59c:	eb 45                	jmp    1a5e3 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   1a59e:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5a1:	8b 40 04             	mov    0x4(%eax),%eax
   1a5a4:	83 ec 0c             	sub    $0xc,%esp
   1a5a7:	50                   	push   %eax
   1a5a8:	e8 38 00 00 00       	call   1a5e5 <_Decode2Bytes>
   1a5ad:	83 c4 10             	add    $0x10,%esp
   1a5b0:	89 c2                	mov    %eax,%edx
   1a5b2:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5b5:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   1a5b8:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5bb:	8b 50 0c             	mov    0xc(%eax),%edx
   1a5be:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5c1:	8b 40 08             	mov    0x8(%eax),%eax
   1a5c4:	39 c2                	cmp    %eax,%edx
   1a5c6:	7e 0b                	jle    1a5d3 <_DecodeLength+0x51>
   1a5c8:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5cb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1a5d1:	eb 10                	jmp    1a5e3 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   1a5d3:	83 ec 08             	sub    $0x8,%esp
   1a5d6:	6a 02                	push   $0x2
   1a5d8:	ff 75 08             	pushl  0x8(%ebp)
   1a5db:	e8 56 ff ff ff       	call   1a536 <_Skip>
   1a5e0:	83 c4 10             	add    $0x10,%esp
}
   1a5e3:	c9                   	leave  
   1a5e4:	c3                   	ret    

0001a5e5 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   1a5e5:	55                   	push   %ebp
   1a5e6:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   1a5e8:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5eb:	0f b6 00             	movzbl (%eax),%eax
   1a5ee:	0f b6 c0             	movzbl %al,%eax
   1a5f1:	c1 e0 08             	shl    $0x8,%eax
   1a5f4:	89 c2                	mov    %eax,%edx
   1a5f6:	8b 45 08             	mov    0x8(%ebp),%eax
   1a5f9:	83 c0 01             	add    $0x1,%eax
   1a5fc:	0f b6 00             	movzbl (%eax),%eax
   1a5ff:	0f b6 c0             	movzbl %al,%eax
   1a602:	09 d0                	or     %edx,%eax
}
   1a604:	5d                   	pop    %ebp
   1a605:	c3                   	ret    

0001a606 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   1a606:	55                   	push   %ebp
   1a607:	89 e5                	mov    %esp,%ebp
   1a609:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   1a60c:	8b 45 08             	mov    0x8(%ebp),%eax
   1a60f:	8b 55 10             	mov    0x10(%ebp),%edx
   1a612:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   1a615:	8b 45 14             	mov    0x14(%ebp),%eax
   1a618:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   1a61d:	89 c2                	mov    %eax,%edx
   1a61f:	8b 45 08             	mov    0x8(%ebp),%eax
   1a622:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   1a625:	8b 45 08             	mov    0x8(%ebp),%eax
   1a628:	8b 40 08             	mov    0x8(%eax),%eax
   1a62b:	83 f8 01             	cmp    $0x1,%eax
   1a62e:	7e 1d                	jle    1a64d <_DecodeJPEG+0x47>
   1a630:	8b 45 08             	mov    0x8(%ebp),%eax
   1a633:	8b 40 04             	mov    0x4(%eax),%eax
   1a636:	0f b6 00             	movzbl (%eax),%eax
   1a639:	3c ff                	cmp    $0xff,%al
   1a63b:	75 10                	jne    1a64d <_DecodeJPEG+0x47>
   1a63d:	8b 45 08             	mov    0x8(%ebp),%eax
   1a640:	8b 40 04             	mov    0x4(%eax),%eax
   1a643:	83 c0 01             	add    $0x1,%eax
   1a646:	0f b6 00             	movzbl (%eax),%eax
   1a649:	3c d8                	cmp    $0xd8,%al
   1a64b:	74 0a                	je     1a657 <_DecodeJPEG+0x51>
   1a64d:	b8 01 00 00 00       	mov    $0x1,%eax
   1a652:	e9 56 01 00 00       	jmp    1a7ad <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   1a657:	6a 02                	push   $0x2
   1a659:	ff 75 08             	pushl  0x8(%ebp)
   1a65c:	e8 d5 fe ff ff       	call   1a536 <_Skip>
   1a661:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   1a664:	e9 0a 01 00 00       	jmp    1a773 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   1a669:	8b 45 08             	mov    0x8(%ebp),%eax
   1a66c:	8b 40 08             	mov    0x8(%eax),%eax
   1a66f:	85 c0                	test   %eax,%eax
   1a671:	78 0d                	js     1a680 <_DecodeJPEG+0x7a>
   1a673:	8b 45 08             	mov    0x8(%ebp),%eax
   1a676:	8b 40 04             	mov    0x4(%eax),%eax
   1a679:	0f b6 00             	movzbl (%eax),%eax
   1a67c:	3c ff                	cmp    $0xff,%al
   1a67e:	74 0a                	je     1a68a <_DecodeJPEG+0x84>
   1a680:	b8 05 00 00 00       	mov    $0x5,%eax
   1a685:	e9 23 01 00 00       	jmp    1a7ad <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   1a68a:	6a 02                	push   $0x2
   1a68c:	ff 75 08             	pushl  0x8(%ebp)
   1a68f:	e8 a2 fe ff ff       	call   1a536 <_Skip>
   1a694:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   1a697:	8b 45 08             	mov    0x8(%ebp),%eax
   1a69a:	8b 40 04             	mov    0x4(%eax),%eax
   1a69d:	83 e8 01             	sub    $0x1,%eax
   1a6a0:	0f b6 00             	movzbl (%eax),%eax
   1a6a3:	0f b6 c0             	movzbl %al,%eax
   1a6a6:	3d da 00 00 00       	cmp    $0xda,%eax
   1a6ab:	74 71                	je     1a71e <_DecodeJPEG+0x118>
   1a6ad:	3d da 00 00 00       	cmp    $0xda,%eax
   1a6b2:	7f 10                	jg     1a6c4 <_DecodeJPEG+0xbe>
   1a6b4:	3d c0 00 00 00       	cmp    $0xc0,%eax
   1a6b9:	74 20                	je     1a6db <_DecodeJPEG+0xd5>
   1a6bb:	3d c4 00 00 00       	cmp    $0xc4,%eax
   1a6c0:	74 2c                	je     1a6ee <_DecodeJPEG+0xe8>
   1a6c2:	eb 7d                	jmp    1a741 <_DecodeJPEG+0x13b>
   1a6c4:	3d dd 00 00 00       	cmp    $0xdd,%eax
   1a6c9:	74 43                	je     1a70e <_DecodeJPEG+0x108>
   1a6cb:	3d fe 00 00 00       	cmp    $0xfe,%eax
   1a6d0:	74 5f                	je     1a731 <_DecodeJPEG+0x12b>
   1a6d2:	3d db 00 00 00       	cmp    $0xdb,%eax
   1a6d7:	74 25                	je     1a6fe <_DecodeJPEG+0xf8>
   1a6d9:	eb 66                	jmp    1a741 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   1a6db:	83 ec 0c             	sub    $0xc,%esp
   1a6de:	ff 75 08             	pushl  0x8(%ebp)
   1a6e1:	e8 c9 00 00 00       	call   1a7af <_DecodeSOF>
   1a6e6:	83 c4 10             	add    $0x10,%esp
   1a6e9:	e9 85 00 00 00       	jmp    1a773 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   1a6ee:	83 ec 0c             	sub    $0xc,%esp
   1a6f1:	ff 75 08             	pushl  0x8(%ebp)
   1a6f4:	e8 28 05 00 00       	call   1ac21 <_DecodeDHT>
   1a6f9:	83 c4 10             	add    $0x10,%esp
   1a6fc:	eb 75                	jmp    1a773 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   1a6fe:	83 ec 0c             	sub    $0xc,%esp
   1a701:	ff 75 08             	pushl  0x8(%ebp)
   1a704:	e8 05 07 00 00       	call   1ae0e <_DecodeDQT>
   1a709:	83 c4 10             	add    $0x10,%esp
   1a70c:	eb 65                	jmp    1a773 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   1a70e:	83 ec 0c             	sub    $0xc,%esp
   1a711:	ff 75 08             	pushl  0x8(%ebp)
   1a714:	e8 ff 07 00 00       	call   1af18 <_DecodeDRI>
   1a719:	83 c4 10             	add    $0x10,%esp
   1a71c:	eb 55                	jmp    1a773 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   1a71e:	83 ec 08             	sub    $0x8,%esp
   1a721:	ff 75 0c             	pushl  0xc(%ebp)
   1a724:	ff 75 08             	pushl  0x8(%ebp)
   1a727:	e8 56 08 00 00       	call   1af82 <_DecodeSOS>
   1a72c:	83 c4 10             	add    $0x10,%esp
   1a72f:	eb 42                	jmp    1a773 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   1a731:	83 ec 0c             	sub    $0xc,%esp
   1a734:	ff 75 08             	pushl  0x8(%ebp)
   1a737:	e8 a8 15 00 00       	call   1bce4 <_SkipMarker>
   1a73c:	83 c4 10             	add    $0x10,%esp
   1a73f:	eb 32                	jmp    1a773 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   1a741:	8b 45 08             	mov    0x8(%ebp),%eax
   1a744:	8b 40 04             	mov    0x4(%eax),%eax
   1a747:	83 e8 01             	sub    $0x1,%eax
   1a74a:	0f b6 00             	movzbl (%eax),%eax
   1a74d:	0f b6 c0             	movzbl %al,%eax
   1a750:	25 f0 00 00 00       	and    $0xf0,%eax
   1a755:	3d e0 00 00 00       	cmp    $0xe0,%eax
   1a75a:	75 10                	jne    1a76c <_DecodeJPEG+0x166>
   1a75c:	83 ec 0c             	sub    $0xc,%esp
   1a75f:	ff 75 08             	pushl  0x8(%ebp)
   1a762:	e8 7d 15 00 00       	call   1bce4 <_SkipMarker>
   1a767:	83 c4 10             	add    $0x10,%esp
   1a76a:	eb 07                	jmp    1a773 <_DecodeJPEG+0x16d>
                else return Unsupported;
   1a76c:	b8 02 00 00 00       	mov    $0x2,%eax
   1a771:	eb 3a                	jmp    1a7ad <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   1a773:	8b 45 08             	mov    0x8(%ebp),%eax
   1a776:	8b 00                	mov    (%eax),%eax
   1a778:	85 c0                	test   %eax,%eax
   1a77a:	0f 84 e9 fe ff ff    	je     1a669 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   1a780:	8b 45 08             	mov    0x8(%ebp),%eax
   1a783:	8b 00                	mov    (%eax),%eax
   1a785:	83 f8 06             	cmp    $0x6,%eax
   1a788:	74 07                	je     1a791 <_DecodeJPEG+0x18b>
   1a78a:	8b 45 08             	mov    0x8(%ebp),%eax
   1a78d:	8b 00                	mov    (%eax),%eax
   1a78f:	eb 1c                	jmp    1a7ad <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   1a791:	8b 45 08             	mov    0x8(%ebp),%eax
   1a794:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   1a79a:	83 ec 0c             	sub    $0xc,%esp
   1a79d:	ff 75 08             	pushl  0x8(%ebp)
   1a7a0:	e8 6b 15 00 00       	call   1bd10 <_Convert>
   1a7a5:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   1a7a8:	8b 45 08             	mov    0x8(%ebp),%eax
   1a7ab:	8b 00                	mov    (%eax),%eax
 }
   1a7ad:	c9                   	leave  
   1a7ae:	c3                   	ret    

0001a7af <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   1a7af:	55                   	push   %ebp
   1a7b0:	89 e5                	mov    %esp,%ebp
   1a7b2:	53                   	push   %ebx
   1a7b3:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   1a7b6:	83 ec 0c             	sub    $0xc,%esp
   1a7b9:	ff 75 08             	pushl  0x8(%ebp)
   1a7bc:	e8 c1 fd ff ff       	call   1a582 <_DecodeLength>
   1a7c1:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   1a7c4:	8b 45 08             	mov    0x8(%ebp),%eax
   1a7c7:	8b 00                	mov    (%eax),%eax
   1a7c9:	85 c0                	test   %eax,%eax
   1a7cb:	0f 85 4a 04 00 00    	jne    1ac1b <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   1a7d1:	8b 45 08             	mov    0x8(%ebp),%eax
   1a7d4:	8b 40 0c             	mov    0xc(%eax),%eax
   1a7d7:	83 f8 08             	cmp    $0x8,%eax
   1a7da:	7f 0e                	jg     1a7ea <_DecodeSOF+0x3b>
   1a7dc:	8b 45 08             	mov    0x8(%ebp),%eax
   1a7df:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1a7e5:	e9 32 04 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   1a7ea:	8b 45 08             	mov    0x8(%ebp),%eax
   1a7ed:	8b 40 04             	mov    0x4(%eax),%eax
   1a7f0:	0f b6 00             	movzbl (%eax),%eax
   1a7f3:	3c 08                	cmp    $0x8,%al
   1a7f5:	74 0e                	je     1a805 <_DecodeSOF+0x56>
   1a7f7:	8b 45 08             	mov    0x8(%ebp),%eax
   1a7fa:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1a800:	e9 17 04 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   1a805:	8b 45 08             	mov    0x8(%ebp),%eax
   1a808:	8b 40 04             	mov    0x4(%eax),%eax
   1a80b:	83 c0 01             	add    $0x1,%eax
   1a80e:	83 ec 0c             	sub    $0xc,%esp
   1a811:	50                   	push   %eax
   1a812:	e8 ce fd ff ff       	call   1a5e5 <_Decode2Bytes>
   1a817:	83 c4 10             	add    $0x10,%esp
   1a81a:	89 c2                	mov    %eax,%edx
   1a81c:	8b 45 08             	mov    0x8(%ebp),%eax
   1a81f:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   1a822:	8b 45 08             	mov    0x8(%ebp),%eax
   1a825:	8b 40 04             	mov    0x4(%eax),%eax
   1a828:	83 c0 03             	add    $0x3,%eax
   1a82b:	83 ec 0c             	sub    $0xc,%esp
   1a82e:	50                   	push   %eax
   1a82f:	e8 b1 fd ff ff       	call   1a5e5 <_Decode2Bytes>
   1a834:	83 c4 10             	add    $0x10,%esp
   1a837:	89 c2                	mov    %eax,%edx
   1a839:	8b 45 08             	mov    0x8(%ebp),%eax
   1a83c:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   1a83f:	8b 45 08             	mov    0x8(%ebp),%eax
   1a842:	8b 40 04             	mov    0x4(%eax),%eax
   1a845:	83 c0 05             	add    $0x5,%eax
   1a848:	0f b6 00             	movzbl (%eax),%eax
   1a84b:	0f b6 d0             	movzbl %al,%edx
   1a84e:	8b 45 08             	mov    0x8(%ebp),%eax
   1a851:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   1a854:	83 ec 08             	sub    $0x8,%esp
   1a857:	6a 06                	push   $0x6
   1a859:	ff 75 08             	pushl  0x8(%ebp)
   1a85c:	e8 d5 fc ff ff       	call   1a536 <_Skip>
   1a861:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   1a864:	8b 45 08             	mov    0x8(%ebp),%eax
   1a867:	8b 40 28             	mov    0x28(%eax),%eax
   1a86a:	83 f8 01             	cmp    $0x1,%eax
   1a86d:	74 13                	je     1a882 <_DecodeSOF+0xd3>
   1a86f:	83 f8 03             	cmp    $0x3,%eax
   1a872:	74 0e                	je     1a882 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   1a874:	8b 45 08             	mov    0x8(%ebp),%eax
   1a877:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1a87d:	e9 9a 03 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   1a882:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   1a883:	8b 45 08             	mov    0x8(%ebp),%eax
   1a886:	8b 48 0c             	mov    0xc(%eax),%ecx
   1a889:	8b 45 08             	mov    0x8(%ebp),%eax
   1a88c:	8b 50 28             	mov    0x28(%eax),%edx
   1a88f:	89 d0                	mov    %edx,%eax
   1a891:	01 c0                	add    %eax,%eax
   1a893:	01 d0                	add    %edx,%eax
   1a895:	39 c1                	cmp    %eax,%ecx
   1a897:	7d 0e                	jge    1a8a7 <_DecodeSOF+0xf8>
   1a899:	8b 45 08             	mov    0x8(%ebp),%eax
   1a89c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1a8a2:	e9 75 03 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   1a8a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1a8ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1a8b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1a8bc:	8b 45 08             	mov    0x8(%ebp),%eax
   1a8bf:	83 c0 2c             	add    $0x2c,%eax
   1a8c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1a8c5:	e9 50 01 00 00       	jmp    1aa1a <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   1a8ca:	8b 45 08             	mov    0x8(%ebp),%eax
   1a8cd:	8b 40 04             	mov    0x4(%eax),%eax
   1a8d0:	0f b6 00             	movzbl (%eax),%eax
   1a8d3:	0f b6 d0             	movzbl %al,%edx
   1a8d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a8d9:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   1a8db:	8b 45 08             	mov    0x8(%ebp),%eax
   1a8de:	8b 40 04             	mov    0x4(%eax),%eax
   1a8e1:	83 c0 01             	add    $0x1,%eax
   1a8e4:	0f b6 00             	movzbl (%eax),%eax
   1a8e7:	c0 e8 04             	shr    $0x4,%al
   1a8ea:	0f b6 d0             	movzbl %al,%edx
   1a8ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a8f0:	89 50 04             	mov    %edx,0x4(%eax)
   1a8f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a8f6:	8b 40 04             	mov    0x4(%eax),%eax
   1a8f9:	85 c0                	test   %eax,%eax
   1a8fb:	75 0e                	jne    1a90b <_DecodeSOF+0x15c>
   1a8fd:	8b 45 08             	mov    0x8(%ebp),%eax
   1a900:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1a906:	e9 11 03 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   1a90b:	8b 45 08             	mov    0x8(%ebp),%eax
   1a90e:	8b 40 04             	mov    0x4(%eax),%eax
   1a911:	83 c0 01             	add    $0x1,%eax
   1a914:	0f b6 00             	movzbl (%eax),%eax
   1a917:	0f b6 c0             	movzbl %al,%eax
   1a91a:	83 e0 0f             	and    $0xf,%eax
   1a91d:	89 c2                	mov    %eax,%edx
   1a91f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a922:	89 50 08             	mov    %edx,0x8(%eax)
   1a925:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a928:	8b 40 08             	mov    0x8(%eax),%eax
   1a92b:	85 c0                	test   %eax,%eax
   1a92d:	75 0e                	jne    1a93d <_DecodeSOF+0x18e>
   1a92f:	8b 45 08             	mov    0x8(%ebp),%eax
   1a932:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1a938:	e9 df 02 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   1a93d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a940:	8b 50 04             	mov    0x4(%eax),%edx
   1a943:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a946:	8b 40 04             	mov    0x4(%eax),%eax
   1a949:	83 e8 01             	sub    $0x1,%eax
   1a94c:	21 d0                	and    %edx,%eax
   1a94e:	85 c0                	test   %eax,%eax
   1a950:	74 0e                	je     1a960 <_DecodeSOF+0x1b1>
   1a952:	8b 45 08             	mov    0x8(%ebp),%eax
   1a955:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1a95b:	e9 bc 02 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   1a960:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a963:	8b 50 08             	mov    0x8(%eax),%edx
   1a966:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a969:	8b 40 08             	mov    0x8(%eax),%eax
   1a96c:	83 e8 01             	sub    $0x1,%eax
   1a96f:	21 d0                	and    %edx,%eax
   1a971:	85 c0                	test   %eax,%eax
   1a973:	74 0e                	je     1a983 <_DecodeSOF+0x1d4>
   1a975:	8b 45 08             	mov    0x8(%ebp),%eax
   1a978:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1a97e:	e9 99 02 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   1a983:	8b 45 08             	mov    0x8(%ebp),%eax
   1a986:	8b 40 04             	mov    0x4(%eax),%eax
   1a989:	83 c0 02             	add    $0x2,%eax
   1a98c:	0f b6 00             	movzbl (%eax),%eax
   1a98f:	0f b6 d0             	movzbl %al,%edx
   1a992:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a995:	89 50 18             	mov    %edx,0x18(%eax)
   1a998:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a99b:	8b 40 18             	mov    0x18(%eax),%eax
   1a99e:	25 fc 00 00 00       	and    $0xfc,%eax
   1a9a3:	85 c0                	test   %eax,%eax
   1a9a5:	74 0e                	je     1a9b5 <_DecodeSOF+0x206>
   1a9a7:	8b 45 08             	mov    0x8(%ebp),%eax
   1a9aa:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1a9b0:	e9 67 02 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   1a9b5:	83 ec 08             	sub    $0x8,%esp
   1a9b8:	6a 03                	push   $0x3
   1a9ba:	ff 75 08             	pushl  0x8(%ebp)
   1a9bd:	e8 74 fb ff ff       	call   1a536 <_Skip>
   1a9c2:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   1a9c5:	8b 45 08             	mov    0x8(%ebp),%eax
   1a9c8:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   1a9ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a9d1:	8b 40 18             	mov    0x18(%eax),%eax
   1a9d4:	bb 01 00 00 00       	mov    $0x1,%ebx
   1a9d9:	89 c1                	mov    %eax,%ecx
   1a9db:	d3 e3                	shl    %cl,%ebx
   1a9dd:	89 d8                	mov    %ebx,%eax
   1a9df:	09 c2                	or     %eax,%edx
   1a9e1:	8b 45 08             	mov    0x8(%ebp),%eax
   1a9e4:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   1a9ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a9ed:	8b 40 04             	mov    0x4(%eax),%eax
   1a9f0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1a9f3:	7e 09                	jle    1a9fe <_DecodeSOF+0x24f>
   1a9f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1a9f8:	8b 40 04             	mov    0x4(%eax),%eax
   1a9fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   1a9fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1aa01:	8b 40 08             	mov    0x8(%eax),%eax
   1aa04:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1aa07:	7e 09                	jle    1aa12 <_DecodeSOF+0x263>
   1aa09:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1aa0c:	8b 40 08             	mov    0x8(%eax),%eax
   1aa0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1aa12:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1aa16:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1aa1a:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa1d:	8b 40 28             	mov    0x28(%eax),%eax
   1aa20:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1aa23:	0f 8f a1 fe ff ff    	jg     1a8ca <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   1aa29:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1aa2c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1aa33:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa36:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   1aa39:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1aa3c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1aa43:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa46:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   1aa49:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa4c:	8b 50 10             	mov    0x10(%eax),%edx
   1aa4f:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa52:	8b 40 20             	mov    0x20(%eax),%eax
   1aa55:	01 d0                	add    %edx,%eax
   1aa57:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1aa5a:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa5d:	8b 58 20             	mov    0x20(%eax),%ebx
   1aa60:	89 c8                	mov    %ecx,%eax
   1aa62:	99                   	cltd   
   1aa63:	f7 fb                	idiv   %ebx
   1aa65:	89 c2                	mov    %eax,%edx
   1aa67:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa6a:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   1aa6d:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa70:	8b 50 14             	mov    0x14(%eax),%edx
   1aa73:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa76:	8b 40 24             	mov    0x24(%eax),%eax
   1aa79:	01 d0                	add    %edx,%eax
   1aa7b:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1aa7e:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa81:	8b 58 24             	mov    0x24(%eax),%ebx
   1aa84:	89 c8                	mov    %ecx,%eax
   1aa86:	99                   	cltd   
   1aa87:	f7 fb                	idiv   %ebx
   1aa89:	89 c2                	mov    %eax,%edx
   1aa8b:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa8e:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   1aa91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1aa98:	8b 45 08             	mov    0x8(%ebp),%eax
   1aa9b:	83 c0 2c             	add    $0x2c,%eax
   1aa9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1aaa1:	e9 fd 00 00 00       	jmp    1aba3 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   1aaa6:	8b 45 08             	mov    0x8(%ebp),%eax
   1aaa9:	8b 50 10             	mov    0x10(%eax),%edx
   1aaac:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1aaaf:	8b 40 04             	mov    0x4(%eax),%eax
   1aab2:	0f af d0             	imul   %eax,%edx
   1aab5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1aab8:	01 d0                	add    %edx,%eax
   1aaba:	83 e8 01             	sub    $0x1,%eax
   1aabd:	99                   	cltd   
   1aabe:	f7 7d ec             	idivl  -0x14(%ebp)
   1aac1:	89 c2                	mov    %eax,%edx
   1aac3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1aac6:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   1aac9:	8b 45 08             	mov    0x8(%ebp),%eax
   1aacc:	8b 50 14             	mov    0x14(%eax),%edx
   1aacf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1aad2:	8b 40 08             	mov    0x8(%eax),%eax
   1aad5:	0f af d0             	imul   %eax,%edx
   1aad8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1aadb:	01 d0                	add    %edx,%eax
   1aadd:	83 e8 01             	sub    $0x1,%eax
   1aae0:	99                   	cltd   
   1aae1:	f7 7d f0             	idivl  -0x10(%ebp)
   1aae4:	89 c2                	mov    %eax,%edx
   1aae6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1aae9:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   1aaec:	8b 45 08             	mov    0x8(%ebp),%eax
   1aaef:	8b 50 18             	mov    0x18(%eax),%edx
   1aaf2:	8b 45 08             	mov    0x8(%ebp),%eax
   1aaf5:	8b 40 20             	mov    0x20(%eax),%eax
   1aaf8:	0f af d0             	imul   %eax,%edx
   1aafb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1aafe:	8b 40 04             	mov    0x4(%eax),%eax
   1ab01:	0f af c2             	imul   %edx,%eax
   1ab04:	99                   	cltd   
   1ab05:	f7 7d ec             	idivl  -0x14(%ebp)
   1ab08:	89 c2                	mov    %eax,%edx
   1ab0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab0d:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   1ab10:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab13:	8b 40 0c             	mov    0xc(%eax),%eax
   1ab16:	83 f8 02             	cmp    $0x2,%eax
   1ab19:	7f 0b                	jg     1ab26 <_DecodeSOF+0x377>
   1ab1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab1e:	8b 40 04             	mov    0x4(%eax),%eax
   1ab21:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1ab24:	75 16                	jne    1ab3c <_DecodeSOF+0x38d>
   1ab26:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab29:	8b 40 10             	mov    0x10(%eax),%eax
   1ab2c:	83 f8 02             	cmp    $0x2,%eax
   1ab2f:	7f 19                	jg     1ab4a <_DecodeSOF+0x39b>
   1ab31:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab34:	8b 40 08             	mov    0x8(%eax),%eax
   1ab37:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1ab3a:	74 0e                	je     1ab4a <_DecodeSOF+0x39b>
   1ab3c:	8b 45 08             	mov    0x8(%ebp),%eax
   1ab3f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1ab45:	e9 d2 00 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   1ab4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab4d:	8b 48 14             	mov    0x14(%eax),%ecx
   1ab50:	8b 45 08             	mov    0x8(%ebp),%eax
   1ab53:	8b 50 1c             	mov    0x1c(%eax),%edx
   1ab56:	8b 45 08             	mov    0x8(%ebp),%eax
   1ab59:	8b 40 24             	mov    0x24(%eax),%eax
   1ab5c:	0f af d0             	imul   %eax,%edx
   1ab5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab62:	8b 40 08             	mov    0x8(%eax),%eax
   1ab65:	0f af c2             	imul   %edx,%eax
   1ab68:	99                   	cltd   
   1ab69:	f7 7d f0             	idivl  -0x10(%ebp)
   1ab6c:	0f af c1             	imul   %ecx,%eax
   1ab6f:	83 ec 0c             	sub    $0xc,%esp
   1ab72:	50                   	push   %eax
   1ab73:	e8 45 c5 fe ff       	call   70bd <malloc>
   1ab78:	83 c4 10             	add    $0x10,%esp
   1ab7b:	89 c2                	mov    %eax,%edx
   1ab7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab80:	89 50 28             	mov    %edx,0x28(%eax)
   1ab83:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ab86:	8b 40 28             	mov    0x28(%eax),%eax
   1ab89:	85 c0                	test   %eax,%eax
   1ab8b:	75 0e                	jne    1ab9b <_DecodeSOF+0x3ec>
   1ab8d:	8b 45 08             	mov    0x8(%ebp),%eax
   1ab90:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1ab96:	e9 81 00 00 00       	jmp    1ac1c <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   1ab9b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1ab9f:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1aba3:	8b 45 08             	mov    0x8(%ebp),%eax
   1aba6:	8b 40 28             	mov    0x28(%eax),%eax
   1aba9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1abac:	0f 8f f4 fe ff ff    	jg     1aaa6 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   1abb2:	8b 45 08             	mov    0x8(%ebp),%eax
   1abb5:	8b 40 28             	mov    0x28(%eax),%eax
   1abb8:	83 f8 03             	cmp    $0x3,%eax
   1abbb:	75 47                	jne    1ac04 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   1abbd:	8b 45 08             	mov    0x8(%ebp),%eax
   1abc0:	8b 50 10             	mov    0x10(%eax),%edx
   1abc3:	8b 45 08             	mov    0x8(%ebp),%eax
   1abc6:	8b 40 14             	mov    0x14(%eax),%eax
   1abc9:	0f af d0             	imul   %eax,%edx
   1abcc:	8b 45 08             	mov    0x8(%ebp),%eax
   1abcf:	8b 40 28             	mov    0x28(%eax),%eax
   1abd2:	0f af c2             	imul   %edx,%eax
   1abd5:	83 ec 0c             	sub    $0xc,%esp
   1abd8:	50                   	push   %eax
   1abd9:	e8 df c4 fe ff       	call   70bd <malloc>
   1abde:	83 c4 10             	add    $0x10,%esp
   1abe1:	89 c2                	mov    %eax,%edx
   1abe3:	8b 45 08             	mov    0x8(%ebp),%eax
   1abe6:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   1abec:	8b 45 08             	mov    0x8(%ebp),%eax
   1abef:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1abf5:	85 c0                	test   %eax,%eax
   1abf7:	75 0b                	jne    1ac04 <_DecodeSOF+0x455>
   1abf9:	8b 45 08             	mov    0x8(%ebp),%eax
   1abfc:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1ac02:	eb 18                	jmp    1ac1c <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1ac04:	8b 45 08             	mov    0x8(%ebp),%eax
   1ac07:	8b 40 0c             	mov    0xc(%eax),%eax
   1ac0a:	83 ec 08             	sub    $0x8,%esp
   1ac0d:	50                   	push   %eax
   1ac0e:	ff 75 08             	pushl  0x8(%ebp)
   1ac11:	e8 20 f9 ff ff       	call   1a536 <_Skip>
   1ac16:	83 c4 10             	add    $0x10,%esp
   1ac19:	eb 01                	jmp    1ac1c <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   1ac1b:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   1ac1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1ac1f:	c9                   	leave  
   1ac20:	c3                   	ret    

0001ac21 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   1ac21:	55                   	push   %ebp
   1ac22:	89 e5                	mov    %esp,%ebp
   1ac24:	53                   	push   %ebx
   1ac25:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   1ac28:	83 ec 0c             	sub    $0xc,%esp
   1ac2b:	ff 75 08             	pushl  0x8(%ebp)
   1ac2e:	e8 4f f9 ff ff       	call   1a582 <_DecodeLength>
   1ac33:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1ac36:	8b 45 08             	mov    0x8(%ebp),%eax
   1ac39:	8b 00                	mov    (%eax),%eax
   1ac3b:	85 c0                	test   %eax,%eax
   1ac3d:	0f 85 c5 01 00 00    	jne    1ae08 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   1ac43:	e9 9c 01 00 00       	jmp    1ade4 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   1ac48:	8b 45 08             	mov    0x8(%ebp),%eax
   1ac4b:	8b 40 04             	mov    0x4(%eax),%eax
   1ac4e:	0f b6 00             	movzbl (%eax),%eax
   1ac51:	0f b6 c0             	movzbl %al,%eax
   1ac54:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   1ac57:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ac5a:	25 ec 00 00 00       	and    $0xec,%eax
   1ac5f:	85 c0                	test   %eax,%eax
   1ac61:	74 0e                	je     1ac71 <_DecodeDHT+0x50>
   1ac63:	8b 45 08             	mov    0x8(%ebp),%eax
   1ac66:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1ac6c:	e9 98 01 00 00       	jmp    1ae09 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   1ac71:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ac74:	83 e0 02             	and    $0x2,%eax
   1ac77:	85 c0                	test   %eax,%eax
   1ac79:	74 0e                	je     1ac89 <_DecodeDHT+0x68>
   1ac7b:	8b 45 08             	mov    0x8(%ebp),%eax
   1ac7e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1ac84:	e9 80 01 00 00       	jmp    1ae09 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   1ac89:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ac8c:	c1 f8 03             	sar    $0x3,%eax
   1ac8f:	0b 45 f4             	or     -0xc(%ebp),%eax
   1ac92:	83 e0 03             	and    $0x3,%eax
   1ac95:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1ac98:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   1ac9f:	eb 1c                	jmp    1acbd <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   1aca1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1aca4:	8d 50 ff             	lea    -0x1(%eax),%edx
   1aca7:	8b 45 08             	mov    0x8(%ebp),%eax
   1acaa:	8b 48 04             	mov    0x4(%eax),%ecx
   1acad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1acb0:	01 c8                	add    %ecx,%eax
   1acb2:	0f b6 00             	movzbl (%eax),%eax
   1acb5:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   1acb9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1acbd:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1acc1:	7e de                	jle    1aca1 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   1acc3:	83 ec 08             	sub    $0x8,%esp
   1acc6:	6a 11                	push   $0x11
   1acc8:	ff 75 08             	pushl  0x8(%ebp)
   1accb:	e8 66 f8 ff ff       	call   1a536 <_Skip>
   1acd0:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   1acd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1acd6:	c1 e0 11             	shl    $0x11,%eax
   1acd9:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1acdf:	8b 45 08             	mov    0x8(%ebp),%eax
   1ace2:	01 d0                	add    %edx,%eax
   1ace4:	83 c0 08             	add    $0x8,%eax
   1ace7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   1acea:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   1acf1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1acf4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1acf7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   1acfe:	e9 be 00 00 00       	jmp    1adc1 <_DecodeDHT+0x1a0>
            spread >>= 1;
   1ad03:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   1ad06:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1ad09:	83 e8 01             	sub    $0x1,%eax
   1ad0c:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   1ad11:	0f b6 c0             	movzbl %al,%eax
   1ad14:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   1ad17:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1ad1b:	0f 84 9b 00 00 00    	je     1adbc <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   1ad21:	8b 45 08             	mov    0x8(%ebp),%eax
   1ad24:	8b 40 0c             	mov    0xc(%eax),%eax
   1ad27:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1ad2a:	7d 0e                	jge    1ad3a <_DecodeDHT+0x119>
   1ad2c:	8b 45 08             	mov    0x8(%ebp),%eax
   1ad2f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1ad35:	e9 cf 00 00 00       	jmp    1ae09 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   1ad3a:	b8 10 00 00 00       	mov    $0x10,%eax
   1ad3f:	2b 45 f0             	sub    -0x10(%ebp),%eax
   1ad42:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1ad45:	89 c1                	mov    %eax,%ecx
   1ad47:	d3 e2                	shl    %cl,%edx
   1ad49:	89 d0                	mov    %edx,%eax
   1ad4b:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   1ad4e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1ad52:	79 0e                	jns    1ad62 <_DecodeDHT+0x141>
   1ad54:	8b 45 08             	mov    0x8(%ebp),%eax
   1ad57:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1ad5d:	e9 a7 00 00 00       	jmp    1ae09 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   1ad62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1ad69:	eb 36                	jmp    1ada1 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   1ad6b:	8b 45 08             	mov    0x8(%ebp),%eax
   1ad6e:	8b 50 04             	mov    0x4(%eax),%edx
   1ad71:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ad74:	01 d0                	add    %edx,%eax
   1ad76:	0f b6 00             	movzbl (%eax),%eax
   1ad79:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   1ad7b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   1ad7e:	eb 14                	jmp    1ad94 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   1ad80:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1ad83:	89 c2                	mov    %eax,%edx
   1ad85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1ad88:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   1ad8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1ad8d:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   1ad90:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   1ad94:	89 d8                	mov    %ebx,%eax
   1ad96:	8d 58 ff             	lea    -0x1(%eax),%ebx
   1ad99:	85 c0                	test   %eax,%eax
   1ad9b:	75 e3                	jne    1ad80 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   1ad9d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1ada1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ada4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1ada7:	7c c2                	jl     1ad6b <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   1ada9:	83 ec 08             	sub    $0x8,%esp
   1adac:	ff 75 e0             	pushl  -0x20(%ebp)
   1adaf:	ff 75 08             	pushl  0x8(%ebp)
   1adb2:	e8 7f f7 ff ff       	call   1a536 <_Skip>
   1adb7:	83 c4 10             	add    $0x10,%esp
   1adba:	eb 01                	jmp    1adbd <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   1adbc:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   1adbd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1adc1:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1adc5:	0f 8e 38 ff ff ff    	jle    1ad03 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1adcb:	eb 0a                	jmp    1add7 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   1adcd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1add0:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   1add3:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1add7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1adda:	8d 50 ff             	lea    -0x1(%eax),%edx
   1addd:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1ade0:	85 c0                	test   %eax,%eax
   1ade2:	75 e9                	jne    1adcd <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   1ade4:	8b 45 08             	mov    0x8(%ebp),%eax
   1ade7:	8b 40 0c             	mov    0xc(%eax),%eax
   1adea:	83 f8 10             	cmp    $0x10,%eax
   1aded:	0f 8f 55 fe ff ff    	jg     1ac48 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1adf3:	8b 45 08             	mov    0x8(%ebp),%eax
   1adf6:	8b 40 0c             	mov    0xc(%eax),%eax
   1adf9:	85 c0                	test   %eax,%eax
   1adfb:	74 0c                	je     1ae09 <_DecodeDHT+0x1e8>
   1adfd:	8b 45 08             	mov    0x8(%ebp),%eax
   1ae00:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1ae06:	eb 01                	jmp    1ae09 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   1ae08:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1ae09:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1ae0c:	c9                   	leave  
   1ae0d:	c3                   	ret    

0001ae0e <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   1ae0e:	55                   	push   %ebp
   1ae0f:	89 e5                	mov    %esp,%ebp
   1ae11:	53                   	push   %ebx
   1ae12:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   1ae15:	83 ec 0c             	sub    $0xc,%esp
   1ae18:	ff 75 08             	pushl  0x8(%ebp)
   1ae1b:	e8 62 f7 ff ff       	call   1a582 <_DecodeLength>
   1ae20:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1ae23:	8b 45 08             	mov    0x8(%ebp),%eax
   1ae26:	8b 00                	mov    (%eax),%eax
   1ae28:	85 c0                	test   %eax,%eax
   1ae2a:	0f 85 e2 00 00 00    	jne    1af12 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   1ae30:	e9 b8 00 00 00       	jmp    1aeed <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   1ae35:	8b 45 08             	mov    0x8(%ebp),%eax
   1ae38:	8b 40 04             	mov    0x4(%eax),%eax
   1ae3b:	0f b6 00             	movzbl (%eax),%eax
   1ae3e:	0f b6 c0             	movzbl %al,%eax
   1ae41:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   1ae44:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ae47:	25 ec 00 00 00       	and    $0xec,%eax
   1ae4c:	85 c0                	test   %eax,%eax
   1ae4e:	74 0e                	je     1ae5e <_DecodeDQT+0x50>
   1ae50:	8b 45 08             	mov    0x8(%ebp),%eax
   1ae53:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1ae59:	e9 b5 00 00 00       	jmp    1af13 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   1ae5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ae61:	83 e0 10             	and    $0x10,%eax
   1ae64:	85 c0                	test   %eax,%eax
   1ae66:	74 0e                	je     1ae76 <_DecodeDQT+0x68>
   1ae68:	8b 45 08             	mov    0x8(%ebp),%eax
   1ae6b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1ae71:	e9 9d 00 00 00       	jmp    1af13 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   1ae76:	8b 45 08             	mov    0x8(%ebp),%eax
   1ae79:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   1ae7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ae82:	bb 01 00 00 00       	mov    $0x1,%ebx
   1ae87:	89 c1                	mov    %eax,%ecx
   1ae89:	d3 e3                	shl    %cl,%ebx
   1ae8b:	89 d8                	mov    %ebx,%eax
   1ae8d:	09 c2                	or     %eax,%edx
   1ae8f:	8b 45 08             	mov    0x8(%ebp),%eax
   1ae92:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   1ae98:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1ae9b:	c1 e0 06             	shl    $0x6,%eax
   1ae9e:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   1aea4:	8b 45 08             	mov    0x8(%ebp),%eax
   1aea7:	01 d0                	add    %edx,%eax
   1aea9:	83 c0 08             	add    $0x8,%eax
   1aeac:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   1aeaf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1aeb6:	eb 1f                	jmp    1aed7 <_DecodeDQT+0xc9>
   1aeb8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1aebb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1aebe:	01 c2                	add    %eax,%edx
   1aec0:	8b 45 08             	mov    0x8(%ebp),%eax
   1aec3:	8b 40 04             	mov    0x4(%eax),%eax
   1aec6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1aec9:	83 c1 01             	add    $0x1,%ecx
   1aecc:	01 c8                	add    %ecx,%eax
   1aece:	0f b6 00             	movzbl (%eax),%eax
   1aed1:	88 02                	mov    %al,(%edx)
   1aed3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1aed7:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   1aedb:	7e db                	jle    1aeb8 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   1aedd:	83 ec 08             	sub    $0x8,%esp
   1aee0:	6a 41                	push   $0x41
   1aee2:	ff 75 08             	pushl  0x8(%ebp)
   1aee5:	e8 4c f6 ff ff       	call   1a536 <_Skip>
   1aeea:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   1aeed:	8b 45 08             	mov    0x8(%ebp),%eax
   1aef0:	8b 40 0c             	mov    0xc(%eax),%eax
   1aef3:	83 f8 40             	cmp    $0x40,%eax
   1aef6:	0f 8f 39 ff ff ff    	jg     1ae35 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1aefc:	8b 45 08             	mov    0x8(%ebp),%eax
   1aeff:	8b 40 0c             	mov    0xc(%eax),%eax
   1af02:	85 c0                	test   %eax,%eax
   1af04:	74 0d                	je     1af13 <_DecodeDQT+0x105>
   1af06:	8b 45 08             	mov    0x8(%ebp),%eax
   1af09:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1af0f:	90                   	nop
   1af10:	eb 01                	jmp    1af13 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1af12:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1af13:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1af16:	c9                   	leave  
   1af17:	c3                   	ret    

0001af18 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   1af18:	55                   	push   %ebp
   1af19:	89 e5                	mov    %esp,%ebp
   1af1b:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   1af1e:	83 ec 0c             	sub    $0xc,%esp
   1af21:	ff 75 08             	pushl  0x8(%ebp)
   1af24:	e8 59 f6 ff ff       	call   1a582 <_DecodeLength>
   1af29:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1af2c:	8b 45 08             	mov    0x8(%ebp),%eax
   1af2f:	8b 00                	mov    (%eax),%eax
   1af31:	85 c0                	test   %eax,%eax
   1af33:	75 4a                	jne    1af7f <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   1af35:	8b 45 08             	mov    0x8(%ebp),%eax
   1af38:	8b 40 0c             	mov    0xc(%eax),%eax
   1af3b:	83 f8 01             	cmp    $0x1,%eax
   1af3e:	7f 0b                	jg     1af4b <_DecodeDRI+0x33>
   1af40:	8b 45 08             	mov    0x8(%ebp),%eax
   1af43:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1af49:	eb 35                	jmp    1af80 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   1af4b:	8b 45 08             	mov    0x8(%ebp),%eax
   1af4e:	8b 40 04             	mov    0x4(%eax),%eax
   1af51:	83 ec 0c             	sub    $0xc,%esp
   1af54:	50                   	push   %eax
   1af55:	e8 8b f6 ff ff       	call   1a5e5 <_Decode2Bytes>
   1af5a:	83 c4 10             	add    $0x10,%esp
   1af5d:	89 c2                	mov    %eax,%edx
   1af5f:	8b 45 08             	mov    0x8(%ebp),%eax
   1af62:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   1af68:	8b 45 08             	mov    0x8(%ebp),%eax
   1af6b:	8b 40 0c             	mov    0xc(%eax),%eax
   1af6e:	83 ec 08             	sub    $0x8,%esp
   1af71:	50                   	push   %eax
   1af72:	ff 75 08             	pushl  0x8(%ebp)
   1af75:	e8 bc f5 ff ff       	call   1a536 <_Skip>
   1af7a:	83 c4 10             	add    $0x10,%esp
   1af7d:	eb 01                	jmp    1af80 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   1af7f:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   1af80:	c9                   	leave  
   1af81:	c3                   	ret    

0001af82 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   1af82:	55                   	push   %ebp
   1af83:	89 e5                	mov    %esp,%ebp
   1af85:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   1af88:	8b 45 08             	mov    0x8(%ebp),%eax
   1af8b:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   1af91:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1af94:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   1af9b:	83 ec 0c             	sub    $0xc,%esp
   1af9e:	ff 75 08             	pushl  0x8(%ebp)
   1afa1:	e8 dc f5 ff ff       	call   1a582 <_DecodeLength>
   1afa6:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1afa9:	8b 45 08             	mov    0x8(%ebp),%eax
   1afac:	8b 00                	mov    (%eax),%eax
   1afae:	85 c0                	test   %eax,%eax
   1afb0:	0f 85 c2 02 00 00    	jne    1b278 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   1afb6:	8b 45 08             	mov    0x8(%ebp),%eax
   1afb9:	8b 50 0c             	mov    0xc(%eax),%edx
   1afbc:	8b 45 08             	mov    0x8(%ebp),%eax
   1afbf:	8b 40 28             	mov    0x28(%eax),%eax
   1afc2:	83 c0 02             	add    $0x2,%eax
   1afc5:	01 c0                	add    %eax,%eax
   1afc7:	39 c2                	cmp    %eax,%edx
   1afc9:	7c 16                	jl     1afe1 <_DecodeSOS+0x5f>
   1afcb:	8b 45 08             	mov    0x8(%ebp),%eax
   1afce:	8b 40 04             	mov    0x4(%eax),%eax
   1afd1:	0f b6 00             	movzbl (%eax),%eax
   1afd4:	0f b6 d0             	movzbl %al,%edx
   1afd7:	8b 45 08             	mov    0x8(%ebp),%eax
   1afda:	8b 40 28             	mov    0x28(%eax),%eax
   1afdd:	39 c2                	cmp    %eax,%edx
   1afdf:	74 0e                	je     1afef <_DecodeSOS+0x6d>
   1afe1:	8b 45 08             	mov    0x8(%ebp),%eax
   1afe4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1afea:	e9 8d 02 00 00       	jmp    1b27c <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   1afef:	83 ec 08             	sub    $0x8,%esp
   1aff2:	6a 01                	push   $0x1
   1aff4:	ff 75 08             	pushl  0x8(%ebp)
   1aff7:	e8 3a f5 ff ff       	call   1a536 <_Skip>
   1affc:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1afff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1b006:	8b 45 08             	mov    0x8(%ebp),%eax
   1b009:	83 c0 2c             	add    $0x2c,%eax
   1b00c:	89 45 dc             	mov    %eax,-0x24(%ebp)
   1b00f:	e9 ba 00 00 00       	jmp    1b0ce <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   1b014:	8b 45 08             	mov    0x8(%ebp),%eax
   1b017:	8b 40 04             	mov    0x4(%eax),%eax
   1b01a:	0f b6 00             	movzbl (%eax),%eax
   1b01d:	0f b6 d0             	movzbl %al,%edx
   1b020:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b023:	8b 00                	mov    (%eax),%eax
   1b025:	39 c2                	cmp    %eax,%edx
   1b027:	74 0e                	je     1b037 <_DecodeSOS+0xb5>
   1b029:	8b 45 08             	mov    0x8(%ebp),%eax
   1b02c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1b032:	e9 45 02 00 00       	jmp    1b27c <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   1b037:	8b 45 08             	mov    0x8(%ebp),%eax
   1b03a:	8b 40 04             	mov    0x4(%eax),%eax
   1b03d:	83 c0 01             	add    $0x1,%eax
   1b040:	0f b6 00             	movzbl (%eax),%eax
   1b043:	0f b6 c0             	movzbl %al,%eax
   1b046:	25 ec 00 00 00       	and    $0xec,%eax
   1b04b:	85 c0                	test   %eax,%eax
   1b04d:	74 0e                	je     1b05d <_DecodeSOS+0xdb>
   1b04f:	8b 45 08             	mov    0x8(%ebp),%eax
   1b052:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1b058:	e9 1f 02 00 00       	jmp    1b27c <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   1b05d:	8b 45 08             	mov    0x8(%ebp),%eax
   1b060:	8b 40 04             	mov    0x4(%eax),%eax
   1b063:	83 c0 01             	add    $0x1,%eax
   1b066:	0f b6 00             	movzbl (%eax),%eax
   1b069:	0f b6 c0             	movzbl %al,%eax
   1b06c:	83 e0 02             	and    $0x2,%eax
   1b06f:	85 c0                	test   %eax,%eax
   1b071:	74 0e                	je     1b081 <_DecodeSOS+0xff>
   1b073:	8b 45 08             	mov    0x8(%ebp),%eax
   1b076:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1b07c:	e9 fb 01 00 00       	jmp    1b27c <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   1b081:	8b 45 08             	mov    0x8(%ebp),%eax
   1b084:	8b 40 04             	mov    0x4(%eax),%eax
   1b087:	83 c0 01             	add    $0x1,%eax
   1b08a:	0f b6 00             	movzbl (%eax),%eax
   1b08d:	c0 e8 04             	shr    $0x4,%al
   1b090:	0f b6 d0             	movzbl %al,%edx
   1b093:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b096:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   1b099:	8b 45 08             	mov    0x8(%ebp),%eax
   1b09c:	8b 40 04             	mov    0x4(%eax),%eax
   1b09f:	83 c0 01             	add    $0x1,%eax
   1b0a2:	0f b6 00             	movzbl (%eax),%eax
   1b0a5:	0f b6 c0             	movzbl %al,%eax
   1b0a8:	83 e0 01             	and    $0x1,%eax
   1b0ab:	83 c8 02             	or     $0x2,%eax
   1b0ae:	89 c2                	mov    %eax,%edx
   1b0b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b0b3:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   1b0b6:	83 ec 08             	sub    $0x8,%esp
   1b0b9:	6a 02                	push   $0x2
   1b0bb:	ff 75 08             	pushl  0x8(%ebp)
   1b0be:	e8 73 f4 ff ff       	call   1a536 <_Skip>
   1b0c3:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1b0c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1b0ca:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1b0ce:	8b 45 08             	mov    0x8(%ebp),%eax
   1b0d1:	8b 40 28             	mov    0x28(%eax),%eax
   1b0d4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1b0d7:	0f 8f 37 ff ff ff    	jg     1b014 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   1b0dd:	8b 45 08             	mov    0x8(%ebp),%eax
   1b0e0:	8b 40 04             	mov    0x4(%eax),%eax
   1b0e3:	0f b6 00             	movzbl (%eax),%eax
   1b0e6:	84 c0                	test   %al,%al
   1b0e8:	75 10                	jne    1b0fa <_DecodeSOS+0x178>
   1b0ea:	8b 45 08             	mov    0x8(%ebp),%eax
   1b0ed:	8b 40 04             	mov    0x4(%eax),%eax
   1b0f0:	83 c0 01             	add    $0x1,%eax
   1b0f3:	0f b6 00             	movzbl (%eax),%eax
   1b0f6:	3c 3f                	cmp    $0x3f,%al
   1b0f8:	74 0e                	je     1b108 <_DecodeSOS+0x186>
   1b0fa:	8b 45 08             	mov    0x8(%ebp),%eax
   1b0fd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1b103:	e9 74 01 00 00       	jmp    1b27c <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   1b108:	8b 45 08             	mov    0x8(%ebp),%eax
   1b10b:	8b 40 04             	mov    0x4(%eax),%eax
   1b10e:	83 c0 02             	add    $0x2,%eax
   1b111:	0f b6 00             	movzbl (%eax),%eax
   1b114:	84 c0                	test   %al,%al
   1b116:	74 0e                	je     1b126 <_DecodeSOS+0x1a4>
   1b118:	8b 45 08             	mov    0x8(%ebp),%eax
   1b11b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1b121:	e9 56 01 00 00       	jmp    1b27c <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   1b126:	8b 45 08             	mov    0x8(%ebp),%eax
   1b129:	8b 40 0c             	mov    0xc(%eax),%eax
   1b12c:	83 ec 08             	sub    $0x8,%esp
   1b12f:	50                   	push   %eax
   1b130:	ff 75 08             	pushl  0x8(%ebp)
   1b133:	e8 fe f3 ff ff       	call   1a536 <_Skip>
   1b138:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   1b13b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1b142:	e9 17 01 00 00       	jmp    1b25e <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   1b147:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1b14e:	e9 f8 00 00 00       	jmp    1b24b <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   1b153:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1b15a:	8b 45 08             	mov    0x8(%ebp),%eax
   1b15d:	83 c0 2c             	add    $0x2c,%eax
   1b160:	89 45 dc             	mov    %eax,-0x24(%ebp)
   1b163:	e9 8d 00 00 00       	jmp    1b1f5 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   1b168:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1b16f:	eb 71                	jmp    1b1e2 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   1b171:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1b178:	eb 59                	jmp    1b1d3 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   1b17a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b17d:	8b 50 28             	mov    0x28(%eax),%edx
   1b180:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b183:	8b 40 08             	mov    0x8(%eax),%eax
   1b186:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1b18a:	89 c1                	mov    %eax,%ecx
   1b18c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1b18f:	01 c1                	add    %eax,%ecx
   1b191:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b194:	8b 40 14             	mov    0x14(%eax),%eax
   1b197:	0f af c8             	imul   %eax,%ecx
   1b19a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b19d:	8b 40 04             	mov    0x4(%eax),%eax
   1b1a0:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   1b1a4:	01 c1                	add    %eax,%ecx
   1b1a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1b1a9:	01 c8                	add    %ecx,%eax
   1b1ab:	c1 e0 03             	shl    $0x3,%eax
   1b1ae:	01 d0                	add    %edx,%eax
   1b1b0:	50                   	push   %eax
   1b1b1:	ff 75 dc             	pushl  -0x24(%ebp)
   1b1b4:	ff 75 0c             	pushl  0xc(%ebp)
   1b1b7:	ff 75 08             	pushl  0x8(%ebp)
   1b1ba:	e8 bf 00 00 00       	call   1b27e <_DecodeBlock>
   1b1bf:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   1b1c2:	8b 45 08             	mov    0x8(%ebp),%eax
   1b1c5:	8b 00                	mov    (%eax),%eax
   1b1c7:	85 c0                	test   %eax,%eax
   1b1c9:	0f 85 ac 00 00 00    	jne    1b27b <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   1b1cf:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1b1d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b1d6:	8b 40 04             	mov    0x4(%eax),%eax
   1b1d9:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1b1dc:	7f 9c                	jg     1b17a <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   1b1de:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1b1e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b1e5:	8b 40 08             	mov    0x8(%eax),%eax
   1b1e8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1b1eb:	7f 84                	jg     1b171 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   1b1ed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1b1f1:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1b1f5:	8b 45 08             	mov    0x8(%ebp),%eax
   1b1f8:	8b 40 28             	mov    0x28(%eax),%eax
   1b1fb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1b1fe:	0f 8f 64 ff ff ff    	jg     1b168 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   1b204:	8b 45 08             	mov    0x8(%ebp),%eax
   1b207:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   1b20d:	85 c0                	test   %eax,%eax
   1b20f:	74 36                	je     1b247 <_DecodeSOS+0x2c5>
   1b211:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   1b215:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1b219:	75 2c                	jne    1b247 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   1b21b:	83 ec 0c             	sub    $0xc,%esp
   1b21e:	ff 75 08             	pushl  0x8(%ebp)
   1b221:	e8 9f 0a 00 00       	call   1bcc5 <_ByteAlign>
   1b226:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   1b229:	83 ec 08             	sub    $0x8,%esp
   1b22c:	6a 10                	push   $0x10
   1b22e:	ff 75 08             	pushl  0x8(%ebp)
   1b231:	e8 ce 04 00 00       	call   1b704 <_GetBits>
   1b236:	83 c4 10             	add    $0x10,%esp
   1b239:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   1b23c:	8b 45 08             	mov    0x8(%ebp),%eax
   1b23f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1b245:	eb 35                	jmp    1b27c <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   1b247:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1b24b:	8b 45 08             	mov    0x8(%ebp),%eax
   1b24e:	8b 40 18             	mov    0x18(%eax),%eax
   1b251:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1b254:	0f 8f f9 fe ff ff    	jg     1b153 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   1b25a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1b25e:	8b 45 08             	mov    0x8(%ebp),%eax
   1b261:	8b 40 1c             	mov    0x1c(%eax),%eax
   1b264:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1b267:	0f 8f da fe ff ff    	jg     1b147 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   1b26d:	8b 45 08             	mov    0x8(%ebp),%eax
   1b270:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   1b276:	eb 04                	jmp    1b27c <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1b278:	90                   	nop
   1b279:	eb 01                	jmp    1b27c <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   1b27b:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   1b27c:	c9                   	leave  
   1b27d:	c3                   	ret    

0001b27e <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   1b27e:	55                   	push   %ebp
   1b27f:	89 e5                	mov    %esp,%ebp
   1b281:	53                   	push   %ebx
   1b282:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   1b285:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   1b28c:	8b 45 08             	mov    0x8(%ebp),%eax
   1b28f:	05 c0 01 08 00       	add    $0x801c0,%eax
   1b294:	83 ec 04             	sub    $0x4,%esp
   1b297:	68 00 01 00 00       	push   $0x100
   1b29c:	6a 00                	push   $0x0
   1b29e:	50                   	push   %eax
   1b29f:	e8 04 b8 fe ff       	call   6aa8 <memset>
   1b2a4:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   1b2a7:	8b 45 10             	mov    0x10(%ebp),%eax
   1b2aa:	8b 40 20             	mov    0x20(%eax),%eax
   1b2ad:	c1 e0 11             	shl    $0x11,%eax
   1b2b0:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1b2b6:	8b 45 08             	mov    0x8(%ebp),%eax
   1b2b9:	01 d0                	add    %edx,%eax
   1b2bb:	83 c0 08             	add    $0x8,%eax
   1b2be:	83 ec 04             	sub    $0x4,%esp
   1b2c1:	6a 00                	push   $0x0
   1b2c3:	50                   	push   %eax
   1b2c4:	ff 75 08             	pushl  0x8(%ebp)
   1b2c7:	e8 86 01 00 00       	call   1b452 <_GetVLC>
   1b2cc:	83 c4 10             	add    $0x10,%esp
   1b2cf:	89 c2                	mov    %eax,%edx
   1b2d1:	8b 45 10             	mov    0x10(%ebp),%eax
   1b2d4:	8b 40 24             	mov    0x24(%eax),%eax
   1b2d7:	01 c2                	add    %eax,%edx
   1b2d9:	8b 45 10             	mov    0x10(%ebp),%eax
   1b2dc:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   1b2df:	8b 45 10             	mov    0x10(%ebp),%eax
   1b2e2:	8b 50 24             	mov    0x24(%eax),%edx
   1b2e5:	8b 45 10             	mov    0x10(%ebp),%eax
   1b2e8:	8b 48 18             	mov    0x18(%eax),%ecx
   1b2eb:	8b 45 08             	mov    0x8(%ebp),%eax
   1b2ee:	c1 e1 06             	shl    $0x6,%ecx
   1b2f1:	01 c8                	add    %ecx,%eax
   1b2f3:	05 b8 00 00 00       	add    $0xb8,%eax
   1b2f8:	0f b6 00             	movzbl (%eax),%eax
   1b2fb:	0f b6 c0             	movzbl %al,%eax
   1b2fe:	0f af d0             	imul   %eax,%edx
   1b301:	8b 45 08             	mov    0x8(%ebp),%eax
   1b304:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   1b30a:	8b 45 10             	mov    0x10(%ebp),%eax
   1b30d:	8b 40 1c             	mov    0x1c(%eax),%eax
   1b310:	c1 e0 11             	shl    $0x11,%eax
   1b313:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1b319:	8b 45 08             	mov    0x8(%ebp),%eax
   1b31c:	01 d0                	add    %edx,%eax
   1b31e:	8d 50 08             	lea    0x8(%eax),%edx
   1b321:	83 ec 04             	sub    $0x4,%esp
   1b324:	8d 45 ef             	lea    -0x11(%ebp),%eax
   1b327:	50                   	push   %eax
   1b328:	52                   	push   %edx
   1b329:	ff 75 08             	pushl  0x8(%ebp)
   1b32c:	e8 21 01 00 00       	call   1b452 <_GetVLC>
   1b331:	83 c4 10             	add    $0x10,%esp
   1b334:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   1b337:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   1b33b:	84 c0                	test   %al,%al
   1b33d:	0f 84 92 00 00 00    	je     1b3d5 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   1b343:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   1b347:	0f b6 c0             	movzbl %al,%eax
   1b34a:	83 e0 0f             	and    $0xf,%eax
   1b34d:	85 c0                	test   %eax,%eax
   1b34f:	75 16                	jne    1b367 <_DecodeBlock+0xe9>
   1b351:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   1b355:	3c f0                	cmp    $0xf0,%al
   1b357:	74 0e                	je     1b367 <_DecodeBlock+0xe9>
   1b359:	8b 45 08             	mov    0x8(%ebp),%eax
   1b35c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1b362:	e9 e6 00 00 00       	jmp    1b44d <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   1b367:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   1b36b:	c0 e8 04             	shr    $0x4,%al
   1b36e:	0f b6 c0             	movzbl %al,%eax
   1b371:	83 c0 01             	add    $0x1,%eax
   1b374:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   1b377:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   1b37b:	7e 0e                	jle    1b38b <_DecodeBlock+0x10d>
   1b37d:	8b 45 08             	mov    0x8(%ebp),%eax
   1b380:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1b386:	e9 c2 00 00 00       	jmp    1b44d <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   1b38b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1b38e:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b391:	01 d0                	add    %edx,%eax
   1b393:	0f b6 00             	movzbl (%eax),%eax
   1b396:	0f be c8             	movsbl %al,%ecx
   1b399:	8b 45 10             	mov    0x10(%ebp),%eax
   1b39c:	8b 50 18             	mov    0x18(%eax),%edx
   1b39f:	8b 45 08             	mov    0x8(%ebp),%eax
   1b3a2:	c1 e2 06             	shl    $0x6,%edx
   1b3a5:	01 c2                	add    %eax,%edx
   1b3a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1b3aa:	01 d0                	add    %edx,%eax
   1b3ac:	05 b8 00 00 00       	add    $0xb8,%eax
   1b3b1:	0f b6 00             	movzbl (%eax),%eax
   1b3b4:	0f b6 c0             	movzbl %al,%eax
   1b3b7:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   1b3bb:	89 c2                	mov    %eax,%edx
   1b3bd:	8b 45 08             	mov    0x8(%ebp),%eax
   1b3c0:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   1b3c6:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   1b3c9:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   1b3cd:	0f 8e 37 ff ff ff    	jle    1b30a <_DecodeBlock+0x8c>
   1b3d3:	eb 01                	jmp    1b3d6 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   1b3d5:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   1b3d6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1b3dd:	eb 24                	jmp    1b403 <_DecodeBlock+0x185>
   1b3df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1b3e2:	05 70 00 02 00       	add    $0x20070,%eax
   1b3e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1b3ee:	8b 45 08             	mov    0x8(%ebp),%eax
   1b3f1:	01 d0                	add    %edx,%eax
   1b3f3:	83 ec 0c             	sub    $0xc,%esp
   1b3f6:	50                   	push   %eax
   1b3f7:	e8 32 03 00 00       	call   1b72e <_RowIDCT>
   1b3fc:	83 c4 10             	add    $0x10,%esp
   1b3ff:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   1b403:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   1b407:	7e d6                	jle    1b3df <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   1b409:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1b410:	eb 35                	jmp    1b447 <_DecodeBlock+0x1c9>
   1b412:	8b 45 10             	mov    0x10(%ebp),%eax
   1b415:	8b 40 14             	mov    0x14(%eax),%eax
   1b418:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1b41b:	8b 55 14             	mov    0x14(%ebp),%edx
   1b41e:	01 d1                	add    %edx,%ecx
   1b420:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1b423:	81 c2 70 00 02 00    	add    $0x20070,%edx
   1b429:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   1b430:	8b 55 08             	mov    0x8(%ebp),%edx
   1b433:	01 da                	add    %ebx,%edx
   1b435:	83 ec 04             	sub    $0x4,%esp
   1b438:	50                   	push   %eax
   1b439:	51                   	push   %ecx
   1b43a:	52                   	push   %edx
   1b43b:	e8 7b 05 00 00       	call   1b9bb <_ColIDCT>
   1b440:	83 c4 10             	add    $0x10,%esp
   1b443:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1b447:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   1b44b:	7e c5                	jle    1b412 <_DecodeBlock+0x194>
}
   1b44d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1b450:	c9                   	leave  
   1b451:	c3                   	ret    

0001b452 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   1b452:	55                   	push   %ebp
   1b453:	89 e5                	mov    %esp,%ebp
   1b455:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   1b458:	83 ec 08             	sub    $0x8,%esp
   1b45b:	6a 10                	push   $0x10
   1b45d:	ff 75 08             	pushl  0x8(%ebp)
   1b460:	e8 c2 00 00 00       	call   1b527 <_ShowBits>
   1b465:	83 c4 10             	add    $0x10,%esp
   1b468:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   1b46b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1b46e:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1b471:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b474:	01 d0                	add    %edx,%eax
   1b476:	0f b6 00             	movzbl (%eax),%eax
   1b479:	0f b6 c0             	movzbl %al,%eax
   1b47c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   1b47f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1b483:	75 13                	jne    1b498 <_GetVLC+0x46>
   1b485:	8b 45 08             	mov    0x8(%ebp),%eax
   1b488:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1b48e:	b8 00 00 00 00       	mov    $0x0,%eax
   1b493:	e9 8d 00 00 00       	jmp    1b525 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   1b498:	83 ec 08             	sub    $0x8,%esp
   1b49b:	ff 75 f0             	pushl  -0x10(%ebp)
   1b49e:	ff 75 08             	pushl  0x8(%ebp)
   1b4a1:	e8 25 02 00 00       	call   1b6cb <_SkipBits>
   1b4a6:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   1b4a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1b4ac:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1b4af:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b4b2:	01 d0                	add    %edx,%eax
   1b4b4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   1b4b8:	0f b6 c0             	movzbl %al,%eax
   1b4bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   1b4be:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1b4c2:	74 0a                	je     1b4ce <_GetVLC+0x7c>
   1b4c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1b4c7:	89 c2                	mov    %eax,%edx
   1b4c9:	8b 45 10             	mov    0x10(%ebp),%eax
   1b4cc:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   1b4ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1b4d1:	83 e0 0f             	and    $0xf,%eax
   1b4d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   1b4d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1b4db:	75 07                	jne    1b4e4 <_GetVLC+0x92>
   1b4dd:	b8 00 00 00 00       	mov    $0x0,%eax
   1b4e2:	eb 41                	jmp    1b525 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   1b4e4:	83 ec 08             	sub    $0x8,%esp
   1b4e7:	ff 75 f0             	pushl  -0x10(%ebp)
   1b4ea:	ff 75 08             	pushl  0x8(%ebp)
   1b4ed:	e8 12 02 00 00       	call   1b704 <_GetBits>
   1b4f2:	83 c4 10             	add    $0x10,%esp
   1b4f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   1b4f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b4fb:	83 e8 01             	sub    $0x1,%eax
   1b4fe:	ba 01 00 00 00       	mov    $0x1,%edx
   1b503:	89 c1                	mov    %eax,%ecx
   1b505:	d3 e2                	shl    %cl,%edx
   1b507:	89 d0                	mov    %edx,%eax
   1b509:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1b50c:	7e 14                	jle    1b522 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   1b50e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b511:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   1b516:	89 c1                	mov    %eax,%ecx
   1b518:	d3 e2                	shl    %cl,%edx
   1b51a:	89 d0                	mov    %edx,%eax
   1b51c:	83 c0 01             	add    $0x1,%eax
   1b51f:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   1b522:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1b525:	c9                   	leave  
   1b526:	c3                   	ret    

0001b527 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   1b527:	55                   	push   %ebp
   1b528:	89 e5                	mov    %esp,%ebp
   1b52a:	53                   	push   %ebx
   1b52b:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   1b52e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1b532:	0f 85 4f 01 00 00    	jne    1b687 <_ShowBits+0x160>
   1b538:	b8 00 00 00 00       	mov    $0x0,%eax
   1b53d:	e9 83 01 00 00       	jmp    1b6c5 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   1b542:	8b 45 08             	mov    0x8(%ebp),%eax
   1b545:	8b 40 08             	mov    0x8(%eax),%eax
   1b548:	85 c0                	test   %eax,%eax
   1b54a:	7f 33                	jg     1b57f <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   1b54c:	8b 45 08             	mov    0x8(%ebp),%eax
   1b54f:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   1b555:	c1 e0 08             	shl    $0x8,%eax
   1b558:	0c ff                	or     $0xff,%al
   1b55a:	89 c2                	mov    %eax,%edx
   1b55c:	8b 45 08             	mov    0x8(%ebp),%eax
   1b55f:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   1b565:	8b 45 08             	mov    0x8(%ebp),%eax
   1b568:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1b56e:	8d 50 08             	lea    0x8(%eax),%edx
   1b571:	8b 45 08             	mov    0x8(%ebp),%eax
   1b574:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   1b57a:	e9 08 01 00 00       	jmp    1b687 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   1b57f:	8b 45 08             	mov    0x8(%ebp),%eax
   1b582:	8b 40 04             	mov    0x4(%eax),%eax
   1b585:	8d 48 01             	lea    0x1(%eax),%ecx
   1b588:	8b 55 08             	mov    0x8(%ebp),%edx
   1b58b:	89 4a 04             	mov    %ecx,0x4(%edx)
   1b58e:	0f b6 00             	movzbl (%eax),%eax
   1b591:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   1b594:	8b 45 08             	mov    0x8(%ebp),%eax
   1b597:	8b 40 08             	mov    0x8(%eax),%eax
   1b59a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1b59d:	8b 45 08             	mov    0x8(%ebp),%eax
   1b5a0:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   1b5a3:	8b 45 08             	mov    0x8(%ebp),%eax
   1b5a6:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1b5ac:	8d 50 08             	lea    0x8(%eax),%edx
   1b5af:	8b 45 08             	mov    0x8(%ebp),%eax
   1b5b2:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   1b5b8:	8b 45 08             	mov    0x8(%ebp),%eax
   1b5bb:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   1b5c1:	c1 e0 08             	shl    $0x8,%eax
   1b5c4:	89 c2                	mov    %eax,%edx
   1b5c6:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   1b5ca:	09 c2                	or     %eax,%edx
   1b5cc:	8b 45 08             	mov    0x8(%ebp),%eax
   1b5cf:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   1b5d5:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   1b5d9:	0f 85 a8 00 00 00    	jne    1b687 <_ShowBits+0x160>
            if(ctx->size){
   1b5df:	8b 45 08             	mov    0x8(%ebp),%eax
   1b5e2:	8b 40 08             	mov    0x8(%eax),%eax
   1b5e5:	85 c0                	test   %eax,%eax
   1b5e7:	0f 84 91 00 00 00    	je     1b67e <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   1b5ed:	8b 45 08             	mov    0x8(%ebp),%eax
   1b5f0:	8b 40 04             	mov    0x4(%eax),%eax
   1b5f3:	8d 48 01             	lea    0x1(%eax),%ecx
   1b5f6:	8b 55 08             	mov    0x8(%ebp),%edx
   1b5f9:	89 4a 04             	mov    %ecx,0x4(%edx)
   1b5fc:	0f b6 00             	movzbl (%eax),%eax
   1b5ff:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   1b602:	8b 45 08             	mov    0x8(%ebp),%eax
   1b605:	8b 40 08             	mov    0x8(%eax),%eax
   1b608:	8d 50 ff             	lea    -0x1(%eax),%edx
   1b60b:	8b 45 08             	mov    0x8(%ebp),%eax
   1b60e:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   1b611:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1b615:	85 c0                	test   %eax,%eax
   1b617:	74 62                	je     1b67b <_ShowBits+0x154>
   1b619:	3d d9 00 00 00       	cmp    $0xd9,%eax
   1b61e:	75 0c                	jne    1b62c <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   1b620:	8b 45 08             	mov    0x8(%ebp),%eax
   1b623:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   1b62a:	eb 5b                	jmp    1b687 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   1b62c:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1b630:	25 f8 00 00 00       	and    $0xf8,%eax
   1b635:	3d d0 00 00 00       	cmp    $0xd0,%eax
   1b63a:	74 0b                	je     1b647 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   1b63c:	8b 45 08             	mov    0x8(%ebp),%eax
   1b63f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1b645:	eb 40                	jmp    1b687 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   1b647:	8b 45 08             	mov    0x8(%ebp),%eax
   1b64a:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   1b650:	c1 e0 08             	shl    $0x8,%eax
   1b653:	89 c2                	mov    %eax,%edx
   1b655:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1b659:	09 c2                	or     %eax,%edx
   1b65b:	8b 45 08             	mov    0x8(%ebp),%eax
   1b65e:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   1b664:	8b 45 08             	mov    0x8(%ebp),%eax
   1b667:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1b66d:	8d 50 08             	lea    0x8(%eax),%edx
   1b670:	8b 45 08             	mov    0x8(%ebp),%eax
   1b673:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   1b679:	eb 0c                	jmp    1b687 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   1b67b:	90                   	nop
   1b67c:	eb 09                	jmp    1b687 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   1b67e:	8b 45 08             	mov    0x8(%ebp),%eax
   1b681:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   1b687:	8b 45 08             	mov    0x8(%ebp),%eax
   1b68a:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1b690:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1b693:	0f 8c a9 fe ff ff    	jl     1b542 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   1b699:	8b 45 08             	mov    0x8(%ebp),%eax
   1b69c:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   1b6a2:	8b 45 08             	mov    0x8(%ebp),%eax
   1b6a5:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1b6ab:	2b 45 0c             	sub    0xc(%ebp),%eax
   1b6ae:	89 c1                	mov    %eax,%ecx
   1b6b0:	d3 fa                	sar    %cl,%edx
   1b6b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   1b6b5:	bb 01 00 00 00       	mov    $0x1,%ebx
   1b6ba:	89 c1                	mov    %eax,%ecx
   1b6bc:	d3 e3                	shl    %cl,%ebx
   1b6be:	89 d8                	mov    %ebx,%eax
   1b6c0:	83 e8 01             	sub    $0x1,%eax
   1b6c3:	21 d0                	and    %edx,%eax
}
   1b6c5:	83 c4 10             	add    $0x10,%esp
   1b6c8:	5b                   	pop    %ebx
   1b6c9:	5d                   	pop    %ebp
   1b6ca:	c3                   	ret    

0001b6cb <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   1b6cb:	55                   	push   %ebp
   1b6cc:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   1b6ce:	8b 45 08             	mov    0x8(%ebp),%eax
   1b6d1:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1b6d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1b6da:	7d 0e                	jge    1b6ea <_SkipBits+0x1f>
   1b6dc:	ff 75 0c             	pushl  0xc(%ebp)
   1b6df:	ff 75 08             	pushl  0x8(%ebp)
   1b6e2:	e8 40 fe ff ff       	call   1b527 <_ShowBits>
   1b6e7:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   1b6ea:	8b 45 08             	mov    0x8(%ebp),%eax
   1b6ed:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1b6f3:	2b 45 0c             	sub    0xc(%ebp),%eax
   1b6f6:	89 c2                	mov    %eax,%edx
   1b6f8:	8b 45 08             	mov    0x8(%ebp),%eax
   1b6fb:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1b701:	90                   	nop
   1b702:	c9                   	leave  
   1b703:	c3                   	ret    

0001b704 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   1b704:	55                   	push   %ebp
   1b705:	89 e5                	mov    %esp,%ebp
   1b707:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   1b70a:	ff 75 0c             	pushl  0xc(%ebp)
   1b70d:	ff 75 08             	pushl  0x8(%ebp)
   1b710:	e8 12 fe ff ff       	call   1b527 <_ShowBits>
   1b715:	83 c4 08             	add    $0x8,%esp
   1b718:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   1b71b:	ff 75 0c             	pushl  0xc(%ebp)
   1b71e:	ff 75 08             	pushl  0x8(%ebp)
   1b721:	e8 a5 ff ff ff       	call   1b6cb <_SkipBits>
   1b726:	83 c4 08             	add    $0x8,%esp
    return res;
   1b729:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1b72c:	c9                   	leave  
   1b72d:	c3                   	ret    

0001b72e <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   1b72e:	55                   	push   %ebp
   1b72f:	89 e5                	mov    %esp,%ebp
   1b731:	57                   	push   %edi
   1b732:	56                   	push   %esi
   1b733:	53                   	push   %ebx
   1b734:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   1b737:	8b 45 08             	mov    0x8(%ebp),%eax
   1b73a:	83 c0 10             	add    $0x10,%eax
   1b73d:	8b 00                	mov    (%eax),%eax
   1b73f:	c1 e0 0b             	shl    $0xb,%eax
   1b742:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   1b745:	8b 45 08             	mov    0x8(%ebp),%eax
   1b748:	8b 40 18             	mov    0x18(%eax),%eax
   1b74b:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1b74e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b751:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   1b754:	8b 55 08             	mov    0x8(%ebp),%edx
   1b757:	8b 52 08             	mov    0x8(%edx),%edx
   1b75a:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1b75d:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   1b760:	8b 55 08             	mov    0x8(%ebp),%edx
   1b763:	8b 52 04             	mov    0x4(%edx),%edx
   1b766:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1b769:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   1b76c:	8b 55 08             	mov    0x8(%ebp),%edx
   1b76f:	8b 52 1c             	mov    0x1c(%edx),%edx
   1b772:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1b775:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   1b778:	8b 55 08             	mov    0x8(%ebp),%edx
   1b77b:	8b 52 14             	mov    0x14(%edx),%edx
   1b77e:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1b781:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   1b784:	8b 55 08             	mov    0x8(%ebp),%edx
   1b787:	8b 52 0c             	mov    0xc(%edx),%edx
   1b78a:	89 55 d8             	mov    %edx,-0x28(%ebp)
   1b78d:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   1b790:	85 c0                	test   %eax,%eax
   1b792:	75 68                	jne    1b7fc <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   1b794:	8b 45 08             	mov    0x8(%ebp),%eax
   1b797:	8d 48 04             	lea    0x4(%eax),%ecx
   1b79a:	8b 45 08             	mov    0x8(%ebp),%eax
   1b79d:	8d 58 08             	lea    0x8(%eax),%ebx
   1b7a0:	8b 45 08             	mov    0x8(%ebp),%eax
   1b7a3:	8d 70 0c             	lea    0xc(%eax),%esi
   1b7a6:	8b 45 08             	mov    0x8(%ebp),%eax
   1b7a9:	8d 78 10             	lea    0x10(%eax),%edi
   1b7ac:	8b 45 08             	mov    0x8(%ebp),%eax
   1b7af:	83 c0 14             	add    $0x14,%eax
   1b7b2:	89 45 c0             	mov    %eax,-0x40(%ebp)
   1b7b5:	8b 45 08             	mov    0x8(%ebp),%eax
   1b7b8:	83 c0 18             	add    $0x18,%eax
   1b7bb:	89 45 bc             	mov    %eax,-0x44(%ebp)
   1b7be:	8b 45 08             	mov    0x8(%ebp),%eax
   1b7c1:	8d 50 1c             	lea    0x1c(%eax),%edx
   1b7c4:	8b 45 08             	mov    0x8(%ebp),%eax
   1b7c7:	8b 00                	mov    (%eax),%eax
   1b7c9:	c1 e0 03             	shl    $0x3,%eax
   1b7cc:	89 02                	mov    %eax,(%edx)
   1b7ce:	8b 02                	mov    (%edx),%eax
   1b7d0:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1b7d3:	89 02                	mov    %eax,(%edx)
   1b7d5:	89 d0                	mov    %edx,%eax
   1b7d7:	8b 00                	mov    (%eax),%eax
   1b7d9:	8b 55 c0             	mov    -0x40(%ebp),%edx
   1b7dc:	89 02                	mov    %eax,(%edx)
   1b7de:	89 d0                	mov    %edx,%eax
   1b7e0:	8b 00                	mov    (%eax),%eax
   1b7e2:	89 07                	mov    %eax,(%edi)
   1b7e4:	8b 07                	mov    (%edi),%eax
   1b7e6:	89 06                	mov    %eax,(%esi)
   1b7e8:	8b 06                	mov    (%esi),%eax
   1b7ea:	89 03                	mov    %eax,(%ebx)
   1b7ec:	8b 03                	mov    (%ebx),%eax
   1b7ee:	89 01                	mov    %eax,(%ecx)
   1b7f0:	8b 11                	mov    (%ecx),%edx
   1b7f2:	8b 45 08             	mov    0x8(%ebp),%eax
   1b7f5:	89 10                	mov    %edx,(%eax)
        return;
   1b7f7:	e9 b7 01 00 00       	jmp    1b9b3 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   1b7fc:	8b 45 08             	mov    0x8(%ebp),%eax
   1b7ff:	8b 00                	mov    (%eax),%eax
   1b801:	c1 e0 0b             	shl    $0xb,%eax
   1b804:	83 e8 80             	sub    $0xffffff80,%eax
   1b807:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   1b80a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1b80d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1b810:	01 d0                	add    %edx,%eax
   1b812:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   1b818:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   1b81b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1b81e:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1b824:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1b827:	01 d0                	add    %edx,%eax
   1b829:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   1b82c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1b82f:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   1b835:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1b838:	01 d0                	add    %edx,%eax
   1b83a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   1b83d:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1b840:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1b843:	01 d0                	add    %edx,%eax
   1b845:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   1b84b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   1b84e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b851:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1b857:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1b85a:	01 d0                	add    %edx,%eax
   1b85c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   1b85f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1b862:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   1b868:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1b86b:	01 d0                	add    %edx,%eax
   1b86d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   1b870:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1b873:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b876:	01 d0                	add    %edx,%eax
   1b878:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   1b87b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b87e:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   1b881:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1b884:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1b887:	01 d0                	add    %edx,%eax
   1b889:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1b88f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   1b892:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1b895:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1b89b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b89e:	01 d0                	add    %edx,%eax
   1b8a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   1b8a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1b8a6:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   1b8ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b8af:	01 d0                	add    %edx,%eax
   1b8b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   1b8b4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1b8b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b8ba:	01 d0                	add    %edx,%eax
   1b8bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   1b8bf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1b8c2:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   1b8c5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1b8c8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1b8cb:	01 d0                	add    %edx,%eax
   1b8cd:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   1b8d0:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1b8d3:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   1b8d6:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1b8d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1b8dc:	01 d0                	add    %edx,%eax
   1b8de:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   1b8e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1b8e4:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   1b8e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1b8ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1b8ed:	01 d0                	add    %edx,%eax
   1b8ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   1b8f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1b8f5:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1b8f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1b8fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1b8fe:	01 d0                	add    %edx,%eax
   1b900:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1b906:	83 e8 80             	sub    $0xffffff80,%eax
   1b909:	c1 f8 08             	sar    $0x8,%eax
   1b90c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   1b90f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1b912:	2b 45 e0             	sub    -0x20(%ebp),%eax
   1b915:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1b91b:	83 e8 80             	sub    $0xffffff80,%eax
   1b91e:	c1 f8 08             	sar    $0x8,%eax
   1b921:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   1b924:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1b927:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1b92a:	01 d0                	add    %edx,%eax
   1b92c:	c1 f8 08             	sar    $0x8,%eax
   1b92f:	89 c2                	mov    %eax,%edx
   1b931:	8b 45 08             	mov    0x8(%ebp),%eax
   1b934:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   1b936:	8b 45 08             	mov    0x8(%ebp),%eax
   1b939:	83 c0 04             	add    $0x4,%eax
   1b93c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1b93f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1b942:	01 ca                	add    %ecx,%edx
   1b944:	c1 fa 08             	sar    $0x8,%edx
   1b947:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   1b949:	8b 45 08             	mov    0x8(%ebp),%eax
   1b94c:	83 c0 08             	add    $0x8,%eax
   1b94f:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   1b952:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1b955:	01 ca                	add    %ecx,%edx
   1b957:	c1 fa 08             	sar    $0x8,%edx
   1b95a:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   1b95c:	8b 45 08             	mov    0x8(%ebp),%eax
   1b95f:	83 c0 0c             	add    $0xc,%eax
   1b962:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   1b965:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1b968:	01 ca                	add    %ecx,%edx
   1b96a:	c1 fa 08             	sar    $0x8,%edx
   1b96d:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   1b96f:	8b 45 08             	mov    0x8(%ebp),%eax
   1b972:	8d 50 10             	lea    0x10(%eax),%edx
   1b975:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1b978:	2b 45 dc             	sub    -0x24(%ebp),%eax
   1b97b:	c1 f8 08             	sar    $0x8,%eax
   1b97e:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   1b980:	8b 45 08             	mov    0x8(%ebp),%eax
   1b983:	8d 50 14             	lea    0x14(%eax),%edx
   1b986:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1b989:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1b98c:	c1 f8 08             	sar    $0x8,%eax
   1b98f:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   1b991:	8b 45 08             	mov    0x8(%ebp),%eax
   1b994:	8d 50 18             	lea    0x18(%eax),%edx
   1b997:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1b99a:	2b 45 ec             	sub    -0x14(%ebp),%eax
   1b99d:	c1 f8 08             	sar    $0x8,%eax
   1b9a0:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   1b9a2:	8b 45 08             	mov    0x8(%ebp),%eax
   1b9a5:	8d 50 1c             	lea    0x1c(%eax),%edx
   1b9a8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1b9ab:	2b 45 f0             	sub    -0x10(%ebp),%eax
   1b9ae:	c1 f8 08             	sar    $0x8,%eax
   1b9b1:	89 02                	mov    %eax,(%edx)
}
   1b9b3:	83 c4 38             	add    $0x38,%esp
   1b9b6:	5b                   	pop    %ebx
   1b9b7:	5e                   	pop    %esi
   1b9b8:	5f                   	pop    %edi
   1b9b9:	5d                   	pop    %ebp
   1b9ba:	c3                   	ret    

0001b9bb <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   1b9bb:	55                   	push   %ebp
   1b9bc:	89 e5                	mov    %esp,%ebp
   1b9be:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1b9c1:	8b 45 08             	mov    0x8(%ebp),%eax
   1b9c4:	83 e8 80             	sub    $0xffffff80,%eax
   1b9c7:	8b 00                	mov    (%eax),%eax
   1b9c9:	c1 e0 08             	shl    $0x8,%eax
   1b9cc:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   1b9cf:	8b 45 08             	mov    0x8(%ebp),%eax
   1b9d2:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1b9d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1b9db:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1b9de:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   1b9e1:	8b 55 08             	mov    0x8(%ebp),%edx
   1b9e4:	8b 52 40             	mov    0x40(%edx),%edx
   1b9e7:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1b9ea:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   1b9ed:	8b 55 08             	mov    0x8(%ebp),%edx
   1b9f0:	8b 52 20             	mov    0x20(%edx),%edx
   1b9f3:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1b9f6:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   1b9f9:	8b 55 08             	mov    0x8(%ebp),%edx
   1b9fc:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   1ba02:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1ba05:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   1ba08:	8b 55 08             	mov    0x8(%ebp),%edx
   1ba0b:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   1ba11:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1ba14:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   1ba17:	8b 55 08             	mov    0x8(%ebp),%edx
   1ba1a:	8b 52 60             	mov    0x60(%edx),%edx
   1ba1d:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1ba20:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1ba23:	85 c0                	test   %eax,%eax
   1ba25:	75 45                	jne    1ba6c <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   1ba27:	8b 45 08             	mov    0x8(%ebp),%eax
   1ba2a:	8b 00                	mov    (%eax),%eax
   1ba2c:	83 c0 20             	add    $0x20,%eax
   1ba2f:	c1 f8 06             	sar    $0x6,%eax
   1ba32:	83 e8 80             	sub    $0xffffff80,%eax
   1ba35:	50                   	push   %eax
   1ba36:	e8 d6 ea ff ff       	call   1a511 <_Clip>
   1ba3b:	83 c4 04             	add    $0x4,%esp
   1ba3e:	0f b6 c0             	movzbl %al,%eax
   1ba41:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   1ba44:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   1ba4b:	eb 14                	jmp    1ba61 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   1ba4d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1ba50:	89 c2                	mov    %eax,%edx
   1ba52:	8b 45 0c             	mov    0xc(%ebp),%eax
   1ba55:	88 10                	mov    %dl,(%eax)
            out += stride;
   1ba57:	8b 45 10             	mov    0x10(%ebp),%eax
   1ba5a:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   1ba5d:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   1ba61:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1ba65:	75 e6                	jne    1ba4d <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   1ba67:	e9 57 02 00 00       	jmp    1bcc3 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   1ba6c:	8b 45 08             	mov    0x8(%ebp),%eax
   1ba6f:	8b 00                	mov    (%eax),%eax
   1ba71:	c1 e0 08             	shl    $0x8,%eax
   1ba74:	05 00 20 00 00       	add    $0x2000,%eax
   1ba79:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   1ba7c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1ba7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1ba82:	01 d0                	add    %edx,%eax
   1ba84:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   1ba8a:	83 c0 04             	add    $0x4,%eax
   1ba8d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   1ba90:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1ba93:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1ba99:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1ba9c:	01 d0                	add    %edx,%eax
   1ba9e:	c1 f8 03             	sar    $0x3,%eax
   1baa1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   1baa4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1baa7:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   1baad:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1bab0:	01 d0                	add    %edx,%eax
   1bab2:	c1 f8 03             	sar    $0x3,%eax
   1bab5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   1bab8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1babb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1babe:	01 d0                	add    %edx,%eax
   1bac0:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   1bac6:	83 c0 04             	add    $0x4,%eax
   1bac9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   1bacc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1bacf:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1bad5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1bad8:	01 d0                	add    %edx,%eax
   1bada:	c1 f8 03             	sar    $0x3,%eax
   1badd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   1bae0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bae3:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   1bae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1baec:	01 d0                	add    %edx,%eax
   1baee:	c1 f8 03             	sar    $0x3,%eax
   1baf1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1baf4:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1baf7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1bafa:	01 d0                	add    %edx,%eax
   1bafc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   1baff:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1bb02:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1bb05:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1bb08:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1bb0b:	01 d0                	add    %edx,%eax
   1bb0d:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1bb13:	83 c0 04             	add    $0x4,%eax
   1bb16:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   1bb19:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1bb1c:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1bb22:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1bb25:	01 d0                	add    %edx,%eax
   1bb27:	c1 f8 03             	sar    $0x3,%eax
   1bb2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   1bb2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1bb30:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   1bb36:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1bb39:	01 d0                	add    %edx,%eax
   1bb3b:	c1 f8 03             	sar    $0x3,%eax
   1bb3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   1bb41:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1bb44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1bb47:	01 d0                	add    %edx,%eax
   1bb49:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   1bb4c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1bb4f:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   1bb52:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1bb55:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bb58:	01 d0                	add    %edx,%eax
   1bb5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   1bb5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bb60:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   1bb63:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1bb66:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1bb69:	01 d0                	add    %edx,%eax
   1bb6b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   1bb6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1bb71:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   1bb74:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1bb77:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1bb7a:	01 d0                	add    %edx,%eax
   1bb7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   1bb7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1bb82:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1bb85:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1bb88:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1bb8b:	01 d0                	add    %edx,%eax
   1bb8d:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1bb93:	83 e8 80             	sub    $0xffffff80,%eax
   1bb96:	c1 f8 08             	sar    $0x8,%eax
   1bb99:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   1bb9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1bb9f:	2b 45 e8             	sub    -0x18(%ebp),%eax
   1bba2:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1bba8:	83 e8 80             	sub    $0xffffff80,%eax
   1bbab:	c1 f8 08             	sar    $0x8,%eax
   1bbae:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   1bbb1:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1bbb4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1bbb7:	01 d0                	add    %edx,%eax
   1bbb9:	c1 f8 0e             	sar    $0xe,%eax
   1bbbc:	83 e8 80             	sub    $0xffffff80,%eax
   1bbbf:	50                   	push   %eax
   1bbc0:	e8 4c e9 ff ff       	call   1a511 <_Clip>
   1bbc5:	83 c4 04             	add    $0x4,%esp
   1bbc8:	89 c2                	mov    %eax,%edx
   1bbca:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bbcd:	88 10                	mov    %dl,(%eax)
   1bbcf:	8b 45 10             	mov    0x10(%ebp),%eax
   1bbd2:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   1bbd5:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1bbd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1bbdb:	01 d0                	add    %edx,%eax
   1bbdd:	c1 f8 0e             	sar    $0xe,%eax
   1bbe0:	83 e8 80             	sub    $0xffffff80,%eax
   1bbe3:	50                   	push   %eax
   1bbe4:	e8 28 e9 ff ff       	call   1a511 <_Clip>
   1bbe9:	83 c4 04             	add    $0x4,%esp
   1bbec:	89 c2                	mov    %eax,%edx
   1bbee:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bbf1:	88 10                	mov    %dl,(%eax)
   1bbf3:	8b 45 10             	mov    0x10(%ebp),%eax
   1bbf6:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   1bbf9:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1bbfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1bbff:	01 d0                	add    %edx,%eax
   1bc01:	c1 f8 0e             	sar    $0xe,%eax
   1bc04:	83 e8 80             	sub    $0xffffff80,%eax
   1bc07:	50                   	push   %eax
   1bc08:	e8 04 e9 ff ff       	call   1a511 <_Clip>
   1bc0d:	83 c4 04             	add    $0x4,%esp
   1bc10:	89 c2                	mov    %eax,%edx
   1bc12:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bc15:	88 10                	mov    %dl,(%eax)
   1bc17:	8b 45 10             	mov    0x10(%ebp),%eax
   1bc1a:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   1bc1d:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1bc20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1bc23:	01 d0                	add    %edx,%eax
   1bc25:	c1 f8 0e             	sar    $0xe,%eax
   1bc28:	83 e8 80             	sub    $0xffffff80,%eax
   1bc2b:	50                   	push   %eax
   1bc2c:	e8 e0 e8 ff ff       	call   1a511 <_Clip>
   1bc31:	83 c4 04             	add    $0x4,%esp
   1bc34:	89 c2                	mov    %eax,%edx
   1bc36:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bc39:	88 10                	mov    %dl,(%eax)
   1bc3b:	8b 45 10             	mov    0x10(%ebp),%eax
   1bc3e:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   1bc41:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1bc44:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1bc47:	c1 f8 0e             	sar    $0xe,%eax
   1bc4a:	83 e8 80             	sub    $0xffffff80,%eax
   1bc4d:	50                   	push   %eax
   1bc4e:	e8 be e8 ff ff       	call   1a511 <_Clip>
   1bc53:	83 c4 04             	add    $0x4,%esp
   1bc56:	89 c2                	mov    %eax,%edx
   1bc58:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bc5b:	88 10                	mov    %dl,(%eax)
   1bc5d:	8b 45 10             	mov    0x10(%ebp),%eax
   1bc60:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   1bc63:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1bc66:	2b 45 ec             	sub    -0x14(%ebp),%eax
   1bc69:	c1 f8 0e             	sar    $0xe,%eax
   1bc6c:	83 e8 80             	sub    $0xffffff80,%eax
   1bc6f:	50                   	push   %eax
   1bc70:	e8 9c e8 ff ff       	call   1a511 <_Clip>
   1bc75:	83 c4 04             	add    $0x4,%esp
   1bc78:	89 c2                	mov    %eax,%edx
   1bc7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bc7d:	88 10                	mov    %dl,(%eax)
   1bc7f:	8b 45 10             	mov    0x10(%ebp),%eax
   1bc82:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   1bc85:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1bc88:	2b 45 f4             	sub    -0xc(%ebp),%eax
   1bc8b:	c1 f8 0e             	sar    $0xe,%eax
   1bc8e:	83 e8 80             	sub    $0xffffff80,%eax
   1bc91:	50                   	push   %eax
   1bc92:	e8 7a e8 ff ff       	call   1a511 <_Clip>
   1bc97:	83 c4 04             	add    $0x4,%esp
   1bc9a:	89 c2                	mov    %eax,%edx
   1bc9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bc9f:	88 10                	mov    %dl,(%eax)
   1bca1:	8b 45 10             	mov    0x10(%ebp),%eax
   1bca4:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   1bca7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bcaa:	2b 45 f8             	sub    -0x8(%ebp),%eax
   1bcad:	c1 f8 0e             	sar    $0xe,%eax
   1bcb0:	83 e8 80             	sub    $0xffffff80,%eax
   1bcb3:	50                   	push   %eax
   1bcb4:	e8 58 e8 ff ff       	call   1a511 <_Clip>
   1bcb9:	83 c4 04             	add    $0x4,%esp
   1bcbc:	89 c2                	mov    %eax,%edx
   1bcbe:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bcc1:	88 10                	mov    %dl,(%eax)
}
   1bcc3:	c9                   	leave  
   1bcc4:	c3                   	ret    

0001bcc5 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   1bcc5:	55                   	push   %ebp
   1bcc6:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   1bcc8:	8b 45 08             	mov    0x8(%ebp),%eax
   1bccb:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1bcd1:	25 f8 00 00 00       	and    $0xf8,%eax
   1bcd6:	89 c2                	mov    %eax,%edx
   1bcd8:	8b 45 08             	mov    0x8(%ebp),%eax
   1bcdb:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1bce1:	90                   	nop
   1bce2:	5d                   	pop    %ebp
   1bce3:	c3                   	ret    

0001bce4 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   1bce4:	55                   	push   %ebp
   1bce5:	89 e5                	mov    %esp,%ebp
   1bce7:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   1bcea:	83 ec 0c             	sub    $0xc,%esp
   1bced:	ff 75 08             	pushl  0x8(%ebp)
   1bcf0:	e8 8d e8 ff ff       	call   1a582 <_DecodeLength>
   1bcf5:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   1bcf8:	8b 45 08             	mov    0x8(%ebp),%eax
   1bcfb:	8b 40 0c             	mov    0xc(%eax),%eax
   1bcfe:	83 ec 08             	sub    $0x8,%esp
   1bd01:	50                   	push   %eax
   1bd02:	ff 75 08             	pushl  0x8(%ebp)
   1bd05:	e8 2c e8 ff ff       	call   1a536 <_Skip>
   1bd0a:	83 c4 10             	add    $0x10,%esp
}
   1bd0d:	90                   	nop
   1bd0e:	c9                   	leave  
   1bd0f:	c3                   	ret    

0001bd10 <_Convert>:

void _Convert(Context* ctx){
   1bd10:	55                   	push   %ebp
   1bd11:	89 e5                	mov    %esp,%ebp
   1bd13:	57                   	push   %edi
   1bd14:	56                   	push   %esi
   1bd15:	53                   	push   %ebx
   1bd16:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1bd19:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1bd20:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd23:	83 c0 2c             	add    $0x2c,%eax
   1bd26:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1bd29:	e9 b2 00 00 00       	jmp    1bde0 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   1bd2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bd31:	8b 50 0c             	mov    0xc(%eax),%edx
   1bd34:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd37:	8b 40 10             	mov    0x10(%eax),%eax
   1bd3a:	39 c2                	cmp    %eax,%edx
   1bd3c:	7d 11                	jge    1bd4f <_Convert+0x3f>
   1bd3e:	83 ec 08             	sub    $0x8,%esp
   1bd41:	ff 75 e0             	pushl  -0x20(%ebp)
   1bd44:	ff 75 08             	pushl  0x8(%ebp)
   1bd47:	e8 79 02 00 00       	call   1bfc5 <_UpsampleH>
   1bd4c:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   1bd4f:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd52:	8b 00                	mov    (%eax),%eax
   1bd54:	85 c0                	test   %eax,%eax
   1bd56:	0f 85 5d 02 00 00    	jne    1bfb9 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   1bd5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bd5f:	8b 50 10             	mov    0x10(%eax),%edx
   1bd62:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd65:	8b 40 14             	mov    0x14(%eax),%eax
   1bd68:	39 c2                	cmp    %eax,%edx
   1bd6a:	7d 11                	jge    1bd7d <_Convert+0x6d>
   1bd6c:	83 ec 08             	sub    $0x8,%esp
   1bd6f:	ff 75 e0             	pushl  -0x20(%ebp)
   1bd72:	ff 75 08             	pushl  0x8(%ebp)
   1bd75:	e8 db 05 00 00       	call   1c355 <_UpsampleV>
   1bd7a:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   1bd7d:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd80:	8b 00                	mov    (%eax),%eax
   1bd82:	85 c0                	test   %eax,%eax
   1bd84:	0f 85 32 02 00 00    	jne    1bfbc <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   1bd8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bd8d:	8b 50 0c             	mov    0xc(%eax),%edx
   1bd90:	8b 45 08             	mov    0x8(%ebp),%eax
   1bd93:	8b 40 10             	mov    0x10(%eax),%eax
   1bd96:	39 c2                	cmp    %eax,%edx
   1bd98:	7c 94                	jl     1bd2e <_Convert+0x1e>
   1bd9a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bd9d:	8b 50 10             	mov    0x10(%eax),%edx
   1bda0:	8b 45 08             	mov    0x8(%ebp),%eax
   1bda3:	8b 40 14             	mov    0x14(%eax),%eax
   1bda6:	39 c2                	cmp    %eax,%edx
   1bda8:	7c 84                	jl     1bd2e <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   1bdaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bdad:	8b 50 0c             	mov    0xc(%eax),%edx
   1bdb0:	8b 45 08             	mov    0x8(%ebp),%eax
   1bdb3:	8b 40 10             	mov    0x10(%eax),%eax
   1bdb6:	39 c2                	cmp    %eax,%edx
   1bdb8:	7c 10                	jl     1bdca <_Convert+0xba>
   1bdba:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1bdbd:	8b 50 10             	mov    0x10(%eax),%edx
   1bdc0:	8b 45 08             	mov    0x8(%ebp),%eax
   1bdc3:	8b 40 14             	mov    0x14(%eax),%eax
   1bdc6:	39 c2                	cmp    %eax,%edx
   1bdc8:	7d 0e                	jge    1bdd8 <_Convert+0xc8>
   1bdca:	8b 45 08             	mov    0x8(%ebp),%eax
   1bdcd:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   1bdd3:	e9 e5 01 00 00       	jmp    1bfbd <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1bdd8:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1bddc:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   1bde0:	8b 45 08             	mov    0x8(%ebp),%eax
   1bde3:	8b 40 28             	mov    0x28(%eax),%eax
   1bde6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1bde9:	7f 9f                	jg     1bd8a <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   1bdeb:	8b 45 08             	mov    0x8(%ebp),%eax
   1bdee:	8b 40 28             	mov    0x28(%eax),%eax
   1bdf1:	83 f8 03             	cmp    $0x3,%eax
   1bdf4:	0f 85 3d 01 00 00    	jne    1bf37 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   1bdfa:	8b 45 08             	mov    0x8(%ebp),%eax
   1bdfd:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1be03:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   1be06:	8b 45 08             	mov    0x8(%ebp),%eax
   1be09:	8b 40 54             	mov    0x54(%eax),%eax
   1be0c:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   1be0f:	8b 45 08             	mov    0x8(%ebp),%eax
   1be12:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1be18:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   1be1b:	8b 45 08             	mov    0x8(%ebp),%eax
   1be1e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1be24:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   1be27:	8b 45 08             	mov    0x8(%ebp),%eax
   1be2a:	8b 40 14             	mov    0x14(%eax),%eax
   1be2d:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1be30:	e9 f3 00 00 00       	jmp    1bf28 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   1be35:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   1be3c:	e9 b6 00 00 00       	jmp    1bef7 <_Convert+0x1e7>
                register int y = py[x] << 8;
   1be41:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1be44:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1be47:	01 d0                	add    %edx,%eax
   1be49:	0f b6 00             	movzbl (%eax),%eax
   1be4c:	0f b6 c0             	movzbl %al,%eax
   1be4f:	c1 e0 08             	shl    $0x8,%eax
   1be52:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   1be54:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1be57:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1be5a:	01 d0                	add    %edx,%eax
   1be5c:	0f b6 00             	movzbl (%eax),%eax
   1be5f:	0f b6 c0             	movzbl %al,%eax
   1be62:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   1be65:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1be68:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1be6b:	01 d0                	add    %edx,%eax
   1be6d:	0f b6 00             	movzbl (%eax),%eax
   1be70:	0f b6 c0             	movzbl %al,%eax
   1be73:	83 c0 80             	add    $0xffffff80,%eax
   1be76:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   1be78:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1be7b:	8d 46 01             	lea    0x1(%esi),%eax
   1be7e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1be81:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   1be84:	89 c8                	mov    %ecx,%eax
   1be86:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   1be8c:	01 d8                	add    %ebx,%eax
   1be8e:	83 e8 80             	sub    $0xffffff80,%eax
   1be91:	c1 f8 08             	sar    $0x8,%eax
   1be94:	83 ec 0c             	sub    $0xc,%esp
   1be97:	50                   	push   %eax
   1be98:	e8 74 e6 ff ff       	call   1a511 <_Clip>
   1be9d:	83 c4 10             	add    $0x10,%esp
   1bea0:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   1bea2:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1bea5:	8d 46 01             	lea    0x1(%esi),%eax
   1bea8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1beab:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   1beae:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   1beb1:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   1beb8:	01 d0                	add    %edx,%eax
   1beba:	83 e8 80             	sub    $0xffffff80,%eax
   1bebd:	c1 f8 08             	sar    $0x8,%eax
   1bec0:	83 ec 0c             	sub    $0xc,%esp
   1bec3:	50                   	push   %eax
   1bec4:	e8 48 e6 ff ff       	call   1a511 <_Clip>
   1bec9:	83 c4 10             	add    $0x10,%esp
   1becc:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   1bece:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1bed1:	8d 46 01             	lea    0x1(%esi),%eax
   1bed4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1bed7:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   1bedd:	01 d8                	add    %ebx,%eax
   1bedf:	83 e8 80             	sub    $0xffffff80,%eax
   1bee2:	c1 f8 08             	sar    $0x8,%eax
   1bee5:	83 ec 0c             	sub    $0xc,%esp
   1bee8:	50                   	push   %eax
   1bee9:	e8 23 e6 ff ff       	call   1a511 <_Clip>
   1beee:	83 c4 10             	add    $0x10,%esp
   1bef1:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   1bef3:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   1bef7:	8b 45 08             	mov    0x8(%ebp),%eax
   1befa:	8b 40 10             	mov    0x10(%eax),%eax
   1befd:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   1bf00:	0f 8f 3b ff ff ff    	jg     1be41 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   1bf06:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf09:	8b 40 40             	mov    0x40(%eax),%eax
   1bf0c:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   1bf0f:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf12:	8b 40 6c             	mov    0x6c(%eax),%eax
   1bf15:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   1bf18:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf1b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1bf21:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   1bf24:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   1bf28:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1bf2c:	0f 85 03 ff ff ff    	jne    1be35 <_Convert+0x125>
   1bf32:	e9 86 00 00 00       	jmp    1bfbd <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   1bf37:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf3a:	8b 50 38             	mov    0x38(%eax),%edx
   1bf3d:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf40:	8b 40 40             	mov    0x40(%eax),%eax
   1bf43:	39 c2                	cmp    %eax,%edx
   1bf45:	74 76                	je     1bfbd <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   1bf47:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf4a:	8b 50 54             	mov    0x54(%eax),%edx
   1bf4d:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf50:	8b 40 40             	mov    0x40(%eax),%eax
   1bf53:	01 d0                	add    %edx,%eax
   1bf55:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   1bf58:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf5b:	8b 50 54             	mov    0x54(%eax),%edx
   1bf5e:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf61:	8b 40 38             	mov    0x38(%eax),%eax
   1bf64:	01 d0                	add    %edx,%eax
   1bf66:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   1bf69:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf6c:	8b 40 3c             	mov    0x3c(%eax),%eax
   1bf6f:	83 e8 01             	sub    $0x1,%eax
   1bf72:	89 45 bc             	mov    %eax,-0x44(%ebp)
   1bf75:	eb 2e                	jmp    1bfa5 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   1bf77:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf7a:	8b 40 38             	mov    0x38(%eax),%eax
   1bf7d:	83 ec 04             	sub    $0x4,%esp
   1bf80:	50                   	push   %eax
   1bf81:	ff 75 c4             	pushl  -0x3c(%ebp)
   1bf84:	ff 75 c0             	pushl  -0x40(%ebp)
   1bf87:	e8 72 ac fe ff       	call   6bfe <memmove>
   1bf8c:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   1bf8f:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf92:	8b 40 40             	mov    0x40(%eax),%eax
   1bf95:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   1bf98:	8b 45 08             	mov    0x8(%ebp),%eax
   1bf9b:	8b 40 38             	mov    0x38(%eax),%eax
   1bf9e:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   1bfa1:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   1bfa5:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   1bfa9:	75 cc                	jne    1bf77 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   1bfab:	8b 45 08             	mov    0x8(%ebp),%eax
   1bfae:	8b 50 38             	mov    0x38(%eax),%edx
   1bfb1:	8b 45 08             	mov    0x8(%ebp),%eax
   1bfb4:	89 50 40             	mov    %edx,0x40(%eax)
   1bfb7:	eb 04                	jmp    1bfbd <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   1bfb9:	90                   	nop
   1bfba:	eb 01                	jmp    1bfbd <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   1bfbc:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   1bfbd:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1bfc0:	5b                   	pop    %ebx
   1bfc1:	5e                   	pop    %esi
   1bfc2:	5f                   	pop    %edi
   1bfc3:	5d                   	pop    %ebp
   1bfc4:	c3                   	ret    

0001bfc5 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   1bfc5:	55                   	push   %ebp
   1bfc6:	89 e5                	mov    %esp,%ebp
   1bfc8:	53                   	push   %ebx
   1bfc9:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   1bfcc:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bfcf:	8b 40 0c             	mov    0xc(%eax),%eax
   1bfd2:	83 e8 03             	sub    $0x3,%eax
   1bfd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   1bfd8:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bfdb:	8b 50 0c             	mov    0xc(%eax),%edx
   1bfde:	8b 45 0c             	mov    0xc(%ebp),%eax
   1bfe1:	8b 40 10             	mov    0x10(%eax),%eax
   1bfe4:	0f af c2             	imul   %edx,%eax
   1bfe7:	01 c0                	add    %eax,%eax
   1bfe9:	83 ec 0c             	sub    $0xc,%esp
   1bfec:	50                   	push   %eax
   1bfed:	e8 cb b0 fe ff       	call   70bd <malloc>
   1bff2:	83 c4 10             	add    $0x10,%esp
   1bff5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   1bff8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1bffc:	75 0e                	jne    1c00c <_UpsampleH+0x47>
   1bffe:	8b 45 08             	mov    0x8(%ebp),%eax
   1c001:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1c007:	e9 44 03 00 00       	jmp    1c350 <_UpsampleH+0x38b>
    lin = c->pixels;
   1c00c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c00f:	8b 40 28             	mov    0x28(%eax),%eax
   1c012:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   1c015:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c018:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   1c01b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c01e:	8b 40 10             	mov    0x10(%eax),%eax
   1c021:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   1c024:	e9 e0 02 00 00       	jmp    1c309 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   1c029:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c02c:	0f b6 00             	movzbl (%eax),%eax
   1c02f:	0f b6 c0             	movzbl %al,%eax
   1c032:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1c038:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c03b:	83 c0 01             	add    $0x1,%eax
   1c03e:	0f b6 00             	movzbl (%eax),%eax
   1c041:	0f b6 c0             	movzbl %al,%eax
   1c044:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1c047:	01 d0                	add    %edx,%eax
   1c049:	83 ec 0c             	sub    $0xc,%esp
   1c04c:	50                   	push   %eax
   1c04d:	e8 c4 06 00 00       	call   1c716 <CF>
   1c052:	83 c4 10             	add    $0x10,%esp
   1c055:	89 c2                	mov    %eax,%edx
   1c057:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c05a:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   1c05c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c05f:	8d 58 01             	lea    0x1(%eax),%ebx
   1c062:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c065:	0f b6 00             	movzbl (%eax),%eax
   1c068:	0f b6 c0             	movzbl %al,%eax
   1c06b:	6b c8 68             	imul   $0x68,%eax,%ecx
   1c06e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c071:	83 c0 01             	add    $0x1,%eax
   1c074:	0f b6 00             	movzbl (%eax),%eax
   1c077:	0f b6 d0             	movzbl %al,%edx
   1c07a:	89 d0                	mov    %edx,%eax
   1c07c:	01 c0                	add    %eax,%eax
   1c07e:	01 d0                	add    %edx,%eax
   1c080:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1c087:	01 d0                	add    %edx,%eax
   1c089:	01 c1                	add    %eax,%ecx
   1c08b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c08e:	83 c0 02             	add    $0x2,%eax
   1c091:	0f b6 00             	movzbl (%eax),%eax
   1c094:	0f b6 d0             	movzbl %al,%edx
   1c097:	89 d0                	mov    %edx,%eax
   1c099:	01 c0                	add    %eax,%eax
   1c09b:	01 d0                	add    %edx,%eax
   1c09d:	f7 d8                	neg    %eax
   1c09f:	01 c8                	add    %ecx,%eax
   1c0a1:	83 ec 0c             	sub    $0xc,%esp
   1c0a4:	50                   	push   %eax
   1c0a5:	e8 6c 06 00 00       	call   1c716 <CF>
   1c0aa:	83 c4 10             	add    $0x10,%esp
   1c0ad:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   1c0af:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c0b2:	8d 58 02             	lea    0x2(%eax),%ebx
   1c0b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c0b8:	0f b6 00             	movzbl (%eax),%eax
   1c0bb:	0f b6 c0             	movzbl %al,%eax
   1c0be:	c1 e0 02             	shl    $0x2,%eax
   1c0c1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1c0c8:	29 c2                	sub    %eax,%edx
   1c0ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c0cd:	83 c0 01             	add    $0x1,%eax
   1c0d0:	0f b6 00             	movzbl (%eax),%eax
   1c0d3:	0f b6 c0             	movzbl %al,%eax
   1c0d6:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1c0d9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1c0dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c0df:	83 c0 02             	add    $0x2,%eax
   1c0e2:	0f b6 00             	movzbl (%eax),%eax
   1c0e5:	0f b6 d0             	movzbl %al,%edx
   1c0e8:	89 d0                	mov    %edx,%eax
   1c0ea:	c1 e0 03             	shl    $0x3,%eax
   1c0ed:	01 d0                	add    %edx,%eax
   1c0ef:	f7 d8                	neg    %eax
   1c0f1:	01 c8                	add    %ecx,%eax
   1c0f3:	83 ec 0c             	sub    $0xc,%esp
   1c0f6:	50                   	push   %eax
   1c0f7:	e8 1a 06 00 00       	call   1c716 <CF>
   1c0fc:	83 c4 10             	add    $0x10,%esp
   1c0ff:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   1c101:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1c108:	e9 fa 00 00 00       	jmp    1c207 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   1c10d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c110:	01 c0                	add    %eax,%eax
   1c112:	8d 50 03             	lea    0x3(%eax),%edx
   1c115:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c118:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1c11b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1c11e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c121:	01 d0                	add    %edx,%eax
   1c123:	0f b6 00             	movzbl (%eax),%eax
   1c126:	0f b6 d0             	movzbl %al,%edx
   1c129:	89 d0                	mov    %edx,%eax
   1c12b:	c1 e0 03             	shl    $0x3,%eax
   1c12e:	01 d0                	add    %edx,%eax
   1c130:	f7 d8                	neg    %eax
   1c132:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1c135:	8d 4a 01             	lea    0x1(%edx),%ecx
   1c138:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1c13b:	01 ca                	add    %ecx,%edx
   1c13d:	0f b6 12             	movzbl (%edx),%edx
   1c140:	0f b6 d2             	movzbl %dl,%edx
   1c143:	6b d2 6f             	imul   $0x6f,%edx,%edx
   1c146:	01 c2                	add    %eax,%edx
   1c148:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c14b:	8d 48 02             	lea    0x2(%eax),%ecx
   1c14e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c151:	01 c8                	add    %ecx,%eax
   1c153:	0f b6 00             	movzbl (%eax),%eax
   1c156:	0f b6 c0             	movzbl %al,%eax
   1c159:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1c15c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1c15f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c162:	8d 50 03             	lea    0x3(%eax),%edx
   1c165:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c168:	01 d0                	add    %edx,%eax
   1c16a:	0f b6 00             	movzbl (%eax),%eax
   1c16d:	0f b6 d0             	movzbl %al,%edx
   1c170:	89 d0                	mov    %edx,%eax
   1c172:	01 c0                	add    %eax,%eax
   1c174:	01 d0                	add    %edx,%eax
   1c176:	f7 d8                	neg    %eax
   1c178:	01 c8                	add    %ecx,%eax
   1c17a:	83 ec 0c             	sub    $0xc,%esp
   1c17d:	50                   	push   %eax
   1c17e:	e8 93 05 00 00       	call   1c716 <CF>
   1c183:	83 c4 10             	add    $0x10,%esp
   1c186:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   1c188:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c18b:	01 c0                	add    %eax,%eax
   1c18d:	8d 50 04             	lea    0x4(%eax),%edx
   1c190:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c193:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1c196:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1c199:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c19c:	01 d0                	add    %edx,%eax
   1c19e:	0f b6 00             	movzbl (%eax),%eax
   1c1a1:	0f b6 d0             	movzbl %al,%edx
   1c1a4:	89 d0                	mov    %edx,%eax
   1c1a6:	01 c0                	add    %eax,%eax
   1c1a8:	01 d0                	add    %edx,%eax
   1c1aa:	f7 d8                	neg    %eax
   1c1ac:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1c1af:	8d 4a 01             	lea    0x1(%edx),%ecx
   1c1b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1c1b5:	01 ca                	add    %ecx,%edx
   1c1b7:	0f b6 12             	movzbl (%edx),%edx
   1c1ba:	0f b6 d2             	movzbl %dl,%edx
   1c1bd:	6b d2 1d             	imul   $0x1d,%edx,%edx
   1c1c0:	01 c2                	add    %eax,%edx
   1c1c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c1c5:	8d 48 02             	lea    0x2(%eax),%ecx
   1c1c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c1cb:	01 c8                	add    %ecx,%eax
   1c1cd:	0f b6 00             	movzbl (%eax),%eax
   1c1d0:	0f b6 c0             	movzbl %al,%eax
   1c1d3:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1c1d6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1c1d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c1dc:	8d 50 03             	lea    0x3(%eax),%edx
   1c1df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c1e2:	01 d0                	add    %edx,%eax
   1c1e4:	0f b6 00             	movzbl (%eax),%eax
   1c1e7:	0f b6 d0             	movzbl %al,%edx
   1c1ea:	89 d0                	mov    %edx,%eax
   1c1ec:	c1 e0 03             	shl    $0x3,%eax
   1c1ef:	01 d0                	add    %edx,%eax
   1c1f1:	f7 d8                	neg    %eax
   1c1f3:	01 c8                	add    %ecx,%eax
   1c1f5:	83 ec 0c             	sub    $0xc,%esp
   1c1f8:	50                   	push   %eax
   1c1f9:	e8 18 05 00 00       	call   1c716 <CF>
   1c1fe:	83 c4 10             	add    $0x10,%esp
   1c201:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   1c203:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1c207:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c20a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1c20d:	0f 8c fa fe ff ff    	jl     1c10d <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   1c213:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c216:	8b 40 14             	mov    0x14(%eax),%eax
   1c219:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   1c21c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c21f:	8b 40 0c             	mov    0xc(%eax),%eax
   1c222:	01 c0                	add    %eax,%eax
   1c224:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   1c227:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c22a:	8d 58 fd             	lea    -0x3(%eax),%ebx
   1c22d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c230:	83 e8 01             	sub    $0x1,%eax
   1c233:	0f b6 00             	movzbl (%eax),%eax
   1c236:	0f b6 c0             	movzbl %al,%eax
   1c239:	c1 e0 02             	shl    $0x2,%eax
   1c23c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1c243:	29 c2                	sub    %eax,%edx
   1c245:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c248:	83 e8 02             	sub    $0x2,%eax
   1c24b:	0f b6 00             	movzbl (%eax),%eax
   1c24e:	0f b6 c0             	movzbl %al,%eax
   1c251:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1c254:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1c257:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c25a:	83 e8 03             	sub    $0x3,%eax
   1c25d:	0f b6 00             	movzbl (%eax),%eax
   1c260:	0f b6 d0             	movzbl %al,%edx
   1c263:	89 d0                	mov    %edx,%eax
   1c265:	c1 e0 03             	shl    $0x3,%eax
   1c268:	01 d0                	add    %edx,%eax
   1c26a:	f7 d8                	neg    %eax
   1c26c:	01 c8                	add    %ecx,%eax
   1c26e:	83 ec 0c             	sub    $0xc,%esp
   1c271:	50                   	push   %eax
   1c272:	e8 9f 04 00 00       	call   1c716 <CF>
   1c277:	83 c4 10             	add    $0x10,%esp
   1c27a:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   1c27c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c27f:	8d 58 fe             	lea    -0x2(%eax),%ebx
   1c282:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c285:	83 e8 01             	sub    $0x1,%eax
   1c288:	0f b6 00             	movzbl (%eax),%eax
   1c28b:	0f b6 c0             	movzbl %al,%eax
   1c28e:	6b c8 68             	imul   $0x68,%eax,%ecx
   1c291:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c294:	83 e8 02             	sub    $0x2,%eax
   1c297:	0f b6 00             	movzbl (%eax),%eax
   1c29a:	0f b6 d0             	movzbl %al,%edx
   1c29d:	89 d0                	mov    %edx,%eax
   1c29f:	01 c0                	add    %eax,%eax
   1c2a1:	01 d0                	add    %edx,%eax
   1c2a3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1c2aa:	01 d0                	add    %edx,%eax
   1c2ac:	01 c1                	add    %eax,%ecx
   1c2ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c2b1:	83 e8 03             	sub    $0x3,%eax
   1c2b4:	0f b6 00             	movzbl (%eax),%eax
   1c2b7:	0f b6 d0             	movzbl %al,%edx
   1c2ba:	89 d0                	mov    %edx,%eax
   1c2bc:	01 c0                	add    %eax,%eax
   1c2be:	01 d0                	add    %edx,%eax
   1c2c0:	f7 d8                	neg    %eax
   1c2c2:	01 c8                	add    %ecx,%eax
   1c2c4:	83 ec 0c             	sub    $0xc,%esp
   1c2c7:	50                   	push   %eax
   1c2c8:	e8 49 04 00 00       	call   1c716 <CF>
   1c2cd:	83 c4 10             	add    $0x10,%esp
   1c2d0:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   1c2d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c2d5:	8d 58 ff             	lea    -0x1(%eax),%ebx
   1c2d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c2db:	83 e8 01             	sub    $0x1,%eax
   1c2de:	0f b6 00             	movzbl (%eax),%eax
   1c2e1:	0f b6 c0             	movzbl %al,%eax
   1c2e4:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1c2ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c2ed:	83 e8 02             	sub    $0x2,%eax
   1c2f0:	0f b6 00             	movzbl (%eax),%eax
   1c2f3:	0f b6 c0             	movzbl %al,%eax
   1c2f6:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1c2f9:	01 d0                	add    %edx,%eax
   1c2fb:	83 ec 0c             	sub    $0xc,%esp
   1c2fe:	50                   	push   %eax
   1c2ff:	e8 12 04 00 00       	call   1c716 <CF>
   1c304:	83 c4 10             	add    $0x10,%esp
   1c307:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   1c309:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1c30c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1c30f:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1c312:	85 c0                	test   %eax,%eax
   1c314:	0f 85 0f fd ff ff    	jne    1c029 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   1c31a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c31d:	8b 40 0c             	mov    0xc(%eax),%eax
   1c320:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1c323:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c326:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   1c329:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c32c:	8b 50 0c             	mov    0xc(%eax),%edx
   1c32f:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c332:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   1c335:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c338:	8b 40 28             	mov    0x28(%eax),%eax
   1c33b:	83 ec 0c             	sub    $0xc,%esp
   1c33e:	50                   	push   %eax
   1c33f:	e8 37 ac fe ff       	call   6f7b <free>
   1c344:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   1c347:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c34a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1c34d:	89 50 28             	mov    %edx,0x28(%eax)
}
   1c350:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1c353:	c9                   	leave  
   1c354:	c3                   	ret    

0001c355 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   1c355:	55                   	push   %ebp
   1c356:	89 e5                	mov    %esp,%ebp
   1c358:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   1c35b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c35e:	8b 40 0c             	mov    0xc(%eax),%eax
   1c361:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   1c364:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c367:	8b 40 14             	mov    0x14(%eax),%eax
   1c36a:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1c36d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c370:	01 c0                	add    %eax,%eax
   1c372:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   1c375:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c378:	8b 50 0c             	mov    0xc(%eax),%edx
   1c37b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c37e:	8b 40 10             	mov    0x10(%eax),%eax
   1c381:	0f af c2             	imul   %edx,%eax
   1c384:	01 c0                	add    %eax,%eax
   1c386:	83 ec 0c             	sub    $0xc,%esp
   1c389:	50                   	push   %eax
   1c38a:	e8 2e ad fe ff       	call   70bd <malloc>
   1c38f:	83 c4 10             	add    $0x10,%esp
   1c392:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   1c395:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1c399:	75 0e                	jne    1c3a9 <_UpsampleV+0x54>
   1c39b:	8b 45 08             	mov    0x8(%ebp),%eax
   1c39e:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1c3a4:	e9 6b 03 00 00       	jmp    1c714 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   1c3a9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1c3b0:	e9 1d 03 00 00       	jmp    1c6d2 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   1c3b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c3b8:	8b 50 28             	mov    0x28(%eax),%edx
   1c3bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c3be:	01 d0                	add    %edx,%eax
   1c3c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   1c3c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1c3c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1c3c9:	01 d0                	add    %edx,%eax
   1c3cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   1c3ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c3d1:	0f b6 00             	movzbl (%eax),%eax
   1c3d4:	0f b6 c0             	movzbl %al,%eax
   1c3d7:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1c3dd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1c3e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c3e3:	01 c8                	add    %ecx,%eax
   1c3e5:	0f b6 00             	movzbl (%eax),%eax
   1c3e8:	0f b6 c0             	movzbl %al,%eax
   1c3eb:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1c3ee:	01 d0                	add    %edx,%eax
   1c3f0:	83 ec 0c             	sub    $0xc,%esp
   1c3f3:	50                   	push   %eax
   1c3f4:	e8 1d 03 00 00       	call   1c716 <CF>
   1c3f9:	83 c4 10             	add    $0x10,%esp
   1c3fc:	89 c2                	mov    %eax,%edx
   1c3fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c401:	88 10                	mov    %dl,(%eax)
   1c403:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1c406:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   1c409:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c40c:	0f b6 00             	movzbl (%eax),%eax
   1c40f:	0f b6 c0             	movzbl %al,%eax
   1c412:	6b c8 68             	imul   $0x68,%eax,%ecx
   1c415:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1c418:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c41b:	01 d0                	add    %edx,%eax
   1c41d:	0f b6 00             	movzbl (%eax),%eax
   1c420:	0f b6 d0             	movzbl %al,%edx
   1c423:	89 d0                	mov    %edx,%eax
   1c425:	01 c0                	add    %eax,%eax
   1c427:	01 d0                	add    %edx,%eax
   1c429:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1c430:	01 d0                	add    %edx,%eax
   1c432:	01 c1                	add    %eax,%ecx
   1c434:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1c437:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c43a:	01 d0                	add    %edx,%eax
   1c43c:	0f b6 00             	movzbl (%eax),%eax
   1c43f:	0f b6 d0             	movzbl %al,%edx
   1c442:	89 d0                	mov    %edx,%eax
   1c444:	01 c0                	add    %eax,%eax
   1c446:	01 d0                	add    %edx,%eax
   1c448:	f7 d8                	neg    %eax
   1c44a:	01 c8                	add    %ecx,%eax
   1c44c:	83 ec 0c             	sub    $0xc,%esp
   1c44f:	50                   	push   %eax
   1c450:	e8 c1 02 00 00       	call   1c716 <CF>
   1c455:	83 c4 10             	add    $0x10,%esp
   1c458:	89 c2                	mov    %eax,%edx
   1c45a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c45d:	88 10                	mov    %dl,(%eax)
   1c45f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1c462:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   1c465:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c468:	0f b6 00             	movzbl (%eax),%eax
   1c46b:	0f b6 c0             	movzbl %al,%eax
   1c46e:	c1 e0 02             	shl    $0x2,%eax
   1c471:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1c478:	89 d1                	mov    %edx,%ecx
   1c47a:	29 c1                	sub    %eax,%ecx
   1c47c:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1c47f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c482:	01 d0                	add    %edx,%eax
   1c484:	0f b6 00             	movzbl (%eax),%eax
   1c487:	0f b6 c0             	movzbl %al,%eax
   1c48a:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1c48d:	01 c1                	add    %eax,%ecx
   1c48f:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1c492:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c495:	01 d0                	add    %edx,%eax
   1c497:	0f b6 00             	movzbl (%eax),%eax
   1c49a:	0f b6 d0             	movzbl %al,%edx
   1c49d:	89 d0                	mov    %edx,%eax
   1c49f:	c1 e0 03             	shl    $0x3,%eax
   1c4a2:	01 d0                	add    %edx,%eax
   1c4a4:	f7 d8                	neg    %eax
   1c4a6:	01 c8                	add    %ecx,%eax
   1c4a8:	83 ec 0c             	sub    $0xc,%esp
   1c4ab:	50                   	push   %eax
   1c4ac:	e8 65 02 00 00       	call   1c716 <CF>
   1c4b1:	83 c4 10             	add    $0x10,%esp
   1c4b4:	89 c2                	mov    %eax,%edx
   1c4b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c4b9:	88 10                	mov    %dl,(%eax)
   1c4bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1c4be:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   1c4c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c4c4:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   1c4c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c4ca:	8b 40 10             	mov    0x10(%eax),%eax
   1c4cd:	83 e8 03             	sub    $0x3,%eax
   1c4d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1c4d3:	e9 e6 00 00 00       	jmp    1c5be <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   1c4d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c4db:	f7 d8                	neg    %eax
   1c4dd:	89 c2                	mov    %eax,%edx
   1c4df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c4e2:	01 d0                	add    %edx,%eax
   1c4e4:	0f b6 00             	movzbl (%eax),%eax
   1c4e7:	0f b6 d0             	movzbl %al,%edx
   1c4ea:	89 d0                	mov    %edx,%eax
   1c4ec:	c1 e0 03             	shl    $0x3,%eax
   1c4ef:	01 d0                	add    %edx,%eax
   1c4f1:	f7 d8                	neg    %eax
   1c4f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1c4f6:	0f b6 12             	movzbl (%edx),%edx
   1c4f9:	0f b6 d2             	movzbl %dl,%edx
   1c4fc:	6b d2 6f             	imul   $0x6f,%edx,%edx
   1c4ff:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   1c502:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1c505:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c508:	01 d0                	add    %edx,%eax
   1c50a:	0f b6 00             	movzbl (%eax),%eax
   1c50d:	0f b6 c0             	movzbl %al,%eax
   1c510:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1c513:	01 c1                	add    %eax,%ecx
   1c515:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1c518:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c51b:	01 d0                	add    %edx,%eax
   1c51d:	0f b6 00             	movzbl (%eax),%eax
   1c520:	0f b6 d0             	movzbl %al,%edx
   1c523:	89 d0                	mov    %edx,%eax
   1c525:	01 c0                	add    %eax,%eax
   1c527:	01 d0                	add    %edx,%eax
   1c529:	f7 d8                	neg    %eax
   1c52b:	01 c8                	add    %ecx,%eax
   1c52d:	83 ec 0c             	sub    $0xc,%esp
   1c530:	50                   	push   %eax
   1c531:	e8 e0 01 00 00       	call   1c716 <CF>
   1c536:	83 c4 10             	add    $0x10,%esp
   1c539:	89 c2                	mov    %eax,%edx
   1c53b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c53e:	88 10                	mov    %dl,(%eax)
   1c540:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1c543:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   1c546:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c549:	f7 d8                	neg    %eax
   1c54b:	89 c2                	mov    %eax,%edx
   1c54d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c550:	01 d0                	add    %edx,%eax
   1c552:	0f b6 00             	movzbl (%eax),%eax
   1c555:	0f b6 d0             	movzbl %al,%edx
   1c558:	89 d0                	mov    %edx,%eax
   1c55a:	01 c0                	add    %eax,%eax
   1c55c:	01 d0                	add    %edx,%eax
   1c55e:	f7 d8                	neg    %eax
   1c560:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1c563:	0f b6 12             	movzbl (%edx),%edx
   1c566:	0f b6 d2             	movzbl %dl,%edx
   1c569:	6b d2 1d             	imul   $0x1d,%edx,%edx
   1c56c:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   1c56f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1c572:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c575:	01 d0                	add    %edx,%eax
   1c577:	0f b6 00             	movzbl (%eax),%eax
   1c57a:	0f b6 c0             	movzbl %al,%eax
   1c57d:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1c580:	01 c1                	add    %eax,%ecx
   1c582:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1c585:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c588:	01 d0                	add    %edx,%eax
   1c58a:	0f b6 00             	movzbl (%eax),%eax
   1c58d:	0f b6 d0             	movzbl %al,%edx
   1c590:	89 d0                	mov    %edx,%eax
   1c592:	c1 e0 03             	shl    $0x3,%eax
   1c595:	01 d0                	add    %edx,%eax
   1c597:	f7 d8                	neg    %eax
   1c599:	01 c8                	add    %ecx,%eax
   1c59b:	83 ec 0c             	sub    $0xc,%esp
   1c59e:	50                   	push   %eax
   1c59f:	e8 72 01 00 00       	call   1c716 <CF>
   1c5a4:	83 c4 10             	add    $0x10,%esp
   1c5a7:	89 c2                	mov    %eax,%edx
   1c5a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c5ac:	88 10                	mov    %dl,(%eax)
   1c5ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1c5b1:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   1c5b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c5b7:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   1c5ba:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   1c5be:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1c5c2:	0f 85 10 ff ff ff    	jne    1c4d8 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   1c5c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c5cb:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   1c5ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c5d1:	0f b6 00             	movzbl (%eax),%eax
   1c5d4:	0f b6 c0             	movzbl %al,%eax
   1c5d7:	c1 e0 02             	shl    $0x2,%eax
   1c5da:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1c5e1:	29 c2                	sub    %eax,%edx
   1c5e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c5e6:	f7 d8                	neg    %eax
   1c5e8:	89 c1                	mov    %eax,%ecx
   1c5ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c5ed:	01 c8                	add    %ecx,%eax
   1c5ef:	0f b6 00             	movzbl (%eax),%eax
   1c5f2:	0f b6 c0             	movzbl %al,%eax
   1c5f5:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1c5f8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1c5fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1c5fe:	f7 d8                	neg    %eax
   1c600:	89 c2                	mov    %eax,%edx
   1c602:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c605:	01 d0                	add    %edx,%eax
   1c607:	0f b6 00             	movzbl (%eax),%eax
   1c60a:	0f b6 d0             	movzbl %al,%edx
   1c60d:	89 d0                	mov    %edx,%eax
   1c60f:	c1 e0 03             	shl    $0x3,%eax
   1c612:	01 d0                	add    %edx,%eax
   1c614:	f7 d8                	neg    %eax
   1c616:	01 c8                	add    %ecx,%eax
   1c618:	83 ec 0c             	sub    $0xc,%esp
   1c61b:	50                   	push   %eax
   1c61c:	e8 f5 00 00 00       	call   1c716 <CF>
   1c621:	83 c4 10             	add    $0x10,%esp
   1c624:	89 c2                	mov    %eax,%edx
   1c626:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c629:	88 10                	mov    %dl,(%eax)
   1c62b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1c62e:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   1c631:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c634:	0f b6 00             	movzbl (%eax),%eax
   1c637:	0f b6 c0             	movzbl %al,%eax
   1c63a:	6b c8 68             	imul   $0x68,%eax,%ecx
   1c63d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c640:	f7 d8                	neg    %eax
   1c642:	89 c2                	mov    %eax,%edx
   1c644:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c647:	01 d0                	add    %edx,%eax
   1c649:	0f b6 00             	movzbl (%eax),%eax
   1c64c:	0f b6 d0             	movzbl %al,%edx
   1c64f:	89 d0                	mov    %edx,%eax
   1c651:	01 c0                	add    %eax,%eax
   1c653:	01 d0                	add    %edx,%eax
   1c655:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1c65c:	01 d0                	add    %edx,%eax
   1c65e:	01 c1                	add    %eax,%ecx
   1c660:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1c663:	f7 d8                	neg    %eax
   1c665:	89 c2                	mov    %eax,%edx
   1c667:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c66a:	01 d0                	add    %edx,%eax
   1c66c:	0f b6 00             	movzbl (%eax),%eax
   1c66f:	0f b6 d0             	movzbl %al,%edx
   1c672:	89 d0                	mov    %edx,%eax
   1c674:	01 c0                	add    %eax,%eax
   1c676:	01 d0                	add    %edx,%eax
   1c678:	f7 d8                	neg    %eax
   1c67a:	01 c8                	add    %ecx,%eax
   1c67c:	83 ec 0c             	sub    $0xc,%esp
   1c67f:	50                   	push   %eax
   1c680:	e8 91 00 00 00       	call   1c716 <CF>
   1c685:	83 c4 10             	add    $0x10,%esp
   1c688:	89 c2                	mov    %eax,%edx
   1c68a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c68d:	88 10                	mov    %dl,(%eax)
   1c68f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1c692:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   1c695:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c698:	0f b6 00             	movzbl (%eax),%eax
   1c69b:	0f b6 c0             	movzbl %al,%eax
   1c69e:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1c6a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1c6a7:	f7 d8                	neg    %eax
   1c6a9:	89 c1                	mov    %eax,%ecx
   1c6ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1c6ae:	01 c8                	add    %ecx,%eax
   1c6b0:	0f b6 00             	movzbl (%eax),%eax
   1c6b3:	0f b6 c0             	movzbl %al,%eax
   1c6b6:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1c6b9:	01 d0                	add    %edx,%eax
   1c6bb:	83 ec 0c             	sub    $0xc,%esp
   1c6be:	50                   	push   %eax
   1c6bf:	e8 52 00 00 00       	call   1c716 <CF>
   1c6c4:	83 c4 10             	add    $0x10,%esp
   1c6c7:	89 c2                	mov    %eax,%edx
   1c6c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1c6cc:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   1c6ce:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1c6d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1c6d5:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1c6d8:	0f 8c d7 fc ff ff    	jl     1c3b5 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   1c6de:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c6e1:	8b 40 10             	mov    0x10(%eax),%eax
   1c6e4:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1c6e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c6ea:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   1c6ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c6f0:	8b 50 0c             	mov    0xc(%eax),%edx
   1c6f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c6f6:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   1c6f9:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c6fc:	8b 40 28             	mov    0x28(%eax),%eax
   1c6ff:	83 ec 0c             	sub    $0xc,%esp
   1c702:	50                   	push   %eax
   1c703:	e8 73 a8 fe ff       	call   6f7b <free>
   1c708:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   1c70b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1c70e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1c711:	89 50 28             	mov    %edx,0x28(%eax)
}
   1c714:	c9                   	leave  
   1c715:	c3                   	ret    

0001c716 <CF>:

uchar CF(const int x){
   1c716:	55                   	push   %ebp
   1c717:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   1c719:	8b 45 08             	mov    0x8(%ebp),%eax
   1c71c:	83 c0 40             	add    $0x40,%eax
   1c71f:	c1 f8 07             	sar    $0x7,%eax
   1c722:	50                   	push   %eax
   1c723:	e8 e9 dd ff ff       	call   1a511 <_Clip>
   1c728:	83 c4 04             	add    $0x4,%esp
}
   1c72b:	c9                   	leave  
   1c72c:	c3                   	ret    
