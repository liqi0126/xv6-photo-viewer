
_desktop：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <MsgProc>:
RGB IconBuffer[IconSize * IconSize];
RGB save_icon[148*341];

int flag = 0;
void MsgProc(struct message * msg)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	83 ec 48             	sub    $0x48,%esp
    int pid;
    char * argv[] = {"xxxxxxxxxxxxxxxxxxxxxxx", "0"};
       6:	c7 45 bc b4 61 01 00 	movl   $0x161b4,-0x44(%ebp)
       d:	c7 45 c0 cc 61 01 00 	movl   $0x161cc,-0x40(%ebp)
    int i;

    int x;
    int y;
    int clicked;
    switch (msg->msg_type)
      14:	8b 45 08             	mov    0x8(%ebp),%eax
      17:	8b 00                	mov    (%eax),%eax
      19:	83 f8 02             	cmp    $0x2,%eax
      1c:	74 1c                	je     3a <MsgProc+0x3a>
      1e:	83 f8 02             	cmp    $0x2,%eax
      21:	7f 0a                	jg     2d <MsgProc+0x2d>
      23:	83 f8 01             	cmp    $0x1,%eax
      26:	74 34                	je     5c <MsgProc+0x5c>
                exit();
             }
        }
        break;
    }
}
      28:	e9 fd 01 00 00       	jmp    22a <MsgProc+0x22a>
    int i;

    int x;
    int y;
    int clicked;
    switch (msg->msg_type)
      2d:	83 f8 08             	cmp    $0x8,%eax
      30:	74 4c                	je     7e <MsgProc+0x7e>
      32:	83 f8 09             	cmp    $0x9,%eax
        break;
    case M_KEY_UP:
        printf(1, "USER K UP%d %d\n", msg->params[0], msg->params[1]);
        break;
    case M_TIMER:
        break;
      35:	e9 f0 01 00 00       	jmp    22a <MsgProc+0x22a>
    int y;
    int clicked;
    switch (msg->msg_type)
    {
    case M_KEY_DOWN:
       printf(1, "USER K DOWN%d %d\n", msg->params[0], msg->params[1]);
      3a:	8b 45 08             	mov    0x8(%ebp),%eax
      3d:	8b 50 08             	mov    0x8(%eax),%edx
      40:	8b 45 08             	mov    0x8(%ebp),%eax
      43:	8b 40 04             	mov    0x4(%eax),%eax
      46:	52                   	push   %edx
      47:	50                   	push   %eax
      48:	68 ce 61 01 00       	push   $0x161ce
      4d:	6a 01                	push   $0x1
      4f:	e8 d1 07 00 00       	call   825 <printf>
      54:	83 c4 10             	add    $0x10,%esp
        break;
      57:	e9 ce 01 00 00       	jmp    22a <MsgProc+0x22a>
    case M_KEY_UP:
        printf(1, "USER K UP%d %d\n", msg->params[0], msg->params[1]);
      5c:	8b 45 08             	mov    0x8(%ebp),%eax
      5f:	8b 50 08             	mov    0x8(%eax),%edx
      62:	8b 45 08             	mov    0x8(%ebp),%eax
      65:	8b 40 04             	mov    0x4(%eax),%eax
      68:	52                   	push   %edx
      69:	50                   	push   %eax
      6a:	68 e0 61 01 00       	push   $0x161e0
      6f:	6a 01                	push   $0x1
      71:	e8 af 07 00 00       	call   825 <printf>
      76:	83 c4 10             	add    $0x10,%esp
        break;
      79:	e9 ac 01 00 00       	jmp    22a <MsgProc+0x22a>
    case M_TIMER:
        break;
    case M_MOUSE_DBCLICK:
        x = msg->params[0];
      7e:	8b 45 08             	mov    0x8(%ebp),%eax
      81:	8b 40 04             	mov    0x4(%eax),%eax
      84:	89 45 e8             	mov    %eax,-0x18(%ebp)
        y = msg->params[1];
      87:	8b 45 08             	mov    0x8(%ebp),%eax
      8a:	8b 40 08             	mov    0x8(%eax),%eax
      8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        printf(1, "DES DBC %d %d\n", x, y);
      90:	ff 75 e4             	pushl  -0x1c(%ebp)
      93:	ff 75 e8             	pushl  -0x18(%ebp)
      96:	68 f0 61 01 00       	push   $0x161f0
      9b:	6a 01                	push   $0x1
      9d:	e8 83 07 00 00       	call   825 <printf>
      a2:	83 c4 10             	add    $0x10,%esp
        for(i = 0; i < AppCount; ++i)
      a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      ac:	eb 66                	jmp    114 <MsgProc+0x114>
        {
            int minX, minY, maxX, maxY;
            minX = appPos[i].x;
      ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
      b1:	8b 04 c5 80 84 04 00 	mov    0x48480(,%eax,8),%eax
      b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
            minY = appPos[i].y;
      bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
      be:	8b 04 c5 84 84 04 00 	mov    0x48484(,%eax,8),%eax
      c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
            maxX = appPos[i].x + IconSize;
      c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
      cb:	8b 04 c5 80 84 04 00 	mov    0x48480(,%eax,8),%eax
      d2:	83 c0 50             	add    $0x50,%eax
      d5:	89 45 d8             	mov    %eax,-0x28(%ebp)
            maxY = appPos[i].y + IconSize;
      d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
      db:	8b 04 c5 84 84 04 00 	mov    0x48484(,%eax,8),%eax
      e2:	83 c0 50             	add    $0x50,%eax
      e5:	89 45 d4             	mov    %eax,-0x2c(%ebp)

            if(x > minX && x < maxX && y > minY && y <maxY)
      e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
      eb:	3b 45 e0             	cmp    -0x20(%ebp),%eax
      ee:	7e 20                	jle    110 <MsgProc+0x110>
      f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
      f3:	3b 45 d8             	cmp    -0x28(%ebp),%eax
      f6:	7d 18                	jge    110 <MsgProc+0x110>
      f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      fb:	3b 45 dc             	cmp    -0x24(%ebp),%eax
      fe:	7e 10                	jle    110 <MsgProc+0x110>
     100:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     103:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
     106:	7d 08                	jge    110 <MsgProc+0x110>
            {
                clicked = i;
     108:	8b 45 f4             	mov    -0xc(%ebp),%eax
     10b:	89 45 f0             	mov    %eax,-0x10(%ebp)
                break;
     10e:	eb 0a                	jmp    11a <MsgProc+0x11a>
        break;
    case M_MOUSE_DBCLICK:
        x = msg->params[0];
        y = msg->params[1];
        printf(1, "DES DBC %d %d\n", x, y);
        for(i = 0; i < AppCount; ++i)
     110:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     114:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
     118:	7e 94                	jle    ae <MsgProc+0xae>
                clicked = i;
                break;
            }
        }

        if (clicked < AppCount)
     11a:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
     11e:	0f 8f 05 01 00 00    	jg     229 <MsgProc+0x229>
        {
            if (clicked == 0)
     124:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     128:	75 0d                	jne    137 <MsgProc+0x137>
                flag = flag + 1;
     12a:	a1 c0 e9 01 00       	mov    0x1e9c0,%eax
     12f:	83 c0 01             	add    $0x1,%eax
     132:	a3 c0 e9 01 00       	mov    %eax,0x1e9c0
            pid = fork();
     137:	e8 3a 05 00 00       	call   676 <fork>
     13c:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if(pid == 0){
     13f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
     143:	0f 85 e0 00 00 00    	jne    229 <MsgProc+0x229>
                argv[1][0] = flag + '0';
     149:	8b 45 c0             	mov    -0x40(%ebp),%eax
     14c:	8b 15 c0 e9 01 00    	mov    0x1e9c0,%edx
     152:	83 c2 30             	add    $0x30,%edx
     155:	88 10                	mov    %dl,(%eax)
                strcpy(argv[0],appName[i]);
     157:	8b 45 f4             	mov    -0xc(%ebp),%eax
     15a:	8b 14 85 60 e5 01 00 	mov    0x1e560(,%eax,4),%edx
     161:	8b 45 bc             	mov    -0x44(%ebp),%eax
     164:	83 ec 08             	sub    $0x8,%esp
     167:	52                   	push   %edx
     168:	50                   	push   %eax
     169:	e8 df 02 00 00       	call   44d <strcpy>
     16e:	83 c4 10             	add    $0x10,%esp
                int len = strlen(appName[i]);
     171:	8b 45 f4             	mov    -0xc(%ebp),%eax
     174:	8b 04 85 60 e5 01 00 	mov    0x1e560(,%eax,4),%eax
     17b:	83 ec 0c             	sub    $0xc,%esp
     17e:	50                   	push   %eax
     17f:	e8 38 03 00 00       	call   4bc <strlen>
     184:	83 c4 10             	add    $0x10,%esp
     187:	89 45 cc             	mov    %eax,-0x34(%ebp)
                len = len - 4;
     18a:	83 6d cc 04          	subl   $0x4,-0x34(%ebp)
                char temp[len + 1];
     18e:	8b 45 cc             	mov    -0x34(%ebp),%eax
     191:	83 c0 01             	add    $0x1,%eax
     194:	8d 50 ff             	lea    -0x1(%eax),%edx
     197:	89 55 c8             	mov    %edx,-0x38(%ebp)
     19a:	89 c2                	mov    %eax,%edx
     19c:	b8 10 00 00 00       	mov    $0x10,%eax
     1a1:	83 e8 01             	sub    $0x1,%eax
     1a4:	01 d0                	add    %edx,%eax
     1a6:	b9 10 00 00 00       	mov    $0x10,%ecx
     1ab:	ba 00 00 00 00       	mov    $0x0,%edx
     1b0:	f7 f1                	div    %ecx
     1b2:	6b c0 10             	imul   $0x10,%eax,%eax
     1b5:	29 c4                	sub    %eax,%esp
     1b7:	89 e0                	mov    %esp,%eax
     1b9:	83 c0 00             	add    $0x0,%eax
     1bc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
                int j;
                for (j = 0; j < len; ++j)
     1bf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
     1c6:	eb 20                	jmp    1e8 <MsgProc+0x1e8>
                    temp[j] = appName[i][j];
     1c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1cb:	8b 14 85 60 e5 01 00 	mov    0x1e560(,%eax,4),%edx
     1d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
     1d5:	01 d0                	add    %edx,%eax
     1d7:	0f b6 00             	movzbl (%eax),%eax
     1da:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
     1dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
     1e0:	01 ca                	add    %ecx,%edx
     1e2:	88 02                	mov    %al,(%edx)
                strcpy(argv[0],appName[i]);
                int len = strlen(appName[i]);
                len = len - 4;
                char temp[len + 1];
                int j;
                for (j = 0; j < len; ++j)
     1e4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
     1e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
     1eb:	3b 45 cc             	cmp    -0x34(%ebp),%eax
     1ee:	7c d8                	jl     1c8 <MsgProc+0x1c8>
                    temp[j] = appName[i][j];
                temp[len] = '\0';
     1f0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
     1f3:	8b 45 cc             	mov    -0x34(%ebp),%eax
     1f6:	01 d0                	add    %edx,%eax
     1f8:	c6 00 00             	movb   $0x0,(%eax)

                printf(1, "Test %s\n", temp);
     1fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
     1fe:	83 ec 04             	sub    $0x4,%esp
     201:	50                   	push   %eax
     202:	68 ff 61 01 00       	push   $0x161ff
     207:	6a 01                	push   $0x1
     209:	e8 17 06 00 00       	call   825 <printf>
     20e:	83 c4 10             	add    $0x10,%esp
                exec(temp, argv);
     211:	8b 45 c4             	mov    -0x3c(%ebp),%eax
     214:	83 ec 08             	sub    $0x8,%esp
     217:	8d 55 bc             	lea    -0x44(%ebp),%edx
     21a:	52                   	push   %edx
     21b:	50                   	push   %eax
     21c:	e8 95 04 00 00       	call   6b6 <exec>
     221:	83 c4 10             	add    $0x10,%esp
                exit();
     224:	e8 55 04 00 00       	call   67e <exit>
             }
        }
        break;
     229:	90                   	nop
    }
}
     22a:	90                   	nop
     22b:	c9                   	leave  
     22c:	c3                   	ret    

0000022d <desktopInit>:

void desktopInit()
{
     22d:	55                   	push   %ebp
     22e:	89 e5                	mov    %esp,%ebp
     230:	83 ec 38             	sub    $0x38,%esp
    int i;

    for (i = 0; i < AppCount; ++i)
     233:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     23a:	e9 c7 00 00 00       	jmp    306 <desktopInit+0xd9>
    {
        int h, w;
        read24BitmapFile(appName[i], IconBuffer, &h, &w);
     23f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     242:	8b 04 85 60 e5 01 00 	mov    0x1e560(,%eax,4),%eax
     249:	8d 55 d4             	lea    -0x2c(%ebp),%edx
     24c:	52                   	push   %edx
     24d:	8d 55 d8             	lea    -0x28(%ebp),%edx
     250:	52                   	push   %edx
     251:	68 e0 e9 01 00       	push   $0x1e9e0
     256:	50                   	push   %eax
     257:	e8 ab 0f 00 00       	call   1207 <read24BitmapFile>
     25c:	83 c4 10             	add    $0x10,%esp
        printf(1, "Icon %d, %d", h, w);
     25f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
     262:	8b 45 d8             	mov    -0x28(%ebp),%eax
     265:	52                   	push   %edx
     266:	50                   	push   %eax
     267:	68 08 62 01 00       	push   $0x16208
     26c:	6a 01                	push   $0x1
     26e:	e8 b2 05 00 00       	call   825 <printf>
     273:	83 c4 10             	add    $0x10,%esp
        appPos[i].x = 50;
     276:	8b 45 f4             	mov    -0xc(%ebp),%eax
     279:	c7 04 c5 80 84 04 00 	movl   $0x32,0x48480(,%eax,8)
     280:	32 00 00 00 
        appPos[i].y = 20 + 120 * i;
     284:	8b 45 f4             	mov    -0xc(%ebp),%eax
     287:	c1 e0 03             	shl    $0x3,%eax
     28a:	89 c2                	mov    %eax,%edx
     28c:	c1 e2 04             	shl    $0x4,%edx
     28f:	29 c2                	sub    %eax,%edx
     291:	89 d0                	mov    %edx,%eax
     293:	8d 50 14             	lea    0x14(%eax),%edx
     296:	8b 45 f4             	mov    -0xc(%ebp),%eax
     299:	89 14 c5 84 84 04 00 	mov    %edx,0x48484(,%eax,8)
        api_paint24BitmapToContent(&wnd, IconBuffer, appPos[i], (Point){0, 0},(Size){80,80}, (Size){80,80});
     2a0:	c7 45 dc 50 00 00 00 	movl   $0x50,-0x24(%ebp)
     2a7:	c7 45 e0 50 00 00 00 	movl   $0x50,-0x20(%ebp)
     2ae:	c7 45 e4 50 00 00 00 	movl   $0x50,-0x1c(%ebp)
     2b5:	c7 45 e8 50 00 00 00 	movl   $0x50,-0x18(%ebp)
     2bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
     2c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     2ca:	83 ec 08             	sub    $0x8,%esp
     2cd:	ff 75 e0             	pushl  -0x20(%ebp)
     2d0:	ff 75 dc             	pushl  -0x24(%ebp)
     2d3:	ff 75 e8             	pushl  -0x18(%ebp)
     2d6:	ff 75 e4             	pushl  -0x1c(%ebp)
     2d9:	ff 75 f0             	pushl  -0x10(%ebp)
     2dc:	ff 75 ec             	pushl  -0x14(%ebp)
     2df:	8b 45 f4             	mov    -0xc(%ebp),%eax
     2e2:	ff 34 c5 84 84 04 00 	pushl  0x48484(,%eax,8)
     2e9:	ff 34 c5 80 84 04 00 	pushl  0x48480(,%eax,8)
     2f0:	68 e0 e9 01 00       	push   $0x1e9e0
     2f5:	68 60 84 04 00       	push   $0x48460
     2fa:	e8 45 13 00 00       	call   1644 <api_paint24BitmapToContent>
     2ff:	83 c4 30             	add    $0x30,%esp

void desktopInit()
{
    int i;

    for (i = 0; i < AppCount; ++i)
     302:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     306:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
     30a:	0f 8e 2f ff ff ff    	jle    23f <desktopInit+0x12>
        appPos[i].x = 50;
        appPos[i].y = 20 + 120 * i;
        api_paint24BitmapToContent(&wnd, IconBuffer, appPos[i], (Point){0, 0},(Size){80,80}, (Size){80,80});
       // api_paint24Bitmap(&wnd, IconBuffer, appPos[i],(Size){55,40});
    }
}
     310:	90                   	nop
     311:	c9                   	leave  
     312:	c3                   	ret    

00000313 <main>:

int
main(void) {
     313:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     317:	83 e4 f0             	and    $0xfffffff0,%esp
     31a:	ff 71 fc             	pushl  -0x4(%ecx)
     31d:	55                   	push   %ebp
     31e:	89 e5                	mov    %esp,%ebp
     320:	51                   	push   %ecx
     321:	83 ec 34             	sub    $0x34,%esp
    wnd.pos.x = 0;
     324:	c7 05 64 84 04 00 00 	movl   $0x0,0x48464
     32b:	00 00 00 
    wnd.pos.y = 0;
     32e:	c7 05 68 84 04 00 00 	movl   $0x0,0x48468
     335:	00 00 00 
    wnd.size.w = USCREEN_WIDTH;
     338:	c7 05 70 84 04 00 20 	movl   $0x320,0x48470
     33f:	03 00 00 
    wnd.size.h = USCREEN_HEIGHT;
     342:	c7 05 6c 84 04 00 58 	movl   $0x258,0x4846c
     349:	02 00 00 
    wnd.title = "desktop";
     34c:	c7 05 74 84 04 00 14 	movl   $0x16214,0x48474
     353:	62 01 00 

    RGB * background = malloc(800 * 600 * 3);
     356:	83 ec 0c             	sub    $0xc,%esp
     359:	68 00 f9 15 00       	push   $0x15f900
     35e:	e8 95 07 00 00       	call   af8 <malloc>
     363:	83 c4 10             	add    $0x10,%esp
     366:	89 45 f4             	mov    %eax,-0xc(%ebp)
    api_createwindow(&wnd);
     369:	83 ec 0c             	sub    $0xc,%esp
     36c:	68 60 84 04 00       	push   $0x48460
     371:	e8 bc 11 00 00       	call   1532 <api_createwindow>
     376:	83 c4 10             	add    $0x10,%esp

    char filename[] = "desktop.bmp";
     379:	c7 45 d8 64 65 73 6b 	movl   $0x6b736564,-0x28(%ebp)
     380:	c7 45 dc 74 6f 70 2e 	movl   $0x2e706f74,-0x24(%ebp)
     387:	c7 45 e0 62 6d 70 00 	movl   $0x706d62,-0x20(%ebp)
    int h, w;
    read24BitmapFile(filename, background, &h, &w);
     38e:	8d 45 d0             	lea    -0x30(%ebp),%eax
     391:	50                   	push   %eax
     392:	8d 45 d4             	lea    -0x2c(%ebp),%eax
     395:	50                   	push   %eax
     396:	ff 75 f4             	pushl  -0xc(%ebp)
     399:	8d 45 d8             	lea    -0x28(%ebp),%eax
     39c:	50                   	push   %eax
     39d:	e8 65 0e 00 00       	call   1207 <read24BitmapFile>
     3a2:	83 c4 10             	add    $0x10,%esp

    api_paint24Bitmap(&wnd, background,(Point){0,0}, (Size){h, w});
     3a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     3a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     3ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
     3ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
     3b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
     3b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     3bf:	83 ec 08             	sub    $0x8,%esp
     3c2:	ff 75 e8             	pushl  -0x18(%ebp)
     3c5:	ff 75 e4             	pushl  -0x1c(%ebp)
     3c8:	ff 75 f0             	pushl  -0x10(%ebp)
     3cb:	ff 75 ec             	pushl  -0x14(%ebp)
     3ce:	ff 75 f4             	pushl  -0xc(%ebp)
     3d1:	68 60 84 04 00       	push   $0x48460
     3d6:	e8 1b 12 00 00       	call   15f6 <api_paint24Bitmap>
     3db:	83 c4 20             	add    $0x20,%esp
    desktopInit();
     3de:	e8 4a fe ff ff       	call   22d <desktopInit>
    api_repaint(&wnd);
     3e3:	83 ec 0c             	sub    $0xc,%esp
     3e6:	68 60 84 04 00       	push   $0x48460
     3eb:	e8 d4 12 00 00       	call   16c4 <api_repaint>
     3f0:	83 c4 10             	add    $0x10,%esp
    printf(1, "safe here\n");
     3f3:	83 ec 08             	sub    $0x8,%esp
     3f6:	68 1c 62 01 00       	push   $0x1621c
     3fb:	6a 01                	push   $0x1
     3fd:	e8 23 04 00 00       	call   825 <printf>
     402:	83 c4 10             	add    $0x10,%esp
    api_exec(&wnd, &MsgProc);
     405:	83 ec 08             	sub    $0x8,%esp
     408:	68 00 00 00 00       	push   $0x0
     40d:	68 60 84 04 00       	push   $0x48460
     412:	e8 fd 12 00 00       	call   1714 <api_exec>
     417:	83 c4 10             	add    $0x10,%esp
    return 0;
     41a:	b8 00 00 00 00       	mov    $0x0,%eax
}
     41f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
     422:	c9                   	leave  
     423:	8d 61 fc             	lea    -0x4(%ecx),%esp
     426:	c3                   	ret    

00000427 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     427:	55                   	push   %ebp
     428:	89 e5                	mov    %esp,%ebp
     42a:	57                   	push   %edi
     42b:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     42c:	8b 4d 08             	mov    0x8(%ebp),%ecx
     42f:	8b 55 10             	mov    0x10(%ebp),%edx
     432:	8b 45 0c             	mov    0xc(%ebp),%eax
     435:	89 cb                	mov    %ecx,%ebx
     437:	89 df                	mov    %ebx,%edi
     439:	89 d1                	mov    %edx,%ecx
     43b:	fc                   	cld    
     43c:	f3 aa                	rep stos %al,%es:(%edi)
     43e:	89 ca                	mov    %ecx,%edx
     440:	89 fb                	mov    %edi,%ebx
     442:	89 5d 08             	mov    %ebx,0x8(%ebp)
     445:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     448:	90                   	nop
     449:	5b                   	pop    %ebx
     44a:	5f                   	pop    %edi
     44b:	5d                   	pop    %ebp
     44c:	c3                   	ret    

0000044d <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     44d:	55                   	push   %ebp
     44e:	89 e5                	mov    %esp,%ebp
     450:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     453:	8b 45 08             	mov    0x8(%ebp),%eax
     456:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     459:	90                   	nop
     45a:	8b 45 08             	mov    0x8(%ebp),%eax
     45d:	8d 50 01             	lea    0x1(%eax),%edx
     460:	89 55 08             	mov    %edx,0x8(%ebp)
     463:	8b 55 0c             	mov    0xc(%ebp),%edx
     466:	8d 4a 01             	lea    0x1(%edx),%ecx
     469:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     46c:	0f b6 12             	movzbl (%edx),%edx
     46f:	88 10                	mov    %dl,(%eax)
     471:	0f b6 00             	movzbl (%eax),%eax
     474:	84 c0                	test   %al,%al
     476:	75 e2                	jne    45a <strcpy+0xd>
    ;
  return os;
     478:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     47b:	c9                   	leave  
     47c:	c3                   	ret    

0000047d <strcmp>:

int
strcmp(const char *p, const char *q)
{
     47d:	55                   	push   %ebp
     47e:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     480:	eb 08                	jmp    48a <strcmp+0xd>
    p++, q++;
     482:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     486:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     48a:	8b 45 08             	mov    0x8(%ebp),%eax
     48d:	0f b6 00             	movzbl (%eax),%eax
     490:	84 c0                	test   %al,%al
     492:	74 10                	je     4a4 <strcmp+0x27>
     494:	8b 45 08             	mov    0x8(%ebp),%eax
     497:	0f b6 10             	movzbl (%eax),%edx
     49a:	8b 45 0c             	mov    0xc(%ebp),%eax
     49d:	0f b6 00             	movzbl (%eax),%eax
     4a0:	38 c2                	cmp    %al,%dl
     4a2:	74 de                	je     482 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     4a4:	8b 45 08             	mov    0x8(%ebp),%eax
     4a7:	0f b6 00             	movzbl (%eax),%eax
     4aa:	0f b6 d0             	movzbl %al,%edx
     4ad:	8b 45 0c             	mov    0xc(%ebp),%eax
     4b0:	0f b6 00             	movzbl (%eax),%eax
     4b3:	0f b6 c0             	movzbl %al,%eax
     4b6:	29 c2                	sub    %eax,%edx
     4b8:	89 d0                	mov    %edx,%eax
}
     4ba:	5d                   	pop    %ebp
     4bb:	c3                   	ret    

000004bc <strlen>:

uint
strlen(char *s)
{
     4bc:	55                   	push   %ebp
     4bd:	89 e5                	mov    %esp,%ebp
     4bf:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     4c2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     4c9:	eb 04                	jmp    4cf <strlen+0x13>
     4cb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     4cf:	8b 55 fc             	mov    -0x4(%ebp),%edx
     4d2:	8b 45 08             	mov    0x8(%ebp),%eax
     4d5:	01 d0                	add    %edx,%eax
     4d7:	0f b6 00             	movzbl (%eax),%eax
     4da:	84 c0                	test   %al,%al
     4dc:	75 ed                	jne    4cb <strlen+0xf>
    ;
  return n;
     4de:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     4e1:	c9                   	leave  
     4e2:	c3                   	ret    

000004e3 <memset>:

void*
memset(void *dst, int c, uint n)
{
     4e3:	55                   	push   %ebp
     4e4:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     4e6:	8b 45 10             	mov    0x10(%ebp),%eax
     4e9:	50                   	push   %eax
     4ea:	ff 75 0c             	pushl  0xc(%ebp)
     4ed:	ff 75 08             	pushl  0x8(%ebp)
     4f0:	e8 32 ff ff ff       	call   427 <stosb>
     4f5:	83 c4 0c             	add    $0xc,%esp
  return dst;
     4f8:	8b 45 08             	mov    0x8(%ebp),%eax
}
     4fb:	c9                   	leave  
     4fc:	c3                   	ret    

000004fd <strchr>:

char*
strchr(const char *s, char c)
{
     4fd:	55                   	push   %ebp
     4fe:	89 e5                	mov    %esp,%ebp
     500:	83 ec 04             	sub    $0x4,%esp
     503:	8b 45 0c             	mov    0xc(%ebp),%eax
     506:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     509:	eb 14                	jmp    51f <strchr+0x22>
    if(*s == c)
     50b:	8b 45 08             	mov    0x8(%ebp),%eax
     50e:	0f b6 00             	movzbl (%eax),%eax
     511:	3a 45 fc             	cmp    -0x4(%ebp),%al
     514:	75 05                	jne    51b <strchr+0x1e>
      return (char*)s;
     516:	8b 45 08             	mov    0x8(%ebp),%eax
     519:	eb 13                	jmp    52e <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     51b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     51f:	8b 45 08             	mov    0x8(%ebp),%eax
     522:	0f b6 00             	movzbl (%eax),%eax
     525:	84 c0                	test   %al,%al
     527:	75 e2                	jne    50b <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     529:	b8 00 00 00 00       	mov    $0x0,%eax
}
     52e:	c9                   	leave  
     52f:	c3                   	ret    

00000530 <gets>:

char*
gets(char *buf, int max)
{
     530:	55                   	push   %ebp
     531:	89 e5                	mov    %esp,%ebp
     533:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     536:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     53d:	eb 42                	jmp    581 <gets+0x51>
    cc = read(0, &c, 1);
     53f:	83 ec 04             	sub    $0x4,%esp
     542:	6a 01                	push   $0x1
     544:	8d 45 ef             	lea    -0x11(%ebp),%eax
     547:	50                   	push   %eax
     548:	6a 00                	push   $0x0
     54a:	e8 47 01 00 00       	call   696 <read>
     54f:	83 c4 10             	add    $0x10,%esp
     552:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     555:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     559:	7e 33                	jle    58e <gets+0x5e>
      break;
    buf[i++] = c;
     55b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     55e:	8d 50 01             	lea    0x1(%eax),%edx
     561:	89 55 f4             	mov    %edx,-0xc(%ebp)
     564:	89 c2                	mov    %eax,%edx
     566:	8b 45 08             	mov    0x8(%ebp),%eax
     569:	01 c2                	add    %eax,%edx
     56b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     56f:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     571:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     575:	3c 0a                	cmp    $0xa,%al
     577:	74 16                	je     58f <gets+0x5f>
     579:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     57d:	3c 0d                	cmp    $0xd,%al
     57f:	74 0e                	je     58f <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     581:	8b 45 f4             	mov    -0xc(%ebp),%eax
     584:	83 c0 01             	add    $0x1,%eax
     587:	3b 45 0c             	cmp    0xc(%ebp),%eax
     58a:	7c b3                	jl     53f <gets+0xf>
     58c:	eb 01                	jmp    58f <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     58e:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     58f:	8b 55 f4             	mov    -0xc(%ebp),%edx
     592:	8b 45 08             	mov    0x8(%ebp),%eax
     595:	01 d0                	add    %edx,%eax
     597:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     59a:	8b 45 08             	mov    0x8(%ebp),%eax
}
     59d:	c9                   	leave  
     59e:	c3                   	ret    

0000059f <stat>:

int
stat(char *n, struct stat *st)
{
     59f:	55                   	push   %ebp
     5a0:	89 e5                	mov    %esp,%ebp
     5a2:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     5a5:	83 ec 08             	sub    $0x8,%esp
     5a8:	6a 00                	push   $0x0
     5aa:	ff 75 08             	pushl  0x8(%ebp)
     5ad:	e8 0c 01 00 00       	call   6be <open>
     5b2:	83 c4 10             	add    $0x10,%esp
     5b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     5b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     5bc:	79 07                	jns    5c5 <stat+0x26>
    return -1;
     5be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     5c3:	eb 25                	jmp    5ea <stat+0x4b>
  r = fstat(fd, st);
     5c5:	83 ec 08             	sub    $0x8,%esp
     5c8:	ff 75 0c             	pushl  0xc(%ebp)
     5cb:	ff 75 f4             	pushl  -0xc(%ebp)
     5ce:	e8 03 01 00 00       	call   6d6 <fstat>
     5d3:	83 c4 10             	add    $0x10,%esp
     5d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     5d9:	83 ec 0c             	sub    $0xc,%esp
     5dc:	ff 75 f4             	pushl  -0xc(%ebp)
     5df:	e8 c2 00 00 00       	call   6a6 <close>
     5e4:	83 c4 10             	add    $0x10,%esp
  return r;
     5e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     5ea:	c9                   	leave  
     5eb:	c3                   	ret    

000005ec <atoi>:

int
atoi(const char *s)
{
     5ec:	55                   	push   %ebp
     5ed:	89 e5                	mov    %esp,%ebp
     5ef:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     5f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     5f9:	eb 25                	jmp    620 <atoi+0x34>
    n = n*10 + *s++ - '0';
     5fb:	8b 55 fc             	mov    -0x4(%ebp),%edx
     5fe:	89 d0                	mov    %edx,%eax
     600:	c1 e0 02             	shl    $0x2,%eax
     603:	01 d0                	add    %edx,%eax
     605:	01 c0                	add    %eax,%eax
     607:	89 c1                	mov    %eax,%ecx
     609:	8b 45 08             	mov    0x8(%ebp),%eax
     60c:	8d 50 01             	lea    0x1(%eax),%edx
     60f:	89 55 08             	mov    %edx,0x8(%ebp)
     612:	0f b6 00             	movzbl (%eax),%eax
     615:	0f be c0             	movsbl %al,%eax
     618:	01 c8                	add    %ecx,%eax
     61a:	83 e8 30             	sub    $0x30,%eax
     61d:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     620:	8b 45 08             	mov    0x8(%ebp),%eax
     623:	0f b6 00             	movzbl (%eax),%eax
     626:	3c 2f                	cmp    $0x2f,%al
     628:	7e 0a                	jle    634 <atoi+0x48>
     62a:	8b 45 08             	mov    0x8(%ebp),%eax
     62d:	0f b6 00             	movzbl (%eax),%eax
     630:	3c 39                	cmp    $0x39,%al
     632:	7e c7                	jle    5fb <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     634:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     637:	c9                   	leave  
     638:	c3                   	ret    

00000639 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     639:	55                   	push   %ebp
     63a:	89 e5                	mov    %esp,%ebp
     63c:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     63f:	8b 45 08             	mov    0x8(%ebp),%eax
     642:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     645:	8b 45 0c             	mov    0xc(%ebp),%eax
     648:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     64b:	eb 17                	jmp    664 <memmove+0x2b>
    *dst++ = *src++;
     64d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     650:	8d 50 01             	lea    0x1(%eax),%edx
     653:	89 55 fc             	mov    %edx,-0x4(%ebp)
     656:	8b 55 f8             	mov    -0x8(%ebp),%edx
     659:	8d 4a 01             	lea    0x1(%edx),%ecx
     65c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     65f:	0f b6 12             	movzbl (%edx),%edx
     662:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     664:	8b 45 10             	mov    0x10(%ebp),%eax
     667:	8d 50 ff             	lea    -0x1(%eax),%edx
     66a:	89 55 10             	mov    %edx,0x10(%ebp)
     66d:	85 c0                	test   %eax,%eax
     66f:	7f dc                	jg     64d <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     671:	8b 45 08             	mov    0x8(%ebp),%eax
}
     674:	c9                   	leave  
     675:	c3                   	ret    

00000676 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     676:	b8 01 00 00 00       	mov    $0x1,%eax
     67b:	cd 40                	int    $0x40
     67d:	c3                   	ret    

0000067e <exit>:
SYSCALL(exit)
     67e:	b8 02 00 00 00       	mov    $0x2,%eax
     683:	cd 40                	int    $0x40
     685:	c3                   	ret    

00000686 <wait>:
SYSCALL(wait)
     686:	b8 03 00 00 00       	mov    $0x3,%eax
     68b:	cd 40                	int    $0x40
     68d:	c3                   	ret    

0000068e <pipe>:
SYSCALL(pipe)
     68e:	b8 04 00 00 00       	mov    $0x4,%eax
     693:	cd 40                	int    $0x40
     695:	c3                   	ret    

00000696 <read>:
SYSCALL(read)
     696:	b8 05 00 00 00       	mov    $0x5,%eax
     69b:	cd 40                	int    $0x40
     69d:	c3                   	ret    

0000069e <write>:
SYSCALL(write)
     69e:	b8 10 00 00 00       	mov    $0x10,%eax
     6a3:	cd 40                	int    $0x40
     6a5:	c3                   	ret    

000006a6 <close>:
SYSCALL(close)
     6a6:	b8 15 00 00 00       	mov    $0x15,%eax
     6ab:	cd 40                	int    $0x40
     6ad:	c3                   	ret    

000006ae <kill>:
SYSCALL(kill)
     6ae:	b8 06 00 00 00       	mov    $0x6,%eax
     6b3:	cd 40                	int    $0x40
     6b5:	c3                   	ret    

000006b6 <exec>:
SYSCALL(exec)
     6b6:	b8 07 00 00 00       	mov    $0x7,%eax
     6bb:	cd 40                	int    $0x40
     6bd:	c3                   	ret    

000006be <open>:
SYSCALL(open)
     6be:	b8 0f 00 00 00       	mov    $0xf,%eax
     6c3:	cd 40                	int    $0x40
     6c5:	c3                   	ret    

000006c6 <mknod>:
SYSCALL(mknod)
     6c6:	b8 11 00 00 00       	mov    $0x11,%eax
     6cb:	cd 40                	int    $0x40
     6cd:	c3                   	ret    

000006ce <unlink>:
SYSCALL(unlink)
     6ce:	b8 12 00 00 00       	mov    $0x12,%eax
     6d3:	cd 40                	int    $0x40
     6d5:	c3                   	ret    

000006d6 <fstat>:
SYSCALL(fstat)
     6d6:	b8 08 00 00 00       	mov    $0x8,%eax
     6db:	cd 40                	int    $0x40
     6dd:	c3                   	ret    

000006de <link>:
SYSCALL(link)
     6de:	b8 13 00 00 00       	mov    $0x13,%eax
     6e3:	cd 40                	int    $0x40
     6e5:	c3                   	ret    

000006e6 <mkdir>:
SYSCALL(mkdir)
     6e6:	b8 14 00 00 00       	mov    $0x14,%eax
     6eb:	cd 40                	int    $0x40
     6ed:	c3                   	ret    

000006ee <chdir>:
SYSCALL(chdir)
     6ee:	b8 09 00 00 00       	mov    $0x9,%eax
     6f3:	cd 40                	int    $0x40
     6f5:	c3                   	ret    

000006f6 <dup>:
SYSCALL(dup)
     6f6:	b8 0a 00 00 00       	mov    $0xa,%eax
     6fb:	cd 40                	int    $0x40
     6fd:	c3                   	ret    

000006fe <getpid>:
SYSCALL(getpid)
     6fe:	b8 0b 00 00 00       	mov    $0xb,%eax
     703:	cd 40                	int    $0x40
     705:	c3                   	ret    

00000706 <sbrk>:
SYSCALL(sbrk)
     706:	b8 0c 00 00 00       	mov    $0xc,%eax
     70b:	cd 40                	int    $0x40
     70d:	c3                   	ret    

0000070e <sleep>:
SYSCALL(sleep)
     70e:	b8 0d 00 00 00       	mov    $0xd,%eax
     713:	cd 40                	int    $0x40
     715:	c3                   	ret    

00000716 <uptime>:
SYSCALL(uptime)
     716:	b8 0e 00 00 00       	mov    $0xe,%eax
     71b:	cd 40                	int    $0x40
     71d:	c3                   	ret    

0000071e <createwindow>:
SYSCALL(createwindow)
     71e:	b8 16 00 00 00       	mov    $0x16,%eax
     723:	cd 40                	int    $0x40
     725:	c3                   	ret    

00000726 <repaintwindow>:
SYSCALL(repaintwindow)
     726:	b8 17 00 00 00       	mov    $0x17,%eax
     72b:	cd 40                	int    $0x40
     72d:	c3                   	ret    

0000072e <getmessage>:
SYSCALL(getmessage)
     72e:	b8 18 00 00 00       	mov    $0x18,%eax
     733:	cd 40                	int    $0x40
     735:	c3                   	ret    

00000736 <settimer>:
SYSCALL(settimer)
     736:	b8 19 00 00 00       	mov    $0x19,%eax
     73b:	cd 40                	int    $0x40
     73d:	c3                   	ret    

0000073e <updatewindow>:
SYSCALL(updatewindow)
     73e:	b8 1a 00 00 00       	mov    $0x1a,%eax
     743:	cd 40                	int    $0x40
     745:	c3                   	ret    

00000746 <destroywindow>:
SYSCALL(destroywindow)
     746:	b8 1b 00 00 00       	mov    $0x1b,%eax
     74b:	cd 40                	int    $0x40
     74d:	c3                   	ret    

0000074e <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     74e:	55                   	push   %ebp
     74f:	89 e5                	mov    %esp,%ebp
     751:	83 ec 18             	sub    $0x18,%esp
     754:	8b 45 0c             	mov    0xc(%ebp),%eax
     757:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     75a:	83 ec 04             	sub    $0x4,%esp
     75d:	6a 01                	push   $0x1
     75f:	8d 45 f4             	lea    -0xc(%ebp),%eax
     762:	50                   	push   %eax
     763:	ff 75 08             	pushl  0x8(%ebp)
     766:	e8 33 ff ff ff       	call   69e <write>
     76b:	83 c4 10             	add    $0x10,%esp
}
     76e:	90                   	nop
     76f:	c9                   	leave  
     770:	c3                   	ret    

00000771 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     771:	55                   	push   %ebp
     772:	89 e5                	mov    %esp,%ebp
     774:	53                   	push   %ebx
     775:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     778:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     77f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     783:	74 17                	je     79c <printint+0x2b>
     785:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     789:	79 11                	jns    79c <printint+0x2b>
    neg = 1;
     78b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     792:	8b 45 0c             	mov    0xc(%ebp),%eax
     795:	f7 d8                	neg    %eax
     797:	89 45 ec             	mov    %eax,-0x14(%ebp)
     79a:	eb 06                	jmp    7a2 <printint+0x31>
  } else {
    x = xx;
     79c:	8b 45 0c             	mov    0xc(%ebp),%eax
     79f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     7a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     7a9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     7ac:	8d 41 01             	lea    0x1(%ecx),%eax
     7af:	89 45 f4             	mov    %eax,-0xc(%ebp)
     7b2:	8b 5d 10             	mov    0x10(%ebp),%ebx
     7b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
     7b8:	ba 00 00 00 00       	mov    $0x0,%edx
     7bd:	f7 f3                	div    %ebx
     7bf:	89 d0                	mov    %edx,%eax
     7c1:	0f b6 80 80 e5 01 00 	movzbl 0x1e580(%eax),%eax
     7c8:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     7cc:	8b 5d 10             	mov    0x10(%ebp),%ebx
     7cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
     7d2:	ba 00 00 00 00       	mov    $0x0,%edx
     7d7:	f7 f3                	div    %ebx
     7d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
     7dc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     7e0:	75 c7                	jne    7a9 <printint+0x38>
  if(neg)
     7e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     7e6:	74 2d                	je     815 <printint+0xa4>
    buf[i++] = '-';
     7e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7eb:	8d 50 01             	lea    0x1(%eax),%edx
     7ee:	89 55 f4             	mov    %edx,-0xc(%ebp)
     7f1:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     7f6:	eb 1d                	jmp    815 <printint+0xa4>
    putc(fd, buf[i]);
     7f8:	8d 55 dc             	lea    -0x24(%ebp),%edx
     7fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7fe:	01 d0                	add    %edx,%eax
     800:	0f b6 00             	movzbl (%eax),%eax
     803:	0f be c0             	movsbl %al,%eax
     806:	83 ec 08             	sub    $0x8,%esp
     809:	50                   	push   %eax
     80a:	ff 75 08             	pushl  0x8(%ebp)
     80d:	e8 3c ff ff ff       	call   74e <putc>
     812:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     815:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     819:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     81d:	79 d9                	jns    7f8 <printint+0x87>
    putc(fd, buf[i]);
}
     81f:	90                   	nop
     820:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     823:	c9                   	leave  
     824:	c3                   	ret    

00000825 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     825:	55                   	push   %ebp
     826:	89 e5                	mov    %esp,%ebp
     828:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     82b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     832:	8d 45 0c             	lea    0xc(%ebp),%eax
     835:	83 c0 04             	add    $0x4,%eax
     838:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     83b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     842:	e9 59 01 00 00       	jmp    9a0 <printf+0x17b>
    c = fmt[i] & 0xff;
     847:	8b 55 0c             	mov    0xc(%ebp),%edx
     84a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     84d:	01 d0                	add    %edx,%eax
     84f:	0f b6 00             	movzbl (%eax),%eax
     852:	0f be c0             	movsbl %al,%eax
     855:	25 ff 00 00 00       	and    $0xff,%eax
     85a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     85d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     861:	75 2c                	jne    88f <printf+0x6a>
      if(c == '%'){
     863:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     867:	75 0c                	jne    875 <printf+0x50>
        state = '%';
     869:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     870:	e9 27 01 00 00       	jmp    99c <printf+0x177>
      } else {
        putc(fd, c);
     875:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     878:	0f be c0             	movsbl %al,%eax
     87b:	83 ec 08             	sub    $0x8,%esp
     87e:	50                   	push   %eax
     87f:	ff 75 08             	pushl  0x8(%ebp)
     882:	e8 c7 fe ff ff       	call   74e <putc>
     887:	83 c4 10             	add    $0x10,%esp
     88a:	e9 0d 01 00 00       	jmp    99c <printf+0x177>
      }
    } else if(state == '%'){
     88f:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     893:	0f 85 03 01 00 00    	jne    99c <printf+0x177>
      if(c == 'd'){
     899:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     89d:	75 1e                	jne    8bd <printf+0x98>
        printint(fd, *ap, 10, 1);
     89f:	8b 45 e8             	mov    -0x18(%ebp),%eax
     8a2:	8b 00                	mov    (%eax),%eax
     8a4:	6a 01                	push   $0x1
     8a6:	6a 0a                	push   $0xa
     8a8:	50                   	push   %eax
     8a9:	ff 75 08             	pushl  0x8(%ebp)
     8ac:	e8 c0 fe ff ff       	call   771 <printint>
     8b1:	83 c4 10             	add    $0x10,%esp
        ap++;
     8b4:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     8b8:	e9 d8 00 00 00       	jmp    995 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     8bd:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     8c1:	74 06                	je     8c9 <printf+0xa4>
     8c3:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     8c7:	75 1e                	jne    8e7 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     8c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
     8cc:	8b 00                	mov    (%eax),%eax
     8ce:	6a 00                	push   $0x0
     8d0:	6a 10                	push   $0x10
     8d2:	50                   	push   %eax
     8d3:	ff 75 08             	pushl  0x8(%ebp)
     8d6:	e8 96 fe ff ff       	call   771 <printint>
     8db:	83 c4 10             	add    $0x10,%esp
        ap++;
     8de:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     8e2:	e9 ae 00 00 00       	jmp    995 <printf+0x170>
      } else if(c == 's'){
     8e7:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     8eb:	75 43                	jne    930 <printf+0x10b>
        s = (char*)*ap;
     8ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
     8f0:	8b 00                	mov    (%eax),%eax
     8f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     8f5:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     8f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     8fd:	75 25                	jne    924 <printf+0xff>
          s = "(null)";
     8ff:	c7 45 f4 27 62 01 00 	movl   $0x16227,-0xc(%ebp)
        while(*s != 0){
     906:	eb 1c                	jmp    924 <printf+0xff>
          putc(fd, *s);
     908:	8b 45 f4             	mov    -0xc(%ebp),%eax
     90b:	0f b6 00             	movzbl (%eax),%eax
     90e:	0f be c0             	movsbl %al,%eax
     911:	83 ec 08             	sub    $0x8,%esp
     914:	50                   	push   %eax
     915:	ff 75 08             	pushl  0x8(%ebp)
     918:	e8 31 fe ff ff       	call   74e <putc>
     91d:	83 c4 10             	add    $0x10,%esp
          s++;
     920:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     924:	8b 45 f4             	mov    -0xc(%ebp),%eax
     927:	0f b6 00             	movzbl (%eax),%eax
     92a:	84 c0                	test   %al,%al
     92c:	75 da                	jne    908 <printf+0xe3>
     92e:	eb 65                	jmp    995 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     930:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     934:	75 1d                	jne    953 <printf+0x12e>
        putc(fd, *ap);
     936:	8b 45 e8             	mov    -0x18(%ebp),%eax
     939:	8b 00                	mov    (%eax),%eax
     93b:	0f be c0             	movsbl %al,%eax
     93e:	83 ec 08             	sub    $0x8,%esp
     941:	50                   	push   %eax
     942:	ff 75 08             	pushl  0x8(%ebp)
     945:	e8 04 fe ff ff       	call   74e <putc>
     94a:	83 c4 10             	add    $0x10,%esp
        ap++;
     94d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     951:	eb 42                	jmp    995 <printf+0x170>
      } else if(c == '%'){
     953:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     957:	75 17                	jne    970 <printf+0x14b>
        putc(fd, c);
     959:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     95c:	0f be c0             	movsbl %al,%eax
     95f:	83 ec 08             	sub    $0x8,%esp
     962:	50                   	push   %eax
     963:	ff 75 08             	pushl  0x8(%ebp)
     966:	e8 e3 fd ff ff       	call   74e <putc>
     96b:	83 c4 10             	add    $0x10,%esp
     96e:	eb 25                	jmp    995 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     970:	83 ec 08             	sub    $0x8,%esp
     973:	6a 25                	push   $0x25
     975:	ff 75 08             	pushl  0x8(%ebp)
     978:	e8 d1 fd ff ff       	call   74e <putc>
     97d:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     980:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     983:	0f be c0             	movsbl %al,%eax
     986:	83 ec 08             	sub    $0x8,%esp
     989:	50                   	push   %eax
     98a:	ff 75 08             	pushl  0x8(%ebp)
     98d:	e8 bc fd ff ff       	call   74e <putc>
     992:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     995:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     99c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     9a0:	8b 55 0c             	mov    0xc(%ebp),%edx
     9a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
     9a6:	01 d0                	add    %edx,%eax
     9a8:	0f b6 00             	movzbl (%eax),%eax
     9ab:	84 c0                	test   %al,%al
     9ad:	0f 85 94 fe ff ff    	jne    847 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     9b3:	90                   	nop
     9b4:	c9                   	leave  
     9b5:	c3                   	ret    

000009b6 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     9b6:	55                   	push   %ebp
     9b7:	89 e5                	mov    %esp,%ebp
     9b9:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     9bc:	8b 45 08             	mov    0x8(%ebp),%eax
     9bf:	83 e8 08             	sub    $0x8,%eax
     9c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     9c5:	a1 cc e9 01 00       	mov    0x1e9cc,%eax
     9ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
     9cd:	eb 24                	jmp    9f3 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     9cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
     9d2:	8b 00                	mov    (%eax),%eax
     9d4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     9d7:	77 12                	ja     9eb <free+0x35>
     9d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
     9dc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     9df:	77 24                	ja     a05 <free+0x4f>
     9e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
     9e4:	8b 00                	mov    (%eax),%eax
     9e6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     9e9:	77 1a                	ja     a05 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     9eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
     9ee:	8b 00                	mov    (%eax),%eax
     9f0:	89 45 fc             	mov    %eax,-0x4(%ebp)
     9f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
     9f6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     9f9:	76 d4                	jbe    9cf <free+0x19>
     9fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
     9fe:	8b 00                	mov    (%eax),%eax
     a00:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     a03:	76 ca                	jbe    9cf <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     a05:	8b 45 f8             	mov    -0x8(%ebp),%eax
     a08:	8b 40 04             	mov    0x4(%eax),%eax
     a0b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     a12:	8b 45 f8             	mov    -0x8(%ebp),%eax
     a15:	01 c2                	add    %eax,%edx
     a17:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a1a:	8b 00                	mov    (%eax),%eax
     a1c:	39 c2                	cmp    %eax,%edx
     a1e:	75 24                	jne    a44 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     a20:	8b 45 f8             	mov    -0x8(%ebp),%eax
     a23:	8b 50 04             	mov    0x4(%eax),%edx
     a26:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a29:	8b 00                	mov    (%eax),%eax
     a2b:	8b 40 04             	mov    0x4(%eax),%eax
     a2e:	01 c2                	add    %eax,%edx
     a30:	8b 45 f8             	mov    -0x8(%ebp),%eax
     a33:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     a36:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a39:	8b 00                	mov    (%eax),%eax
     a3b:	8b 10                	mov    (%eax),%edx
     a3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
     a40:	89 10                	mov    %edx,(%eax)
     a42:	eb 0a                	jmp    a4e <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     a44:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a47:	8b 10                	mov    (%eax),%edx
     a49:	8b 45 f8             	mov    -0x8(%ebp),%eax
     a4c:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     a4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a51:	8b 40 04             	mov    0x4(%eax),%eax
     a54:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     a5b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a5e:	01 d0                	add    %edx,%eax
     a60:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     a63:	75 20                	jne    a85 <free+0xcf>
    p->s.size += bp->s.size;
     a65:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a68:	8b 50 04             	mov    0x4(%eax),%edx
     a6b:	8b 45 f8             	mov    -0x8(%ebp),%eax
     a6e:	8b 40 04             	mov    0x4(%eax),%eax
     a71:	01 c2                	add    %eax,%edx
     a73:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a76:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     a79:	8b 45 f8             	mov    -0x8(%ebp),%eax
     a7c:	8b 10                	mov    (%eax),%edx
     a7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a81:	89 10                	mov    %edx,(%eax)
     a83:	eb 08                	jmp    a8d <free+0xd7>
  } else
    p->s.ptr = bp;
     a85:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a88:	8b 55 f8             	mov    -0x8(%ebp),%edx
     a8b:	89 10                	mov    %edx,(%eax)
  freep = p;
     a8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     a90:	a3 cc e9 01 00       	mov    %eax,0x1e9cc
}
     a95:	90                   	nop
     a96:	c9                   	leave  
     a97:	c3                   	ret    

00000a98 <morecore>:

static Header*
morecore(uint nu)
{
     a98:	55                   	push   %ebp
     a99:	89 e5                	mov    %esp,%ebp
     a9b:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     a9e:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     aa5:	77 07                	ja     aae <morecore+0x16>
    nu = 4096;
     aa7:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     aae:	8b 45 08             	mov    0x8(%ebp),%eax
     ab1:	c1 e0 03             	shl    $0x3,%eax
     ab4:	83 ec 0c             	sub    $0xc,%esp
     ab7:	50                   	push   %eax
     ab8:	e8 49 fc ff ff       	call   706 <sbrk>
     abd:	83 c4 10             	add    $0x10,%esp
     ac0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     ac3:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     ac7:	75 07                	jne    ad0 <morecore+0x38>
    return 0;
     ac9:	b8 00 00 00 00       	mov    $0x0,%eax
     ace:	eb 26                	jmp    af6 <morecore+0x5e>
  hp = (Header*)p;
     ad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ad3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     ad6:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ad9:	8b 55 08             	mov    0x8(%ebp),%edx
     adc:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     adf:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ae2:	83 c0 08             	add    $0x8,%eax
     ae5:	83 ec 0c             	sub    $0xc,%esp
     ae8:	50                   	push   %eax
     ae9:	e8 c8 fe ff ff       	call   9b6 <free>
     aee:	83 c4 10             	add    $0x10,%esp
  return freep;
     af1:	a1 cc e9 01 00       	mov    0x1e9cc,%eax
}
     af6:	c9                   	leave  
     af7:	c3                   	ret    

00000af8 <malloc>:

void*
malloc(uint nbytes)
{
     af8:	55                   	push   %ebp
     af9:	89 e5                	mov    %esp,%ebp
     afb:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     afe:	8b 45 08             	mov    0x8(%ebp),%eax
     b01:	83 c0 07             	add    $0x7,%eax
     b04:	c1 e8 03             	shr    $0x3,%eax
     b07:	83 c0 01             	add    $0x1,%eax
     b0a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     b0d:	a1 cc e9 01 00       	mov    0x1e9cc,%eax
     b12:	89 45 f0             	mov    %eax,-0x10(%ebp)
     b15:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     b19:	75 23                	jne    b3e <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     b1b:	c7 45 f0 c4 e9 01 00 	movl   $0x1e9c4,-0x10(%ebp)
     b22:	8b 45 f0             	mov    -0x10(%ebp),%eax
     b25:	a3 cc e9 01 00       	mov    %eax,0x1e9cc
     b2a:	a1 cc e9 01 00       	mov    0x1e9cc,%eax
     b2f:	a3 c4 e9 01 00       	mov    %eax,0x1e9c4
    base.s.size = 0;
     b34:	c7 05 c8 e9 01 00 00 	movl   $0x0,0x1e9c8
     b3b:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     b3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
     b41:	8b 00                	mov    (%eax),%eax
     b43:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     b46:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b49:	8b 40 04             	mov    0x4(%eax),%eax
     b4c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     b4f:	72 4d                	jb     b9e <malloc+0xa6>
      if(p->s.size == nunits)
     b51:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b54:	8b 40 04             	mov    0x4(%eax),%eax
     b57:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     b5a:	75 0c                	jne    b68 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     b5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b5f:	8b 10                	mov    (%eax),%edx
     b61:	8b 45 f0             	mov    -0x10(%ebp),%eax
     b64:	89 10                	mov    %edx,(%eax)
     b66:	eb 26                	jmp    b8e <malloc+0x96>
      else {
        p->s.size -= nunits;
     b68:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b6b:	8b 40 04             	mov    0x4(%eax),%eax
     b6e:	2b 45 ec             	sub    -0x14(%ebp),%eax
     b71:	89 c2                	mov    %eax,%edx
     b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b76:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     b79:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b7c:	8b 40 04             	mov    0x4(%eax),%eax
     b7f:	c1 e0 03             	shl    $0x3,%eax
     b82:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b88:	8b 55 ec             	mov    -0x14(%ebp),%edx
     b8b:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     b8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
     b91:	a3 cc e9 01 00       	mov    %eax,0x1e9cc
      return (void*)(p + 1);
     b96:	8b 45 f4             	mov    -0xc(%ebp),%eax
     b99:	83 c0 08             	add    $0x8,%eax
     b9c:	eb 3b                	jmp    bd9 <malloc+0xe1>
    }
    if(p == freep)
     b9e:	a1 cc e9 01 00       	mov    0x1e9cc,%eax
     ba3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     ba6:	75 1e                	jne    bc6 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     ba8:	83 ec 0c             	sub    $0xc,%esp
     bab:	ff 75 ec             	pushl  -0x14(%ebp)
     bae:	e8 e5 fe ff ff       	call   a98 <morecore>
     bb3:	83 c4 10             	add    $0x10,%esp
     bb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
     bb9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     bbd:	75 07                	jne    bc6 <malloc+0xce>
        return 0;
     bbf:	b8 00 00 00 00       	mov    $0x0,%eax
     bc4:	eb 13                	jmp    bd9 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     bc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     bc9:	89 45 f0             	mov    %eax,-0x10(%ebp)
     bcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     bcf:	8b 00                	mov    (%eax),%eax
     bd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     bd4:	e9 6d ff ff ff       	jmp    b46 <malloc+0x4e>
}
     bd9:	c9                   	leave  
     bda:	c3                   	ret    

00000bdb <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     bdb:	55                   	push   %ebp
     bdc:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     bde:	a1 d0 e9 01 00       	mov    0x1e9d0,%eax
     be3:	83 c0 01             	add    $0x1,%eax
     be6:	a3 d0 e9 01 00       	mov    %eax,0x1e9d0
    g_seed = (214013*g_seed+2531011);
     beb:	a1 d0 e9 01 00       	mov    0x1e9d0,%eax
     bf0:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     bf6:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     bfb:	a3 d0 e9 01 00       	mov    %eax,0x1e9d0
    return (g_seed>>16)&0x7FFF;
     c00:	a1 d0 e9 01 00       	mov    0x1e9d0,%eax
     c05:	c1 e8 10             	shr    $0x10,%eax
     c08:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     c0d:	5d                   	pop    %ebp
     c0e:	c3                   	ret    

00000c0f <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     c0f:	55                   	push   %ebp
     c10:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     c12:	d9 45 08             	flds   0x8(%ebp)
     c15:	d9 ee                	fldz   
     c17:	d9 c9                	fxch   %st(1)
     c19:	df e9                	fucomip %st(1),%st
     c1b:	dd d8                	fstp   %st(0)
     c1d:	76 05                	jbe    c24 <abs+0x15>
     c1f:	d9 45 08             	flds   0x8(%ebp)
     c22:	eb 05                	jmp    c29 <abs+0x1a>
	return -x;
     c24:	d9 45 08             	flds   0x8(%ebp)
     c27:	d9 e0                	fchs   
}
     c29:	5d                   	pop    %ebp
     c2a:	c3                   	ret    

00000c2b <pow>:

float pow(float a, int b)
{
     c2b:	55                   	push   %ebp
     c2c:	89 e5                	mov    %esp,%ebp
     c2e:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     c31:	d9 45 08             	flds   0x8(%ebp)
     c34:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     c37:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     c3b:	7e 17                	jle    c54 <pow+0x29>
		while (--b)
     c3d:	eb 09                	jmp    c48 <pow+0x1d>
			r *= a;
     c3f:	d9 45 fc             	flds   -0x4(%ebp)
     c42:	d8 4d 08             	fmuls  0x8(%ebp)
     c45:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     c48:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     c4c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     c50:	75 ed                	jne    c3f <pow+0x14>
     c52:	eb 2a                	jmp    c7e <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     c54:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     c58:	79 1f                	jns    c79 <pow+0x4e>
		while (++b)
     c5a:	eb 09                	jmp    c65 <pow+0x3a>
			r *= a;
     c5c:	d9 45 fc             	flds   -0x4(%ebp)
     c5f:	d8 4d 08             	fmuls  0x8(%ebp)
     c62:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     c65:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     c69:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     c6d:	75 ed                	jne    c5c <pow+0x31>
			r *= a;
		r = 1.0 / r;
     c6f:	d9 e8                	fld1   
     c71:	d8 75 fc             	fdivs  -0x4(%ebp)
     c74:	d9 5d fc             	fstps  -0x4(%ebp)
     c77:	eb 05                	jmp    c7e <pow+0x53>
	}
	else r = 0;
     c79:	d9 ee                	fldz   
     c7b:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     c7e:	d9 45 fc             	flds   -0x4(%ebp)
}
     c81:	c9                   	leave  
     c82:	c3                   	ret    

00000c83 <sqrt>:

float sqrt(float number) {
     c83:	55                   	push   %ebp
     c84:	89 e5                	mov    %esp,%ebp
     c86:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     c89:	d9 ee                	fldz   
     c8b:	d9 45 08             	flds   0x8(%ebp)
     c8e:	d9 c9                	fxch   %st(1)
     c90:	df e9                	fucomip %st(1),%st
     c92:	dd d8                	fstp   %st(0)
     c94:	76 06                	jbe    c9c <sqrt+0x19>
		return -1;
     c96:	d9 e8                	fld1   
     c98:	d9 e0                	fchs   
     c9a:	eb 3a                	jmp    cd6 <sqrt+0x53>
	}

	new_guess = 1;
     c9c:	d9 e8                	fld1   
     c9e:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     ca1:	d9 45 fc             	flds   -0x4(%ebp)
     ca4:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     ca7:	d9 45 08             	flds   0x8(%ebp)
     caa:	d8 75 f8             	fdivs  -0x8(%ebp)
     cad:	d8 45 f8             	fadds  -0x8(%ebp)
     cb0:	d9 05 30 62 01 00    	flds   0x16230
     cb6:	de f9                	fdivrp %st,%st(1)
     cb8:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     cbb:	d9 45 fc             	flds   -0x4(%ebp)
     cbe:	d9 45 f8             	flds   -0x8(%ebp)
     cc1:	df e9                	fucomip %st(1),%st
     cc3:	dd d8                	fstp   %st(0)
     cc5:	7a da                	jp     ca1 <sqrt+0x1e>
     cc7:	d9 45 fc             	flds   -0x4(%ebp)
     cca:	d9 45 f8             	flds   -0x8(%ebp)
     ccd:	df e9                	fucomip %st(1),%st
     ccf:	dd d8                	fstp   %st(0)
     cd1:	75 ce                	jne    ca1 <sqrt+0x1e>

	return new_guess;
     cd3:	d9 45 fc             	flds   -0x4(%ebp)
}
     cd6:	c9                   	leave  
     cd7:	c3                   	ret    

00000cd8 <cos>:

float cos(float x)
{
     cd8:	55                   	push   %ebp
     cd9:	89 e5                	mov    %esp,%ebp
     cdb:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     cde:	d9 e8                	fld1   
     ce0:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     ce3:	d9 45 08             	flds   0x8(%ebp)
     ce6:	dd 05 38 62 01 00    	fldl   0x16238
     cec:	d9 c9                	fxch   %st(1)
     cee:	df e9                	fucomip %st(1),%st
     cf0:	dd d8                	fstp   %st(0)
     cf2:	77 0f                	ja     d03 <cos+0x2b>
     cf4:	d9 45 08             	flds   0x8(%ebp)
     cf7:	dd 05 40 62 01 00    	fldl   0x16240
     cfd:	df e9                	fucomip %st(1),%st
     cff:	dd d8                	fstp   %st(0)
     d01:	76 3c                	jbe    d3f <cos+0x67>
     d03:	d9 45 08             	flds   0x8(%ebp)
     d06:	d9 45 08             	flds   0x8(%ebp)
     d09:	dd 05 38 62 01 00    	fldl   0x16238
     d0f:	de f9                	fdivrp %st,%st(1)
     d11:	d9 7d e2             	fnstcw -0x1e(%ebp)
     d14:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     d18:	b4 0c                	mov    $0xc,%ah
     d1a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     d1e:	d9 6d e0             	fldcw  -0x20(%ebp)
     d21:	db 5d dc             	fistpl -0x24(%ebp)
     d24:	d9 6d e2             	fldcw  -0x1e(%ebp)
     d27:	8b 45 dc             	mov    -0x24(%ebp),%eax
     d2a:	01 c0                	add    %eax,%eax
     d2c:	89 45 d8             	mov    %eax,-0x28(%ebp)
     d2f:	db 45 d8             	fildl  -0x28(%ebp)
     d32:	dd 05 48 62 01 00    	fldl   0x16248
     d38:	de c9                	fmulp  %st,%st(1)
     d3a:	de e9                	fsubrp %st,%st(1)
     d3c:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     d3f:	d9 45 08             	flds   0x8(%ebp)
     d42:	dd 05 48 62 01 00    	fldl   0x16248
     d48:	d9 c9                	fxch   %st(1)
     d4a:	df e9                	fucomip %st(1),%st
     d4c:	dd d8                	fstp   %st(0)
     d4e:	76 0e                	jbe    d5e <cos+0x86>
     d50:	d9 45 08             	flds   0x8(%ebp)
     d53:	dd 05 38 62 01 00    	fldl   0x16238
     d59:	de e9                	fsubrp %st,%st(1)
     d5b:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     d5e:	d9 45 08             	flds   0x8(%ebp)
     d61:	dd 05 50 62 01 00    	fldl   0x16250
     d67:	df e9                	fucomip %st(1),%st
     d69:	dd d8                	fstp   %st(0)
     d6b:	76 0e                	jbe    d7b <cos+0xa3>
     d6d:	d9 45 08             	flds   0x8(%ebp)
     d70:	dd 05 38 62 01 00    	fldl   0x16238
     d76:	de c1                	faddp  %st,%st(1)
     d78:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     d7b:	d9 45 08             	flds   0x8(%ebp)
     d7e:	dd 05 58 62 01 00    	fldl   0x16258
     d84:	d9 c9                	fxch   %st(1)
     d86:	df e9                	fucomip %st(1),%st
     d88:	dd d8                	fstp   %st(0)
     d8a:	76 16                	jbe    da2 <cos+0xca>
    {
        x -= PI;
     d8c:	d9 45 08             	flds   0x8(%ebp)
     d8f:	dd 05 48 62 01 00    	fldl   0x16248
     d95:	de e9                	fsubrp %st,%st(1)
     d97:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     d9a:	d9 45 f4             	flds   -0xc(%ebp)
     d9d:	d9 e0                	fchs   
     d9f:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     da2:	d9 45 08             	flds   0x8(%ebp)
     da5:	dd 05 60 62 01 00    	fldl   0x16260
     dab:	df e9                	fucomip %st(1),%st
     dad:	dd d8                	fstp   %st(0)
     daf:	76 16                	jbe    dc7 <cos+0xef>
    {
        x += PI;
     db1:	d9 45 08             	flds   0x8(%ebp)
     db4:	dd 05 48 62 01 00    	fldl   0x16248
     dba:	de c1                	faddp  %st,%st(1)
     dbc:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     dbf:	d9 45 f4             	flds   -0xc(%ebp)
     dc2:	d9 e0                	fchs   
     dc4:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     dc7:	d9 45 08             	flds   0x8(%ebp)
     dca:	dd 05 68 62 01 00    	fldl   0x16268
     dd0:	d9 c9                	fxch   %st(1)
     dd2:	df e9                	fucomip %st(1),%st
     dd4:	dd d8                	fstp   %st(0)
     dd6:	76 28                	jbe    e00 <cos+0x128>
     dd8:	d9 45 08             	flds   0x8(%ebp)
     ddb:	dd 05 58 62 01 00    	fldl   0x16258
     de1:	de e1                	fsubp  %st,%st(1)
     de3:	d9 5d e4             	fstps  -0x1c(%ebp)
     de6:	d9 45 e4             	flds   -0x1c(%ebp)
     de9:	83 ec 0c             	sub    $0xc,%esp
     dec:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     df0:	d9 1c 24             	fstps  (%esp)
     df3:	e8 83 00 00 00       	call   e7b <sin>
     df8:	83 c4 10             	add    $0x10,%esp
     dfb:	d8 4d f4             	fmuls  -0xc(%ebp)
     dfe:	eb 79                	jmp    e79 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     e00:	83 ec 08             	sub    $0x8,%esp
     e03:	6a 02                	push   $0x2
     e05:	ff 75 08             	pushl  0x8(%ebp)
     e08:	e8 1e fe ff ff       	call   c2b <pow>
     e0d:	83 c4 10             	add    $0x10,%esp
     e10:	d9 05 30 62 01 00    	flds   0x16230
     e16:	de f9                	fdivrp %st,%st(1)
     e18:	d9 e8                	fld1   
     e1a:	de e1                	fsubp  %st,%st(1)
     e1c:	d9 5d d8             	fstps  -0x28(%ebp)
     e1f:	83 ec 08             	sub    $0x8,%esp
     e22:	6a 04                	push   $0x4
     e24:	ff 75 08             	pushl  0x8(%ebp)
     e27:	e8 ff fd ff ff       	call   c2b <pow>
     e2c:	83 c4 10             	add    $0x10,%esp
     e2f:	d9 05 70 62 01 00    	flds   0x16270
     e35:	de f9                	fdivrp %st,%st(1)
     e37:	d8 45 d8             	fadds  -0x28(%ebp)
     e3a:	d9 5d d8             	fstps  -0x28(%ebp)
     e3d:	83 ec 08             	sub    $0x8,%esp
     e40:	6a 06                	push   $0x6
     e42:	ff 75 08             	pushl  0x8(%ebp)
     e45:	e8 e1 fd ff ff       	call   c2b <pow>
     e4a:	83 c4 10             	add    $0x10,%esp
     e4d:	d9 05 74 62 01 00    	flds   0x16274
     e53:	de f9                	fdivrp %st,%st(1)
     e55:	d8 6d d8             	fsubrs -0x28(%ebp)
     e58:	d9 5d d8             	fstps  -0x28(%ebp)
     e5b:	83 ec 08             	sub    $0x8,%esp
     e5e:	6a 08                	push   $0x8
     e60:	ff 75 08             	pushl  0x8(%ebp)
     e63:	e8 c3 fd ff ff       	call   c2b <pow>
     e68:	83 c4 10             	add    $0x10,%esp
     e6b:	d9 05 78 62 01 00    	flds   0x16278
     e71:	de f9                	fdivrp %st,%st(1)
     e73:	d8 45 d8             	fadds  -0x28(%ebp)
     e76:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     e79:	c9                   	leave  
     e7a:	c3                   	ret    

00000e7b <sin>:

float sin(float x)
{
     e7b:	55                   	push   %ebp
     e7c:	89 e5                	mov    %esp,%ebp
     e7e:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     e81:	d9 e8                	fld1   
     e83:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     e86:	d9 45 08             	flds   0x8(%ebp)
     e89:	dd 05 38 62 01 00    	fldl   0x16238
     e8f:	d9 c9                	fxch   %st(1)
     e91:	df e9                	fucomip %st(1),%st
     e93:	dd d8                	fstp   %st(0)
     e95:	77 0f                	ja     ea6 <sin+0x2b>
     e97:	d9 45 08             	flds   0x8(%ebp)
     e9a:	dd 05 40 62 01 00    	fldl   0x16240
     ea0:	df e9                	fucomip %st(1),%st
     ea2:	dd d8                	fstp   %st(0)
     ea4:	76 3c                	jbe    ee2 <sin+0x67>
     ea6:	d9 45 08             	flds   0x8(%ebp)
     ea9:	d9 45 08             	flds   0x8(%ebp)
     eac:	dd 05 38 62 01 00    	fldl   0x16238
     eb2:	de f9                	fdivrp %st,%st(1)
     eb4:	d9 7d e2             	fnstcw -0x1e(%ebp)
     eb7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     ebb:	b4 0c                	mov    $0xc,%ah
     ebd:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     ec1:	d9 6d e0             	fldcw  -0x20(%ebp)
     ec4:	db 5d dc             	fistpl -0x24(%ebp)
     ec7:	d9 6d e2             	fldcw  -0x1e(%ebp)
     eca:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ecd:	01 c0                	add    %eax,%eax
     ecf:	89 45 d8             	mov    %eax,-0x28(%ebp)
     ed2:	db 45 d8             	fildl  -0x28(%ebp)
     ed5:	dd 05 48 62 01 00    	fldl   0x16248
     edb:	de c9                	fmulp  %st,%st(1)
     edd:	de e9                	fsubrp %st,%st(1)
     edf:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     ee2:	d9 45 08             	flds   0x8(%ebp)
     ee5:	dd 05 48 62 01 00    	fldl   0x16248
     eeb:	d9 c9                	fxch   %st(1)
     eed:	df e9                	fucomip %st(1),%st
     eef:	dd d8                	fstp   %st(0)
     ef1:	76 0e                	jbe    f01 <sin+0x86>
     ef3:	d9 45 08             	flds   0x8(%ebp)
     ef6:	dd 05 38 62 01 00    	fldl   0x16238
     efc:	de e9                	fsubrp %st,%st(1)
     efe:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     f01:	d9 45 08             	flds   0x8(%ebp)
     f04:	dd 05 50 62 01 00    	fldl   0x16250
     f0a:	df e9                	fucomip %st(1),%st
     f0c:	dd d8                	fstp   %st(0)
     f0e:	76 0e                	jbe    f1e <sin+0xa3>
     f10:	d9 45 08             	flds   0x8(%ebp)
     f13:	dd 05 38 62 01 00    	fldl   0x16238
     f19:	de c1                	faddp  %st,%st(1)
     f1b:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     f1e:	d9 45 08             	flds   0x8(%ebp)
     f21:	dd 05 58 62 01 00    	fldl   0x16258
     f27:	d9 c9                	fxch   %st(1)
     f29:	df e9                	fucomip %st(1),%st
     f2b:	dd d8                	fstp   %st(0)
     f2d:	76 16                	jbe    f45 <sin+0xca>
    {
        x -= PI;
     f2f:	d9 45 08             	flds   0x8(%ebp)
     f32:	dd 05 48 62 01 00    	fldl   0x16248
     f38:	de e9                	fsubrp %st,%st(1)
     f3a:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     f3d:	d9 45 f4             	flds   -0xc(%ebp)
     f40:	d9 e0                	fchs   
     f42:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     f45:	d9 45 08             	flds   0x8(%ebp)
     f48:	dd 05 60 62 01 00    	fldl   0x16260
     f4e:	df e9                	fucomip %st(1),%st
     f50:	dd d8                	fstp   %st(0)
     f52:	76 16                	jbe    f6a <sin+0xef>
    {
        x += PI;
     f54:	d9 45 08             	flds   0x8(%ebp)
     f57:	dd 05 48 62 01 00    	fldl   0x16248
     f5d:	de c1                	faddp  %st,%st(1)
     f5f:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     f62:	d9 45 f4             	flds   -0xc(%ebp)
     f65:	d9 e0                	fchs   
     f67:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     f6a:	d9 ee                	fldz   
     f6c:	d9 45 08             	flds   0x8(%ebp)
     f6f:	d9 c9                	fxch   %st(1)
     f71:	df e9                	fucomip %st(1),%st
     f73:	dd d8                	fstp   %st(0)
     f75:	76 10                	jbe    f87 <sin+0x10c>
    {
        x *= -1;
     f77:	d9 45 08             	flds   0x8(%ebp)
     f7a:	d9 e0                	fchs   
     f7c:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     f7f:	d9 45 f4             	flds   -0xc(%ebp)
     f82:	d9 e0                	fchs   
     f84:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     f87:	d9 45 08             	flds   0x8(%ebp)
     f8a:	dd 05 68 62 01 00    	fldl   0x16268
     f90:	d9 c9                	fxch   %st(1)
     f92:	df e9                	fucomip %st(1),%st
     f94:	dd d8                	fstp   %st(0)
     f96:	76 28                	jbe    fc0 <sin+0x145>
     f98:	d9 45 08             	flds   0x8(%ebp)
     f9b:	dd 05 58 62 01 00    	fldl   0x16258
     fa1:	de e1                	fsubp  %st,%st(1)
     fa3:	d9 5d e4             	fstps  -0x1c(%ebp)
     fa6:	d9 45 e4             	flds   -0x1c(%ebp)
     fa9:	83 ec 0c             	sub    $0xc,%esp
     fac:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     fb0:	d9 1c 24             	fstps  (%esp)
     fb3:	e8 20 fd ff ff       	call   cd8 <cos>
     fb8:	83 c4 10             	add    $0x10,%esp
     fbb:	d8 4d f4             	fmuls  -0xc(%ebp)
     fbe:	eb 7a                	jmp    103a <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     fc0:	83 ec 08             	sub    $0x8,%esp
     fc3:	6a 03                	push   $0x3
     fc5:	ff 75 08             	pushl  0x8(%ebp)
     fc8:	e8 5e fc ff ff       	call   c2b <pow>
     fcd:	83 c4 10             	add    $0x10,%esp
     fd0:	d9 05 7c 62 01 00    	flds   0x1627c
     fd6:	de f9                	fdivrp %st,%st(1)
     fd8:	d9 45 08             	flds   0x8(%ebp)
     fdb:	de e1                	fsubp  %st,%st(1)
     fdd:	d9 5d d8             	fstps  -0x28(%ebp)
     fe0:	83 ec 08             	sub    $0x8,%esp
     fe3:	6a 05                	push   $0x5
     fe5:	ff 75 08             	pushl  0x8(%ebp)
     fe8:	e8 3e fc ff ff       	call   c2b <pow>
     fed:	83 c4 10             	add    $0x10,%esp
     ff0:	d9 05 80 62 01 00    	flds   0x16280
     ff6:	de f9                	fdivrp %st,%st(1)
     ff8:	d8 45 d8             	fadds  -0x28(%ebp)
     ffb:	d9 5d d8             	fstps  -0x28(%ebp)
     ffe:	83 ec 08             	sub    $0x8,%esp
    1001:	6a 07                	push   $0x7
    1003:	ff 75 08             	pushl  0x8(%ebp)
    1006:	e8 20 fc ff ff       	call   c2b <pow>
    100b:	83 c4 10             	add    $0x10,%esp
    100e:	d9 05 84 62 01 00    	flds   0x16284
    1014:	de f9                	fdivrp %st,%st(1)
    1016:	d8 6d d8             	fsubrs -0x28(%ebp)
    1019:	d9 5d d8             	fstps  -0x28(%ebp)
    101c:	83 ec 08             	sub    $0x8,%esp
    101f:	6a 09                	push   $0x9
    1021:	ff 75 08             	pushl  0x8(%ebp)
    1024:	e8 02 fc ff ff       	call   c2b <pow>
    1029:	83 c4 10             	add    $0x10,%esp
    102c:	d9 05 88 62 01 00    	flds   0x16288
    1032:	de f9                	fdivrp %st,%st(1)
    1034:	d8 45 d8             	fadds  -0x28(%ebp)
    1037:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    103a:	c9                   	leave  
    103b:	c3                   	ret    

0000103c <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
    103c:	55                   	push   %ebp
    103d:	89 e5                	mov    %esp,%ebp
    103f:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1042:	83 ec 04             	sub    $0x4,%esp
    1045:	6a 0e                	push   $0xe
    1047:	ff 75 0c             	pushl  0xc(%ebp)
    104a:	ff 75 08             	pushl  0x8(%ebp)
    104d:	e8 44 f6 ff ff       	call   696 <read>
    1052:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1055:	83 ec 04             	sub    $0x4,%esp
    1058:	6a 28                	push   $0x28
    105a:	ff 75 10             	pushl  0x10(%ebp)
    105d:	ff 75 08             	pushl  0x8(%ebp)
    1060:	e8 31 f6 ff ff       	call   696 <read>
    1065:	83 c4 10             	add    $0x10,%esp
}
    1068:	90                   	nop
    1069:	c9                   	leave  
    106a:	c3                   	ret    

0000106b <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
    106b:	55                   	push   %ebp
    106c:	89 e5                	mov    %esp,%ebp
    106e:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    1074:	83 ec 08             	sub    $0x8,%esp
    1077:	6a 00                	push   $0x0
    1079:	ff 75 08             	pushl  0x8(%ebp)
    107c:	e8 3d f6 ff ff       	call   6be <open>
    1081:	83 c4 10             	add    $0x10,%esp
    1084:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    1087:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    108b:	79 0a                	jns    1097 <readBitmapFile+0x2c>
        return -1;
    108d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1092:	e9 6e 01 00 00       	jmp    1205 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1097:	83 ec 04             	sub    $0x4,%esp
    109a:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    109d:	50                   	push   %eax
    109e:	8d 45 ca             	lea    -0x36(%ebp),%eax
    10a1:	50                   	push   %eax
    10a2:	ff 75 ec             	pushl  -0x14(%ebp)
    10a5:	e8 92 ff ff ff       	call   103c <readBitmapHeader>
    10aa:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    10ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    10b0:	83 e8 36             	sub    $0x36,%eax
    10b3:	83 ec 04             	sub    $0x4,%esp
    10b6:	50                   	push   %eax
    10b7:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    10bd:	50                   	push   %eax
    10be:	ff 75 ec             	pushl  -0x14(%ebp)
    10c1:	e8 d0 f5 ff ff       	call   696 <read>
    10c6:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    10c9:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    10cc:	8b 45 14             	mov    0x14(%ebp),%eax
    10cf:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    10d1:	8b 55 aa             	mov    -0x56(%ebp),%edx
    10d4:	8b 45 10             	mov    0x10(%ebp),%eax
    10d7:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    10d9:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    10dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    10df:	8b 45 aa             	mov    -0x56(%ebp),%eax
    10e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    10e5:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    10e9:	0f b7 c0             	movzwl %ax,%eax
    10ec:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    10ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
    10f2:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    10f6:	8d 50 07             	lea    0x7(%eax),%edx
    10f9:	85 c0                	test   %eax,%eax
    10fb:	0f 48 c2             	cmovs  %edx,%eax
    10fe:	c1 f8 03             	sar    $0x3,%eax
    1101:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1104:	8b 45 0c             	mov    0xc(%ebp),%eax
    1107:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    110a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    110d:	83 e8 01             	sub    $0x1,%eax
    1110:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1113:	e9 d0 00 00 00       	jmp    11e8 <readBitmapFile+0x17d>
        if (bits == 32) {
    1118:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    111c:	75 22                	jne    1140 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    111e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1121:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    1125:	89 c2                	mov    %eax,%edx
    1127:	8b 45 d8             	mov    -0x28(%ebp),%eax
    112a:	01 d0                	add    %edx,%eax
    112c:	83 ec 04             	sub    $0x4,%esp
    112f:	ff 75 dc             	pushl  -0x24(%ebp)
    1132:	50                   	push   %eax
    1133:	ff 75 ec             	pushl  -0x14(%ebp)
    1136:	e8 5b f5 ff ff       	call   696 <read>
    113b:	83 c4 10             	add    $0x10,%esp
    113e:	eb 65                	jmp    11a5 <readBitmapFile+0x13a>
        } else {
            int j = 0;
    1140:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    1147:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    114e:	eb 4d                	jmp    119d <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    1150:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1153:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1157:	c1 e0 02             	shl    $0x2,%eax
    115a:	89 c2                	mov    %eax,%edx
    115c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    115f:	c1 e0 02             	shl    $0x2,%eax
    1162:	01 c2                	add    %eax,%edx
    1164:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1167:	01 d0                	add    %edx,%eax
    1169:	83 ec 04             	sub    $0x4,%esp
    116c:	6a 03                	push   $0x3
    116e:	50                   	push   %eax
    116f:	ff 75 ec             	pushl  -0x14(%ebp)
    1172:	e8 1f f5 ff ff       	call   696 <read>
    1177:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    117a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    117d:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1181:	c1 e0 02             	shl    $0x2,%eax
    1184:	89 c2                	mov    %eax,%edx
    1186:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1189:	c1 e0 02             	shl    $0x2,%eax
    118c:	01 d0                	add    %edx,%eax
    118e:	8d 50 03             	lea    0x3(%eax),%edx
    1191:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1194:	01 d0                	add    %edx,%eax
    1196:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    1199:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    119d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    11a0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    11a3:	7c ab                	jl     1150 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    11a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    11a8:	99                   	cltd   
    11a9:	c1 ea 1e             	shr    $0x1e,%edx
    11ac:	01 d0                	add    %edx,%eax
    11ae:	83 e0 03             	and    $0x3,%eax
    11b1:	29 d0                	sub    %edx,%eax
    11b3:	85 c0                	test   %eax,%eax
    11b5:	7e 2d                	jle    11e4 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    11b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    11ba:	99                   	cltd   
    11bb:	c1 ea 1e             	shr    $0x1e,%edx
    11be:	01 d0                	add    %edx,%eax
    11c0:	83 e0 03             	and    $0x3,%eax
    11c3:	29 d0                	sub    %edx,%eax
    11c5:	ba 04 00 00 00       	mov    $0x4,%edx
    11ca:	29 c2                	sub    %eax,%edx
    11cc:	89 d0                	mov    %edx,%eax
    11ce:	83 ec 04             	sub    $0x4,%esp
    11d1:	50                   	push   %eax
    11d2:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    11d8:	50                   	push   %eax
    11d9:	ff 75 ec             	pushl  -0x14(%ebp)
    11dc:	e8 b5 f4 ff ff       	call   696 <read>
    11e1:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    11e4:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    11e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    11ec:	0f 89 26 ff ff ff    	jns    1118 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    11f2:	83 ec 0c             	sub    $0xc,%esp
    11f5:	ff 75 ec             	pushl  -0x14(%ebp)
    11f8:	e8 a9 f4 ff ff       	call   6a6 <close>
    11fd:	83 c4 10             	add    $0x10,%esp
    return 0;
    1200:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1205:	c9                   	leave  
    1206:	c3                   	ret    

00001207 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    1207:	55                   	push   %ebp
    1208:	89 e5                	mov    %esp,%ebp
    120a:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    1210:	83 ec 08             	sub    $0x8,%esp
    1213:	6a 00                	push   $0x0
    1215:	ff 75 08             	pushl  0x8(%ebp)
    1218:	e8 a1 f4 ff ff       	call   6be <open>
    121d:	83 c4 10             	add    $0x10,%esp
    1220:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    1223:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1227:	79 0a                	jns    1233 <read24BitmapFile+0x2c>
        return -1;
    1229:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    122e:	e9 66 01 00 00       	jmp    1399 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1233:	83 ec 04             	sub    $0x4,%esp
    1236:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1239:	50                   	push   %eax
    123a:	8d 45 ca             	lea    -0x36(%ebp),%eax
    123d:	50                   	push   %eax
    123e:	ff 75 ec             	pushl  -0x14(%ebp)
    1241:	e8 f6 fd ff ff       	call   103c <readBitmapHeader>
    1246:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1249:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    124c:	83 e8 36             	sub    $0x36,%eax
    124f:	83 ec 04             	sub    $0x4,%esp
    1252:	50                   	push   %eax
    1253:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1259:	50                   	push   %eax
    125a:	ff 75 ec             	pushl  -0x14(%ebp)
    125d:	e8 34 f4 ff ff       	call   696 <read>
    1262:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    1265:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1268:	8b 45 14             	mov    0x14(%ebp),%eax
    126b:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    126d:	8b 55 aa             	mov    -0x56(%ebp),%edx
    1270:	8b 45 10             	mov    0x10(%ebp),%eax
    1273:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    1275:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    1278:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    127b:	8b 45 aa             	mov    -0x56(%ebp),%eax
    127e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    1281:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    1285:	0f b7 c0             	movzwl %ax,%eax
    1288:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    128b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    128e:	89 d0                	mov    %edx,%eax
    1290:	01 c0                	add    %eax,%eax
    1292:	01 d0                	add    %edx,%eax
    1294:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1297:	8b 45 0c             	mov    0xc(%ebp),%eax
    129a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    129d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    12a0:	83 e8 01             	sub    $0x1,%eax
    12a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    12a6:	e9 d1 00 00 00       	jmp    137c <read24BitmapFile+0x175>
        if (bits == 24) {
    12ab:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    12af:	75 22                	jne    12d3 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    12b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    12b4:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    12b8:	89 c2                	mov    %eax,%edx
    12ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
    12bd:	01 d0                	add    %edx,%eax
    12bf:	83 ec 04             	sub    $0x4,%esp
    12c2:	ff 75 dc             	pushl  -0x24(%ebp)
    12c5:	50                   	push   %eax
    12c6:	ff 75 ec             	pushl  -0x14(%ebp)
    12c9:	e8 c8 f3 ff ff       	call   696 <read>
    12ce:	83 c4 10             	add    $0x10,%esp
    12d1:	eb 66                	jmp    1339 <read24BitmapFile+0x132>
        } else {
            int j = 0;
    12d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    12da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    12e1:	eb 4e                	jmp    1331 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    12e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    12e6:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    12ea:	89 c2                	mov    %eax,%edx
    12ec:	89 d0                	mov    %edx,%eax
    12ee:	01 c0                	add    %eax,%eax
    12f0:	01 d0                	add    %edx,%eax
    12f2:	89 c1                	mov    %eax,%ecx
    12f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    12f7:	89 d0                	mov    %edx,%eax
    12f9:	01 c0                	add    %eax,%eax
    12fb:	01 d0                	add    %edx,%eax
    12fd:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    1300:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1303:	01 d0                	add    %edx,%eax
    1305:	83 ec 04             	sub    $0x4,%esp
    1308:	6a 03                	push   $0x3
    130a:	50                   	push   %eax
    130b:	ff 75 ec             	pushl  -0x14(%ebp)
    130e:	e8 83 f3 ff ff       	call   696 <read>
    1313:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    1316:	83 ec 04             	sub    $0x4,%esp
    1319:	6a 01                	push   $0x1
    131b:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1321:	50                   	push   %eax
    1322:	ff 75 ec             	pushl  -0x14(%ebp)
    1325:	e8 6c f3 ff ff       	call   696 <read>
    132a:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    132d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1331:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1334:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1337:	7c aa                	jl     12e3 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    1339:	8b 45 dc             	mov    -0x24(%ebp),%eax
    133c:	99                   	cltd   
    133d:	c1 ea 1e             	shr    $0x1e,%edx
    1340:	01 d0                	add    %edx,%eax
    1342:	83 e0 03             	and    $0x3,%eax
    1345:	29 d0                	sub    %edx,%eax
    1347:	85 c0                	test   %eax,%eax
    1349:	7e 2d                	jle    1378 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    134b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    134e:	99                   	cltd   
    134f:	c1 ea 1e             	shr    $0x1e,%edx
    1352:	01 d0                	add    %edx,%eax
    1354:	83 e0 03             	and    $0x3,%eax
    1357:	29 d0                	sub    %edx,%eax
    1359:	ba 04 00 00 00       	mov    $0x4,%edx
    135e:	29 c2                	sub    %eax,%edx
    1360:	89 d0                	mov    %edx,%eax
    1362:	83 ec 04             	sub    $0x4,%esp
    1365:	50                   	push   %eax
    1366:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    136c:	50                   	push   %eax
    136d:	ff 75 ec             	pushl  -0x14(%ebp)
    1370:	e8 21 f3 ff ff       	call   696 <read>
    1375:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1378:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    137c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1380:	0f 89 25 ff ff ff    	jns    12ab <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1386:	83 ec 0c             	sub    $0xc,%esp
    1389:	ff 75 ec             	pushl  -0x14(%ebp)
    138c:	e8 15 f3 ff ff       	call   6a6 <close>
    1391:	83 c4 10             	add    $0x10,%esp
    return 0;
    1394:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1399:	c9                   	leave  
    139a:	c3                   	ret    

0000139b <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    139b:	55                   	push   %ebp
    139c:	89 e5                	mov    %esp,%ebp
    139e:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    13a1:	8b 55 10             	mov    0x10(%ebp),%edx
    13a4:	89 d0                	mov    %edx,%eax
    13a6:	01 c0                	add    %eax,%eax
    13a8:	01 d0                	add    %edx,%eax
    13aa:	c1 e0 03             	shl    $0x3,%eax
    13ad:	83 c0 1f             	add    $0x1f,%eax
    13b0:	8d 50 1f             	lea    0x1f(%eax),%edx
    13b3:	85 c0                	test   %eax,%eax
    13b5:	0f 48 c2             	cmovs  %edx,%eax
    13b8:	c1 f8 05             	sar    $0x5,%eax
    13bb:	c1 e0 02             	shl    $0x2,%eax
    13be:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    13c1:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    13c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    13ca:	0f af 45 0c          	imul   0xc(%ebp),%eax
    13ce:	83 c0 36             	add    $0x36,%eax
    13d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    13d4:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    13da:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    13e0:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    13e7:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    13ee:	8b 45 10             	mov    0x10(%ebp),%eax
    13f1:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    13f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    13f7:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    13fa:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    1400:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    1406:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    140d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1410:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1414:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1417:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    141e:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    1425:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    142c:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1433:	83 ec 04             	sub    $0x4,%esp
    1436:	6a 0e                	push   $0xe
    1438:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    143b:	50                   	push   %eax
    143c:	ff 75 08             	pushl  0x8(%ebp)
    143f:	e8 5a f2 ff ff       	call   69e <write>
    1444:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1447:	83 ec 04             	sub    $0x4,%esp
    144a:	6a 28                	push   $0x28
    144c:	8d 45 be             	lea    -0x42(%ebp),%eax
    144f:	50                   	push   %eax
    1450:	ff 75 08             	pushl  0x8(%ebp)
    1453:	e8 46 f2 ff ff       	call   69e <write>
    1458:	83 c4 10             	add    $0x10,%esp
}
    145b:	90                   	nop
    145c:	c9                   	leave  
    145d:	c3                   	ret    

0000145e <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    145e:	55                   	push   %ebp
    145f:	89 e5                	mov    %esp,%ebp
    1461:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    1464:	83 ec 08             	sub    $0x8,%esp
    1467:	68 02 02 00 00       	push   $0x202
    146c:	ff 75 08             	pushl  0x8(%ebp)
    146f:	e8 4a f2 ff ff       	call   6be <open>
    1474:	83 c4 10             	add    $0x10,%esp
    1477:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    147a:	8b 55 14             	mov    0x14(%ebp),%edx
    147d:	89 d0                	mov    %edx,%eax
    147f:	01 c0                	add    %eax,%eax
    1481:	01 d0                	add    %edx,%eax
    1483:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    1486:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    148a:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    148e:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    1492:	83 ec 04             	sub    $0x4,%esp
    1495:	ff 75 14             	pushl  0x14(%ebp)
    1498:	ff 75 10             	pushl  0x10(%ebp)
    149b:	ff 75 f0             	pushl  -0x10(%ebp)
    149e:	e8 f8 fe ff ff       	call   139b <write24BitmapFileHeader>
    14a3:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    14a6:	8b 45 10             	mov    0x10(%ebp),%eax
    14a9:	83 e8 01             	sub    $0x1,%eax
    14ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
    14af:	eb 66                	jmp    1517 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    14b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    14b4:	0f af 45 14          	imul   0x14(%ebp),%eax
    14b8:	89 c2                	mov    %eax,%edx
    14ba:	89 d0                	mov    %edx,%eax
    14bc:	01 c0                	add    %eax,%eax
    14be:	01 c2                	add    %eax,%edx
    14c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    14c3:	01 d0                	add    %edx,%eax
    14c5:	83 ec 04             	sub    $0x4,%esp
    14c8:	ff 75 ec             	pushl  -0x14(%ebp)
    14cb:	50                   	push   %eax
    14cc:	ff 75 f0             	pushl  -0x10(%ebp)
    14cf:	e8 ca f1 ff ff       	call   69e <write>
    14d4:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    14d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    14da:	99                   	cltd   
    14db:	c1 ea 1e             	shr    $0x1e,%edx
    14de:	01 d0                	add    %edx,%eax
    14e0:	83 e0 03             	and    $0x3,%eax
    14e3:	29 d0                	sub    %edx,%eax
    14e5:	85 c0                	test   %eax,%eax
    14e7:	7e 2a                	jle    1513 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    14e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    14ec:	99                   	cltd   
    14ed:	c1 ea 1e             	shr    $0x1e,%edx
    14f0:	01 d0                	add    %edx,%eax
    14f2:	83 e0 03             	and    $0x3,%eax
    14f5:	29 d0                	sub    %edx,%eax
    14f7:	ba 04 00 00 00       	mov    $0x4,%edx
    14fc:	29 c2                	sub    %eax,%edx
    14fe:	89 d0                	mov    %edx,%eax
    1500:	83 ec 04             	sub    $0x4,%esp
    1503:	50                   	push   %eax
    1504:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1507:	50                   	push   %eax
    1508:	ff 75 f0             	pushl  -0x10(%ebp)
    150b:	e8 8e f1 ff ff       	call   69e <write>
    1510:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    1513:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1517:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    151b:	79 94                	jns    14b1 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    151d:	83 ec 0c             	sub    $0xc,%esp
    1520:	ff 75 f0             	pushl  -0x10(%ebp)
    1523:	e8 7e f1 ff ff       	call   6a6 <close>
    1528:	83 c4 10             	add    $0x10,%esp
    return 0;
    152b:	b8 00 00 00 00       	mov    $0x0,%eax
    1530:	c9                   	leave  
    1531:	c3                   	ret    

00001532 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    1532:	55                   	push   %ebp
    1533:	89 e5                	mov    %esp,%ebp
    1535:	57                   	push   %edi
    1536:	56                   	push   %esi
    1537:	53                   	push   %ebx
    1538:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    153b:	8b 45 08             	mov    0x8(%ebp),%eax
    153e:	8b 50 10             	mov    0x10(%eax),%edx
    1541:	8b 40 0c             	mov    0xc(%eax),%eax
    1544:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1547:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    154a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    154d:	8b 55 e0             	mov    -0x20(%ebp),%edx
    1550:	83 c2 1e             	add    $0x1e,%edx
    1553:	0f af d0             	imul   %eax,%edx
    1556:	89 d0                	mov    %edx,%eax
    1558:	01 c0                	add    %eax,%eax
    155a:	01 d0                	add    %edx,%eax
    155c:	83 ec 0c             	sub    $0xc,%esp
    155f:	50                   	push   %eax
    1560:	e8 93 f5 ff ff       	call   af8 <malloc>
    1565:	83 c4 10             	add    $0x10,%esp
    1568:	89 c2                	mov    %eax,%edx
    156a:	8b 45 08             	mov    0x8(%ebp),%eax
    156d:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    1570:	8b 45 08             	mov    0x8(%ebp),%eax
    1573:	8b 40 1c             	mov    0x1c(%eax),%eax
    1576:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1579:	6b d2 5a             	imul   $0x5a,%edx,%edx
    157c:	01 c2                	add    %eax,%edx
    157e:	8b 45 08             	mov    0x8(%ebp),%eax
    1581:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    1584:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1587:	8b 45 e0             	mov    -0x20(%ebp),%eax
    158a:	0f af d0             	imul   %eax,%edx
    158d:	89 d0                	mov    %edx,%eax
    158f:	01 c0                	add    %eax,%eax
    1591:	01 d0                	add    %edx,%eax
    1593:	89 c2                	mov    %eax,%edx
    1595:	8b 45 08             	mov    0x8(%ebp),%eax
    1598:	8b 40 18             	mov    0x18(%eax),%eax
    159b:	83 ec 04             	sub    $0x4,%esp
    159e:	52                   	push   %edx
    159f:	68 ff 00 00 00       	push   $0xff
    15a4:	50                   	push   %eax
    15a5:	e8 39 ef ff ff       	call   4e3 <memset>
    15aa:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    15ad:	8b 45 08             	mov    0x8(%ebp),%eax
    15b0:	8b 78 1c             	mov    0x1c(%eax),%edi
    15b3:	8b 45 08             	mov    0x8(%ebp),%eax
    15b6:	8b 70 14             	mov    0x14(%eax),%esi
    15b9:	8b 45 08             	mov    0x8(%ebp),%eax
    15bc:	8b 58 0c             	mov    0xc(%eax),%ebx
    15bf:	8b 45 08             	mov    0x8(%ebp),%eax
    15c2:	8b 48 10             	mov    0x10(%eax),%ecx
    15c5:	8b 45 08             	mov    0x8(%ebp),%eax
    15c8:	8b 50 08             	mov    0x8(%eax),%edx
    15cb:	8b 45 08             	mov    0x8(%ebp),%eax
    15ce:	8b 40 04             	mov    0x4(%eax),%eax
    15d1:	83 ec 08             	sub    $0x8,%esp
    15d4:	57                   	push   %edi
    15d5:	56                   	push   %esi
    15d6:	53                   	push   %ebx
    15d7:	51                   	push   %ecx
    15d8:	52                   	push   %edx
    15d9:	50                   	push   %eax
    15da:	e8 3f f1 ff ff       	call   71e <createwindow>
    15df:	83 c4 20             	add    $0x20,%esp
    15e2:	89 c2                	mov    %eax,%edx
    15e4:	8b 45 08             	mov    0x8(%ebp),%eax
    15e7:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    15e9:	8b 45 08             	mov    0x8(%ebp),%eax
    15ec:	8b 00                	mov    (%eax),%eax
}
    15ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
    15f1:	5b                   	pop    %ebx
    15f2:	5e                   	pop    %esi
    15f3:	5f                   	pop    %edi
    15f4:	5d                   	pop    %ebp
    15f5:	c3                   	ret    

000015f6 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    15f6:	55                   	push   %ebp
    15f7:	89 e5                	mov    %esp,%ebp
    15f9:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    15fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1603:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    160a:	8b 45 08             	mov    0x8(%ebp),%eax
    160d:	8b 40 18             	mov    0x18(%eax),%eax
    1610:	ff 75 1c             	pushl  0x1c(%ebp)
    1613:	ff 75 18             	pushl  0x18(%ebp)
    1616:	ff 75 1c             	pushl  0x1c(%ebp)
    1619:	ff 75 18             	pushl  0x18(%ebp)
    161c:	8b 55 08             	mov    0x8(%ebp),%edx
    161f:	ff 72 10             	pushl  0x10(%edx)
    1622:	ff 72 0c             	pushl  0xc(%edx)
    1625:	ff 75 f4             	pushl  -0xc(%ebp)
    1628:	ff 75 f0             	pushl  -0x10(%ebp)
    162b:	ff 75 14             	pushl  0x14(%ebp)
    162e:	ff 75 10             	pushl  0x10(%ebp)
    1631:	ff 75 0c             	pushl  0xc(%ebp)
    1634:	50                   	push   %eax
    1635:	e8 d5 07 00 00       	call   1e0f <drawBitmap>
    163a:	83 c4 30             	add    $0x30,%esp
    return 0;
    163d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1642:	c9                   	leave  
    1643:	c3                   	ret    

00001644 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1644:	55                   	push   %ebp
    1645:	89 e5                	mov    %esp,%ebp
    1647:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    164a:	8b 45 08             	mov    0x8(%ebp),%eax
    164d:	8b 40 18             	mov    0x18(%eax),%eax
    1650:	ff 75 2c             	pushl  0x2c(%ebp)
    1653:	ff 75 28             	pushl  0x28(%ebp)
    1656:	ff 75 24             	pushl  0x24(%ebp)
    1659:	ff 75 20             	pushl  0x20(%ebp)
    165c:	8b 55 08             	mov    0x8(%ebp),%edx
    165f:	ff 72 10             	pushl  0x10(%edx)
    1662:	ff 72 0c             	pushl  0xc(%edx)
    1665:	ff 75 1c             	pushl  0x1c(%ebp)
    1668:	ff 75 18             	pushl  0x18(%ebp)
    166b:	ff 75 14             	pushl  0x14(%ebp)
    166e:	ff 75 10             	pushl  0x10(%ebp)
    1671:	ff 75 0c             	pushl  0xc(%ebp)
    1674:	50                   	push   %eax
    1675:	e8 95 07 00 00       	call   1e0f <drawBitmap>
    167a:	83 c4 30             	add    $0x30,%esp
    return 0;
    167d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1682:	c9                   	leave  
    1683:	c3                   	ret    

00001684 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1684:	55                   	push   %ebp
    1685:	89 e5                	mov    %esp,%ebp
    1687:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    168a:	8b 45 08             	mov    0x8(%ebp),%eax
    168d:	8b 40 18             	mov    0x18(%eax),%eax
    1690:	ff 75 2c             	pushl  0x2c(%ebp)
    1693:	ff 75 28             	pushl  0x28(%ebp)
    1696:	ff 75 24             	pushl  0x24(%ebp)
    1699:	ff 75 20             	pushl  0x20(%ebp)
    169c:	8b 55 08             	mov    0x8(%ebp),%edx
    169f:	ff 72 10             	pushl  0x10(%edx)
    16a2:	ff 72 0c             	pushl  0xc(%edx)
    16a5:	ff 75 1c             	pushl  0x1c(%ebp)
    16a8:	ff 75 18             	pushl  0x18(%ebp)
    16ab:	ff 75 14             	pushl  0x14(%ebp)
    16ae:	ff 75 10             	pushl  0x10(%ebp)
    16b1:	ff 75 0c             	pushl  0xc(%ebp)
    16b4:	50                   	push   %eax
    16b5:	e8 75 08 00 00       	call   1f2f <drawTransparentBitmap>
    16ba:	83 c4 30             	add    $0x30,%esp
    return 0;
    16bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    16c2:	c9                   	leave  
    16c3:	c3                   	ret    

000016c4 <api_repaint>:

int api_repaint(Window* wnd)
{
    16c4:	55                   	push   %ebp
    16c5:	89 e5                	mov    %esp,%ebp
    16c7:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    16ca:	8b 45 08             	mov    0x8(%ebp),%eax
    16cd:	8b 00                	mov    (%eax),%eax
    16cf:	83 ec 0c             	sub    $0xc,%esp
    16d2:	50                   	push   %eax
    16d3:	e8 4e f0 ff ff       	call   726 <repaintwindow>
    16d8:	83 c4 10             	add    $0x10,%esp
    return 0;
    16db:	b8 00 00 00 00       	mov    $0x0,%eax
}
    16e0:	c9                   	leave  
    16e1:	c3                   	ret    

000016e2 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    16e2:	55                   	push   %ebp
    16e3:	89 e5                	mov    %esp,%ebp
    16e5:	56                   	push   %esi
    16e6:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    16e7:	8b 75 18             	mov    0x18(%ebp),%esi
    16ea:	8b 5d 14             	mov    0x14(%ebp),%ebx
    16ed:	8b 4d 10             	mov    0x10(%ebp),%ecx
    16f0:	8b 55 0c             	mov    0xc(%ebp),%edx
    16f3:	8b 45 08             	mov    0x8(%ebp),%eax
    16f6:	8b 00                	mov    (%eax),%eax
    16f8:	83 ec 0c             	sub    $0xc,%esp
    16fb:	56                   	push   %esi
    16fc:	53                   	push   %ebx
    16fd:	51                   	push   %ecx
    16fe:	52                   	push   %edx
    16ff:	50                   	push   %eax
    1700:	e8 39 f0 ff ff       	call   73e <updatewindow>
    1705:	83 c4 20             	add    $0x20,%esp
    return 0;
    1708:	b8 00 00 00 00       	mov    $0x0,%eax
}
    170d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    1710:	5b                   	pop    %ebx
    1711:	5e                   	pop    %esi
    1712:	5d                   	pop    %ebp
    1713:	c3                   	ret    

00001714 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    1714:	55                   	push   %ebp
    1715:	89 e5                	mov    %esp,%ebp
    1717:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    171a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    1721:	8b 45 08             	mov    0x8(%ebp),%eax
    1724:	8b 00                	mov    (%eax),%eax
    1726:	83 ec 08             	sub    $0x8,%esp
    1729:	8d 55 c8             	lea    -0x38(%ebp),%edx
    172c:	52                   	push   %edx
    172d:	50                   	push   %eax
    172e:	e8 fb ef ff ff       	call   72e <getmessage>
    1733:	83 c4 10             	add    $0x10,%esp
    1736:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1739:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    173d:	74 e2                	je     1721 <api_exec+0xd>
        {
            pf(&msg);
    173f:	83 ec 0c             	sub    $0xc,%esp
    1742:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1745:	50                   	push   %eax
    1746:	8b 45 0c             	mov    0xc(%ebp),%eax
    1749:	ff d0                	call   *%eax
    174b:	83 c4 10             	add    $0x10,%esp
        }
    }
    174e:	eb d1                	jmp    1721 <api_exec+0xd>

00001750 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    1750:	55                   	push   %ebp
    1751:	89 e5                	mov    %esp,%ebp
    1753:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1756:	8b 45 08             	mov    0x8(%ebp),%eax
    1759:	8b 00                	mov    (%eax),%eax
    175b:	83 ec 08             	sub    $0x8,%esp
    175e:	ff 75 0c             	pushl  0xc(%ebp)
    1761:	50                   	push   %eax
    1762:	e8 cf ef ff ff       	call   736 <settimer>
    1767:	83 c4 10             	add    $0x10,%esp
    return 0;
    176a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    176f:	c9                   	leave  
    1770:	c3                   	ret    

00001771 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    1771:	55                   	push   %ebp
    1772:	89 e5                	mov    %esp,%ebp
    1774:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    1777:	8b 45 08             	mov    0x8(%ebp),%eax
    177a:	8b 50 18             	mov    0x18(%eax),%edx
    177d:	ff 75 18             	pushl  0x18(%ebp)
    1780:	ff 75 14             	pushl  0x14(%ebp)
    1783:	83 ec 04             	sub    $0x4,%esp
    1786:	89 e0                	mov    %esp,%eax
    1788:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    178c:	66 89 08             	mov    %cx,(%eax)
    178f:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    1793:	88 48 02             	mov    %cl,0x2(%eax)
    1796:	8b 45 08             	mov    0x8(%ebp),%eax
    1799:	ff 70 10             	pushl  0x10(%eax)
    179c:	ff 70 0c             	pushl  0xc(%eax)
    179f:	ff 75 10             	pushl  0x10(%ebp)
    17a2:	ff 75 0c             	pushl  0xc(%ebp)
    17a5:	52                   	push   %edx
    17a6:	e8 6f 04 00 00       	call   1c1a <drawRect>
    17ab:	83 c4 20             	add    $0x20,%esp
    return 0;
    17ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
    17b3:	c9                   	leave  
    17b4:	c3                   	ret    

000017b5 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    17b5:	55                   	push   %ebp
    17b6:	89 e5                	mov    %esp,%ebp
    17b8:	83 ec 28             	sub    $0x28,%esp
    17bb:	8b 45 14             	mov    0x14(%ebp),%eax
    17be:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    17c1:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    17c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    17c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    17cb:	8b 45 10             	mov    0x10(%ebp),%eax
    17ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
    17d1:	8b 45 08             	mov    0x8(%ebp),%eax
    17d4:	8b 40 18             	mov    0x18(%eax),%eax
    17d7:	83 ec 04             	sub    $0x4,%esp
    17da:	ff 75 18             	pushl  0x18(%ebp)
    17dd:	52                   	push   %edx
    17de:	8b 55 08             	mov    0x8(%ebp),%edx
    17e1:	ff 72 10             	pushl  0x10(%edx)
    17e4:	ff 72 0c             	pushl  0xc(%edx)
    17e7:	ff 75 f4             	pushl  -0xc(%ebp)
    17ea:	ff 75 f0             	pushl  -0x10(%ebp)
    17ed:	50                   	push   %eax
    17ee:	e8 d4 02 00 00       	call   1ac7 <drawCharacter>
    17f3:	83 c4 20             	add    $0x20,%esp
    return 0;
    17f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    17fb:	c9                   	leave  
    17fc:	c3                   	ret    

000017fd <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    17fd:	55                   	push   %ebp
    17fe:	89 e5                	mov    %esp,%ebp
    1800:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1803:	8b 45 0c             	mov    0xc(%ebp),%eax
    1806:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1809:	8b 45 10             	mov    0x10(%ebp),%eax
    180c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    180f:	8b 45 08             	mov    0x8(%ebp),%eax
    1812:	8b 40 18             	mov    0x18(%eax),%eax
    1815:	83 ec 04             	sub    $0x4,%esp
    1818:	ff 75 18             	pushl  0x18(%ebp)
    181b:	ff 75 14             	pushl  0x14(%ebp)
    181e:	8b 55 08             	mov    0x8(%ebp),%edx
    1821:	ff 72 10             	pushl  0x10(%edx)
    1824:	ff 72 0c             	pushl  0xc(%edx)
    1827:	ff 75 f4             	pushl  -0xc(%ebp)
    182a:	ff 75 f0             	pushl  -0x10(%ebp)
    182d:	50                   	push   %eax
    182e:	e8 8e 03 00 00       	call   1bc1 <drawString>
    1833:	83 c4 20             	add    $0x20,%esp
    return 0;
    1836:	b8 00 00 00 00       	mov    $0x0,%eax
}
    183b:	c9                   	leave  
    183c:	c3                   	ret    

0000183d <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    183d:	55                   	push   %ebp
    183e:	89 e5                	mov    %esp,%ebp
    1840:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    1843:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1847:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    184b:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    184f:	83 ec 08             	sub    $0x8,%esp
    1852:	83 ec 04             	sub    $0x4,%esp
    1855:	89 e0                	mov    %esp,%eax
    1857:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    185b:	66 89 10             	mov    %dx,(%eax)
    185e:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    1862:	88 50 02             	mov    %dl,0x2(%eax)
    1865:	ff 75 18             	pushl  0x18(%ebp)
    1868:	ff 75 14             	pushl  0x14(%ebp)
    186b:	ff 75 10             	pushl  0x10(%ebp)
    186e:	ff 75 0c             	pushl  0xc(%ebp)
    1871:	ff 75 08             	pushl  0x8(%ebp)
    1874:	e8 f8 fe ff ff       	call   1771 <api_drawRect>
    1879:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    187c:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    1880:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    1884:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    1888:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    188c:	8b 45 10             	mov    0x10(%ebp),%eax
    188f:	8d 50 0a             	lea    0xa(%eax),%edx
    1892:	8b 45 0c             	mov    0xc(%ebp),%eax
    1895:	83 c0 0a             	add    $0xa,%eax
    1898:	83 ec 0c             	sub    $0xc,%esp
    189b:	ff 75 f4             	pushl  -0xc(%ebp)
    189e:	ff 75 1c             	pushl  0x1c(%ebp)
    18a1:	52                   	push   %edx
    18a2:	50                   	push   %eax
    18a3:	ff 75 08             	pushl  0x8(%ebp)
    18a6:	e8 52 ff ff ff       	call   17fd <api_drawString>
    18ab:	83 c4 20             	add    $0x20,%esp
    return 0;
    18ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
    18b3:	c9                   	leave  
    18b4:	c3                   	ret    

000018b5 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    18b5:	55                   	push   %ebp
    18b6:	89 e5                	mov    %esp,%ebp
    18b8:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    18bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    18c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    18c9:	8b 45 08             	mov    0x8(%ebp),%eax
    18cc:	8b 40 18             	mov    0x18(%eax),%eax
    18cf:	ff 75 1c             	pushl  0x1c(%ebp)
    18d2:	ff 75 18             	pushl  0x18(%ebp)
    18d5:	ff 75 1c             	pushl  0x1c(%ebp)
    18d8:	ff 75 18             	pushl  0x18(%ebp)
    18db:	8b 55 08             	mov    0x8(%ebp),%edx
    18de:	ff 72 10             	pushl  0x10(%edx)
    18e1:	ff 72 0c             	pushl  0xc(%edx)
    18e4:	ff 75 f4             	pushl  -0xc(%ebp)
    18e7:	ff 75 f0             	pushl  -0x10(%ebp)
    18ea:	ff 75 14             	pushl  0x14(%ebp)
    18ed:	ff 75 10             	pushl  0x10(%ebp)
    18f0:	ff 75 0c             	pushl  0xc(%ebp)
    18f3:	50                   	push   %eax
    18f4:	e8 16 05 00 00       	call   1e0f <drawBitmap>
    18f9:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    18fc:	8b 45 08             	mov    0x8(%ebp),%eax
    18ff:	8b 40 18             	mov    0x18(%eax),%eax
    1902:	ff 75 28             	pushl  0x28(%ebp)
    1905:	ff 75 1c             	pushl  0x1c(%ebp)
    1908:	ff 75 18             	pushl  0x18(%ebp)
    190b:	8b 55 08             	mov    0x8(%ebp),%edx
    190e:	ff 72 10             	pushl  0x10(%edx)
    1911:	ff 72 0c             	pushl  0xc(%edx)
    1914:	ff 75 14             	pushl  0x14(%ebp)
    1917:	ff 75 10             	pushl  0x10(%ebp)
    191a:	50                   	push   %eax
    191b:	e8 99 07 00 00       	call   20b9 <colorShift>
    1920:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    1923:	8b 45 08             	mov    0x8(%ebp),%eax
    1926:	8b 50 18             	mov    0x18(%eax),%edx
    1929:	83 ec 0c             	sub    $0xc,%esp
    192c:	ff 75 20             	pushl  0x20(%ebp)
    192f:	ff 75 1c             	pushl  0x1c(%ebp)
    1932:	ff 75 18             	pushl  0x18(%ebp)
    1935:	83 ec 04             	sub    $0x4,%esp
    1938:	89 e0                	mov    %esp,%eax
    193a:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    193e:	66 89 08             	mov    %cx,(%eax)
    1941:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1945:	88 48 02             	mov    %cl,0x2(%eax)
    1948:	8b 45 08             	mov    0x8(%ebp),%eax
    194b:	ff 70 10             	pushl  0x10(%eax)
    194e:	ff 70 0c             	pushl  0xc(%eax)
    1951:	ff 75 14             	pushl  0x14(%ebp)
    1954:	ff 75 10             	pushl  0x10(%ebp)
    1957:	52                   	push   %edx
    1958:	e8 6d 03 00 00       	call   1cca <drawBorder>
    195d:	83 c4 30             	add    $0x30,%esp
    return 0;
    1960:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1965:	c9                   	leave  
    1966:	c3                   	ret    

00001967 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    1967:	55                   	push   %ebp
    1968:	89 e5                	mov    %esp,%ebp
    196a:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    196d:	8b 45 08             	mov    0x8(%ebp),%eax
    1970:	8b 00                	mov    (%eax),%eax
    1972:	83 ec 0c             	sub    $0xc,%esp
    1975:	50                   	push   %eax
    1976:	e8 cb ed ff ff       	call   746 <destroywindow>
    197b:	83 c4 10             	add    $0x10,%esp
    return 0;
    197e:	b8 00 00 00 00       	mov    $0x0,%eax
    1983:	c9                   	leave  
    1984:	c3                   	ret    

00001985 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    1985:	55                   	push   %ebp
    1986:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    1988:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    198c:	8b 45 08             	mov    0x8(%ebp),%eax
    198f:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    1992:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1996:	8b 45 08             	mov    0x8(%ebp),%eax
    1999:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    199c:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    19a0:	8b 45 08             	mov    0x8(%ebp),%eax
    19a3:	88 10                	mov    %dl,(%eax)
}
    19a5:	90                   	nop
    19a6:	5d                   	pop    %ebp
    19a7:	c3                   	ret    

000019a8 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    19a8:	55                   	push   %ebp
    19a9:	89 e5                	mov    %esp,%ebp
    19ab:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    19ae:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    19b2:	3c ff                	cmp    $0xff,%al
    19b4:	75 22                	jne    19d8 <drawPointAlpha+0x30>
        color->R = origin.R;
    19b6:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    19ba:	8b 45 08             	mov    0x8(%ebp),%eax
    19bd:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    19c0:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    19c4:	8b 45 08             	mov    0x8(%ebp),%eax
    19c7:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    19ca:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    19ce:	8b 45 08             	mov    0x8(%ebp),%eax
    19d1:	88 10                	mov    %dl,(%eax)
        return;
    19d3:	e9 ed 00 00 00       	jmp    1ac5 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    19d8:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    19dc:	84 c0                	test   %al,%al
    19de:	0f 84 e0 00 00 00    	je     1ac4 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    19e4:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    19e8:	0f b6 c0             	movzbl %al,%eax
    19eb:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    19ef:	df 45 e4             	fild   -0x1c(%ebp)
    19f2:	d9 05 e0 a0 01 00    	flds   0x1a0e0
    19f8:	de f9                	fdivrp %st,%st(1)
    19fa:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    19fd:	8b 45 08             	mov    0x8(%ebp),%eax
    1a00:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1a04:	0f b6 c0             	movzbl %al,%eax
    1a07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1a0a:	db 45 e4             	fildl  -0x1c(%ebp)
    1a0d:	d9 e8                	fld1   
    1a0f:	d8 65 fc             	fsubs  -0x4(%ebp)
    1a12:	de c9                	fmulp  %st,%st(1)
    1a14:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1a18:	0f b6 c0             	movzbl %al,%eax
    1a1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1a1e:	db 45 e4             	fildl  -0x1c(%ebp)
    1a21:	d8 4d fc             	fmuls  -0x4(%ebp)
    1a24:	de c1                	faddp  %st,%st(1)
    1a26:	d9 7d ee             	fnstcw -0x12(%ebp)
    1a29:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1a2d:	b4 0c                	mov    $0xc,%ah
    1a2f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    1a33:	d9 6d ec             	fldcw  -0x14(%ebp)
    1a36:	df 5d ea             	fistp  -0x16(%ebp)
    1a39:	d9 6d ee             	fldcw  -0x12(%ebp)
    1a3c:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1a40:	89 c2                	mov    %eax,%edx
    1a42:	8b 45 08             	mov    0x8(%ebp),%eax
    1a45:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1a48:	8b 45 08             	mov    0x8(%ebp),%eax
    1a4b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1a4f:	0f b6 c0             	movzbl %al,%eax
    1a52:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1a55:	db 45 e4             	fildl  -0x1c(%ebp)
    1a58:	d9 e8                	fld1   
    1a5a:	d8 65 fc             	fsubs  -0x4(%ebp)
    1a5d:	de c9                	fmulp  %st,%st(1)
    1a5f:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    1a63:	0f b6 c0             	movzbl %al,%eax
    1a66:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1a69:	db 45 e4             	fildl  -0x1c(%ebp)
    1a6c:	d8 4d fc             	fmuls  -0x4(%ebp)
    1a6f:	de c1                	faddp  %st,%st(1)
    1a71:	d9 6d ec             	fldcw  -0x14(%ebp)
    1a74:	df 5d ea             	fistp  -0x16(%ebp)
    1a77:	d9 6d ee             	fldcw  -0x12(%ebp)
    1a7a:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1a7e:	89 c2                	mov    %eax,%edx
    1a80:	8b 45 08             	mov    0x8(%ebp),%eax
    1a83:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    1a86:	8b 45 08             	mov    0x8(%ebp),%eax
    1a89:	0f b6 00             	movzbl (%eax),%eax
    1a8c:	0f b6 c0             	movzbl %al,%eax
    1a8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1a92:	db 45 e4             	fildl  -0x1c(%ebp)
    1a95:	d9 e8                	fld1   
    1a97:	d8 65 fc             	fsubs  -0x4(%ebp)
    1a9a:	de c9                	fmulp  %st,%st(1)
    1a9c:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    1aa0:	0f b6 c0             	movzbl %al,%eax
    1aa3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1aa6:	db 45 e4             	fildl  -0x1c(%ebp)
    1aa9:	d8 4d fc             	fmuls  -0x4(%ebp)
    1aac:	de c1                	faddp  %st,%st(1)
    1aae:	d9 6d ec             	fldcw  -0x14(%ebp)
    1ab1:	df 5d ea             	fistp  -0x16(%ebp)
    1ab4:	d9 6d ee             	fldcw  -0x12(%ebp)
    1ab7:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1abb:	89 c2                	mov    %eax,%edx
    1abd:	8b 45 08             	mov    0x8(%ebp),%eax
    1ac0:	88 10                	mov    %dl,(%eax)
    1ac2:	eb 01                	jmp    1ac5 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    1ac4:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    1ac5:	c9                   	leave  
    1ac6:	c3                   	ret    

00001ac7 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    1ac7:	55                   	push   %ebp
    1ac8:	89 e5                	mov    %esp,%ebp
    1aca:	83 ec 14             	sub    $0x14,%esp
    1acd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1ad0:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    1ad3:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    1ad7:	83 e8 20             	sub    $0x20,%eax
    1ada:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    1add:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1ae1:	0f 88 d7 00 00 00    	js     1bbe <drawCharacter+0xf7>
    1ae7:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1aeb:	0f 8f cd 00 00 00    	jg     1bbe <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1af1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1af8:	e9 b5 00 00 00       	jmp    1bb2 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1afd:	8b 55 10             	mov    0x10(%ebp),%edx
    1b00:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1b03:	01 c2                	add    %eax,%edx
    1b05:	8b 45 14             	mov    0x14(%ebp),%eax
    1b08:	39 c2                	cmp    %eax,%edx
    1b0a:	0f 8f af 00 00 00    	jg     1bbf <drawCharacter+0xf8>
    1b10:	8b 55 10             	mov    0x10(%ebp),%edx
    1b13:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1b16:	01 d0                	add    %edx,%eax
    1b18:	85 c0                	test   %eax,%eax
    1b1a:	0f 88 9f 00 00 00    	js     1bbf <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1b20:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1b27:	eb 7b                	jmp    1ba4 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1b29:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1b2c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1b2f:	89 d0                	mov    %edx,%eax
    1b31:	c1 e0 03             	shl    $0x3,%eax
    1b34:	01 d0                	add    %edx,%eax
    1b36:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1b3c:	01 c2                	add    %eax,%edx
    1b3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1b41:	01 d0                	add    %edx,%eax
    1b43:	05 c0 64 01 00       	add    $0x164c0,%eax
    1b48:	0f b6 00             	movzbl (%eax),%eax
    1b4b:	3c 01                	cmp    $0x1,%al
    1b4d:	75 51                	jne    1ba0 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    1b4f:	8b 55 0c             	mov    0xc(%ebp),%edx
    1b52:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1b55:	01 c2                	add    %eax,%edx
    1b57:	8b 45 18             	mov    0x18(%ebp),%eax
    1b5a:	39 c2                	cmp    %eax,%edx
    1b5c:	7f 50                	jg     1bae <drawCharacter+0xe7>
    1b5e:	8b 55 0c             	mov    0xc(%ebp),%edx
    1b61:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1b64:	01 d0                	add    %edx,%eax
    1b66:	85 c0                	test   %eax,%eax
    1b68:	78 44                	js     1bae <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1b6a:	8b 55 10             	mov    0x10(%ebp),%edx
    1b6d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1b70:	01 c2                	add    %eax,%edx
    1b72:	8b 45 18             	mov    0x18(%ebp),%eax
    1b75:	0f af c2             	imul   %edx,%eax
    1b78:	89 c2                	mov    %eax,%edx
    1b7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b7d:	01 c2                	add    %eax,%edx
    1b7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1b82:	01 c2                	add    %eax,%edx
    1b84:	89 d0                	mov    %edx,%eax
    1b86:	01 c0                	add    %eax,%eax
    1b88:	01 c2                	add    %eax,%edx
    1b8a:	8b 45 08             	mov    0x8(%ebp),%eax
    1b8d:	01 d0                	add    %edx,%eax
    1b8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    1b92:	ff 75 20             	pushl  0x20(%ebp)
    1b95:	ff 75 f0             	pushl  -0x10(%ebp)
    1b98:	e8 0b fe ff ff       	call   19a8 <drawPointAlpha>
    1b9d:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1ba0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1ba4:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    1ba8:	0f 8e 7b ff ff ff    	jle    1b29 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1bae:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1bb2:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1bb6:	0f 8e 41 ff ff ff    	jle    1afd <drawCharacter+0x36>
    1bbc:	eb 01                	jmp    1bbf <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1bbe:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    1bbf:	c9                   	leave  
    1bc0:	c3                   	ret    

00001bc1 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    1bc1:	55                   	push   %ebp
    1bc2:	89 e5                	mov    %esp,%ebp
    1bc4:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1bc7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    1bce:	eb 3d                	jmp    1c0d <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    1bd0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bd3:	0f b6 00             	movzbl (%eax),%eax
    1bd6:	0f be c0             	movsbl %al,%eax
    1bd9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1bdc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1bdf:	01 ca                	add    %ecx,%edx
    1be1:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1be4:	8b 55 10             	mov    0x10(%ebp),%edx
    1be7:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1bea:	ff 75 20             	pushl  0x20(%ebp)
    1bed:	50                   	push   %eax
    1bee:	ff 75 18             	pushl  0x18(%ebp)
    1bf1:	ff 75 14             	pushl  0x14(%ebp)
    1bf4:	ff 75 f8             	pushl  -0x8(%ebp)
    1bf7:	ff 75 f4             	pushl  -0xc(%ebp)
    1bfa:	ff 75 08             	pushl  0x8(%ebp)
    1bfd:	e8 c5 fe ff ff       	call   1ac7 <drawCharacter>
    1c02:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1c05:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1c09:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1c0d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1c10:	0f b6 00             	movzbl (%eax),%eax
    1c13:	84 c0                	test   %al,%al
    1c15:	75 b9                	jne    1bd0 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1c17:	90                   	nop
    1c18:	c9                   	leave  
    1c19:	c3                   	ret    

00001c1a <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1c1a:	55                   	push   %ebp
    1c1b:	89 e5                	mov    %esp,%ebp
    1c1d:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1c20:	8b 45 20             	mov    0x20(%ebp),%eax
    1c23:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1c26:	8b 45 24             	mov    0x24(%ebp),%eax
    1c29:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1c2c:	8b 55 14             	mov    0x14(%ebp),%edx
    1c2f:	8b 45 10             	mov    0x10(%ebp),%eax
    1c32:	29 c2                	sub    %eax,%edx
    1c34:	89 d0                	mov    %edx,%eax
    1c36:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1c39:	7d 0d                	jge    1c48 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1c3b:	8b 55 14             	mov    0x14(%ebp),%edx
    1c3e:	8b 45 10             	mov    0x10(%ebp),%eax
    1c41:	29 c2                	sub    %eax,%edx
    1c43:	89 d0                	mov    %edx,%eax
    1c45:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1c48:	8b 55 18             	mov    0x18(%ebp),%edx
    1c4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c4e:	29 c2                	sub    %eax,%edx
    1c50:	89 d0                	mov    %edx,%eax
    1c52:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1c55:	7d 0d                	jge    1c64 <drawRect+0x4a>
        draw_w = s.w - p.x;
    1c57:	8b 55 18             	mov    0x18(%ebp),%edx
    1c5a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c5d:	29 c2                	sub    %eax,%edx
    1c5f:	89 d0                	mov    %edx,%eax
    1c61:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1c64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1c6b:	eb 52                	jmp    1cbf <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1c6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1c74:	eb 3d                	jmp    1cb3 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    1c76:	8b 55 10             	mov    0x10(%ebp),%edx
    1c79:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c7c:	01 c2                	add    %eax,%edx
    1c7e:	8b 45 18             	mov    0x18(%ebp),%eax
    1c81:	0f af c2             	imul   %edx,%eax
    1c84:	89 c2                	mov    %eax,%edx
    1c86:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c89:	01 c2                	add    %eax,%edx
    1c8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c8e:	01 c2                	add    %eax,%edx
    1c90:	89 d0                	mov    %edx,%eax
    1c92:	01 c0                	add    %eax,%eax
    1c94:	01 c2                	add    %eax,%edx
    1c96:	8b 45 08             	mov    0x8(%ebp),%eax
    1c99:	01 d0                	add    %edx,%eax
    1c9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    1c9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ca1:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1ca5:	66 89 10             	mov    %dx,(%eax)
    1ca8:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1cac:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1caf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1cb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1cb6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1cb9:	7c bb                	jl     1c76 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1cbb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1cbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1cc2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1cc5:	7c a6                	jl     1c6d <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1cc7:	90                   	nop
    1cc8:	c9                   	leave  
    1cc9:	c3                   	ret    

00001cca <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1cca:	55                   	push   %ebp
    1ccb:	89 e5                	mov    %esp,%ebp
    1ccd:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    1cd0:	8b 45 28             	mov    0x28(%ebp),%eax
    1cd3:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1cd6:	8b 45 24             	mov    0x24(%ebp),%eax
    1cd9:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1cdc:	ff 75 cc             	pushl  -0x34(%ebp)
    1cdf:	ff 75 c8             	pushl  -0x38(%ebp)
    1ce2:	83 ec 04             	sub    $0x4,%esp
    1ce5:	89 e0                	mov    %esp,%eax
    1ce7:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1ceb:	66 89 10             	mov    %dx,(%eax)
    1cee:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1cf2:	88 50 02             	mov    %dl,0x2(%eax)
    1cf5:	ff 75 18             	pushl  0x18(%ebp)
    1cf8:	ff 75 14             	pushl  0x14(%ebp)
    1cfb:	ff 75 10             	pushl  0x10(%ebp)
    1cfe:	ff 75 0c             	pushl  0xc(%ebp)
    1d01:	ff 75 08             	pushl  0x8(%ebp)
    1d04:	e8 11 ff ff ff       	call   1c1a <drawRect>
    1d09:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1d0c:	8b 45 28             	mov    0x28(%ebp),%eax
    1d0f:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1d12:	8b 45 24             	mov    0x24(%ebp),%eax
    1d15:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1d18:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d1b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1d1e:	8b 55 10             	mov    0x10(%ebp),%edx
    1d21:	8b 45 20             	mov    0x20(%ebp),%eax
    1d24:	01 d0                	add    %edx,%eax
    1d26:	2b 45 28             	sub    0x28(%ebp),%eax
    1d29:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1d2c:	ff 75 d4             	pushl  -0x2c(%ebp)
    1d2f:	ff 75 d0             	pushl  -0x30(%ebp)
    1d32:	83 ec 04             	sub    $0x4,%esp
    1d35:	89 e0                	mov    %esp,%eax
    1d37:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1d3b:	66 89 10             	mov    %dx,(%eax)
    1d3e:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1d42:	88 50 02             	mov    %dl,0x2(%eax)
    1d45:	ff 75 18             	pushl  0x18(%ebp)
    1d48:	ff 75 14             	pushl  0x14(%ebp)
    1d4b:	ff 75 dc             	pushl  -0x24(%ebp)
    1d4e:	ff 75 d8             	pushl  -0x28(%ebp)
    1d51:	ff 75 08             	pushl  0x8(%ebp)
    1d54:	e8 c1 fe ff ff       	call   1c1a <drawRect>
    1d59:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1d5c:	8b 45 20             	mov    0x20(%ebp),%eax
    1d5f:	8b 55 28             	mov    0x28(%ebp),%edx
    1d62:	01 d2                	add    %edx,%edx
    1d64:	29 d0                	sub    %edx,%eax
    1d66:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1d69:	8b 45 28             	mov    0x28(%ebp),%eax
    1d6c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1d6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d72:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1d75:	8b 55 10             	mov    0x10(%ebp),%edx
    1d78:	8b 45 28             	mov    0x28(%ebp),%eax
    1d7b:	01 d0                	add    %edx,%eax
    1d7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1d80:	ff 75 e4             	pushl  -0x1c(%ebp)
    1d83:	ff 75 e0             	pushl  -0x20(%ebp)
    1d86:	83 ec 04             	sub    $0x4,%esp
    1d89:	89 e0                	mov    %esp,%eax
    1d8b:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1d8f:	66 89 10             	mov    %dx,(%eax)
    1d92:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1d96:	88 50 02             	mov    %dl,0x2(%eax)
    1d99:	ff 75 18             	pushl  0x18(%ebp)
    1d9c:	ff 75 14             	pushl  0x14(%ebp)
    1d9f:	ff 75 ec             	pushl  -0x14(%ebp)
    1da2:	ff 75 e8             	pushl  -0x18(%ebp)
    1da5:	ff 75 08             	pushl  0x8(%ebp)
    1da8:	e8 6d fe ff ff       	call   1c1a <drawRect>
    1dad:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1db0:	8b 45 20             	mov    0x20(%ebp),%eax
    1db3:	8b 55 28             	mov    0x28(%ebp),%edx
    1db6:	01 d2                	add    %edx,%edx
    1db8:	29 d0                	sub    %edx,%eax
    1dba:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1dbd:	8b 45 28             	mov    0x28(%ebp),%eax
    1dc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1dc3:	8b 55 0c             	mov    0xc(%ebp),%edx
    1dc6:	8b 45 24             	mov    0x24(%ebp),%eax
    1dc9:	01 d0                	add    %edx,%eax
    1dcb:	2b 45 28             	sub    0x28(%ebp),%eax
    1dce:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1dd1:	8b 55 10             	mov    0x10(%ebp),%edx
    1dd4:	8b 45 28             	mov    0x28(%ebp),%eax
    1dd7:	01 d0                	add    %edx,%eax
    1dd9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1ddc:	ff 75 f4             	pushl  -0xc(%ebp)
    1ddf:	ff 75 f0             	pushl  -0x10(%ebp)
    1de2:	83 ec 04             	sub    $0x4,%esp
    1de5:	89 e0                	mov    %esp,%eax
    1de7:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1deb:	66 89 10             	mov    %dx,(%eax)
    1dee:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1df2:	88 50 02             	mov    %dl,0x2(%eax)
    1df5:	ff 75 18             	pushl  0x18(%ebp)
    1df8:	ff 75 14             	pushl  0x14(%ebp)
    1dfb:	ff 75 fc             	pushl  -0x4(%ebp)
    1dfe:	ff 75 f8             	pushl  -0x8(%ebp)
    1e01:	ff 75 08             	pushl  0x8(%ebp)
    1e04:	e8 11 fe ff ff       	call   1c1a <drawRect>
    1e09:	83 c4 20             	add    $0x20,%esp
}
    1e0c:	90                   	nop
    1e0d:	c9                   	leave  
    1e0e:	c3                   	ret    

00001e0f <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1e0f:	55                   	push   %ebp
    1e10:	89 e5                	mov    %esp,%ebp
    1e12:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1e15:	8b 45 30             	mov    0x30(%ebp),%eax
    1e18:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1e1b:	8b 45 34             	mov    0x34(%ebp),%eax
    1e1e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1e21:	8b 55 20             	mov    0x20(%ebp),%edx
    1e24:	8b 45 14             	mov    0x14(%ebp),%eax
    1e27:	29 c2                	sub    %eax,%edx
    1e29:	89 d0                	mov    %edx,%eax
    1e2b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1e2e:	7d 0d                	jge    1e3d <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1e30:	8b 55 20             	mov    0x20(%ebp),%edx
    1e33:	8b 45 14             	mov    0x14(%ebp),%eax
    1e36:	29 c2                	sub    %eax,%edx
    1e38:	89 d0                	mov    %edx,%eax
    1e3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1e3d:	8b 55 28             	mov    0x28(%ebp),%edx
    1e40:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1e43:	29 c2                	sub    %eax,%edx
    1e45:	89 d0                	mov    %edx,%eax
    1e47:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1e4a:	7d 0d                	jge    1e59 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1e4c:	8b 55 28             	mov    0x28(%ebp),%edx
    1e4f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1e52:	29 c2                	sub    %eax,%edx
    1e54:	89 d0                	mov    %edx,%eax
    1e56:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1e59:	8b 55 24             	mov    0x24(%ebp),%edx
    1e5c:	8b 45 10             	mov    0x10(%ebp),%eax
    1e5f:	29 c2                	sub    %eax,%edx
    1e61:	89 d0                	mov    %edx,%eax
    1e63:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1e66:	7d 0d                	jge    1e75 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1e68:	8b 55 24             	mov    0x24(%ebp),%edx
    1e6b:	8b 45 10             	mov    0x10(%ebp),%eax
    1e6e:	29 c2                	sub    %eax,%edx
    1e70:	89 d0                	mov    %edx,%eax
    1e72:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1e75:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1e78:	8b 45 18             	mov    0x18(%ebp),%eax
    1e7b:	29 c2                	sub    %eax,%edx
    1e7d:	89 d0                	mov    %edx,%eax
    1e7f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1e82:	7d 0d                	jge    1e91 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1e84:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1e87:	8b 45 18             	mov    0x18(%ebp),%eax
    1e8a:	29 c2                	sub    %eax,%edx
    1e8c:	89 d0                	mov    %edx,%eax
    1e8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1e91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1e98:	e9 83 00 00 00       	jmp    1f20 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1e9d:	8b 55 14             	mov    0x14(%ebp),%edx
    1ea0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ea3:	01 d0                	add    %edx,%eax
    1ea5:	85 c0                	test   %eax,%eax
    1ea7:	78 72                	js     1f1b <drawBitmap+0x10c>
    1ea9:	8b 55 14             	mov    0x14(%ebp),%edx
    1eac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1eaf:	01 c2                	add    %eax,%edx
    1eb1:	8b 45 20             	mov    0x20(%ebp),%eax
    1eb4:	39 c2                	cmp    %eax,%edx
    1eb6:	7d 63                	jge    1f1b <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1eb8:	8b 55 14             	mov    0x14(%ebp),%edx
    1ebb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ebe:	01 c2                	add    %eax,%edx
    1ec0:	8b 45 24             	mov    0x24(%ebp),%eax
    1ec3:	0f af c2             	imul   %edx,%eax
    1ec6:	89 c2                	mov    %eax,%edx
    1ec8:	8b 45 10             	mov    0x10(%ebp),%eax
    1ecb:	01 c2                	add    %eax,%edx
    1ecd:	89 d0                	mov    %edx,%eax
    1ecf:	01 c0                	add    %eax,%eax
    1ed1:	01 c2                	add    %eax,%edx
    1ed3:	8b 45 08             	mov    0x8(%ebp),%eax
    1ed6:	01 d0                	add    %edx,%eax
    1ed8:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1edb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1ede:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ee1:	01 c2                	add    %eax,%edx
    1ee3:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1ee6:	0f af c2             	imul   %edx,%eax
    1ee9:	89 c2                	mov    %eax,%edx
    1eeb:	8b 45 18             	mov    0x18(%ebp),%eax
    1eee:	01 c2                	add    %eax,%edx
    1ef0:	89 d0                	mov    %edx,%eax
    1ef2:	01 c0                	add    %eax,%eax
    1ef4:	01 c2                	add    %eax,%edx
    1ef6:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ef9:	01 d0                	add    %edx,%eax
    1efb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1efe:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1f01:	89 d0                	mov    %edx,%eax
    1f03:	01 c0                	add    %eax,%eax
    1f05:	01 d0                	add    %edx,%eax
    1f07:	83 ec 04             	sub    $0x4,%esp
    1f0a:	50                   	push   %eax
    1f0b:	ff 75 e4             	pushl  -0x1c(%ebp)
    1f0e:	ff 75 e8             	pushl  -0x18(%ebp)
    1f11:	e8 23 e7 ff ff       	call   639 <memmove>
    1f16:	83 c4 10             	add    $0x10,%esp
    1f19:	eb 01                	jmp    1f1c <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1f1b:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1f1c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1f20:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f23:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1f26:	0f 8c 71 ff ff ff    	jl     1e9d <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1f2c:	90                   	nop
    1f2d:	c9                   	leave  
    1f2e:	c3                   	ret    

00001f2f <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1f2f:	55                   	push   %ebp
    1f30:	89 e5                	mov    %esp,%ebp
    1f32:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1f35:	8b 45 30             	mov    0x30(%ebp),%eax
    1f38:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1f3b:	8b 45 34             	mov    0x34(%ebp),%eax
    1f3e:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1f41:	8b 55 20             	mov    0x20(%ebp),%edx
    1f44:	8b 45 14             	mov    0x14(%ebp),%eax
    1f47:	29 c2                	sub    %eax,%edx
    1f49:	89 d0                	mov    %edx,%eax
    1f4b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1f4e:	7d 0d                	jge    1f5d <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1f50:	8b 55 20             	mov    0x20(%ebp),%edx
    1f53:	8b 45 14             	mov    0x14(%ebp),%eax
    1f56:	29 c2                	sub    %eax,%edx
    1f58:	89 d0                	mov    %edx,%eax
    1f5a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1f5d:	8b 55 28             	mov    0x28(%ebp),%edx
    1f60:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1f63:	29 c2                	sub    %eax,%edx
    1f65:	89 d0                	mov    %edx,%eax
    1f67:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1f6a:	7d 0d                	jge    1f79 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1f6c:	8b 55 28             	mov    0x28(%ebp),%edx
    1f6f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1f72:	29 c2                	sub    %eax,%edx
    1f74:	89 d0                	mov    %edx,%eax
    1f76:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1f79:	8b 55 24             	mov    0x24(%ebp),%edx
    1f7c:	8b 45 10             	mov    0x10(%ebp),%eax
    1f7f:	29 c2                	sub    %eax,%edx
    1f81:	89 d0                	mov    %edx,%eax
    1f83:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1f86:	7d 0d                	jge    1f95 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1f88:	8b 55 24             	mov    0x24(%ebp),%edx
    1f8b:	8b 45 10             	mov    0x10(%ebp),%eax
    1f8e:	29 c2                	sub    %eax,%edx
    1f90:	89 d0                	mov    %edx,%eax
    1f92:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1f95:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1f98:	8b 45 18             	mov    0x18(%ebp),%eax
    1f9b:	29 c2                	sub    %eax,%edx
    1f9d:	89 d0                	mov    %edx,%eax
    1f9f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1fa2:	7d 0d                	jge    1fb1 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1fa4:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1fa7:	8b 45 18             	mov    0x18(%ebp),%eax
    1faa:	29 c2                	sub    %eax,%edx
    1fac:	89 d0                	mov    %edx,%eax
    1fae:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1fb1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1fb8:	e9 b8 00 00 00       	jmp    2075 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1fbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1fc4:	e9 9c 00 00 00       	jmp    2065 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1fc9:	8b 55 14             	mov    0x14(%ebp),%edx
    1fcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1fcf:	01 c2                	add    %eax,%edx
    1fd1:	8b 45 24             	mov    0x24(%ebp),%eax
    1fd4:	0f af c2             	imul   %edx,%eax
    1fd7:	89 c2                	mov    %eax,%edx
    1fd9:	8b 45 10             	mov    0x10(%ebp),%eax
    1fdc:	01 c2                	add    %eax,%edx
    1fde:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1fe1:	01 c2                	add    %eax,%edx
    1fe3:	89 d0                	mov    %edx,%eax
    1fe5:	01 c0                	add    %eax,%eax
    1fe7:	01 c2                	add    %eax,%edx
    1fe9:	8b 45 08             	mov    0x8(%ebp),%eax
    1fec:	01 d0                	add    %edx,%eax
    1fee:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1ff1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1ff4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ff7:	01 c2                	add    %eax,%edx
    1ff9:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1ffc:	0f af c2             	imul   %edx,%eax
    1fff:	89 c2                	mov    %eax,%edx
    2001:	8b 45 18             	mov    0x18(%ebp),%eax
    2004:	01 c2                	add    %eax,%edx
    2006:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2009:	01 c2                	add    %eax,%edx
    200b:	89 d0                	mov    %edx,%eax
    200d:	01 c0                	add    %eax,%eax
    200f:	01 c2                	add    %eax,%edx
    2011:	8b 45 0c             	mov    0xc(%ebp),%eax
    2014:	01 d0                	add    %edx,%eax
    2016:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    2019:	8b 45 e8             	mov    -0x18(%ebp),%eax
    201c:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2020:	3c ff                	cmp    $0xff,%al
    2022:	75 15                	jne    2039 <drawTransparentBitmap+0x10a>
    2024:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2027:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    202b:	3c ff                	cmp    $0xff,%al
    202d:	75 0a                	jne    2039 <drawTransparentBitmap+0x10a>
    202f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2032:	0f b6 00             	movzbl (%eax),%eax
    2035:	3c ff                	cmp    $0xff,%al
    2037:	74 27                	je     2060 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    2039:	8b 45 e8             	mov    -0x18(%ebp),%eax
    203c:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2040:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2043:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    2046:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2049:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    204d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2050:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    2053:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2056:	0f b6 10             	movzbl (%eax),%edx
    2059:	8b 45 ec             	mov    -0x14(%ebp),%eax
    205c:	88 10                	mov    %dl,(%eax)
    205e:	eb 01                	jmp    2061 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    2060:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    2061:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2065:	8b 45 34             	mov    0x34(%ebp),%eax
    2068:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    206b:	0f 8f 58 ff ff ff    	jg     1fc9 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    2071:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2075:	8b 45 30             	mov    0x30(%ebp),%eax
    2078:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    207b:	0f 8f 3c ff ff ff    	jg     1fbd <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    2081:	90                   	nop
    2082:	c9                   	leave  
    2083:	c3                   	ret    

00002084 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    2084:	55                   	push   %ebp
    2085:	89 e5                	mov    %esp,%ebp
    2087:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    208a:	ff 75 24             	pushl  0x24(%ebp)
    208d:	ff 75 20             	pushl  0x20(%ebp)
    2090:	ff 75 1c             	pushl  0x1c(%ebp)
    2093:	ff 75 18             	pushl  0x18(%ebp)
    2096:	ff 75 1c             	pushl  0x1c(%ebp)
    2099:	ff 75 18             	pushl  0x18(%ebp)
    209c:	ff 75 14             	pushl  0x14(%ebp)
    209f:	ff 75 10             	pushl  0x10(%ebp)
    20a2:	ff 75 14             	pushl  0x14(%ebp)
    20a5:	ff 75 10             	pushl  0x10(%ebp)
    20a8:	ff 75 0c             	pushl  0xc(%ebp)
    20ab:	ff 75 08             	pushl  0x8(%ebp)
    20ae:	e8 5c fd ff ff       	call   1e0f <drawBitmap>
    20b3:	83 c4 30             	add    $0x30,%esp
}
    20b6:	90                   	nop
    20b7:	c9                   	leave  
    20b8:	c3                   	ret    

000020b9 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    20b9:	55                   	push   %ebp
    20ba:	89 e5                	mov    %esp,%ebp
    20bc:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    20bf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    20c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    20c5:	8b 45 20             	mov    0x20(%ebp),%eax
    20c8:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    20cb:	8b 55 14             	mov    0x14(%ebp),%edx
    20ce:	8b 45 10             	mov    0x10(%ebp),%eax
    20d1:	29 c2                	sub    %eax,%edx
    20d3:	89 d0                	mov    %edx,%eax
    20d5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    20d8:	7d 0d                	jge    20e7 <colorShift+0x2e>
        draw_h = s.h - p.y;
    20da:	8b 55 14             	mov    0x14(%ebp),%edx
    20dd:	8b 45 10             	mov    0x10(%ebp),%eax
    20e0:	29 c2                	sub    %eax,%edx
    20e2:	89 d0                	mov    %edx,%eax
    20e4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    20e7:	8b 55 18             	mov    0x18(%ebp),%edx
    20ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    20ed:	29 c2                	sub    %eax,%edx
    20ef:	89 d0                	mov    %edx,%eax
    20f1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    20f4:	7d 0d                	jge    2103 <colorShift+0x4a>
        draw_w = s.w - p.x;
    20f6:	8b 55 18             	mov    0x18(%ebp),%edx
    20f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    20fc:	29 c2                	sub    %eax,%edx
    20fe:	89 d0                	mov    %edx,%eax
    2100:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2103:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    210a:	e9 fc 00 00 00       	jmp    220b <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    210f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2116:	e9 e0 00 00 00       	jmp    21fb <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    211b:	8b 55 10             	mov    0x10(%ebp),%edx
    211e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2121:	01 c2                	add    %eax,%edx
    2123:	8b 45 18             	mov    0x18(%ebp),%eax
    2126:	0f af c2             	imul   %edx,%eax
    2129:	89 c2                	mov    %eax,%edx
    212b:	8b 45 0c             	mov    0xc(%ebp),%eax
    212e:	01 c2                	add    %eax,%edx
    2130:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2133:	01 c2                	add    %eax,%edx
    2135:	89 d0                	mov    %edx,%eax
    2137:	01 c0                	add    %eax,%eax
    2139:	01 c2                	add    %eax,%edx
    213b:	8b 45 08             	mov    0x8(%ebp),%eax
    213e:	01 d0                	add    %edx,%eax
    2140:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    2143:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2146:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    214a:	3c c8                	cmp    $0xc8,%al
    214c:	0f 86 a5 00 00 00    	jbe    21f7 <colorShift+0x13e>
    2152:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2155:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2159:	3c c8                	cmp    $0xc8,%al
    215b:	0f 86 96 00 00 00    	jbe    21f7 <colorShift+0x13e>
    2161:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2164:	0f b6 00             	movzbl (%eax),%eax
    2167:	3c c8                	cmp    $0xc8,%al
    2169:	0f 86 88 00 00 00    	jbe    21f7 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    216f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2172:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2176:	0f b6 d0             	movzbl %al,%edx
    2179:	8b 45 24             	mov    0x24(%ebp),%eax
    217c:	01 d0                	add    %edx,%eax
    217e:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2184:	89 d0                	mov    %edx,%eax
    2186:	c1 f8 1f             	sar    $0x1f,%eax
    2189:	c1 e8 18             	shr    $0x18,%eax
    218c:	01 c2                	add    %eax,%edx
    218e:	0f b6 d2             	movzbl %dl,%edx
    2191:	29 c2                	sub    %eax,%edx
    2193:	89 d0                	mov    %edx,%eax
    2195:	89 c2                	mov    %eax,%edx
    2197:	8b 45 ec             	mov    -0x14(%ebp),%eax
    219a:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    219d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    21a0:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21a4:	0f b6 d0             	movzbl %al,%edx
    21a7:	8b 45 24             	mov    0x24(%ebp),%eax
    21aa:	01 d0                	add    %edx,%eax
    21ac:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    21b2:	89 d0                	mov    %edx,%eax
    21b4:	c1 f8 1f             	sar    $0x1f,%eax
    21b7:	c1 e8 18             	shr    $0x18,%eax
    21ba:	01 c2                	add    %eax,%edx
    21bc:	0f b6 d2             	movzbl %dl,%edx
    21bf:	29 c2                	sub    %eax,%edx
    21c1:	89 d0                	mov    %edx,%eax
    21c3:	89 c2                	mov    %eax,%edx
    21c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    21c8:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    21cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    21ce:	0f b6 00             	movzbl (%eax),%eax
    21d1:	0f b6 d0             	movzbl %al,%edx
    21d4:	8b 45 24             	mov    0x24(%ebp),%eax
    21d7:	01 d0                	add    %edx,%eax
    21d9:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    21df:	89 d0                	mov    %edx,%eax
    21e1:	c1 f8 1f             	sar    $0x1f,%eax
    21e4:	c1 e8 18             	shr    $0x18,%eax
    21e7:	01 c2                	add    %eax,%edx
    21e9:	0f b6 d2             	movzbl %dl,%edx
    21ec:	29 c2                	sub    %eax,%edx
    21ee:	89 d0                	mov    %edx,%eax
    21f0:	89 c2                	mov    %eax,%edx
    21f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    21f5:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    21f7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    21fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21fe:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2201:	0f 8c 14 ff ff ff    	jl     211b <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    2207:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    220b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    220e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2211:	0f 8c f8 fe ff ff    	jl     210f <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    2217:	90                   	nop
    2218:	c9                   	leave  
    2219:	c3                   	ret    

0000221a <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    221a:	55                   	push   %ebp
    221b:	89 e5                	mov    %esp,%ebp
    221d:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    2220:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2227:	e9 fb 00 00 00       	jmp    2327 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    222c:	8b 55 14             	mov    0x14(%ebp),%edx
    222f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2232:	01 c2                	add    %eax,%edx
    2234:	0f b7 05 4e 84 04 00 	movzwl 0x4844e,%eax
    223b:	0f b7 c0             	movzwl %ax,%eax
    223e:	39 c2                	cmp    %eax,%edx
    2240:	0f 8f eb 00 00 00    	jg     2331 <drawMouse+0x117>
    2246:	8b 55 14             	mov    0x14(%ebp),%edx
    2249:	8b 45 fc             	mov    -0x4(%ebp),%eax
    224c:	01 d0                	add    %edx,%eax
    224e:	85 c0                	test   %eax,%eax
    2250:	0f 88 db 00 00 00    	js     2331 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2256:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    225d:	e9 b7 00 00 00       	jmp    2319 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    2262:	8b 55 10             	mov    0x10(%ebp),%edx
    2265:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2268:	01 c2                	add    %eax,%edx
    226a:	0f b7 05 4c 84 04 00 	movzwl 0x4844c,%eax
    2271:	0f b7 c0             	movzwl %ax,%eax
    2274:	39 c2                	cmp    %eax,%edx
    2276:	0f 8f a7 00 00 00    	jg     2323 <drawMouse+0x109>
    227c:	8b 55 10             	mov    0x10(%ebp),%edx
    227f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2282:	01 d0                	add    %edx,%eax
    2284:	85 c0                	test   %eax,%eax
    2286:	0f 88 97 00 00 00    	js     2323 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    228c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    228f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2292:	89 d0                	mov    %edx,%eax
    2294:	c1 e0 04             	shl    $0x4,%eax
    2297:	29 d0                	sub    %edx,%eax
    2299:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    229f:	01 c2                	add    %eax,%edx
    22a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    22a4:	01 d0                	add    %edx,%eax
    22a6:	05 a0 62 01 00       	add    $0x162a0,%eax
    22ab:	0f b6 00             	movzbl (%eax),%eax
    22ae:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    22b1:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    22b5:	74 5e                	je     2315 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    22b7:	8b 55 14             	mov    0x14(%ebp),%edx
    22ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    22bd:	01 c2                	add    %eax,%edx
    22bf:	0f b7 05 4c 84 04 00 	movzwl 0x4844c,%eax
    22c6:	0f b7 c0             	movzwl %ax,%eax
    22c9:	0f af c2             	imul   %edx,%eax
    22cc:	89 c2                	mov    %eax,%edx
    22ce:	8b 45 10             	mov    0x10(%ebp),%eax
    22d1:	01 c2                	add    %eax,%edx
    22d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    22d6:	01 c2                	add    %eax,%edx
    22d8:	89 d0                	mov    %edx,%eax
    22da:	01 c0                	add    %eax,%eax
    22dc:	01 c2                	add    %eax,%edx
    22de:	8b 45 08             	mov    0x8(%ebp),%eax
    22e1:	01 d0                	add    %edx,%eax
    22e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    22e6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    22ea:	8d 50 ff             	lea    -0x1(%eax),%edx
    22ed:	89 d0                	mov    %edx,%eax
    22ef:	01 c0                	add    %eax,%eax
    22f1:	01 d0                	add    %edx,%eax
    22f3:	05 ac 84 04 00       	add    $0x484ac,%eax
    22f8:	83 ec 04             	sub    $0x4,%esp
    22fb:	89 e2                	mov    %esp,%edx
    22fd:	0f b7 08             	movzwl (%eax),%ecx
    2300:	66 89 0a             	mov    %cx,(%edx)
    2303:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2307:	88 42 02             	mov    %al,0x2(%edx)
    230a:	ff 75 f0             	pushl  -0x10(%ebp)
    230d:	e8 73 f6 ff ff       	call   1985 <drawPoint>
    2312:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2315:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2319:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    231d:	0f 8e 3f ff ff ff    	jle    2262 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    2323:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2327:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    232b:	0f 8e fb fe ff ff    	jle    222c <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    2331:	90                   	nop
    2332:	c9                   	leave  
    2333:	c3                   	ret    

00002334 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    2334:	55                   	push   %ebp
    2335:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    2337:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    233b:	78 1b                	js     2358 <getColor+0x24>
    233d:	8b 45 08             	mov    0x8(%ebp),%eax
    2340:	8b 40 04             	mov    0x4(%eax),%eax
    2343:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2346:	7c 10                	jl     2358 <getColor+0x24>
    2348:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    234c:	78 0a                	js     2358 <getColor+0x24>
    234e:	8b 45 08             	mov    0x8(%ebp),%eax
    2351:	8b 00                	mov    (%eax),%eax
    2353:	3b 45 10             	cmp    0x10(%ebp),%eax
    2356:	7d 10                	jge    2368 <getColor+0x34>
    {
        *isInPic = 1;
    2358:	8b 45 14             	mov    0x14(%ebp),%eax
    235b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    2361:	b8 91 e5 01 00       	mov    $0x1e591,%eax
    2366:	eb 44                	jmp    23ac <getColor+0x78>
    }

    if (y == pic->height)
    2368:	8b 45 08             	mov    0x8(%ebp),%eax
    236b:	8b 40 04             	mov    0x4(%eax),%eax
    236e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2371:	75 04                	jne    2377 <getColor+0x43>
        y--;
    2373:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    2377:	8b 45 08             	mov    0x8(%ebp),%eax
    237a:	8b 00                	mov    (%eax),%eax
    237c:	3b 45 10             	cmp    0x10(%ebp),%eax
    237f:	75 04                	jne    2385 <getColor+0x51>
        x--;
    2381:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    2385:	8b 45 14             	mov    0x14(%ebp),%eax
    2388:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    238e:	8b 45 08             	mov    0x8(%ebp),%eax
    2391:	8b 48 08             	mov    0x8(%eax),%ecx
    2394:	8b 45 08             	mov    0x8(%ebp),%eax
    2397:	8b 00                	mov    (%eax),%eax
    2399:	0f af 45 0c          	imul   0xc(%ebp),%eax
    239d:	89 c2                	mov    %eax,%edx
    239f:	8b 45 10             	mov    0x10(%ebp),%eax
    23a2:	01 c2                	add    %eax,%edx
    23a4:	89 d0                	mov    %edx,%eax
    23a6:	01 c0                	add    %eax,%eax
    23a8:	01 d0                	add    %edx,%eax
    23aa:	01 c8                	add    %ecx,%eax
}
    23ac:	5d                   	pop    %ebp
    23ad:	c3                   	ret    

000023ae <setColor>:

int setColor(RGB *src, RGB *dst)
{
    23ae:	55                   	push   %ebp
    23af:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    23b1:	8b 45 08             	mov    0x8(%ebp),%eax
    23b4:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    23b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    23bb:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    23be:	8b 45 08             	mov    0x8(%ebp),%eax
    23c1:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    23c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    23c8:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    23cb:	8b 45 08             	mov    0x8(%ebp),%eax
    23ce:	0f b6 10             	movzbl (%eax),%edx
    23d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    23d4:	88 10                	mov    %dl,(%eax)

    return 1;
    23d6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    23db:	5d                   	pop    %ebp
    23dc:	c3                   	ret    

000023dd <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    23dd:	55                   	push   %ebp
    23de:	89 e5                	mov    %esp,%ebp
    23e0:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    23e3:	d9 45 10             	flds   0x10(%ebp)
    23e6:	d9 7d be             	fnstcw -0x42(%ebp)
    23e9:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    23ed:	b4 0c                	mov    $0xc,%ah
    23ef:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    23f3:	d9 6d bc             	fldcw  -0x44(%ebp)
    23f6:	db 5d fc             	fistpl -0x4(%ebp)
    23f9:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    23fc:	d9 45 0c             	flds   0xc(%ebp)
    23ff:	d9 6d bc             	fldcw  -0x44(%ebp)
    2402:	db 5d f8             	fistpl -0x8(%ebp)
    2405:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2408:	db 45 fc             	fildl  -0x4(%ebp)
    240b:	d9 45 10             	flds   0x10(%ebp)
    240e:	d9 c9                	fxch   %st(1)
    2410:	df e9                	fucomip %st(1),%st
    2412:	dd d8                	fstp   %st(0)
    2414:	76 04                	jbe    241a <mixColor+0x3d>
        x--;
    2416:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    241a:	db 45 f8             	fildl  -0x8(%ebp)
    241d:	d9 45 0c             	flds   0xc(%ebp)
    2420:	d9 c9                	fxch   %st(1)
    2422:	df e9                	fucomip %st(1),%st
    2424:	dd d8                	fstp   %st(0)
    2426:	76 04                	jbe    242c <mixColor+0x4f>
        y--;
    2428:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    242c:	8d 45 c0             	lea    -0x40(%ebp),%eax
    242f:	50                   	push   %eax
    2430:	ff 75 fc             	pushl  -0x4(%ebp)
    2433:	ff 75 f8             	pushl  -0x8(%ebp)
    2436:	ff 75 08             	pushl  0x8(%ebp)
    2439:	e8 f6 fe ff ff       	call   2334 <getColor>
    243e:	83 c4 10             	add    $0x10,%esp
    2441:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2444:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2447:	83 c0 01             	add    $0x1,%eax
    244a:	8d 55 c0             	lea    -0x40(%ebp),%edx
    244d:	83 c2 04             	add    $0x4,%edx
    2450:	52                   	push   %edx
    2451:	ff 75 fc             	pushl  -0x4(%ebp)
    2454:	50                   	push   %eax
    2455:	ff 75 08             	pushl  0x8(%ebp)
    2458:	e8 d7 fe ff ff       	call   2334 <getColor>
    245d:	83 c4 10             	add    $0x10,%esp
    2460:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2463:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2466:	83 c0 01             	add    $0x1,%eax
    2469:	8d 55 c0             	lea    -0x40(%ebp),%edx
    246c:	83 c2 08             	add    $0x8,%edx
    246f:	52                   	push   %edx
    2470:	50                   	push   %eax
    2471:	ff 75 f8             	pushl  -0x8(%ebp)
    2474:	ff 75 08             	pushl  0x8(%ebp)
    2477:	e8 b8 fe ff ff       	call   2334 <getColor>
    247c:	83 c4 10             	add    $0x10,%esp
    247f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2482:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2485:	8d 50 01             	lea    0x1(%eax),%edx
    2488:	8b 45 f8             	mov    -0x8(%ebp),%eax
    248b:	83 c0 01             	add    $0x1,%eax
    248e:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    2491:	83 c1 0c             	add    $0xc,%ecx
    2494:	51                   	push   %ecx
    2495:	52                   	push   %edx
    2496:	50                   	push   %eax
    2497:	ff 75 08             	pushl  0x8(%ebp)
    249a:	e8 95 fe ff ff       	call   2334 <getColor>
    249f:	83 c4 10             	add    $0x10,%esp
    24a2:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    24a5:	db 45 fc             	fildl  -0x4(%ebp)
    24a8:	d9 45 10             	flds   0x10(%ebp)
    24ab:	de e1                	fsubp  %st,%st(1)
    24ad:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    24b0:	db 45 f8             	fildl  -0x8(%ebp)
    24b3:	d9 45 0c             	flds   0xc(%ebp)
    24b6:	de e1                	fsubp  %st,%st(1)
    24b8:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    24bb:	d9 45 e4             	flds   -0x1c(%ebp)
    24be:	d8 4d e0             	fmuls  -0x20(%ebp)
    24c1:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    24c4:	d9 e8                	fld1   
    24c6:	d8 65 e0             	fsubs  -0x20(%ebp)
    24c9:	d8 4d e4             	fmuls  -0x1c(%ebp)
    24cc:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    24cf:	d9 e8                	fld1   
    24d1:	d8 65 e4             	fsubs  -0x1c(%ebp)
    24d4:	d8 4d e0             	fmuls  -0x20(%ebp)
    24d7:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    24da:	d9 e8                	fld1   
    24dc:	d8 65 e4             	fsubs  -0x1c(%ebp)
    24df:	d9 e8                	fld1   
    24e1:	d8 65 e0             	fsubs  -0x20(%ebp)
    24e4:	de c9                	fmulp  %st,%st(1)
    24e6:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    24e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    24ec:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    24f0:	0f b6 c0             	movzbl %al,%eax
    24f3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24f6:	db 45 b4             	fildl  -0x4c(%ebp)
    24f9:	d8 4d d0             	fmuls  -0x30(%ebp)
    24fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
    24ff:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2502:	db 45 b4             	fildl  -0x4c(%ebp)
    2505:	de c9                	fmulp  %st,%st(1)
    2507:	8b 45 f0             	mov    -0x10(%ebp),%eax
    250a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    250e:	0f b6 c0             	movzbl %al,%eax
    2511:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2514:	db 45 b4             	fildl  -0x4c(%ebp)
    2517:	d8 4d d4             	fmuls  -0x2c(%ebp)
    251a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    251d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2520:	db 45 b4             	fildl  -0x4c(%ebp)
    2523:	de c9                	fmulp  %st,%st(1)
    2525:	de c1                	faddp  %st,%st(1)
    2527:	8b 45 ec             	mov    -0x14(%ebp),%eax
    252a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    252e:	0f b6 c0             	movzbl %al,%eax
    2531:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2534:	db 45 b4             	fildl  -0x4c(%ebp)
    2537:	d8 4d d8             	fmuls  -0x28(%ebp)
    253a:	8b 45 c8             	mov    -0x38(%ebp),%eax
    253d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2540:	db 45 b4             	fildl  -0x4c(%ebp)
    2543:	de c9                	fmulp  %st,%st(1)
    2545:	de c1                	faddp  %st,%st(1)
    2547:	8b 45 e8             	mov    -0x18(%ebp),%eax
    254a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    254e:	0f b6 c0             	movzbl %al,%eax
    2551:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2554:	db 45 b4             	fildl  -0x4c(%ebp)
    2557:	d8 4d dc             	fmuls  -0x24(%ebp)
    255a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    255d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2560:	db 45 b4             	fildl  -0x4c(%ebp)
    2563:	de c9                	fmulp  %st,%st(1)
    2565:	de c1                	faddp  %st,%st(1)
    2567:	d9 7d be             	fnstcw -0x42(%ebp)
    256a:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    256e:	b4 0c                	mov    $0xc,%ah
    2570:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2574:	d9 6d bc             	fldcw  -0x44(%ebp)
    2577:	db 5d b8             	fistpl -0x48(%ebp)
    257a:	d9 6d be             	fldcw  -0x42(%ebp)
    257d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2580:	89 c2                	mov    %eax,%edx
    2582:	8b 45 14             	mov    0x14(%ebp),%eax
    2585:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    2588:	8b 45 f4             	mov    -0xc(%ebp),%eax
    258b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    258f:	0f b6 c0             	movzbl %al,%eax
    2592:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2595:	db 45 b4             	fildl  -0x4c(%ebp)
    2598:	d8 4d d0             	fmuls  -0x30(%ebp)
    259b:	8b 45 c0             	mov    -0x40(%ebp),%eax
    259e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25a1:	db 45 b4             	fildl  -0x4c(%ebp)
    25a4:	de c9                	fmulp  %st,%st(1)
    25a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    25a9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    25ad:	0f b6 c0             	movzbl %al,%eax
    25b0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25b3:	db 45 b4             	fildl  -0x4c(%ebp)
    25b6:	d8 4d d4             	fmuls  -0x2c(%ebp)
    25b9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    25bc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25bf:	db 45 b4             	fildl  -0x4c(%ebp)
    25c2:	de c9                	fmulp  %st,%st(1)
    25c4:	de c1                	faddp  %st,%st(1)
    25c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    25c9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    25cd:	0f b6 c0             	movzbl %al,%eax
    25d0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25d3:	db 45 b4             	fildl  -0x4c(%ebp)
    25d6:	d8 4d d8             	fmuls  -0x28(%ebp)
    25d9:	8b 45 c8             	mov    -0x38(%ebp),%eax
    25dc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25df:	db 45 b4             	fildl  -0x4c(%ebp)
    25e2:	de c9                	fmulp  %st,%st(1)
    25e4:	de c1                	faddp  %st,%st(1)
    25e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25e9:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    25ed:	0f b6 c0             	movzbl %al,%eax
    25f0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25f3:	db 45 b4             	fildl  -0x4c(%ebp)
    25f6:	d8 4d dc             	fmuls  -0x24(%ebp)
    25f9:	8b 45 cc             	mov    -0x34(%ebp),%eax
    25fc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25ff:	db 45 b4             	fildl  -0x4c(%ebp)
    2602:	de c9                	fmulp  %st,%st(1)
    2604:	de c1                	faddp  %st,%st(1)
    2606:	d9 6d bc             	fldcw  -0x44(%ebp)
    2609:	db 5d b8             	fistpl -0x48(%ebp)
    260c:	d9 6d be             	fldcw  -0x42(%ebp)
    260f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2612:	89 c2                	mov    %eax,%edx
    2614:	8b 45 14             	mov    0x14(%ebp),%eax
    2617:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    261a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    261d:	0f b6 00             	movzbl (%eax),%eax
    2620:	0f b6 c0             	movzbl %al,%eax
    2623:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2626:	db 45 b4             	fildl  -0x4c(%ebp)
    2629:	d8 4d d0             	fmuls  -0x30(%ebp)
    262c:	8b 45 c0             	mov    -0x40(%ebp),%eax
    262f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2632:	db 45 b4             	fildl  -0x4c(%ebp)
    2635:	de c9                	fmulp  %st,%st(1)
    2637:	8b 45 f0             	mov    -0x10(%ebp),%eax
    263a:	0f b6 00             	movzbl (%eax),%eax
    263d:	0f b6 c0             	movzbl %al,%eax
    2640:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2643:	db 45 b4             	fildl  -0x4c(%ebp)
    2646:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2649:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    264c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    264f:	db 45 b4             	fildl  -0x4c(%ebp)
    2652:	de c9                	fmulp  %st,%st(1)
    2654:	de c1                	faddp  %st,%st(1)
    2656:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2659:	0f b6 00             	movzbl (%eax),%eax
    265c:	0f b6 c0             	movzbl %al,%eax
    265f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2662:	db 45 b4             	fildl  -0x4c(%ebp)
    2665:	d8 4d d8             	fmuls  -0x28(%ebp)
    2668:	8b 45 c8             	mov    -0x38(%ebp),%eax
    266b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    266e:	db 45 b4             	fildl  -0x4c(%ebp)
    2671:	de c9                	fmulp  %st,%st(1)
    2673:	de c1                	faddp  %st,%st(1)
    2675:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2678:	0f b6 00             	movzbl (%eax),%eax
    267b:	0f b6 c0             	movzbl %al,%eax
    267e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2681:	db 45 b4             	fildl  -0x4c(%ebp)
    2684:	d8 4d dc             	fmuls  -0x24(%ebp)
    2687:	8b 45 cc             	mov    -0x34(%ebp),%eax
    268a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    268d:	db 45 b4             	fildl  -0x4c(%ebp)
    2690:	de c9                	fmulp  %st,%st(1)
    2692:	de c1                	faddp  %st,%st(1)
    2694:	d9 6d bc             	fldcw  -0x44(%ebp)
    2697:	db 5d b8             	fistpl -0x48(%ebp)
    269a:	d9 6d be             	fldcw  -0x42(%ebp)
    269d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    26a0:	89 c2                	mov    %eax,%edx
    26a2:	8b 45 14             	mov    0x14(%ebp),%eax
    26a5:	88 10                	mov    %dl,(%eax)

    return 1;
    26a7:	b8 01 00 00 00       	mov    $0x1,%eax
}
    26ac:	c9                   	leave  
    26ad:	c3                   	ret    

000026ae <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    26ae:	55                   	push   %ebp
    26af:	89 e5                	mov    %esp,%ebp
    26b1:	53                   	push   %ebx
    26b2:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    26b5:	8b 45 10             	mov    0x10(%ebp),%eax
    26b8:	c1 f8 10             	sar    $0x10,%eax
    26bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    26be:	8b 45 0c             	mov    0xc(%ebp),%eax
    26c1:	c1 f8 10             	sar    $0x10,%eax
    26c4:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    26c7:	8d 45 bc             	lea    -0x44(%ebp),%eax
    26ca:	50                   	push   %eax
    26cb:	ff 75 f8             	pushl  -0x8(%ebp)
    26ce:	ff 75 f4             	pushl  -0xc(%ebp)
    26d1:	ff 75 08             	pushl  0x8(%ebp)
    26d4:	e8 5b fc ff ff       	call   2334 <getColor>
    26d9:	83 c4 10             	add    $0x10,%esp
    26dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    26df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    26e2:	83 c0 01             	add    $0x1,%eax
    26e5:	8d 55 bc             	lea    -0x44(%ebp),%edx
    26e8:	83 c2 04             	add    $0x4,%edx
    26eb:	52                   	push   %edx
    26ec:	ff 75 f8             	pushl  -0x8(%ebp)
    26ef:	50                   	push   %eax
    26f0:	ff 75 08             	pushl  0x8(%ebp)
    26f3:	e8 3c fc ff ff       	call   2334 <getColor>
    26f8:	83 c4 10             	add    $0x10,%esp
    26fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    26fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2701:	83 c0 01             	add    $0x1,%eax
    2704:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2707:	83 c2 08             	add    $0x8,%edx
    270a:	52                   	push   %edx
    270b:	50                   	push   %eax
    270c:	ff 75 f4             	pushl  -0xc(%ebp)
    270f:	ff 75 08             	pushl  0x8(%ebp)
    2712:	e8 1d fc ff ff       	call   2334 <getColor>
    2717:	83 c4 10             	add    $0x10,%esp
    271a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    271d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2720:	8d 50 01             	lea    0x1(%eax),%edx
    2723:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2726:	83 c0 01             	add    $0x1,%eax
    2729:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    272c:	83 c1 0c             	add    $0xc,%ecx
    272f:	51                   	push   %ecx
    2730:	52                   	push   %edx
    2731:	50                   	push   %eax
    2732:	ff 75 08             	pushl  0x8(%ebp)
    2735:	e8 fa fb ff ff       	call   2334 <getColor>
    273a:	83 c4 10             	add    $0x10,%esp
    273d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    2740:	8b 45 10             	mov    0x10(%ebp),%eax
    2743:	0f b7 c0             	movzwl %ax,%eax
    2746:	c1 f8 08             	sar    $0x8,%eax
    2749:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    274c:	8b 45 0c             	mov    0xc(%ebp),%eax
    274f:	0f b7 c0             	movzwl %ax,%eax
    2752:	c1 f8 08             	sar    $0x8,%eax
    2755:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2758:	8b 45 e0             	mov    -0x20(%ebp),%eax
    275b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    275f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    2762:	b8 ff 00 00 00       	mov    $0xff,%eax
    2767:	2b 45 dc             	sub    -0x24(%ebp),%eax
    276a:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    276e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    2771:	b8 ff 00 00 00       	mov    $0xff,%eax
    2776:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2779:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    277d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    2780:	b8 ff 00 00 00       	mov    $0xff,%eax
    2785:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2788:	89 c2                	mov    %eax,%edx
    278a:	b8 ff 00 00 00       	mov    $0xff,%eax
    278f:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2792:	0f af c2             	imul   %edx,%eax
    2795:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    2798:	8b 45 f0             	mov    -0x10(%ebp),%eax
    279b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    279f:	0f b6 c0             	movzbl %al,%eax
    27a2:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    27a6:	8b 55 bc             	mov    -0x44(%ebp),%edx
    27a9:	0f af d0             	imul   %eax,%edx
    27ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    27af:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    27b3:	0f b6 c0             	movzbl %al,%eax
    27b6:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    27ba:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    27bd:	0f af c1             	imul   %ecx,%eax
    27c0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    27c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    27c6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    27ca:	0f b6 c0             	movzbl %al,%eax
    27cd:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    27d1:	8b 55 c8             	mov    -0x38(%ebp),%edx
    27d4:	0f af d0             	imul   %eax,%edx
    27d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    27da:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    27de:	0f b6 c0             	movzbl %al,%eax
    27e1:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    27e5:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    27e8:	0f af c1             	imul   %ecx,%eax
    27eb:	01 d0                	add    %edx,%eax
    27ed:	01 d8                	add    %ebx,%eax
    27ef:	c1 e8 10             	shr    $0x10,%eax
    27f2:	89 c2                	mov    %eax,%edx
    27f4:	8b 45 14             	mov    0x14(%ebp),%eax
    27f7:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    27fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    27fd:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2801:	0f b6 c0             	movzbl %al,%eax
    2804:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2808:	8b 55 bc             	mov    -0x44(%ebp),%edx
    280b:	0f af d0             	imul   %eax,%edx
    280e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2811:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2815:	0f b6 c0             	movzbl %al,%eax
    2818:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    281c:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    281f:	0f af c1             	imul   %ecx,%eax
    2822:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2825:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2828:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    282c:	0f b6 c0             	movzbl %al,%eax
    282f:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2833:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2836:	0f af d0             	imul   %eax,%edx
    2839:	8b 45 e8             	mov    -0x18(%ebp),%eax
    283c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2840:	0f b6 c0             	movzbl %al,%eax
    2843:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2847:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    284a:	0f af c1             	imul   %ecx,%eax
    284d:	01 d0                	add    %edx,%eax
    284f:	01 d8                	add    %ebx,%eax
    2851:	c1 e8 10             	shr    $0x10,%eax
    2854:	89 c2                	mov    %eax,%edx
    2856:	8b 45 14             	mov    0x14(%ebp),%eax
    2859:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    285c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    285f:	0f b6 00             	movzbl (%eax),%eax
    2862:	0f b6 c0             	movzbl %al,%eax
    2865:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2869:	8b 55 bc             	mov    -0x44(%ebp),%edx
    286c:	0f af d0             	imul   %eax,%edx
    286f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2872:	0f b6 00             	movzbl (%eax),%eax
    2875:	0f b6 c0             	movzbl %al,%eax
    2878:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    287c:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    287f:	0f af c1             	imul   %ecx,%eax
    2882:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2885:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2888:	0f b6 00             	movzbl (%eax),%eax
    288b:	0f b6 c0             	movzbl %al,%eax
    288e:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2892:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2895:	0f af d0             	imul   %eax,%edx
    2898:	8b 45 e8             	mov    -0x18(%ebp),%eax
    289b:	0f b6 00             	movzbl (%eax),%eax
    289e:	0f b6 c0             	movzbl %al,%eax
    28a1:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    28a5:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    28a8:	0f af c1             	imul   %ecx,%eax
    28ab:	01 d0                	add    %edx,%eax
    28ad:	01 d8                	add    %ebx,%eax
    28af:	c1 e8 10             	shr    $0x10,%eax
    28b2:	89 c2                	mov    %eax,%edx
    28b4:	8b 45 14             	mov    0x14(%ebp),%eax
    28b7:	88 10                	mov    %dl,(%eax)
}
    28b9:	90                   	nop
    28ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    28bd:	c9                   	leave  
    28be:	c3                   	ret    

000028bf <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    28bf:	55                   	push   %ebp
    28c0:	89 e5                	mov    %esp,%ebp
    28c2:	53                   	push   %ebx
    28c3:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    28c6:	8b 45 08             	mov    0x8(%ebp),%eax
    28c9:	8b 00                	mov    (%eax),%eax
    28cb:	c1 e0 10             	shl    $0x10,%eax
    28ce:	89 c1                	mov    %eax,%ecx
    28d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    28d3:	8b 18                	mov    (%eax),%ebx
    28d5:	89 c8                	mov    %ecx,%eax
    28d7:	99                   	cltd   
    28d8:	f7 fb                	idiv   %ebx
    28da:	83 c0 01             	add    $0x1,%eax
    28dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    28e0:	8b 45 08             	mov    0x8(%ebp),%eax
    28e3:	8b 40 04             	mov    0x4(%eax),%eax
    28e6:	c1 e0 10             	shl    $0x10,%eax
    28e9:	89 c1                	mov    %eax,%ecx
    28eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    28ee:	8b 58 04             	mov    0x4(%eax),%ebx
    28f1:	89 c8                	mov    %ecx,%eax
    28f3:	99                   	cltd   
    28f4:	f7 fb                	idiv   %ebx
    28f6:	83 c0 01             	add    $0x1,%eax
    28f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    28fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    28ff:	d1 f8                	sar    %eax
    2901:	2d 00 80 00 00       	sub    $0x8000,%eax
    2906:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2909:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    290c:	d1 f8                	sar    %eax
    290e:	2d 00 80 00 00       	sub    $0x8000,%eax
    2913:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2916:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2919:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    291c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2923:	eb 5d                	jmp    2982 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2925:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2928:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    292b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2932:	eb 3a                	jmp    296e <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    2934:	8b 45 0c             	mov    0xc(%ebp),%eax
    2937:	8b 48 08             	mov    0x8(%eax),%ecx
    293a:	8b 45 0c             	mov    0xc(%ebp),%eax
    293d:	8b 00                	mov    (%eax),%eax
    293f:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2943:	89 c2                	mov    %eax,%edx
    2945:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2948:	01 c2                	add    %eax,%edx
    294a:	89 d0                	mov    %edx,%eax
    294c:	01 c0                	add    %eax,%eax
    294e:	01 d0                	add    %edx,%eax
    2950:	01 c8                	add    %ecx,%eax
    2952:	50                   	push   %eax
    2953:	ff 75 f0             	pushl  -0x10(%ebp)
    2956:	ff 75 f8             	pushl  -0x8(%ebp)
    2959:	ff 75 08             	pushl  0x8(%ebp)
    295c:	e8 4d fd ff ff       	call   26ae <mixColorInt>
    2961:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    2964:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2967:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    296a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    296e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2971:	8b 00                	mov    (%eax),%eax
    2973:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2976:	7f bc                	jg     2934 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    2978:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    297b:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    297e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2982:	8b 45 0c             	mov    0xc(%ebp),%eax
    2985:	8b 40 04             	mov    0x4(%eax),%eax
    2988:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    298b:	7f 98                	jg     2925 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    298d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2992:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2995:	c9                   	leave  
    2996:	c3                   	ret    

00002997 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    2997:	55                   	push   %ebp
    2998:	89 e5                	mov    %esp,%ebp
    299a:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    299d:	8b 45 08             	mov    0x8(%ebp),%eax
    29a0:	8b 00                	mov    (%eax),%eax
    29a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    29a5:	db 45 e4             	fildl  -0x1c(%ebp)
    29a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    29ab:	8b 00                	mov    (%eax),%eax
    29ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    29b0:	db 45 e4             	fildl  -0x1c(%ebp)
    29b3:	de f9                	fdivrp %st,%st(1)
    29b5:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    29b8:	8b 45 08             	mov    0x8(%ebp),%eax
    29bb:	8b 40 04             	mov    0x4(%eax),%eax
    29be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    29c1:	db 45 e4             	fildl  -0x1c(%ebp)
    29c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    29c7:	8b 40 04             	mov    0x4(%eax),%eax
    29ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    29cd:	db 45 e4             	fildl  -0x1c(%ebp)
    29d0:	de f9                	fdivrp %st,%st(1)
    29d2:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    29d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    29dc:	eb 5e                	jmp    2a3c <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    29de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    29e5:	eb 47                	jmp    2a2e <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    29e7:	db 45 f8             	fildl  -0x8(%ebp)
    29ea:	d8 4d f4             	fmuls  -0xc(%ebp)
    29ed:	d9 7d ee             	fnstcw -0x12(%ebp)
    29f0:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    29f4:	b4 0c                	mov    $0xc,%ah
    29f6:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    29fa:	d9 6d ec             	fldcw  -0x14(%ebp)
    29fd:	db 5d e8             	fistpl -0x18(%ebp)
    2a00:	d9 6d ee             	fldcw  -0x12(%ebp)
    2a03:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2a06:	db 45 fc             	fildl  -0x4(%ebp)
    2a09:	d8 4d f0             	fmuls  -0x10(%ebp)
    2a0c:	d9 6d ec             	fldcw  -0x14(%ebp)
    2a0f:	db 5d e8             	fistpl -0x18(%ebp)
    2a12:	d9 6d ee             	fldcw  -0x12(%ebp)
    2a15:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2a18:	6a 00                	push   $0x0
    2a1a:	52                   	push   %edx
    2a1b:	50                   	push   %eax
    2a1c:	ff 75 08             	pushl  0x8(%ebp)
    2a1f:	e8 10 f9 ff ff       	call   2334 <getColor>
    2a24:	83 c4 10             	add    $0x10,%esp
    2a27:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2a2a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2a2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a31:	8b 00                	mov    (%eax),%eax
    2a33:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2a36:	7f af                	jg     29e7 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2a38:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2a3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a3f:	8b 40 04             	mov    0x4(%eax),%eax
    2a42:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2a45:	7f 97                	jg     29de <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2a47:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a4c:	c9                   	leave  
    2a4d:	c3                   	ret    

00002a4e <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    2a4e:	55                   	push   %ebp
    2a4f:	89 e5                	mov    %esp,%ebp
    2a51:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    2a54:	8b 45 08             	mov    0x8(%ebp),%eax
    2a57:	8b 00                	mov    (%eax),%eax
    2a59:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2a5c:	db 45 e0             	fildl  -0x20(%ebp)
    2a5f:	d9 5d e0             	fstps  -0x20(%ebp)
    2a62:	83 ec 0c             	sub    $0xc,%esp
    2a65:	ff 75 10             	pushl  0x10(%ebp)
    2a68:	e8 6b e2 ff ff       	call   cd8 <cos>
    2a6d:	83 c4 10             	add    $0x10,%esp
    2a70:	d9 5d dc             	fstps  -0x24(%ebp)
    2a73:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2a76:	83 ec 0c             	sub    $0xc,%esp
    2a79:	50                   	push   %eax
    2a7a:	e8 90 e1 ff ff       	call   c0f <abs>
    2a7f:	83 c4 10             	add    $0x10,%esp
    2a82:	d8 4d e0             	fmuls  -0x20(%ebp)
    2a85:	d9 5d e0             	fstps  -0x20(%ebp)
    2a88:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a8b:	8b 00                	mov    (%eax),%eax
    2a8d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2a90:	db 45 dc             	fildl  -0x24(%ebp)
    2a93:	d9 5d dc             	fstps  -0x24(%ebp)
    2a96:	83 ec 0c             	sub    $0xc,%esp
    2a99:	ff 75 10             	pushl  0x10(%ebp)
    2a9c:	e8 da e3 ff ff       	call   e7b <sin>
    2aa1:	83 c4 10             	add    $0x10,%esp
    2aa4:	d9 5d d8             	fstps  -0x28(%ebp)
    2aa7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2aaa:	83 ec 0c             	sub    $0xc,%esp
    2aad:	50                   	push   %eax
    2aae:	e8 5c e1 ff ff       	call   c0f <abs>
    2ab3:	83 c4 10             	add    $0x10,%esp
    2ab6:	d8 4d dc             	fmuls  -0x24(%ebp)
    2ab9:	d8 45 e0             	fadds  -0x20(%ebp)
    2abc:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2abf:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2ac3:	b4 0c                	mov    $0xc,%ah
    2ac5:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2ac9:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2acc:	db 5d f4             	fistpl -0xc(%ebp)
    2acf:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    2ad2:	8b 45 08             	mov    0x8(%ebp),%eax
    2ad5:	8b 00                	mov    (%eax),%eax
    2ad7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2ada:	db 45 e0             	fildl  -0x20(%ebp)
    2add:	d9 5d e0             	fstps  -0x20(%ebp)
    2ae0:	83 ec 0c             	sub    $0xc,%esp
    2ae3:	ff 75 10             	pushl  0x10(%ebp)
    2ae6:	e8 90 e3 ff ff       	call   e7b <sin>
    2aeb:	83 c4 10             	add    $0x10,%esp
    2aee:	d9 5d dc             	fstps  -0x24(%ebp)
    2af1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2af4:	83 ec 0c             	sub    $0xc,%esp
    2af7:	50                   	push   %eax
    2af8:	e8 12 e1 ff ff       	call   c0f <abs>
    2afd:	83 c4 10             	add    $0x10,%esp
    2b00:	d8 4d e0             	fmuls  -0x20(%ebp)
    2b03:	d9 5d e0             	fstps  -0x20(%ebp)
    2b06:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b09:	8b 00                	mov    (%eax),%eax
    2b0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2b0e:	db 45 dc             	fildl  -0x24(%ebp)
    2b11:	d9 5d dc             	fstps  -0x24(%ebp)
    2b14:	83 ec 0c             	sub    $0xc,%esp
    2b17:	ff 75 10             	pushl  0x10(%ebp)
    2b1a:	e8 b9 e1 ff ff       	call   cd8 <cos>
    2b1f:	83 c4 10             	add    $0x10,%esp
    2b22:	d9 5d d8             	fstps  -0x28(%ebp)
    2b25:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2b28:	83 ec 0c             	sub    $0xc,%esp
    2b2b:	50                   	push   %eax
    2b2c:	e8 de e0 ff ff       	call   c0f <abs>
    2b31:	83 c4 10             	add    $0x10,%esp
    2b34:	d8 4d dc             	fmuls  -0x24(%ebp)
    2b37:	d8 45 e0             	fadds  -0x20(%ebp)
    2b3a:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2b3d:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2b41:	b4 0c                	mov    $0xc,%ah
    2b43:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2b47:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2b4a:	db 5d f0             	fistpl -0x10(%ebp)
    2b4d:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    2b50:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b53:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2b56:	89 10                	mov    %edx,(%eax)
    *width = w;
    2b58:	8b 45 08             	mov    0x8(%ebp),%eax
    2b5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2b5e:	89 10                	mov    %edx,(%eax)
    return 1;
    2b60:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b65:	c9                   	leave  
    2b66:	c3                   	ret    

00002b67 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    2b67:	55                   	push   %ebp
    2b68:	89 e5                	mov    %esp,%ebp
    2b6a:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2b6d:	8b 45 08             	mov    0x8(%ebp),%eax
    2b70:	8b 40 04             	mov    0x4(%eax),%eax
    2b73:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2b76:	db 45 c4             	fildl  -0x3c(%ebp)
    2b79:	d9 05 e4 a0 01 00    	flds   0x1a0e4
    2b7f:	de f9                	fdivrp %st,%st(1)
    2b81:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    2b84:	8b 45 08             	mov    0x8(%ebp),%eax
    2b87:	8b 00                	mov    (%eax),%eax
    2b89:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2b8c:	db 45 c4             	fildl  -0x3c(%ebp)
    2b8f:	d9 05 e4 a0 01 00    	flds   0x1a0e4
    2b95:	de f9                	fdivrp %st,%st(1)
    2b97:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2b9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b9d:	8b 50 04             	mov    0x4(%eax),%edx
    2ba0:	8b 45 08             	mov    0x8(%ebp),%eax
    2ba3:	8b 40 04             	mov    0x4(%eax),%eax
    2ba6:	29 c2                	sub    %eax,%edx
    2ba8:	89 d0                	mov    %edx,%eax
    2baa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2bad:	db 45 c4             	fildl  -0x3c(%ebp)
    2bb0:	d9 05 e4 a0 01 00    	flds   0x1a0e4
    2bb6:	de f9                	fdivrp %st,%st(1)
    2bb8:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2bbb:	8b 45 0c             	mov    0xc(%ebp),%eax
    2bbe:	8b 10                	mov    (%eax),%edx
    2bc0:	8b 45 08             	mov    0x8(%ebp),%eax
    2bc3:	8b 00                	mov    (%eax),%eax
    2bc5:	29 c2                	sub    %eax,%edx
    2bc7:	89 d0                	mov    %edx,%eax
    2bc9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2bcc:	db 45 c4             	fildl  -0x3c(%ebp)
    2bcf:	d9 05 e4 a0 01 00    	flds   0x1a0e4
    2bd5:	de f9                	fdivrp %st,%st(1)
    2bd7:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2bda:	d9 45 10             	flds   0x10(%ebp)
    2bdd:	d9 e0                	fchs   
    2bdf:	83 ec 0c             	sub    $0xc,%esp
    2be2:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2be6:	d9 1c 24             	fstps  (%esp)
    2be9:	e8 ea e0 ff ff       	call   cd8 <cos>
    2bee:	83 c4 10             	add    $0x10,%esp
    2bf1:	d9 5d c4             	fstps  -0x3c(%ebp)
    2bf4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2bf7:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2bfa:	d9 45 10             	flds   0x10(%ebp)
    2bfd:	d9 e0                	fchs   
    2bff:	83 ec 0c             	sub    $0xc,%esp
    2c02:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2c06:	d9 1c 24             	fstps  (%esp)
    2c09:	e8 6d e2 ff ff       	call   e7b <sin>
    2c0e:	83 c4 10             	add    $0x10,%esp
    2c11:	d9 5d c4             	fstps  -0x3c(%ebp)
    2c14:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2c17:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2c1a:	d9 ee                	fldz   
    2c1c:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    2c1f:	d9 ee                	fldz   
    2c21:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    2c24:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2c2b:	e9 28 01 00 00       	jmp    2d58 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    2c30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2c37:	e9 0a 01 00 00       	jmp    2d46 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2c3c:	db 45 f4             	fildl  -0xc(%ebp)
    2c3f:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2c42:	d8 65 ec             	fsubs  -0x14(%ebp)
    2c45:	d8 4d dc             	fmuls  -0x24(%ebp)
    2c48:	db 45 f0             	fildl  -0x10(%ebp)
    2c4b:	d8 65 e0             	fsubs  -0x20(%ebp)
    2c4e:	d8 65 e8             	fsubs  -0x18(%ebp)
    2c51:	d8 4d d8             	fmuls  -0x28(%ebp)
    2c54:	de c1                	faddp  %st,%st(1)
    2c56:	d8 45 ec             	fadds  -0x14(%ebp)
    2c59:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2c5c:	db 45 f0             	fildl  -0x10(%ebp)
    2c5f:	d8 65 e0             	fsubs  -0x20(%ebp)
    2c62:	d8 65 e8             	fsubs  -0x18(%ebp)
    2c65:	d8 4d dc             	fmuls  -0x24(%ebp)
    2c68:	db 45 f4             	fildl  -0xc(%ebp)
    2c6b:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2c6e:	d8 65 ec             	fsubs  -0x14(%ebp)
    2c71:	d8 4d d8             	fmuls  -0x28(%ebp)
    2c74:	de e9                	fsubrp %st,%st(1)
    2c76:	d8 45 e8             	fadds  -0x18(%ebp)
    2c79:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2c7c:	d9 45 d4             	flds   -0x2c(%ebp)
    2c7f:	d9 ee                	fldz   
    2c81:	d9 c9                	fxch   %st(1)
    2c83:	df e9                	fucomip %st(1),%st
    2c85:	dd d8                	fstp   %st(0)
    2c87:	0f 93 c0             	setae  %al
    2c8a:	83 f0 01             	xor    $0x1,%eax
    2c8d:	84 c0                	test   %al,%al
    2c8f:	75 52                	jne    2ce3 <picTurn+0x17c>
    2c91:	8b 45 08             	mov    0x8(%ebp),%eax
    2c94:	8b 40 04             	mov    0x4(%eax),%eax
    2c97:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2c9a:	db 45 c4             	fildl  -0x3c(%ebp)
    2c9d:	d9 45 d4             	flds   -0x2c(%ebp)
    2ca0:	d9 c9                	fxch   %st(1)
    2ca2:	df e9                	fucomip %st(1),%st
    2ca4:	dd d8                	fstp   %st(0)
    2ca6:	0f 97 c0             	seta   %al
    2ca9:	83 f0 01             	xor    $0x1,%eax
    2cac:	84 c0                	test   %al,%al
    2cae:	75 33                	jne    2ce3 <picTurn+0x17c>
    2cb0:	d9 45 d0             	flds   -0x30(%ebp)
    2cb3:	d9 ee                	fldz   
    2cb5:	d9 c9                	fxch   %st(1)
    2cb7:	df e9                	fucomip %st(1),%st
    2cb9:	dd d8                	fstp   %st(0)
    2cbb:	0f 93 c0             	setae  %al
    2cbe:	83 f0 01             	xor    $0x1,%eax
    2cc1:	84 c0                	test   %al,%al
    2cc3:	75 1e                	jne    2ce3 <picTurn+0x17c>
    2cc5:	8b 45 08             	mov    0x8(%ebp),%eax
    2cc8:	8b 00                	mov    (%eax),%eax
    2cca:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2ccd:	db 45 c4             	fildl  -0x3c(%ebp)
    2cd0:	d9 45 d0             	flds   -0x30(%ebp)
    2cd3:	d9 c9                	fxch   %st(1)
    2cd5:	df e9                	fucomip %st(1),%st
    2cd7:	dd d8                	fstp   %st(0)
    2cd9:	0f 97 c0             	seta   %al
    2cdc:	83 f0 01             	xor    $0x1,%eax
    2cdf:	84 c0                	test   %al,%al
    2ce1:	74 2f                	je     2d12 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    2ce3:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ce6:	8b 48 08             	mov    0x8(%eax),%ecx
    2ce9:	8b 45 0c             	mov    0xc(%ebp),%eax
    2cec:	8b 00                	mov    (%eax),%eax
    2cee:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2cf2:	89 c2                	mov    %eax,%edx
    2cf4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2cf7:	01 c2                	add    %eax,%edx
    2cf9:	89 d0                	mov    %edx,%eax
    2cfb:	01 c0                	add    %eax,%eax
    2cfd:	01 d0                	add    %edx,%eax
    2cff:	01 c8                	add    %ecx,%eax
    2d01:	83 ec 08             	sub    $0x8,%esp
    2d04:	50                   	push   %eax
    2d05:	68 91 e5 01 00       	push   $0x1e591
    2d0a:	e8 9f f6 ff ff       	call   23ae <setColor>
    2d0f:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    2d12:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d15:	8b 48 08             	mov    0x8(%eax),%ecx
    2d18:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d1b:	8b 00                	mov    (%eax),%eax
    2d1d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2d21:	89 c2                	mov    %eax,%edx
    2d23:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2d26:	01 c2                	add    %eax,%edx
    2d28:	89 d0                	mov    %edx,%eax
    2d2a:	01 c0                	add    %eax,%eax
    2d2c:	01 d0                	add    %edx,%eax
    2d2e:	01 c8                	add    %ecx,%eax
    2d30:	50                   	push   %eax
    2d31:	ff 75 d0             	pushl  -0x30(%ebp)
    2d34:	ff 75 d4             	pushl  -0x2c(%ebp)
    2d37:	ff 75 08             	pushl  0x8(%ebp)
    2d3a:	e8 9e f6 ff ff       	call   23dd <mixColor>
    2d3f:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2d42:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2d46:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d49:	8b 00                	mov    (%eax),%eax
    2d4b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2d4e:	0f 8f e8 fe ff ff    	jg     2c3c <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2d54:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2d58:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d5b:	8b 40 04             	mov    0x4(%eax),%eax
    2d5e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2d61:	0f 8f c9 fe ff ff    	jg     2c30 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    2d67:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2d6c:	c9                   	leave  
    2d6d:	c3                   	ret    

00002d6e <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2d6e:	55                   	push   %ebp
    2d6f:	89 e5                	mov    %esp,%ebp
    2d71:	53                   	push   %ebx
    2d72:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2d75:	8b 45 08             	mov    0x8(%ebp),%eax
    2d78:	8b 10                	mov    (%eax),%edx
    2d7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d7d:	8b 00                	mov    (%eax),%eax
    2d7f:	39 c2                	cmp    %eax,%edx
    2d81:	75 10                	jne    2d93 <picRollingOver+0x25>
    2d83:	8b 45 08             	mov    0x8(%ebp),%eax
    2d86:	8b 50 04             	mov    0x4(%eax),%edx
    2d89:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d8c:	8b 40 04             	mov    0x4(%eax),%eax
    2d8f:	39 c2                	cmp    %eax,%edx
    2d91:	74 0a                	je     2d9d <picRollingOver+0x2f>
        return 0;
    2d93:	b8 00 00 00 00       	mov    $0x0,%eax
    2d98:	e9 88 00 00 00       	jmp    2e25 <picRollingOver+0xb7>

    int h = src->height;
    2d9d:	8b 45 08             	mov    0x8(%ebp),%eax
    2da0:	8b 40 04             	mov    0x4(%eax),%eax
    2da3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2da6:	8b 45 08             	mov    0x8(%ebp),%eax
    2da9:	8b 00                	mov    (%eax),%eax
    2dab:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2dae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2db5:	eb 61                	jmp    2e18 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2db7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2dbe:	eb 4c                	jmp    2e0c <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2dc0:	8b 45 0c             	mov    0xc(%ebp),%eax
    2dc3:	8b 48 08             	mov    0x8(%eax),%ecx
    2dc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2dc9:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2dcc:	83 e8 01             	sub    $0x1,%eax
    2dcf:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2dd3:	89 c2                	mov    %eax,%edx
    2dd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dd8:	01 c2                	add    %eax,%edx
    2dda:	89 d0                	mov    %edx,%eax
    2ddc:	01 c0                	add    %eax,%eax
    2dde:	01 d0                	add    %edx,%eax
    2de0:	01 c1                	add    %eax,%ecx
    2de2:	8b 45 08             	mov    0x8(%ebp),%eax
    2de5:	8b 58 08             	mov    0x8(%eax),%ebx
    2de8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2deb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2def:	89 c2                	mov    %eax,%edx
    2df1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2df4:	01 c2                	add    %eax,%edx
    2df6:	89 d0                	mov    %edx,%eax
    2df8:	01 c0                	add    %eax,%eax
    2dfa:	01 d0                	add    %edx,%eax
    2dfc:	01 d8                	add    %ebx,%eax
    2dfe:	51                   	push   %ecx
    2dff:	50                   	push   %eax
    2e00:	e8 a9 f5 ff ff       	call   23ae <setColor>
    2e05:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2e08:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e0f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2e12:	7c ac                	jl     2dc0 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2e14:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2e18:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2e1b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2e1e:	7c 97                	jl     2db7 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2e20:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2e25:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2e28:	c9                   	leave  
    2e29:	c3                   	ret    

00002e2a <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2e2a:	55                   	push   %ebp
    2e2b:	89 e5                	mov    %esp,%ebp
    2e2d:	53                   	push   %ebx
    2e2e:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2e31:	8b 45 08             	mov    0x8(%ebp),%eax
    2e34:	8b 10                	mov    (%eax),%edx
    2e36:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e39:	8b 00                	mov    (%eax),%eax
    2e3b:	39 c2                	cmp    %eax,%edx
    2e3d:	75 10                	jne    2e4f <picTurnAround+0x25>
    2e3f:	8b 45 08             	mov    0x8(%ebp),%eax
    2e42:	8b 50 04             	mov    0x4(%eax),%edx
    2e45:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e48:	8b 40 04             	mov    0x4(%eax),%eax
    2e4b:	39 c2                	cmp    %eax,%edx
    2e4d:	74 0a                	je     2e59 <picTurnAround+0x2f>
        return 0;
    2e4f:	b8 00 00 00 00       	mov    $0x0,%eax
    2e54:	e9 88 00 00 00       	jmp    2ee1 <picTurnAround+0xb7>

    int h = src->height;
    2e59:	8b 45 08             	mov    0x8(%ebp),%eax
    2e5c:	8b 40 04             	mov    0x4(%eax),%eax
    2e5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2e62:	8b 45 08             	mov    0x8(%ebp),%eax
    2e65:	8b 00                	mov    (%eax),%eax
    2e67:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2e6a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2e71:	eb 61                	jmp    2ed4 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2e73:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2e7a:	eb 4c                	jmp    2ec8 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2e7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    2e7f:	8b 48 08             	mov    0x8(%eax),%ecx
    2e82:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2e85:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2e89:	89 c2                	mov    %eax,%edx
    2e8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2e8e:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2e91:	01 c2                	add    %eax,%edx
    2e93:	89 d0                	mov    %edx,%eax
    2e95:	01 c0                	add    %eax,%eax
    2e97:	01 d0                	add    %edx,%eax
    2e99:	83 e8 03             	sub    $0x3,%eax
    2e9c:	01 c1                	add    %eax,%ecx
    2e9e:	8b 45 08             	mov    0x8(%ebp),%eax
    2ea1:	8b 58 08             	mov    0x8(%eax),%ebx
    2ea4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ea7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2eab:	89 c2                	mov    %eax,%edx
    2ead:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2eb0:	01 c2                	add    %eax,%edx
    2eb2:	89 d0                	mov    %edx,%eax
    2eb4:	01 c0                	add    %eax,%eax
    2eb6:	01 d0                	add    %edx,%eax
    2eb8:	01 d8                	add    %ebx,%eax
    2eba:	51                   	push   %ecx
    2ebb:	50                   	push   %eax
    2ebc:	e8 ed f4 ff ff       	call   23ae <setColor>
    2ec1:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2ec4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2ec8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ecb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2ece:	7c ac                	jl     2e7c <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2ed0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2ed4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ed7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2eda:	7c 97                	jl     2e73 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2edc:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2ee1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2ee4:	c9                   	leave  
    2ee5:	c3                   	ret    

00002ee6 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2ee6:	55                   	push   %ebp
    2ee7:	89 e5                	mov    %esp,%ebp
    2ee9:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2eec:	83 ec 0c             	sub    $0xc,%esp
    2eef:	ff 75 08             	pushl  0x8(%ebp)
    2ef2:	e8 c5 d5 ff ff       	call   4bc <strlen>
    2ef7:	83 c4 10             	add    $0x10,%esp
    2efa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2efd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f00:	8d 50 ff             	lea    -0x1(%eax),%edx
    2f03:	8b 45 08             	mov    0x8(%ebp),%eax
    2f06:	01 d0                	add    %edx,%eax
    2f08:	0f b6 00             	movzbl (%eax),%eax
    2f0b:	3c 67                	cmp    $0x67,%al
    2f0d:	75 2b                	jne    2f3a <type+0x54>
    2f0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f12:	8d 50 fe             	lea    -0x2(%eax),%edx
    2f15:	8b 45 08             	mov    0x8(%ebp),%eax
    2f18:	01 d0                	add    %edx,%eax
    2f1a:	0f b6 00             	movzbl (%eax),%eax
    2f1d:	3c 70                	cmp    $0x70,%al
    2f1f:	75 19                	jne    2f3a <type+0x54>
    2f21:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f24:	8d 50 fd             	lea    -0x3(%eax),%edx
    2f27:	8b 45 08             	mov    0x8(%ebp),%eax
    2f2a:	01 d0                	add    %edx,%eax
    2f2c:	0f b6 00             	movzbl (%eax),%eax
    2f2f:	3c 6a                	cmp    $0x6a,%al
    2f31:	75 07                	jne    2f3a <type+0x54>
    2f33:	b8 00 00 00 00       	mov    $0x0,%eax
    2f38:	eb 7f                	jmp    2fb9 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2f3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f3d:	8d 50 ff             	lea    -0x1(%eax),%edx
    2f40:	8b 45 08             	mov    0x8(%ebp),%eax
    2f43:	01 d0                	add    %edx,%eax
    2f45:	0f b6 00             	movzbl (%eax),%eax
    2f48:	3c 70                	cmp    $0x70,%al
    2f4a:	75 2b                	jne    2f77 <type+0x91>
    2f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f4f:	8d 50 fe             	lea    -0x2(%eax),%edx
    2f52:	8b 45 08             	mov    0x8(%ebp),%eax
    2f55:	01 d0                	add    %edx,%eax
    2f57:	0f b6 00             	movzbl (%eax),%eax
    2f5a:	3c 6d                	cmp    $0x6d,%al
    2f5c:	75 19                	jne    2f77 <type+0x91>
    2f5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f61:	8d 50 fd             	lea    -0x3(%eax),%edx
    2f64:	8b 45 08             	mov    0x8(%ebp),%eax
    2f67:	01 d0                	add    %edx,%eax
    2f69:	0f b6 00             	movzbl (%eax),%eax
    2f6c:	3c 62                	cmp    $0x62,%al
    2f6e:	75 07                	jne    2f77 <type+0x91>
    2f70:	b8 01 00 00 00       	mov    $0x1,%eax
    2f75:	eb 42                	jmp    2fb9 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2f77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f7a:	8d 50 ff             	lea    -0x1(%eax),%edx
    2f7d:	8b 45 08             	mov    0x8(%ebp),%eax
    2f80:	01 d0                	add    %edx,%eax
    2f82:	0f b6 00             	movzbl (%eax),%eax
    2f85:	3c 67                	cmp    $0x67,%al
    2f87:	75 2b                	jne    2fb4 <type+0xce>
    2f89:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f8c:	8d 50 fe             	lea    -0x2(%eax),%edx
    2f8f:	8b 45 08             	mov    0x8(%ebp),%eax
    2f92:	01 d0                	add    %edx,%eax
    2f94:	0f b6 00             	movzbl (%eax),%eax
    2f97:	3c 6e                	cmp    $0x6e,%al
    2f99:	75 19                	jne    2fb4 <type+0xce>
    2f9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f9e:	8d 50 fd             	lea    -0x3(%eax),%edx
    2fa1:	8b 45 08             	mov    0x8(%ebp),%eax
    2fa4:	01 d0                	add    %edx,%eax
    2fa6:	0f b6 00             	movzbl (%eax),%eax
    2fa9:	3c 70                	cmp    $0x70,%al
    2fab:	75 07                	jne    2fb4 <type+0xce>
    2fad:	b8 02 00 00 00       	mov    $0x2,%eax
    2fb2:	eb 05                	jmp    2fb9 <type+0xd3>
    else return NONE;
    2fb4:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2fb9:	c9                   	leave  
    2fba:	c3                   	ret    

00002fbb <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2fbb:	55                   	push   %ebp
    2fbc:	89 e5                	mov    %esp,%ebp
    2fbe:	56                   	push   %esi
    2fbf:	53                   	push   %ebx
    2fc0:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2fc3:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2fca:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2fd1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2fd8:	83 ec 08             	sub    $0x8,%esp
    2fdb:	6a 00                	push   $0x0
    2fdd:	ff 75 0c             	pushl  0xc(%ebp)
    2fe0:	e8 d9 d6 ff ff       	call   6be <open>
    2fe5:	83 c4 10             	add    $0x10,%esp
    2fe8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2feb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2fef:	79 2c                	jns    301d <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2ff1:	83 ec 08             	sub    $0x8,%esp
    2ff4:	ff 75 0c             	pushl  0xc(%ebp)
    2ff7:	68 e8 a0 01 00       	push   $0x1a0e8
    2ffc:	e8 24 d8 ff ff       	call   825 <printf>
    3001:	83 c4 10             	add    $0x10,%esp
        return bmp;
    3004:	8b 45 08             	mov    0x8(%ebp),%eax
    3007:	8b 55 b8             	mov    -0x48(%ebp),%edx
    300a:	89 10                	mov    %edx,(%eax)
    300c:	8b 55 bc             	mov    -0x44(%ebp),%edx
    300f:	89 50 04             	mov    %edx,0x4(%eax)
    3012:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3015:	89 50 08             	mov    %edx,0x8(%eax)
    3018:	e9 2d 02 00 00       	jmp    324a <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    301d:	83 ec 04             	sub    $0x4,%esp
    3020:	6a 0e                	push   $0xe
    3022:	8d 45 aa             	lea    -0x56(%ebp),%eax
    3025:	50                   	push   %eax
    3026:	ff 75 ec             	pushl  -0x14(%ebp)
    3029:	e8 68 d6 ff ff       	call   696 <read>
    302e:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    3031:	83 ec 04             	sub    $0x4,%esp
    3034:	6a 28                	push   $0x28
    3036:	8d 45 82             	lea    -0x7e(%ebp),%eax
    3039:	50                   	push   %eax
    303a:	ff 75 ec             	pushl  -0x14(%ebp)
    303d:	e8 54 d6 ff ff       	call   696 <read>
    3042:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    3045:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    3049:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    304c:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    3050:	0f b7 d8             	movzwl %ax,%ebx
    3053:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    3056:	8b 55 ac             	mov    -0x54(%ebp),%edx
    3059:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    305d:	0f b7 c0             	movzwl %ax,%eax
    3060:	83 ec 04             	sub    $0x4,%esp
    3063:	6a 36                	push   $0x36
    3065:	56                   	push   %esi
    3066:	53                   	push   %ebx
    3067:	51                   	push   %ecx
    3068:	52                   	push   %edx
    3069:	50                   	push   %eax
    306a:	68 f8 a0 01 00       	push   $0x1a0f8
    306f:	e8 b1 d7 ff ff       	call   825 <printf>
    3074:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    3077:	8b 45 86             	mov    -0x7a(%ebp),%eax
    307a:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    307d:	8b 45 8a             	mov    -0x76(%ebp),%eax
    3080:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    3083:	8b 55 b8             	mov    -0x48(%ebp),%edx
    3086:	8b 45 bc             	mov    -0x44(%ebp),%eax
    3089:	0f af c2             	imul   %edx,%eax
    308c:	89 c2                	mov    %eax,%edx
    308e:	89 d0                	mov    %edx,%eax
    3090:	01 c0                	add    %eax,%eax
    3092:	01 d0                	add    %edx,%eax
    3094:	83 ec 0c             	sub    $0xc,%esp
    3097:	50                   	push   %eax
    3098:	e8 5b da ff ff       	call   af8 <malloc>
    309d:	83 c4 10             	add    $0x10,%esp
    30a0:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    30a3:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    30a7:	0f b7 c0             	movzwl %ax,%eax
    30aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    30ad:	8b 45 b8             	mov    -0x48(%ebp),%eax
    30b0:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    30b4:	83 c0 1f             	add    $0x1f,%eax
    30b7:	c1 f8 05             	sar    $0x5,%eax
    30ba:	c1 e0 02             	shl    $0x2,%eax
    30bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    30c0:	8b 45 bc             	mov    -0x44(%ebp),%eax
    30c3:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    30c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    30ca:	8b 55 bc             	mov    -0x44(%ebp),%edx
    30cd:	8b 45 b8             	mov    -0x48(%ebp),%eax
    30d0:	83 ec 08             	sub    $0x8,%esp
    30d3:	52                   	push   %edx
    30d4:	50                   	push   %eax
    30d5:	ff 75 e8             	pushl  -0x18(%ebp)
    30d8:	ff 75 e0             	pushl  -0x20(%ebp)
    30db:	ff 75 e4             	pushl  -0x1c(%ebp)
    30de:	68 20 a1 01 00       	push   $0x1a120
    30e3:	e8 3d d7 ff ff       	call   825 <printf>
    30e8:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    30eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    30ee:	83 e8 36             	sub    $0x36,%eax
    30f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    30f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    30f7:	83 ec 0c             	sub    $0xc,%esp
    30fa:	50                   	push   %eax
    30fb:	e8 f8 d9 ff ff       	call   af8 <malloc>
    3100:	83 c4 10             	add    $0x10,%esp
    3103:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    3106:	83 ec 04             	sub    $0x4,%esp
    3109:	ff 75 dc             	pushl  -0x24(%ebp)
    310c:	ff 75 d8             	pushl  -0x28(%ebp)
    310f:	ff 75 ec             	pushl  -0x14(%ebp)
    3112:	e8 7f d5 ff ff       	call   696 <read>
    3117:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    311a:	8b 45 ac             	mov    -0x54(%ebp),%eax
    311d:	83 ec 0c             	sub    $0xc,%esp
    3120:	50                   	push   %eax
    3121:	e8 d2 d9 ff ff       	call   af8 <malloc>
    3126:	83 c4 10             	add    $0x10,%esp
    3129:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    312c:	8b 45 ac             	mov    -0x54(%ebp),%eax
    312f:	83 ec 04             	sub    $0x4,%esp
    3132:	50                   	push   %eax
    3133:	ff 75 d4             	pushl  -0x2c(%ebp)
    3136:	ff 75 ec             	pushl  -0x14(%ebp)
    3139:	e8 58 d5 ff ff       	call   696 <read>
    313e:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    3141:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    3145:	66 c1 e8 03          	shr    $0x3,%ax
    3149:	0f b7 c0             	movzwl %ax,%eax
    314c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    314f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3156:	e9 c1 00 00 00       	jmp    321c <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    315b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    315e:	2b 45 f4             	sub    -0xc(%ebp),%eax
    3161:	8d 50 ff             	lea    -0x1(%eax),%edx
    3164:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3167:	0f af c2             	imul   %edx,%eax
    316a:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    316d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3170:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    3174:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    3177:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    317e:	e9 89 00 00 00       	jmp    320c <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    3183:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3186:	83 c0 01             	add    $0x1,%eax
    3189:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    318d:	89 c2                	mov    %eax,%edx
    318f:	8b 45 c8             	mov    -0x38(%ebp),%eax
    3192:	01 d0                	add    %edx,%eax
    3194:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    3197:	8b 55 c0             	mov    -0x40(%ebp),%edx
    319a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    319d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    31a0:	01 c8                	add    %ecx,%eax
    31a2:	89 c1                	mov    %eax,%ecx
    31a4:	89 c8                	mov    %ecx,%eax
    31a6:	01 c0                	add    %eax,%eax
    31a8:	01 c8                	add    %ecx,%eax
    31aa:	01 c2                	add    %eax,%edx
    31ac:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    31af:	8d 48 ff             	lea    -0x1(%eax),%ecx
    31b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    31b5:	01 c8                	add    %ecx,%eax
    31b7:	0f b6 00             	movzbl (%eax),%eax
    31ba:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    31bd:	8b 55 c0             	mov    -0x40(%ebp),%edx
    31c0:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    31c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    31c6:	01 c8                	add    %ecx,%eax
    31c8:	89 c1                	mov    %eax,%ecx
    31ca:	89 c8                	mov    %ecx,%eax
    31cc:	01 c0                	add    %eax,%eax
    31ce:	01 c8                	add    %ecx,%eax
    31d0:	01 c2                	add    %eax,%edx
    31d2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    31d5:	8d 48 fe             	lea    -0x2(%eax),%ecx
    31d8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    31db:	01 c8                	add    %ecx,%eax
    31dd:	0f b6 00             	movzbl (%eax),%eax
    31e0:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    31e3:	8b 55 c0             	mov    -0x40(%ebp),%edx
    31e6:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    31e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    31ec:	01 c8                	add    %ecx,%eax
    31ee:	89 c1                	mov    %eax,%ecx
    31f0:	89 c8                	mov    %ecx,%eax
    31f2:	01 c0                	add    %eax,%eax
    31f4:	01 c8                	add    %ecx,%eax
    31f6:	01 c2                	add    %eax,%edx
    31f8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    31fb:	8d 48 fd             	lea    -0x3(%eax),%ecx
    31fe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3201:	01 c8                	add    %ecx,%eax
    3203:	0f b6 00             	movzbl (%eax),%eax
    3206:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    3208:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    320c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    320f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3212:	0f 8f 6b ff ff ff    	jg     3183 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    3218:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    321c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    321f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3222:	0f 8f 33 ff ff ff    	jg     315b <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    3228:	83 ec 0c             	sub    $0xc,%esp
    322b:	ff 75 ec             	pushl  -0x14(%ebp)
    322e:	e8 73 d4 ff ff       	call   6a6 <close>
    3233:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3236:	8b 45 08             	mov    0x8(%ebp),%eax
    3239:	8b 55 b8             	mov    -0x48(%ebp),%edx
    323c:	89 10                	mov    %edx,(%eax)
    323e:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3241:	89 50 04             	mov    %edx,0x4(%eax)
    3244:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3247:	89 50 08             	mov    %edx,0x8(%eax)
}
    324a:	8b 45 08             	mov    0x8(%ebp),%eax
    324d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3250:	5b                   	pop    %ebx
    3251:	5e                   	pop    %esi
    3252:	5d                   	pop    %ebp
    3253:	c2 04 00             	ret    $0x4

00003256 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    3256:	55                   	push   %ebp
    3257:	89 e5                	mov    %esp,%ebp
    3259:	53                   	push   %ebx
    325a:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    325d:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    3261:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    3265:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    3269:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    326d:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    3271:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    3275:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    3279:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    327d:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    3281:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    3285:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    3289:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    328d:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    3291:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    3295:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    3299:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    329d:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    32a1:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    32a5:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    32a9:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    32ad:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    32b1:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    32b5:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    32b9:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    32bd:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    32c1:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    32c5:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    32c9:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    32cd:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    32d1:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    32d5:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    32d9:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    32dd:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    32e1:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    32e5:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    32e9:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    32ed:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    32f1:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    32f5:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    32f9:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    32fd:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    3301:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    3305:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    3309:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    330d:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    3311:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    3315:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    3319:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    331d:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    3321:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    3325:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    3329:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    332d:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    3331:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    3335:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    3339:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    333d:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    3341:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    3345:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    3349:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    334d:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    3351:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    3355:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    3359:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    335d:	83 ec 0c             	sub    $0xc,%esp
    3360:	68 c8 02 08 00       	push   $0x802c8
    3365:	e8 8e d7 ff ff       	call   af8 <malloc>
    336a:	83 c4 10             	add    $0x10,%esp
    336d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    3370:	83 ec 04             	sub    $0x4,%esp
    3373:	68 c8 02 08 00       	push   $0x802c8
    3378:	6a 00                	push   $0x0
    337a:	ff 75 f0             	pushl  -0x10(%ebp)
    337d:	e8 61 d1 ff ff       	call   4e3 <memset>
    3382:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    3385:	83 ec 08             	sub    $0x8,%esp
    3388:	6a 00                	push   $0x0
    338a:	ff 75 0c             	pushl  0xc(%ebp)
    338d:	e8 2c d3 ff ff       	call   6be <open>
    3392:	83 c4 10             	add    $0x10,%esp
    3395:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    3398:	83 ec 0c             	sub    $0xc,%esp
    339b:	68 40 42 0f 00       	push   $0xf4240
    33a0:	e8 53 d7 ff ff       	call   af8 <malloc>
    33a5:	83 c4 10             	add    $0x10,%esp
    33a8:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    33ab:	83 ec 04             	sub    $0x4,%esp
    33ae:	68 40 42 0f 00       	push   $0xf4240
    33b3:	ff 75 e8             	pushl  -0x18(%ebp)
    33b6:	ff 75 ec             	pushl  -0x14(%ebp)
    33b9:	e8 d8 d2 ff ff       	call   696 <read>
    33be:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    33c1:	83 ec 0c             	sub    $0xc,%esp
    33c4:	ff 75 ec             	pushl  -0x14(%ebp)
    33c7:	e8 da d2 ff ff       	call   6a6 <close>
    33cc:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    33cf:	68 40 42 0f 00       	push   $0xf4240
    33d4:	ff 75 e8             	pushl  -0x18(%ebp)
    33d7:	8d 45 9c             	lea    -0x64(%ebp),%eax
    33da:	50                   	push   %eax
    33db:	ff 75 f0             	pushl  -0x10(%ebp)
    33de:	e8 5e 0c 01 00       	call   14041 <_DecodeJPEG>
    33e3:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    33e6:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    33ed:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    33f4:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    33fb:	83 ec 0c             	sub    $0xc,%esp
    33fe:	ff 75 f0             	pushl  -0x10(%ebp)
    3401:	e8 29 0b 01 00       	call   13f2f <GetImageSize>
    3406:	83 c4 10             	add    $0x10,%esp
    3409:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    340c:	83 ec 0c             	sub    $0xc,%esp
    340f:	ff 75 f0             	pushl  -0x10(%ebp)
    3412:	e8 e1 0a 01 00       	call   13ef8 <GetImage>
    3417:	83 c4 10             	add    $0x10,%esp
    341a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    341d:	83 ec 0c             	sub    $0xc,%esp
    3420:	ff 75 f0             	pushl  -0x10(%ebp)
    3423:	e8 f1 0a 01 00       	call   13f19 <GetWidth>
    3428:	83 c4 10             	add    $0x10,%esp
    342b:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    342e:	83 ec 0c             	sub    $0xc,%esp
    3431:	ff 75 f0             	pushl  -0x10(%ebp)
    3434:	e8 eb 0a 01 00       	call   13f24 <GetHeight>
    3439:	83 c4 10             	add    $0x10,%esp
    343c:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    343f:	8b 55 90             	mov    -0x70(%ebp),%edx
    3442:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3445:	0f af c2             	imul   %edx,%eax
    3448:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    344b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    344e:	89 d0                	mov    %edx,%eax
    3450:	01 c0                	add    %eax,%eax
    3452:	01 d0                	add    %edx,%eax
    3454:	83 ec 0c             	sub    $0xc,%esp
    3457:	50                   	push   %eax
    3458:	e8 9b d6 ff ff       	call   af8 <malloc>
    345d:	83 c4 10             	add    $0x10,%esp
    3460:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    3463:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    346a:	e9 9c 00 00 00       	jmp    350b <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    346f:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3472:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3475:	ba 56 55 55 55       	mov    $0x55555556,%edx
    347a:	89 c8                	mov    %ecx,%eax
    347c:	f7 ea                	imul   %edx
    347e:	89 c8                	mov    %ecx,%eax
    3480:	c1 f8 1f             	sar    $0x1f,%eax
    3483:	29 c2                	sub    %eax,%edx
    3485:	89 d0                	mov    %edx,%eax
    3487:	89 c2                	mov    %eax,%edx
    3489:	89 d0                	mov    %edx,%eax
    348b:	01 c0                	add    %eax,%eax
    348d:	01 d0                	add    %edx,%eax
    348f:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3492:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3495:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3498:	01 c8                	add    %ecx,%eax
    349a:	0f b6 00             	movzbl (%eax),%eax
    349d:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    34a0:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    34a3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    34a6:	ba 56 55 55 55       	mov    $0x55555556,%edx
    34ab:	89 c8                	mov    %ecx,%eax
    34ad:	f7 ea                	imul   %edx
    34af:	89 c8                	mov    %ecx,%eax
    34b1:	c1 f8 1f             	sar    $0x1f,%eax
    34b4:	29 c2                	sub    %eax,%edx
    34b6:	89 d0                	mov    %edx,%eax
    34b8:	89 c2                	mov    %eax,%edx
    34ba:	89 d0                	mov    %edx,%eax
    34bc:	01 c0                	add    %eax,%eax
    34be:	01 d0                	add    %edx,%eax
    34c0:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    34c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    34c6:	8d 48 01             	lea    0x1(%eax),%ecx
    34c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    34cc:	01 c8                	add    %ecx,%eax
    34ce:	0f b6 00             	movzbl (%eax),%eax
    34d1:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    34d4:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    34d7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    34da:	ba 56 55 55 55       	mov    $0x55555556,%edx
    34df:	89 c8                	mov    %ecx,%eax
    34e1:	f7 ea                	imul   %edx
    34e3:	89 c8                	mov    %ecx,%eax
    34e5:	c1 f8 1f             	sar    $0x1f,%eax
    34e8:	29 c2                	sub    %eax,%edx
    34ea:	89 d0                	mov    %edx,%eax
    34ec:	89 c2                	mov    %eax,%edx
    34ee:	89 d0                	mov    %edx,%eax
    34f0:	01 c0                	add    %eax,%eax
    34f2:	01 d0                	add    %edx,%eax
    34f4:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    34f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    34fa:	8d 48 02             	lea    0x2(%eax),%ecx
    34fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3500:	01 c8                	add    %ecx,%eax
    3502:	0f b6 00             	movzbl (%eax),%eax
    3505:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3507:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    350b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    350e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    3511:	0f 8c 58 ff ff ff    	jl     346f <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3517:	8b 45 08             	mov    0x8(%ebp),%eax
    351a:	8b 55 90             	mov    -0x70(%ebp),%edx
    351d:	89 10                	mov    %edx,(%eax)
    351f:	8b 55 94             	mov    -0x6c(%ebp),%edx
    3522:	89 50 04             	mov    %edx,0x4(%eax)
    3525:	8b 55 98             	mov    -0x68(%ebp),%edx
    3528:	89 50 08             	mov    %edx,0x8(%eax)
}
    352b:	8b 45 08             	mov    0x8(%ebp),%eax
    352e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3531:	c9                   	leave  
    3532:	c2 04 00             	ret    $0x4

00003535 <LoadPng>:

PBitmap LoadPng(char* filename){
    3535:	55                   	push   %ebp
    3536:	89 e5                	mov    %esp,%ebp
    3538:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    353b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    3542:	ff 75 0c             	pushl  0xc(%ebp)
    3545:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3548:	50                   	push   %eax
    3549:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    354c:	50                   	push   %eax
    354d:	8d 45 e8             	lea    -0x18(%ebp),%eax
    3550:	50                   	push   %eax
    3551:	e8 d3 d3 00 00       	call   10929 <lodepng_decode24_file>
    3556:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3559:	8b 45 e0             	mov    -0x20(%ebp),%eax
    355c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    355f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3562:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    3565:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    356c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    356f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3572:	0f af c2             	imul   %edx,%eax
    3575:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    3578:	8b 55 f0             	mov    -0x10(%ebp),%edx
    357b:	89 d0                	mov    %edx,%eax
    357d:	01 c0                	add    %eax,%eax
    357f:	01 d0                	add    %edx,%eax
    3581:	83 ec 0c             	sub    $0xc,%esp
    3584:	50                   	push   %eax
    3585:	e8 6e d5 ff ff       	call   af8 <malloc>
    358a:	83 c4 10             	add    $0x10,%esp
    358d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3590:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3597:	e9 87 00 00 00       	jmp    3623 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    359c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    359f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    35a2:	89 d0                	mov    %edx,%eax
    35a4:	01 c0                	add    %eax,%eax
    35a6:	01 d0                	add    %edx,%eax
    35a8:	01 c8                	add    %ecx,%eax
    35aa:	0f b6 00             	movzbl (%eax),%eax
    35ad:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    35b0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    35b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    35b6:	89 d0                	mov    %edx,%eax
    35b8:	01 c0                	add    %eax,%eax
    35ba:	01 d0                	add    %edx,%eax
    35bc:	83 c0 01             	add    $0x1,%eax
    35bf:	01 c8                	add    %ecx,%eax
    35c1:	0f b6 00             	movzbl (%eax),%eax
    35c4:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    35c7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    35ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    35cd:	89 d0                	mov    %edx,%eax
    35cf:	01 c0                	add    %eax,%eax
    35d1:	01 d0                	add    %edx,%eax
    35d3:	83 c0 02             	add    $0x2,%eax
    35d6:	01 c8                	add    %ecx,%eax
    35d8:	0f b6 00             	movzbl (%eax),%eax
    35db:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    35de:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    35e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    35e4:	89 d0                	mov    %edx,%eax
    35e6:	01 c0                	add    %eax,%eax
    35e8:	01 d0                	add    %edx,%eax
    35ea:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    35ed:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    35f1:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    35f4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    35f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    35fa:	89 d0                	mov    %edx,%eax
    35fc:	01 c0                	add    %eax,%eax
    35fe:	01 d0                	add    %edx,%eax
    3600:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3603:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3607:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    360a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    360d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3610:	89 d0                	mov    %edx,%eax
    3612:	01 c0                	add    %eax,%eax
    3614:	01 d0                	add    %edx,%eax
    3616:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3619:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    361d:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    361f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3623:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3626:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3629:	0f 8c 6d ff ff ff    	jl     359c <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    362f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3632:	83 ec 0c             	sub    $0xc,%esp
    3635:	50                   	push   %eax
    3636:	e8 7b d3 ff ff       	call   9b6 <free>
    363b:	83 c4 10             	add    $0x10,%esp
    return bmp;
    363e:	8b 45 08             	mov    0x8(%ebp),%eax
    3641:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3644:	89 10                	mov    %edx,(%eax)
    3646:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3649:	89 50 04             	mov    %edx,0x4(%eax)
    364c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    364f:	89 50 08             	mov    %edx,0x8(%eax)

}
    3652:	8b 45 08             	mov    0x8(%ebp),%eax
    3655:	c9                   	leave  
    3656:	c2 04 00             	ret    $0x4

00003659 <LoadImg>:

PBitmap LoadImg(char* filename){
    3659:	55                   	push   %ebp
    365a:	89 e5                	mov    %esp,%ebp
    365c:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    365f:	83 ec 0c             	sub    $0xc,%esp
    3662:	ff 75 0c             	pushl  0xc(%ebp)
    3665:	e8 7c f8 ff ff       	call   2ee6 <type>
    366a:	83 c4 10             	add    $0x10,%esp
    366d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    3670:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3673:	83 f8 01             	cmp    $0x1,%eax
    3676:	74 1d                	je     3695 <LoadImg+0x3c>
    3678:	83 f8 02             	cmp    $0x2,%eax
    367b:	74 2c                	je     36a9 <LoadImg+0x50>
    367d:	85 c0                	test   %eax,%eax
    367f:	75 3c                	jne    36bd <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    3681:	8b 45 08             	mov    0x8(%ebp),%eax
    3684:	83 ec 08             	sub    $0x8,%esp
    3687:	ff 75 0c             	pushl  0xc(%ebp)
    368a:	50                   	push   %eax
    368b:	e8 c6 fb ff ff       	call   3256 <LoadJpeg>
    3690:	83 c4 0c             	add    $0xc,%esp
    3693:	eb 3c                	jmp    36d1 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    3695:	8b 45 08             	mov    0x8(%ebp),%eax
    3698:	83 ec 08             	sub    $0x8,%esp
    369b:	ff 75 0c             	pushl  0xc(%ebp)
    369e:	50                   	push   %eax
    369f:	e8 17 f9 ff ff       	call   2fbb <LoadBmp>
    36a4:	83 c4 0c             	add    $0xc,%esp
    36a7:	eb 28                	jmp    36d1 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    36a9:	8b 45 08             	mov    0x8(%ebp),%eax
    36ac:	83 ec 08             	sub    $0x8,%esp
    36af:	ff 75 0c             	pushl  0xc(%ebp)
    36b2:	50                   	push   %eax
    36b3:	e8 7d fe ff ff       	call   3535 <LoadPng>
    36b8:	83 c4 0c             	add    $0xc,%esp
    36bb:	eb 14                	jmp    36d1 <LoadImg+0x78>

        default: return bmp;
    36bd:	8b 45 08             	mov    0x8(%ebp),%eax
    36c0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    36c3:	89 10                	mov    %edx,(%eax)
    36c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    36c8:	89 50 04             	mov    %edx,0x4(%eax)
    36cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    36ce:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    36d1:	8b 45 08             	mov    0x8(%ebp),%eax
    36d4:	c9                   	leave  
    36d5:	c2 04 00             	ret    $0x4

000036d8 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    36d8:	55                   	push   %ebp
    36d9:	89 e5                	mov    %esp,%ebp
    36db:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    36de:	8b 45 08             	mov    0x8(%ebp),%eax
    36e1:	83 ec 0c             	sub    $0xc,%esp
    36e4:	50                   	push   %eax
    36e5:	e8 0e d4 ff ff       	call   af8 <malloc>
    36ea:	83 c4 10             	add    $0x10,%esp
}
    36ed:	c9                   	leave  
    36ee:	c3                   	ret    

000036ef <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    36ef:	55                   	push   %ebp
    36f0:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    36f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    36f7:	5d                   	pop    %ebp
    36f8:	c3                   	ret    

000036f9 <lodepng_free>:

static void lodepng_free(void* ptr) {
    36f9:	55                   	push   %ebp
    36fa:	89 e5                	mov    %esp,%ebp
    36fc:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    36ff:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3703:	74 0e                	je     3713 <lodepng_free+0x1a>
    free(ptr);
    3705:	83 ec 0c             	sub    $0xc,%esp
    3708:	ff 75 08             	pushl  0x8(%ebp)
    370b:	e8 a6 d2 ff ff       	call   9b6 <free>
    3710:	83 c4 10             	add    $0x10,%esp
}
    3713:	90                   	nop
    3714:	c9                   	leave  
    3715:	c3                   	ret    

00003716 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3716:	55                   	push   %ebp
    3717:	89 e5                	mov    %esp,%ebp
    3719:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    371c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3723:	eb 19                	jmp    373e <lodepng_memcpy+0x28>
    3725:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3728:	8b 45 08             	mov    0x8(%ebp),%eax
    372b:	01 c2                	add    %eax,%edx
    372d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3730:	8b 45 0c             	mov    0xc(%ebp),%eax
    3733:	01 c8                	add    %ecx,%eax
    3735:	0f b6 00             	movzbl (%eax),%eax
    3738:	88 02                	mov    %al,(%edx)
    373a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    373e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3741:	3b 45 10             	cmp    0x10(%ebp),%eax
    3744:	7c df                	jl     3725 <lodepng_memcpy+0xf>
}
    3746:	90                   	nop
    3747:	c9                   	leave  
    3748:	c3                   	ret    

00003749 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3749:	55                   	push   %ebp
    374a:	89 e5                	mov    %esp,%ebp
    374c:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    374f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3756:	eb 11                	jmp    3769 <lodepng_memset+0x20>
    3758:	8b 55 fc             	mov    -0x4(%ebp),%edx
    375b:	8b 45 08             	mov    0x8(%ebp),%eax
    375e:	01 d0                	add    %edx,%eax
    3760:	8b 55 0c             	mov    0xc(%ebp),%edx
    3763:	88 10                	mov    %dl,(%eax)
    3765:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3769:	8b 45 fc             	mov    -0x4(%ebp),%eax
    376c:	3b 45 10             	cmp    0x10(%ebp),%eax
    376f:	7c e7                	jl     3758 <lodepng_memset+0xf>
}
    3771:	90                   	nop
    3772:	c9                   	leave  
    3773:	c3                   	ret    

00003774 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    3774:	55                   	push   %ebp
    3775:	89 e5                	mov    %esp,%ebp
    3777:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    377a:	8b 45 08             	mov    0x8(%ebp),%eax
    377d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    3780:	eb 04                	jmp    3786 <lodepng_strlen+0x12>
    3782:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    3786:	8b 45 08             	mov    0x8(%ebp),%eax
    3789:	0f b6 00             	movzbl (%eax),%eax
    378c:	84 c0                	test   %al,%al
    378e:	75 f2                	jne    3782 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    3790:	8b 55 08             	mov    0x8(%ebp),%edx
    3793:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3796:	29 c2                	sub    %eax,%edx
    3798:	89 d0                	mov    %edx,%eax
}
    379a:	c9                   	leave  
    379b:	c3                   	ret    

0000379c <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    379c:	55                   	push   %ebp
    379d:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    379f:	8b 55 08             	mov    0x8(%ebp),%edx
    37a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    37a5:	01 c2                	add    %eax,%edx
    37a7:	8b 45 10             	mov    0x10(%ebp),%eax
    37aa:	89 10                	mov    %edx,(%eax)
  return *result < a;
    37ac:	8b 45 10             	mov    0x10(%ebp),%eax
    37af:	8b 00                	mov    (%eax),%eax
    37b1:	3b 45 08             	cmp    0x8(%ebp),%eax
    37b4:	0f 9c c0             	setl   %al
    37b7:	0f b6 c0             	movzbl %al,%eax
}
    37ba:	5d                   	pop    %ebp
    37bb:	c3                   	ret    

000037bc <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    37bc:	55                   	push   %ebp
    37bd:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    37bf:	8b 45 08             	mov    0x8(%ebp),%eax
    37c2:	0f af 45 0c          	imul   0xc(%ebp),%eax
    37c6:	89 c2                	mov    %eax,%edx
    37c8:	8b 45 10             	mov    0x10(%ebp),%eax
    37cb:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    37cd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    37d1:	74 15                	je     37e8 <lodepng_mulofl+0x2c>
    37d3:	8b 45 10             	mov    0x10(%ebp),%eax
    37d6:	8b 00                	mov    (%eax),%eax
    37d8:	99                   	cltd   
    37d9:	f7 7d 08             	idivl  0x8(%ebp)
    37dc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    37df:	74 07                	je     37e8 <lodepng_mulofl+0x2c>
    37e1:	b8 01 00 00 00       	mov    $0x1,%eax
    37e6:	eb 05                	jmp    37ed <lodepng_mulofl+0x31>
    37e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    37ed:	5d                   	pop    %ebp
    37ee:	c3                   	ret    

000037ef <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    37ef:	55                   	push   %ebp
    37f0:	89 e5                	mov    %esp,%ebp
    37f2:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    37f5:	8d 45 fc             	lea    -0x4(%ebp),%eax
    37f8:	50                   	push   %eax
    37f9:	ff 75 0c             	pushl  0xc(%ebp)
    37fc:	ff 75 08             	pushl  0x8(%ebp)
    37ff:	e8 98 ff ff ff       	call   379c <lodepng_addofl>
    3804:	83 c4 0c             	add    $0xc,%esp
    3807:	85 c0                	test   %eax,%eax
    3809:	74 07                	je     3812 <lodepng_gtofl+0x23>
    380b:	b8 01 00 00 00       	mov    $0x1,%eax
    3810:	eb 0c                	jmp    381e <lodepng_gtofl+0x2f>
  return d > c;
    3812:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3815:	3b 45 10             	cmp    0x10(%ebp),%eax
    3818:	0f 9f c0             	setg   %al
    381b:	0f b6 c0             	movzbl %al,%eax
}
    381e:	c9                   	leave  
    381f:	c3                   	ret    

00003820 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    3820:	55                   	push   %ebp
    3821:	89 e5                	mov    %esp,%ebp
    3823:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3826:	8b 45 08             	mov    0x8(%ebp),%eax
    3829:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3830:	8b 45 08             	mov    0x8(%ebp),%eax
    3833:	8b 50 08             	mov    0x8(%eax),%edx
    3836:	8b 45 08             	mov    0x8(%ebp),%eax
    3839:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    383c:	8b 45 08             	mov    0x8(%ebp),%eax
    383f:	8b 00                	mov    (%eax),%eax
    3841:	83 ec 0c             	sub    $0xc,%esp
    3844:	50                   	push   %eax
    3845:	e8 af fe ff ff       	call   36f9 <lodepng_free>
    384a:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    384d:	8b 45 08             	mov    0x8(%ebp),%eax
    3850:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3856:	90                   	nop
    3857:	c9                   	leave  
    3858:	c3                   	ret    

00003859 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3859:	55                   	push   %ebp
    385a:	89 e5                	mov    %esp,%ebp
    385c:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    385f:	8b 45 0c             	mov    0xc(%ebp),%eax
    3862:	c1 e0 02             	shl    $0x2,%eax
    3865:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    3868:	8b 45 08             	mov    0x8(%ebp),%eax
    386b:	8b 40 08             	mov    0x8(%eax),%eax
    386e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3871:	7d 46                	jge    38b9 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    3873:	8b 45 08             	mov    0x8(%ebp),%eax
    3876:	8b 40 08             	mov    0x8(%eax),%eax
    3879:	d1 f8                	sar    %eax
    387b:	89 c2                	mov    %eax,%edx
    387d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3880:	01 d0                	add    %edx,%eax
    3882:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3885:	8b 45 08             	mov    0x8(%ebp),%eax
    3888:	8b 00                	mov    (%eax),%eax
    388a:	ff 75 f8             	pushl  -0x8(%ebp)
    388d:	50                   	push   %eax
    388e:	e8 5c fe ff ff       	call   36ef <lodepng_realloc>
    3893:	83 c4 08             	add    $0x8,%esp
    3896:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    3899:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    389d:	74 13                	je     38b2 <uivector_resize+0x59>
      p->allocsize = newsize;
    389f:	8b 45 08             	mov    0x8(%ebp),%eax
    38a2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    38a5:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    38a8:	8b 45 08             	mov    0x8(%ebp),%eax
    38ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    38ae:	89 10                	mov    %edx,(%eax)
    38b0:	eb 07                	jmp    38b9 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    38b2:	b8 00 00 00 00       	mov    $0x0,%eax
    38b7:	eb 0e                	jmp    38c7 <uivector_resize+0x6e>
  }
  p->size = size;
    38b9:	8b 45 08             	mov    0x8(%ebp),%eax
    38bc:	8b 55 0c             	mov    0xc(%ebp),%edx
    38bf:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    38c2:	b8 01 00 00 00       	mov    $0x1,%eax
}
    38c7:	c9                   	leave  
    38c8:	c3                   	ret    

000038c9 <uivector_init>:

static void uivector_init(uivector* p) {
    38c9:	55                   	push   %ebp
    38ca:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    38cc:	8b 45 08             	mov    0x8(%ebp),%eax
    38cf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    38d5:	8b 45 08             	mov    0x8(%ebp),%eax
    38d8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    38df:	8b 45 08             	mov    0x8(%ebp),%eax
    38e2:	8b 50 08             	mov    0x8(%eax),%edx
    38e5:	8b 45 08             	mov    0x8(%ebp),%eax
    38e8:	89 50 04             	mov    %edx,0x4(%eax)
}
    38eb:	90                   	nop
    38ec:	5d                   	pop    %ebp
    38ed:	c3                   	ret    

000038ee <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    38ee:	55                   	push   %ebp
    38ef:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    38f1:	8b 45 08             	mov    0x8(%ebp),%eax
    38f4:	8b 40 04             	mov    0x4(%eax),%eax
    38f7:	83 c0 01             	add    $0x1,%eax
    38fa:	50                   	push   %eax
    38fb:	ff 75 08             	pushl  0x8(%ebp)
    38fe:	e8 56 ff ff ff       	call   3859 <uivector_resize>
    3903:	83 c4 08             	add    $0x8,%esp
    3906:	85 c0                	test   %eax,%eax
    3908:	75 07                	jne    3911 <uivector_push_back+0x23>
    390a:	b8 00 00 00 00       	mov    $0x0,%eax
    390f:	eb 1f                	jmp    3930 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    3911:	8b 45 08             	mov    0x8(%ebp),%eax
    3914:	8b 10                	mov    (%eax),%edx
    3916:	8b 45 08             	mov    0x8(%ebp),%eax
    3919:	8b 40 04             	mov    0x4(%eax),%eax
    391c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    3921:	c1 e0 02             	shl    $0x2,%eax
    3924:	01 c2                	add    %eax,%edx
    3926:	8b 45 0c             	mov    0xc(%ebp),%eax
    3929:	89 02                	mov    %eax,(%edx)
  return 1;
    392b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3930:	c9                   	leave  
    3931:	c3                   	ret    

00003932 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    3932:	55                   	push   %ebp
    3933:	89 e5                	mov    %esp,%ebp
    3935:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3938:	8b 45 08             	mov    0x8(%ebp),%eax
    393b:	8b 40 08             	mov    0x8(%eax),%eax
    393e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3941:	7d 46                	jge    3989 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    3943:	8b 45 08             	mov    0x8(%ebp),%eax
    3946:	8b 40 08             	mov    0x8(%eax),%eax
    3949:	d1 f8                	sar    %eax
    394b:	89 c2                	mov    %eax,%edx
    394d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3950:	01 d0                	add    %edx,%eax
    3952:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3955:	8b 45 08             	mov    0x8(%ebp),%eax
    3958:	8b 00                	mov    (%eax),%eax
    395a:	ff 75 fc             	pushl  -0x4(%ebp)
    395d:	50                   	push   %eax
    395e:	e8 8c fd ff ff       	call   36ef <lodepng_realloc>
    3963:	83 c4 08             	add    $0x8,%esp
    3966:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    3969:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    396d:	74 13                	je     3982 <ucvector_resize+0x50>
      p->allocsize = newsize;
    396f:	8b 45 08             	mov    0x8(%ebp),%eax
    3972:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3975:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    3978:	8b 45 08             	mov    0x8(%ebp),%eax
    397b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    397e:	89 10                	mov    %edx,(%eax)
    3980:	eb 07                	jmp    3989 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    3982:	b8 00 00 00 00       	mov    $0x0,%eax
    3987:	eb 0e                	jmp    3997 <ucvector_resize+0x65>
  }
  p->size = size;
    3989:	8b 45 08             	mov    0x8(%ebp),%eax
    398c:	8b 55 0c             	mov    0xc(%ebp),%edx
    398f:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3992:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3997:	c9                   	leave  
    3998:	c3                   	ret    

00003999 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    3999:	55                   	push   %ebp
    399a:	89 e5                	mov    %esp,%ebp
    399c:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    399f:	8b 45 0c             	mov    0xc(%ebp),%eax
    39a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    39a5:	8b 45 10             	mov    0x10(%ebp),%eax
    39a8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    39ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
    39ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    39b1:	8b 45 08             	mov    0x8(%ebp),%eax
    39b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    39b7:	89 10                	mov    %edx,(%eax)
    39b9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    39bc:	89 50 04             	mov    %edx,0x4(%eax)
    39bf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    39c2:	89 50 08             	mov    %edx,0x8(%eax)
}
    39c5:	8b 45 08             	mov    0x8(%ebp),%eax
    39c8:	c9                   	leave  
    39c9:	c2 04 00             	ret    $0x4

000039cc <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    39cc:	55                   	push   %ebp
    39cd:	89 e5                	mov    %esp,%ebp
    39cf:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    39d2:	8b 45 08             	mov    0x8(%ebp),%eax
    39d5:	8b 00                	mov    (%eax),%eax
    39d7:	83 ec 0c             	sub    $0xc,%esp
    39da:	50                   	push   %eax
    39db:	e8 19 fd ff ff       	call   36f9 <lodepng_free>
    39e0:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    39e3:	8b 45 08             	mov    0x8(%ebp),%eax
    39e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    39ec:	90                   	nop
    39ed:	c9                   	leave  
    39ee:	c3                   	ret    

000039ef <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    39ef:	55                   	push   %ebp
    39f0:	89 e5                	mov    %esp,%ebp
    39f2:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    39f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    39f8:	83 c0 01             	add    $0x1,%eax
    39fb:	83 ec 0c             	sub    $0xc,%esp
    39fe:	50                   	push   %eax
    39ff:	e8 d4 fc ff ff       	call   36d8 <lodepng_malloc>
    3a04:	83 c4 10             	add    $0x10,%esp
    3a07:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3a0a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3a0e:	74 1f                	je     3a2f <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    3a10:	83 ec 04             	sub    $0x4,%esp
    3a13:	ff 75 0c             	pushl  0xc(%ebp)
    3a16:	ff 75 08             	pushl  0x8(%ebp)
    3a19:	ff 75 f4             	pushl  -0xc(%ebp)
    3a1c:	e8 f5 fc ff ff       	call   3716 <lodepng_memcpy>
    3a21:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    3a24:	8b 55 0c             	mov    0xc(%ebp),%edx
    3a27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a2a:	01 d0                	add    %edx,%eax
    3a2c:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    3a2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3a32:	c9                   	leave  
    3a33:	c3                   	ret    

00003a34 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    3a34:	55                   	push   %ebp
    3a35:	89 e5                	mov    %esp,%ebp
    3a37:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3a3a:	ff 75 08             	pushl  0x8(%ebp)
    3a3d:	e8 32 fd ff ff       	call   3774 <lodepng_strlen>
    3a42:	83 c4 04             	add    $0x4,%esp
    3a45:	83 ec 08             	sub    $0x8,%esp
    3a48:	50                   	push   %eax
    3a49:	ff 75 08             	pushl  0x8(%ebp)
    3a4c:	e8 9e ff ff ff       	call   39ef <alloc_string_sized>
    3a51:	83 c4 10             	add    $0x10,%esp
}
    3a54:	c9                   	leave  
    3a55:	c3                   	ret    

00003a56 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    3a56:	55                   	push   %ebp
    3a57:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3a59:	8b 45 08             	mov    0x8(%ebp),%eax
    3a5c:	0f b6 00             	movzbl (%eax),%eax
    3a5f:	0f b6 c0             	movzbl %al,%eax
    3a62:	c1 e0 18             	shl    $0x18,%eax
    3a65:	89 c2                	mov    %eax,%edx
    3a67:	8b 45 08             	mov    0x8(%ebp),%eax
    3a6a:	83 c0 01             	add    $0x1,%eax
    3a6d:	0f b6 00             	movzbl (%eax),%eax
    3a70:	0f b6 c0             	movzbl %al,%eax
    3a73:	c1 e0 10             	shl    $0x10,%eax
    3a76:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3a78:	8b 45 08             	mov    0x8(%ebp),%eax
    3a7b:	83 c0 02             	add    $0x2,%eax
    3a7e:	0f b6 00             	movzbl (%eax),%eax
    3a81:	0f b6 c0             	movzbl %al,%eax
    3a84:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3a87:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3a89:	8b 45 08             	mov    0x8(%ebp),%eax
    3a8c:	83 c0 03             	add    $0x3,%eax
    3a8f:	0f b6 00             	movzbl (%eax),%eax
    3a92:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3a95:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    3a97:	5d                   	pop    %ebp
    3a98:	c3                   	ret    

00003a99 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    3a99:	55                   	push   %ebp
    3a9a:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    3a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a9f:	c1 e8 18             	shr    $0x18,%eax
    3aa2:	89 c2                	mov    %eax,%edx
    3aa4:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa7:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    3aa9:	8b 45 08             	mov    0x8(%ebp),%eax
    3aac:	83 c0 01             	add    $0x1,%eax
    3aaf:	8b 55 0c             	mov    0xc(%ebp),%edx
    3ab2:	c1 ea 10             	shr    $0x10,%edx
    3ab5:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    3ab7:	8b 45 08             	mov    0x8(%ebp),%eax
    3aba:	83 c0 02             	add    $0x2,%eax
    3abd:	8b 55 0c             	mov    0xc(%ebp),%edx
    3ac0:	c1 ea 08             	shr    $0x8,%edx
    3ac3:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    3ac5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac8:	83 c0 03             	add    $0x3,%eax
    3acb:	8b 55 0c             	mov    0xc(%ebp),%edx
    3ace:	88 10                	mov    %dl,(%eax)
}
    3ad0:	90                   	nop
    3ad1:	5d                   	pop    %ebp
    3ad2:	c3                   	ret    

00003ad3 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    3ad3:	55                   	push   %ebp
    3ad4:	89 e5                	mov    %esp,%ebp
    3ad6:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    3ad9:	83 ec 08             	sub    $0x8,%esp
    3adc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3adf:	50                   	push   %eax
    3ae0:	ff 75 08             	pushl  0x8(%ebp)
    3ae3:	e8 b7 ca ff ff       	call   59f <stat>
    3ae8:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3aee:	c9                   	leave  
    3aef:	c3                   	ret    

00003af0 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    3af0:	55                   	push   %ebp
    3af1:	89 e5                	mov    %esp,%ebp
    3af3:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3af6:	83 ec 08             	sub    $0x8,%esp
    3af9:	6a 00                	push   $0x0
    3afb:	ff 75 10             	pushl  0x10(%ebp)
    3afe:	e8 bb cb ff ff       	call   6be <open>
    3b03:	83 c4 10             	add    $0x10,%esp
    3b06:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3b09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3b0d:	79 07                	jns    3b16 <lodepng_buffer_file+0x26>
  {
      return -1;
    3b0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3b14:	eb 19                	jmp    3b2f <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3b16:	83 ec 04             	sub    $0x4,%esp
    3b19:	ff 75 0c             	pushl  0xc(%ebp)
    3b1c:	ff 75 08             	pushl  0x8(%ebp)
    3b1f:	ff 75 f4             	pushl  -0xc(%ebp)
    3b22:	e8 6f cb ff ff       	call   696 <read>
    3b27:	83 c4 10             	add    $0x10,%esp
  return 0;
    3b2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3b2f:	c9                   	leave  
    3b30:	c3                   	ret    

00003b31 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    3b31:	55                   	push   %ebp
    3b32:	89 e5                	mov    %esp,%ebp
    3b34:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3b37:	83 ec 0c             	sub    $0xc,%esp
    3b3a:	ff 75 10             	pushl  0x10(%ebp)
    3b3d:	e8 91 ff ff ff       	call   3ad3 <lodepng_filesize>
    3b42:	83 c4 10             	add    $0x10,%esp
    3b45:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3b48:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3b4c:	79 07                	jns    3b55 <lodepng_load_file+0x24>
    3b4e:	b8 4e 00 00 00       	mov    $0x4e,%eax
    3b53:	eb 4a                	jmp    3b9f <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    3b55:	8b 45 0c             	mov    0xc(%ebp),%eax
    3b58:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3b5b:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3b5d:	83 ec 0c             	sub    $0xc,%esp
    3b60:	ff 75 f4             	pushl  -0xc(%ebp)
    3b63:	e8 70 fb ff ff       	call   36d8 <lodepng_malloc>
    3b68:	83 c4 10             	add    $0x10,%esp
    3b6b:	89 c2                	mov    %eax,%edx
    3b6d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b70:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    3b72:	8b 45 08             	mov    0x8(%ebp),%eax
    3b75:	8b 00                	mov    (%eax),%eax
    3b77:	85 c0                	test   %eax,%eax
    3b79:	75 0d                	jne    3b88 <lodepng_load_file+0x57>
    3b7b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3b7f:	7e 07                	jle    3b88 <lodepng_load_file+0x57>
    3b81:	b8 53 00 00 00       	mov    $0x53,%eax
    3b86:	eb 17                	jmp    3b9f <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    3b88:	8b 45 08             	mov    0x8(%ebp),%eax
    3b8b:	8b 00                	mov    (%eax),%eax
    3b8d:	83 ec 04             	sub    $0x4,%esp
    3b90:	ff 75 10             	pushl  0x10(%ebp)
    3b93:	ff 75 f4             	pushl  -0xc(%ebp)
    3b96:	50                   	push   %eax
    3b97:	e8 54 ff ff ff       	call   3af0 <lodepng_buffer_file>
    3b9c:	83 c4 10             	add    $0x10,%esp
}
    3b9f:	c9                   	leave  
    3ba0:	c3                   	ret    

00003ba1 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    3ba1:	55                   	push   %ebp
    3ba2:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    3ba4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3ba9:	5d                   	pop    %ebp
    3baa:	c3                   	ret    

00003bab <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3bab:	55                   	push   %ebp
    3bac:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3bae:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb1:	8b 55 0c             	mov    0xc(%ebp),%edx
    3bb4:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    3bb6:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb9:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3bbd:	90                   	nop
    3bbe:	5d                   	pop    %ebp
    3bbf:	c3                   	ret    

00003bc0 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3bc0:	55                   	push   %ebp
    3bc1:	89 e5                	mov    %esp,%ebp
    3bc3:	56                   	push   %esi
    3bc4:	53                   	push   %ebx
    3bc5:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3bc8:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3bcc:	0f 85 aa 00 00 00    	jne    3c7c <writeBits+0xbc>
    WRITEBIT(writer, value);
    3bd2:	8b 45 08             	mov    0x8(%ebp),%eax
    3bd5:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3bd9:	0f b6 c0             	movzbl %al,%eax
    3bdc:	83 e0 07             	and    $0x7,%eax
    3bdf:	85 c0                	test   %eax,%eax
    3be1:	75 39                	jne    3c1c <writeBits+0x5c>
    3be3:	8b 45 08             	mov    0x8(%ebp),%eax
    3be6:	8b 00                	mov    (%eax),%eax
    3be8:	8b 40 04             	mov    0x4(%eax),%eax
    3beb:	8d 50 01             	lea    0x1(%eax),%edx
    3bee:	8b 45 08             	mov    0x8(%ebp),%eax
    3bf1:	8b 00                	mov    (%eax),%eax
    3bf3:	52                   	push   %edx
    3bf4:	50                   	push   %eax
    3bf5:	e8 38 fd ff ff       	call   3932 <ucvector_resize>
    3bfa:	83 c4 08             	add    $0x8,%esp
    3bfd:	85 c0                	test   %eax,%eax
    3bff:	0f 84 44 01 00 00    	je     3d49 <writeBits+0x189>
    3c05:	8b 45 08             	mov    0x8(%ebp),%eax
    3c08:	8b 00                	mov    (%eax),%eax
    3c0a:	8b 10                	mov    (%eax),%edx
    3c0c:	8b 45 08             	mov    0x8(%ebp),%eax
    3c0f:	8b 00                	mov    (%eax),%eax
    3c11:	8b 40 04             	mov    0x4(%eax),%eax
    3c14:	83 e8 01             	sub    $0x1,%eax
    3c17:	01 d0                	add    %edx,%eax
    3c19:	c6 00 00             	movb   $0x0,(%eax)
    3c1c:	8b 45 08             	mov    0x8(%ebp),%eax
    3c1f:	8b 00                	mov    (%eax),%eax
    3c21:	8b 10                	mov    (%eax),%edx
    3c23:	8b 45 08             	mov    0x8(%ebp),%eax
    3c26:	8b 00                	mov    (%eax),%eax
    3c28:	8b 40 04             	mov    0x4(%eax),%eax
    3c2b:	83 e8 01             	sub    $0x1,%eax
    3c2e:	01 c2                	add    %eax,%edx
    3c30:	8b 45 08             	mov    0x8(%ebp),%eax
    3c33:	8b 00                	mov    (%eax),%eax
    3c35:	8b 08                	mov    (%eax),%ecx
    3c37:	8b 45 08             	mov    0x8(%ebp),%eax
    3c3a:	8b 00                	mov    (%eax),%eax
    3c3c:	8b 40 04             	mov    0x4(%eax),%eax
    3c3f:	83 e8 01             	sub    $0x1,%eax
    3c42:	01 c8                	add    %ecx,%eax
    3c44:	0f b6 00             	movzbl (%eax),%eax
    3c47:	88 45 e7             	mov    %al,-0x19(%ebp)
    3c4a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c4d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c51:	0f b6 c0             	movzbl %al,%eax
    3c54:	83 e0 07             	and    $0x7,%eax
    3c57:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3c5a:	89 de                	mov    %ebx,%esi
    3c5c:	89 c1                	mov    %eax,%ecx
    3c5e:	d3 e6                	shl    %cl,%esi
    3c60:	89 f0                	mov    %esi,%eax
    3c62:	0a 45 e7             	or     -0x19(%ebp),%al
    3c65:	88 02                	mov    %al,(%edx)
    3c67:	8b 45 08             	mov    0x8(%ebp),%eax
    3c6a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c6e:	8d 50 01             	lea    0x1(%eax),%edx
    3c71:	8b 45 08             	mov    0x8(%ebp),%eax
    3c74:	88 50 04             	mov    %dl,0x4(%eax)
    3c77:	e9 d1 00 00 00       	jmp    3d4d <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3c7c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3c83:	e9 b3 00 00 00       	jmp    3d3b <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3c88:	8b 45 08             	mov    0x8(%ebp),%eax
    3c8b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c8f:	0f b6 c0             	movzbl %al,%eax
    3c92:	83 e0 07             	and    $0x7,%eax
    3c95:	85 c0                	test   %eax,%eax
    3c97:	75 39                	jne    3cd2 <writeBits+0x112>
    3c99:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9c:	8b 00                	mov    (%eax),%eax
    3c9e:	8b 40 04             	mov    0x4(%eax),%eax
    3ca1:	8d 50 01             	lea    0x1(%eax),%edx
    3ca4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca7:	8b 00                	mov    (%eax),%eax
    3ca9:	52                   	push   %edx
    3caa:	50                   	push   %eax
    3cab:	e8 82 fc ff ff       	call   3932 <ucvector_resize>
    3cb0:	83 c4 08             	add    $0x8,%esp
    3cb3:	85 c0                	test   %eax,%eax
    3cb5:	0f 84 91 00 00 00    	je     3d4c <writeBits+0x18c>
    3cbb:	8b 45 08             	mov    0x8(%ebp),%eax
    3cbe:	8b 00                	mov    (%eax),%eax
    3cc0:	8b 10                	mov    (%eax),%edx
    3cc2:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc5:	8b 00                	mov    (%eax),%eax
    3cc7:	8b 40 04             	mov    0x4(%eax),%eax
    3cca:	83 e8 01             	sub    $0x1,%eax
    3ccd:	01 d0                	add    %edx,%eax
    3ccf:	c6 00 00             	movb   $0x0,(%eax)
    3cd2:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd5:	8b 00                	mov    (%eax),%eax
    3cd7:	8b 10                	mov    (%eax),%edx
    3cd9:	8b 45 08             	mov    0x8(%ebp),%eax
    3cdc:	8b 00                	mov    (%eax),%eax
    3cde:	8b 40 04             	mov    0x4(%eax),%eax
    3ce1:	83 e8 01             	sub    $0x1,%eax
    3ce4:	01 c2                	add    %eax,%edx
    3ce6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce9:	8b 00                	mov    (%eax),%eax
    3ceb:	8b 08                	mov    (%eax),%ecx
    3ced:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf0:	8b 00                	mov    (%eax),%eax
    3cf2:	8b 40 04             	mov    0x4(%eax),%eax
    3cf5:	83 e8 01             	sub    $0x1,%eax
    3cf8:	01 c8                	add    %ecx,%eax
    3cfa:	0f b6 00             	movzbl (%eax),%eax
    3cfd:	89 c6                	mov    %eax,%esi
    3cff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3d02:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3d05:	89 c1                	mov    %eax,%ecx
    3d07:	d3 eb                	shr    %cl,%ebx
    3d09:	89 d8                	mov    %ebx,%eax
    3d0b:	83 e0 01             	and    $0x1,%eax
    3d0e:	89 c3                	mov    %eax,%ebx
    3d10:	8b 45 08             	mov    0x8(%ebp),%eax
    3d13:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3d17:	0f b6 c0             	movzbl %al,%eax
    3d1a:	83 e0 07             	and    $0x7,%eax
    3d1d:	89 c1                	mov    %eax,%ecx
    3d1f:	d3 e3                	shl    %cl,%ebx
    3d21:	89 d8                	mov    %ebx,%eax
    3d23:	09 f0                	or     %esi,%eax
    3d25:	88 02                	mov    %al,(%edx)
    3d27:	8b 45 08             	mov    0x8(%ebp),%eax
    3d2a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3d2e:	8d 50 01             	lea    0x1(%eax),%edx
    3d31:	8b 45 08             	mov    0x8(%ebp),%eax
    3d34:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3d37:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3d3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3d3e:	3b 45 10             	cmp    0x10(%ebp),%eax
    3d41:	0f 85 41 ff ff ff    	jne    3c88 <writeBits+0xc8>
    3d47:	eb 04                	jmp    3d4d <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3d49:	90                   	nop
    3d4a:	eb 01                	jmp    3d4d <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3d4c:	90                   	nop
    }
  }
}
    3d4d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3d50:	5b                   	pop    %ebx
    3d51:	5e                   	pop    %esi
    3d52:	5d                   	pop    %ebp
    3d53:	c3                   	ret    

00003d54 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3d54:	55                   	push   %ebp
    3d55:	89 e5                	mov    %esp,%ebp
    3d57:	56                   	push   %esi
    3d58:	53                   	push   %ebx
    3d59:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3d5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3d63:	e9 bd 00 00 00       	jmp    3e25 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3d68:	8b 45 08             	mov    0x8(%ebp),%eax
    3d6b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3d6f:	0f b6 c0             	movzbl %al,%eax
    3d72:	83 e0 07             	and    $0x7,%eax
    3d75:	85 c0                	test   %eax,%eax
    3d77:	75 39                	jne    3db2 <writeBitsReversed+0x5e>
    3d79:	8b 45 08             	mov    0x8(%ebp),%eax
    3d7c:	8b 00                	mov    (%eax),%eax
    3d7e:	8b 40 04             	mov    0x4(%eax),%eax
    3d81:	8d 50 01             	lea    0x1(%eax),%edx
    3d84:	8b 45 08             	mov    0x8(%ebp),%eax
    3d87:	8b 00                	mov    (%eax),%eax
    3d89:	52                   	push   %edx
    3d8a:	50                   	push   %eax
    3d8b:	e8 a2 fb ff ff       	call   3932 <ucvector_resize>
    3d90:	83 c4 08             	add    $0x8,%esp
    3d93:	85 c0                	test   %eax,%eax
    3d95:	0f 84 98 00 00 00    	je     3e33 <writeBitsReversed+0xdf>
    3d9b:	8b 45 08             	mov    0x8(%ebp),%eax
    3d9e:	8b 00                	mov    (%eax),%eax
    3da0:	8b 10                	mov    (%eax),%edx
    3da2:	8b 45 08             	mov    0x8(%ebp),%eax
    3da5:	8b 00                	mov    (%eax),%eax
    3da7:	8b 40 04             	mov    0x4(%eax),%eax
    3daa:	83 e8 01             	sub    $0x1,%eax
    3dad:	01 d0                	add    %edx,%eax
    3daf:	c6 00 00             	movb   $0x0,(%eax)
    3db2:	8b 45 08             	mov    0x8(%ebp),%eax
    3db5:	8b 00                	mov    (%eax),%eax
    3db7:	8b 10                	mov    (%eax),%edx
    3db9:	8b 45 08             	mov    0x8(%ebp),%eax
    3dbc:	8b 00                	mov    (%eax),%eax
    3dbe:	8b 40 04             	mov    0x4(%eax),%eax
    3dc1:	83 e8 01             	sub    $0x1,%eax
    3dc4:	01 c2                	add    %eax,%edx
    3dc6:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc9:	8b 00                	mov    (%eax),%eax
    3dcb:	8b 08                	mov    (%eax),%ecx
    3dcd:	8b 45 08             	mov    0x8(%ebp),%eax
    3dd0:	8b 00                	mov    (%eax),%eax
    3dd2:	8b 40 04             	mov    0x4(%eax),%eax
    3dd5:	83 e8 01             	sub    $0x1,%eax
    3dd8:	01 c8                	add    %ecx,%eax
    3dda:	0f b6 00             	movzbl (%eax),%eax
    3ddd:	89 c6                	mov    %eax,%esi
    3ddf:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3de2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3de5:	29 c1                	sub    %eax,%ecx
    3de7:	89 c8                	mov    %ecx,%eax
    3de9:	83 e8 01             	sub    $0x1,%eax
    3dec:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3def:	89 c1                	mov    %eax,%ecx
    3df1:	d3 eb                	shr    %cl,%ebx
    3df3:	89 d8                	mov    %ebx,%eax
    3df5:	83 e0 01             	and    $0x1,%eax
    3df8:	89 c3                	mov    %eax,%ebx
    3dfa:	8b 45 08             	mov    0x8(%ebp),%eax
    3dfd:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3e01:	0f b6 c0             	movzbl %al,%eax
    3e04:	83 e0 07             	and    $0x7,%eax
    3e07:	89 c1                	mov    %eax,%ecx
    3e09:	d3 e3                	shl    %cl,%ebx
    3e0b:	89 d8                	mov    %ebx,%eax
    3e0d:	09 f0                	or     %esi,%eax
    3e0f:	88 02                	mov    %al,(%edx)
    3e11:	8b 45 08             	mov    0x8(%ebp),%eax
    3e14:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3e18:	8d 50 01             	lea    0x1(%eax),%edx
    3e1b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1e:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3e21:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3e25:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3e28:	3b 45 10             	cmp    0x10(%ebp),%eax
    3e2b:	0f 85 37 ff ff ff    	jne    3d68 <writeBitsReversed+0x14>
    3e31:	eb 01                	jmp    3e34 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3e33:	90                   	nop
  }
}
    3e34:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3e37:	5b                   	pop    %ebx
    3e38:	5e                   	pop    %esi
    3e39:	5d                   	pop    %ebp
    3e3a:	c3                   	ret    

00003e3b <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3e3b:	55                   	push   %ebp
    3e3c:	89 e5                	mov    %esp,%ebp
    3e3e:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3e41:	8b 45 08             	mov    0x8(%ebp),%eax
    3e44:	8b 55 0c             	mov    0xc(%ebp),%edx
    3e47:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3e49:	8b 45 08             	mov    0x8(%ebp),%eax
    3e4c:	8b 55 10             	mov    0x10(%ebp),%edx
    3e4f:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3e52:	8b 45 08             	mov    0x8(%ebp),%eax
    3e55:	83 c0 08             	add    $0x8,%eax
    3e58:	50                   	push   %eax
    3e59:	6a 08                	push   $0x8
    3e5b:	ff 75 10             	pushl  0x10(%ebp)
    3e5e:	e8 59 f9 ff ff       	call   37bc <lodepng_mulofl>
    3e63:	83 c4 0c             	add    $0xc,%esp
    3e66:	85 c0                	test   %eax,%eax
    3e68:	74 07                	je     3e71 <LodePNGBitReader_init+0x36>
    3e6a:	b8 69 00 00 00       	mov    $0x69,%eax
    3e6f:	eb 39                	jmp    3eaa <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3e71:	8b 45 08             	mov    0x8(%ebp),%eax
    3e74:	8b 40 08             	mov    0x8(%eax),%eax
    3e77:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3e7a:	52                   	push   %edx
    3e7b:	6a 40                	push   $0x40
    3e7d:	50                   	push   %eax
    3e7e:	e8 19 f9 ff ff       	call   379c <lodepng_addofl>
    3e83:	83 c4 0c             	add    $0xc,%esp
    3e86:	85 c0                	test   %eax,%eax
    3e88:	74 07                	je     3e91 <LodePNGBitReader_init+0x56>
    3e8a:	b8 69 00 00 00       	mov    $0x69,%eax
    3e8f:	eb 19                	jmp    3eaa <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3e91:	8b 45 08             	mov    0x8(%ebp),%eax
    3e94:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3e9b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e9e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3ea5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3eaa:	c9                   	leave  
    3eab:	c3                   	ret    

00003eac <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3eac:	55                   	push   %ebp
    3ead:	89 e5                	mov    %esp,%ebp
    3eaf:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3eb2:	8b 45 08             	mov    0x8(%ebp),%eax
    3eb5:	8b 40 0c             	mov    0xc(%eax),%eax
    3eb8:	c1 f8 03             	sar    $0x3,%eax
    3ebb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3ebe:	8b 45 08             	mov    0x8(%ebp),%eax
    3ec1:	8b 40 04             	mov    0x4(%eax),%eax
    3ec4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3ec7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3eca:	8d 50 01             	lea    0x1(%eax),%edx
    3ecd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ed0:	39 c2                	cmp    %eax,%edx
    3ed2:	73 4e                	jae    3f22 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3ed4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed7:	8b 10                	mov    (%eax),%edx
    3ed9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3edc:	01 d0                	add    %edx,%eax
    3ede:	0f b6 00             	movzbl (%eax),%eax
    3ee1:	0f b6 d0             	movzbl %al,%edx
    3ee4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ee7:	8b 00                	mov    (%eax),%eax
    3ee9:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3eec:	83 c1 01             	add    $0x1,%ecx
    3eef:	01 c8                	add    %ecx,%eax
    3ef1:	0f b6 00             	movzbl (%eax),%eax
    3ef4:	0f b6 c0             	movzbl %al,%eax
    3ef7:	c1 e0 08             	shl    $0x8,%eax
    3efa:	09 c2                	or     %eax,%edx
    3efc:	8b 45 08             	mov    0x8(%ebp),%eax
    3eff:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3f02:	8b 45 08             	mov    0x8(%ebp),%eax
    3f05:	8b 50 10             	mov    0x10(%eax),%edx
    3f08:	8b 45 08             	mov    0x8(%ebp),%eax
    3f0b:	8b 40 0c             	mov    0xc(%eax),%eax
    3f0e:	83 e0 07             	and    $0x7,%eax
    3f11:	89 c1                	mov    %eax,%ecx
    3f13:	d3 ea                	shr    %cl,%edx
    3f15:	8b 45 08             	mov    0x8(%ebp),%eax
    3f18:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3f1b:	b8 01 00 00 00       	mov    $0x1,%eax
    3f20:	eb 64                	jmp    3f86 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3f22:	8b 45 08             	mov    0x8(%ebp),%eax
    3f25:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f2c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3f2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f32:	39 c2                	cmp    %eax,%edx
    3f34:	73 1e                	jae    3f54 <ensureBits9+0xa8>
    3f36:	8b 45 08             	mov    0x8(%ebp),%eax
    3f39:	8b 50 10             	mov    0x10(%eax),%edx
    3f3c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f3f:	8b 08                	mov    (%eax),%ecx
    3f41:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f44:	01 c8                	add    %ecx,%eax
    3f46:	0f b6 00             	movzbl (%eax),%eax
    3f49:	0f b6 c0             	movzbl %al,%eax
    3f4c:	09 c2                	or     %eax,%edx
    3f4e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f51:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3f54:	8b 45 08             	mov    0x8(%ebp),%eax
    3f57:	8b 50 10             	mov    0x10(%eax),%edx
    3f5a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f5d:	8b 40 0c             	mov    0xc(%eax),%eax
    3f60:	83 e0 07             	and    $0x7,%eax
    3f63:	89 c1                	mov    %eax,%ecx
    3f65:	d3 ea                	shr    %cl,%edx
    3f67:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6a:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3f6d:	8b 45 08             	mov    0x8(%ebp),%eax
    3f70:	8b 50 0c             	mov    0xc(%eax),%edx
    3f73:	8b 45 0c             	mov    0xc(%ebp),%eax
    3f76:	01 c2                	add    %eax,%edx
    3f78:	8b 45 08             	mov    0x8(%ebp),%eax
    3f7b:	8b 40 08             	mov    0x8(%eax),%eax
    3f7e:	39 c2                	cmp    %eax,%edx
    3f80:	0f 9e c0             	setle  %al
    3f83:	0f b6 c0             	movzbl %al,%eax
  }
}
    3f86:	c9                   	leave  
    3f87:	c3                   	ret    

00003f88 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3f88:	55                   	push   %ebp
    3f89:	89 e5                	mov    %esp,%ebp
    3f8b:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3f8e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f91:	8b 40 0c             	mov    0xc(%eax),%eax
    3f94:	c1 f8 03             	sar    $0x3,%eax
    3f97:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3f9a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f9d:	8b 40 04             	mov    0x4(%eax),%eax
    3fa0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3fa3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3fa6:	8d 50 02             	lea    0x2(%eax),%edx
    3fa9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fac:	39 c2                	cmp    %eax,%edx
    3fae:	73 6d                	jae    401d <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3fb0:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb3:	8b 10                	mov    (%eax),%edx
    3fb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3fb8:	01 d0                	add    %edx,%eax
    3fba:	0f b6 00             	movzbl (%eax),%eax
    3fbd:	0f b6 d0             	movzbl %al,%edx
    3fc0:	8b 45 08             	mov    0x8(%ebp),%eax
    3fc3:	8b 00                	mov    (%eax),%eax
    3fc5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3fc8:	83 c1 01             	add    $0x1,%ecx
    3fcb:	01 c8                	add    %ecx,%eax
    3fcd:	0f b6 00             	movzbl (%eax),%eax
    3fd0:	0f b6 c0             	movzbl %al,%eax
    3fd3:	c1 e0 08             	shl    $0x8,%eax
    3fd6:	89 d1                	mov    %edx,%ecx
    3fd8:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3fda:	8b 45 08             	mov    0x8(%ebp),%eax
    3fdd:	8b 00                	mov    (%eax),%eax
    3fdf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3fe2:	83 c2 02             	add    $0x2,%edx
    3fe5:	01 d0                	add    %edx,%eax
    3fe7:	0f b6 00             	movzbl (%eax),%eax
    3fea:	0f b6 c0             	movzbl %al,%eax
    3fed:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ff0:	09 c1                	or     %eax,%ecx
    3ff2:	89 ca                	mov    %ecx,%edx
    3ff4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff7:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3ffa:	8b 45 08             	mov    0x8(%ebp),%eax
    3ffd:	8b 50 10             	mov    0x10(%eax),%edx
    4000:	8b 45 08             	mov    0x8(%ebp),%eax
    4003:	8b 40 0c             	mov    0xc(%eax),%eax
    4006:	83 e0 07             	and    $0x7,%eax
    4009:	89 c1                	mov    %eax,%ecx
    400b:	d3 ea                	shr    %cl,%edx
    400d:	8b 45 08             	mov    0x8(%ebp),%eax
    4010:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4013:	b8 01 00 00 00       	mov    $0x1,%eax
    4018:	e9 95 00 00 00       	jmp    40b2 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    401d:	8b 45 08             	mov    0x8(%ebp),%eax
    4020:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4027:	8b 55 fc             	mov    -0x4(%ebp),%edx
    402a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    402d:	39 c2                	cmp    %eax,%edx
    402f:	73 1e                	jae    404f <ensureBits17+0xc7>
    4031:	8b 45 08             	mov    0x8(%ebp),%eax
    4034:	8b 50 10             	mov    0x10(%eax),%edx
    4037:	8b 45 08             	mov    0x8(%ebp),%eax
    403a:	8b 08                	mov    (%eax),%ecx
    403c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    403f:	01 c8                	add    %ecx,%eax
    4041:	0f b6 00             	movzbl (%eax),%eax
    4044:	0f b6 c0             	movzbl %al,%eax
    4047:	09 c2                	or     %eax,%edx
    4049:	8b 45 08             	mov    0x8(%ebp),%eax
    404c:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    404f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4052:	8d 50 01             	lea    0x1(%eax),%edx
    4055:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4058:	39 c2                	cmp    %eax,%edx
    405a:	73 24                	jae    4080 <ensureBits17+0xf8>
    405c:	8b 45 08             	mov    0x8(%ebp),%eax
    405f:	8b 50 10             	mov    0x10(%eax),%edx
    4062:	8b 45 08             	mov    0x8(%ebp),%eax
    4065:	8b 00                	mov    (%eax),%eax
    4067:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    406a:	83 c1 01             	add    $0x1,%ecx
    406d:	01 c8                	add    %ecx,%eax
    406f:	0f b6 00             	movzbl (%eax),%eax
    4072:	0f b6 c0             	movzbl %al,%eax
    4075:	c1 e0 08             	shl    $0x8,%eax
    4078:	09 c2                	or     %eax,%edx
    407a:	8b 45 08             	mov    0x8(%ebp),%eax
    407d:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4080:	8b 45 08             	mov    0x8(%ebp),%eax
    4083:	8b 50 10             	mov    0x10(%eax),%edx
    4086:	8b 45 08             	mov    0x8(%ebp),%eax
    4089:	8b 40 0c             	mov    0xc(%eax),%eax
    408c:	83 e0 07             	and    $0x7,%eax
    408f:	89 c1                	mov    %eax,%ecx
    4091:	d3 ea                	shr    %cl,%edx
    4093:	8b 45 08             	mov    0x8(%ebp),%eax
    4096:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4099:	8b 45 08             	mov    0x8(%ebp),%eax
    409c:	8b 50 0c             	mov    0xc(%eax),%edx
    409f:	8b 45 0c             	mov    0xc(%ebp),%eax
    40a2:	01 c2                	add    %eax,%edx
    40a4:	8b 45 08             	mov    0x8(%ebp),%eax
    40a7:	8b 40 08             	mov    0x8(%eax),%eax
    40aa:	39 c2                	cmp    %eax,%edx
    40ac:	0f 9e c0             	setle  %al
    40af:	0f b6 c0             	movzbl %al,%eax
  }
}
    40b2:	c9                   	leave  
    40b3:	c3                   	ret    

000040b4 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    40b4:	55                   	push   %ebp
    40b5:	89 e5                	mov    %esp,%ebp
    40b7:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    40ba:	8b 45 08             	mov    0x8(%ebp),%eax
    40bd:	8b 40 0c             	mov    0xc(%eax),%eax
    40c0:	c1 f8 03             	sar    $0x3,%eax
    40c3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    40c6:	8b 45 08             	mov    0x8(%ebp),%eax
    40c9:	8b 40 04             	mov    0x4(%eax),%eax
    40cc:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    40cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    40d2:	8d 50 03             	lea    0x3(%eax),%edx
    40d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40d8:	39 c2                	cmp    %eax,%edx
    40da:	0f 83 85 00 00 00    	jae    4165 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    40e0:	8b 45 08             	mov    0x8(%ebp),%eax
    40e3:	8b 10                	mov    (%eax),%edx
    40e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    40e8:	01 d0                	add    %edx,%eax
    40ea:	0f b6 00             	movzbl (%eax),%eax
    40ed:	0f b6 d0             	movzbl %al,%edx
    40f0:	8b 45 08             	mov    0x8(%ebp),%eax
    40f3:	8b 00                	mov    (%eax),%eax
    40f5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    40f8:	83 c1 01             	add    $0x1,%ecx
    40fb:	01 c8                	add    %ecx,%eax
    40fd:	0f b6 00             	movzbl (%eax),%eax
    4100:	0f b6 c0             	movzbl %al,%eax
    4103:	c1 e0 08             	shl    $0x8,%eax
    4106:	89 d1                	mov    %edx,%ecx
    4108:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    410a:	8b 45 08             	mov    0x8(%ebp),%eax
    410d:	8b 00                	mov    (%eax),%eax
    410f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4112:	83 c2 02             	add    $0x2,%edx
    4115:	01 d0                	add    %edx,%eax
    4117:	0f b6 00             	movzbl (%eax),%eax
    411a:	0f b6 c0             	movzbl %al,%eax
    411d:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4120:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4122:	8b 45 08             	mov    0x8(%ebp),%eax
    4125:	8b 00                	mov    (%eax),%eax
    4127:	8b 55 fc             	mov    -0x4(%ebp),%edx
    412a:	83 c2 03             	add    $0x3,%edx
    412d:	01 d0                	add    %edx,%eax
    412f:	0f b6 00             	movzbl (%eax),%eax
    4132:	0f b6 c0             	movzbl %al,%eax
    4135:	c1 e0 18             	shl    $0x18,%eax
    4138:	09 c1                	or     %eax,%ecx
    413a:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    413c:	8b 45 08             	mov    0x8(%ebp),%eax
    413f:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4142:	8b 45 08             	mov    0x8(%ebp),%eax
    4145:	8b 50 10             	mov    0x10(%eax),%edx
    4148:	8b 45 08             	mov    0x8(%ebp),%eax
    414b:	8b 40 0c             	mov    0xc(%eax),%eax
    414e:	83 e0 07             	and    $0x7,%eax
    4151:	89 c1                	mov    %eax,%ecx
    4153:	d3 ea                	shr    %cl,%edx
    4155:	8b 45 08             	mov    0x8(%ebp),%eax
    4158:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    415b:	b8 01 00 00 00       	mov    $0x1,%eax
    4160:	e9 c6 00 00 00       	jmp    422b <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    4165:	8b 45 08             	mov    0x8(%ebp),%eax
    4168:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    416f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4172:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4175:	39 c2                	cmp    %eax,%edx
    4177:	73 1e                	jae    4197 <ensureBits25+0xe3>
    4179:	8b 45 08             	mov    0x8(%ebp),%eax
    417c:	8b 50 10             	mov    0x10(%eax),%edx
    417f:	8b 45 08             	mov    0x8(%ebp),%eax
    4182:	8b 08                	mov    (%eax),%ecx
    4184:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4187:	01 c8                	add    %ecx,%eax
    4189:	0f b6 00             	movzbl (%eax),%eax
    418c:	0f b6 c0             	movzbl %al,%eax
    418f:	09 c2                	or     %eax,%edx
    4191:	8b 45 08             	mov    0x8(%ebp),%eax
    4194:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    4197:	8b 45 fc             	mov    -0x4(%ebp),%eax
    419a:	8d 50 01             	lea    0x1(%eax),%edx
    419d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41a0:	39 c2                	cmp    %eax,%edx
    41a2:	73 24                	jae    41c8 <ensureBits25+0x114>
    41a4:	8b 45 08             	mov    0x8(%ebp),%eax
    41a7:	8b 50 10             	mov    0x10(%eax),%edx
    41aa:	8b 45 08             	mov    0x8(%ebp),%eax
    41ad:	8b 00                	mov    (%eax),%eax
    41af:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    41b2:	83 c1 01             	add    $0x1,%ecx
    41b5:	01 c8                	add    %ecx,%eax
    41b7:	0f b6 00             	movzbl (%eax),%eax
    41ba:	0f b6 c0             	movzbl %al,%eax
    41bd:	c1 e0 08             	shl    $0x8,%eax
    41c0:	09 c2                	or     %eax,%edx
    41c2:	8b 45 08             	mov    0x8(%ebp),%eax
    41c5:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    41c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    41cb:	8d 50 02             	lea    0x2(%eax),%edx
    41ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41d1:	39 c2                	cmp    %eax,%edx
    41d3:	73 24                	jae    41f9 <ensureBits25+0x145>
    41d5:	8b 45 08             	mov    0x8(%ebp),%eax
    41d8:	8b 50 10             	mov    0x10(%eax),%edx
    41db:	8b 45 08             	mov    0x8(%ebp),%eax
    41de:	8b 00                	mov    (%eax),%eax
    41e0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    41e3:	83 c1 02             	add    $0x2,%ecx
    41e6:	01 c8                	add    %ecx,%eax
    41e8:	0f b6 00             	movzbl (%eax),%eax
    41eb:	0f b6 c0             	movzbl %al,%eax
    41ee:	c1 e0 10             	shl    $0x10,%eax
    41f1:	09 c2                	or     %eax,%edx
    41f3:	8b 45 08             	mov    0x8(%ebp),%eax
    41f6:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    41f9:	8b 45 08             	mov    0x8(%ebp),%eax
    41fc:	8b 50 10             	mov    0x10(%eax),%edx
    41ff:	8b 45 08             	mov    0x8(%ebp),%eax
    4202:	8b 40 0c             	mov    0xc(%eax),%eax
    4205:	83 e0 07             	and    $0x7,%eax
    4208:	89 c1                	mov    %eax,%ecx
    420a:	d3 ea                	shr    %cl,%edx
    420c:	8b 45 08             	mov    0x8(%ebp),%eax
    420f:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4212:	8b 45 08             	mov    0x8(%ebp),%eax
    4215:	8b 50 0c             	mov    0xc(%eax),%edx
    4218:	8b 45 0c             	mov    0xc(%ebp),%eax
    421b:	01 c2                	add    %eax,%edx
    421d:	8b 45 08             	mov    0x8(%ebp),%eax
    4220:	8b 40 08             	mov    0x8(%eax),%eax
    4223:	39 c2                	cmp    %eax,%edx
    4225:	0f 9e c0             	setle  %al
    4228:	0f b6 c0             	movzbl %al,%eax
  }
}
    422b:	c9                   	leave  
    422c:	c3                   	ret    

0000422d <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    422d:	55                   	push   %ebp
    422e:	89 e5                	mov    %esp,%ebp
    4230:	53                   	push   %ebx
    4231:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4234:	8b 45 08             	mov    0x8(%ebp),%eax
    4237:	8b 40 0c             	mov    0xc(%eax),%eax
    423a:	c1 f8 03             	sar    $0x3,%eax
    423d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    4240:	8b 45 08             	mov    0x8(%ebp),%eax
    4243:	8b 40 04             	mov    0x4(%eax),%eax
    4246:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    4249:	8b 45 f8             	mov    -0x8(%ebp),%eax
    424c:	8d 50 04             	lea    0x4(%eax),%edx
    424f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4252:	39 c2                	cmp    %eax,%edx
    4254:	0f 83 c3 00 00 00    	jae    431d <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    425a:	8b 45 08             	mov    0x8(%ebp),%eax
    425d:	8b 10                	mov    (%eax),%edx
    425f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4262:	01 d0                	add    %edx,%eax
    4264:	0f b6 00             	movzbl (%eax),%eax
    4267:	0f b6 d0             	movzbl %al,%edx
    426a:	8b 45 08             	mov    0x8(%ebp),%eax
    426d:	8b 00                	mov    (%eax),%eax
    426f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4272:	83 c1 01             	add    $0x1,%ecx
    4275:	01 c8                	add    %ecx,%eax
    4277:	0f b6 00             	movzbl (%eax),%eax
    427a:	0f b6 c0             	movzbl %al,%eax
    427d:	c1 e0 08             	shl    $0x8,%eax
    4280:	89 d1                	mov    %edx,%ecx
    4282:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4284:	8b 45 08             	mov    0x8(%ebp),%eax
    4287:	8b 00                	mov    (%eax),%eax
    4289:	8b 55 f8             	mov    -0x8(%ebp),%edx
    428c:	83 c2 02             	add    $0x2,%edx
    428f:	01 d0                	add    %edx,%eax
    4291:	0f b6 00             	movzbl (%eax),%eax
    4294:	0f b6 c0             	movzbl %al,%eax
    4297:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    429a:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    429c:	8b 45 08             	mov    0x8(%ebp),%eax
    429f:	8b 00                	mov    (%eax),%eax
    42a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    42a4:	83 c2 03             	add    $0x3,%edx
    42a7:	01 d0                	add    %edx,%eax
    42a9:	0f b6 00             	movzbl (%eax),%eax
    42ac:	0f b6 c0             	movzbl %al,%eax
    42af:	c1 e0 18             	shl    $0x18,%eax
    42b2:	09 c1                	or     %eax,%ecx
    42b4:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    42b6:	8b 45 08             	mov    0x8(%ebp),%eax
    42b9:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    42bc:	8b 45 08             	mov    0x8(%ebp),%eax
    42bf:	8b 50 10             	mov    0x10(%eax),%edx
    42c2:	8b 45 08             	mov    0x8(%ebp),%eax
    42c5:	8b 40 0c             	mov    0xc(%eax),%eax
    42c8:	83 e0 07             	and    $0x7,%eax
    42cb:	89 c1                	mov    %eax,%ecx
    42cd:	d3 ea                	shr    %cl,%edx
    42cf:	8b 45 08             	mov    0x8(%ebp),%eax
    42d2:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    42d5:	8b 45 08             	mov    0x8(%ebp),%eax
    42d8:	8b 50 10             	mov    0x10(%eax),%edx
    42db:	8b 45 08             	mov    0x8(%ebp),%eax
    42de:	8b 00                	mov    (%eax),%eax
    42e0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    42e3:	83 c1 04             	add    $0x4,%ecx
    42e6:	01 c8                	add    %ecx,%eax
    42e8:	0f b6 00             	movzbl (%eax),%eax
    42eb:	0f b6 c0             	movzbl %al,%eax
    42ee:	c1 e0 18             	shl    $0x18,%eax
    42f1:	89 c3                	mov    %eax,%ebx
    42f3:	8b 45 08             	mov    0x8(%ebp),%eax
    42f6:	8b 40 0c             	mov    0xc(%eax),%eax
    42f9:	83 e0 07             	and    $0x7,%eax
    42fc:	b9 08 00 00 00       	mov    $0x8,%ecx
    4301:	29 c1                	sub    %eax,%ecx
    4303:	89 c8                	mov    %ecx,%eax
    4305:	89 c1                	mov    %eax,%ecx
    4307:	d3 e3                	shl    %cl,%ebx
    4309:	89 d8                	mov    %ebx,%eax
    430b:	09 c2                	or     %eax,%edx
    430d:	8b 45 08             	mov    0x8(%ebp),%eax
    4310:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4313:	b8 01 00 00 00       	mov    $0x1,%eax
    4318:	e9 f7 00 00 00       	jmp    4414 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    431d:	8b 45 08             	mov    0x8(%ebp),%eax
    4320:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4327:	8b 55 f8             	mov    -0x8(%ebp),%edx
    432a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    432d:	39 c2                	cmp    %eax,%edx
    432f:	73 1e                	jae    434f <ensureBits32+0x122>
    4331:	8b 45 08             	mov    0x8(%ebp),%eax
    4334:	8b 50 10             	mov    0x10(%eax),%edx
    4337:	8b 45 08             	mov    0x8(%ebp),%eax
    433a:	8b 08                	mov    (%eax),%ecx
    433c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    433f:	01 c8                	add    %ecx,%eax
    4341:	0f b6 00             	movzbl (%eax),%eax
    4344:	0f b6 c0             	movzbl %al,%eax
    4347:	09 c2                	or     %eax,%edx
    4349:	8b 45 08             	mov    0x8(%ebp),%eax
    434c:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    434f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4352:	8d 50 01             	lea    0x1(%eax),%edx
    4355:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4358:	39 c2                	cmp    %eax,%edx
    435a:	73 24                	jae    4380 <ensureBits32+0x153>
    435c:	8b 45 08             	mov    0x8(%ebp),%eax
    435f:	8b 50 10             	mov    0x10(%eax),%edx
    4362:	8b 45 08             	mov    0x8(%ebp),%eax
    4365:	8b 00                	mov    (%eax),%eax
    4367:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    436a:	83 c1 01             	add    $0x1,%ecx
    436d:	01 c8                	add    %ecx,%eax
    436f:	0f b6 00             	movzbl (%eax),%eax
    4372:	0f b6 c0             	movzbl %al,%eax
    4375:	c1 e0 08             	shl    $0x8,%eax
    4378:	09 c2                	or     %eax,%edx
    437a:	8b 45 08             	mov    0x8(%ebp),%eax
    437d:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    4380:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4383:	8d 50 02             	lea    0x2(%eax),%edx
    4386:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4389:	39 c2                	cmp    %eax,%edx
    438b:	73 24                	jae    43b1 <ensureBits32+0x184>
    438d:	8b 45 08             	mov    0x8(%ebp),%eax
    4390:	8b 50 10             	mov    0x10(%eax),%edx
    4393:	8b 45 08             	mov    0x8(%ebp),%eax
    4396:	8b 00                	mov    (%eax),%eax
    4398:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    439b:	83 c1 02             	add    $0x2,%ecx
    439e:	01 c8                	add    %ecx,%eax
    43a0:	0f b6 00             	movzbl (%eax),%eax
    43a3:	0f b6 c0             	movzbl %al,%eax
    43a6:	c1 e0 10             	shl    $0x10,%eax
    43a9:	09 c2                	or     %eax,%edx
    43ab:	8b 45 08             	mov    0x8(%ebp),%eax
    43ae:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    43b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    43b4:	8d 50 03             	lea    0x3(%eax),%edx
    43b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43ba:	39 c2                	cmp    %eax,%edx
    43bc:	73 24                	jae    43e2 <ensureBits32+0x1b5>
    43be:	8b 45 08             	mov    0x8(%ebp),%eax
    43c1:	8b 50 10             	mov    0x10(%eax),%edx
    43c4:	8b 45 08             	mov    0x8(%ebp),%eax
    43c7:	8b 00                	mov    (%eax),%eax
    43c9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    43cc:	83 c1 03             	add    $0x3,%ecx
    43cf:	01 c8                	add    %ecx,%eax
    43d1:	0f b6 00             	movzbl (%eax),%eax
    43d4:	0f b6 c0             	movzbl %al,%eax
    43d7:	c1 e0 18             	shl    $0x18,%eax
    43da:	09 c2                	or     %eax,%edx
    43dc:	8b 45 08             	mov    0x8(%ebp),%eax
    43df:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    43e2:	8b 45 08             	mov    0x8(%ebp),%eax
    43e5:	8b 50 10             	mov    0x10(%eax),%edx
    43e8:	8b 45 08             	mov    0x8(%ebp),%eax
    43eb:	8b 40 0c             	mov    0xc(%eax),%eax
    43ee:	83 e0 07             	and    $0x7,%eax
    43f1:	89 c1                	mov    %eax,%ecx
    43f3:	d3 ea                	shr    %cl,%edx
    43f5:	8b 45 08             	mov    0x8(%ebp),%eax
    43f8:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    43fb:	8b 45 08             	mov    0x8(%ebp),%eax
    43fe:	8b 50 0c             	mov    0xc(%eax),%edx
    4401:	8b 45 0c             	mov    0xc(%ebp),%eax
    4404:	01 c2                	add    %eax,%edx
    4406:	8b 45 08             	mov    0x8(%ebp),%eax
    4409:	8b 40 08             	mov    0x8(%eax),%eax
    440c:	39 c2                	cmp    %eax,%edx
    440e:	0f 9e c0             	setle  %al
    4411:	0f b6 c0             	movzbl %al,%eax
  }
}
    4414:	83 c4 10             	add    $0x10,%esp
    4417:	5b                   	pop    %ebx
    4418:	5d                   	pop    %ebp
    4419:	c3                   	ret    

0000441a <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    441a:	55                   	push   %ebp
    441b:	89 e5                	mov    %esp,%ebp
    441d:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    441e:	8b 45 08             	mov    0x8(%ebp),%eax
    4421:	8b 50 10             	mov    0x10(%eax),%edx
    4424:	8b 45 0c             	mov    0xc(%ebp),%eax
    4427:	bb 01 00 00 00       	mov    $0x1,%ebx
    442c:	89 c1                	mov    %eax,%ecx
    442e:	d3 e3                	shl    %cl,%ebx
    4430:	89 d8                	mov    %ebx,%eax
    4432:	83 e8 01             	sub    $0x1,%eax
    4435:	21 d0                	and    %edx,%eax
}
    4437:	5b                   	pop    %ebx
    4438:	5d                   	pop    %ebp
    4439:	c3                   	ret    

0000443a <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    443a:	55                   	push   %ebp
    443b:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    443d:	8b 45 08             	mov    0x8(%ebp),%eax
    4440:	8b 50 10             	mov    0x10(%eax),%edx
    4443:	8b 45 0c             	mov    0xc(%ebp),%eax
    4446:	89 c1                	mov    %eax,%ecx
    4448:	d3 ea                	shr    %cl,%edx
    444a:	8b 45 08             	mov    0x8(%ebp),%eax
    444d:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    4450:	8b 45 08             	mov    0x8(%ebp),%eax
    4453:	8b 50 0c             	mov    0xc(%eax),%edx
    4456:	8b 45 0c             	mov    0xc(%ebp),%eax
    4459:	01 c2                	add    %eax,%edx
    445b:	8b 45 08             	mov    0x8(%ebp),%eax
    445e:	89 50 0c             	mov    %edx,0xc(%eax)
}
    4461:	90                   	nop
    4462:	5d                   	pop    %ebp
    4463:	c3                   	ret    

00004464 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    4464:	55                   	push   %ebp
    4465:	89 e5                	mov    %esp,%ebp
    4467:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    446a:	ff 75 0c             	pushl  0xc(%ebp)
    446d:	ff 75 08             	pushl  0x8(%ebp)
    4470:	e8 a5 ff ff ff       	call   441a <peekBits>
    4475:	83 c4 08             	add    $0x8,%esp
    4478:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    447b:	ff 75 0c             	pushl  0xc(%ebp)
    447e:	ff 75 08             	pushl  0x8(%ebp)
    4481:	e8 b4 ff ff ff       	call   443a <advanceBits>
    4486:	83 c4 08             	add    $0x8,%esp
  return result;
    4489:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    448c:	c9                   	leave  
    448d:	c3                   	ret    

0000448e <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    448e:	55                   	push   %ebp
    448f:	89 e5                	mov    %esp,%ebp
    4491:	53                   	push   %ebx
    4492:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    4495:	ff 75 0c             	pushl  0xc(%ebp)
    4498:	ff 75 08             	pushl  0x8(%ebp)
    449b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    449e:	50                   	push   %eax
    449f:	e8 97 f9 ff ff       	call   3e3b <LodePNGBitReader_init>
    44a4:	83 c4 0c             	add    $0xc,%esp
    44a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    44aa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    44ae:	74 0a                	je     44ba <lode_png_test_bitreader+0x2c>
    44b0:	b8 00 00 00 00       	mov    $0x0,%eax
    44b5:	e9 c3 00 00 00       	jmp    457d <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    44ba:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    44c1:	e9 a6 00 00 00       	jmp    456c <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    44c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    44c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    44d0:	8b 45 14             	mov    0x14(%ebp),%eax
    44d3:	01 d0                	add    %edx,%eax
    44d5:	8b 00                	mov    (%eax),%eax
    44d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    44da:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    44de:	7e 14                	jle    44f4 <lode_png_test_bitreader+0x66>
    44e0:	ff 75 ec             	pushl  -0x14(%ebp)
    44e3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    44e6:	50                   	push   %eax
    44e7:	e8 41 fd ff ff       	call   422d <ensureBits32>
    44ec:	83 c4 08             	add    $0x8,%esp
    44ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    44f2:	eb 46                	jmp    453a <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    44f4:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    44f8:	7e 14                	jle    450e <lode_png_test_bitreader+0x80>
    44fa:	ff 75 ec             	pushl  -0x14(%ebp)
    44fd:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4500:	50                   	push   %eax
    4501:	e8 ae fb ff ff       	call   40b4 <ensureBits25>
    4506:	83 c4 08             	add    $0x8,%esp
    4509:	89 45 f4             	mov    %eax,-0xc(%ebp)
    450c:	eb 2c                	jmp    453a <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    450e:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    4512:	7e 14                	jle    4528 <lode_png_test_bitreader+0x9a>
    4514:	ff 75 ec             	pushl  -0x14(%ebp)
    4517:	8d 45 d8             	lea    -0x28(%ebp),%eax
    451a:	50                   	push   %eax
    451b:	e8 68 fa ff ff       	call   3f88 <ensureBits17>
    4520:	83 c4 08             	add    $0x8,%esp
    4523:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4526:	eb 12                	jmp    453a <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4528:	ff 75 ec             	pushl  -0x14(%ebp)
    452b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    452e:	50                   	push   %eax
    452f:	e8 78 f9 ff ff       	call   3eac <ensureBits9>
    4534:	83 c4 08             	add    $0x8,%esp
    4537:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    453a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    453e:	75 07                	jne    4547 <lode_png_test_bitreader+0xb9>
    4540:	b8 00 00 00 00       	mov    $0x0,%eax
    4545:	eb 36                	jmp    457d <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4547:	8b 45 f8             	mov    -0x8(%ebp),%eax
    454a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4551:	8b 45 18             	mov    0x18(%ebp),%eax
    4554:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4557:	ff 75 ec             	pushl  -0x14(%ebp)
    455a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    455d:	50                   	push   %eax
    455e:	e8 01 ff ff ff       	call   4464 <readBits>
    4563:	83 c4 08             	add    $0x8,%esp
    4566:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    4568:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    456c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    456f:	3b 45 10             	cmp    0x10(%ebp),%eax
    4572:	0f 8c 4e ff ff ff    	jl     44c6 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    4578:	b8 01 00 00 00       	mov    $0x1,%eax
}
    457d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4580:	c9                   	leave  
    4581:	c3                   	ret    

00004582 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    4582:	55                   	push   %ebp
    4583:	89 e5                	mov    %esp,%ebp
    4585:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    4588:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    458f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    4596:	eb 27                	jmp    45bf <reverseBits+0x3d>
    4598:	8b 45 0c             	mov    0xc(%ebp),%eax
    459b:	2b 45 fc             	sub    -0x4(%ebp),%eax
    459e:	83 e8 01             	sub    $0x1,%eax
    45a1:	8b 55 08             	mov    0x8(%ebp),%edx
    45a4:	89 c1                	mov    %eax,%ecx
    45a6:	d3 ea                	shr    %cl,%edx
    45a8:	89 d0                	mov    %edx,%eax
    45aa:	83 e0 01             	and    $0x1,%eax
    45ad:	89 c2                	mov    %eax,%edx
    45af:	8b 45 fc             	mov    -0x4(%ebp),%eax
    45b2:	89 c1                	mov    %eax,%ecx
    45b4:	d3 e2                	shl    %cl,%edx
    45b6:	89 d0                	mov    %edx,%eax
    45b8:	09 45 f8             	or     %eax,-0x8(%ebp)
    45bb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    45bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    45c2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    45c5:	72 d1                	jb     4598 <reverseBits+0x16>
  return result;
    45c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    45ca:	c9                   	leave  
    45cb:	c3                   	ret    

000045cc <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    45cc:	55                   	push   %ebp
    45cd:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    45cf:	8b 45 08             	mov    0x8(%ebp),%eax
    45d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    45d8:	8b 45 08             	mov    0x8(%ebp),%eax
    45db:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    45e2:	8b 45 08             	mov    0x8(%ebp),%eax
    45e5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    45ec:	8b 45 08             	mov    0x8(%ebp),%eax
    45ef:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    45f6:	90                   	nop
    45f7:	5d                   	pop    %ebp
    45f8:	c3                   	ret    

000045f9 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    45f9:	55                   	push   %ebp
    45fa:	89 e5                	mov    %esp,%ebp
    45fc:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    45ff:	8b 45 08             	mov    0x8(%ebp),%eax
    4602:	8b 00                	mov    (%eax),%eax
    4604:	83 ec 0c             	sub    $0xc,%esp
    4607:	50                   	push   %eax
    4608:	e8 ec f0 ff ff       	call   36f9 <lodepng_free>
    460d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    4610:	8b 45 08             	mov    0x8(%ebp),%eax
    4613:	8b 40 04             	mov    0x4(%eax),%eax
    4616:	83 ec 0c             	sub    $0xc,%esp
    4619:	50                   	push   %eax
    461a:	e8 da f0 ff ff       	call   36f9 <lodepng_free>
    461f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    4622:	8b 45 08             	mov    0x8(%ebp),%eax
    4625:	8b 40 10             	mov    0x10(%eax),%eax
    4628:	83 ec 0c             	sub    $0xc,%esp
    462b:	50                   	push   %eax
    462c:	e8 c8 f0 ff ff       	call   36f9 <lodepng_free>
    4631:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4634:	8b 45 08             	mov    0x8(%ebp),%eax
    4637:	8b 40 14             	mov    0x14(%eax),%eax
    463a:	83 ec 0c             	sub    $0xc,%esp
    463d:	50                   	push   %eax
    463e:	e8 b6 f0 ff ff       	call   36f9 <lodepng_free>
    4643:	83 c4 10             	add    $0x10,%esp
}
    4646:	90                   	nop
    4647:	c9                   	leave  
    4648:	c3                   	ret    

00004649 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4649:	55                   	push   %ebp
    464a:	89 e5                	mov    %esp,%ebp
    464c:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    464f:	a1 08 ba 01 00       	mov    0x1ba08,%eax
    4654:	c1 e0 02             	shl    $0x2,%eax
    4657:	83 ec 0c             	sub    $0xc,%esp
    465a:	50                   	push   %eax
    465b:	e8 78 f0 ff ff       	call   36d8 <lodepng_malloc>
    4660:	83 c4 10             	add    $0x10,%esp
    4663:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    4666:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    466a:	75 0a                	jne    4676 <HuffmanTree_makeTable+0x2d>
    466c:	b8 53 00 00 00       	mov    $0x53,%eax
    4671:	e9 61 04 00 00       	jmp    4ad7 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    4676:	a1 08 ba 01 00       	mov    0x1ba08,%eax
    467b:	c1 e0 02             	shl    $0x2,%eax
    467e:	83 ec 04             	sub    $0x4,%esp
    4681:	50                   	push   %eax
    4682:	6a 00                	push   $0x0
    4684:	ff 75 dc             	pushl  -0x24(%ebp)
    4687:	e8 bd f0 ff ff       	call   3749 <lodepng_memset>
    468c:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    468f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4696:	eb 7d                	jmp    4715 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    4698:	8b 45 08             	mov    0x8(%ebp),%eax
    469b:	8b 00                	mov    (%eax),%eax
    469d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46a0:	c1 e2 02             	shl    $0x2,%edx
    46a3:	01 d0                	add    %edx,%eax
    46a5:	8b 00                	mov    (%eax),%eax
    46a7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    46aa:	8b 45 08             	mov    0x8(%ebp),%eax
    46ad:	8b 40 04             	mov    0x4(%eax),%eax
    46b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46b3:	c1 e2 02             	shl    $0x2,%edx
    46b6:	01 d0                	add    %edx,%eax
    46b8:	8b 00                	mov    (%eax),%eax
    46ba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    46bd:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    46c1:	76 4d                	jbe    4710 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    46c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    46c6:	83 e8 09             	sub    $0x9,%eax
    46c9:	8b 55 d8             	mov    -0x28(%ebp),%edx
    46cc:	89 c1                	mov    %eax,%ecx
    46ce:	d3 ea                	shr    %cl,%edx
    46d0:	89 d0                	mov    %edx,%eax
    46d2:	83 ec 08             	sub    $0x8,%esp
    46d5:	6a 09                	push   $0x9
    46d7:	50                   	push   %eax
    46d8:	e8 a5 fe ff ff       	call   4582 <reverseBits>
    46dd:	83 c4 10             	add    $0x10,%esp
    46e0:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    46e3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    46e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    46ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
    46f0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    46f3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    46f6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    46fd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4700:	01 d0                	add    %edx,%eax
    4702:	8b 10                	mov    (%eax),%edx
    4704:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4707:	39 c2                	cmp    %eax,%edx
    4709:	0f 43 c2             	cmovae %edx,%eax
    470c:	89 01                	mov    %eax,(%ecx)
    470e:	eb 01                	jmp    4711 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4710:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    4711:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4715:	8b 45 08             	mov    0x8(%ebp),%eax
    4718:	8b 50 0c             	mov    0xc(%eax),%edx
    471b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    471e:	39 c2                	cmp    %eax,%edx
    4720:	0f 87 72 ff ff ff    	ja     4698 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4726:	a1 08 ba 01 00       	mov    0x1ba08,%eax
    472b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    472e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4735:	eb 35                	jmp    476c <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4737:	8b 45 f4             	mov    -0xc(%ebp),%eax
    473a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4741:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4744:	01 d0                	add    %edx,%eax
    4746:	8b 00                	mov    (%eax),%eax
    4748:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    474b:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    474f:	76 17                	jbe    4768 <HuffmanTree_makeTable+0x11f>
    4751:	8b 45 cc             	mov    -0x34(%ebp),%eax
    4754:	83 e8 09             	sub    $0x9,%eax
    4757:	ba 01 00 00 00       	mov    $0x1,%edx
    475c:	89 c1                	mov    %eax,%ecx
    475e:	d3 e2                	shl    %cl,%edx
    4760:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4763:	01 d0                	add    %edx,%eax
    4765:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4768:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    476c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    476f:	a1 08 ba 01 00       	mov    0x1ba08,%eax
    4774:	39 c2                	cmp    %eax,%edx
    4776:	72 bf                	jb     4737 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    4778:	83 ec 0c             	sub    $0xc,%esp
    477b:	ff 75 e8             	pushl  -0x18(%ebp)
    477e:	e8 55 ef ff ff       	call   36d8 <lodepng_malloc>
    4783:	83 c4 10             	add    $0x10,%esp
    4786:	89 c2                	mov    %eax,%edx
    4788:	8b 45 08             	mov    0x8(%ebp),%eax
    478b:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    478e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4791:	01 c0                	add    %eax,%eax
    4793:	83 ec 0c             	sub    $0xc,%esp
    4796:	50                   	push   %eax
    4797:	e8 3c ef ff ff       	call   36d8 <lodepng_malloc>
    479c:	83 c4 10             	add    $0x10,%esp
    479f:	89 c2                	mov    %eax,%edx
    47a1:	8b 45 08             	mov    0x8(%ebp),%eax
    47a4:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    47a7:	8b 45 08             	mov    0x8(%ebp),%eax
    47aa:	8b 40 10             	mov    0x10(%eax),%eax
    47ad:	85 c0                	test   %eax,%eax
    47af:	74 0a                	je     47bb <HuffmanTree_makeTable+0x172>
    47b1:	8b 45 08             	mov    0x8(%ebp),%eax
    47b4:	8b 40 14             	mov    0x14(%eax),%eax
    47b7:	85 c0                	test   %eax,%eax
    47b9:	75 18                	jne    47d3 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    47bb:	83 ec 0c             	sub    $0xc,%esp
    47be:	ff 75 dc             	pushl  -0x24(%ebp)
    47c1:	e8 33 ef ff ff       	call   36f9 <lodepng_free>
    47c6:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    47c9:	b8 53 00 00 00       	mov    $0x53,%eax
    47ce:	e9 04 03 00 00       	jmp    4ad7 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    47d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    47da:	eb 12                	jmp    47ee <HuffmanTree_makeTable+0x1a5>
    47dc:	8b 45 08             	mov    0x8(%ebp),%eax
    47df:	8b 50 10             	mov    0x10(%eax),%edx
    47e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47e5:	01 d0                	add    %edx,%eax
    47e7:	c6 00 10             	movb   $0x10,(%eax)
    47ea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    47ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47f1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    47f4:	7c e6                	jl     47dc <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    47f6:	a1 08 ba 01 00       	mov    0x1ba08,%eax
    47fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    47fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4805:	eb 5b                	jmp    4862 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4807:	8b 45 f4             	mov    -0xc(%ebp),%eax
    480a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4811:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4814:	01 d0                	add    %edx,%eax
    4816:	8b 00                	mov    (%eax),%eax
    4818:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    481b:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    481f:	76 3c                	jbe    485d <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    4821:	8b 45 08             	mov    0x8(%ebp),%eax
    4824:	8b 50 10             	mov    0x10(%eax),%edx
    4827:	8b 45 f4             	mov    -0xc(%ebp),%eax
    482a:	01 d0                	add    %edx,%eax
    482c:	8b 55 c8             	mov    -0x38(%ebp),%edx
    482f:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    4831:	8b 45 08             	mov    0x8(%ebp),%eax
    4834:	8b 40 14             	mov    0x14(%eax),%eax
    4837:	8b 55 f4             	mov    -0xc(%ebp),%edx
    483a:	01 d2                	add    %edx,%edx
    483c:	01 d0                	add    %edx,%eax
    483e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4841:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    4844:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4847:	83 e8 09             	sub    $0x9,%eax
    484a:	ba 01 00 00 00       	mov    $0x1,%edx
    484f:	89 c1                	mov    %eax,%ecx
    4851:	d3 e2                	shl    %cl,%edx
    4853:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4856:	01 d0                	add    %edx,%eax
    4858:	89 45 ec             	mov    %eax,-0x14(%ebp)
    485b:	eb 01                	jmp    485e <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    485d:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    485e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4862:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4865:	a1 08 ba 01 00       	mov    0x1ba08,%eax
    486a:	39 c2                	cmp    %eax,%edx
    486c:	72 99                	jb     4807 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    486e:	83 ec 0c             	sub    $0xc,%esp
    4871:	ff 75 dc             	pushl  -0x24(%ebp)
    4874:	e8 80 ee ff ff       	call   36f9 <lodepng_free>
    4879:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    487c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    4883:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    488a:	e9 9d 01 00 00       	jmp    4a2c <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    488f:	8b 45 08             	mov    0x8(%ebp),%eax
    4892:	8b 40 04             	mov    0x4(%eax),%eax
    4895:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4898:	c1 e2 02             	shl    $0x2,%edx
    489b:	01 d0                	add    %edx,%eax
    489d:	8b 00                	mov    (%eax),%eax
    489f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    48a2:	8b 45 08             	mov    0x8(%ebp),%eax
    48a5:	8b 00                	mov    (%eax),%eax
    48a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    48aa:	c1 e2 02             	shl    $0x2,%edx
    48ad:	01 d0                	add    %edx,%eax
    48af:	8b 00                	mov    (%eax),%eax
    48b1:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    48b4:	83 ec 08             	sub    $0x8,%esp
    48b7:	ff 75 c4             	pushl  -0x3c(%ebp)
    48ba:	ff 75 c0             	pushl  -0x40(%ebp)
    48bd:	e8 c0 fc ff ff       	call   4582 <reverseBits>
    48c2:	83 c4 10             	add    $0x10,%esp
    48c5:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    48c8:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    48cc:	0f 84 55 01 00 00    	je     4a27 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    48d2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    48d6:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    48da:	0f 87 81 00 00 00    	ja     4961 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    48e0:	b8 09 00 00 00       	mov    $0x9,%eax
    48e5:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    48e8:	ba 01 00 00 00       	mov    $0x1,%edx
    48ed:	89 c1                	mov    %eax,%ecx
    48ef:	d3 e2                	shl    %cl,%edx
    48f1:	89 d0                	mov    %edx,%eax
    48f3:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    48f6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    48fd:	eb 55                	jmp    4954 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    48ff:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4902:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4905:	89 c1                	mov    %eax,%ecx
    4907:	d3 e2                	shl    %cl,%edx
    4909:	89 d0                	mov    %edx,%eax
    490b:	0b 45 bc             	or     -0x44(%ebp),%eax
    490e:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4911:	8b 45 08             	mov    0x8(%ebp),%eax
    4914:	8b 50 10             	mov    0x10(%eax),%edx
    4917:	8b 45 98             	mov    -0x68(%ebp),%eax
    491a:	01 d0                	add    %edx,%eax
    491c:	0f b6 00             	movzbl (%eax),%eax
    491f:	3c 10                	cmp    $0x10,%al
    4921:	74 0a                	je     492d <HuffmanTree_makeTable+0x2e4>
    4923:	b8 37 00 00 00       	mov    $0x37,%eax
    4928:	e9 aa 01 00 00       	jmp    4ad7 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    492d:	8b 45 08             	mov    0x8(%ebp),%eax
    4930:	8b 50 10             	mov    0x10(%eax),%edx
    4933:	8b 45 98             	mov    -0x68(%ebp),%eax
    4936:	01 d0                	add    %edx,%eax
    4938:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    493b:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    493d:	8b 45 08             	mov    0x8(%ebp),%eax
    4940:	8b 40 14             	mov    0x14(%eax),%eax
    4943:	8b 55 98             	mov    -0x68(%ebp),%edx
    4946:	01 d2                	add    %edx,%edx
    4948:	01 d0                	add    %edx,%eax
    494a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    494d:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    4950:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    4954:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4957:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    495a:	72 a3                	jb     48ff <HuffmanTree_makeTable+0x2b6>
    495c:	e9 c7 00 00 00       	jmp    4a28 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    4961:	a1 0c ba 01 00       	mov    0x1ba0c,%eax
    4966:	23 45 bc             	and    -0x44(%ebp),%eax
    4969:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    496c:	8b 45 08             	mov    0x8(%ebp),%eax
    496f:	8b 50 10             	mov    0x10(%eax),%edx
    4972:	8b 45 b8             	mov    -0x48(%ebp),%eax
    4975:	01 d0                	add    %edx,%eax
    4977:	0f b6 00             	movzbl (%eax),%eax
    497a:	0f b6 c0             	movzbl %al,%eax
    497d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    4980:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4983:	83 e8 09             	sub    $0x9,%eax
    4986:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    4989:	8b 45 08             	mov    0x8(%ebp),%eax
    498c:	8b 40 14             	mov    0x14(%eax),%eax
    498f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    4992:	01 d2                	add    %edx,%edx
    4994:	01 d0                	add    %edx,%eax
    4996:	0f b7 00             	movzwl (%eax),%eax
    4999:	0f b7 c0             	movzwl %ax,%eax
    499c:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    499f:	8b 45 b0             	mov    -0x50(%ebp),%eax
    49a2:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    49a5:	83 c0 09             	add    $0x9,%eax
    49a8:	ba 01 00 00 00       	mov    $0x1,%edx
    49ad:	89 c1                	mov    %eax,%ecx
    49af:	d3 e2                	shl    %cl,%edx
    49b1:	89 d0                	mov    %edx,%eax
    49b3:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    49b6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    49b9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    49bc:	73 0a                	jae    49c8 <HuffmanTree_makeTable+0x37f>
    49be:	b8 37 00 00 00       	mov    $0x37,%eax
    49c3:	e9 0f 01 00 00       	jmp    4ad7 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    49c8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    49cf:	eb 4c                	jmp    4a1d <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    49d1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    49d4:	c1 e8 09             	shr    $0x9,%eax
    49d7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    49da:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    49dd:	83 e8 09             	sub    $0x9,%eax
    49e0:	8b 55 e0             	mov    -0x20(%ebp),%edx
    49e3:	89 c1                	mov    %eax,%ecx
    49e5:	d3 e2                	shl    %cl,%edx
    49e7:	89 d0                	mov    %edx,%eax
    49e9:	0b 45 a4             	or     -0x5c(%ebp),%eax
    49ec:	89 c2                	mov    %eax,%edx
    49ee:	8b 45 ac             	mov    -0x54(%ebp),%eax
    49f1:	01 d0                	add    %edx,%eax
    49f3:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    49f6:	8b 45 08             	mov    0x8(%ebp),%eax
    49f9:	8b 50 10             	mov    0x10(%eax),%edx
    49fc:	8b 45 a0             	mov    -0x60(%ebp),%eax
    49ff:	01 d0                	add    %edx,%eax
    4a01:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4a04:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4a06:	8b 45 08             	mov    0x8(%ebp),%eax
    4a09:	8b 40 14             	mov    0x14(%eax),%eax
    4a0c:	8b 55 a0             	mov    -0x60(%ebp),%edx
    4a0f:	01 d2                	add    %edx,%edx
    4a11:	01 d0                	add    %edx,%eax
    4a13:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a16:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4a19:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4a1d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4a20:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    4a23:	72 ac                	jb     49d1 <HuffmanTree_makeTable+0x388>
    4a25:	eb 01                	jmp    4a28 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4a27:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4a28:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4a2c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a2f:	8b 50 0c             	mov    0xc(%eax),%edx
    4a32:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a35:	39 c2                	cmp    %eax,%edx
    4a37:	0f 87 52 fe ff ff    	ja     488f <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    4a3d:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    4a41:	7f 61                	jg     4aa4 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4a43:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4a4a:	eb 4e                	jmp    4a9a <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4a4c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a4f:	8b 50 10             	mov    0x10(%eax),%edx
    4a52:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a55:	01 d0                	add    %edx,%eax
    4a57:	0f b6 00             	movzbl (%eax),%eax
    4a5a:	3c 10                	cmp    $0x10,%al
    4a5c:	75 38                	jne    4a96 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    4a5e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a61:	8b 50 10             	mov    0x10(%eax),%edx
    4a64:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a67:	01 d0                	add    %edx,%eax
    4a69:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4a6c:	8b 15 08 ba 01 00    	mov    0x1ba08,%edx
    4a72:	39 d1                	cmp    %edx,%ecx
    4a74:	73 07                	jae    4a7d <HuffmanTree_makeTable+0x434>
    4a76:	ba 01 00 00 00       	mov    $0x1,%edx
    4a7b:	eb 05                	jmp    4a82 <HuffmanTree_makeTable+0x439>
    4a7d:	ba 0a 00 00 00       	mov    $0xa,%edx
    4a82:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    4a84:	8b 45 08             	mov    0x8(%ebp),%eax
    4a87:	8b 40 14             	mov    0x14(%eax),%eax
    4a8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4a8d:	01 d2                	add    %edx,%edx
    4a8f:	01 d0                	add    %edx,%eax
    4a91:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4a96:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4a9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a9d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4aa0:	7c aa                	jl     4a4c <HuffmanTree_makeTable+0x403>
    4aa2:	eb 2e                	jmp    4ad2 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4aa4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4aab:	eb 1d                	jmp    4aca <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    4aad:	8b 45 08             	mov    0x8(%ebp),%eax
    4ab0:	8b 50 10             	mov    0x10(%eax),%edx
    4ab3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ab6:	01 d0                	add    %edx,%eax
    4ab8:	0f b6 00             	movzbl (%eax),%eax
    4abb:	3c 10                	cmp    $0x10,%al
    4abd:	75 07                	jne    4ac6 <HuffmanTree_makeTable+0x47d>
    4abf:	b8 37 00 00 00       	mov    $0x37,%eax
    4ac4:	eb 11                	jmp    4ad7 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4ac6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4acd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4ad0:	7c db                	jl     4aad <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    4ad2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4ad7:	c9                   	leave  
    4ad8:	c3                   	ret    

00004ad9 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    4ad9:	55                   	push   %ebp
    4ada:	89 e5                	mov    %esp,%ebp
    4adc:	56                   	push   %esi
    4add:	53                   	push   %ebx
    4ade:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    4ae1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4ae8:	8b 45 08             	mov    0x8(%ebp),%eax
    4aeb:	8b 40 0c             	mov    0xc(%eax),%eax
    4aee:	c1 e0 02             	shl    $0x2,%eax
    4af1:	83 ec 0c             	sub    $0xc,%esp
    4af4:	50                   	push   %eax
    4af5:	e8 de eb ff ff       	call   36d8 <lodepng_malloc>
    4afa:	83 c4 10             	add    $0x10,%esp
    4afd:	89 c2                	mov    %eax,%edx
    4aff:	8b 45 08             	mov    0x8(%ebp),%eax
    4b02:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4b04:	8b 45 08             	mov    0x8(%ebp),%eax
    4b07:	8b 40 08             	mov    0x8(%eax),%eax
    4b0a:	83 c0 01             	add    $0x1,%eax
    4b0d:	c1 e0 02             	shl    $0x2,%eax
    4b10:	83 ec 0c             	sub    $0xc,%esp
    4b13:	50                   	push   %eax
    4b14:	e8 bf eb ff ff       	call   36d8 <lodepng_malloc>
    4b19:	83 c4 10             	add    $0x10,%esp
    4b1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4b1f:	8b 45 08             	mov    0x8(%ebp),%eax
    4b22:	8b 40 08             	mov    0x8(%eax),%eax
    4b25:	83 c0 01             	add    $0x1,%eax
    4b28:	c1 e0 02             	shl    $0x2,%eax
    4b2b:	83 ec 0c             	sub    $0xc,%esp
    4b2e:	50                   	push   %eax
    4b2f:	e8 a4 eb ff ff       	call   36d8 <lodepng_malloc>
    4b34:	83 c4 10             	add    $0x10,%esp
    4b37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4b3a:	8b 45 08             	mov    0x8(%ebp),%eax
    4b3d:	8b 00                	mov    (%eax),%eax
    4b3f:	85 c0                	test   %eax,%eax
    4b41:	74 0c                	je     4b4f <HuffmanTree_makeFromLengths2+0x76>
    4b43:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4b47:	74 06                	je     4b4f <HuffmanTree_makeFromLengths2+0x76>
    4b49:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4b4d:	75 07                	jne    4b56 <HuffmanTree_makeFromLengths2+0x7d>
    4b4f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    4b56:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4b5a:	0f 85 7d 01 00 00    	jne    4cdd <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    4b60:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4b67:	eb 2c                	jmp    4b95 <HuffmanTree_makeFromLengths2+0xbc>
    4b69:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4b6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4b73:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4b76:	01 c2                	add    %eax,%edx
    4b78:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4b7b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4b82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4b85:	01 c8                	add    %ecx,%eax
    4b87:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4b8d:	8b 00                	mov    (%eax),%eax
    4b8f:	89 02                	mov    %eax,(%edx)
    4b91:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4b95:	8b 45 08             	mov    0x8(%ebp),%eax
    4b98:	8b 40 08             	mov    0x8(%eax),%eax
    4b9b:	83 c0 01             	add    $0x1,%eax
    4b9e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4ba1:	75 c6                	jne    4b69 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    4ba3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4baa:	eb 27                	jmp    4bd3 <HuffmanTree_makeFromLengths2+0xfa>
    4bac:	8b 45 08             	mov    0x8(%ebp),%eax
    4baf:	8b 40 04             	mov    0x4(%eax),%eax
    4bb2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4bb5:	c1 e2 02             	shl    $0x2,%edx
    4bb8:	01 d0                	add    %edx,%eax
    4bba:	8b 00                	mov    (%eax),%eax
    4bbc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4bc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4bc6:	01 d0                	add    %edx,%eax
    4bc8:	8b 10                	mov    (%eax),%edx
    4bca:	83 c2 01             	add    $0x1,%edx
    4bcd:	89 10                	mov    %edx,(%eax)
    4bcf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4bd3:	8b 45 08             	mov    0x8(%ebp),%eax
    4bd6:	8b 40 0c             	mov    0xc(%eax),%eax
    4bd9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4bdc:	75 ce                	jne    4bac <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4bde:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4be5:	eb 47                	jmp    4c2e <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4be7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4bea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4bf1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4bf4:	01 d0                	add    %edx,%eax
    4bf6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4bf9:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4bff:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4c06:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4c09:	01 ca                	add    %ecx,%edx
    4c0b:	8b 0a                	mov    (%edx),%ecx
    4c0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4c10:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4c16:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4c1d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4c20:	01 da                	add    %ebx,%edx
    4c22:	8b 12                	mov    (%edx),%edx
    4c24:	01 ca                	add    %ecx,%edx
    4c26:	01 d2                	add    %edx,%edx
    4c28:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4c2a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4c2e:	8b 45 08             	mov    0x8(%ebp),%eax
    4c31:	8b 40 08             	mov    0x8(%eax),%eax
    4c34:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4c37:	73 ae                	jae    4be7 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4c39:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4c40:	e9 89 00 00 00       	jmp    4cce <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4c45:	8b 45 08             	mov    0x8(%ebp),%eax
    4c48:	8b 40 04             	mov    0x4(%eax),%eax
    4c4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4c4e:	c1 e2 02             	shl    $0x2,%edx
    4c51:	01 d0                	add    %edx,%eax
    4c53:	8b 00                	mov    (%eax),%eax
    4c55:	85 c0                	test   %eax,%eax
    4c57:	74 71                	je     4cca <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4c59:	8b 45 08             	mov    0x8(%ebp),%eax
    4c5c:	8b 00                	mov    (%eax),%eax
    4c5e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4c61:	c1 e2 02             	shl    $0x2,%edx
    4c64:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4c67:	8b 45 08             	mov    0x8(%ebp),%eax
    4c6a:	8b 40 04             	mov    0x4(%eax),%eax
    4c6d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4c70:	c1 e2 02             	shl    $0x2,%edx
    4c73:	01 d0                	add    %edx,%eax
    4c75:	8b 00                	mov    (%eax),%eax
    4c77:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4c7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c81:	01 c2                	add    %eax,%edx
    4c83:	8b 02                	mov    (%edx),%eax
    4c85:	8d 48 01             	lea    0x1(%eax),%ecx
    4c88:	89 0a                	mov    %ecx,(%edx)
    4c8a:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4c8c:	8b 45 08             	mov    0x8(%ebp),%eax
    4c8f:	8b 00                	mov    (%eax),%eax
    4c91:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4c94:	c1 e2 02             	shl    $0x2,%edx
    4c97:	01 c2                	add    %eax,%edx
    4c99:	8b 45 08             	mov    0x8(%ebp),%eax
    4c9c:	8b 00                	mov    (%eax),%eax
    4c9e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4ca1:	c1 e1 02             	shl    $0x2,%ecx
    4ca4:	01 c8                	add    %ecx,%eax
    4ca6:	8b 18                	mov    (%eax),%ebx
    4ca8:	8b 45 08             	mov    0x8(%ebp),%eax
    4cab:	8b 40 04             	mov    0x4(%eax),%eax
    4cae:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4cb1:	c1 e1 02             	shl    $0x2,%ecx
    4cb4:	01 c8                	add    %ecx,%eax
    4cb6:	8b 00                	mov    (%eax),%eax
    4cb8:	be 01 00 00 00       	mov    $0x1,%esi
    4cbd:	89 c1                	mov    %eax,%ecx
    4cbf:	d3 e6                	shl    %cl,%esi
    4cc1:	89 f0                	mov    %esi,%eax
    4cc3:	83 e8 01             	sub    $0x1,%eax
    4cc6:	21 d8                	and    %ebx,%eax
    4cc8:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4cca:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4cce:	8b 45 08             	mov    0x8(%ebp),%eax
    4cd1:	8b 40 0c             	mov    0xc(%eax),%eax
    4cd4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4cd7:	0f 85 68 ff ff ff    	jne    4c45 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    4cdd:	83 ec 0c             	sub    $0xc,%esp
    4ce0:	ff 75 e8             	pushl  -0x18(%ebp)
    4ce3:	e8 11 ea ff ff       	call   36f9 <lodepng_free>
    4ce8:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4ceb:	83 ec 0c             	sub    $0xc,%esp
    4cee:	ff 75 e4             	pushl  -0x1c(%ebp)
    4cf1:	e8 03 ea ff ff       	call   36f9 <lodepng_free>
    4cf6:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4cf9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4cfd:	75 11                	jne    4d10 <HuffmanTree_makeFromLengths2+0x237>
    4cff:	83 ec 0c             	sub    $0xc,%esp
    4d02:	ff 75 08             	pushl  0x8(%ebp)
    4d05:	e8 3f f9 ff ff       	call   4649 <HuffmanTree_makeTable>
    4d0a:	83 c4 10             	add    $0x10,%esp
    4d0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    4d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4d13:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4d16:	5b                   	pop    %ebx
    4d17:	5e                   	pop    %esi
    4d18:	5d                   	pop    %ebp
    4d19:	c3                   	ret    

00004d1a <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4d1a:	55                   	push   %ebp
    4d1b:	89 e5                	mov    %esp,%ebp
    4d1d:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4d20:	8b 45 10             	mov    0x10(%ebp),%eax
    4d23:	c1 e0 02             	shl    $0x2,%eax
    4d26:	83 ec 0c             	sub    $0xc,%esp
    4d29:	50                   	push   %eax
    4d2a:	e8 a9 e9 ff ff       	call   36d8 <lodepng_malloc>
    4d2f:	83 c4 10             	add    $0x10,%esp
    4d32:	89 c2                	mov    %eax,%edx
    4d34:	8b 45 08             	mov    0x8(%ebp),%eax
    4d37:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4d3a:	8b 45 08             	mov    0x8(%ebp),%eax
    4d3d:	8b 40 04             	mov    0x4(%eax),%eax
    4d40:	85 c0                	test   %eax,%eax
    4d42:	75 07                	jne    4d4b <HuffmanTree_makeFromLengths+0x31>
    4d44:	b8 53 00 00 00       	mov    $0x53,%eax
    4d49:	eb 56                	jmp    4da1 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4d4b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4d52:	eb 25                	jmp    4d79 <HuffmanTree_makeFromLengths+0x5f>
    4d54:	8b 45 08             	mov    0x8(%ebp),%eax
    4d57:	8b 40 04             	mov    0x4(%eax),%eax
    4d5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4d5d:	c1 e2 02             	shl    $0x2,%edx
    4d60:	01 c2                	add    %eax,%edx
    4d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d65:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4d6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d6f:	01 c8                	add    %ecx,%eax
    4d71:	8b 00                	mov    (%eax),%eax
    4d73:	89 02                	mov    %eax,(%edx)
    4d75:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4d79:	8b 45 10             	mov    0x10(%ebp),%eax
    4d7c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4d7f:	75 d3                	jne    4d54 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4d81:	8b 55 10             	mov    0x10(%ebp),%edx
    4d84:	8b 45 08             	mov    0x8(%ebp),%eax
    4d87:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    4d8a:	8b 45 08             	mov    0x8(%ebp),%eax
    4d8d:	8b 55 14             	mov    0x14(%ebp),%edx
    4d90:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4d93:	83 ec 0c             	sub    $0xc,%esp
    4d96:	ff 75 08             	pushl  0x8(%ebp)
    4d99:	e8 3b fd ff ff       	call   4ad9 <HuffmanTree_makeFromLengths2>
    4d9e:	83 c4 10             	add    $0x10,%esp
}
    4da1:	c9                   	leave  
    4da2:	c3                   	ret    

00004da3 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4da3:	55                   	push   %ebp
    4da4:	89 e5                	mov    %esp,%ebp
    4da6:	53                   	push   %ebx
    4da7:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4daa:	8b 45 08             	mov    0x8(%ebp),%eax
    4dad:	8b 50 0c             	mov    0xc(%eax),%edx
    4db0:	8b 45 08             	mov    0x8(%ebp),%eax
    4db3:	8b 40 08             	mov    0x8(%eax),%eax
    4db6:	39 c2                	cmp    %eax,%edx
    4db8:	0f 82 0b 01 00 00    	jb     4ec9 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4dbe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4dc5:	eb 19                	jmp    4de0 <bpmnode_create+0x3d>
    4dc7:	8b 45 08             	mov    0x8(%ebp),%eax
    4dca:	8b 40 04             	mov    0x4(%eax),%eax
    4dcd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4dd0:	c1 e2 04             	shl    $0x4,%edx
    4dd3:	01 d0                	add    %edx,%eax
    4dd5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4ddc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4de0:	8b 45 08             	mov    0x8(%ebp),%eax
    4de3:	8b 00                	mov    (%eax),%eax
    4de5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4de8:	75 dd                	jne    4dc7 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4dea:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4df1:	eb 60                	jmp    4e53 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4df3:	8b 45 08             	mov    0x8(%ebp),%eax
    4df6:	8b 40 18             	mov    0x18(%eax),%eax
    4df9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4dfc:	c1 e2 02             	shl    $0x2,%edx
    4dff:	01 d0                	add    %edx,%eax
    4e01:	8b 00                	mov    (%eax),%eax
    4e03:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4e06:	eb 13                	jmp    4e1b <bpmnode_create+0x78>
    4e08:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e0b:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4e12:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e15:	8b 40 08             	mov    0x8(%eax),%eax
    4e18:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4e1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4e1f:	75 e7                	jne    4e08 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4e21:	8b 45 08             	mov    0x8(%ebp),%eax
    4e24:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e27:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4e2a:	c1 e2 02             	shl    $0x2,%edx
    4e2d:	01 d0                	add    %edx,%eax
    4e2f:	8b 00                	mov    (%eax),%eax
    4e31:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4e34:	eb 13                	jmp    4e49 <bpmnode_create+0xa6>
    4e36:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e39:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4e40:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e43:	8b 40 08             	mov    0x8(%eax),%eax
    4e46:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4e49:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4e4d:	75 e7                	jne    4e36 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4e4f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4e53:	8b 45 08             	mov    0x8(%ebp),%eax
    4e56:	8b 40 14             	mov    0x14(%eax),%eax
    4e59:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4e5c:	75 95                	jne    4df3 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4e5e:	8b 45 08             	mov    0x8(%ebp),%eax
    4e61:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4e68:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4e6f:	eb 44                	jmp    4eb5 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4e71:	8b 45 08             	mov    0x8(%ebp),%eax
    4e74:	8b 40 04             	mov    0x4(%eax),%eax
    4e77:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4e7a:	c1 e2 04             	shl    $0x4,%edx
    4e7d:	01 d0                	add    %edx,%eax
    4e7f:	8b 40 0c             	mov    0xc(%eax),%eax
    4e82:	85 c0                	test   %eax,%eax
    4e84:	75 2b                	jne    4eb1 <bpmnode_create+0x10e>
    4e86:	8b 45 08             	mov    0x8(%ebp),%eax
    4e89:	8b 58 10             	mov    0x10(%eax),%ebx
    4e8c:	8b 45 08             	mov    0x8(%ebp),%eax
    4e8f:	8b 40 08             	mov    0x8(%eax),%eax
    4e92:	8d 48 01             	lea    0x1(%eax),%ecx
    4e95:	8b 55 08             	mov    0x8(%ebp),%edx
    4e98:	89 4a 08             	mov    %ecx,0x8(%edx)
    4e9b:	c1 e0 02             	shl    $0x2,%eax
    4e9e:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4ea1:	8b 45 08             	mov    0x8(%ebp),%eax
    4ea4:	8b 40 04             	mov    0x4(%eax),%eax
    4ea7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4eaa:	c1 e1 04             	shl    $0x4,%ecx
    4ead:	01 c8                	add    %ecx,%eax
    4eaf:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4eb1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4eb5:	8b 45 08             	mov    0x8(%ebp),%eax
    4eb8:	8b 00                	mov    (%eax),%eax
    4eba:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4ebd:	75 b2                	jne    4e71 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4ebf:	8b 45 08             	mov    0x8(%ebp),%eax
    4ec2:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4ec9:	8b 45 08             	mov    0x8(%ebp),%eax
    4ecc:	8b 58 10             	mov    0x10(%eax),%ebx
    4ecf:	8b 45 08             	mov    0x8(%ebp),%eax
    4ed2:	8b 40 0c             	mov    0xc(%eax),%eax
    4ed5:	8d 48 01             	lea    0x1(%eax),%ecx
    4ed8:	8b 55 08             	mov    0x8(%ebp),%edx
    4edb:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4ede:	c1 e0 02             	shl    $0x2,%eax
    4ee1:	01 d8                	add    %ebx,%eax
    4ee3:	8b 00                	mov    (%eax),%eax
    4ee5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4ee8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4eeb:	8b 55 0c             	mov    0xc(%ebp),%edx
    4eee:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4ef0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4ef3:	8b 55 10             	mov    0x10(%ebp),%edx
    4ef6:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4efc:	8b 55 14             	mov    0x14(%ebp),%edx
    4eff:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4f02:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4f05:	83 c4 10             	add    $0x10,%esp
    4f08:	5b                   	pop    %ebx
    4f09:	5d                   	pop    %ebp
    4f0a:	c3                   	ret    

00004f0b <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4f0b:	55                   	push   %ebp
    4f0c:	89 e5                	mov    %esp,%ebp
    4f0e:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4f11:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f14:	c1 e0 04             	shl    $0x4,%eax
    4f17:	83 ec 0c             	sub    $0xc,%esp
    4f1a:	50                   	push   %eax
    4f1b:	e8 b8 e7 ff ff       	call   36d8 <lodepng_malloc>
    4f20:	83 c4 10             	add    $0x10,%esp
    4f23:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4f26:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4f2d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4f34:	e9 41 01 00 00       	jmp    507a <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4f39:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f3c:	83 e0 01             	and    $0x1,%eax
    4f3f:	85 c0                	test   %eax,%eax
    4f41:	74 05                	je     4f48 <bpmnode_sort+0x3d>
    4f43:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4f46:	eb 03                	jmp    4f4b <bpmnode_sort+0x40>
    4f48:	8b 45 08             	mov    0x8(%ebp),%eax
    4f4b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4f4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f51:	83 e0 01             	and    $0x1,%eax
    4f54:	85 c0                	test   %eax,%eax
    4f56:	74 05                	je     4f5d <bpmnode_sort+0x52>
    4f58:	8b 45 08             	mov    0x8(%ebp),%eax
    4f5b:	eb 03                	jmp    4f60 <bpmnode_sort+0x55>
    4f5d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4f60:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4f63:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4f6a:	e9 f8 00 00 00       	jmp    5067 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4f6f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4f72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f75:	01 c2                	add    %eax,%edx
    4f77:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f7a:	39 c2                	cmp    %eax,%edx
    4f7c:	0f 4e c2             	cmovle %edx,%eax
    4f7f:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4f82:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f85:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4f88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f8b:	01 c2                	add    %eax,%edx
    4f8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f90:	39 c2                	cmp    %eax,%edx
    4f92:	0f 4e c2             	cmovle %edx,%eax
    4f95:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4f98:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f9b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4f9e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4fa1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4fa4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4fa7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4faa:	e9 a4 00 00 00       	jmp    5053 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4faf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4fb2:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4fb5:	7d 62                	jge    5019 <bpmnode_sort+0x10e>
    4fb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fba:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4fbd:	7d 22                	jge    4fe1 <bpmnode_sort+0xd6>
    4fbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4fc2:	c1 e0 04             	shl    $0x4,%eax
    4fc5:	89 c2                	mov    %eax,%edx
    4fc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4fca:	01 d0                	add    %edx,%eax
    4fcc:	8b 10                	mov    (%eax),%edx
    4fce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fd1:	c1 e0 04             	shl    $0x4,%eax
    4fd4:	89 c1                	mov    %eax,%ecx
    4fd6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4fd9:	01 c8                	add    %ecx,%eax
    4fdb:	8b 00                	mov    (%eax),%eax
    4fdd:	39 c2                	cmp    %eax,%edx
    4fdf:	7f 38                	jg     5019 <bpmnode_sort+0x10e>
    4fe1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4fe4:	c1 e0 04             	shl    $0x4,%eax
    4fe7:	89 c2                	mov    %eax,%edx
    4fe9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4fec:	01 d0                	add    %edx,%eax
    4fee:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4ff1:	8d 4a 01             	lea    0x1(%edx),%ecx
    4ff4:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4ff7:	89 d1                	mov    %edx,%ecx
    4ff9:	c1 e1 04             	shl    $0x4,%ecx
    4ffc:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4fff:	01 ca                	add    %ecx,%edx
    5001:	8b 0a                	mov    (%edx),%ecx
    5003:	89 08                	mov    %ecx,(%eax)
    5005:	8b 4a 04             	mov    0x4(%edx),%ecx
    5008:	89 48 04             	mov    %ecx,0x4(%eax)
    500b:	8b 4a 08             	mov    0x8(%edx),%ecx
    500e:	89 48 08             	mov    %ecx,0x8(%eax)
    5011:	8b 52 0c             	mov    0xc(%edx),%edx
    5014:	89 50 0c             	mov    %edx,0xc(%eax)
    5017:	eb 36                	jmp    504f <bpmnode_sort+0x144>
        else b[k] = a[j++];
    5019:	8b 45 e0             	mov    -0x20(%ebp),%eax
    501c:	c1 e0 04             	shl    $0x4,%eax
    501f:	89 c2                	mov    %eax,%edx
    5021:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5024:	01 d0                	add    %edx,%eax
    5026:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5029:	8d 4a 01             	lea    0x1(%edx),%ecx
    502c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    502f:	89 d1                	mov    %edx,%ecx
    5031:	c1 e1 04             	shl    $0x4,%ecx
    5034:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5037:	01 ca                	add    %ecx,%edx
    5039:	8b 0a                	mov    (%edx),%ecx
    503b:	89 08                	mov    %ecx,(%eax)
    503d:	8b 4a 04             	mov    0x4(%edx),%ecx
    5040:	89 48 04             	mov    %ecx,0x4(%eax)
    5043:	8b 4a 08             	mov    0x8(%edx),%ecx
    5046:	89 48 08             	mov    %ecx,0x8(%eax)
    5049:	8b 52 0c             	mov    0xc(%edx),%edx
    504c:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    504f:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5053:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5056:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    5059:	0f 8c 50 ff ff ff    	jl     4faf <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    505f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5062:	01 c0                	add    %eax,%eax
    5064:	01 45 ec             	add    %eax,-0x14(%ebp)
    5067:	8b 45 ec             	mov    -0x14(%ebp),%eax
    506a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    506d:	0f 8c fc fe ff ff    	jl     4f6f <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    5073:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    5077:	d1 65 f4             	shll   -0xc(%ebp)
    507a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    507d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5080:	0f 8c b3 fe ff ff    	jl     4f39 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    5086:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5089:	83 e0 01             	and    $0x1,%eax
    508c:	85 c0                	test   %eax,%eax
    508e:	74 18                	je     50a8 <bpmnode_sort+0x19d>
    5090:	8b 45 0c             	mov    0xc(%ebp),%eax
    5093:	c1 e0 04             	shl    $0x4,%eax
    5096:	83 ec 04             	sub    $0x4,%esp
    5099:	50                   	push   %eax
    509a:	ff 75 dc             	pushl  -0x24(%ebp)
    509d:	ff 75 08             	pushl  0x8(%ebp)
    50a0:	e8 71 e6 ff ff       	call   3716 <lodepng_memcpy>
    50a5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    50a8:	83 ec 0c             	sub    $0xc,%esp
    50ab:	ff 75 dc             	pushl  -0x24(%ebp)
    50ae:	e8 46 e6 ff ff       	call   36f9 <lodepng_free>
    50b3:	83 c4 10             	add    $0x10,%esp
}
    50b6:	90                   	nop
    50b7:	c9                   	leave  
    50b8:	c3                   	ret    

000050b9 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    50b9:	55                   	push   %ebp
    50ba:	89 e5                	mov    %esp,%ebp
    50bc:	56                   	push   %esi
    50bd:	53                   	push   %ebx
    50be:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    50c1:	8b 45 08             	mov    0x8(%ebp),%eax
    50c4:	8b 40 1c             	mov    0x1c(%eax),%eax
    50c7:	8b 55 14             	mov    0x14(%ebp),%edx
    50ca:	c1 e2 02             	shl    $0x2,%edx
    50cd:	01 d0                	add    %edx,%eax
    50cf:	8b 00                	mov    (%eax),%eax
    50d1:	8b 40 04             	mov    0x4(%eax),%eax
    50d4:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    50d7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    50db:	75 66                	jne    5143 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    50dd:	8b 45 10             	mov    0x10(%ebp),%eax
    50e0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    50e3:	0f 83 a0 01 00 00    	jae    5289 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    50e9:	8b 45 08             	mov    0x8(%ebp),%eax
    50ec:	8b 40 18             	mov    0x18(%eax),%eax
    50ef:	8b 55 14             	mov    0x14(%ebp),%edx
    50f2:	c1 e2 02             	shl    $0x2,%edx
    50f5:	01 c2                	add    %eax,%edx
    50f7:	8b 45 08             	mov    0x8(%ebp),%eax
    50fa:	8b 40 1c             	mov    0x1c(%eax),%eax
    50fd:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5100:	c1 e1 02             	shl    $0x2,%ecx
    5103:	01 c8                	add    %ecx,%eax
    5105:	8b 00                	mov    (%eax),%eax
    5107:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    5109:	8b 45 08             	mov    0x8(%ebp),%eax
    510c:	8b 40 1c             	mov    0x1c(%eax),%eax
    510f:	8b 55 14             	mov    0x14(%ebp),%edx
    5112:	c1 e2 02             	shl    $0x2,%edx
    5115:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5118:	8b 45 f4             	mov    -0xc(%ebp),%eax
    511b:	8d 50 01             	lea    0x1(%eax),%edx
    511e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5121:	c1 e0 04             	shl    $0x4,%eax
    5124:	89 c1                	mov    %eax,%ecx
    5126:	8b 45 0c             	mov    0xc(%ebp),%eax
    5129:	01 c8                	add    %ecx,%eax
    512b:	8b 00                	mov    (%eax),%eax
    512d:	6a 00                	push   $0x0
    512f:	52                   	push   %edx
    5130:	50                   	push   %eax
    5131:	ff 75 08             	pushl  0x8(%ebp)
    5134:	e8 6a fc ff ff       	call   4da3 <bpmnode_create>
    5139:	83 c4 10             	add    $0x10,%esp
    513c:	89 03                	mov    %eax,(%ebx)
    513e:	e9 47 01 00 00       	jmp    528a <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    5143:	8b 45 08             	mov    0x8(%ebp),%eax
    5146:	8b 40 18             	mov    0x18(%eax),%eax
    5149:	8b 55 14             	mov    0x14(%ebp),%edx
    514c:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5152:	c1 e2 02             	shl    $0x2,%edx
    5155:	01 d0                	add    %edx,%eax
    5157:	8b 00                	mov    (%eax),%eax
    5159:	8b 10                	mov    (%eax),%edx
    515b:	8b 45 08             	mov    0x8(%ebp),%eax
    515e:	8b 40 1c             	mov    0x1c(%eax),%eax
    5161:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5164:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    516a:	c1 e1 02             	shl    $0x2,%ecx
    516d:	01 c8                	add    %ecx,%eax
    516f:	8b 00                	mov    (%eax),%eax
    5171:	8b 00                	mov    (%eax),%eax
    5173:	01 d0                	add    %edx,%eax
    5175:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    5178:	8b 45 08             	mov    0x8(%ebp),%eax
    517b:	8b 40 18             	mov    0x18(%eax),%eax
    517e:	8b 55 14             	mov    0x14(%ebp),%edx
    5181:	c1 e2 02             	shl    $0x2,%edx
    5184:	01 c2                	add    %eax,%edx
    5186:	8b 45 08             	mov    0x8(%ebp),%eax
    5189:	8b 40 1c             	mov    0x1c(%eax),%eax
    518c:	8b 4d 14             	mov    0x14(%ebp),%ecx
    518f:	c1 e1 02             	shl    $0x2,%ecx
    5192:	01 c8                	add    %ecx,%eax
    5194:	8b 00                	mov    (%eax),%eax
    5196:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    5198:	8b 45 10             	mov    0x10(%ebp),%eax
    519b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    519e:	73 60                	jae    5200 <boundaryPM+0x147>
    51a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    51a3:	c1 e0 04             	shl    $0x4,%eax
    51a6:	89 c2                	mov    %eax,%edx
    51a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    51ab:	01 d0                	add    %edx,%eax
    51ad:	8b 00                	mov    (%eax),%eax
    51af:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51b2:	7d 4c                	jge    5200 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    51b4:	8b 45 08             	mov    0x8(%ebp),%eax
    51b7:	8b 40 1c             	mov    0x1c(%eax),%eax
    51ba:	8b 55 14             	mov    0x14(%ebp),%edx
    51bd:	c1 e2 02             	shl    $0x2,%edx
    51c0:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    51c3:	8b 45 08             	mov    0x8(%ebp),%eax
    51c6:	8b 40 1c             	mov    0x1c(%eax),%eax
    51c9:	8b 55 14             	mov    0x14(%ebp),%edx
    51cc:	c1 e2 02             	shl    $0x2,%edx
    51cf:	01 d0                	add    %edx,%eax
    51d1:	8b 00                	mov    (%eax),%eax
    51d3:	8b 50 08             	mov    0x8(%eax),%edx
    51d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    51d9:	8d 48 01             	lea    0x1(%eax),%ecx
    51dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    51df:	c1 e0 04             	shl    $0x4,%eax
    51e2:	89 c6                	mov    %eax,%esi
    51e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    51e7:	01 f0                	add    %esi,%eax
    51e9:	8b 00                	mov    (%eax),%eax
    51eb:	52                   	push   %edx
    51ec:	51                   	push   %ecx
    51ed:	50                   	push   %eax
    51ee:	ff 75 08             	pushl  0x8(%ebp)
    51f1:	e8 ad fb ff ff       	call   4da3 <bpmnode_create>
    51f6:	83 c4 10             	add    $0x10,%esp
    51f9:	89 03                	mov    %eax,(%ebx)
      return;
    51fb:	e9 8a 00 00 00       	jmp    528a <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    5200:	8b 45 08             	mov    0x8(%ebp),%eax
    5203:	8b 40 1c             	mov    0x1c(%eax),%eax
    5206:	8b 55 14             	mov    0x14(%ebp),%edx
    5209:	c1 e2 02             	shl    $0x2,%edx
    520c:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    520f:	8b 45 08             	mov    0x8(%ebp),%eax
    5212:	8b 40 1c             	mov    0x1c(%eax),%eax
    5215:	8b 55 14             	mov    0x14(%ebp),%edx
    5218:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    521e:	c1 e2 02             	shl    $0x2,%edx
    5221:	01 d0                	add    %edx,%eax
    5223:	8b 00                	mov    (%eax),%eax
    5225:	50                   	push   %eax
    5226:	ff 75 f4             	pushl  -0xc(%ebp)
    5229:	ff 75 f0             	pushl  -0x10(%ebp)
    522c:	ff 75 08             	pushl  0x8(%ebp)
    522f:	e8 6f fb ff ff       	call   4da3 <bpmnode_create>
    5234:	83 c4 10             	add    $0x10,%esp
    5237:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    5239:	8b 45 18             	mov    0x18(%ebp),%eax
    523c:	8d 50 01             	lea    0x1(%eax),%edx
    523f:	8b 45 10             	mov    0x10(%ebp),%eax
    5242:	83 e8 01             	sub    $0x1,%eax
    5245:	01 c0                	add    %eax,%eax
    5247:	39 c2                	cmp    %eax,%edx
    5249:	7d 3f                	jge    528a <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    524b:	8b 45 14             	mov    0x14(%ebp),%eax
    524e:	83 e8 01             	sub    $0x1,%eax
    5251:	83 ec 0c             	sub    $0xc,%esp
    5254:	ff 75 18             	pushl  0x18(%ebp)
    5257:	50                   	push   %eax
    5258:	ff 75 10             	pushl  0x10(%ebp)
    525b:	ff 75 0c             	pushl  0xc(%ebp)
    525e:	ff 75 08             	pushl  0x8(%ebp)
    5261:	e8 53 fe ff ff       	call   50b9 <boundaryPM>
    5266:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5269:	8b 45 14             	mov    0x14(%ebp),%eax
    526c:	83 e8 01             	sub    $0x1,%eax
    526f:	83 ec 0c             	sub    $0xc,%esp
    5272:	ff 75 18             	pushl  0x18(%ebp)
    5275:	50                   	push   %eax
    5276:	ff 75 10             	pushl  0x10(%ebp)
    5279:	ff 75 0c             	pushl  0xc(%ebp)
    527c:	ff 75 08             	pushl  0x8(%ebp)
    527f:	e8 35 fe ff ff       	call   50b9 <boundaryPM>
    5284:	83 c4 20             	add    $0x20,%esp
    5287:	eb 01                	jmp    528a <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    5289:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    528a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    528d:	5b                   	pop    %ebx
    528e:	5e                   	pop    %esi
    528f:	5d                   	pop    %ebp
    5290:	c3                   	ret    

00005291 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    5291:	55                   	push   %ebp
    5292:	89 e5                	mov    %esp,%ebp
    5294:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    5297:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    529e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    52a5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    52a9:	75 0a                	jne    52b5 <lodepng_huffman_code_lengths+0x24>
    52ab:	b8 50 00 00 00       	mov    $0x50,%eax
    52b0:	e9 4d 03 00 00       	jmp    5602 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    52b5:	8b 45 14             	mov    0x14(%ebp),%eax
    52b8:	ba 01 00 00 00       	mov    $0x1,%edx
    52bd:	89 c1                	mov    %eax,%ecx
    52bf:	d3 e2                	shl    %cl,%edx
    52c1:	8b 45 10             	mov    0x10(%ebp),%eax
    52c4:	39 c2                	cmp    %eax,%edx
    52c6:	73 0a                	jae    52d2 <lodepng_huffman_code_lengths+0x41>
    52c8:	b8 50 00 00 00       	mov    $0x50,%eax
    52cd:	e9 30 03 00 00       	jmp    5602 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    52d2:	8b 45 10             	mov    0x10(%ebp),%eax
    52d5:	c1 e0 04             	shl    $0x4,%eax
    52d8:	83 ec 0c             	sub    $0xc,%esp
    52db:	50                   	push   %eax
    52dc:	e8 f7 e3 ff ff       	call   36d8 <lodepng_malloc>
    52e1:	83 c4 10             	add    $0x10,%esp
    52e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    52e7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    52eb:	75 0a                	jne    52f7 <lodepng_huffman_code_lengths+0x66>
    52ed:	b8 53 00 00 00       	mov    $0x53,%eax
    52f2:	e9 0b 03 00 00       	jmp    5602 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    52f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    52fe:	eb 50                	jmp    5350 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    5300:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5303:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    530a:	8b 45 0c             	mov    0xc(%ebp),%eax
    530d:	01 d0                	add    %edx,%eax
    530f:	8b 00                	mov    (%eax),%eax
    5311:	85 c0                	test   %eax,%eax
    5313:	74 37                	je     534c <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    5315:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5318:	c1 e0 04             	shl    $0x4,%eax
    531b:	89 c2                	mov    %eax,%edx
    531d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5320:	01 d0                	add    %edx,%eax
    5322:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5325:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    532c:	8b 55 0c             	mov    0xc(%ebp),%edx
    532f:	01 ca                	add    %ecx,%edx
    5331:	8b 12                	mov    (%edx),%edx
    5333:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    5335:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5338:	c1 e0 04             	shl    $0x4,%eax
    533b:	89 c2                	mov    %eax,%edx
    533d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5340:	01 c2                	add    %eax,%edx
    5342:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5345:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    5348:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    534c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5350:	8b 45 10             	mov    0x10(%ebp),%eax
    5353:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5356:	75 a8                	jne    5300 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    5358:	8b 45 10             	mov    0x10(%ebp),%eax
    535b:	c1 e0 02             	shl    $0x2,%eax
    535e:	83 ec 04             	sub    $0x4,%esp
    5361:	50                   	push   %eax
    5362:	6a 00                	push   $0x0
    5364:	ff 75 08             	pushl  0x8(%ebp)
    5367:	e8 dd e3 ff ff       	call   3749 <lodepng_memset>
    536c:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    536f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5373:	75 18                	jne    538d <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    5375:	8b 45 08             	mov    0x8(%ebp),%eax
    5378:	83 c0 04             	add    $0x4,%eax
    537b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5381:	8b 10                	mov    (%eax),%edx
    5383:	8b 45 08             	mov    0x8(%ebp),%eax
    5386:	89 10                	mov    %edx,(%eax)
    5388:	e9 64 02 00 00       	jmp    55f1 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    538d:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    5391:	75 3e                	jne    53d1 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    5393:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5396:	8b 40 04             	mov    0x4(%eax),%eax
    5399:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53a0:	8b 45 08             	mov    0x8(%ebp),%eax
    53a3:	01 d0                	add    %edx,%eax
    53a5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    53ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    53ae:	8b 40 04             	mov    0x4(%eax),%eax
    53b1:	85 c0                	test   %eax,%eax
    53b3:	75 07                	jne    53bc <lodepng_huffman_code_lengths+0x12b>
    53b5:	ba 04 00 00 00       	mov    $0x4,%edx
    53ba:	eb 05                	jmp    53c1 <lodepng_huffman_code_lengths+0x130>
    53bc:	ba 00 00 00 00       	mov    $0x0,%edx
    53c1:	8b 45 08             	mov    0x8(%ebp),%eax
    53c4:	01 d0                	add    %edx,%eax
    53c6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    53cc:	e9 20 02 00 00       	jmp    55f1 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    53d1:	83 ec 08             	sub    $0x8,%esp
    53d4:	ff 75 ec             	pushl  -0x14(%ebp)
    53d7:	ff 75 e4             	pushl  -0x1c(%ebp)
    53da:	e8 2c fb ff ff       	call   4f0b <bpmnode_sort>
    53df:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    53e2:	8b 45 14             	mov    0x14(%ebp),%eax
    53e5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    53e8:	8b 45 14             	mov    0x14(%ebp),%eax
    53eb:	83 c0 01             	add    $0x1,%eax
    53ee:	0f af 45 14          	imul   0x14(%ebp),%eax
    53f2:	01 c0                	add    %eax,%eax
    53f4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    53f7:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    53fe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5401:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    5404:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5407:	c1 e0 04             	shl    $0x4,%eax
    540a:	83 ec 0c             	sub    $0xc,%esp
    540d:	50                   	push   %eax
    540e:	e8 c5 e2 ff ff       	call   36d8 <lodepng_malloc>
    5413:	83 c4 10             	add    $0x10,%esp
    5416:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5419:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    541c:	c1 e0 02             	shl    $0x2,%eax
    541f:	83 ec 0c             	sub    $0xc,%esp
    5422:	50                   	push   %eax
    5423:	e8 b0 e2 ff ff       	call   36d8 <lodepng_malloc>
    5428:	83 c4 10             	add    $0x10,%esp
    542b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    542e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5431:	c1 e0 02             	shl    $0x2,%eax
    5434:	83 ec 0c             	sub    $0xc,%esp
    5437:	50                   	push   %eax
    5438:	e8 9b e2 ff ff       	call   36d8 <lodepng_malloc>
    543d:	83 c4 10             	add    $0x10,%esp
    5440:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5443:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5446:	c1 e0 02             	shl    $0x2,%eax
    5449:	83 ec 0c             	sub    $0xc,%esp
    544c:	50                   	push   %eax
    544d:	e8 86 e2 ff ff       	call   36d8 <lodepng_malloc>
    5452:	83 c4 10             	add    $0x10,%esp
    5455:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5458:	8b 45 c8             	mov    -0x38(%ebp),%eax
    545b:	85 c0                	test   %eax,%eax
    545d:	74 15                	je     5474 <lodepng_huffman_code_lengths+0x1e3>
    545f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5462:	85 c0                	test   %eax,%eax
    5464:	74 0e                	je     5474 <lodepng_huffman_code_lengths+0x1e3>
    5466:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5469:	85 c0                	test   %eax,%eax
    546b:	74 07                	je     5474 <lodepng_huffman_code_lengths+0x1e3>
    546d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5470:	85 c0                	test   %eax,%eax
    5472:	75 07                	jne    547b <lodepng_huffman_code_lengths+0x1ea>
    5474:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    547b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    547f:	0f 85 30 01 00 00    	jne    55b5 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    5485:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    548c:	eb 1c                	jmp    54aa <lodepng_huffman_code_lengths+0x219>
    548e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5491:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5494:	c1 e2 02             	shl    $0x2,%edx
    5497:	01 d0                	add    %edx,%eax
    5499:	8b 55 c8             	mov    -0x38(%ebp),%edx
    549c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    549f:	c1 e1 04             	shl    $0x4,%ecx
    54a2:	01 ca                	add    %ecx,%edx
    54a4:	89 10                	mov    %edx,(%eax)
    54a6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    54aa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    54ad:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    54b0:	75 dc                	jne    548e <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    54b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    54b5:	8b 00                	mov    (%eax),%eax
    54b7:	6a 00                	push   $0x0
    54b9:	6a 01                	push   $0x1
    54bb:	50                   	push   %eax
    54bc:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    54bf:	50                   	push   %eax
    54c0:	e8 de f8 ff ff       	call   4da3 <bpmnode_create>
    54c5:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    54c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    54cb:	83 c0 10             	add    $0x10,%eax
    54ce:	8b 00                	mov    (%eax),%eax
    54d0:	6a 00                	push   $0x0
    54d2:	6a 02                	push   $0x2
    54d4:	50                   	push   %eax
    54d5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    54d8:	50                   	push   %eax
    54d9:	e8 c5 f8 ff ff       	call   4da3 <bpmnode_create>
    54de:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    54e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    54e8:	eb 27                	jmp    5511 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    54ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
    54ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
    54f0:	c1 e2 02             	shl    $0x2,%edx
    54f3:	01 c2                	add    %eax,%edx
    54f5:	8b 45 c8             	mov    -0x38(%ebp),%eax
    54f8:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    54fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    54fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5500:	c1 e2 02             	shl    $0x2,%edx
    5503:	01 d0                	add    %edx,%eax
    5505:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5508:	83 c2 10             	add    $0x10,%edx
    550b:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    550d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5511:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5514:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5517:	75 d1                	jne    54ea <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5519:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    5520:	eb 24                	jmp    5546 <lodepng_huffman_code_lengths+0x2b5>
    5522:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5525:	8b 55 14             	mov    0x14(%ebp),%edx
    5528:	83 ea 01             	sub    $0x1,%edx
    552b:	83 ec 0c             	sub    $0xc,%esp
    552e:	50                   	push   %eax
    552f:	52                   	push   %edx
    5530:	ff 75 ec             	pushl  -0x14(%ebp)
    5533:	ff 75 e4             	pushl  -0x1c(%ebp)
    5536:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5539:	50                   	push   %eax
    553a:	e8 7a fb ff ff       	call   50b9 <boundaryPM>
    553f:	83 c4 20             	add    $0x20,%esp
    5542:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5546:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5549:	83 e8 01             	sub    $0x1,%eax
    554c:	01 c0                	add    %eax,%eax
    554e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5551:	75 cf                	jne    5522 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5553:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5556:	8b 55 14             	mov    0x14(%ebp),%edx
    5559:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    555f:	c1 e2 02             	shl    $0x2,%edx
    5562:	01 d0                	add    %edx,%eax
    5564:	8b 00                	mov    (%eax),%eax
    5566:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5569:	eb 44                	jmp    55af <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    556b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5572:	eb 27                	jmp    559b <lodepng_huffman_code_lengths+0x30a>
    5574:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5577:	c1 e0 04             	shl    $0x4,%eax
    557a:	89 c2                	mov    %eax,%edx
    557c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    557f:	01 d0                	add    %edx,%eax
    5581:	8b 40 04             	mov    0x4(%eax),%eax
    5584:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    558b:	8b 45 08             	mov    0x8(%ebp),%eax
    558e:	01 d0                	add    %edx,%eax
    5590:	8b 10                	mov    (%eax),%edx
    5592:	83 c2 01             	add    $0x1,%edx
    5595:	89 10                	mov    %edx,(%eax)
    5597:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    559b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    559e:	8b 40 04             	mov    0x4(%eax),%eax
    55a1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    55a4:	75 ce                	jne    5574 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    55a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    55a9:	8b 40 08             	mov    0x8(%eax),%eax
    55ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
    55af:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    55b3:	75 b6                	jne    556b <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    55b5:	8b 45 c8             	mov    -0x38(%ebp),%eax
    55b8:	83 ec 0c             	sub    $0xc,%esp
    55bb:	50                   	push   %eax
    55bc:	e8 38 e1 ff ff       	call   36f9 <lodepng_free>
    55c1:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    55c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    55c7:	83 ec 0c             	sub    $0xc,%esp
    55ca:	50                   	push   %eax
    55cb:	e8 29 e1 ff ff       	call   36f9 <lodepng_free>
    55d0:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    55d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    55d6:	83 ec 0c             	sub    $0xc,%esp
    55d9:	50                   	push   %eax
    55da:	e8 1a e1 ff ff       	call   36f9 <lodepng_free>
    55df:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    55e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    55e5:	83 ec 0c             	sub    $0xc,%esp
    55e8:	50                   	push   %eax
    55e9:	e8 0b e1 ff ff       	call   36f9 <lodepng_free>
    55ee:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    55f1:	83 ec 0c             	sub    $0xc,%esp
    55f4:	ff 75 e4             	pushl  -0x1c(%ebp)
    55f7:	e8 fd e0 ff ff       	call   36f9 <lodepng_free>
    55fc:	83 c4 10             	add    $0x10,%esp
  return error;
    55ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5602:	c9                   	leave  
    5603:	c3                   	ret    

00005604 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    5604:	55                   	push   %ebp
    5605:	89 e5                	mov    %esp,%ebp
    5607:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    560a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    5611:	eb 04                	jmp    5617 <HuffmanTree_makeFromFrequencies+0x13>
    5613:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5617:	8b 45 14             	mov    0x14(%ebp),%eax
    561a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    561f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5626:	8b 45 0c             	mov    0xc(%ebp),%eax
    5629:	01 d0                	add    %edx,%eax
    562b:	8b 00                	mov    (%eax),%eax
    562d:	85 c0                	test   %eax,%eax
    562f:	75 08                	jne    5639 <HuffmanTree_makeFromFrequencies+0x35>
    5631:	8b 45 14             	mov    0x14(%ebp),%eax
    5634:	3b 45 10             	cmp    0x10(%ebp),%eax
    5637:	7f da                	jg     5613 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5639:	8b 45 14             	mov    0x14(%ebp),%eax
    563c:	c1 e0 02             	shl    $0x2,%eax
    563f:	83 ec 0c             	sub    $0xc,%esp
    5642:	50                   	push   %eax
    5643:	e8 90 e0 ff ff       	call   36d8 <lodepng_malloc>
    5648:	83 c4 10             	add    $0x10,%esp
    564b:	89 c2                	mov    %eax,%edx
    564d:	8b 45 08             	mov    0x8(%ebp),%eax
    5650:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    5653:	8b 45 08             	mov    0x8(%ebp),%eax
    5656:	8b 40 04             	mov    0x4(%eax),%eax
    5659:	85 c0                	test   %eax,%eax
    565b:	75 07                	jne    5664 <HuffmanTree_makeFromFrequencies+0x60>
    565d:	b8 53 00 00 00       	mov    $0x53,%eax
    5662:	eb 47                	jmp    56ab <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    5664:	8b 45 08             	mov    0x8(%ebp),%eax
    5667:	8b 55 18             	mov    0x18(%ebp),%edx
    566a:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    566d:	8b 55 14             	mov    0x14(%ebp),%edx
    5670:	8b 45 08             	mov    0x8(%ebp),%eax
    5673:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    5676:	8b 45 08             	mov    0x8(%ebp),%eax
    5679:	8b 40 04             	mov    0x4(%eax),%eax
    567c:	ff 75 18             	pushl  0x18(%ebp)
    567f:	ff 75 14             	pushl  0x14(%ebp)
    5682:	ff 75 0c             	pushl  0xc(%ebp)
    5685:	50                   	push   %eax
    5686:	e8 06 fc ff ff       	call   5291 <lodepng_huffman_code_lengths>
    568b:	83 c4 10             	add    $0x10,%esp
    568e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    5691:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5695:	75 11                	jne    56a8 <HuffmanTree_makeFromFrequencies+0xa4>
    5697:	83 ec 0c             	sub    $0xc,%esp
    569a:	ff 75 08             	pushl  0x8(%ebp)
    569d:	e8 37 f4 ff ff       	call   4ad9 <HuffmanTree_makeFromLengths2>
    56a2:	83 c4 10             	add    $0x10,%esp
    56a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    56a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    56ab:	c9                   	leave  
    56ac:	c3                   	ret    

000056ad <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    56ad:	55                   	push   %ebp
    56ae:	89 e5                	mov    %esp,%ebp
    56b0:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    56b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    56ba:	83 ec 0c             	sub    $0xc,%esp
    56bd:	68 80 04 00 00       	push   $0x480
    56c2:	e8 11 e0 ff ff       	call   36d8 <lodepng_malloc>
    56c7:	83 c4 10             	add    $0x10,%esp
    56ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    56cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    56d1:	75 0a                	jne    56dd <generateFixedLitLenTree+0x30>
    56d3:	b8 53 00 00 00       	mov    $0x53,%eax
    56d8:	e9 d5 00 00 00       	jmp    57b2 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    56dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    56e4:	eb 19                	jmp    56ff <generateFixedLitLenTree+0x52>
    56e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    56e9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    56f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    56f3:	01 d0                	add    %edx,%eax
    56f5:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    56fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    56ff:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5706:	76 de                	jbe    56e6 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5708:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    570f:	eb 19                	jmp    572a <generateFixedLitLenTree+0x7d>
    5711:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5714:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    571b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    571e:	01 d0                	add    %edx,%eax
    5720:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5726:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    572a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    5731:	76 de                	jbe    5711 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    5733:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    573a:	eb 19                	jmp    5755 <generateFixedLitLenTree+0xa8>
    573c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    573f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5746:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5749:	01 d0                	add    %edx,%eax
    574b:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    5751:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5755:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    575c:	76 de                	jbe    573c <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    575e:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    5765:	eb 19                	jmp    5780 <generateFixedLitLenTree+0xd3>
    5767:	8b 45 f4             	mov    -0xc(%ebp),%eax
    576a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5771:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5774:	01 d0                	add    %edx,%eax
    5776:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    577c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5780:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    5787:	76 de                	jbe    5767 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5789:	6a 0f                	push   $0xf
    578b:	68 20 01 00 00       	push   $0x120
    5790:	ff 75 ec             	pushl  -0x14(%ebp)
    5793:	ff 75 08             	pushl  0x8(%ebp)
    5796:	e8 7f f5 ff ff       	call   4d1a <HuffmanTree_makeFromLengths>
    579b:	83 c4 10             	add    $0x10,%esp
    579e:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    57a1:	83 ec 0c             	sub    $0xc,%esp
    57a4:	ff 75 ec             	pushl  -0x14(%ebp)
    57a7:	e8 4d df ff ff       	call   36f9 <lodepng_free>
    57ac:	83 c4 10             	add    $0x10,%esp
  return error;
    57af:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    57b2:	c9                   	leave  
    57b3:	c3                   	ret    

000057b4 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    57b4:	55                   	push   %ebp
    57b5:	89 e5                	mov    %esp,%ebp
    57b7:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    57ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    57c1:	83 ec 0c             	sub    $0xc,%esp
    57c4:	68 80 00 00 00       	push   $0x80
    57c9:	e8 0a df ff ff       	call   36d8 <lodepng_malloc>
    57ce:	83 c4 10             	add    $0x10,%esp
    57d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    57d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    57d8:	75 07                	jne    57e1 <generateFixedDistanceTree+0x2d>
    57da:	b8 53 00 00 00       	mov    $0x53,%eax
    57df:	eb 4e                	jmp    582f <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    57e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    57e8:	eb 19                	jmp    5803 <generateFixedDistanceTree+0x4f>
    57ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    57ed:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57f7:	01 d0                	add    %edx,%eax
    57f9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    57ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5803:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5807:	75 e1                	jne    57ea <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5809:	6a 0f                	push   $0xf
    580b:	6a 20                	push   $0x20
    580d:	ff 75 ec             	pushl  -0x14(%ebp)
    5810:	ff 75 08             	pushl  0x8(%ebp)
    5813:	e8 02 f5 ff ff       	call   4d1a <HuffmanTree_makeFromLengths>
    5818:	83 c4 10             	add    $0x10,%esp
    581b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    581e:	83 ec 0c             	sub    $0xc,%esp
    5821:	ff 75 ec             	pushl  -0x14(%ebp)
    5824:	e8 d0 de ff ff       	call   36f9 <lodepng_free>
    5829:	83 c4 10             	add    $0x10,%esp
  return error;
    582c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    582f:	c9                   	leave  
    5830:	c3                   	ret    

00005831 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    5831:	55                   	push   %ebp
    5832:	89 e5                	mov    %esp,%ebp
    5834:	53                   	push   %ebx
    5835:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5838:	6a 09                	push   $0x9
    583a:	ff 75 08             	pushl  0x8(%ebp)
    583d:	e8 d8 eb ff ff       	call   441a <peekBits>
    5842:	83 c4 08             	add    $0x8,%esp
    5845:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5849:	8b 45 0c             	mov    0xc(%ebp),%eax
    584c:	8b 50 10             	mov    0x10(%eax),%edx
    584f:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    5853:	01 d0                	add    %edx,%eax
    5855:	0f b6 00             	movzbl (%eax),%eax
    5858:	0f b6 c0             	movzbl %al,%eax
    585b:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    585f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5862:	8b 40 14             	mov    0x14(%eax),%eax
    5865:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    5869:	01 d2                	add    %edx,%edx
    586b:	01 d0                	add    %edx,%eax
    586d:	0f b7 00             	movzwl (%eax),%eax
    5870:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    5874:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    5879:	77 16                	ja     5891 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    587b:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    587f:	50                   	push   %eax
    5880:	ff 75 08             	pushl  0x8(%ebp)
    5883:	e8 b2 eb ff ff       	call   443a <advanceBits>
    5888:	83 c4 08             	add    $0x8,%esp
    return value;
    588b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    588f:	eb 5c                	jmp    58ed <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    5891:	6a 09                	push   $0x9
    5893:	ff 75 08             	pushl  0x8(%ebp)
    5896:	e8 9f eb ff ff       	call   443a <advanceBits>
    589b:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    589e:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    58a2:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    58a6:	83 e8 09             	sub    $0x9,%eax
    58a9:	50                   	push   %eax
    58aa:	ff 75 08             	pushl  0x8(%ebp)
    58ad:	e8 68 eb ff ff       	call   441a <peekBits>
    58b2:	83 c4 08             	add    $0x8,%esp
    58b5:	01 d8                	add    %ebx,%eax
    58b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    58ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    58bd:	8b 50 10             	mov    0x10(%eax),%edx
    58c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    58c3:	01 d0                	add    %edx,%eax
    58c5:	0f b6 00             	movzbl (%eax),%eax
    58c8:	0f b6 c0             	movzbl %al,%eax
    58cb:	83 e8 09             	sub    $0x9,%eax
    58ce:	50                   	push   %eax
    58cf:	ff 75 08             	pushl  0x8(%ebp)
    58d2:	e8 63 eb ff ff       	call   443a <advanceBits>
    58d7:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    58da:	8b 45 0c             	mov    0xc(%ebp),%eax
    58dd:	8b 40 14             	mov    0x14(%eax),%eax
    58e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    58e3:	01 d2                	add    %edx,%edx
    58e5:	01 d0                	add    %edx,%eax
    58e7:	0f b7 00             	movzwl (%eax),%eax
    58ea:	0f b7 c0             	movzwl %ax,%eax
  }
}
    58ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    58f0:	c9                   	leave  
    58f1:	c3                   	ret    

000058f2 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    58f2:	55                   	push   %ebp
    58f3:	89 e5                	mov    %esp,%ebp
    58f5:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    58f8:	83 ec 0c             	sub    $0xc,%esp
    58fb:	ff 75 08             	pushl  0x8(%ebp)
    58fe:	e8 aa fd ff ff       	call   56ad <generateFixedLitLenTree>
    5903:	83 c4 10             	add    $0x10,%esp
    5906:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5909:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    590d:	74 05                	je     5914 <getTreeInflateFixed+0x22>
    590f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5912:	eb 0e                	jmp    5922 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    5914:	83 ec 0c             	sub    $0xc,%esp
    5917:	ff 75 0c             	pushl  0xc(%ebp)
    591a:	e8 95 fe ff ff       	call   57b4 <generateFixedDistanceTree>
    591f:	83 c4 10             	add    $0x10,%esp
}
    5922:	c9                   	leave  
    5923:	c3                   	ret    

00005924 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    5924:	55                   	push   %ebp
    5925:	89 e5                	mov    %esp,%ebp
    5927:	53                   	push   %ebx
    5928:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    592b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    5932:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5939:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    5940:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5947:	6a 0e                	push   $0xe
    5949:	ff 75 10             	pushl  0x10(%ebp)
    594c:	e8 37 e6 ff ff       	call   3f88 <ensureBits17>
    5951:	83 c4 08             	add    $0x8,%esp
    5954:	85 c0                	test   %eax,%eax
    5956:	75 0a                	jne    5962 <getTreeInflateDynamic+0x3e>
    5958:	b8 31 00 00 00       	mov    $0x31,%eax
    595d:	e9 ec 04 00 00       	jmp    5e4e <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    5962:	6a 05                	push   $0x5
    5964:	ff 75 10             	pushl  0x10(%ebp)
    5967:	e8 f8 ea ff ff       	call   4464 <readBits>
    596c:	83 c4 08             	add    $0x8,%esp
    596f:	05 01 01 00 00       	add    $0x101,%eax
    5974:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    5977:	6a 05                	push   $0x5
    5979:	ff 75 10             	pushl  0x10(%ebp)
    597c:	e8 e3 ea ff ff       	call   4464 <readBits>
    5981:	83 c4 08             	add    $0x8,%esp
    5984:	83 c0 01             	add    $0x1,%eax
    5987:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    598a:	6a 04                	push   $0x4
    598c:	ff 75 10             	pushl  0x10(%ebp)
    598f:	e8 d0 ea ff ff       	call   4464 <readBits>
    5994:	83 c4 08             	add    $0x8,%esp
    5997:	83 c0 04             	add    $0x4,%eax
    599a:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    599d:	83 ec 0c             	sub    $0xc,%esp
    59a0:	6a 4c                	push   $0x4c
    59a2:	e8 31 dd ff ff       	call   36d8 <lodepng_malloc>
    59a7:	83 c4 10             	add    $0x10,%esp
    59aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    59ad:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    59b1:	75 0a                	jne    59bd <getTreeInflateDynamic+0x99>
    59b3:	b8 53 00 00 00       	mov    $0x53,%eax
    59b8:	e9 91 04 00 00       	jmp    5e4e <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    59bd:	83 ec 0c             	sub    $0xc,%esp
    59c0:	8d 45 a8             	lea    -0x58(%ebp),%eax
    59c3:	50                   	push   %eax
    59c4:	e8 03 ec ff ff       	call   45cc <HuffmanTree_init>
    59c9:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    59cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    59d0:	0f 85 3c 04 00 00    	jne    5e12 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    59d6:	8b 45 10             	mov    0x10(%ebp),%eax
    59d9:	8b 48 08             	mov    0x8(%eax),%ecx
    59dc:	8b 55 d0             	mov    -0x30(%ebp),%edx
    59df:	89 d0                	mov    %edx,%eax
    59e1:	01 c0                	add    %eax,%eax
    59e3:	01 d0                	add    %edx,%eax
    59e5:	89 c2                	mov    %eax,%edx
    59e7:	8b 45 10             	mov    0x10(%ebp),%eax
    59ea:	8b 40 0c             	mov    0xc(%eax),%eax
    59ed:	83 ec 04             	sub    $0x4,%esp
    59f0:	51                   	push   %ecx
    59f1:	52                   	push   %edx
    59f2:	50                   	push   %eax
    59f3:	e8 f7 dd ff ff       	call   37ef <lodepng_gtofl>
    59f8:	83 c4 10             	add    $0x10,%esp
    59fb:	85 c0                	test   %eax,%eax
    59fd:	74 0c                	je     5a0b <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    59ff:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5a06:	e9 07 04 00 00       	jmp    5e12 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5a0b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5a12:	eb 3d                	jmp    5a51 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    5a14:	83 ec 08             	sub    $0x8,%esp
    5a17:	6a 03                	push   $0x3
    5a19:	ff 75 10             	pushl  0x10(%ebp)
    5a1c:	e8 8b e4 ff ff       	call   3eac <ensureBits9>
    5a21:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    5a24:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a27:	8b 04 85 80 a3 01 00 	mov    0x1a380(,%eax,4),%eax
    5a2e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a35:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5a38:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5a3b:	83 ec 08             	sub    $0x8,%esp
    5a3e:	6a 03                	push   $0x3
    5a40:	ff 75 10             	pushl  0x10(%ebp)
    5a43:	e8 1c ea ff ff       	call   4464 <readBits>
    5a48:	83 c4 10             	add    $0x10,%esp
    5a4b:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    5a4d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5a51:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a54:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5a57:	75 bb                	jne    5a14 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5a59:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5a5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5a5f:	eb 20                	jmp    5a81 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    5a61:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a64:	8b 04 85 80 a3 01 00 	mov    0x1a380(,%eax,4),%eax
    5a6b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a72:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5a75:	01 d0                	add    %edx,%eax
    5a77:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5a7d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5a81:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    5a85:	75 da                	jne    5a61 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    5a87:	6a 07                	push   $0x7
    5a89:	6a 13                	push   $0x13
    5a8b:	ff 75 dc             	pushl  -0x24(%ebp)
    5a8e:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5a91:	50                   	push   %eax
    5a92:	e8 83 f2 ff ff       	call   4d1a <HuffmanTree_makeFromLengths>
    5a97:	83 c4 10             	add    $0x10,%esp
    5a9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5a9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5aa1:	0f 85 64 03 00 00    	jne    5e0b <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5aa7:	83 ec 0c             	sub    $0xc,%esp
    5aaa:	68 80 04 00 00       	push   $0x480
    5aaf:	e8 24 dc ff ff       	call   36d8 <lodepng_malloc>
    5ab4:	83 c4 10             	add    $0x10,%esp
    5ab7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5aba:	83 ec 0c             	sub    $0xc,%esp
    5abd:	68 80 00 00 00       	push   $0x80
    5ac2:	e8 11 dc ff ff       	call   36d8 <lodepng_malloc>
    5ac7:	83 c4 10             	add    $0x10,%esp
    5aca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    5acd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5ad1:	74 06                	je     5ad9 <getTreeInflateDynamic+0x1b5>
    5ad3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5ad7:	75 0c                	jne    5ae5 <getTreeInflateDynamic+0x1c1>
    5ad9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5ae0:	e9 2d 03 00 00       	jmp    5e12 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    5ae5:	83 ec 04             	sub    $0x4,%esp
    5ae8:	68 80 04 00 00       	push   $0x480
    5aed:	6a 00                	push   $0x0
    5aef:	ff 75 e8             	pushl  -0x18(%ebp)
    5af2:	e8 52 dc ff ff       	call   3749 <lodepng_memset>
    5af7:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5afa:	83 ec 04             	sub    $0x4,%esp
    5afd:	68 80 00 00 00       	push   $0x80
    5b02:	6a 00                	push   $0x0
    5b04:	ff 75 e4             	pushl  -0x1c(%ebp)
    5b07:	e8 3d dc ff ff       	call   3749 <lodepng_memset>
    5b0c:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    5b0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5b16:	e9 8d 02 00 00       	jmp    5da8 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5b1b:	83 ec 08             	sub    $0x8,%esp
    5b1e:	6a 16                	push   $0x16
    5b20:	ff 75 10             	pushl  0x10(%ebp)
    5b23:	e8 8c e5 ff ff       	call   40b4 <ensureBits25>
    5b28:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5b2b:	83 ec 08             	sub    $0x8,%esp
    5b2e:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5b31:	50                   	push   %eax
    5b32:	ff 75 10             	pushl  0x10(%ebp)
    5b35:	e8 f7 fc ff ff       	call   5831 <huffmanDecodeSymbol>
    5b3a:	83 c4 10             	add    $0x10,%esp
    5b3d:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    5b40:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    5b44:	77 3e                	ja     5b84 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5b46:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b49:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5b4c:	73 16                	jae    5b64 <getTreeInflateDynamic+0x240>
    5b4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b51:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b58:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5b5b:	01 c2                	add    %eax,%edx
    5b5d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5b60:	89 02                	mov    %eax,(%edx)
    5b62:	eb 17                	jmp    5b7b <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    5b64:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b67:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5b6a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b74:	01 c2                	add    %eax,%edx
    5b76:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5b79:	89 02                	mov    %eax,(%edx)
        ++i;
    5b7b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5b7f:	e9 0b 02 00 00       	jmp    5d8f <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    5b84:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    5b88:	0f 85 da 00 00 00    	jne    5c68 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5b8e:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    5b95:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5b99:	75 0c                	jne    5ba7 <getTreeInflateDynamic+0x283>
    5b9b:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    5ba2:	e9 12 02 00 00       	jmp    5db9 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    5ba7:	83 ec 08             	sub    $0x8,%esp
    5baa:	6a 02                	push   $0x2
    5bac:	ff 75 10             	pushl  0x10(%ebp)
    5baf:	e8 b0 e8 ff ff       	call   4464 <readBits>
    5bb4:	83 c4 10             	add    $0x10,%esp
    5bb7:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5bba:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5bbd:	83 c0 01             	add    $0x1,%eax
    5bc0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5bc3:	76 1b                	jbe    5be0 <getTreeInflateDynamic+0x2bc>
    5bc5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5bc8:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5bcd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5bd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5bd7:	01 d0                	add    %edx,%eax
    5bd9:	8b 00                	mov    (%eax),%eax
    5bdb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5bde:	eb 1c                	jmp    5bfc <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    5be0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5be3:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5be6:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5beb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5bf2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5bf5:	01 d0                	add    %edx,%eax
    5bf7:	8b 00                	mov    (%eax),%eax
    5bf9:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5bfc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5c03:	eb 56                	jmp    5c5b <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5c05:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5c08:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c0b:	01 d0                	add    %edx,%eax
    5c0d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5c10:	77 0c                	ja     5c1e <getTreeInflateDynamic+0x2fa>
    5c12:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5c19:	e9 71 01 00 00       	jmp    5d8f <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5c1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c21:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5c24:	73 16                	jae    5c3c <getTreeInflateDynamic+0x318>
    5c26:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c29:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c30:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5c33:	01 c2                	add    %eax,%edx
    5c35:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5c38:	89 02                	mov    %eax,(%edx)
    5c3a:	eb 17                	jmp    5c53 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5c3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c3f:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5c42:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c4c:	01 c2                	add    %eax,%edx
    5c4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5c51:	89 02                	mov    %eax,(%edx)
          ++i;
    5c53:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5c57:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5c5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c5e:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    5c61:	72 a2                	jb     5c05 <getTreeInflateDynamic+0x2e1>
    5c63:	e9 27 01 00 00       	jmp    5d8f <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    5c68:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5c6c:	0f 85 88 00 00 00    	jne    5cfa <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    5c72:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    5c79:	83 ec 08             	sub    $0x8,%esp
    5c7c:	6a 03                	push   $0x3
    5c7e:	ff 75 10             	pushl  0x10(%ebp)
    5c81:	e8 de e7 ff ff       	call   4464 <readBits>
    5c86:	83 c4 10             	add    $0x10,%esp
    5c89:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5c8c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5c93:	eb 58                	jmp    5ced <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    5c95:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5c98:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c9b:	01 d0                	add    %edx,%eax
    5c9d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5ca0:	77 0c                	ja     5cae <getTreeInflateDynamic+0x38a>
    5ca2:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    5ca9:	e9 e1 00 00 00       	jmp    5d8f <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5cae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cb1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5cb4:	73 17                	jae    5ccd <getTreeInflateDynamic+0x3a9>
    5cb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cb9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5cc0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cc3:	01 d0                	add    %edx,%eax
    5cc5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5ccb:	eb 18                	jmp    5ce5 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    5ccd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5cd0:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5cd3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5cda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5cdd:	01 d0                	add    %edx,%eax
    5cdf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5ce5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5ce9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5ced:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cf0:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    5cf3:	72 a0                	jb     5c95 <getTreeInflateDynamic+0x371>
    5cf5:	e9 95 00 00 00       	jmp    5d8f <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5cfa:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5cfe:	0f 85 82 00 00 00    	jne    5d86 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5d04:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5d0b:	83 ec 08             	sub    $0x8,%esp
    5d0e:	6a 07                	push   $0x7
    5d10:	ff 75 10             	pushl  0x10(%ebp)
    5d13:	e8 4c e7 ff ff       	call   4464 <readBits>
    5d18:	83 c4 10             	add    $0x10,%esp
    5d1b:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5d1e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5d25:	eb 55                	jmp    5d7c <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5d27:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5d2a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5d2d:	01 d0                	add    %edx,%eax
    5d2f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5d32:	77 09                	ja     5d3d <getTreeInflateDynamic+0x419>
    5d34:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5d3b:	eb 52                	jmp    5d8f <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5d3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d40:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5d43:	73 17                	jae    5d5c <getTreeInflateDynamic+0x438>
    5d45:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d48:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5d4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d52:	01 d0                	add    %edx,%eax
    5d54:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5d5a:	eb 18                	jmp    5d74 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5d5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d5f:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5d62:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5d69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d6c:	01 d0                	add    %edx,%eax
    5d6e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5d74:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5d78:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5d7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d7f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5d82:	72 a3                	jb     5d27 <getTreeInflateDynamic+0x403>
    5d84:	eb 09                	jmp    5d8f <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5d86:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5d8d:	eb 2a                	jmp    5db9 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5d8f:	8b 45 10             	mov    0x10(%ebp),%eax
    5d92:	8b 50 0c             	mov    0xc(%eax),%edx
    5d95:	8b 45 10             	mov    0x10(%ebp),%eax
    5d98:	8b 40 08             	mov    0x8(%eax),%eax
    5d9b:	39 c2                	cmp    %eax,%edx
    5d9d:	7e 09                	jle    5da8 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5d9f:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5da6:	eb 11                	jmp    5db9 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5da8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5dab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5dae:	01 d0                	add    %edx,%eax
    5db0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5db3:	0f 87 62 fd ff ff    	ja     5b1b <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5db9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5dbd:	75 4f                	jne    5e0e <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5dbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5dc2:	05 00 04 00 00       	add    $0x400,%eax
    5dc7:	8b 00                	mov    (%eax),%eax
    5dc9:	85 c0                	test   %eax,%eax
    5dcb:	75 09                	jne    5dd6 <getTreeInflateDynamic+0x4b2>
    5dcd:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5dd4:	eb 3c                	jmp    5e12 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5dd6:	6a 0f                	push   $0xf
    5dd8:	68 20 01 00 00       	push   $0x120
    5ddd:	ff 75 e8             	pushl  -0x18(%ebp)
    5de0:	ff 75 08             	pushl  0x8(%ebp)
    5de3:	e8 32 ef ff ff       	call   4d1a <HuffmanTree_makeFromLengths>
    5de8:	83 c4 10             	add    $0x10,%esp
    5deb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5dee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5df2:	75 1d                	jne    5e11 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5df4:	6a 0f                	push   $0xf
    5df6:	6a 20                	push   $0x20
    5df8:	ff 75 e4             	pushl  -0x1c(%ebp)
    5dfb:	ff 75 0c             	pushl  0xc(%ebp)
    5dfe:	e8 17 ef ff ff       	call   4d1a <HuffmanTree_makeFromLengths>
    5e03:	83 c4 10             	add    $0x10,%esp
    5e06:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5e09:	eb 07                	jmp    5e12 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5e0b:	90                   	nop
    5e0c:	eb 04                	jmp    5e12 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5e0e:	90                   	nop
    5e0f:	eb 01                	jmp    5e12 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5e11:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5e12:	83 ec 0c             	sub    $0xc,%esp
    5e15:	ff 75 dc             	pushl  -0x24(%ebp)
    5e18:	e8 dc d8 ff ff       	call   36f9 <lodepng_free>
    5e1d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5e20:	83 ec 0c             	sub    $0xc,%esp
    5e23:	ff 75 e8             	pushl  -0x18(%ebp)
    5e26:	e8 ce d8 ff ff       	call   36f9 <lodepng_free>
    5e2b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5e2e:	83 ec 0c             	sub    $0xc,%esp
    5e31:	ff 75 e4             	pushl  -0x1c(%ebp)
    5e34:	e8 c0 d8 ff ff       	call   36f9 <lodepng_free>
    5e39:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5e3c:	83 ec 0c             	sub    $0xc,%esp
    5e3f:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5e42:	50                   	push   %eax
    5e43:	e8 b1 e7 ff ff       	call   45f9 <HuffmanTree_cleanup>
    5e48:	83 c4 10             	add    $0x10,%esp

  return error;
    5e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5e4e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5e51:	c9                   	leave  
    5e52:	c3                   	ret    

00005e53 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5e53:	55                   	push   %ebp
    5e54:	89 e5                	mov    %esp,%ebp
    5e56:	53                   	push   %ebx
    5e57:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5e5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5e61:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5e64:	50                   	push   %eax
    5e65:	e8 62 e7 ff ff       	call   45cc <HuffmanTree_init>
    5e6a:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5e6d:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5e70:	50                   	push   %eax
    5e71:	e8 56 e7 ff ff       	call   45cc <HuffmanTree_init>
    5e76:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5e79:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5e7d:	75 1b                	jne    5e9a <inflateHuffmanBlock+0x47>
    5e7f:	83 ec 08             	sub    $0x8,%esp
    5e82:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5e85:	50                   	push   %eax
    5e86:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5e89:	50                   	push   %eax
    5e8a:	e8 63 fa ff ff       	call   58f2 <getTreeInflateFixed>
    5e8f:	83 c4 10             	add    $0x10,%esp
    5e92:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5e95:	e9 9a 02 00 00       	jmp    6134 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5e9a:	83 ec 04             	sub    $0x4,%esp
    5e9d:	ff 75 0c             	pushl  0xc(%ebp)
    5ea0:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ea3:	50                   	push   %eax
    5ea4:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ea7:	50                   	push   %eax
    5ea8:	e8 77 fa ff ff       	call   5924 <getTreeInflateDynamic>
    5ead:	83 c4 10             	add    $0x10,%esp
    5eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5eb3:	e9 7c 02 00 00       	jmp    6134 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5eb8:	83 ec 08             	sub    $0x8,%esp
    5ebb:	6a 14                	push   $0x14
    5ebd:	ff 75 0c             	pushl  0xc(%ebp)
    5ec0:	e8 ef e1 ff ff       	call   40b4 <ensureBits25>
    5ec5:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5ec8:	83 ec 08             	sub    $0x8,%esp
    5ecb:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ece:	50                   	push   %eax
    5ecf:	ff 75 0c             	pushl  0xc(%ebp)
    5ed2:	e8 5a f9 ff ff       	call   5831 <huffmanDecodeSymbol>
    5ed7:	83 c4 10             	add    $0x10,%esp
    5eda:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5edd:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5ee4:	77 42                	ja     5f28 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5ee6:	8b 45 08             	mov    0x8(%ebp),%eax
    5ee9:	8b 40 04             	mov    0x4(%eax),%eax
    5eec:	83 c0 01             	add    $0x1,%eax
    5eef:	83 ec 08             	sub    $0x8,%esp
    5ef2:	50                   	push   %eax
    5ef3:	ff 75 08             	pushl  0x8(%ebp)
    5ef6:	e8 37 da ff ff       	call   3932 <ucvector_resize>
    5efb:	83 c4 10             	add    $0x10,%esp
    5efe:	85 c0                	test   %eax,%eax
    5f00:	75 0c                	jne    5f0e <inflateHuffmanBlock+0xbb>
    5f02:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5f09:	e9 33 02 00 00       	jmp    6141 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5f0e:	8b 45 08             	mov    0x8(%ebp),%eax
    5f11:	8b 10                	mov    (%eax),%edx
    5f13:	8b 45 08             	mov    0x8(%ebp),%eax
    5f16:	8b 40 04             	mov    0x4(%eax),%eax
    5f19:	83 e8 01             	sub    $0x1,%eax
    5f1c:	01 d0                	add    %edx,%eax
    5f1e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5f21:	88 10                	mov    %dl,(%eax)
    5f23:	e9 d9 01 00 00       	jmp    6101 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5f28:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5f2f:	0f 86 ba 01 00 00    	jbe    60ef <inflateHuffmanBlock+0x29c>
    5f35:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5f3c:	0f 87 ad 01 00 00    	ja     60ef <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5f42:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5f45:	2d 01 01 00 00       	sub    $0x101,%eax
    5f4a:	8b 04 85 80 a1 01 00 	mov    0x1a180(,%eax,4),%eax
    5f51:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5f54:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5f57:	2d 01 01 00 00       	sub    $0x101,%eax
    5f5c:	8b 04 85 00 a2 01 00 	mov    0x1a200(,%eax,4),%eax
    5f63:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5f66:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5f6a:	74 1c                	je     5f88 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5f6c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5f6f:	83 ec 08             	sub    $0x8,%esp
    5f72:	50                   	push   %eax
    5f73:	ff 75 0c             	pushl  0xc(%ebp)
    5f76:	e8 e9 e4 ff ff       	call   4464 <readBits>
    5f7b:	83 c4 10             	add    $0x10,%esp
    5f7e:	89 c2                	mov    %eax,%edx
    5f80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f83:	01 d0                	add    %edx,%eax
    5f85:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5f88:	83 ec 08             	sub    $0x8,%esp
    5f8b:	6a 1c                	push   $0x1c
    5f8d:	ff 75 0c             	pushl  0xc(%ebp)
    5f90:	e8 98 e2 ff ff       	call   422d <ensureBits32>
    5f95:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5f98:	83 ec 08             	sub    $0x8,%esp
    5f9b:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5f9e:	50                   	push   %eax
    5f9f:	ff 75 0c             	pushl  0xc(%ebp)
    5fa2:	e8 8a f8 ff ff       	call   5831 <huffmanDecodeSymbol>
    5fa7:	83 c4 10             	add    $0x10,%esp
    5faa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5fad:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5fb1:	76 1e                	jbe    5fd1 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5fb3:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5fb7:	77 0c                	ja     5fc5 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5fb9:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5fc0:	e9 7c 01 00 00       	jmp    6141 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5fc5:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5fcc:	e9 70 01 00 00       	jmp    6141 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5fd1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5fd4:	8b 04 85 80 a2 01 00 	mov    0x1a280(,%eax,4),%eax
    5fdb:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5fde:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5fe1:	8b 04 85 00 a3 01 00 	mov    0x1a300(,%eax,4),%eax
    5fe8:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5feb:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5fef:	74 15                	je     6006 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5ff1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5ff4:	83 ec 08             	sub    $0x8,%esp
    5ff7:	50                   	push   %eax
    5ff8:	ff 75 0c             	pushl  0xc(%ebp)
    5ffb:	e8 64 e4 ff ff       	call   4464 <readBits>
    6000:	83 c4 10             	add    $0x10,%esp
    6003:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    6006:	8b 45 08             	mov    0x8(%ebp),%eax
    6009:	8b 40 04             	mov    0x4(%eax),%eax
    600c:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    600f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6012:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    6015:	76 0c                	jbe    6023 <inflateHuffmanBlock+0x1d0>
    6017:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    601e:	e9 1e 01 00 00       	jmp    6141 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    6023:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6026:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6029:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    602c:	8b 45 08             	mov    0x8(%ebp),%eax
    602f:	8b 50 04             	mov    0x4(%eax),%edx
    6032:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6035:	01 d0                	add    %edx,%eax
    6037:	83 ec 08             	sub    $0x8,%esp
    603a:	50                   	push   %eax
    603b:	ff 75 08             	pushl  0x8(%ebp)
    603e:	e8 ef d8 ff ff       	call   3932 <ucvector_resize>
    6043:	83 c4 10             	add    $0x10,%esp
    6046:	85 c0                	test   %eax,%eax
    6048:	75 0c                	jne    6056 <inflateHuffmanBlock+0x203>
    604a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6051:	e9 eb 00 00 00       	jmp    6141 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    6056:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6059:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    605c:	73 6b                	jae    60c9 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    605e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6061:	8b 55 08             	mov    0x8(%ebp),%edx
    6064:	8b 0a                	mov    (%edx),%ecx
    6066:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6069:	01 d1                	add    %edx,%ecx
    606b:	8b 55 08             	mov    0x8(%ebp),%edx
    606e:	8b 1a                	mov    (%edx),%ebx
    6070:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6073:	01 da                	add    %ebx,%edx
    6075:	83 ec 04             	sub    $0x4,%esp
    6078:	50                   	push   %eax
    6079:	51                   	push   %ecx
    607a:	52                   	push   %edx
    607b:	e8 96 d6 ff ff       	call   3716 <lodepng_memcpy>
    6080:	83 c4 10             	add    $0x10,%esp
        start += distance;
    6083:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6086:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6089:	01 d0                	add    %edx,%eax
    608b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    608e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6091:	89 45 e0             	mov    %eax,-0x20(%ebp)
    6094:	eb 29                	jmp    60bf <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    6096:	8b 45 08             	mov    0x8(%ebp),%eax
    6099:	8b 08                	mov    (%eax),%ecx
    609b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    609e:	8d 50 01             	lea    0x1(%eax),%edx
    60a1:	89 55 ec             	mov    %edx,-0x14(%ebp)
    60a4:	01 c1                	add    %eax,%ecx
    60a6:	8b 45 08             	mov    0x8(%ebp),%eax
    60a9:	8b 18                	mov    (%eax),%ebx
    60ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    60ae:	8d 50 01             	lea    0x1(%eax),%edx
    60b1:	89 55 e8             	mov    %edx,-0x18(%ebp)
    60b4:	01 d8                	add    %ebx,%eax
    60b6:	0f b6 00             	movzbl (%eax),%eax
    60b9:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    60bb:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    60bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
    60c2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    60c5:	7c cf                	jl     6096 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    60c7:	eb 38                	jmp    6101 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    60c9:	8b 45 08             	mov    0x8(%ebp),%eax
    60cc:	8b 10                	mov    (%eax),%edx
    60ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
    60d1:	01 c2                	add    %eax,%edx
    60d3:	8b 45 08             	mov    0x8(%ebp),%eax
    60d6:	8b 08                	mov    (%eax),%ecx
    60d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    60db:	01 c8                	add    %ecx,%eax
    60dd:	83 ec 04             	sub    $0x4,%esp
    60e0:	ff 75 e4             	pushl  -0x1c(%ebp)
    60e3:	52                   	push   %edx
    60e4:	50                   	push   %eax
    60e5:	e8 2c d6 ff ff       	call   3716 <lodepng_memcpy>
    60ea:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    60ed:	eb 12                	jmp    6101 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    60ef:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    60f6:	74 48                	je     6140 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    60f8:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    60ff:	eb 40                	jmp    6141 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    6101:	8b 45 0c             	mov    0xc(%ebp),%eax
    6104:	8b 50 0c             	mov    0xc(%eax),%edx
    6107:	8b 45 0c             	mov    0xc(%ebp),%eax
    610a:	8b 40 08             	mov    0x8(%eax),%eax
    610d:	39 c2                	cmp    %eax,%edx
    610f:	7e 09                	jle    611a <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    6111:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    6118:	eb 27                	jmp    6141 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    611a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    611e:	74 14                	je     6134 <inflateHuffmanBlock+0x2e1>
    6120:	8b 45 08             	mov    0x8(%ebp),%eax
    6123:	8b 40 04             	mov    0x4(%eax),%eax
    6126:	3b 45 14             	cmp    0x14(%ebp),%eax
    6129:	7e 09                	jle    6134 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    612b:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    6132:	eb 0d                	jmp    6141 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6134:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6138:	0f 84 7a fd ff ff    	je     5eb8 <inflateHuffmanBlock+0x65>
    613e:	eb 01                	jmp    6141 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    6140:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    6141:	83 ec 0c             	sub    $0xc,%esp
    6144:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6147:	50                   	push   %eax
    6148:	e8 ac e4 ff ff       	call   45f9 <HuffmanTree_cleanup>
    614d:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    6150:	83 ec 0c             	sub    $0xc,%esp
    6153:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6156:	50                   	push   %eax
    6157:	e8 9d e4 ff ff       	call   45f9 <HuffmanTree_cleanup>
    615c:	83 c4 10             	add    $0x10,%esp

  return error;
    615f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6162:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6165:	c9                   	leave  
    6166:	c3                   	ret    

00006167 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    6167:	55                   	push   %ebp
    6168:	89 e5                	mov    %esp,%ebp
    616a:	53                   	push   %ebx
    616b:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    616e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6171:	8b 40 04             	mov    0x4(%eax),%eax
    6174:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    6177:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    617e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6181:	8b 40 0c             	mov    0xc(%eax),%eax
    6184:	83 c0 07             	add    $0x7,%eax
    6187:	c1 e8 03             	shr    $0x3,%eax
    618a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    618d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6190:	83 c0 04             	add    $0x4,%eax
    6193:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6196:	7c 0a                	jl     61a2 <inflateNoCompression+0x3b>
    6198:	b8 34 00 00 00       	mov    $0x34,%eax
    619d:	e9 01 01 00 00       	jmp    62a3 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    61a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    61a5:	8b 10                	mov    (%eax),%edx
    61a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    61aa:	01 d0                	add    %edx,%eax
    61ac:	0f b6 00             	movzbl (%eax),%eax
    61af:	0f b6 d0             	movzbl %al,%edx
    61b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    61b5:	8b 00                	mov    (%eax),%eax
    61b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    61ba:	83 c1 01             	add    $0x1,%ecx
    61bd:	01 c8                	add    %ecx,%eax
    61bf:	0f b6 00             	movzbl (%eax),%eax
    61c2:	0f b6 c0             	movzbl %al,%eax
    61c5:	c1 e0 08             	shl    $0x8,%eax
    61c8:	01 d0                	add    %edx,%eax
    61ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
    61cd:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    61d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    61d4:	8b 10                	mov    (%eax),%edx
    61d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    61d9:	01 d0                	add    %edx,%eax
    61db:	0f b6 00             	movzbl (%eax),%eax
    61de:	0f b6 d0             	movzbl %al,%edx
    61e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    61e4:	8b 00                	mov    (%eax),%eax
    61e6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    61e9:	83 c1 01             	add    $0x1,%ecx
    61ec:	01 c8                	add    %ecx,%eax
    61ee:	0f b6 00             	movzbl (%eax),%eax
    61f1:	0f b6 c0             	movzbl %al,%eax
    61f4:	c1 e0 08             	shl    $0x8,%eax
    61f7:	01 d0                	add    %edx,%eax
    61f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    61fc:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    6200:	8b 45 10             	mov    0x10(%ebp),%eax
    6203:	8b 40 04             	mov    0x4(%eax),%eax
    6206:	85 c0                	test   %eax,%eax
    6208:	75 19                	jne    6223 <inflateNoCompression+0xbc>
    620a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    620d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6210:	01 d0                	add    %edx,%eax
    6212:	3d ff ff 00 00       	cmp    $0xffff,%eax
    6217:	74 0a                	je     6223 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    6219:	b8 15 00 00 00       	mov    $0x15,%eax
    621e:	e9 80 00 00 00       	jmp    62a3 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    6223:	8b 45 08             	mov    0x8(%ebp),%eax
    6226:	8b 40 04             	mov    0x4(%eax),%eax
    6229:	89 c2                	mov    %eax,%edx
    622b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    622e:	01 d0                	add    %edx,%eax
    6230:	50                   	push   %eax
    6231:	ff 75 08             	pushl  0x8(%ebp)
    6234:	e8 f9 d6 ff ff       	call   3932 <ucvector_resize>
    6239:	83 c4 08             	add    $0x8,%esp
    623c:	85 c0                	test   %eax,%eax
    623e:	75 07                	jne    6247 <inflateNoCompression+0xe0>
    6240:	b8 53 00 00 00       	mov    $0x53,%eax
    6245:	eb 5c                	jmp    62a3 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    6247:	8b 55 f0             	mov    -0x10(%ebp),%edx
    624a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    624d:	01 c2                	add    %eax,%edx
    624f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6252:	39 c2                	cmp    %eax,%edx
    6254:	76 07                	jbe    625d <inflateNoCompression+0xf6>
    6256:	b8 17 00 00 00       	mov    $0x17,%eax
    625b:	eb 46                	jmp    62a3 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    625d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6260:	8b 55 0c             	mov    0xc(%ebp),%edx
    6263:	8b 0a                	mov    (%edx),%ecx
    6265:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6268:	01 d1                	add    %edx,%ecx
    626a:	8b 55 08             	mov    0x8(%ebp),%edx
    626d:	8b 1a                	mov    (%edx),%ebx
    626f:	8b 55 08             	mov    0x8(%ebp),%edx
    6272:	8b 52 04             	mov    0x4(%edx),%edx
    6275:	2b 55 ec             	sub    -0x14(%ebp),%edx
    6278:	01 da                	add    %ebx,%edx
    627a:	50                   	push   %eax
    627b:	51                   	push   %ecx
    627c:	52                   	push   %edx
    627d:	e8 94 d4 ff ff       	call   3716 <lodepng_memcpy>
    6282:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    6285:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6288:	8b 45 ec             	mov    -0x14(%ebp),%eax
    628b:	01 d0                	add    %edx,%eax
    628d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    6290:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6293:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    629a:	8b 45 0c             	mov    0xc(%ebp),%eax
    629d:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    62a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    62a3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    62a6:	c9                   	leave  
    62a7:	c3                   	ret    

000062a8 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    62a8:	55                   	push   %ebp
    62a9:	89 e5                	mov    %esp,%ebp
    62ab:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    62ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    62b5:	ff 75 10             	pushl  0x10(%ebp)
    62b8:	ff 75 0c             	pushl  0xc(%ebp)
    62bb:	8d 45 d8             	lea    -0x28(%ebp),%eax
    62be:	50                   	push   %eax
    62bf:	e8 77 db ff ff       	call   3e3b <LodePNGBitReader_init>
    62c4:	83 c4 0c             	add    $0xc,%esp
    62c7:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    62ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    62ce:	0f 84 b9 00 00 00    	je     638d <lodepng_inflatev+0xe5>
    62d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    62d7:	e9 c1 00 00 00       	jmp    639d <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    62dc:	6a 03                	push   $0x3
    62de:	8d 45 d8             	lea    -0x28(%ebp),%eax
    62e1:	50                   	push   %eax
    62e2:	e8 c5 db ff ff       	call   3eac <ensureBits9>
    62e7:	83 c4 08             	add    $0x8,%esp
    62ea:	85 c0                	test   %eax,%eax
    62ec:	75 0a                	jne    62f8 <lodepng_inflatev+0x50>
    62ee:	b8 34 00 00 00       	mov    $0x34,%eax
    62f3:	e9 a5 00 00 00       	jmp    639d <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    62f8:	6a 01                	push   $0x1
    62fa:	8d 45 d8             	lea    -0x28(%ebp),%eax
    62fd:	50                   	push   %eax
    62fe:	e8 61 e1 ff ff       	call   4464 <readBits>
    6303:	83 c4 08             	add    $0x8,%esp
    6306:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    6309:	6a 02                	push   $0x2
    630b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    630e:	50                   	push   %eax
    630f:	e8 50 e1 ff ff       	call   4464 <readBits>
    6314:	83 c4 08             	add    $0x8,%esp
    6317:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    631a:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    631e:	75 07                	jne    6327 <lodepng_inflatev+0x7f>
    6320:	b8 14 00 00 00       	mov    $0x14,%eax
    6325:	eb 76                	jmp    639d <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    6327:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    632b:	75 17                	jne    6344 <lodepng_inflatev+0x9c>
    632d:	ff 75 14             	pushl  0x14(%ebp)
    6330:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6333:	50                   	push   %eax
    6334:	ff 75 08             	pushl  0x8(%ebp)
    6337:	e8 2b fe ff ff       	call   6167 <inflateNoCompression>
    633c:	83 c4 0c             	add    $0xc,%esp
    633f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6342:	eb 1c                	jmp    6360 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    6344:	8b 45 14             	mov    0x14(%ebp),%eax
    6347:	8b 40 08             	mov    0x8(%eax),%eax
    634a:	50                   	push   %eax
    634b:	ff 75 ec             	pushl  -0x14(%ebp)
    634e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6351:	50                   	push   %eax
    6352:	ff 75 08             	pushl  0x8(%ebp)
    6355:	e8 f9 fa ff ff       	call   5e53 <inflateHuffmanBlock>
    635a:	83 c4 10             	add    $0x10,%esp
    635d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6360:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6364:	75 21                	jne    6387 <lodepng_inflatev+0xdf>
    6366:	8b 45 14             	mov    0x14(%ebp),%eax
    6369:	8b 40 08             	mov    0x8(%eax),%eax
    636c:	85 c0                	test   %eax,%eax
    636e:	74 17                	je     6387 <lodepng_inflatev+0xdf>
    6370:	8b 45 08             	mov    0x8(%ebp),%eax
    6373:	8b 50 04             	mov    0x4(%eax),%edx
    6376:	8b 45 14             	mov    0x14(%ebp),%eax
    6379:	8b 40 08             	mov    0x8(%eax),%eax
    637c:	39 c2                	cmp    %eax,%edx
    637e:	7e 07                	jle    6387 <lodepng_inflatev+0xdf>
    6380:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    6387:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    638b:	75 0c                	jne    6399 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    638d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6391:	0f 84 45 ff ff ff    	je     62dc <lodepng_inflatev+0x34>
    6397:	eb 01                	jmp    639a <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    6399:	90                   	nop
  }

  return error;
    639a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    639d:	c9                   	leave  
    639e:	c3                   	ret    

0000639f <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    639f:	55                   	push   %ebp
    63a0:	89 e5                	mov    %esp,%ebp
    63a2:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    63a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    63a8:	8b 08                	mov    (%eax),%ecx
    63aa:	8b 45 08             	mov    0x8(%ebp),%eax
    63ad:	8b 10                	mov    (%eax),%edx
    63af:	8d 45 e8             	lea    -0x18(%ebp),%eax
    63b2:	51                   	push   %ecx
    63b3:	52                   	push   %edx
    63b4:	50                   	push   %eax
    63b5:	e8 df d5 ff ff       	call   3999 <ucvector_init>
    63ba:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    63bd:	ff 75 18             	pushl  0x18(%ebp)
    63c0:	ff 75 14             	pushl  0x14(%ebp)
    63c3:	ff 75 10             	pushl  0x10(%ebp)
    63c6:	8d 45 e8             	lea    -0x18(%ebp),%eax
    63c9:	50                   	push   %eax
    63ca:	e8 d9 fe ff ff       	call   62a8 <lodepng_inflatev>
    63cf:	83 c4 10             	add    $0x10,%esp
    63d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    63d5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    63d8:	8b 45 08             	mov    0x8(%ebp),%eax
    63db:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    63dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    63e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    63e3:	89 10                	mov    %edx,(%eax)
  return error;
    63e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    63e8:	c9                   	leave  
    63e9:	c3                   	ret    

000063ea <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    63ea:	55                   	push   %ebp
    63eb:	89 e5                	mov    %esp,%ebp
    63ed:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    63f0:	8b 45 14             	mov    0x14(%ebp),%eax
    63f3:	8b 40 10             	mov    0x10(%eax),%eax
    63f6:	85 c0                	test   %eax,%eax
    63f8:	74 64                	je     645e <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    63fa:	8b 45 14             	mov    0x14(%ebp),%eax
    63fd:	8b 40 10             	mov    0x10(%eax),%eax
    6400:	8b 55 08             	mov    0x8(%ebp),%edx
    6403:	8d 4a 04             	lea    0x4(%edx),%ecx
    6406:	8b 55 08             	mov    0x8(%ebp),%edx
    6409:	83 ec 0c             	sub    $0xc,%esp
    640c:	ff 75 14             	pushl  0x14(%ebp)
    640f:	ff 75 10             	pushl  0x10(%ebp)
    6412:	ff 75 0c             	pushl  0xc(%ebp)
    6415:	51                   	push   %ecx
    6416:	52                   	push   %edx
    6417:	ff d0                	call   *%eax
    6419:	83 c4 20             	add    $0x20,%esp
    641c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    641f:	8b 45 08             	mov    0x8(%ebp),%eax
    6422:	8b 50 04             	mov    0x4(%eax),%edx
    6425:	8b 45 08             	mov    0x8(%ebp),%eax
    6428:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    642b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    642f:	74 28                	je     6459 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    6431:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6438:	8b 45 14             	mov    0x14(%ebp),%eax
    643b:	8b 40 08             	mov    0x8(%eax),%eax
    643e:	85 c0                	test   %eax,%eax
    6440:	74 17                	je     6459 <inflatev+0x6f>
    6442:	8b 45 08             	mov    0x8(%ebp),%eax
    6445:	8b 50 04             	mov    0x4(%eax),%edx
    6448:	8b 45 14             	mov    0x14(%ebp),%eax
    644b:	8b 40 08             	mov    0x8(%eax),%eax
    644e:	39 c2                	cmp    %eax,%edx
    6450:	7e 07                	jle    6459 <inflatev+0x6f>
    6452:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6459:	8b 45 f4             	mov    -0xc(%ebp),%eax
    645c:	eb 14                	jmp    6472 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    645e:	ff 75 14             	pushl  0x14(%ebp)
    6461:	ff 75 10             	pushl  0x10(%ebp)
    6464:	ff 75 0c             	pushl  0xc(%ebp)
    6467:	ff 75 08             	pushl  0x8(%ebp)
    646a:	e8 39 fe ff ff       	call   62a8 <lodepng_inflatev>
    646f:	83 c4 10             	add    $0x10,%esp
  }
}
    6472:	c9                   	leave  
    6473:	c3                   	ret    

00006474 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    6474:	55                   	push   %ebp
    6475:	89 e5                	mov    %esp,%ebp
    6477:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    647a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    6481:	8b 45 0c             	mov    0xc(%ebp),%eax
    6484:	83 e8 01             	sub    $0x1,%eax
    6487:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    648a:	eb 39                	jmp    64c5 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    648c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    648f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6492:	01 d0                	add    %edx,%eax
    6494:	d1 f8                	sar    %eax
    6496:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    6499:	8b 45 f4             	mov    -0xc(%ebp),%eax
    649c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    64a3:	8b 45 08             	mov    0x8(%ebp),%eax
    64a6:	01 d0                	add    %edx,%eax
    64a8:	8b 10                	mov    (%eax),%edx
    64aa:	8b 45 10             	mov    0x10(%ebp),%eax
    64ad:	39 c2                	cmp    %eax,%edx
    64af:	72 0b                	jb     64bc <searchCodeIndex+0x48>
    64b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    64b4:	83 e8 01             	sub    $0x1,%eax
    64b7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    64ba:	eb 09                	jmp    64c5 <searchCodeIndex+0x51>
    else left = mid + 1;
    64bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    64bf:	83 c0 01             	add    $0x1,%eax
    64c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    64c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    64c8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    64cb:	7e bf                	jle    648c <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    64cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    64d0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    64d3:	7d 18                	jge    64ed <searchCodeIndex+0x79>
    64d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    64d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    64df:	8b 45 08             	mov    0x8(%ebp),%eax
    64e2:	01 d0                	add    %edx,%eax
    64e4:	8b 10                	mov    (%eax),%edx
    64e6:	8b 45 10             	mov    0x10(%ebp),%eax
    64e9:	39 c2                	cmp    %eax,%edx
    64eb:	76 04                	jbe    64f1 <searchCodeIndex+0x7d>
    64ed:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    64f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    64f4:	c9                   	leave  
    64f5:	c3                   	ret    

000064f6 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    64f6:	55                   	push   %ebp
    64f7:	89 e5                	mov    %esp,%ebp
    64f9:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    64fc:	ff 75 0c             	pushl  0xc(%ebp)
    64ff:	6a 1d                	push   $0x1d
    6501:	68 80 a1 01 00       	push   $0x1a180
    6506:	e8 69 ff ff ff       	call   6474 <searchCodeIndex>
    650b:	83 c4 0c             	add    $0xc,%esp
    650e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    6511:	8b 55 0c             	mov    0xc(%ebp),%edx
    6514:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6517:	8b 04 85 80 a1 01 00 	mov    0x1a180(,%eax,4),%eax
    651e:	29 c2                	sub    %eax,%edx
    6520:	89 d0                	mov    %edx,%eax
    6522:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    6525:	ff 75 10             	pushl  0x10(%ebp)
    6528:	6a 1e                	push   $0x1e
    652a:	68 80 a2 01 00       	push   $0x1a280
    652f:	e8 40 ff ff ff       	call   6474 <searchCodeIndex>
    6534:	83 c4 0c             	add    $0xc,%esp
    6537:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    653a:	8b 55 10             	mov    0x10(%ebp),%edx
    653d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6540:	8b 04 85 80 a2 01 00 	mov    0x1a280(,%eax,4),%eax
    6547:	29 c2                	sub    %eax,%edx
    6549:	89 d0                	mov    %edx,%eax
    654b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    654e:	8b 45 08             	mov    0x8(%ebp),%eax
    6551:	8b 40 04             	mov    0x4(%eax),%eax
    6554:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    6557:	8b 45 08             	mov    0x8(%ebp),%eax
    655a:	8b 40 04             	mov    0x4(%eax),%eax
    655d:	83 c0 04             	add    $0x4,%eax
    6560:	50                   	push   %eax
    6561:	ff 75 08             	pushl  0x8(%ebp)
    6564:	e8 f0 d2 ff ff       	call   3859 <uivector_resize>
    6569:	83 c4 08             	add    $0x8,%esp
    656c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    656f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    6573:	74 57                	je     65cc <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    6575:	8b 45 08             	mov    0x8(%ebp),%eax
    6578:	8b 00                	mov    (%eax),%eax
    657a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    657d:	c1 e2 02             	shl    $0x2,%edx
    6580:	01 d0                	add    %edx,%eax
    6582:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6585:	81 c2 01 01 00 00    	add    $0x101,%edx
    658b:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    658d:	8b 45 08             	mov    0x8(%ebp),%eax
    6590:	8b 00                	mov    (%eax),%eax
    6592:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6595:	83 c2 01             	add    $0x1,%edx
    6598:	c1 e2 02             	shl    $0x2,%edx
    659b:	01 c2                	add    %eax,%edx
    659d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    65a0:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    65a2:	8b 45 08             	mov    0x8(%ebp),%eax
    65a5:	8b 00                	mov    (%eax),%eax
    65a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    65aa:	83 c2 02             	add    $0x2,%edx
    65ad:	c1 e2 02             	shl    $0x2,%edx
    65b0:	01 c2                	add    %eax,%edx
    65b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    65b5:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    65b7:	8b 45 08             	mov    0x8(%ebp),%eax
    65ba:	8b 00                	mov    (%eax),%eax
    65bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    65bf:	83 c2 03             	add    $0x3,%edx
    65c2:	c1 e2 02             	shl    $0x2,%edx
    65c5:	01 c2                	add    %eax,%edx
    65c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    65ca:	89 02                	mov    %eax,(%edx)
  }
}
    65cc:	90                   	nop
    65cd:	c9                   	leave  
    65ce:	c3                   	ret    

000065cf <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    65cf:	55                   	push   %ebp
    65d0:	89 e5                	mov    %esp,%ebp
    65d2:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    65d5:	b8 00 00 01 00       	mov    $0x10000,%eax
    65da:	c1 e0 02             	shl    $0x2,%eax
    65dd:	83 ec 0c             	sub    $0xc,%esp
    65e0:	50                   	push   %eax
    65e1:	e8 f2 d0 ff ff       	call   36d8 <lodepng_malloc>
    65e6:	83 c4 10             	add    $0x10,%esp
    65e9:	89 c2                	mov    %eax,%edx
    65eb:	8b 45 08             	mov    0x8(%ebp),%eax
    65ee:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    65f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    65f3:	c1 e0 02             	shl    $0x2,%eax
    65f6:	83 ec 0c             	sub    $0xc,%esp
    65f9:	50                   	push   %eax
    65fa:	e8 d9 d0 ff ff       	call   36d8 <lodepng_malloc>
    65ff:	83 c4 10             	add    $0x10,%esp
    6602:	89 c2                	mov    %eax,%edx
    6604:	8b 45 08             	mov    0x8(%ebp),%eax
    6607:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    660a:	8b 45 0c             	mov    0xc(%ebp),%eax
    660d:	01 c0                	add    %eax,%eax
    660f:	83 ec 0c             	sub    $0xc,%esp
    6612:	50                   	push   %eax
    6613:	e8 c0 d0 ff ff       	call   36d8 <lodepng_malloc>
    6618:	83 c4 10             	add    $0x10,%esp
    661b:	89 c2                	mov    %eax,%edx
    661d:	8b 45 08             	mov    0x8(%ebp),%eax
    6620:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6623:	8b 45 0c             	mov    0xc(%ebp),%eax
    6626:	01 c0                	add    %eax,%eax
    6628:	83 ec 0c             	sub    $0xc,%esp
    662b:	50                   	push   %eax
    662c:	e8 a7 d0 ff ff       	call   36d8 <lodepng_malloc>
    6631:	83 c4 10             	add    $0x10,%esp
    6634:	89 c2                	mov    %eax,%edx
    6636:	8b 45 08             	mov    0x8(%ebp),%eax
    6639:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    663c:	b8 02 01 00 00       	mov    $0x102,%eax
    6641:	83 c0 01             	add    $0x1,%eax
    6644:	c1 e0 02             	shl    $0x2,%eax
    6647:	83 ec 0c             	sub    $0xc,%esp
    664a:	50                   	push   %eax
    664b:	e8 88 d0 ff ff       	call   36d8 <lodepng_malloc>
    6650:	83 c4 10             	add    $0x10,%esp
    6653:	89 c2                	mov    %eax,%edx
    6655:	8b 45 08             	mov    0x8(%ebp),%eax
    6658:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    665b:	8b 45 0c             	mov    0xc(%ebp),%eax
    665e:	01 c0                	add    %eax,%eax
    6660:	83 ec 0c             	sub    $0xc,%esp
    6663:	50                   	push   %eax
    6664:	e8 6f d0 ff ff       	call   36d8 <lodepng_malloc>
    6669:	83 c4 10             	add    $0x10,%esp
    666c:	89 c2                	mov    %eax,%edx
    666e:	8b 45 08             	mov    0x8(%ebp),%eax
    6671:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    6674:	8b 45 08             	mov    0x8(%ebp),%eax
    6677:	8b 00                	mov    (%eax),%eax
    6679:	85 c0                	test   %eax,%eax
    667b:	74 32                	je     66af <hash_init+0xe0>
    667d:	8b 45 08             	mov    0x8(%ebp),%eax
    6680:	8b 40 04             	mov    0x4(%eax),%eax
    6683:	85 c0                	test   %eax,%eax
    6685:	74 28                	je     66af <hash_init+0xe0>
    6687:	8b 45 08             	mov    0x8(%ebp),%eax
    668a:	8b 40 08             	mov    0x8(%eax),%eax
    668d:	85 c0                	test   %eax,%eax
    668f:	74 1e                	je     66af <hash_init+0xe0>
    6691:	8b 45 08             	mov    0x8(%ebp),%eax
    6694:	8b 40 0c             	mov    0xc(%eax),%eax
    6697:	85 c0                	test   %eax,%eax
    6699:	74 14                	je     66af <hash_init+0xe0>
    669b:	8b 45 08             	mov    0x8(%ebp),%eax
    669e:	8b 40 10             	mov    0x10(%eax),%eax
    66a1:	85 c0                	test   %eax,%eax
    66a3:	74 0a                	je     66af <hash_init+0xe0>
    66a5:	8b 45 08             	mov    0x8(%ebp),%eax
    66a8:	8b 40 14             	mov    0x14(%eax),%eax
    66ab:	85 c0                	test   %eax,%eax
    66ad:	75 0a                	jne    66b9 <hash_init+0xea>
    return 83; /*alloc fail*/
    66af:	b8 53 00 00 00       	mov    $0x53,%eax
    66b4:	e9 d3 00 00 00       	jmp    678c <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    66b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    66c0:	eb 17                	jmp    66d9 <hash_init+0x10a>
    66c2:	8b 45 08             	mov    0x8(%ebp),%eax
    66c5:	8b 00                	mov    (%eax),%eax
    66c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    66ca:	c1 e2 02             	shl    $0x2,%edx
    66cd:	01 d0                	add    %edx,%eax
    66cf:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    66d5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    66d9:	b8 00 00 01 00       	mov    $0x10000,%eax
    66de:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    66e1:	75 df                	jne    66c2 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    66e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    66ea:	eb 18                	jmp    6704 <hash_init+0x135>
    66ec:	8b 45 08             	mov    0x8(%ebp),%eax
    66ef:	8b 40 08             	mov    0x8(%eax),%eax
    66f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    66f5:	c1 e2 02             	shl    $0x2,%edx
    66f8:	01 d0                	add    %edx,%eax
    66fa:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6700:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6704:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6707:	3b 45 0c             	cmp    0xc(%ebp),%eax
    670a:	75 e0                	jne    66ec <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    670c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6713:	eb 17                	jmp    672c <hash_init+0x15d>
    6715:	8b 45 08             	mov    0x8(%ebp),%eax
    6718:	8b 40 04             	mov    0x4(%eax),%eax
    671b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    671e:	01 d2                	add    %edx,%edx
    6720:	01 d0                	add    %edx,%eax
    6722:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6725:	66 89 10             	mov    %dx,(%eax)
    6728:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    672c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    672f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6732:	75 e1                	jne    6715 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6734:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    673b:	eb 18                	jmp    6755 <hash_init+0x186>
    673d:	8b 45 08             	mov    0x8(%ebp),%eax
    6740:	8b 40 0c             	mov    0xc(%eax),%eax
    6743:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6746:	c1 e2 02             	shl    $0x2,%edx
    6749:	01 d0                	add    %edx,%eax
    674b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6751:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6755:	b8 02 01 00 00       	mov    $0x102,%eax
    675a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    675d:	76 de                	jbe    673d <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    675f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6766:	eb 17                	jmp    677f <hash_init+0x1b0>
    6768:	8b 45 08             	mov    0x8(%ebp),%eax
    676b:	8b 40 10             	mov    0x10(%eax),%eax
    676e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6771:	01 d2                	add    %edx,%edx
    6773:	01 d0                	add    %edx,%eax
    6775:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6778:	66 89 10             	mov    %dx,(%eax)
    677b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    677f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6782:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6785:	75 e1                	jne    6768 <hash_init+0x199>

  return 0;
    6787:	b8 00 00 00 00       	mov    $0x0,%eax
}
    678c:	c9                   	leave  
    678d:	c3                   	ret    

0000678e <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    678e:	55                   	push   %ebp
    678f:	89 e5                	mov    %esp,%ebp
    6791:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    6794:	8b 45 08             	mov    0x8(%ebp),%eax
    6797:	8b 00                	mov    (%eax),%eax
    6799:	83 ec 0c             	sub    $0xc,%esp
    679c:	50                   	push   %eax
    679d:	e8 57 cf ff ff       	call   36f9 <lodepng_free>
    67a2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    67a5:	8b 45 08             	mov    0x8(%ebp),%eax
    67a8:	8b 40 08             	mov    0x8(%eax),%eax
    67ab:	83 ec 0c             	sub    $0xc,%esp
    67ae:	50                   	push   %eax
    67af:	e8 45 cf ff ff       	call   36f9 <lodepng_free>
    67b4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    67b7:	8b 45 08             	mov    0x8(%ebp),%eax
    67ba:	8b 40 04             	mov    0x4(%eax),%eax
    67bd:	83 ec 0c             	sub    $0xc,%esp
    67c0:	50                   	push   %eax
    67c1:	e8 33 cf ff ff       	call   36f9 <lodepng_free>
    67c6:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    67c9:	8b 45 08             	mov    0x8(%ebp),%eax
    67cc:	8b 40 14             	mov    0x14(%eax),%eax
    67cf:	83 ec 0c             	sub    $0xc,%esp
    67d2:	50                   	push   %eax
    67d3:	e8 21 cf ff ff       	call   36f9 <lodepng_free>
    67d8:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    67db:	8b 45 08             	mov    0x8(%ebp),%eax
    67de:	8b 40 0c             	mov    0xc(%eax),%eax
    67e1:	83 ec 0c             	sub    $0xc,%esp
    67e4:	50                   	push   %eax
    67e5:	e8 0f cf ff ff       	call   36f9 <lodepng_free>
    67ea:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    67ed:	8b 45 08             	mov    0x8(%ebp),%eax
    67f0:	8b 40 10             	mov    0x10(%eax),%eax
    67f3:	83 ec 0c             	sub    $0xc,%esp
    67f6:	50                   	push   %eax
    67f7:	e8 fd ce ff ff       	call   36f9 <lodepng_free>
    67fc:	83 c4 10             	add    $0x10,%esp
}
    67ff:	90                   	nop
    6800:	c9                   	leave  
    6801:	c3                   	ret    

00006802 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    6802:	55                   	push   %ebp
    6803:	89 e5                	mov    %esp,%ebp
    6805:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6808:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    680f:	8b 45 10             	mov    0x10(%ebp),%eax
    6812:	83 c0 02             	add    $0x2,%eax
    6815:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6818:	7d 41                	jge    685b <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    681a:	8b 55 10             	mov    0x10(%ebp),%edx
    681d:	8b 45 08             	mov    0x8(%ebp),%eax
    6820:	01 d0                	add    %edx,%eax
    6822:	0f b6 00             	movzbl (%eax),%eax
    6825:	0f b6 c0             	movzbl %al,%eax
    6828:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    682b:	8b 45 10             	mov    0x10(%ebp),%eax
    682e:	8d 50 01             	lea    0x1(%eax),%edx
    6831:	8b 45 08             	mov    0x8(%ebp),%eax
    6834:	01 d0                	add    %edx,%eax
    6836:	0f b6 00             	movzbl (%eax),%eax
    6839:	0f b6 c0             	movzbl %al,%eax
    683c:	c1 e0 04             	shl    $0x4,%eax
    683f:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    6842:	8b 45 10             	mov    0x10(%ebp),%eax
    6845:	8d 50 02             	lea    0x2(%eax),%edx
    6848:	8b 45 08             	mov    0x8(%ebp),%eax
    684b:	01 d0                	add    %edx,%eax
    684d:	0f b6 00             	movzbl (%eax),%eax
    6850:	0f b6 c0             	movzbl %al,%eax
    6853:	c1 e0 08             	shl    $0x8,%eax
    6856:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6859:	eb 51                	jmp    68ac <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    685b:	8b 45 10             	mov    0x10(%ebp),%eax
    685e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6861:	7c 07                	jl     686a <getHash+0x68>
    6863:	b8 00 00 00 00       	mov    $0x0,%eax
    6868:	eb 4a                	jmp    68b4 <getHash+0xb2>
    amount = size - pos;
    686a:	8b 45 0c             	mov    0xc(%ebp),%eax
    686d:	2b 45 10             	sub    0x10(%ebp),%eax
    6870:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    6873:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    687a:	eb 28                	jmp    68a4 <getHash+0xa2>
    687c:	8b 55 10             	mov    0x10(%ebp),%edx
    687f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6882:	01 d0                	add    %edx,%eax
    6884:	89 c2                	mov    %eax,%edx
    6886:	8b 45 08             	mov    0x8(%ebp),%eax
    6889:	01 d0                	add    %edx,%eax
    688b:	0f b6 00             	movzbl (%eax),%eax
    688e:	0f b6 d0             	movzbl %al,%edx
    6891:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6894:	c1 e0 03             	shl    $0x3,%eax
    6897:	89 c1                	mov    %eax,%ecx
    6899:	d3 e2                	shl    %cl,%edx
    689b:	89 d0                	mov    %edx,%eax
    689d:	31 45 fc             	xor    %eax,-0x4(%ebp)
    68a0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    68a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    68a7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    68aa:	75 d0                	jne    687c <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    68ac:	b8 ff ff 00 00       	mov    $0xffff,%eax
    68b1:	23 45 fc             	and    -0x4(%ebp),%eax
}
    68b4:	c9                   	leave  
    68b5:	c3                   	ret    

000068b6 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    68b6:	55                   	push   %ebp
    68b7:	89 e5                	mov    %esp,%ebp
    68b9:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    68bc:	8b 55 10             	mov    0x10(%ebp),%edx
    68bf:	8b 45 08             	mov    0x8(%ebp),%eax
    68c2:	01 d0                	add    %edx,%eax
    68c4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    68c7:	b8 02 01 00 00       	mov    $0x102,%eax
    68cc:	89 c2                	mov    %eax,%edx
    68ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
    68d1:	01 d0                	add    %edx,%eax
    68d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    68d6:	8b 55 0c             	mov    0xc(%ebp),%edx
    68d9:	8b 45 08             	mov    0x8(%ebp),%eax
    68dc:	01 d0                	add    %edx,%eax
    68de:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    68e1:	73 0b                	jae    68ee <countZeros+0x38>
    68e3:	8b 55 0c             	mov    0xc(%ebp),%edx
    68e6:	8b 45 08             	mov    0x8(%ebp),%eax
    68e9:	01 d0                	add    %edx,%eax
    68eb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    68ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    68f1:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    68f4:	eb 04                	jmp    68fa <countZeros+0x44>
    68f6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    68fa:	8b 45 08             	mov    0x8(%ebp),%eax
    68fd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6900:	74 0a                	je     690c <countZeros+0x56>
    6902:	8b 45 08             	mov    0x8(%ebp),%eax
    6905:	0f b6 00             	movzbl (%eax),%eax
    6908:	84 c0                	test   %al,%al
    690a:	74 ea                	je     68f6 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    690c:	8b 55 08             	mov    0x8(%ebp),%edx
    690f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6912:	29 c2                	sub    %eax,%edx
    6914:	89 d0                	mov    %edx,%eax
}
    6916:	c9                   	leave  
    6917:	c3                   	ret    

00006918 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6918:	55                   	push   %ebp
    6919:	89 e5                	mov    %esp,%ebp
    691b:	83 ec 04             	sub    $0x4,%esp
    691e:	8b 45 14             	mov    0x14(%ebp),%eax
    6921:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6925:	8b 45 08             	mov    0x8(%ebp),%eax
    6928:	8b 40 08             	mov    0x8(%eax),%eax
    692b:	8b 55 0c             	mov    0xc(%ebp),%edx
    692e:	c1 e2 02             	shl    $0x2,%edx
    6931:	01 c2                	add    %eax,%edx
    6933:	8b 45 10             	mov    0x10(%ebp),%eax
    6936:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6938:	8b 45 08             	mov    0x8(%ebp),%eax
    693b:	8b 00                	mov    (%eax),%eax
    693d:	8b 55 10             	mov    0x10(%ebp),%edx
    6940:	c1 e2 02             	shl    $0x2,%edx
    6943:	01 d0                	add    %edx,%eax
    6945:	8b 00                	mov    (%eax),%eax
    6947:	83 f8 ff             	cmp    $0xffffffff,%eax
    694a:	74 1f                	je     696b <updateHashChain+0x53>
    694c:	8b 45 08             	mov    0x8(%ebp),%eax
    694f:	8b 40 04             	mov    0x4(%eax),%eax
    6952:	8b 55 0c             	mov    0xc(%ebp),%edx
    6955:	01 d2                	add    %edx,%edx
    6957:	01 c2                	add    %eax,%edx
    6959:	8b 45 08             	mov    0x8(%ebp),%eax
    695c:	8b 00                	mov    (%eax),%eax
    695e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6961:	c1 e1 02             	shl    $0x2,%ecx
    6964:	01 c8                	add    %ecx,%eax
    6966:	8b 00                	mov    (%eax),%eax
    6968:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    696b:	8b 45 08             	mov    0x8(%ebp),%eax
    696e:	8b 00                	mov    (%eax),%eax
    6970:	8b 55 10             	mov    0x10(%ebp),%edx
    6973:	c1 e2 02             	shl    $0x2,%edx
    6976:	01 c2                	add    %eax,%edx
    6978:	8b 45 0c             	mov    0xc(%ebp),%eax
    697b:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    697d:	8b 45 08             	mov    0x8(%ebp),%eax
    6980:	8b 40 14             	mov    0x14(%eax),%eax
    6983:	8b 55 0c             	mov    0xc(%ebp),%edx
    6986:	01 d2                	add    %edx,%edx
    6988:	01 c2                	add    %eax,%edx
    698a:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    698e:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    6991:	8b 45 08             	mov    0x8(%ebp),%eax
    6994:	8b 40 0c             	mov    0xc(%eax),%eax
    6997:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    699b:	c1 e2 02             	shl    $0x2,%edx
    699e:	01 d0                	add    %edx,%eax
    69a0:	8b 00                	mov    (%eax),%eax
    69a2:	83 f8 ff             	cmp    $0xffffffff,%eax
    69a5:	74 21                	je     69c8 <updateHashChain+0xb0>
    69a7:	8b 45 08             	mov    0x8(%ebp),%eax
    69aa:	8b 40 10             	mov    0x10(%eax),%eax
    69ad:	8b 55 0c             	mov    0xc(%ebp),%edx
    69b0:	01 d2                	add    %edx,%edx
    69b2:	01 c2                	add    %eax,%edx
    69b4:	8b 45 08             	mov    0x8(%ebp),%eax
    69b7:	8b 40 0c             	mov    0xc(%eax),%eax
    69ba:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    69be:	c1 e1 02             	shl    $0x2,%ecx
    69c1:	01 c8                	add    %ecx,%eax
    69c3:	8b 00                	mov    (%eax),%eax
    69c5:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    69c8:	8b 45 08             	mov    0x8(%ebp),%eax
    69cb:	8b 40 0c             	mov    0xc(%eax),%eax
    69ce:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    69d2:	c1 e2 02             	shl    $0x2,%edx
    69d5:	01 c2                	add    %eax,%edx
    69d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    69da:	89 02                	mov    %eax,(%edx)
}
    69dc:	90                   	nop
    69dd:	c9                   	leave  
    69de:	c3                   	ret    

000069df <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    69df:	55                   	push   %ebp
    69e0:	89 e5                	mov    %esp,%ebp
    69e2:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    69e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    69ec:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    69f3:	77 08                	ja     69fd <encodeLZ77+0x1e>
    69f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    69f8:	c1 e8 03             	shr    $0x3,%eax
    69fb:	eb 03                	jmp    6a00 <encodeLZ77+0x21>
    69fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6a00:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6a03:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6a0a:	76 07                	jbe    6a13 <encodeLZ77+0x34>
    6a0c:	b8 02 01 00 00       	mov    $0x102,%eax
    6a11:	eb 05                	jmp    6a18 <encodeLZ77+0x39>
    6a13:	b8 40 00 00 00       	mov    $0x40,%eax
    6a18:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6a1b:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    6a22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6a29:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    6a30:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6a37:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    6a3e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    6a42:	74 09                	je     6a4d <encodeLZ77+0x6e>
    6a44:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6a4b:	76 0a                	jbe    6a57 <encodeLZ77+0x78>
    6a4d:	b8 3c 00 00 00       	mov    $0x3c,%eax
    6a52:	e9 e3 04 00 00       	jmp    6f3a <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    6a57:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6a5a:	83 e8 01             	sub    $0x1,%eax
    6a5d:	23 45 1c             	and    0x1c(%ebp),%eax
    6a60:	85 c0                	test   %eax,%eax
    6a62:	74 0a                	je     6a6e <encodeLZ77+0x8f>
    6a64:	b8 5a 00 00 00       	mov    $0x5a,%eax
    6a69:	e9 cc 04 00 00       	jmp    6f3a <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    6a6e:	b8 02 01 00 00       	mov    $0x102,%eax
    6a73:	39 45 24             	cmp    %eax,0x24(%ebp)
    6a76:	76 08                	jbe    6a80 <encodeLZ77+0xa1>
    6a78:	b8 02 01 00 00       	mov    $0x102,%eax
    6a7d:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    6a80:	8b 45 14             	mov    0x14(%ebp),%eax
    6a83:	89 45 fc             	mov    %eax,-0x4(%ebp)
    6a86:	e9 a0 04 00 00       	jmp    6f2b <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    6a8b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6a8e:	8d 50 ff             	lea    -0x1(%eax),%edx
    6a91:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6a94:	21 d0                	and    %edx,%eax
    6a96:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    6a99:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    6aa0:	ff 75 fc             	pushl  -0x4(%ebp)
    6aa3:	ff 75 18             	pushl  0x18(%ebp)
    6aa6:	ff 75 10             	pushl  0x10(%ebp)
    6aa9:	e8 54 fd ff ff       	call   6802 <getHash>
    6aae:	83 c4 0c             	add    $0xc,%esp
    6ab1:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    6ab4:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6ab8:	74 4e                	je     6b08 <encodeLZ77+0x129>
    6aba:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6abe:	75 48                	jne    6b08 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6ac0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6ac4:	75 16                	jne    6adc <encodeLZ77+0xfd>
    6ac6:	ff 75 fc             	pushl  -0x4(%ebp)
    6ac9:	ff 75 18             	pushl  0x18(%ebp)
    6acc:	ff 75 10             	pushl  0x10(%ebp)
    6acf:	e8 e2 fd ff ff       	call   68b6 <countZeros>
    6ad4:	83 c4 0c             	add    $0xc,%esp
    6ad7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6ada:	eb 35                	jmp    6b11 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6adc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6adf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ae2:	01 c2                	add    %eax,%edx
    6ae4:	8b 45 18             	mov    0x18(%ebp),%eax
    6ae7:	39 c2                	cmp    %eax,%edx
    6ae9:	77 17                	ja     6b02 <encodeLZ77+0x123>
    6aeb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6aee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6af1:	01 d0                	add    %edx,%eax
    6af3:	8d 50 ff             	lea    -0x1(%eax),%edx
    6af6:	8b 45 10             	mov    0x10(%ebp),%eax
    6af9:	01 d0                	add    %edx,%eax
    6afb:	0f b6 00             	movzbl (%eax),%eax
    6afe:	84 c0                	test   %al,%al
    6b00:	74 0f                	je     6b11 <encodeLZ77+0x132>
    6b02:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b06:	eb 09                	jmp    6b11 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6b08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6b0f:	eb 01                	jmp    6b12 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b11:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    6b12:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b15:	0f b7 c0             	movzwl %ax,%eax
    6b18:	50                   	push   %eax
    6b19:	ff 75 b0             	pushl  -0x50(%ebp)
    6b1c:	ff 75 b4             	pushl  -0x4c(%ebp)
    6b1f:	ff 75 0c             	pushl  0xc(%ebp)
    6b22:	e8 f1 fd ff ff       	call   6918 <updateHashChain>
    6b27:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6b2a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    6b31:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6b38:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b3b:	8b 40 04             	mov    0x4(%eax),%eax
    6b3e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    6b41:	01 d2                	add    %edx,%edx
    6b43:	01 d0                	add    %edx,%eax
    6b45:	0f b7 00             	movzwl (%eax),%eax
    6b48:	0f b7 c0             	movzwl %ax,%eax
    6b4b:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6b4e:	ba 02 01 00 00       	mov    $0x102,%edx
    6b53:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6b56:	01 c2                	add    %eax,%edx
    6b58:	8b 45 18             	mov    0x18(%ebp),%eax
    6b5b:	39 c2                	cmp    %eax,%edx
    6b5d:	0f 4e c2             	cmovle %edx,%eax
    6b60:	89 c2                	mov    %eax,%edx
    6b62:	8b 45 10             	mov    0x10(%ebp),%eax
    6b65:	01 d0                	add    %edx,%eax
    6b67:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6b6a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6b71:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6b74:	8d 50 01             	lea    0x1(%eax),%edx
    6b77:	89 55 c8             	mov    %edx,-0x38(%ebp)
    6b7a:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6b7d:	0f 83 67 01 00 00    	jae    6cea <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    6b83:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6b86:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    6b89:	77 08                	ja     6b93 <encodeLZ77+0x1b4>
    6b8b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6b8e:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6b91:	eb 0d                	jmp    6ba0 <encodeLZ77+0x1c1>
    6b93:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6b96:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6b99:	89 c2                	mov    %eax,%edx
    6b9b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6b9e:	01 d0                	add    %edx,%eax
    6ba0:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6ba3:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6ba6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6ba9:	0f 82 3e 01 00 00    	jb     6ced <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6baf:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6bb2:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    6bb5:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6bb9:	0f 84 a3 00 00 00    	je     6c62 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    6bbf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6bc2:	8b 45 10             	mov    0x10(%ebp),%eax
    6bc5:	01 d0                	add    %edx,%eax
    6bc7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6bca:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6bcd:	2b 45 a8             	sub    -0x58(%ebp),%eax
    6bd0:	89 c2                	mov    %eax,%edx
    6bd2:	8b 45 10             	mov    0x10(%ebp),%eax
    6bd5:	01 d0                	add    %edx,%eax
    6bd7:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6bda:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6bde:	76 3a                	jbe    6c1a <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    6be0:	8b 45 0c             	mov    0xc(%ebp),%eax
    6be3:	8b 40 14             	mov    0x14(%eax),%eax
    6be6:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6be9:	01 d2                	add    %edx,%edx
    6beb:	01 d0                	add    %edx,%eax
    6bed:	0f b7 00             	movzwl (%eax),%eax
    6bf0:	0f b7 c0             	movzwl %ax,%eax
    6bf3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6bf6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6bf9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6bfc:	76 06                	jbe    6c04 <encodeLZ77+0x225>
    6bfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c01:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    6c04:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6c07:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6c0a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6c0d:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6c10:	eb 08                	jmp    6c1a <encodeLZ77+0x23b>
          ++backptr;
    6c12:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6c16:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6c1a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6c1d:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    6c20:	74 10                	je     6c32 <encodeLZ77+0x253>
    6c22:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6c25:	0f b6 10             	movzbl (%eax),%edx
    6c28:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6c2b:	0f b6 00             	movzbl (%eax),%eax
    6c2e:	38 c2                	cmp    %al,%dl
    6c30:	74 e0                	je     6c12 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    6c32:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6c35:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6c38:	8b 55 10             	mov    0x10(%ebp),%edx
    6c3b:	01 ca                	add    %ecx,%edx
    6c3d:	29 d0                	sub    %edx,%eax
    6c3f:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    6c42:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6c45:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6c48:	76 18                	jbe    6c62 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6c4a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6c4d:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    6c50:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6c53:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6c56:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6c59:	3b 45 24             	cmp    0x24(%ebp),%eax
    6c5c:	0f 83 8e 00 00 00    	jae    6cf0 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6c62:	8b 45 0c             	mov    0xc(%ebp),%eax
    6c65:	8b 40 04             	mov    0x4(%eax),%eax
    6c68:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6c6b:	01 d2                	add    %edx,%edx
    6c6d:	01 d0                	add    %edx,%eax
    6c6f:	0f b7 00             	movzwl (%eax),%eax
    6c72:	0f b7 c0             	movzwl %ax,%eax
    6c75:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6c78:	74 79                	je     6cf3 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    6c7a:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6c7e:	76 38                	jbe    6cb8 <encodeLZ77+0x2d9>
    6c80:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c83:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6c86:	76 30                	jbe    6cb8 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    6c88:	8b 45 0c             	mov    0xc(%ebp),%eax
    6c8b:	8b 40 10             	mov    0x10(%eax),%eax
    6c8e:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6c91:	01 d2                	add    %edx,%edx
    6c93:	01 d0                	add    %edx,%eax
    6c95:	0f b7 00             	movzwl (%eax),%eax
    6c98:	0f b7 c0             	movzwl %ax,%eax
    6c9b:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    6c9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ca1:	8b 40 14             	mov    0x14(%eax),%eax
    6ca4:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6ca7:	01 d2                	add    %edx,%edx
    6ca9:	01 d0                	add    %edx,%eax
    6cab:	0f b7 00             	movzwl (%eax),%eax
    6cae:	0f b7 c0             	movzwl %ax,%eax
    6cb1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6cb4:	74 2f                	je     6ce5 <encodeLZ77+0x306>
    6cb6:	eb 3f                	jmp    6cf7 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cbb:	8b 40 04             	mov    0x4(%eax),%eax
    6cbe:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6cc1:	01 d2                	add    %edx,%edx
    6cc3:	01 d0                	add    %edx,%eax
    6cc5:	0f b7 00             	movzwl (%eax),%eax
    6cc8:	0f b7 c0             	movzwl %ax,%eax
    6ccb:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6cce:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cd1:	8b 40 08             	mov    0x8(%eax),%eax
    6cd4:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6cd7:	c1 e2 02             	shl    $0x2,%edx
    6cda:	01 d0                	add    %edx,%eax
    6cdc:	8b 10                	mov    (%eax),%edx
    6cde:	8b 45 b0             	mov    -0x50(%ebp),%eax
    6ce1:	39 c2                	cmp    %eax,%edx
    6ce3:	75 11                	jne    6cf6 <encodeLZ77+0x317>
      }
    }
    6ce5:	e9 87 fe ff ff       	jmp    6b71 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6cea:	90                   	nop
    6ceb:	eb 0a                	jmp    6cf7 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6ced:	90                   	nop
    6cee:	eb 07                	jmp    6cf7 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6cf0:	90                   	nop
    6cf1:	eb 04                	jmp    6cf7 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6cf3:	90                   	nop
    6cf4:	eb 01                	jmp    6cf7 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6cf6:	90                   	nop
      }
    }

    if(lazymatching) {
    6cf7:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6cfb:	0f 84 c8 00 00 00    	je     6dc9 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    6d01:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6d05:	75 30                	jne    6d37 <encodeLZ77+0x358>
    6d07:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6d0b:	76 2a                	jbe    6d37 <encodeLZ77+0x358>
    6d0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d10:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6d13:	77 22                	ja     6d37 <encodeLZ77+0x358>
    6d15:	b8 02 01 00 00       	mov    $0x102,%eax
    6d1a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6d1d:	73 18                	jae    6d37 <encodeLZ77+0x358>
        lazy = 1;
    6d1f:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6d26:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d29:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6d2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d2f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6d32:	e9 f0 01 00 00       	jmp    6f27 <encodeLZ77+0x548>
      }
      if(lazy) {
    6d37:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6d3b:	0f 84 88 00 00 00    	je     6dc9 <encodeLZ77+0x3ea>
        lazy = 0;
    6d41:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6d48:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6d4c:	75 0c                	jne    6d5a <encodeLZ77+0x37b>
    6d4e:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6d55:	e9 dd 01 00 00       	jmp    6f37 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6d5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6d5d:	83 c0 01             	add    $0x1,%eax
    6d60:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6d63:	73 2d                	jae    6d92 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    6d65:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6d68:	8d 50 ff             	lea    -0x1(%eax),%edx
    6d6b:	8b 45 10             	mov    0x10(%ebp),%eax
    6d6e:	01 d0                	add    %edx,%eax
    6d70:	0f b6 00             	movzbl (%eax),%eax
    6d73:	0f b6 c0             	movzbl %al,%eax
    6d76:	50                   	push   %eax
    6d77:	ff 75 08             	pushl  0x8(%ebp)
    6d7a:	e8 6f cb ff ff       	call   38ee <uivector_push_back>
    6d7f:	83 c4 08             	add    $0x8,%esp
    6d82:	85 c0                	test   %eax,%eax
    6d84:	75 43                	jne    6dc9 <encodeLZ77+0x3ea>
    6d86:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6d8d:	e9 a5 01 00 00       	jmp    6f37 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6d92:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6d95:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6d98:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6d9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6d9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6da1:	8b 00                	mov    (%eax),%eax
    6da3:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6da6:	c1 e2 02             	shl    $0x2,%edx
    6da9:	01 d0                	add    %edx,%eax
    6dab:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6db1:	8b 45 0c             	mov    0xc(%ebp),%eax
    6db4:	8b 40 0c             	mov    0xc(%eax),%eax
    6db7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6dba:	c1 e2 02             	shl    $0x2,%edx
    6dbd:	01 d0                	add    %edx,%eax
    6dbf:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6dc5:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6dc9:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6dcd:	76 14                	jbe    6de3 <encodeLZ77+0x404>
    6dcf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6dd2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6dd5:	76 0c                	jbe    6de3 <encodeLZ77+0x404>
    6dd7:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6dde:	e9 54 01 00 00       	jmp    6f37 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6de3:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6de7:	77 2e                	ja     6e17 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6de9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6dec:	8b 45 10             	mov    0x10(%ebp),%eax
    6def:	01 d0                	add    %edx,%eax
    6df1:	0f b6 00             	movzbl (%eax),%eax
    6df4:	0f b6 c0             	movzbl %al,%eax
    6df7:	50                   	push   %eax
    6df8:	ff 75 08             	pushl  0x8(%ebp)
    6dfb:	e8 ee ca ff ff       	call   38ee <uivector_push_back>
    6e00:	83 c4 08             	add    $0x8,%esp
    6e03:	85 c0                	test   %eax,%eax
    6e05:	0f 85 1c 01 00 00    	jne    6f27 <encodeLZ77+0x548>
    6e0b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6e12:	e9 20 01 00 00       	jmp    6f37 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6e17:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e1a:	3b 45 20             	cmp    0x20(%ebp),%eax
    6e1d:	72 0f                	jb     6e2e <encodeLZ77+0x44f>
    6e1f:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6e23:	75 37                	jne    6e5c <encodeLZ77+0x47d>
    6e25:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6e2c:	76 2e                	jbe    6e5c <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6e2e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e31:	8b 45 10             	mov    0x10(%ebp),%eax
    6e34:	01 d0                	add    %edx,%eax
    6e36:	0f b6 00             	movzbl (%eax),%eax
    6e39:	0f b6 c0             	movzbl %al,%eax
    6e3c:	50                   	push   %eax
    6e3d:	ff 75 08             	pushl  0x8(%ebp)
    6e40:	e8 a9 ca ff ff       	call   38ee <uivector_push_back>
    6e45:	83 c4 08             	add    $0x8,%esp
    6e48:	85 c0                	test   %eax,%eax
    6e4a:	0f 85 d7 00 00 00    	jne    6f27 <encodeLZ77+0x548>
    6e50:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6e57:	e9 db 00 00 00       	jmp    6f37 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6e5c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e62:	52                   	push   %edx
    6e63:	50                   	push   %eax
    6e64:	ff 75 08             	pushl  0x8(%ebp)
    6e67:	e8 8a f6 ff ff       	call   64f6 <addLengthDistance>
    6e6c:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6e6f:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6e76:	e9 a0 00 00 00       	jmp    6f1b <encodeLZ77+0x53c>
        ++pos;
    6e7b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6e7f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6e82:	8d 50 ff             	lea    -0x1(%eax),%edx
    6e85:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6e88:	21 d0                	and    %edx,%eax
    6e8a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6e8d:	ff 75 fc             	pushl  -0x4(%ebp)
    6e90:	ff 75 18             	pushl  0x18(%ebp)
    6e93:	ff 75 10             	pushl  0x10(%ebp)
    6e96:	e8 67 f9 ff ff       	call   6802 <getHash>
    6e9b:	83 c4 0c             	add    $0xc,%esp
    6e9e:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6ea1:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6ea5:	74 4e                	je     6ef5 <encodeLZ77+0x516>
    6ea7:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6eab:	75 48                	jne    6ef5 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6ead:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6eb1:	75 16                	jne    6ec9 <encodeLZ77+0x4ea>
    6eb3:	ff 75 fc             	pushl  -0x4(%ebp)
    6eb6:	ff 75 18             	pushl  0x18(%ebp)
    6eb9:	ff 75 10             	pushl  0x10(%ebp)
    6ebc:	e8 f5 f9 ff ff       	call   68b6 <countZeros>
    6ec1:	83 c4 0c             	add    $0xc,%esp
    6ec4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6ec7:	eb 35                	jmp    6efe <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6ec9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ecc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ecf:	01 c2                	add    %eax,%edx
    6ed1:	8b 45 18             	mov    0x18(%ebp),%eax
    6ed4:	39 c2                	cmp    %eax,%edx
    6ed6:	77 17                	ja     6eef <encodeLZ77+0x510>
    6ed8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6edb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ede:	01 d0                	add    %edx,%eax
    6ee0:	8d 50 ff             	lea    -0x1(%eax),%edx
    6ee3:	8b 45 10             	mov    0x10(%ebp),%eax
    6ee6:	01 d0                	add    %edx,%eax
    6ee8:	0f b6 00             	movzbl (%eax),%eax
    6eeb:	84 c0                	test   %al,%al
    6eed:	74 0f                	je     6efe <encodeLZ77+0x51f>
    6eef:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6ef3:	eb 09                	jmp    6efe <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6ef5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6efc:	eb 01                	jmp    6eff <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6efe:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6eff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f02:	0f b7 c0             	movzwl %ax,%eax
    6f05:	50                   	push   %eax
    6f06:	ff 75 b0             	pushl  -0x50(%ebp)
    6f09:	ff 75 b4             	pushl  -0x4c(%ebp)
    6f0c:	ff 75 0c             	pushl  0xc(%ebp)
    6f0f:	e8 04 fa ff ff       	call   6918 <updateHashChain>
    6f14:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6f17:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6f1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6f1e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6f21:	0f 82 54 ff ff ff    	jb     6e7b <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6f27:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6f2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6f2e:	3b 45 18             	cmp    0x18(%ebp),%eax
    6f31:	0f 8c 54 fb ff ff    	jl     6a8b <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6f37:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6f3a:	c9                   	leave  
    6f3b:	c3                   	ret    

00006f3c <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6f3c:	55                   	push   %ebp
    6f3d:	89 e5                	mov    %esp,%ebp
    6f3f:	53                   	push   %ebx
    6f40:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6f43:	8b 45 10             	mov    0x10(%ebp),%eax
    6f46:	05 fe ff 00 00       	add    $0xfffe,%eax
    6f4b:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6f50:	f7 e2                	mul    %edx
    6f52:	89 d0                	mov    %edx,%eax
    6f54:	c1 e8 0f             	shr    $0xf,%eax
    6f57:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6f5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6f61:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6f68:	e9 1b 01 00 00       	jmp    7088 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6f6d:	8b 45 08             	mov    0x8(%ebp),%eax
    6f70:	8b 40 04             	mov    0x4(%eax),%eax
    6f73:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6f76:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6f79:	83 e8 01             	sub    $0x1,%eax
    6f7c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6f7f:	0f 94 c0             	sete   %al
    6f82:	0f b6 c0             	movzbl %al,%eax
    6f85:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6f88:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6f8f:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6f96:	8b 45 10             	mov    0x10(%ebp),%eax
    6f99:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6f9c:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6fa1:	77 09                	ja     6fac <deflateNoCompression+0x70>
    6fa3:	8b 45 10             	mov    0x10(%ebp),%eax
    6fa6:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6fa9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6fac:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6fb1:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6fb4:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6fb7:	8b 45 08             	mov    0x8(%ebp),%eax
    6fba:	8b 40 04             	mov    0x4(%eax),%eax
    6fbd:	89 c2                	mov    %eax,%edx
    6fbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6fc2:	01 d0                	add    %edx,%eax
    6fc4:	83 c0 05             	add    $0x5,%eax
    6fc7:	50                   	push   %eax
    6fc8:	ff 75 08             	pushl  0x8(%ebp)
    6fcb:	e8 62 c9 ff ff       	call   3932 <ucvector_resize>
    6fd0:	83 c4 08             	add    $0x8,%esp
    6fd3:	85 c0                	test   %eax,%eax
    6fd5:	75 0a                	jne    6fe1 <deflateNoCompression+0xa5>
    6fd7:	b8 53 00 00 00       	mov    $0x53,%eax
    6fdc:	e9 b8 00 00 00       	jmp    7099 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6fe1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6fe4:	89 c2                	mov    %eax,%edx
    6fe6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6fe9:	83 e0 01             	and    $0x1,%eax
    6fec:	01 c0                	add    %eax,%eax
    6fee:	01 c2                	add    %eax,%edx
    6ff0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6ff3:	83 e0 02             	and    $0x2,%eax
    6ff6:	01 c0                	add    %eax,%eax
    6ff8:	01 d0                	add    %edx,%eax
    6ffa:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6ffd:	8b 45 08             	mov    0x8(%ebp),%eax
    7000:	8b 10                	mov    (%eax),%edx
    7002:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7005:	01 c2                	add    %eax,%edx
    7007:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    700b:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    700d:	8b 45 08             	mov    0x8(%ebp),%eax
    7010:	8b 00                	mov    (%eax),%eax
    7012:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7015:	83 c2 01             	add    $0x1,%edx
    7018:	01 d0                	add    %edx,%eax
    701a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    701d:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    701f:	8b 45 08             	mov    0x8(%ebp),%eax
    7022:	8b 00                	mov    (%eax),%eax
    7024:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7027:	83 c2 02             	add    $0x2,%edx
    702a:	01 d0                	add    %edx,%eax
    702c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    702f:	c1 ea 08             	shr    $0x8,%edx
    7032:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    7034:	8b 45 08             	mov    0x8(%ebp),%eax
    7037:	8b 00                	mov    (%eax),%eax
    7039:	8b 55 e8             	mov    -0x18(%ebp),%edx
    703c:	83 c2 03             	add    $0x3,%edx
    703f:	01 d0                	add    %edx,%eax
    7041:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7044:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    7046:	8b 45 08             	mov    0x8(%ebp),%eax
    7049:	8b 00                	mov    (%eax),%eax
    704b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    704e:	83 c2 04             	add    $0x4,%edx
    7051:	01 d0                	add    %edx,%eax
    7053:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7056:	c1 ea 08             	shr    $0x8,%edx
    7059:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    705b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    705e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    7061:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7064:	01 d1                	add    %edx,%ecx
    7066:	8b 55 08             	mov    0x8(%ebp),%edx
    7069:	8b 12                	mov    (%edx),%edx
    706b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    706e:	83 c3 05             	add    $0x5,%ebx
    7071:	01 da                	add    %ebx,%edx
    7073:	50                   	push   %eax
    7074:	51                   	push   %ecx
    7075:	52                   	push   %edx
    7076:	e8 9b c6 ff ff       	call   3716 <lodepng_memcpy>
    707b:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    707e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7081:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    7084:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    7088:	8b 45 f8             	mov    -0x8(%ebp),%eax
    708b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    708e:	0f 85 d9 fe ff ff    	jne    6f6d <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    7094:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7099:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    709c:	c9                   	leave  
    709d:	c3                   	ret    

0000709e <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    709e:	55                   	push   %ebp
    709f:	89 e5                	mov    %esp,%ebp
    70a1:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    70a4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    70ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    70b2:	e9 10 01 00 00       	jmp    71c7 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    70b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    70ba:	8b 00                	mov    (%eax),%eax
    70bc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    70bf:	c1 e2 02             	shl    $0x2,%edx
    70c2:	01 d0                	add    %edx,%eax
    70c4:	8b 00                	mov    (%eax),%eax
    70c6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    70c9:	8b 45 10             	mov    0x10(%ebp),%eax
    70cc:	8b 40 04             	mov    0x4(%eax),%eax
    70cf:	8b 55 f8             	mov    -0x8(%ebp),%edx
    70d2:	c1 e2 02             	shl    $0x2,%edx
    70d5:	01 d0                	add    %edx,%eax
    70d7:	8b 00                	mov    (%eax),%eax
    70d9:	89 c1                	mov    %eax,%ecx
    70db:	8b 45 10             	mov    0x10(%ebp),%eax
    70de:	8b 00                	mov    (%eax),%eax
    70e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    70e3:	c1 e2 02             	shl    $0x2,%edx
    70e6:	01 d0                	add    %edx,%eax
    70e8:	8b 00                	mov    (%eax),%eax
    70ea:	51                   	push   %ecx
    70eb:	50                   	push   %eax
    70ec:	ff 75 08             	pushl  0x8(%ebp)
    70ef:	e8 60 cc ff ff       	call   3d54 <writeBitsReversed>
    70f4:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    70f7:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    70fe:	0f 86 bf 00 00 00    	jbe    71c3 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    7104:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7107:	2d 01 01 00 00       	sub    $0x101,%eax
    710c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    710f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7112:	8b 04 85 00 a2 01 00 	mov    0x1a200(,%eax,4),%eax
    7119:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    711c:	8b 45 0c             	mov    0xc(%ebp),%eax
    711f:	8b 00                	mov    (%eax),%eax
    7121:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7125:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7128:	c1 e2 02             	shl    $0x2,%edx
    712b:	01 d0                	add    %edx,%eax
    712d:	8b 00                	mov    (%eax),%eax
    712f:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    7132:	8b 45 0c             	mov    0xc(%ebp),%eax
    7135:	8b 00                	mov    (%eax),%eax
    7137:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    713b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    713e:	c1 e2 02             	shl    $0x2,%edx
    7141:	01 d0                	add    %edx,%eax
    7143:	8b 00                	mov    (%eax),%eax
    7145:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    7148:	8b 45 e8             	mov    -0x18(%ebp),%eax
    714b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    714e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7151:	8b 04 85 00 a3 01 00 	mov    0x1a300(,%eax,4),%eax
    7158:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    715b:	8b 45 0c             	mov    0xc(%ebp),%eax
    715e:	8b 00                	mov    (%eax),%eax
    7160:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7164:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7167:	c1 e2 02             	shl    $0x2,%edx
    716a:	01 d0                	add    %edx,%eax
    716c:	8b 00                	mov    (%eax),%eax
    716e:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    7171:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7174:	50                   	push   %eax
    7175:	ff 75 ec             	pushl  -0x14(%ebp)
    7178:	ff 75 08             	pushl  0x8(%ebp)
    717b:	e8 40 ca ff ff       	call   3bc0 <writeBits>
    7180:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    7183:	8b 45 14             	mov    0x14(%ebp),%eax
    7186:	8b 40 04             	mov    0x4(%eax),%eax
    7189:	8b 55 e8             	mov    -0x18(%ebp),%edx
    718c:	c1 e2 02             	shl    $0x2,%edx
    718f:	01 d0                	add    %edx,%eax
    7191:	8b 00                	mov    (%eax),%eax
    7193:	89 c1                	mov    %eax,%ecx
    7195:	8b 45 14             	mov    0x14(%ebp),%eax
    7198:	8b 00                	mov    (%eax),%eax
    719a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    719d:	c1 e2 02             	shl    $0x2,%edx
    71a0:	01 d0                	add    %edx,%eax
    71a2:	8b 00                	mov    (%eax),%eax
    71a4:	51                   	push   %ecx
    71a5:	50                   	push   %eax
    71a6:	ff 75 08             	pushl  0x8(%ebp)
    71a9:	e8 a6 cb ff ff       	call   3d54 <writeBitsReversed>
    71ae:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    71b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    71b4:	50                   	push   %eax
    71b5:	ff 75 dc             	pushl  -0x24(%ebp)
    71b8:	ff 75 08             	pushl  0x8(%ebp)
    71bb:	e8 00 ca ff ff       	call   3bc0 <writeBits>
    71c0:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    71c3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    71c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    71ca:	8b 40 04             	mov    0x4(%eax),%eax
    71cd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    71d0:	0f 85 e1 fe ff ff    	jne    70b7 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    71d6:	90                   	nop
    71d7:	c9                   	leave  
    71d8:	c3                   	ret    

000071d9 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    71d9:	55                   	push   %ebp
    71da:	89 e5                	mov    %esp,%ebp
    71dc:	53                   	push   %ebx
    71dd:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    71e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    71ea:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    71f1:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    71f8:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    71ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    7206:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    720d:	8b 45 18             	mov    0x18(%ebp),%eax
    7210:	2b 45 14             	sub    0x14(%ebp),%eax
    7213:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    7216:	8b 45 20             	mov    0x20(%ebp),%eax
    7219:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    721c:	8d 45 90             	lea    -0x70(%ebp),%eax
    721f:	50                   	push   %eax
    7220:	e8 a4 c6 ff ff       	call   38c9 <uivector_init>
    7225:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    7228:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    722e:	50                   	push   %eax
    722f:	e8 98 d3 ff ff       	call   45cc <HuffmanTree_init>
    7234:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7237:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    723d:	50                   	push   %eax
    723e:	e8 89 d3 ff ff       	call   45cc <HuffmanTree_init>
    7243:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    7246:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    724c:	50                   	push   %eax
    724d:	e8 7a d3 ff ff       	call   45cc <HuffmanTree_init>
    7252:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    7255:	83 ec 0c             	sub    $0xc,%esp
    7258:	68 78 04 00 00       	push   $0x478
    725d:	e8 76 c4 ff ff       	call   36d8 <lodepng_malloc>
    7262:	83 c4 10             	add    $0x10,%esp
    7265:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    7268:	83 ec 0c             	sub    $0xc,%esp
    726b:	6a 78                	push   $0x78
    726d:	e8 66 c4 ff ff       	call   36d8 <lodepng_malloc>
    7272:	83 c4 10             	add    $0x10,%esp
    7275:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7278:	83 ec 0c             	sub    $0xc,%esp
    727b:	6a 4c                	push   $0x4c
    727d:	e8 56 c4 ff ff       	call   36d8 <lodepng_malloc>
    7282:	83 c4 10             	add    $0x10,%esp
    7285:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    7288:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    728c:	74 0c                	je     729a <deflateDynamic+0xc1>
    728e:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    7292:	74 06                	je     729a <deflateDynamic+0xc1>
    7294:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    7298:	75 07                	jne    72a1 <deflateDynamic+0xc8>
    729a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    72a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    72a5:	0f 85 f6 07 00 00    	jne    7aa1 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    72ab:	83 ec 04             	sub    $0x4,%esp
    72ae:	68 78 04 00 00       	push   $0x478
    72b3:	6a 00                	push   $0x0
    72b5:	ff 75 d4             	pushl  -0x2c(%ebp)
    72b8:	e8 8c c4 ff ff       	call   3749 <lodepng_memset>
    72bd:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    72c0:	83 ec 04             	sub    $0x4,%esp
    72c3:	6a 78                	push   $0x78
    72c5:	6a 00                	push   $0x0
    72c7:	ff 75 d0             	pushl  -0x30(%ebp)
    72ca:	e8 7a c4 ff ff       	call   3749 <lodepng_memset>
    72cf:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    72d2:	83 ec 04             	sub    $0x4,%esp
    72d5:	6a 4c                	push   $0x4c
    72d7:	6a 00                	push   $0x0
    72d9:	ff 75 cc             	pushl  -0x34(%ebp)
    72dc:	e8 68 c4 ff ff       	call   3749 <lodepng_memset>
    72e1:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    72e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    72e7:	8b 40 04             	mov    0x4(%eax),%eax
    72ea:	85 c0                	test   %eax,%eax
    72ec:	74 45                	je     7333 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    72ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
    72f1:	8b 58 14             	mov    0x14(%eax),%ebx
    72f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    72f7:	8b 48 10             	mov    0x10(%eax),%ecx
    72fa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    72fd:	8b 50 0c             	mov    0xc(%eax),%edx
    7300:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7303:	8b 40 08             	mov    0x8(%eax),%eax
    7306:	83 ec 0c             	sub    $0xc,%esp
    7309:	53                   	push   %ebx
    730a:	51                   	push   %ecx
    730b:	52                   	push   %edx
    730c:	50                   	push   %eax
    730d:	ff 75 18             	pushl  0x18(%ebp)
    7310:	ff 75 14             	pushl  0x14(%ebp)
    7313:	ff 75 10             	pushl  0x10(%ebp)
    7316:	ff 75 0c             	pushl  0xc(%ebp)
    7319:	8d 45 90             	lea    -0x70(%ebp),%eax
    731c:	50                   	push   %eax
    731d:	e8 bd f6 ff ff       	call   69df <encodeLZ77>
    7322:	83 c4 30             	add    $0x30,%esp
    7325:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    7328:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    732c:	74 59                	je     7387 <deflateDynamic+0x1ae>
    732e:	e9 6e 07 00 00       	jmp    7aa1 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    7333:	83 ec 08             	sub    $0x8,%esp
    7336:	ff 75 c8             	pushl  -0x38(%ebp)
    7339:	8d 45 90             	lea    -0x70(%ebp),%eax
    733c:	50                   	push   %eax
    733d:	e8 17 c5 ff ff       	call   3859 <uivector_resize>
    7342:	83 c4 10             	add    $0x10,%esp
    7345:	85 c0                	test   %eax,%eax
    7347:	75 0c                	jne    7355 <deflateDynamic+0x17c>
    7349:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7350:	e9 4c 07 00 00       	jmp    7aa1 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    7355:	8b 45 14             	mov    0x14(%ebp),%eax
    7358:	89 45 e8             	mov    %eax,-0x18(%ebp)
    735b:	eb 22                	jmp    737f <deflateDynamic+0x1a6>
    735d:	8b 55 90             	mov    -0x70(%ebp),%edx
    7360:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7363:	2b 45 14             	sub    0x14(%ebp),%eax
    7366:	c1 e0 02             	shl    $0x2,%eax
    7369:	01 c2                	add    %eax,%edx
    736b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    736e:	8b 45 10             	mov    0x10(%ebp),%eax
    7371:	01 c8                	add    %ecx,%eax
    7373:	0f b6 00             	movzbl (%eax),%eax
    7376:	0f b6 c0             	movzbl %al,%eax
    7379:	89 02                	mov    %eax,(%edx)
    737b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    737f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7382:	3b 45 18             	cmp    0x18(%ebp),%eax
    7385:	7c d6                	jl     735d <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7387:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    738e:	eb 60                	jmp    73f0 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    7390:	8b 45 90             	mov    -0x70(%ebp),%eax
    7393:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7396:	c1 e2 02             	shl    $0x2,%edx
    7399:	01 d0                	add    %edx,%eax
    739b:	8b 00                	mov    (%eax),%eax
    739d:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    73a0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    73a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    73ad:	01 d0                	add    %edx,%eax
    73af:	8b 10                	mov    (%eax),%edx
    73b1:	83 c2 01             	add    $0x1,%edx
    73b4:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    73b6:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    73bd:	76 2d                	jbe    73ec <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    73bf:	8b 45 90             	mov    -0x70(%ebp),%eax
    73c2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    73c5:	83 c2 02             	add    $0x2,%edx
    73c8:	c1 e2 02             	shl    $0x2,%edx
    73cb:	01 d0                	add    %edx,%eax
    73cd:	8b 00                	mov    (%eax),%eax
    73cf:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    73d2:	8b 45 bc             	mov    -0x44(%ebp),%eax
    73d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73dc:	8b 45 d0             	mov    -0x30(%ebp),%eax
    73df:	01 d0                	add    %edx,%eax
    73e1:	8b 10                	mov    (%eax),%edx
    73e3:	83 c2 01             	add    $0x1,%edx
    73e6:	89 10                	mov    %edx,(%eax)
        i += 3;
    73e8:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    73ec:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    73f0:	8b 45 94             	mov    -0x6c(%ebp),%eax
    73f3:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    73f6:	75 98                	jne    7390 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    73f8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    73fb:	05 00 04 00 00       	add    $0x400,%eax
    7400:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    7406:	83 ec 0c             	sub    $0xc,%esp
    7409:	6a 0f                	push   $0xf
    740b:	68 1e 01 00 00       	push   $0x11e
    7410:	68 01 01 00 00       	push   $0x101
    7415:	ff 75 d4             	pushl  -0x2c(%ebp)
    7418:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    741e:	50                   	push   %eax
    741f:	e8 e0 e1 ff ff       	call   5604 <HuffmanTree_makeFromFrequencies>
    7424:	83 c4 20             	add    $0x20,%esp
    7427:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    742a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    742e:	0f 85 66 06 00 00    	jne    7a9a <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7434:	83 ec 0c             	sub    $0xc,%esp
    7437:	6a 0f                	push   $0xf
    7439:	6a 1e                	push   $0x1e
    743b:	6a 02                	push   $0x2
    743d:	ff 75 d0             	pushl  -0x30(%ebp)
    7440:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7446:	50                   	push   %eax
    7447:	e8 b8 e1 ff ff       	call   5604 <HuffmanTree_makeFromFrequencies>
    744c:	83 c4 20             	add    $0x20,%esp
    744f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7452:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7456:	0f 85 41 06 00 00    	jne    7a9d <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    745c:	8b 45 84             	mov    -0x7c(%ebp),%eax
    745f:	ba 1e 01 00 00       	mov    $0x11e,%edx
    7464:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    7469:	0f 47 c2             	cmova  %edx,%eax
    746c:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    746f:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    7475:	ba 1e 00 00 00       	mov    $0x1e,%edx
    747a:	83 f8 1e             	cmp    $0x1e,%eax
    747d:	0f 47 c2             	cmova  %edx,%eax
    7480:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    7483:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7486:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7489:	01 d0                	add    %edx,%eax
    748b:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    748e:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7491:	c1 e0 02             	shl    $0x2,%eax
    7494:	83 ec 0c             	sub    $0xc,%esp
    7497:	50                   	push   %eax
    7498:	e8 3b c2 ff ff       	call   36d8 <lodepng_malloc>
    749d:	83 c4 10             	add    $0x10,%esp
    74a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    74a3:	8b 45 b0             	mov    -0x50(%ebp),%eax
    74a6:	c1 e0 02             	shl    $0x2,%eax
    74a9:	83 ec 0c             	sub    $0xc,%esp
    74ac:	50                   	push   %eax
    74ad:	e8 26 c2 ff ff       	call   36d8 <lodepng_malloc>
    74b2:	83 c4 10             	add    $0x10,%esp
    74b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    74b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    74bc:	74 06                	je     74c4 <deflateDynamic+0x2eb>
    74be:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    74c2:	75 0c                	jne    74d0 <deflateDynamic+0x2f7>
    74c4:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    74cb:	e9 d1 05 00 00       	jmp    7aa1 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    74d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    74d7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    74de:	eb 25                	jmp    7505 <deflateDynamic+0x32c>
    74e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74e3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74ed:	01 c2                	add    %eax,%edx
    74ef:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    74f5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    74f8:	c1 e1 02             	shl    $0x2,%ecx
    74fb:	01 c8                	add    %ecx,%eax
    74fd:	8b 00                	mov    (%eax),%eax
    74ff:	89 02                	mov    %eax,(%edx)
    7501:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7505:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7508:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    750b:	75 d3                	jne    74e0 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    750d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7514:	eb 2a                	jmp    7540 <deflateDynamic+0x367>
    7516:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7519:	8b 45 e8             	mov    -0x18(%ebp),%eax
    751c:	01 d0                	add    %edx,%eax
    751e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7525:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7528:	01 c2                	add    %eax,%edx
    752a:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    7530:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7533:	c1 e1 02             	shl    $0x2,%ecx
    7536:	01 c8                	add    %ecx,%eax
    7538:	8b 00                	mov    (%eax),%eax
    753a:	89 02                	mov    %eax,(%edx)
    753c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7540:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7543:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7546:	75 ce                	jne    7516 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7548:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    754f:	e9 3b 02 00 00       	jmp    778f <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    7554:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    755b:	eb 04                	jmp    7561 <deflateDynamic+0x388>
    755d:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    7561:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7564:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7567:	01 d0                	add    %edx,%eax
    7569:	8d 50 01             	lea    0x1(%eax),%edx
    756c:	8b 45 b0             	mov    -0x50(%ebp),%eax
    756f:	39 c2                	cmp    %eax,%edx
    7571:	73 2e                	jae    75a1 <deflateDynamic+0x3c8>
    7573:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7576:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7579:	01 d0                	add    %edx,%eax
    757b:	83 c0 01             	add    $0x1,%eax
    757e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7585:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7588:	01 d0                	add    %edx,%eax
    758a:	8b 10                	mov    (%eax),%edx
    758c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    758f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7596:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7599:	01 c8                	add    %ecx,%eax
    759b:	8b 00                	mov    (%eax),%eax
    759d:	39 c2                	cmp    %eax,%edx
    759f:	74 bc                	je     755d <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    75a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    75ae:	01 d0                	add    %edx,%eax
    75b0:	8b 00                	mov    (%eax),%eax
    75b2:	85 c0                	test   %eax,%eax
    75b4:	0f 85 a9 00 00 00    	jne    7663 <deflateDynamic+0x48a>
    75ba:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    75be:	0f 86 9f 00 00 00    	jbe    7663 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    75c4:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    75c8:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    75cc:	77 3a                	ja     7608 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    75ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    75d1:	8d 50 01             	lea    0x1(%eax),%edx
    75d4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    75d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75de:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75e1:	01 d0                	add    %edx,%eax
    75e3:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    75e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    75ec:	8d 50 01             	lea    0x1(%eax),%edx
    75ef:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    75f2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75fc:	01 d0                	add    %edx,%eax
    75fe:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7601:	83 ea 03             	sub    $0x3,%edx
    7604:	89 10                	mov    %edx,(%eax)
    7606:	eb 48                	jmp    7650 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7608:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    760f:	76 07                	jbe    7618 <deflateDynamic+0x43f>
    7611:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7618:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    761b:	8d 50 01             	lea    0x1(%eax),%edx
    761e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7621:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7628:	8b 45 ec             	mov    -0x14(%ebp),%eax
    762b:	01 d0                	add    %edx,%eax
    762d:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    7633:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7636:	8d 50 01             	lea    0x1(%eax),%edx
    7639:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    763c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7643:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7646:	01 d0                	add    %edx,%eax
    7648:	8b 55 dc             	mov    -0x24(%ebp),%edx
    764b:	83 ea 0b             	sub    $0xb,%edx
    764e:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    7650:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7653:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7656:	01 d0                	add    %edx,%eax
    7658:	83 e8 01             	sub    $0x1,%eax
    765b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    765e:	e9 28 01 00 00       	jmp    778b <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    7663:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    7667:	0f 86 f6 00 00 00    	jbe    7763 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    766d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7670:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7675:	f7 e2                	mul    %edx
    7677:	89 d0                	mov    %edx,%eax
    7679:	c1 e8 02             	shr    $0x2,%eax
    767c:	89 45 ac             	mov    %eax,-0x54(%ebp)
    767f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7682:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7687:	89 c8                	mov    %ecx,%eax
    7689:	f7 e2                	mul    %edx
    768b:	c1 ea 02             	shr    $0x2,%edx
    768e:	89 d0                	mov    %edx,%eax
    7690:	01 c0                	add    %eax,%eax
    7692:	01 d0                	add    %edx,%eax
    7694:	01 c0                	add    %eax,%eax
    7696:	29 c1                	sub    %eax,%ecx
    7698:	89 c8                	mov    %ecx,%eax
    769a:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    769d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    76a0:	8d 50 01             	lea    0x1(%eax),%edx
    76a3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    76a6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76b0:	01 c2                	add    %eax,%edx
    76b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76b5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    76bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    76bf:	01 c8                	add    %ecx,%eax
    76c1:	8b 00                	mov    (%eax),%eax
    76c3:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    76c5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    76cc:	eb 3a                	jmp    7708 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    76ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    76d1:	8d 50 01             	lea    0x1(%eax),%edx
    76d4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    76d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76de:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76e1:	01 d0                	add    %edx,%eax
    76e3:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    76e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    76ec:	8d 50 01             	lea    0x1(%eax),%edx
    76ef:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    76f2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76fc:	01 d0                	add    %edx,%eax
    76fe:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    7704:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7708:	8b 45 d8             	mov    -0x28(%ebp),%eax
    770b:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    770e:	72 be                	jb     76ce <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    7710:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    7714:	76 3a                	jbe    7750 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7716:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7719:	8d 50 01             	lea    0x1(%eax),%edx
    771c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    771f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7726:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7729:	01 d0                	add    %edx,%eax
    772b:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    7731:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7734:	8d 50 01             	lea    0x1(%eax),%edx
    7737:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    773a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7741:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7744:	01 d0                	add    %edx,%eax
    7746:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7749:	83 ea 03             	sub    $0x3,%edx
    774c:	89 10                	mov    %edx,(%eax)
    774e:	eb 06                	jmp    7756 <deflateDynamic+0x57d>
        }
        else j -= rest;
    7750:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7753:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7756:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7759:	8b 45 dc             	mov    -0x24(%ebp),%eax
    775c:	01 d0                	add    %edx,%eax
    775e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7761:	eb 28                	jmp    778b <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7763:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7766:	8d 50 01             	lea    0x1(%eax),%edx
    7769:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    776c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7773:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7776:	01 c2                	add    %eax,%edx
    7778:	8b 45 e8             	mov    -0x18(%ebp),%eax
    777b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7782:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7785:	01 c8                	add    %ecx,%eax
    7787:	8b 00                	mov    (%eax),%eax
    7789:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    778b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    778f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7792:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    7795:	0f 85 b9 fd ff ff    	jne    7554 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    779b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    77a2:	eb 42                	jmp    77e6 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    77a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    77a7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    77ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    77b1:	01 d0                	add    %edx,%eax
    77b3:	8b 00                	mov    (%eax),%eax
    77b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    77bc:	8b 45 cc             	mov    -0x34(%ebp),%eax
    77bf:	01 d0                	add    %edx,%eax
    77c1:	8b 10                	mov    (%eax),%edx
    77c3:	83 c2 01             	add    $0x1,%edx
    77c6:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    77c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    77cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    77d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    77d5:	01 d0                	add    %edx,%eax
    77d7:	8b 00                	mov    (%eax),%eax
    77d9:	83 f8 0f             	cmp    $0xf,%eax
    77dc:	76 04                	jbe    77e2 <deflateDynamic+0x609>
    77de:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    77e2:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    77e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    77e9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    77ec:	75 b6                	jne    77a4 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    77ee:	83 ec 0c             	sub    $0xc,%esp
    77f1:	6a 07                	push   $0x7
    77f3:	6a 13                	push   $0x13
    77f5:	6a 13                	push   $0x13
    77f7:	ff 75 cc             	pushl  -0x34(%ebp)
    77fa:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7800:	50                   	push   %eax
    7801:	e8 fe dd ff ff       	call   5604 <HuffmanTree_makeFromFrequencies>
    7806:	83 c4 20             	add    $0x20,%esp
    7809:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    780c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7810:	0f 85 8a 02 00 00    	jne    7aa0 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7816:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    781d:	eb 04                	jmp    7823 <deflateDynamic+0x64a>
      numcodes_cl--;
    781f:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7823:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7826:	83 f8 04             	cmp    $0x4,%eax
    7829:	76 1e                	jbe    7849 <deflateDynamic+0x670>
    782b:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7831:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7834:	83 ea 01             	sub    $0x1,%edx
    7837:	8b 14 95 80 a3 01 00 	mov    0x1a380(,%edx,4),%edx
    783e:	c1 e2 02             	shl    $0x2,%edx
    7841:	01 d0                	add    %edx,%eax
    7843:	8b 00                	mov    (%eax),%eax
    7845:	85 c0                	test   %eax,%eax
    7847:	74 d6                	je     781f <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7849:	83 ec 04             	sub    $0x4,%esp
    784c:	6a 01                	push   $0x1
    784e:	ff 75 c4             	pushl  -0x3c(%ebp)
    7851:	ff 75 08             	pushl  0x8(%ebp)
    7854:	e8 67 c3 ff ff       	call   3bc0 <writeBits>
    7859:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    785c:	83 ec 04             	sub    $0x4,%esp
    785f:	6a 01                	push   $0x1
    7861:	6a 00                	push   $0x0
    7863:	ff 75 08             	pushl  0x8(%ebp)
    7866:	e8 55 c3 ff ff       	call   3bc0 <writeBits>
    786b:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    786e:	83 ec 04             	sub    $0x4,%esp
    7871:	6a 01                	push   $0x1
    7873:	6a 01                	push   $0x1
    7875:	ff 75 08             	pushl  0x8(%ebp)
    7878:	e8 43 c3 ff ff       	call   3bc0 <writeBits>
    787d:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    7880:	8b 45 b8             	mov    -0x48(%ebp),%eax
    7883:	2d 01 01 00 00       	sub    $0x101,%eax
    7888:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    788b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    788e:	83 e8 01             	sub    $0x1,%eax
    7891:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    7894:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7897:	83 e8 04             	sub    $0x4,%eax
    789a:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    789d:	83 ec 04             	sub    $0x4,%esp
    78a0:	6a 05                	push   $0x5
    78a2:	ff 75 a4             	pushl  -0x5c(%ebp)
    78a5:	ff 75 08             	pushl  0x8(%ebp)
    78a8:	e8 13 c3 ff ff       	call   3bc0 <writeBits>
    78ad:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    78b0:	83 ec 04             	sub    $0x4,%esp
    78b3:	6a 05                	push   $0x5
    78b5:	ff 75 a0             	pushl  -0x60(%ebp)
    78b8:	ff 75 08             	pushl  0x8(%ebp)
    78bb:	e8 00 c3 ff ff       	call   3bc0 <writeBits>
    78c0:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    78c3:	83 ec 04             	sub    $0x4,%esp
    78c6:	6a 04                	push   $0x4
    78c8:	ff 75 9c             	pushl  -0x64(%ebp)
    78cb:	ff 75 08             	pushl  0x8(%ebp)
    78ce:	e8 ed c2 ff ff       	call   3bc0 <writeBits>
    78d3:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    78d6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    78dd:	eb 2c                	jmp    790b <deflateDynamic+0x732>
    78df:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    78e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78e8:	8b 04 85 80 a3 01 00 	mov    0x1a380(,%eax,4),%eax
    78ef:	c1 e0 02             	shl    $0x2,%eax
    78f2:	01 d0                	add    %edx,%eax
    78f4:	8b 00                	mov    (%eax),%eax
    78f6:	83 ec 04             	sub    $0x4,%esp
    78f9:	6a 03                	push   $0x3
    78fb:	50                   	push   %eax
    78fc:	ff 75 08             	pushl  0x8(%ebp)
    78ff:	e8 bc c2 ff ff       	call   3bc0 <writeBits>
    7904:	83 c4 10             	add    $0x10,%esp
    7907:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    790b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    790e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    7911:	75 cc                	jne    78df <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7913:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    791a:	e9 0a 01 00 00       	jmp    7a29 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    791f:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7925:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7928:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    792f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7932:	01 ca                	add    %ecx,%edx
    7934:	8b 12                	mov    (%edx),%edx
    7936:	c1 e2 02             	shl    $0x2,%edx
    7939:	01 d0                	add    %edx,%eax
    793b:	8b 00                	mov    (%eax),%eax
    793d:	89 c3                	mov    %eax,%ebx
    793f:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7945:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7948:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    794f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7952:	01 ca                	add    %ecx,%edx
    7954:	8b 12                	mov    (%edx),%edx
    7956:	c1 e2 02             	shl    $0x2,%edx
    7959:	01 d0                	add    %edx,%eax
    795b:	8b 00                	mov    (%eax),%eax
    795d:	83 ec 04             	sub    $0x4,%esp
    7960:	53                   	push   %ebx
    7961:	50                   	push   %eax
    7962:	ff 75 08             	pushl  0x8(%ebp)
    7965:	e8 ea c3 ff ff       	call   3d54 <writeBitsReversed>
    796a:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    796d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7970:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7977:	8b 45 ec             	mov    -0x14(%ebp),%eax
    797a:	01 d0                	add    %edx,%eax
    797c:	8b 00                	mov    (%eax),%eax
    797e:	83 f8 10             	cmp    $0x10,%eax
    7981:	75 28                	jne    79ab <deflateDynamic+0x7d2>
    7983:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7987:	8b 45 e8             	mov    -0x18(%ebp),%eax
    798a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7991:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7994:	01 d0                	add    %edx,%eax
    7996:	8b 00                	mov    (%eax),%eax
    7998:	83 ec 04             	sub    $0x4,%esp
    799b:	6a 02                	push   $0x2
    799d:	50                   	push   %eax
    799e:	ff 75 08             	pushl  0x8(%ebp)
    79a1:	e8 1a c2 ff ff       	call   3bc0 <writeBits>
    79a6:	83 c4 10             	add    $0x10,%esp
    79a9:	eb 7a                	jmp    7a25 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    79ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    79ae:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    79b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79b8:	01 d0                	add    %edx,%eax
    79ba:	8b 00                	mov    (%eax),%eax
    79bc:	83 f8 11             	cmp    $0x11,%eax
    79bf:	75 28                	jne    79e9 <deflateDynamic+0x810>
    79c1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    79c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    79c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    79cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79d2:	01 d0                	add    %edx,%eax
    79d4:	8b 00                	mov    (%eax),%eax
    79d6:	83 ec 04             	sub    $0x4,%esp
    79d9:	6a 03                	push   $0x3
    79db:	50                   	push   %eax
    79dc:	ff 75 08             	pushl  0x8(%ebp)
    79df:	e8 dc c1 ff ff       	call   3bc0 <writeBits>
    79e4:	83 c4 10             	add    $0x10,%esp
    79e7:	eb 3c                	jmp    7a25 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    79e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    79ec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    79f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79f6:	01 d0                	add    %edx,%eax
    79f8:	8b 00                	mov    (%eax),%eax
    79fa:	83 f8 12             	cmp    $0x12,%eax
    79fd:	75 26                	jne    7a25 <deflateDynamic+0x84c>
    79ff:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7a03:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a06:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7a0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a10:	01 d0                	add    %edx,%eax
    7a12:	8b 00                	mov    (%eax),%eax
    7a14:	83 ec 04             	sub    $0x4,%esp
    7a17:	6a 07                	push   $0x7
    7a19:	50                   	push   %eax
    7a1a:	ff 75 08             	pushl  0x8(%ebp)
    7a1d:	e8 9e c1 ff ff       	call   3bc0 <writeBits>
    7a22:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7a25:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7a29:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a2c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7a2f:	0f 85 ea fe ff ff    	jne    791f <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7a35:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7a3b:	50                   	push   %eax
    7a3c:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7a42:	50                   	push   %eax
    7a43:	8d 45 90             	lea    -0x70(%ebp),%eax
    7a46:	50                   	push   %eax
    7a47:	ff 75 08             	pushl  0x8(%ebp)
    7a4a:	e8 4f f6 ff ff       	call   709e <writeLZ77data>
    7a4f:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    7a52:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7a58:	05 00 04 00 00       	add    $0x400,%eax
    7a5d:	8b 00                	mov    (%eax),%eax
    7a5f:	85 c0                	test   %eax,%eax
    7a61:	75 09                	jne    7a6c <deflateDynamic+0x893>
    7a63:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7a6a:	eb 35                	jmp    7aa1 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    7a6c:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7a72:	05 00 04 00 00       	add    $0x400,%eax
    7a77:	8b 00                	mov    (%eax),%eax
    7a79:	89 c2                	mov    %eax,%edx
    7a7b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    7a81:	05 00 04 00 00       	add    $0x400,%eax
    7a86:	8b 00                	mov    (%eax),%eax
    7a88:	83 ec 04             	sub    $0x4,%esp
    7a8b:	52                   	push   %edx
    7a8c:	50                   	push   %eax
    7a8d:	ff 75 08             	pushl  0x8(%ebp)
    7a90:	e8 bf c2 ff ff       	call   3d54 <writeBitsReversed>
    7a95:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    7a98:	eb 07                	jmp    7aa1 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    7a9a:	90                   	nop
    7a9b:	eb 04                	jmp    7aa1 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    7a9d:	90                   	nop
    7a9e:	eb 01                	jmp    7aa1 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7aa0:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    7aa1:	83 ec 0c             	sub    $0xc,%esp
    7aa4:	8d 45 90             	lea    -0x70(%ebp),%eax
    7aa7:	50                   	push   %eax
    7aa8:	e8 73 bd ff ff       	call   3820 <uivector_cleanup>
    7aad:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    7ab0:	83 ec 0c             	sub    $0xc,%esp
    7ab3:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7ab9:	50                   	push   %eax
    7aba:	e8 3a cb ff ff       	call   45f9 <HuffmanTree_cleanup>
    7abf:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7ac2:	83 ec 0c             	sub    $0xc,%esp
    7ac5:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7acb:	50                   	push   %eax
    7acc:	e8 28 cb ff ff       	call   45f9 <HuffmanTree_cleanup>
    7ad1:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    7ad4:	83 ec 0c             	sub    $0xc,%esp
    7ad7:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7add:	50                   	push   %eax
    7ade:	e8 16 cb ff ff       	call   45f9 <HuffmanTree_cleanup>
    7ae3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    7ae6:	83 ec 0c             	sub    $0xc,%esp
    7ae9:	ff 75 d4             	pushl  -0x2c(%ebp)
    7aec:	e8 08 bc ff ff       	call   36f9 <lodepng_free>
    7af1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    7af4:	83 ec 0c             	sub    $0xc,%esp
    7af7:	ff 75 d0             	pushl  -0x30(%ebp)
    7afa:	e8 fa bb ff ff       	call   36f9 <lodepng_free>
    7aff:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    7b02:	83 ec 0c             	sub    $0xc,%esp
    7b05:	ff 75 cc             	pushl  -0x34(%ebp)
    7b08:	e8 ec bb ff ff       	call   36f9 <lodepng_free>
    7b0d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    7b10:	83 ec 0c             	sub    $0xc,%esp
    7b13:	ff 75 f0             	pushl  -0x10(%ebp)
    7b16:	e8 de bb ff ff       	call   36f9 <lodepng_free>
    7b1b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7b1e:	83 ec 0c             	sub    $0xc,%esp
    7b21:	ff 75 ec             	pushl  -0x14(%ebp)
    7b24:	e8 d0 bb ff ff       	call   36f9 <lodepng_free>
    7b29:	83 c4 10             	add    $0x10,%esp

  return error;
    7b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7b2f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7b32:	c9                   	leave  
    7b33:	c3                   	ret    

00007b34 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    7b34:	55                   	push   %ebp
    7b35:	89 e5                	mov    %esp,%ebp
    7b37:	53                   	push   %ebx
    7b38:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7b3b:	8b 45 20             	mov    0x20(%ebp),%eax
    7b3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    7b41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7b48:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7b4b:	50                   	push   %eax
    7b4c:	e8 7b ca ff ff       	call   45cc <HuffmanTree_init>
    7b51:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7b54:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b57:	50                   	push   %eax
    7b58:	e8 6f ca ff ff       	call   45cc <HuffmanTree_init>
    7b5d:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    7b60:	83 ec 0c             	sub    $0xc,%esp
    7b63:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7b66:	50                   	push   %eax
    7b67:	e8 41 db ff ff       	call   56ad <generateFixedLitLenTree>
    7b6c:	83 c4 10             	add    $0x10,%esp
    7b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    7b72:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b76:	75 12                	jne    7b8a <deflateFixed+0x56>
    7b78:	83 ec 0c             	sub    $0xc,%esp
    7b7b:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b7e:	50                   	push   %eax
    7b7f:	e8 30 dc ff ff       	call   57b4 <generateFixedDistanceTree>
    7b84:	83 c4 10             	add    $0x10,%esp
    7b87:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7b8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b8e:	0f 85 3a 01 00 00    	jne    7cce <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    7b94:	83 ec 04             	sub    $0x4,%esp
    7b97:	6a 01                	push   $0x1
    7b99:	ff 75 ec             	pushl  -0x14(%ebp)
    7b9c:	ff 75 08             	pushl  0x8(%ebp)
    7b9f:	e8 1c c0 ff ff       	call   3bc0 <writeBits>
    7ba4:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    7ba7:	83 ec 04             	sub    $0x4,%esp
    7baa:	6a 01                	push   $0x1
    7bac:	6a 01                	push   $0x1
    7bae:	ff 75 08             	pushl  0x8(%ebp)
    7bb1:	e8 0a c0 ff ff       	call   3bc0 <writeBits>
    7bb6:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7bb9:	83 ec 04             	sub    $0x4,%esp
    7bbc:	6a 01                	push   $0x1
    7bbe:	6a 00                	push   $0x0
    7bc0:	ff 75 08             	pushl  0x8(%ebp)
    7bc3:	e8 f8 bf ff ff       	call   3bc0 <writeBits>
    7bc8:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7bcb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7bce:	8b 40 04             	mov    0x4(%eax),%eax
    7bd1:	85 c0                	test   %eax,%eax
    7bd3:	74 77                	je     7c4c <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7bd5:	83 ec 0c             	sub    $0xc,%esp
    7bd8:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7bdb:	50                   	push   %eax
    7bdc:	e8 e8 bc ff ff       	call   38c9 <uivector_init>
    7be1:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7be4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7be7:	8b 58 14             	mov    0x14(%eax),%ebx
    7bea:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7bed:	8b 48 10             	mov    0x10(%eax),%ecx
    7bf0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7bf3:	8b 50 0c             	mov    0xc(%eax),%edx
    7bf6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7bf9:	8b 40 08             	mov    0x8(%eax),%eax
    7bfc:	83 ec 0c             	sub    $0xc,%esp
    7bff:	53                   	push   %ebx
    7c00:	51                   	push   %ecx
    7c01:	52                   	push   %edx
    7c02:	50                   	push   %eax
    7c03:	ff 75 18             	pushl  0x18(%ebp)
    7c06:	ff 75 14             	pushl  0x14(%ebp)
    7c09:	ff 75 10             	pushl  0x10(%ebp)
    7c0c:	ff 75 0c             	pushl  0xc(%ebp)
    7c0f:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7c12:	50                   	push   %eax
    7c13:	e8 c7 ed ff ff       	call   69df <encodeLZ77>
    7c18:	83 c4 30             	add    $0x30,%esp
    7c1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7c1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7c22:	75 17                	jne    7c3b <deflateFixed+0x107>
    7c24:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7c27:	50                   	push   %eax
    7c28:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7c2b:	50                   	push   %eax
    7c2c:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7c2f:	50                   	push   %eax
    7c30:	ff 75 08             	pushl  0x8(%ebp)
    7c33:	e8 66 f4 ff ff       	call   709e <writeLZ77data>
    7c38:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7c3b:	83 ec 0c             	sub    $0xc,%esp
    7c3e:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7c41:	50                   	push   %eax
    7c42:	e8 d9 bb ff ff       	call   3820 <uivector_cleanup>
    7c47:	83 c4 10             	add    $0x10,%esp
    7c4a:	eb 56                	jmp    7ca2 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7c4c:	8b 45 14             	mov    0x14(%ebp),%eax
    7c4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7c52:	eb 46                	jmp    7c9a <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    7c54:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7c57:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7c5a:	8b 55 10             	mov    0x10(%ebp),%edx
    7c5d:	01 ca                	add    %ecx,%edx
    7c5f:	0f b6 12             	movzbl (%edx),%edx
    7c62:	0f b6 d2             	movzbl %dl,%edx
    7c65:	c1 e2 02             	shl    $0x2,%edx
    7c68:	01 d0                	add    %edx,%eax
    7c6a:	8b 00                	mov    (%eax),%eax
    7c6c:	89 c3                	mov    %eax,%ebx
    7c6e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7c71:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7c74:	8b 55 10             	mov    0x10(%ebp),%edx
    7c77:	01 ca                	add    %ecx,%edx
    7c79:	0f b6 12             	movzbl (%edx),%edx
    7c7c:	0f b6 d2             	movzbl %dl,%edx
    7c7f:	c1 e2 02             	shl    $0x2,%edx
    7c82:	01 d0                	add    %edx,%eax
    7c84:	8b 00                	mov    (%eax),%eax
    7c86:	83 ec 04             	sub    $0x4,%esp
    7c89:	53                   	push   %ebx
    7c8a:	50                   	push   %eax
    7c8b:	ff 75 08             	pushl  0x8(%ebp)
    7c8e:	e8 c1 c0 ff ff       	call   3d54 <writeBitsReversed>
    7c93:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7c96:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7c9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7c9d:	3b 45 18             	cmp    0x18(%ebp),%eax
    7ca0:	7c b2                	jl     7c54 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    7ca2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ca6:	75 26                	jne    7cce <deflateFixed+0x19a>
    7ca8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7cab:	05 00 04 00 00       	add    $0x400,%eax
    7cb0:	8b 00                	mov    (%eax),%eax
    7cb2:	89 c2                	mov    %eax,%edx
    7cb4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7cb7:	05 00 04 00 00       	add    $0x400,%eax
    7cbc:	8b 00                	mov    (%eax),%eax
    7cbe:	83 ec 04             	sub    $0x4,%esp
    7cc1:	52                   	push   %edx
    7cc2:	50                   	push   %eax
    7cc3:	ff 75 08             	pushl  0x8(%ebp)
    7cc6:	e8 89 c0 ff ff       	call   3d54 <writeBitsReversed>
    7ccb:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    7cce:	83 ec 0c             	sub    $0xc,%esp
    7cd1:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7cd4:	50                   	push   %eax
    7cd5:	e8 1f c9 ff ff       	call   45f9 <HuffmanTree_cleanup>
    7cda:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7cdd:	83 ec 0c             	sub    $0xc,%esp
    7ce0:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7ce3:	50                   	push   %eax
    7ce4:	e8 10 c9 ff ff       	call   45f9 <HuffmanTree_cleanup>
    7ce9:	83 c4 10             	add    $0x10,%esp

  return error;
    7cec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7cef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7cf2:	c9                   	leave  
    7cf3:	c3                   	ret    

00007cf4 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    7cf4:	55                   	push   %ebp
    7cf5:	89 e5                	mov    %esp,%ebp
    7cf7:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7cfa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    7d01:	ff 75 08             	pushl  0x8(%ebp)
    7d04:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7d07:	50                   	push   %eax
    7d08:	e8 9e be ff ff       	call   3bab <LodePNGBitWriter_init>
    7d0d:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    7d10:	8b 45 14             	mov    0x14(%ebp),%eax
    7d13:	8b 00                	mov    (%eax),%eax
    7d15:	83 f8 02             	cmp    $0x2,%eax
    7d18:	76 0a                	jbe    7d24 <lodepng_deflatev+0x30>
    7d1a:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7d1f:	e9 68 01 00 00       	jmp    7e8c <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7d24:	8b 45 14             	mov    0x14(%ebp),%eax
    7d27:	8b 00                	mov    (%eax),%eax
    7d29:	85 c0                	test   %eax,%eax
    7d2b:	75 16                	jne    7d43 <lodepng_deflatev+0x4f>
    7d2d:	ff 75 10             	pushl  0x10(%ebp)
    7d30:	ff 75 0c             	pushl  0xc(%ebp)
    7d33:	ff 75 08             	pushl  0x8(%ebp)
    7d36:	e8 01 f2 ff ff       	call   6f3c <deflateNoCompression>
    7d3b:	83 c4 0c             	add    $0xc,%esp
    7d3e:	e9 49 01 00 00       	jmp    7e8c <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7d43:	8b 45 14             	mov    0x14(%ebp),%eax
    7d46:	8b 00                	mov    (%eax),%eax
    7d48:	83 f8 01             	cmp    $0x1,%eax
    7d4b:	75 08                	jne    7d55 <lodepng_deflatev+0x61>
    7d4d:	8b 45 10             	mov    0x10(%ebp),%eax
    7d50:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7d53:	eb 2c                	jmp    7d81 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7d55:	8b 45 10             	mov    0x10(%ebp),%eax
    7d58:	c1 e8 03             	shr    $0x3,%eax
    7d5b:	83 c0 08             	add    $0x8,%eax
    7d5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7d61:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    7d68:	7f 07                	jg     7d71 <lodepng_deflatev+0x7d>
    7d6a:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7d71:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    7d78:	7e 07                	jle    7d81 <lodepng_deflatev+0x8d>
    7d7a:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7d81:	8b 55 10             	mov    0x10(%ebp),%edx
    7d84:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7d87:	01 d0                	add    %edx,%eax
    7d89:	83 e8 01             	sub    $0x1,%eax
    7d8c:	99                   	cltd   
    7d8d:	f7 7d ec             	idivl  -0x14(%ebp)
    7d90:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7d93:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7d97:	75 07                	jne    7da0 <lodepng_deflatev+0xac>
    7d99:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7da0:	8b 45 14             	mov    0x14(%ebp),%eax
    7da3:	8b 40 08             	mov    0x8(%eax),%eax
    7da6:	83 ec 08             	sub    $0x8,%esp
    7da9:	50                   	push   %eax
    7daa:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7dad:	50                   	push   %eax
    7dae:	e8 1c e8 ff ff       	call   65cf <hash_init>
    7db3:	83 c4 10             	add    $0x10,%esp
    7db6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7db9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7dbd:	0f 85 b7 00 00 00    	jne    7e7a <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7dc3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7dca:	e9 99 00 00 00       	jmp    7e68 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7dcf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7dd2:	83 e8 01             	sub    $0x1,%eax
    7dd5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7dd8:	0f 94 c0             	sete   %al
    7ddb:	0f b6 c0             	movzbl %al,%eax
    7dde:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7de1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7de4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7de8:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7deb:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7dee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7df1:	01 d0                	add    %edx,%eax
    7df3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7df6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7df9:	3b 45 10             	cmp    0x10(%ebp),%eax
    7dfc:	7e 06                	jle    7e04 <lodepng_deflatev+0x110>
    7dfe:	8b 45 10             	mov    0x10(%ebp),%eax
    7e01:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7e04:	8b 45 14             	mov    0x14(%ebp),%eax
    7e07:	8b 00                	mov    (%eax),%eax
    7e09:	83 f8 01             	cmp    $0x1,%eax
    7e0c:	75 27                	jne    7e35 <lodepng_deflatev+0x141>
    7e0e:	83 ec 04             	sub    $0x4,%esp
    7e11:	ff 75 e0             	pushl  -0x20(%ebp)
    7e14:	ff 75 14             	pushl  0x14(%ebp)
    7e17:	ff 75 e4             	pushl  -0x1c(%ebp)
    7e1a:	ff 75 dc             	pushl  -0x24(%ebp)
    7e1d:	ff 75 0c             	pushl  0xc(%ebp)
    7e20:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7e23:	50                   	push   %eax
    7e24:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7e27:	50                   	push   %eax
    7e28:	e8 07 fd ff ff       	call   7b34 <deflateFixed>
    7e2d:	83 c4 20             	add    $0x20,%esp
    7e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7e33:	eb 2f                	jmp    7e64 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7e35:	8b 45 14             	mov    0x14(%ebp),%eax
    7e38:	8b 00                	mov    (%eax),%eax
    7e3a:	83 f8 02             	cmp    $0x2,%eax
    7e3d:	75 25                	jne    7e64 <lodepng_deflatev+0x170>
    7e3f:	83 ec 04             	sub    $0x4,%esp
    7e42:	ff 75 e0             	pushl  -0x20(%ebp)
    7e45:	ff 75 14             	pushl  0x14(%ebp)
    7e48:	ff 75 e4             	pushl  -0x1c(%ebp)
    7e4b:	ff 75 dc             	pushl  -0x24(%ebp)
    7e4e:	ff 75 0c             	pushl  0xc(%ebp)
    7e51:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7e54:	50                   	push   %eax
    7e55:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7e58:	50                   	push   %eax
    7e59:	e8 7b f3 ff ff       	call   71d9 <deflateDynamic>
    7e5e:	83 c4 20             	add    $0x20,%esp
    7e61:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7e64:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7e68:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7e6b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7e6e:	74 0a                	je     7e7a <lodepng_deflatev+0x186>
    7e70:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e74:	0f 84 55 ff ff ff    	je     7dcf <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7e7a:	83 ec 0c             	sub    $0xc,%esp
    7e7d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7e80:	50                   	push   %eax
    7e81:	e8 08 e9 ff ff       	call   678e <hash_cleanup>
    7e86:	83 c4 10             	add    $0x10,%esp

  return error;
    7e89:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7e8c:	c9                   	leave  
    7e8d:	c3                   	ret    

00007e8e <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7e8e:	55                   	push   %ebp
    7e8f:	89 e5                	mov    %esp,%ebp
    7e91:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7e94:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e97:	8b 08                	mov    (%eax),%ecx
    7e99:	8b 45 08             	mov    0x8(%ebp),%eax
    7e9c:	8b 10                	mov    (%eax),%edx
    7e9e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7ea1:	51                   	push   %ecx
    7ea2:	52                   	push   %edx
    7ea3:	50                   	push   %eax
    7ea4:	e8 f0 ba ff ff       	call   3999 <ucvector_init>
    7ea9:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7eac:	ff 75 18             	pushl  0x18(%ebp)
    7eaf:	ff 75 14             	pushl  0x14(%ebp)
    7eb2:	ff 75 10             	pushl  0x10(%ebp)
    7eb5:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7eb8:	50                   	push   %eax
    7eb9:	e8 36 fe ff ff       	call   7cf4 <lodepng_deflatev>
    7ebe:	83 c4 10             	add    $0x10,%esp
    7ec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7ec4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7ec7:	8b 45 08             	mov    0x8(%ebp),%eax
    7eca:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7ecc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7ecf:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ed2:	89 10                	mov    %edx,(%eax)
  return error;
    7ed4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ed7:	c9                   	leave  
    7ed8:	c3                   	ret    

00007ed9 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7ed9:	55                   	push   %ebp
    7eda:	89 e5                	mov    %esp,%ebp
    7edc:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7edf:	8b 45 18             	mov    0x18(%ebp),%eax
    7ee2:	8b 40 1c             	mov    0x1c(%eax),%eax
    7ee5:	85 c0                	test   %eax,%eax
    7ee7:	74 34                	je     7f1d <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7ee9:	8b 45 18             	mov    0x18(%ebp),%eax
    7eec:	8b 40 1c             	mov    0x1c(%eax),%eax
    7eef:	83 ec 0c             	sub    $0xc,%esp
    7ef2:	ff 75 18             	pushl  0x18(%ebp)
    7ef5:	ff 75 14             	pushl  0x14(%ebp)
    7ef8:	ff 75 10             	pushl  0x10(%ebp)
    7efb:	ff 75 0c             	pushl  0xc(%ebp)
    7efe:	ff 75 08             	pushl  0x8(%ebp)
    7f01:	ff d0                	call   *%eax
    7f03:	83 c4 20             	add    $0x20,%esp
    7f06:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7f09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7f0d:	74 07                	je     7f16 <deflate+0x3d>
    7f0f:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7f14:	eb 21                	jmp    7f37 <deflate+0x5e>
    7f16:	b8 00 00 00 00       	mov    $0x0,%eax
    7f1b:	eb 1a                	jmp    7f37 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7f1d:	83 ec 0c             	sub    $0xc,%esp
    7f20:	ff 75 18             	pushl  0x18(%ebp)
    7f23:	ff 75 14             	pushl  0x14(%ebp)
    7f26:	ff 75 10             	pushl  0x10(%ebp)
    7f29:	ff 75 0c             	pushl  0xc(%ebp)
    7f2c:	ff 75 08             	pushl  0x8(%ebp)
    7f2f:	e8 5a ff ff ff       	call   7e8e <lodepng_deflate>
    7f34:	83 c4 20             	add    $0x20,%esp
  }
}
    7f37:	c9                   	leave  
    7f38:	c3                   	ret    

00007f39 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7f39:	55                   	push   %ebp
    7f3a:	89 e5                	mov    %esp,%ebp
    7f3c:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7f3f:	8b 45 08             	mov    0x8(%ebp),%eax
    7f42:	0f b7 c0             	movzwl %ax,%eax
    7f45:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7f48:	8b 45 08             	mov    0x8(%ebp),%eax
    7f4b:	c1 e8 10             	shr    $0x10,%eax
    7f4e:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7f51:	e9 82 00 00 00       	jmp    7fd8 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7f56:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7f5b:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7f62:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7f66:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7f69:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7f6c:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7f6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7f76:	eb 1c                	jmp    7f94 <update_adler32+0x5b>
      s1 += (*data++);
    7f78:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f7b:	8d 50 01             	lea    0x1(%eax),%edx
    7f7e:	89 55 0c             	mov    %edx,0xc(%ebp)
    7f81:	0f b6 00             	movzbl (%eax),%eax
    7f84:	0f b6 c0             	movzbl %al,%eax
    7f87:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7f8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7f8d:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7f90:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7f94:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7f97:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7f9a:	75 dc                	jne    7f78 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7f9c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7f9f:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7fa4:	89 c8                	mov    %ecx,%eax
    7fa6:	f7 e2                	mul    %edx
    7fa8:	89 d0                	mov    %edx,%eax
    7faa:	c1 e8 0f             	shr    $0xf,%eax
    7fad:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7fb3:	29 c1                	sub    %eax,%ecx
    7fb5:	89 c8                	mov    %ecx,%eax
    7fb7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7fba:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7fbd:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7fc2:	89 c8                	mov    %ecx,%eax
    7fc4:	f7 e2                	mul    %edx
    7fc6:	89 d0                	mov    %edx,%eax
    7fc8:	c1 e8 0f             	shr    $0xf,%eax
    7fcb:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7fd1:	29 c1                	sub    %eax,%ecx
    7fd3:	89 c8                	mov    %ecx,%eax
    7fd5:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7fd8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7fdc:	0f 85 74 ff ff ff    	jne    7f56 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7fe2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7fe5:	c1 e0 10             	shl    $0x10,%eax
    7fe8:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7feb:	c9                   	leave  
    7fec:	c3                   	ret    

00007fed <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7fed:	55                   	push   %ebp
    7fee:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7ff0:	ff 75 0c             	pushl  0xc(%ebp)
    7ff3:	ff 75 08             	pushl  0x8(%ebp)
    7ff6:	6a 01                	push   $0x1
    7ff8:	e8 3c ff ff ff       	call   7f39 <update_adler32>
    7ffd:	83 c4 0c             	add    $0xc,%esp
}
    8000:	c9                   	leave  
    8001:	c3                   	ret    

00008002 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    8002:	55                   	push   %ebp
    8003:	89 e5                	mov    %esp,%ebp
    8005:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    8008:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    800f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    8013:	7f 0a                	jg     801f <lodepng_zlib_decompressv+0x1d>
    8015:	b8 35 00 00 00       	mov    $0x35,%eax
    801a:	e9 27 01 00 00       	jmp    8146 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    801f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8022:	0f b6 00             	movzbl (%eax),%eax
    8025:	0f b6 c0             	movzbl %al,%eax
    8028:	c1 e0 08             	shl    $0x8,%eax
    802b:	89 c2                	mov    %eax,%edx
    802d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8030:	83 c0 01             	add    $0x1,%eax
    8033:	0f b6 00             	movzbl (%eax),%eax
    8036:	0f b6 c0             	movzbl %al,%eax
    8039:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    803c:	ba 43 08 21 84       	mov    $0x84210843,%edx
    8041:	89 c8                	mov    %ecx,%eax
    8043:	f7 ea                	imul   %edx
    8045:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    8048:	c1 f8 04             	sar    $0x4,%eax
    804b:	89 c2                	mov    %eax,%edx
    804d:	89 c8                	mov    %ecx,%eax
    804f:	c1 f8 1f             	sar    $0x1f,%eax
    8052:	29 c2                	sub    %eax,%edx
    8054:	89 d0                	mov    %edx,%eax
    8056:	89 c2                	mov    %eax,%edx
    8058:	c1 e2 05             	shl    $0x5,%edx
    805b:	29 c2                	sub    %eax,%edx
    805d:	89 c8                	mov    %ecx,%eax
    805f:	29 d0                	sub    %edx,%eax
    8061:	85 c0                	test   %eax,%eax
    8063:	74 0a                	je     806f <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    8065:	b8 18 00 00 00       	mov    $0x18,%eax
    806a:	e9 d7 00 00 00       	jmp    8146 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    806f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8072:	0f b6 00             	movzbl (%eax),%eax
    8075:	0f b6 c0             	movzbl %al,%eax
    8078:	83 e0 0f             	and    $0xf,%eax
    807b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    807e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8081:	0f b6 00             	movzbl (%eax),%eax
    8084:	c0 e8 04             	shr    $0x4,%al
    8087:	0f b6 c0             	movzbl %al,%eax
    808a:	83 e0 0f             	and    $0xf,%eax
    808d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    8090:	8b 45 0c             	mov    0xc(%ebp),%eax
    8093:	83 c0 01             	add    $0x1,%eax
    8096:	0f b6 00             	movzbl (%eax),%eax
    8099:	c0 e8 05             	shr    $0x5,%al
    809c:	0f b6 c0             	movzbl %al,%eax
    809f:	83 e0 01             	and    $0x1,%eax
    80a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    80a5:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    80a9:	75 06                	jne    80b1 <lodepng_zlib_decompressv+0xaf>
    80ab:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    80af:	76 0a                	jbe    80bb <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    80b1:	b8 19 00 00 00       	mov    $0x19,%eax
    80b6:	e9 8b 00 00 00       	jmp    8146 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    80bb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    80bf:	74 07                	je     80c8 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    80c1:	b8 1a 00 00 00       	mov    $0x1a,%eax
    80c6:	eb 7e                	jmp    8146 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    80c8:	8b 45 10             	mov    0x10(%ebp),%eax
    80cb:	8d 50 fe             	lea    -0x2(%eax),%edx
    80ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    80d1:	83 c0 02             	add    $0x2,%eax
    80d4:	ff 75 14             	pushl  0x14(%ebp)
    80d7:	52                   	push   %edx
    80d8:	50                   	push   %eax
    80d9:	ff 75 08             	pushl  0x8(%ebp)
    80dc:	e8 09 e3 ff ff       	call   63ea <inflatev>
    80e1:	83 c4 10             	add    $0x10,%esp
    80e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    80e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    80eb:	74 05                	je     80f2 <lodepng_zlib_decompressv+0xf0>
    80ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    80f0:	eb 54                	jmp    8146 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    80f2:	8b 45 14             	mov    0x14(%ebp),%eax
    80f5:	8b 00                	mov    (%eax),%eax
    80f7:	85 c0                	test   %eax,%eax
    80f9:	75 46                	jne    8141 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    80fb:	8b 45 10             	mov    0x10(%ebp),%eax
    80fe:	8d 50 fc             	lea    -0x4(%eax),%edx
    8101:	8b 45 0c             	mov    0xc(%ebp),%eax
    8104:	01 d0                	add    %edx,%eax
    8106:	83 ec 0c             	sub    $0xc,%esp
    8109:	50                   	push   %eax
    810a:	e8 47 b9 ff ff       	call   3a56 <lodepng_read32bitInt>
    810f:	83 c4 10             	add    $0x10,%esp
    8112:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    8115:	8b 45 08             	mov    0x8(%ebp),%eax
    8118:	8b 40 04             	mov    0x4(%eax),%eax
    811b:	89 c2                	mov    %eax,%edx
    811d:	8b 45 08             	mov    0x8(%ebp),%eax
    8120:	8b 00                	mov    (%eax),%eax
    8122:	83 ec 08             	sub    $0x8,%esp
    8125:	52                   	push   %edx
    8126:	50                   	push   %eax
    8127:	e8 c1 fe ff ff       	call   7fed <adler32>
    812c:	83 c4 10             	add    $0x10,%esp
    812f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    8132:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8135:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8138:	74 07                	je     8141 <lodepng_zlib_decompressv+0x13f>
    813a:	b8 3a 00 00 00       	mov    $0x3a,%eax
    813f:	eb 05                	jmp    8146 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    8141:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8146:	c9                   	leave  
    8147:	c3                   	ret    

00008148 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    8148:	55                   	push   %ebp
    8149:	89 e5                	mov    %esp,%ebp
    814b:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    814e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8151:	8b 08                	mov    (%eax),%ecx
    8153:	8b 45 08             	mov    0x8(%ebp),%eax
    8156:	8b 10                	mov    (%eax),%edx
    8158:	8d 45 e8             	lea    -0x18(%ebp),%eax
    815b:	51                   	push   %ecx
    815c:	52                   	push   %edx
    815d:	50                   	push   %eax
    815e:	e8 36 b8 ff ff       	call   3999 <ucvector_init>
    8163:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8166:	ff 75 18             	pushl  0x18(%ebp)
    8169:	ff 75 14             	pushl  0x14(%ebp)
    816c:	ff 75 10             	pushl  0x10(%ebp)
    816f:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8172:	50                   	push   %eax
    8173:	e8 8a fe ff ff       	call   8002 <lodepng_zlib_decompressv>
    8178:	83 c4 10             	add    $0x10,%esp
    817b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    817e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8181:	8b 45 08             	mov    0x8(%ebp),%eax
    8184:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8186:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8189:	8b 45 0c             	mov    0xc(%ebp),%eax
    818c:	89 10                	mov    %edx,(%eax)
  return error;
    818e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8191:	c9                   	leave  
    8192:	c3                   	ret    

00008193 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    8193:	55                   	push   %ebp
    8194:	89 e5                	mov    %esp,%ebp
    8196:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    8199:	8b 45 1c             	mov    0x1c(%ebp),%eax
    819c:	8b 40 0c             	mov    0xc(%eax),%eax
    819f:	85 c0                	test   %eax,%eax
    81a1:	74 57                	je     81fa <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    81a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    81a6:	8b 40 0c             	mov    0xc(%eax),%eax
    81a9:	83 ec 0c             	sub    $0xc,%esp
    81ac:	ff 75 1c             	pushl  0x1c(%ebp)
    81af:	ff 75 18             	pushl  0x18(%ebp)
    81b2:	ff 75 14             	pushl  0x14(%ebp)
    81b5:	ff 75 0c             	pushl  0xc(%ebp)
    81b8:	ff 75 08             	pushl  0x8(%ebp)
    81bb:	ff d0                	call   *%eax
    81bd:	83 c4 20             	add    $0x20,%esp
    81c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    81c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    81c7:	0f 84 98 00 00 00    	je     8265 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    81cd:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    81d4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    81d7:	8b 40 08             	mov    0x8(%eax),%eax
    81da:	85 c0                	test   %eax,%eax
    81dc:	0f 84 83 00 00 00    	je     8265 <zlib_decompress+0xd2>
    81e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    81e5:	8b 10                	mov    (%eax),%edx
    81e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    81ea:	8b 40 08             	mov    0x8(%eax),%eax
    81ed:	39 c2                	cmp    %eax,%edx
    81ef:	7e 74                	jle    8265 <zlib_decompress+0xd2>
    81f1:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    81f8:	eb 6b                	jmp    8265 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    81fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    81fd:	8b 08                	mov    (%eax),%ecx
    81ff:	8b 45 08             	mov    0x8(%ebp),%eax
    8202:	8b 10                	mov    (%eax),%edx
    8204:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8207:	83 ec 04             	sub    $0x4,%esp
    820a:	51                   	push   %ecx
    820b:	52                   	push   %edx
    820c:	50                   	push   %eax
    820d:	e8 87 b7 ff ff       	call   3999 <ucvector_init>
    8212:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    8215:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8219:	74 22                	je     823d <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    821b:	8b 45 0c             	mov    0xc(%ebp),%eax
    821e:	8b 10                	mov    (%eax),%edx
    8220:	8b 45 10             	mov    0x10(%ebp),%eax
    8223:	01 d0                	add    %edx,%eax
    8225:	83 ec 08             	sub    $0x8,%esp
    8228:	50                   	push   %eax
    8229:	8d 45 e8             	lea    -0x18(%ebp),%eax
    822c:	50                   	push   %eax
    822d:	e8 00 b7 ff ff       	call   3932 <ucvector_resize>
    8232:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    8235:	8b 45 0c             	mov    0xc(%ebp),%eax
    8238:	8b 00                	mov    (%eax),%eax
    823a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    823d:	ff 75 1c             	pushl  0x1c(%ebp)
    8240:	ff 75 18             	pushl  0x18(%ebp)
    8243:	ff 75 14             	pushl  0x14(%ebp)
    8246:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8249:	50                   	push   %eax
    824a:	e8 b3 fd ff ff       	call   8002 <lodepng_zlib_decompressv>
    824f:	83 c4 10             	add    $0x10,%esp
    8252:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    8255:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8258:	8b 45 08             	mov    0x8(%ebp),%eax
    825b:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    825d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8260:	8b 45 0c             	mov    0xc(%ebp),%eax
    8263:	89 10                	mov    %edx,(%eax)
  }
  return error;
    8265:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8268:	c9                   	leave  
    8269:	c3                   	ret    

0000826a <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    826a:	55                   	push   %ebp
    826b:	89 e5                	mov    %esp,%ebp
    826d:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    8270:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    8277:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    827e:	83 ec 0c             	sub    $0xc,%esp
    8281:	ff 75 18             	pushl  0x18(%ebp)
    8284:	ff 75 14             	pushl  0x14(%ebp)
    8287:	ff 75 10             	pushl  0x10(%ebp)
    828a:	8d 45 d0             	lea    -0x30(%ebp),%eax
    828d:	50                   	push   %eax
    828e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8291:	50                   	push   %eax
    8292:	e8 42 fc ff ff       	call   7ed9 <deflate>
    8297:	83 c4 20             	add    $0x20,%esp
    829a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    829d:	8b 45 08             	mov    0x8(%ebp),%eax
    82a0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    82a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    82a9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    82af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    82b3:	75 33                	jne    82e8 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    82b5:	8b 45 d0             	mov    -0x30(%ebp),%eax
    82b8:	8d 50 06             	lea    0x6(%eax),%edx
    82bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    82be:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    82c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    82c3:	8b 00                	mov    (%eax),%eax
    82c5:	83 ec 0c             	sub    $0xc,%esp
    82c8:	50                   	push   %eax
    82c9:	e8 0a b4 ff ff       	call   36d8 <lodepng_malloc>
    82ce:	83 c4 10             	add    $0x10,%esp
    82d1:	89 c2                	mov    %eax,%edx
    82d3:	8b 45 08             	mov    0x8(%ebp),%eax
    82d6:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    82d8:	8b 45 08             	mov    0x8(%ebp),%eax
    82db:	8b 00                	mov    (%eax),%eax
    82dd:	85 c0                	test   %eax,%eax
    82df:	75 07                	jne    82e8 <lodepng_zlib_compress+0x7e>
    82e1:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    82e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    82ec:	0f 85 e2 00 00 00    	jne    83d4 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    82f2:	8b 45 14             	mov    0x14(%ebp),%eax
    82f5:	83 ec 08             	sub    $0x8,%esp
    82f8:	50                   	push   %eax
    82f9:	ff 75 10             	pushl  0x10(%ebp)
    82fc:	e8 ec fc ff ff       	call   7fed <adler32>
    8301:	83 c4 10             	add    $0x10,%esp
    8304:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    8307:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    830e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    8315:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    831c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    831f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8326:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8329:	01 d0                	add    %edx,%eax
    832b:	8d 14 00             	lea    (%eax,%eax,1),%edx
    832e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8331:	01 d0                	add    %edx,%eax
    8333:	c1 e0 05             	shl    $0x5,%eax
    8336:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    8339:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    833c:	ba 85 10 42 08       	mov    $0x8421085,%edx
    8341:	89 c8                	mov    %ecx,%eax
    8343:	f7 e2                	mul    %edx
    8345:	89 c8                	mov    %ecx,%eax
    8347:	29 d0                	sub    %edx,%eax
    8349:	d1 e8                	shr    %eax
    834b:	01 d0                	add    %edx,%eax
    834d:	c1 e8 04             	shr    $0x4,%eax
    8350:	89 c2                	mov    %eax,%edx
    8352:	c1 e2 05             	shl    $0x5,%edx
    8355:	29 c2                	sub    %eax,%edx
    8357:	89 c8                	mov    %ecx,%eax
    8359:	29 d0                	sub    %edx,%eax
    835b:	ba 1f 00 00 00       	mov    $0x1f,%edx
    8360:	29 c2                	sub    %eax,%edx
    8362:	89 d0                	mov    %edx,%eax
    8364:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    8367:	8b 45 d8             	mov    -0x28(%ebp),%eax
    836a:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    836d:	8b 45 08             	mov    0x8(%ebp),%eax
    8370:	8b 00                	mov    (%eax),%eax
    8372:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8375:	c1 ea 08             	shr    $0x8,%edx
    8378:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    837a:	8b 45 08             	mov    0x8(%ebp),%eax
    837d:	8b 00                	mov    (%eax),%eax
    837f:	83 c0 01             	add    $0x1,%eax
    8382:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8385:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    8387:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    838e:	eb 1e                	jmp    83ae <lodepng_zlib_compress+0x144>
    8390:	8b 45 08             	mov    0x8(%ebp),%eax
    8393:	8b 00                	mov    (%eax),%eax
    8395:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8398:	83 c2 02             	add    $0x2,%edx
    839b:	01 c2                	add    %eax,%edx
    839d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    83a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    83a3:	01 c8                	add    %ecx,%eax
    83a5:	0f b6 00             	movzbl (%eax),%eax
    83a8:	88 02                	mov    %al,(%edx)
    83aa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    83ae:	8b 45 d0             	mov    -0x30(%ebp),%eax
    83b1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    83b4:	75 da                	jne    8390 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    83b6:	8b 45 08             	mov    0x8(%ebp),%eax
    83b9:	8b 10                	mov    (%eax),%edx
    83bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    83be:	8b 00                	mov    (%eax),%eax
    83c0:	83 e8 04             	sub    $0x4,%eax
    83c3:	01 d0                	add    %edx,%eax
    83c5:	83 ec 08             	sub    $0x8,%esp
    83c8:	ff 75 ec             	pushl  -0x14(%ebp)
    83cb:	50                   	push   %eax
    83cc:	e8 c8 b6 ff ff       	call   3a99 <lodepng_set32bitInt>
    83d1:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    83d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    83d7:	83 ec 0c             	sub    $0xc,%esp
    83da:	50                   	push   %eax
    83db:	e8 19 b3 ff ff       	call   36f9 <lodepng_free>
    83e0:	83 c4 10             	add    $0x10,%esp
  return error;
    83e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    83e6:	c9                   	leave  
    83e7:	c3                   	ret    

000083e8 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    83e8:	55                   	push   %ebp
    83e9:	89 e5                	mov    %esp,%ebp
    83eb:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    83ee:	8b 45 18             	mov    0x18(%ebp),%eax
    83f1:	8b 40 18             	mov    0x18(%eax),%eax
    83f4:	85 c0                	test   %eax,%eax
    83f6:	74 34                	je     842c <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    83f8:	8b 45 18             	mov    0x18(%ebp),%eax
    83fb:	8b 40 18             	mov    0x18(%eax),%eax
    83fe:	83 ec 0c             	sub    $0xc,%esp
    8401:	ff 75 18             	pushl  0x18(%ebp)
    8404:	ff 75 14             	pushl  0x14(%ebp)
    8407:	ff 75 10             	pushl  0x10(%ebp)
    840a:	ff 75 0c             	pushl  0xc(%ebp)
    840d:	ff 75 08             	pushl  0x8(%ebp)
    8410:	ff d0                	call   *%eax
    8412:	83 c4 20             	add    $0x20,%esp
    8415:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8418:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    841c:	74 07                	je     8425 <zlib_compress+0x3d>
    841e:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8423:	eb 21                	jmp    8446 <zlib_compress+0x5e>
    8425:	b8 00 00 00 00       	mov    $0x0,%eax
    842a:	eb 1a                	jmp    8446 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    842c:	83 ec 0c             	sub    $0xc,%esp
    842f:	ff 75 18             	pushl  0x18(%ebp)
    8432:	ff 75 14             	pushl  0x14(%ebp)
    8435:	ff 75 10             	pushl  0x10(%ebp)
    8438:	ff 75 0c             	pushl  0xc(%ebp)
    843b:	ff 75 08             	pushl  0x8(%ebp)
    843e:	e8 27 fe ff ff       	call   826a <lodepng_zlib_compress>
    8443:	83 c4 20             	add    $0x20,%esp
  }
}
    8446:	c9                   	leave  
    8447:	c3                   	ret    

00008448 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8448:	55                   	push   %ebp
    8449:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    844b:	8b 45 08             	mov    0x8(%ebp),%eax
    844e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    8454:	8b 45 08             	mov    0x8(%ebp),%eax
    8457:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    845e:	8b 45 08             	mov    0x8(%ebp),%eax
    8461:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    8468:	8b 45 08             	mov    0x8(%ebp),%eax
    846b:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    8472:	8b 45 08             	mov    0x8(%ebp),%eax
    8475:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    847c:	8b 45 08             	mov    0x8(%ebp),%eax
    847f:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    8486:	8b 45 08             	mov    0x8(%ebp),%eax
    8489:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    8490:	8b 45 08             	mov    0x8(%ebp),%eax
    8493:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    849a:	8b 45 08             	mov    0x8(%ebp),%eax
    849d:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    84a4:	90                   	nop
    84a5:	5d                   	pop    %ebp
    84a6:	c3                   	ret    

000084a7 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    84a7:	55                   	push   %ebp
    84a8:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    84aa:	8b 45 08             	mov    0x8(%ebp),%eax
    84ad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    84b3:	8b 45 08             	mov    0x8(%ebp),%eax
    84b6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    84bd:	8b 45 08             	mov    0x8(%ebp),%eax
    84c0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    84c7:	8b 45 08             	mov    0x8(%ebp),%eax
    84ca:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    84d1:	8b 45 08             	mov    0x8(%ebp),%eax
    84d4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    84db:	8b 45 08             	mov    0x8(%ebp),%eax
    84de:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    84e5:	90                   	nop
    84e6:	5d                   	pop    %ebp
    84e7:	c3                   	ret    

000084e8 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    84e8:	55                   	push   %ebp
    84e9:	89 e5                	mov    %esp,%ebp
    84eb:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    84ee:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    84f5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    84fc:	eb 2a                	jmp    8528 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    84fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8501:	8b 45 08             	mov    0x8(%ebp),%eax
    8504:	01 d0                	add    %edx,%eax
    8506:	0f b6 00             	movzbl (%eax),%eax
    8509:	0f b6 c0             	movzbl %al,%eax
    850c:	33 45 fc             	xor    -0x4(%ebp),%eax
    850f:	0f b6 c0             	movzbl %al,%eax
    8512:	8b 04 85 c0 e5 01 00 	mov    0x1e5c0(,%eax,4),%eax
    8519:	8b 55 fc             	mov    -0x4(%ebp),%edx
    851c:	c1 ea 08             	shr    $0x8,%edx
    851f:	31 d0                	xor    %edx,%eax
    8521:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    8524:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8528:	8b 45 f8             	mov    -0x8(%ebp),%eax
    852b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    852e:	7c ce                	jl     84fe <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    8530:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8533:	f7 d0                	not    %eax
}
    8535:	c9                   	leave  
    8536:	c3                   	ret    

00008537 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8537:	55                   	push   %ebp
    8538:	89 e5                	mov    %esp,%ebp
    853a:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    853d:	8b 45 08             	mov    0x8(%ebp),%eax
    8540:	8b 00                	mov    (%eax),%eax
    8542:	c1 f8 03             	sar    $0x3,%eax
    8545:	89 c2                	mov    %eax,%edx
    8547:	8b 45 0c             	mov    0xc(%ebp),%eax
    854a:	01 d0                	add    %edx,%eax
    854c:	0f b6 00             	movzbl (%eax),%eax
    854f:	0f b6 d0             	movzbl %al,%edx
    8552:	8b 45 08             	mov    0x8(%ebp),%eax
    8555:	8b 00                	mov    (%eax),%eax
    8557:	f7 d0                	not    %eax
    8559:	83 e0 07             	and    $0x7,%eax
    855c:	89 c1                	mov    %eax,%ecx
    855e:	d3 fa                	sar    %cl,%edx
    8560:	89 d0                	mov    %edx,%eax
    8562:	83 e0 01             	and    $0x1,%eax
    8565:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    8568:	8b 45 08             	mov    0x8(%ebp),%eax
    856b:	8b 00                	mov    (%eax),%eax
    856d:	8d 50 01             	lea    0x1(%eax),%edx
    8570:	8b 45 08             	mov    0x8(%ebp),%eax
    8573:	89 10                	mov    %edx,(%eax)
  return result;
    8575:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    8579:	c9                   	leave  
    857a:	c3                   	ret    

0000857b <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    857b:	55                   	push   %ebp
    857c:	89 e5                	mov    %esp,%ebp
    857e:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    8581:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8588:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    858f:	eb 1b                	jmp    85ac <readBitsFromReversedStream+0x31>
    result <<= 1u;
    8591:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    8594:	ff 75 0c             	pushl  0xc(%ebp)
    8597:	ff 75 08             	pushl  0x8(%ebp)
    859a:	e8 98 ff ff ff       	call   8537 <readBitFromReversedStream>
    859f:	83 c4 08             	add    $0x8,%esp
    85a2:	0f b6 c0             	movzbl %al,%eax
    85a5:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    85a8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    85ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    85af:	3b 45 10             	cmp    0x10(%ebp),%eax
    85b2:	7c dd                	jl     8591 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    85b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    85b7:	c9                   	leave  
    85b8:	c3                   	ret    

000085b9 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    85b9:	55                   	push   %ebp
    85ba:	89 e5                	mov    %esp,%ebp
    85bc:	56                   	push   %esi
    85bd:	53                   	push   %ebx
    85be:	83 ec 04             	sub    $0x4,%esp
    85c1:	8b 45 10             	mov    0x10(%ebp),%eax
    85c4:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    85c7:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    85cb:	75 3e                	jne    860b <setBitOfReversedStream+0x52>
    85cd:	8b 45 08             	mov    0x8(%ebp),%eax
    85d0:	8b 00                	mov    (%eax),%eax
    85d2:	c1 f8 03             	sar    $0x3,%eax
    85d5:	89 c2                	mov    %eax,%edx
    85d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    85da:	01 c2                	add    %eax,%edx
    85dc:	8b 45 08             	mov    0x8(%ebp),%eax
    85df:	8b 00                	mov    (%eax),%eax
    85e1:	c1 f8 03             	sar    $0x3,%eax
    85e4:	89 c1                	mov    %eax,%ecx
    85e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    85e9:	01 c8                	add    %ecx,%eax
    85eb:	0f b6 18             	movzbl (%eax),%ebx
    85ee:	8b 45 08             	mov    0x8(%ebp),%eax
    85f1:	8b 00                	mov    (%eax),%eax
    85f3:	f7 d0                	not    %eax
    85f5:	83 e0 07             	and    $0x7,%eax
    85f8:	be 01 00 00 00       	mov    $0x1,%esi
    85fd:	89 c1                	mov    %eax,%ecx
    85ff:	d3 e6                	shl    %cl,%esi
    8601:	89 f0                	mov    %esi,%eax
    8603:	f7 d0                	not    %eax
    8605:	21 d8                	and    %ebx,%eax
    8607:	88 02                	mov    %al,(%edx)
    8609:	eb 3a                	jmp    8645 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    860b:	8b 45 08             	mov    0x8(%ebp),%eax
    860e:	8b 00                	mov    (%eax),%eax
    8610:	c1 f8 03             	sar    $0x3,%eax
    8613:	89 c2                	mov    %eax,%edx
    8615:	8b 45 0c             	mov    0xc(%ebp),%eax
    8618:	01 c2                	add    %eax,%edx
    861a:	8b 45 08             	mov    0x8(%ebp),%eax
    861d:	8b 00                	mov    (%eax),%eax
    861f:	c1 f8 03             	sar    $0x3,%eax
    8622:	89 c1                	mov    %eax,%ecx
    8624:	8b 45 0c             	mov    0xc(%ebp),%eax
    8627:	01 c8                	add    %ecx,%eax
    8629:	0f b6 18             	movzbl (%eax),%ebx
    862c:	8b 45 08             	mov    0x8(%ebp),%eax
    862f:	8b 00                	mov    (%eax),%eax
    8631:	f7 d0                	not    %eax
    8633:	83 e0 07             	and    $0x7,%eax
    8636:	be 01 00 00 00       	mov    $0x1,%esi
    863b:	89 c1                	mov    %eax,%ecx
    863d:	d3 e6                	shl    %cl,%esi
    863f:	89 f0                	mov    %esi,%eax
    8641:	09 d8                	or     %ebx,%eax
    8643:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8645:	8b 45 08             	mov    0x8(%ebp),%eax
    8648:	8b 00                	mov    (%eax),%eax
    864a:	8d 50 01             	lea    0x1(%eax),%edx
    864d:	8b 45 08             	mov    0x8(%ebp),%eax
    8650:	89 10                	mov    %edx,(%eax)
}
    8652:	90                   	nop
    8653:	83 c4 04             	add    $0x4,%esp
    8656:	5b                   	pop    %ebx
    8657:	5e                   	pop    %esi
    8658:	5d                   	pop    %ebp
    8659:	c3                   	ret    

0000865a <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    865a:	55                   	push   %ebp
    865b:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    865d:	ff 75 08             	pushl  0x8(%ebp)
    8660:	e8 f1 b3 ff ff       	call   3a56 <lodepng_read32bitInt>
    8665:	83 c4 04             	add    $0x4,%esp
}
    8668:	c9                   	leave  
    8669:	c3                   	ret    

0000866a <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    866a:	55                   	push   %ebp
    866b:	89 e5                	mov    %esp,%ebp
    866d:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    8670:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8677:	eb 1c                	jmp    8695 <lodepng_chunk_type+0x2b>
    8679:	8b 55 08             	mov    0x8(%ebp),%edx
    867c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    867f:	01 d0                	add    %edx,%eax
    8681:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8684:	8d 4a 04             	lea    0x4(%edx),%ecx
    8687:	8b 55 0c             	mov    0xc(%ebp),%edx
    868a:	01 ca                	add    %ecx,%edx
    868c:	0f b6 12             	movzbl (%edx),%edx
    868f:	88 10                	mov    %dl,(%eax)
    8691:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8695:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    8699:	75 de                	jne    8679 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    869b:	8b 45 08             	mov    0x8(%ebp),%eax
    869e:	83 c0 04             	add    $0x4,%eax
    86a1:	c6 00 00             	movb   $0x0,(%eax)
}
    86a4:	90                   	nop
    86a5:	c9                   	leave  
    86a6:	c3                   	ret    

000086a7 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    86a7:	55                   	push   %ebp
    86a8:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    86aa:	ff 75 0c             	pushl  0xc(%ebp)
    86ad:	e8 c2 b0 ff ff       	call   3774 <lodepng_strlen>
    86b2:	83 c4 04             	add    $0x4,%esp
    86b5:	83 f8 04             	cmp    $0x4,%eax
    86b8:	74 07                	je     86c1 <lodepng_chunk_type_equals+0x1a>
    86ba:	b8 00 00 00 00       	mov    $0x0,%eax
    86bf:	eb 79                	jmp    873a <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    86c1:	8b 45 08             	mov    0x8(%ebp),%eax
    86c4:	83 c0 04             	add    $0x4,%eax
    86c7:	0f b6 00             	movzbl (%eax),%eax
    86ca:	0f b6 d0             	movzbl %al,%edx
    86cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    86d0:	0f b6 00             	movzbl (%eax),%eax
    86d3:	0f be c0             	movsbl %al,%eax
    86d6:	39 c2                	cmp    %eax,%edx
    86d8:	75 5b                	jne    8735 <lodepng_chunk_type_equals+0x8e>
    86da:	8b 45 08             	mov    0x8(%ebp),%eax
    86dd:	83 c0 05             	add    $0x5,%eax
    86e0:	0f b6 00             	movzbl (%eax),%eax
    86e3:	0f b6 d0             	movzbl %al,%edx
    86e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    86e9:	83 c0 01             	add    $0x1,%eax
    86ec:	0f b6 00             	movzbl (%eax),%eax
    86ef:	0f be c0             	movsbl %al,%eax
    86f2:	39 c2                	cmp    %eax,%edx
    86f4:	75 3f                	jne    8735 <lodepng_chunk_type_equals+0x8e>
    86f6:	8b 45 08             	mov    0x8(%ebp),%eax
    86f9:	83 c0 06             	add    $0x6,%eax
    86fc:	0f b6 00             	movzbl (%eax),%eax
    86ff:	0f b6 d0             	movzbl %al,%edx
    8702:	8b 45 0c             	mov    0xc(%ebp),%eax
    8705:	83 c0 02             	add    $0x2,%eax
    8708:	0f b6 00             	movzbl (%eax),%eax
    870b:	0f be c0             	movsbl %al,%eax
    870e:	39 c2                	cmp    %eax,%edx
    8710:	75 23                	jne    8735 <lodepng_chunk_type_equals+0x8e>
    8712:	8b 45 08             	mov    0x8(%ebp),%eax
    8715:	83 c0 07             	add    $0x7,%eax
    8718:	0f b6 00             	movzbl (%eax),%eax
    871b:	0f b6 d0             	movzbl %al,%edx
    871e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8721:	83 c0 03             	add    $0x3,%eax
    8724:	0f b6 00             	movzbl (%eax),%eax
    8727:	0f be c0             	movsbl %al,%eax
    872a:	39 c2                	cmp    %eax,%edx
    872c:	75 07                	jne    8735 <lodepng_chunk_type_equals+0x8e>
    872e:	b8 01 00 00 00       	mov    $0x1,%eax
    8733:	eb 05                	jmp    873a <lodepng_chunk_type_equals+0x93>
    8735:	b8 00 00 00 00       	mov    $0x0,%eax
}
    873a:	c9                   	leave  
    873b:	c3                   	ret    

0000873c <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    873c:	55                   	push   %ebp
    873d:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    873f:	8b 45 08             	mov    0x8(%ebp),%eax
    8742:	83 c0 04             	add    $0x4,%eax
    8745:	0f b6 00             	movzbl (%eax),%eax
    8748:	0f b6 c0             	movzbl %al,%eax
    874b:	83 e0 20             	and    $0x20,%eax
    874e:	85 c0                	test   %eax,%eax
    8750:	0f 95 c0             	setne  %al
}
    8753:	5d                   	pop    %ebp
    8754:	c3                   	ret    

00008755 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    8755:	55                   	push   %ebp
    8756:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8758:	8b 45 08             	mov    0x8(%ebp),%eax
    875b:	83 c0 06             	add    $0x6,%eax
    875e:	0f b6 00             	movzbl (%eax),%eax
    8761:	0f b6 c0             	movzbl %al,%eax
    8764:	83 e0 20             	and    $0x20,%eax
    8767:	85 c0                	test   %eax,%eax
    8769:	0f 95 c0             	setne  %al
}
    876c:	5d                   	pop    %ebp
    876d:	c3                   	ret    

0000876e <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    876e:	55                   	push   %ebp
    876f:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    8771:	8b 45 08             	mov    0x8(%ebp),%eax
    8774:	83 c0 07             	add    $0x7,%eax
    8777:	0f b6 00             	movzbl (%eax),%eax
    877a:	0f b6 c0             	movzbl %al,%eax
    877d:	83 e0 20             	and    $0x20,%eax
    8780:	85 c0                	test   %eax,%eax
    8782:	0f 95 c0             	setne  %al
}
    8785:	5d                   	pop    %ebp
    8786:	c3                   	ret    

00008787 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    8787:	55                   	push   %ebp
    8788:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    878a:	8b 45 08             	mov    0x8(%ebp),%eax
    878d:	83 c0 08             	add    $0x8,%eax
}
    8790:	5d                   	pop    %ebp
    8791:	c3                   	ret    

00008792 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    8792:	55                   	push   %ebp
    8793:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8795:	8b 45 08             	mov    0x8(%ebp),%eax
    8798:	83 c0 08             	add    $0x8,%eax
}
    879b:	5d                   	pop    %ebp
    879c:	c3                   	ret    

0000879d <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    879d:	55                   	push   %ebp
    879e:	89 e5                	mov    %esp,%ebp
    87a0:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    87a3:	ff 75 08             	pushl  0x8(%ebp)
    87a6:	e8 af fe ff ff       	call   865a <lodepng_chunk_length>
    87ab:	83 c4 04             	add    $0x4,%esp
    87ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    87b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87b4:	8d 50 08             	lea    0x8(%eax),%edx
    87b7:	8b 45 08             	mov    0x8(%ebp),%eax
    87ba:	01 d0                	add    %edx,%eax
    87bc:	50                   	push   %eax
    87bd:	e8 94 b2 ff ff       	call   3a56 <lodepng_read32bitInt>
    87c2:	83 c4 04             	add    $0x4,%esp
    87c5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    87c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87cb:	83 c0 04             	add    $0x4,%eax
    87ce:	89 c2                	mov    %eax,%edx
    87d0:	8b 45 08             	mov    0x8(%ebp),%eax
    87d3:	83 c0 04             	add    $0x4,%eax
    87d6:	52                   	push   %edx
    87d7:	50                   	push   %eax
    87d8:	e8 0b fd ff ff       	call   84e8 <lodepng_crc32>
    87dd:	83 c4 08             	add    $0x8,%esp
    87e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    87e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    87e6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    87e9:	74 07                	je     87f2 <lodepng_chunk_check_crc+0x55>
    87eb:	b8 01 00 00 00       	mov    $0x1,%eax
    87f0:	eb 05                	jmp    87f7 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    87f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    87f7:	c9                   	leave  
    87f8:	c3                   	ret    

000087f9 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    87f9:	55                   	push   %ebp
    87fa:	89 e5                	mov    %esp,%ebp
    87fc:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    87ff:	ff 75 08             	pushl  0x8(%ebp)
    8802:	e8 53 fe ff ff       	call   865a <lodepng_chunk_length>
    8807:	83 c4 04             	add    $0x4,%esp
    880a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    880d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8810:	83 c0 04             	add    $0x4,%eax
    8813:	89 c2                	mov    %eax,%edx
    8815:	8b 45 08             	mov    0x8(%ebp),%eax
    8818:	83 c0 04             	add    $0x4,%eax
    881b:	52                   	push   %edx
    881c:	50                   	push   %eax
    881d:	e8 c6 fc ff ff       	call   84e8 <lodepng_crc32>
    8822:	83 c4 08             	add    $0x8,%esp
    8825:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8828:	8b 45 fc             	mov    -0x4(%ebp),%eax
    882b:	8d 50 08             	lea    0x8(%eax),%edx
    882e:	8b 45 08             	mov    0x8(%ebp),%eax
    8831:	01 d0                	add    %edx,%eax
    8833:	ff 75 f8             	pushl  -0x8(%ebp)
    8836:	50                   	push   %eax
    8837:	e8 5d b2 ff ff       	call   3a99 <lodepng_set32bitInt>
    883c:	83 c4 08             	add    $0x8,%esp
}
    883f:	90                   	nop
    8840:	c9                   	leave  
    8841:	c3                   	ret    

00008842 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    8842:	55                   	push   %ebp
    8843:	89 e5                	mov    %esp,%ebp
    8845:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8848:	8b 45 08             	mov    0x8(%ebp),%eax
    884b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    884e:	73 0f                	jae    885f <lodepng_chunk_next+0x1d>
    8850:	8b 55 0c             	mov    0xc(%ebp),%edx
    8853:	8b 45 08             	mov    0x8(%ebp),%eax
    8856:	29 c2                	sub    %eax,%edx
    8858:	89 d0                	mov    %edx,%eax
    885a:	83 f8 0b             	cmp    $0xb,%eax
    885d:	7f 08                	jg     8867 <lodepng_chunk_next+0x25>
    885f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8862:	e9 af 00 00 00       	jmp    8916 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8867:	8b 45 08             	mov    0x8(%ebp),%eax
    886a:	0f b6 00             	movzbl (%eax),%eax
    886d:	3c 89                	cmp    $0x89,%al
    886f:	75 63                	jne    88d4 <lodepng_chunk_next+0x92>
    8871:	8b 45 08             	mov    0x8(%ebp),%eax
    8874:	83 c0 01             	add    $0x1,%eax
    8877:	0f b6 00             	movzbl (%eax),%eax
    887a:	3c 50                	cmp    $0x50,%al
    887c:	75 56                	jne    88d4 <lodepng_chunk_next+0x92>
    887e:	8b 45 08             	mov    0x8(%ebp),%eax
    8881:	83 c0 02             	add    $0x2,%eax
    8884:	0f b6 00             	movzbl (%eax),%eax
    8887:	3c 4e                	cmp    $0x4e,%al
    8889:	75 49                	jne    88d4 <lodepng_chunk_next+0x92>
    888b:	8b 45 08             	mov    0x8(%ebp),%eax
    888e:	83 c0 03             	add    $0x3,%eax
    8891:	0f b6 00             	movzbl (%eax),%eax
    8894:	3c 47                	cmp    $0x47,%al
    8896:	75 3c                	jne    88d4 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8898:	8b 45 08             	mov    0x8(%ebp),%eax
    889b:	83 c0 04             	add    $0x4,%eax
    889e:	0f b6 00             	movzbl (%eax),%eax
    88a1:	3c 0d                	cmp    $0xd,%al
    88a3:	75 2f                	jne    88d4 <lodepng_chunk_next+0x92>
    88a5:	8b 45 08             	mov    0x8(%ebp),%eax
    88a8:	83 c0 05             	add    $0x5,%eax
    88ab:	0f b6 00             	movzbl (%eax),%eax
    88ae:	3c 0a                	cmp    $0xa,%al
    88b0:	75 22                	jne    88d4 <lodepng_chunk_next+0x92>
    88b2:	8b 45 08             	mov    0x8(%ebp),%eax
    88b5:	83 c0 06             	add    $0x6,%eax
    88b8:	0f b6 00             	movzbl (%eax),%eax
    88bb:	3c 1a                	cmp    $0x1a,%al
    88bd:	75 15                	jne    88d4 <lodepng_chunk_next+0x92>
    88bf:	8b 45 08             	mov    0x8(%ebp),%eax
    88c2:	83 c0 07             	add    $0x7,%eax
    88c5:	0f b6 00             	movzbl (%eax),%eax
    88c8:	3c 0a                	cmp    $0xa,%al
    88ca:	75 08                	jne    88d4 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    88cc:	8b 45 08             	mov    0x8(%ebp),%eax
    88cf:	83 c0 08             	add    $0x8,%eax
    88d2:	eb 42                	jmp    8916 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    88d4:	ff 75 08             	pushl  0x8(%ebp)
    88d7:	e8 7e fd ff ff       	call   865a <lodepng_chunk_length>
    88dc:	83 c4 04             	add    $0x4,%esp
    88df:	89 c2                	mov    %eax,%edx
    88e1:	8d 45 f8             	lea    -0x8(%ebp),%eax
    88e4:	50                   	push   %eax
    88e5:	6a 0c                	push   $0xc
    88e7:	52                   	push   %edx
    88e8:	e8 af ae ff ff       	call   379c <lodepng_addofl>
    88ed:	83 c4 0c             	add    $0xc,%esp
    88f0:	85 c0                	test   %eax,%eax
    88f2:	74 05                	je     88f9 <lodepng_chunk_next+0xb7>
    88f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    88f7:	eb 1d                	jmp    8916 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    88f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    88fc:	89 c2                	mov    %eax,%edx
    88fe:	8b 45 08             	mov    0x8(%ebp),%eax
    8901:	01 d0                	add    %edx,%eax
    8903:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8906:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8909:	3b 45 08             	cmp    0x8(%ebp),%eax
    890c:	73 05                	jae    8913 <lodepng_chunk_next+0xd1>
    890e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8911:	eb 03                	jmp    8916 <lodepng_chunk_next+0xd4>
    return result;
    8913:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8916:	c9                   	leave  
    8917:	c3                   	ret    

00008918 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8918:	55                   	push   %ebp
    8919:	89 e5                	mov    %esp,%ebp
    891b:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    891e:	8b 45 08             	mov    0x8(%ebp),%eax
    8921:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8924:	73 0f                	jae    8935 <lodepng_chunk_next_const+0x1d>
    8926:	8b 55 0c             	mov    0xc(%ebp),%edx
    8929:	8b 45 08             	mov    0x8(%ebp),%eax
    892c:	29 c2                	sub    %eax,%edx
    892e:	89 d0                	mov    %edx,%eax
    8930:	83 f8 0b             	cmp    $0xb,%eax
    8933:	7f 08                	jg     893d <lodepng_chunk_next_const+0x25>
    8935:	8b 45 0c             	mov    0xc(%ebp),%eax
    8938:	e9 af 00 00 00       	jmp    89ec <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    893d:	8b 45 08             	mov    0x8(%ebp),%eax
    8940:	0f b6 00             	movzbl (%eax),%eax
    8943:	3c 89                	cmp    $0x89,%al
    8945:	75 63                	jne    89aa <lodepng_chunk_next_const+0x92>
    8947:	8b 45 08             	mov    0x8(%ebp),%eax
    894a:	83 c0 01             	add    $0x1,%eax
    894d:	0f b6 00             	movzbl (%eax),%eax
    8950:	3c 50                	cmp    $0x50,%al
    8952:	75 56                	jne    89aa <lodepng_chunk_next_const+0x92>
    8954:	8b 45 08             	mov    0x8(%ebp),%eax
    8957:	83 c0 02             	add    $0x2,%eax
    895a:	0f b6 00             	movzbl (%eax),%eax
    895d:	3c 4e                	cmp    $0x4e,%al
    895f:	75 49                	jne    89aa <lodepng_chunk_next_const+0x92>
    8961:	8b 45 08             	mov    0x8(%ebp),%eax
    8964:	83 c0 03             	add    $0x3,%eax
    8967:	0f b6 00             	movzbl (%eax),%eax
    896a:	3c 47                	cmp    $0x47,%al
    896c:	75 3c                	jne    89aa <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    896e:	8b 45 08             	mov    0x8(%ebp),%eax
    8971:	83 c0 04             	add    $0x4,%eax
    8974:	0f b6 00             	movzbl (%eax),%eax
    8977:	3c 0d                	cmp    $0xd,%al
    8979:	75 2f                	jne    89aa <lodepng_chunk_next_const+0x92>
    897b:	8b 45 08             	mov    0x8(%ebp),%eax
    897e:	83 c0 05             	add    $0x5,%eax
    8981:	0f b6 00             	movzbl (%eax),%eax
    8984:	3c 0a                	cmp    $0xa,%al
    8986:	75 22                	jne    89aa <lodepng_chunk_next_const+0x92>
    8988:	8b 45 08             	mov    0x8(%ebp),%eax
    898b:	83 c0 06             	add    $0x6,%eax
    898e:	0f b6 00             	movzbl (%eax),%eax
    8991:	3c 1a                	cmp    $0x1a,%al
    8993:	75 15                	jne    89aa <lodepng_chunk_next_const+0x92>
    8995:	8b 45 08             	mov    0x8(%ebp),%eax
    8998:	83 c0 07             	add    $0x7,%eax
    899b:	0f b6 00             	movzbl (%eax),%eax
    899e:	3c 0a                	cmp    $0xa,%al
    89a0:	75 08                	jne    89aa <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    89a2:	8b 45 08             	mov    0x8(%ebp),%eax
    89a5:	83 c0 08             	add    $0x8,%eax
    89a8:	eb 42                	jmp    89ec <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    89aa:	ff 75 08             	pushl  0x8(%ebp)
    89ad:	e8 a8 fc ff ff       	call   865a <lodepng_chunk_length>
    89b2:	83 c4 04             	add    $0x4,%esp
    89b5:	89 c2                	mov    %eax,%edx
    89b7:	8d 45 f8             	lea    -0x8(%ebp),%eax
    89ba:	50                   	push   %eax
    89bb:	6a 0c                	push   $0xc
    89bd:	52                   	push   %edx
    89be:	e8 d9 ad ff ff       	call   379c <lodepng_addofl>
    89c3:	83 c4 0c             	add    $0xc,%esp
    89c6:	85 c0                	test   %eax,%eax
    89c8:	74 05                	je     89cf <lodepng_chunk_next_const+0xb7>
    89ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    89cd:	eb 1d                	jmp    89ec <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    89cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    89d2:	89 c2                	mov    %eax,%edx
    89d4:	8b 45 08             	mov    0x8(%ebp),%eax
    89d7:	01 d0                	add    %edx,%eax
    89d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    89dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    89df:	3b 45 08             	cmp    0x8(%ebp),%eax
    89e2:	73 05                	jae    89e9 <lodepng_chunk_next_const+0xd1>
    89e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    89e7:	eb 03                	jmp    89ec <lodepng_chunk_next_const+0xd4>
    return result;
    89e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    89ec:	c9                   	leave  
    89ed:	c3                   	ret    

000089ee <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    89ee:	55                   	push   %ebp
    89ef:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    89f1:	8b 45 08             	mov    0x8(%ebp),%eax
    89f4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    89f7:	73 0f                	jae    8a08 <lodepng_chunk_find+0x1a>
    89f9:	8b 55 0c             	mov    0xc(%ebp),%edx
    89fc:	8b 45 08             	mov    0x8(%ebp),%eax
    89ff:	29 c2                	sub    %eax,%edx
    8a01:	89 d0                	mov    %edx,%eax
    8a03:	83 f8 0b             	cmp    $0xb,%eax
    8a06:	7f 07                	jg     8a0f <lodepng_chunk_find+0x21>
    8a08:	b8 00 00 00 00       	mov    $0x0,%eax
    8a0d:	eb 2a                	jmp    8a39 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8a0f:	ff 75 10             	pushl  0x10(%ebp)
    8a12:	ff 75 08             	pushl  0x8(%ebp)
    8a15:	e8 8d fc ff ff       	call   86a7 <lodepng_chunk_type_equals>
    8a1a:	83 c4 08             	add    $0x8,%esp
    8a1d:	84 c0                	test   %al,%al
    8a1f:	74 05                	je     8a26 <lodepng_chunk_find+0x38>
    8a21:	8b 45 08             	mov    0x8(%ebp),%eax
    8a24:	eb 13                	jmp    8a39 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8a26:	ff 75 0c             	pushl  0xc(%ebp)
    8a29:	ff 75 08             	pushl  0x8(%ebp)
    8a2c:	e8 11 fe ff ff       	call   8842 <lodepng_chunk_next>
    8a31:	83 c4 08             	add    $0x8,%esp
    8a34:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8a37:	eb b8                	jmp    89f1 <lodepng_chunk_find+0x3>
}
    8a39:	c9                   	leave  
    8a3a:	c3                   	ret    

00008a3b <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8a3b:	55                   	push   %ebp
    8a3c:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8a3e:	8b 45 08             	mov    0x8(%ebp),%eax
    8a41:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8a44:	73 0f                	jae    8a55 <lodepng_chunk_find_const+0x1a>
    8a46:	8b 55 0c             	mov    0xc(%ebp),%edx
    8a49:	8b 45 08             	mov    0x8(%ebp),%eax
    8a4c:	29 c2                	sub    %eax,%edx
    8a4e:	89 d0                	mov    %edx,%eax
    8a50:	83 f8 0b             	cmp    $0xb,%eax
    8a53:	7f 07                	jg     8a5c <lodepng_chunk_find_const+0x21>
    8a55:	b8 00 00 00 00       	mov    $0x0,%eax
    8a5a:	eb 2a                	jmp    8a86 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8a5c:	ff 75 10             	pushl  0x10(%ebp)
    8a5f:	ff 75 08             	pushl  0x8(%ebp)
    8a62:	e8 40 fc ff ff       	call   86a7 <lodepng_chunk_type_equals>
    8a67:	83 c4 08             	add    $0x8,%esp
    8a6a:	84 c0                	test   %al,%al
    8a6c:	74 05                	je     8a73 <lodepng_chunk_find_const+0x38>
    8a6e:	8b 45 08             	mov    0x8(%ebp),%eax
    8a71:	eb 13                	jmp    8a86 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    8a73:	ff 75 0c             	pushl  0xc(%ebp)
    8a76:	ff 75 08             	pushl  0x8(%ebp)
    8a79:	e8 9a fe ff ff       	call   8918 <lodepng_chunk_next_const>
    8a7e:	83 c4 08             	add    $0x8,%esp
    8a81:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8a84:	eb b8                	jmp    8a3e <lodepng_chunk_find_const+0x3>
}
    8a86:	c9                   	leave  
    8a87:	c3                   	ret    

00008a88 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    8a88:	55                   	push   %ebp
    8a89:	89 e5                	mov    %esp,%ebp
    8a8b:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    8a8e:	ff 75 10             	pushl  0x10(%ebp)
    8a91:	e8 c4 fb ff ff       	call   865a <lodepng_chunk_length>
    8a96:	83 c4 04             	add    $0x4,%esp
    8a99:	89 c2                	mov    %eax,%edx
    8a9b:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8a9e:	50                   	push   %eax
    8a9f:	6a 0c                	push   $0xc
    8aa1:	52                   	push   %edx
    8aa2:	e8 f5 ac ff ff       	call   379c <lodepng_addofl>
    8aa7:	83 c4 0c             	add    $0xc,%esp
    8aaa:	85 c0                	test   %eax,%eax
    8aac:	74 0a                	je     8ab8 <lodepng_chunk_append+0x30>
    8aae:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8ab3:	e9 96 00 00 00       	jmp    8b4e <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    8ab8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8abb:	8b 45 0c             	mov    0xc(%ebp),%eax
    8abe:	8b 00                	mov    (%eax),%eax
    8ac0:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    8ac3:	51                   	push   %ecx
    8ac4:	52                   	push   %edx
    8ac5:	50                   	push   %eax
    8ac6:	e8 d1 ac ff ff       	call   379c <lodepng_addofl>
    8acb:	83 c4 0c             	add    $0xc,%esp
    8ace:	85 c0                	test   %eax,%eax
    8ad0:	74 07                	je     8ad9 <lodepng_chunk_append+0x51>
    8ad2:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8ad7:	eb 75                	jmp    8b4e <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    8ad9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8adc:	8b 45 08             	mov    0x8(%ebp),%eax
    8adf:	8b 00                	mov    (%eax),%eax
    8ae1:	52                   	push   %edx
    8ae2:	50                   	push   %eax
    8ae3:	e8 07 ac ff ff       	call   36ef <lodepng_realloc>
    8ae8:	83 c4 08             	add    $0x8,%esp
    8aeb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    8aee:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    8af2:	75 07                	jne    8afb <lodepng_chunk_append+0x73>
    8af4:	b8 53 00 00 00       	mov    $0x53,%eax
    8af9:	eb 53                	jmp    8b4e <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8afb:	8b 45 08             	mov    0x8(%ebp),%eax
    8afe:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8b01:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8b03:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8b06:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b09:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8b0b:	8b 45 08             	mov    0x8(%ebp),%eax
    8b0e:	8b 00                	mov    (%eax),%eax
    8b10:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8b13:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8b16:	29 d1                	sub    %edx,%ecx
    8b18:	89 ca                	mov    %ecx,%edx
    8b1a:	01 d0                	add    %edx,%eax
    8b1c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    8b1f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8b26:	eb 19                	jmp    8b41 <lodepng_chunk_append+0xb9>
    8b28:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b2e:	01 c2                	add    %eax,%edx
    8b30:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8b33:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b36:	01 c8                	add    %ecx,%eax
    8b38:	0f b6 00             	movzbl (%eax),%eax
    8b3b:	88 02                	mov    %al,(%edx)
    8b3d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8b41:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8b44:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8b47:	75 df                	jne    8b28 <lodepng_chunk_append+0xa0>

  return 0;
    8b49:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b4e:	c9                   	leave  
    8b4f:	c3                   	ret    

00008b50 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    8b50:	55                   	push   %ebp
    8b51:	89 e5                	mov    %esp,%ebp
    8b53:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    8b56:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b59:	8b 40 04             	mov    0x4(%eax),%eax
    8b5c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    8b5f:	8b 55 10             	mov    0x10(%ebp),%edx
    8b62:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b65:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    8b68:	51                   	push   %ecx
    8b69:	52                   	push   %edx
    8b6a:	50                   	push   %eax
    8b6b:	e8 2c ac ff ff       	call   379c <lodepng_addofl>
    8b70:	83 c4 0c             	add    $0xc,%esp
    8b73:	85 c0                	test   %eax,%eax
    8b75:	74 07                	je     8b7e <lodepng_chunk_init+0x2e>
    8b77:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8b7c:	eb 78                	jmp    8bf6 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8b7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b81:	8d 55 fc             	lea    -0x4(%ebp),%edx
    8b84:	52                   	push   %edx
    8b85:	6a 0c                	push   $0xc
    8b87:	50                   	push   %eax
    8b88:	e8 0f ac ff ff       	call   379c <lodepng_addofl>
    8b8d:	83 c4 0c             	add    $0xc,%esp
    8b90:	85 c0                	test   %eax,%eax
    8b92:	74 07                	je     8b9b <lodepng_chunk_init+0x4b>
    8b94:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8b99:	eb 5b                	jmp    8bf6 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8b9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b9e:	50                   	push   %eax
    8b9f:	ff 75 0c             	pushl  0xc(%ebp)
    8ba2:	e8 8b ad ff ff       	call   3932 <ucvector_resize>
    8ba7:	83 c4 08             	add    $0x8,%esp
    8baa:	85 c0                	test   %eax,%eax
    8bac:	75 07                	jne    8bb5 <lodepng_chunk_init+0x65>
    8bae:	b8 53 00 00 00       	mov    $0x53,%eax
    8bb3:	eb 41                	jmp    8bf6 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    8bb5:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bb8:	8b 00                	mov    (%eax),%eax
    8bba:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8bbd:	2b 55 10             	sub    0x10(%ebp),%edx
    8bc0:	83 ea 0c             	sub    $0xc,%edx
    8bc3:	01 c2                	add    %eax,%edx
    8bc5:	8b 45 08             	mov    0x8(%ebp),%eax
    8bc8:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8bca:	8b 45 08             	mov    0x8(%ebp),%eax
    8bcd:	8b 00                	mov    (%eax),%eax
    8bcf:	ff 75 10             	pushl  0x10(%ebp)
    8bd2:	50                   	push   %eax
    8bd3:	e8 c1 ae ff ff       	call   3a99 <lodepng_set32bitInt>
    8bd8:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8bdb:	8b 45 08             	mov    0x8(%ebp),%eax
    8bde:	8b 00                	mov    (%eax),%eax
    8be0:	83 c0 04             	add    $0x4,%eax
    8be3:	6a 04                	push   $0x4
    8be5:	ff 75 14             	pushl  0x14(%ebp)
    8be8:	50                   	push   %eax
    8be9:	e8 28 ab ff ff       	call   3716 <lodepng_memcpy>
    8bee:	83 c4 0c             	add    $0xc,%esp

  return 0;
    8bf1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8bf6:	c9                   	leave  
    8bf7:	c3                   	ret    

00008bf8 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8bf8:	55                   	push   %ebp
    8bf9:	89 e5                	mov    %esp,%ebp
    8bfb:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8bfe:	ff 75 10             	pushl  0x10(%ebp)
    8c01:	ff 75 0c             	pushl  0xc(%ebp)
    8c04:	ff 75 08             	pushl  0x8(%ebp)
    8c07:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8c0a:	50                   	push   %eax
    8c0b:	e8 40 ff ff ff       	call   8b50 <lodepng_chunk_init>
    8c10:	83 c4 10             	add    $0x10,%esp
    8c13:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8c16:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8c1a:	74 05                	je     8c21 <lodepng_chunk_createv+0x29>
    8c1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8c1f:	eb 27                	jmp    8c48 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    8c21:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c24:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8c27:	83 c2 08             	add    $0x8,%edx
    8c2a:	50                   	push   %eax
    8c2b:	ff 75 14             	pushl  0x14(%ebp)
    8c2e:	52                   	push   %edx
    8c2f:	e8 e2 aa ff ff       	call   3716 <lodepng_memcpy>
    8c34:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8c37:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8c3a:	50                   	push   %eax
    8c3b:	e8 b9 fb ff ff       	call   87f9 <lodepng_chunk_generate_crc>
    8c40:	83 c4 04             	add    $0x4,%esp

  return 0;
    8c43:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8c48:	c9                   	leave  
    8c49:	c3                   	ret    

00008c4a <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8c4a:	55                   	push   %ebp
    8c4b:	89 e5                	mov    %esp,%ebp
    8c4d:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8c50:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c53:	8b 08                	mov    (%eax),%ecx
    8c55:	8b 45 08             	mov    0x8(%ebp),%eax
    8c58:	8b 10                	mov    (%eax),%edx
    8c5a:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8c5d:	51                   	push   %ecx
    8c5e:	52                   	push   %edx
    8c5f:	50                   	push   %eax
    8c60:	e8 34 ad ff ff       	call   3999 <ucvector_init>
    8c65:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    8c68:	ff 75 18             	pushl  0x18(%ebp)
    8c6b:	ff 75 14             	pushl  0x14(%ebp)
    8c6e:	ff 75 10             	pushl  0x10(%ebp)
    8c71:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8c74:	50                   	push   %eax
    8c75:	e8 7e ff ff ff       	call   8bf8 <lodepng_chunk_createv>
    8c7a:	83 c4 10             	add    $0x10,%esp
    8c7d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    8c80:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8c83:	8b 45 08             	mov    0x8(%ebp),%eax
    8c86:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8c88:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c8e:	89 10                	mov    %edx,(%eax)
  return error;
    8c90:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8c93:	c9                   	leave  
    8c94:	c3                   	ret    

00008c95 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    8c95:	55                   	push   %ebp
    8c96:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8c98:	8b 45 08             	mov    0x8(%ebp),%eax
    8c9b:	83 f8 03             	cmp    $0x3,%eax
    8c9e:	74 6d                	je     8d0d <checkColorValidity+0x78>
    8ca0:	83 f8 03             	cmp    $0x3,%eax
    8ca3:	77 0e                	ja     8cb3 <checkColorValidity+0x1e>
    8ca5:	85 c0                	test   %eax,%eax
    8ca7:	74 28                	je     8cd1 <checkColorValidity+0x3c>
    8ca9:	83 f8 02             	cmp    $0x2,%eax
    8cac:	74 4c                	je     8cfa <checkColorValidity+0x65>
    8cae:	e9 a6 00 00 00       	jmp    8d59 <checkColorValidity+0xc4>
    8cb3:	83 f8 06             	cmp    $0x6,%eax
    8cb6:	0f 84 83 00 00 00    	je     8d3f <checkColorValidity+0xaa>
    8cbc:	3d ff 00 00 00       	cmp    $0xff,%eax
    8cc1:	0f 84 8b 00 00 00    	je     8d52 <checkColorValidity+0xbd>
    8cc7:	83 f8 04             	cmp    $0x4,%eax
    8cca:	74 60                	je     8d2c <checkColorValidity+0x97>
    8ccc:	e9 88 00 00 00       	jmp    8d59 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8cd1:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8cd5:	0f 84 85 00 00 00    	je     8d60 <checkColorValidity+0xcb>
    8cdb:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8cdf:	74 7f                	je     8d60 <checkColorValidity+0xcb>
    8ce1:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8ce5:	74 79                	je     8d60 <checkColorValidity+0xcb>
    8ce7:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8ceb:	74 73                	je     8d60 <checkColorValidity+0xcb>
    8ced:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8cf1:	74 6d                	je     8d60 <checkColorValidity+0xcb>
    8cf3:	b8 25 00 00 00       	mov    $0x25,%eax
    8cf8:	eb 78                	jmp    8d72 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8cfa:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8cfe:	74 63                	je     8d63 <checkColorValidity+0xce>
    8d00:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8d04:	74 5d                	je     8d63 <checkColorValidity+0xce>
    8d06:	b8 25 00 00 00       	mov    $0x25,%eax
    8d0b:	eb 65                	jmp    8d72 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8d0d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8d11:	74 53                	je     8d66 <checkColorValidity+0xd1>
    8d13:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8d17:	74 4d                	je     8d66 <checkColorValidity+0xd1>
    8d19:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8d1d:	74 47                	je     8d66 <checkColorValidity+0xd1>
    8d1f:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8d23:	74 41                	je     8d66 <checkColorValidity+0xd1>
    8d25:	b8 25 00 00 00       	mov    $0x25,%eax
    8d2a:	eb 46                	jmp    8d72 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8d2c:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8d30:	74 37                	je     8d69 <checkColorValidity+0xd4>
    8d32:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8d36:	74 31                	je     8d69 <checkColorValidity+0xd4>
    8d38:	b8 25 00 00 00       	mov    $0x25,%eax
    8d3d:	eb 33                	jmp    8d72 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8d3f:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8d43:	74 27                	je     8d6c <checkColorValidity+0xd7>
    8d45:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8d49:	74 21                	je     8d6c <checkColorValidity+0xd7>
    8d4b:	b8 25 00 00 00       	mov    $0x25,%eax
    8d50:	eb 20                	jmp    8d72 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8d52:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8d57:	eb 19                	jmp    8d72 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8d59:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8d5e:	eb 12                	jmp    8d72 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8d60:	90                   	nop
    8d61:	eb 0a                	jmp    8d6d <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8d63:	90                   	nop
    8d64:	eb 07                	jmp    8d6d <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8d66:	90                   	nop
    8d67:	eb 04                	jmp    8d6d <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8d69:	90                   	nop
    8d6a:	eb 01                	jmp    8d6d <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8d6c:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8d6d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8d72:	5d                   	pop    %ebp
    8d73:	c3                   	ret    

00008d74 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8d74:	55                   	push   %ebp
    8d75:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8d77:	8b 45 08             	mov    0x8(%ebp),%eax
    8d7a:	83 f8 03             	cmp    $0x3,%eax
    8d7d:	74 31                	je     8db0 <getNumColorChannels+0x3c>
    8d7f:	83 f8 03             	cmp    $0x3,%eax
    8d82:	77 0b                	ja     8d8f <getNumColorChannels+0x1b>
    8d84:	85 c0                	test   %eax,%eax
    8d86:	74 1a                	je     8da2 <getNumColorChannels+0x2e>
    8d88:	83 f8 02             	cmp    $0x2,%eax
    8d8b:	74 1c                	je     8da9 <getNumColorChannels+0x35>
    8d8d:	eb 3d                	jmp    8dcc <getNumColorChannels+0x58>
    8d8f:	83 f8 06             	cmp    $0x6,%eax
    8d92:	74 2a                	je     8dbe <getNumColorChannels+0x4a>
    8d94:	3d ff 00 00 00       	cmp    $0xff,%eax
    8d99:	74 2a                	je     8dc5 <getNumColorChannels+0x51>
    8d9b:	83 f8 04             	cmp    $0x4,%eax
    8d9e:	74 17                	je     8db7 <getNumColorChannels+0x43>
    8da0:	eb 2a                	jmp    8dcc <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8da2:	b8 01 00 00 00       	mov    $0x1,%eax
    8da7:	eb 28                	jmp    8dd1 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8da9:	b8 03 00 00 00       	mov    $0x3,%eax
    8dae:	eb 21                	jmp    8dd1 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8db0:	b8 01 00 00 00       	mov    $0x1,%eax
    8db5:	eb 1a                	jmp    8dd1 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8db7:	b8 02 00 00 00       	mov    $0x2,%eax
    8dbc:	eb 13                	jmp    8dd1 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8dbe:	b8 04 00 00 00       	mov    $0x4,%eax
    8dc3:	eb 0c                	jmp    8dd1 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8dc5:	b8 00 00 00 00       	mov    $0x0,%eax
    8dca:	eb 05                	jmp    8dd1 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8dcc:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8dd1:	5d                   	pop    %ebp
    8dd2:	c3                   	ret    

00008dd3 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8dd3:	55                   	push   %ebp
    8dd4:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8dd6:	ff 75 08             	pushl  0x8(%ebp)
    8dd9:	e8 96 ff ff ff       	call   8d74 <getNumColorChannels>
    8dde:	83 c4 04             	add    $0x4,%esp
    8de1:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8de5:	c9                   	leave  
    8de6:	c3                   	ret    

00008de7 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8de7:	55                   	push   %ebp
    8de8:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8dea:	8b 45 08             	mov    0x8(%ebp),%eax
    8ded:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8df4:	8b 45 08             	mov    0x8(%ebp),%eax
    8df7:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8dfe:	8b 45 08             	mov    0x8(%ebp),%eax
    8e01:	8b 50 1c             	mov    0x1c(%eax),%edx
    8e04:	8b 45 08             	mov    0x8(%ebp),%eax
    8e07:	89 50 18             	mov    %edx,0x18(%eax)
    8e0a:	8b 45 08             	mov    0x8(%ebp),%eax
    8e0d:	8b 50 18             	mov    0x18(%eax),%edx
    8e10:	8b 45 08             	mov    0x8(%ebp),%eax
    8e13:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8e16:	8b 45 08             	mov    0x8(%ebp),%eax
    8e19:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8e1f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e22:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8e29:	8b 45 08             	mov    0x8(%ebp),%eax
    8e2c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8e33:	8b 45 08             	mov    0x8(%ebp),%eax
    8e36:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8e3d:	90                   	nop
    8e3e:	5d                   	pop    %ebp
    8e3f:	c3                   	ret    

00008e40 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8e40:	55                   	push   %ebp
    8e41:	89 e5                	mov    %esp,%ebp
    8e43:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8e46:	8b 45 08             	mov    0x8(%ebp),%eax
    8e49:	8b 40 08             	mov    0x8(%eax),%eax
    8e4c:	85 c0                	test   %eax,%eax
    8e4e:	75 18                	jne    8e68 <lodepng_color_mode_alloc_palette+0x28>
    8e50:	83 ec 0c             	sub    $0xc,%esp
    8e53:	68 00 04 00 00       	push   $0x400
    8e58:	e8 7b a8 ff ff       	call   36d8 <lodepng_malloc>
    8e5d:	83 c4 10             	add    $0x10,%esp
    8e60:	89 c2                	mov    %eax,%edx
    8e62:	8b 45 08             	mov    0x8(%ebp),%eax
    8e65:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8e68:	8b 45 08             	mov    0x8(%ebp),%eax
    8e6b:	8b 40 08             	mov    0x8(%eax),%eax
    8e6e:	85 c0                	test   %eax,%eax
    8e70:	74 65                	je     8ed7 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8e72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8e79:	eb 51                	jmp    8ecc <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8e7b:	8b 45 08             	mov    0x8(%ebp),%eax
    8e7e:	8b 40 08             	mov    0x8(%eax),%eax
    8e81:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8e84:	c1 e2 02             	shl    $0x2,%edx
    8e87:	01 d0                	add    %edx,%eax
    8e89:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8e8c:	8b 45 08             	mov    0x8(%ebp),%eax
    8e8f:	8b 40 08             	mov    0x8(%eax),%eax
    8e92:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8e95:	c1 e2 02             	shl    $0x2,%edx
    8e98:	83 c2 01             	add    $0x1,%edx
    8e9b:	01 d0                	add    %edx,%eax
    8e9d:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8ea0:	8b 45 08             	mov    0x8(%ebp),%eax
    8ea3:	8b 40 08             	mov    0x8(%eax),%eax
    8ea6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ea9:	c1 e2 02             	shl    $0x2,%edx
    8eac:	83 c2 02             	add    $0x2,%edx
    8eaf:	01 d0                	add    %edx,%eax
    8eb1:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8eb4:	8b 45 08             	mov    0x8(%ebp),%eax
    8eb7:	8b 40 08             	mov    0x8(%eax),%eax
    8eba:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ebd:	c1 e2 02             	shl    $0x2,%edx
    8ec0:	83 c2 03             	add    $0x3,%edx
    8ec3:	01 d0                	add    %edx,%eax
    8ec5:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8ec8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8ecc:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8ed3:	75 a6                	jne    8e7b <lodepng_color_mode_alloc_palette+0x3b>
    8ed5:	eb 01                	jmp    8ed8 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8ed7:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8ed8:	c9                   	leave  
    8ed9:	c3                   	ret    

00008eda <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8eda:	55                   	push   %ebp
    8edb:	89 e5                	mov    %esp,%ebp
    8edd:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8ee0:	83 ec 0c             	sub    $0xc,%esp
    8ee3:	ff 75 08             	pushl  0x8(%ebp)
    8ee6:	e8 f3 01 00 00       	call   90de <lodepng_palette_clear>
    8eeb:	83 c4 10             	add    $0x10,%esp
}
    8eee:	90                   	nop
    8eef:	c9                   	leave  
    8ef0:	c3                   	ret    

00008ef1 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8ef1:	55                   	push   %ebp
    8ef2:	89 e5                	mov    %esp,%ebp
    8ef4:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8ef7:	83 ec 0c             	sub    $0xc,%esp
    8efa:	ff 75 08             	pushl  0x8(%ebp)
    8efd:	e8 d8 ff ff ff       	call   8eda <lodepng_color_mode_cleanup>
    8f02:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8f05:	83 ec 04             	sub    $0x4,%esp
    8f08:	6a 20                	push   $0x20
    8f0a:	ff 75 0c             	pushl  0xc(%ebp)
    8f0d:	ff 75 08             	pushl  0x8(%ebp)
    8f10:	e8 01 a8 ff ff       	call   3716 <lodepng_memcpy>
    8f15:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8f18:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f1b:	8b 40 08             	mov    0x8(%eax),%eax
    8f1e:	85 c0                	test   %eax,%eax
    8f20:	74 5a                	je     8f7c <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8f22:	83 ec 0c             	sub    $0xc,%esp
    8f25:	68 00 04 00 00       	push   $0x400
    8f2a:	e8 a9 a7 ff ff       	call   36d8 <lodepng_malloc>
    8f2f:	83 c4 10             	add    $0x10,%esp
    8f32:	89 c2                	mov    %eax,%edx
    8f34:	8b 45 08             	mov    0x8(%ebp),%eax
    8f37:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8f3a:	8b 45 08             	mov    0x8(%ebp),%eax
    8f3d:	8b 40 08             	mov    0x8(%eax),%eax
    8f40:	85 c0                	test   %eax,%eax
    8f42:	75 11                	jne    8f55 <lodepng_color_mode_copy+0x64>
    8f44:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f47:	8b 40 0c             	mov    0xc(%eax),%eax
    8f4a:	85 c0                	test   %eax,%eax
    8f4c:	74 07                	je     8f55 <lodepng_color_mode_copy+0x64>
    8f4e:	b8 53 00 00 00       	mov    $0x53,%eax
    8f53:	eb 2c                	jmp    8f81 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8f55:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f58:	8b 40 0c             	mov    0xc(%eax),%eax
    8f5b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8f62:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f65:	8b 50 08             	mov    0x8(%eax),%edx
    8f68:	8b 45 08             	mov    0x8(%ebp),%eax
    8f6b:	8b 40 08             	mov    0x8(%eax),%eax
    8f6e:	83 ec 04             	sub    $0x4,%esp
    8f71:	51                   	push   %ecx
    8f72:	52                   	push   %edx
    8f73:	50                   	push   %eax
    8f74:	e8 9d a7 ff ff       	call   3716 <lodepng_memcpy>
    8f79:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8f7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f81:	c9                   	leave  
    8f82:	c3                   	ret    

00008f83 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8f83:	55                   	push   %ebp
    8f84:	89 e5                	mov    %esp,%ebp
    8f86:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8f89:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8f8c:	50                   	push   %eax
    8f8d:	e8 55 fe ff ff       	call   8de7 <lodepng_color_mode_init>
    8f92:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8f95:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f98:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8f9b:	8b 45 10             	mov    0x10(%ebp),%eax
    8f9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8fa1:	8b 45 08             	mov    0x8(%ebp),%eax
    8fa4:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8fa7:	89 10                	mov    %edx,(%eax)
    8fa9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8fac:	89 50 04             	mov    %edx,0x4(%eax)
    8faf:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8fb2:	89 50 08             	mov    %edx,0x8(%eax)
    8fb5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8fb8:	89 50 0c             	mov    %edx,0xc(%eax)
    8fbb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8fbe:	89 50 10             	mov    %edx,0x10(%eax)
    8fc1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8fc4:	89 50 14             	mov    %edx,0x14(%eax)
    8fc7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8fca:	89 50 18             	mov    %edx,0x18(%eax)
    8fcd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8fd0:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8fd3:	8b 45 08             	mov    0x8(%ebp),%eax
    8fd6:	c9                   	leave  
    8fd7:	c2 04 00             	ret    $0x4

00008fda <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8fda:	55                   	push   %ebp
    8fdb:	89 e5                	mov    %esp,%ebp
    8fdd:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8fe0:	8b 45 08             	mov    0x8(%ebp),%eax
    8fe3:	8b 10                	mov    (%eax),%edx
    8fe5:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fe8:	8b 00                	mov    (%eax),%eax
    8fea:	39 c2                	cmp    %eax,%edx
    8fec:	74 0a                	je     8ff8 <lodepng_color_mode_equal+0x1e>
    8fee:	b8 00 00 00 00       	mov    $0x0,%eax
    8ff3:	e9 e4 00 00 00       	jmp    90dc <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8ff8:	8b 45 08             	mov    0x8(%ebp),%eax
    8ffb:	8b 50 04             	mov    0x4(%eax),%edx
    8ffe:	8b 45 0c             	mov    0xc(%ebp),%eax
    9001:	8b 40 04             	mov    0x4(%eax),%eax
    9004:	39 c2                	cmp    %eax,%edx
    9006:	74 0a                	je     9012 <lodepng_color_mode_equal+0x38>
    9008:	b8 00 00 00 00       	mov    $0x0,%eax
    900d:	e9 ca 00 00 00       	jmp    90dc <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    9012:	8b 45 08             	mov    0x8(%ebp),%eax
    9015:	8b 50 10             	mov    0x10(%eax),%edx
    9018:	8b 45 0c             	mov    0xc(%ebp),%eax
    901b:	8b 40 10             	mov    0x10(%eax),%eax
    901e:	39 c2                	cmp    %eax,%edx
    9020:	74 0a                	je     902c <lodepng_color_mode_equal+0x52>
    9022:	b8 00 00 00 00       	mov    $0x0,%eax
    9027:	e9 b0 00 00 00       	jmp    90dc <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    902c:	8b 45 08             	mov    0x8(%ebp),%eax
    902f:	8b 40 10             	mov    0x10(%eax),%eax
    9032:	85 c0                	test   %eax,%eax
    9034:	74 48                	je     907e <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    9036:	8b 45 08             	mov    0x8(%ebp),%eax
    9039:	8b 50 14             	mov    0x14(%eax),%edx
    903c:	8b 45 0c             	mov    0xc(%ebp),%eax
    903f:	8b 40 14             	mov    0x14(%eax),%eax
    9042:	39 c2                	cmp    %eax,%edx
    9044:	74 0a                	je     9050 <lodepng_color_mode_equal+0x76>
    9046:	b8 00 00 00 00       	mov    $0x0,%eax
    904b:	e9 8c 00 00 00       	jmp    90dc <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    9050:	8b 45 08             	mov    0x8(%ebp),%eax
    9053:	8b 50 18             	mov    0x18(%eax),%edx
    9056:	8b 45 0c             	mov    0xc(%ebp),%eax
    9059:	8b 40 18             	mov    0x18(%eax),%eax
    905c:	39 c2                	cmp    %eax,%edx
    905e:	74 07                	je     9067 <lodepng_color_mode_equal+0x8d>
    9060:	b8 00 00 00 00       	mov    $0x0,%eax
    9065:	eb 75                	jmp    90dc <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    9067:	8b 45 08             	mov    0x8(%ebp),%eax
    906a:	8b 50 1c             	mov    0x1c(%eax),%edx
    906d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9070:	8b 40 1c             	mov    0x1c(%eax),%eax
    9073:	39 c2                	cmp    %eax,%edx
    9075:	74 07                	je     907e <lodepng_color_mode_equal+0xa4>
    9077:	b8 00 00 00 00       	mov    $0x0,%eax
    907c:	eb 5e                	jmp    90dc <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    907e:	8b 45 08             	mov    0x8(%ebp),%eax
    9081:	8b 50 0c             	mov    0xc(%eax),%edx
    9084:	8b 45 0c             	mov    0xc(%ebp),%eax
    9087:	8b 40 0c             	mov    0xc(%eax),%eax
    908a:	39 c2                	cmp    %eax,%edx
    908c:	74 07                	je     9095 <lodepng_color_mode_equal+0xbb>
    908e:	b8 00 00 00 00       	mov    $0x0,%eax
    9093:	eb 47                	jmp    90dc <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    9095:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    909c:	eb 2b                	jmp    90c9 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    909e:	8b 45 08             	mov    0x8(%ebp),%eax
    90a1:	8b 50 08             	mov    0x8(%eax),%edx
    90a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    90a7:	01 d0                	add    %edx,%eax
    90a9:	0f b6 10             	movzbl (%eax),%edx
    90ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    90af:	8b 48 08             	mov    0x8(%eax),%ecx
    90b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    90b5:	01 c8                	add    %ecx,%eax
    90b7:	0f b6 00             	movzbl (%eax),%eax
    90ba:	38 c2                	cmp    %al,%dl
    90bc:	74 07                	je     90c5 <lodepng_color_mode_equal+0xeb>
    90be:	b8 00 00 00 00       	mov    $0x0,%eax
    90c3:	eb 17                	jmp    90dc <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    90c5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    90c9:	8b 45 08             	mov    0x8(%ebp),%eax
    90cc:	8b 40 0c             	mov    0xc(%eax),%eax
    90cf:	c1 e0 02             	shl    $0x2,%eax
    90d2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    90d5:	75 c7                	jne    909e <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    90d7:	b8 01 00 00 00       	mov    $0x1,%eax
}
    90dc:	c9                   	leave  
    90dd:	c3                   	ret    

000090de <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    90de:	55                   	push   %ebp
    90df:	89 e5                	mov    %esp,%ebp
    90e1:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    90e4:	8b 45 08             	mov    0x8(%ebp),%eax
    90e7:	8b 40 08             	mov    0x8(%eax),%eax
    90ea:	85 c0                	test   %eax,%eax
    90ec:	74 12                	je     9100 <lodepng_palette_clear+0x22>
    90ee:	8b 45 08             	mov    0x8(%ebp),%eax
    90f1:	8b 40 08             	mov    0x8(%eax),%eax
    90f4:	83 ec 0c             	sub    $0xc,%esp
    90f7:	50                   	push   %eax
    90f8:	e8 fc a5 ff ff       	call   36f9 <lodepng_free>
    90fd:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    9100:	8b 45 08             	mov    0x8(%ebp),%eax
    9103:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    910a:	8b 45 08             	mov    0x8(%ebp),%eax
    910d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    9114:	90                   	nop
    9115:	c9                   	leave  
    9116:	c3                   	ret    

00009117 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9117:	55                   	push   %ebp
    9118:	89 e5                	mov    %esp,%ebp
    911a:	53                   	push   %ebx
    911b:	83 ec 14             	sub    $0x14,%esp
    911e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9121:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9124:	8b 55 14             	mov    0x14(%ebp),%edx
    9127:	8b 45 18             	mov    0x18(%ebp),%eax
    912a:	88 5d f4             	mov    %bl,-0xc(%ebp)
    912d:	88 4d f0             	mov    %cl,-0x10(%ebp)
    9130:	88 55 ec             	mov    %dl,-0x14(%ebp)
    9133:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    9136:	8b 45 08             	mov    0x8(%ebp),%eax
    9139:	8b 40 08             	mov    0x8(%eax),%eax
    913c:	85 c0                	test   %eax,%eax
    913e:	75 22                	jne    9162 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    9140:	83 ec 0c             	sub    $0xc,%esp
    9143:	ff 75 08             	pushl  0x8(%ebp)
    9146:	e8 f5 fc ff ff       	call   8e40 <lodepng_color_mode_alloc_palette>
    914b:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    914e:	8b 45 08             	mov    0x8(%ebp),%eax
    9151:	8b 40 08             	mov    0x8(%eax),%eax
    9154:	85 c0                	test   %eax,%eax
    9156:	75 0a                	jne    9162 <lodepng_palette_add+0x4b>
    9158:	b8 53 00 00 00       	mov    $0x53,%eax
    915d:	e9 8d 00 00 00       	jmp    91ef <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    9162:	8b 45 08             	mov    0x8(%ebp),%eax
    9165:	8b 40 0c             	mov    0xc(%eax),%eax
    9168:	3d ff 00 00 00       	cmp    $0xff,%eax
    916d:	7e 07                	jle    9176 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    916f:	b8 6c 00 00 00       	mov    $0x6c,%eax
    9174:	eb 79                	jmp    91ef <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    9176:	8b 45 08             	mov    0x8(%ebp),%eax
    9179:	8b 50 08             	mov    0x8(%eax),%edx
    917c:	8b 45 08             	mov    0x8(%ebp),%eax
    917f:	8b 40 0c             	mov    0xc(%eax),%eax
    9182:	c1 e0 02             	shl    $0x2,%eax
    9185:	01 c2                	add    %eax,%edx
    9187:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    918b:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    918d:	8b 45 08             	mov    0x8(%ebp),%eax
    9190:	8b 50 08             	mov    0x8(%eax),%edx
    9193:	8b 45 08             	mov    0x8(%ebp),%eax
    9196:	8b 40 0c             	mov    0xc(%eax),%eax
    9199:	c1 e0 02             	shl    $0x2,%eax
    919c:	83 c0 01             	add    $0x1,%eax
    919f:	01 c2                	add    %eax,%edx
    91a1:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    91a5:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    91a7:	8b 45 08             	mov    0x8(%ebp),%eax
    91aa:	8b 50 08             	mov    0x8(%eax),%edx
    91ad:	8b 45 08             	mov    0x8(%ebp),%eax
    91b0:	8b 40 0c             	mov    0xc(%eax),%eax
    91b3:	c1 e0 02             	shl    $0x2,%eax
    91b6:	83 c0 02             	add    $0x2,%eax
    91b9:	01 c2                	add    %eax,%edx
    91bb:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    91bf:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    91c1:	8b 45 08             	mov    0x8(%ebp),%eax
    91c4:	8b 50 08             	mov    0x8(%eax),%edx
    91c7:	8b 45 08             	mov    0x8(%ebp),%eax
    91ca:	8b 40 0c             	mov    0xc(%eax),%eax
    91cd:	c1 e0 02             	shl    $0x2,%eax
    91d0:	83 c0 03             	add    $0x3,%eax
    91d3:	01 c2                	add    %eax,%edx
    91d5:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    91d9:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    91db:	8b 45 08             	mov    0x8(%ebp),%eax
    91de:	8b 40 0c             	mov    0xc(%eax),%eax
    91e1:	8d 50 01             	lea    0x1(%eax),%edx
    91e4:	8b 45 08             	mov    0x8(%ebp),%eax
    91e7:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    91ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
    91ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    91f2:	c9                   	leave  
    91f3:	c3                   	ret    

000091f4 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    91f4:	55                   	push   %ebp
    91f5:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    91f7:	8b 45 08             	mov    0x8(%ebp),%eax
    91fa:	8b 50 04             	mov    0x4(%eax),%edx
    91fd:	8b 45 08             	mov    0x8(%ebp),%eax
    9200:	8b 00                	mov    (%eax),%eax
    9202:	52                   	push   %edx
    9203:	50                   	push   %eax
    9204:	e8 ca fb ff ff       	call   8dd3 <lodepng_get_bpp_lct>
    9209:	83 c4 08             	add    $0x8,%esp
}
    920c:	c9                   	leave  
    920d:	c3                   	ret    

0000920e <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    920e:	55                   	push   %ebp
    920f:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    9211:	8b 45 08             	mov    0x8(%ebp),%eax
    9214:	8b 00                	mov    (%eax),%eax
    9216:	50                   	push   %eax
    9217:	e8 58 fb ff ff       	call   8d74 <getNumColorChannels>
    921c:	83 c4 04             	add    $0x4,%esp
}
    921f:	c9                   	leave  
    9220:	c3                   	ret    

00009221 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    9221:	55                   	push   %ebp
    9222:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    9224:	8b 45 08             	mov    0x8(%ebp),%eax
    9227:	8b 00                	mov    (%eax),%eax
    9229:	85 c0                	test   %eax,%eax
    922b:	74 0a                	je     9237 <lodepng_is_greyscale_type+0x16>
    922d:	8b 45 08             	mov    0x8(%ebp),%eax
    9230:	8b 00                	mov    (%eax),%eax
    9232:	83 f8 04             	cmp    $0x4,%eax
    9235:	75 07                	jne    923e <lodepng_is_greyscale_type+0x1d>
    9237:	b8 01 00 00 00       	mov    $0x1,%eax
    923c:	eb 05                	jmp    9243 <lodepng_is_greyscale_type+0x22>
    923e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9243:	5d                   	pop    %ebp
    9244:	c3                   	ret    

00009245 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    9245:	55                   	push   %ebp
    9246:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    9248:	8b 45 08             	mov    0x8(%ebp),%eax
    924b:	8b 00                	mov    (%eax),%eax
    924d:	83 e0 04             	and    $0x4,%eax
    9250:	85 c0                	test   %eax,%eax
    9252:	0f 95 c0             	setne  %al
    9255:	0f b6 c0             	movzbl %al,%eax
}
    9258:	5d                   	pop    %ebp
    9259:	c3                   	ret    

0000925a <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    925a:	55                   	push   %ebp
    925b:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    925d:	8b 45 08             	mov    0x8(%ebp),%eax
    9260:	8b 00                	mov    (%eax),%eax
    9262:	83 f8 03             	cmp    $0x3,%eax
    9265:	0f 94 c0             	sete   %al
    9268:	0f b6 c0             	movzbl %al,%eax
}
    926b:	5d                   	pop    %ebp
    926c:	c3                   	ret    

0000926d <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    926d:	55                   	push   %ebp
    926e:	89 e5                	mov    %esp,%ebp
    9270:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9273:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    927a:	eb 23                	jmp    929f <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    927c:	8b 45 08             	mov    0x8(%ebp),%eax
    927f:	8b 40 08             	mov    0x8(%eax),%eax
    9282:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9285:	c1 e2 02             	shl    $0x2,%edx
    9288:	83 c2 03             	add    $0x3,%edx
    928b:	01 d0                	add    %edx,%eax
    928d:	0f b6 00             	movzbl (%eax),%eax
    9290:	3c ff                	cmp    $0xff,%al
    9292:	74 07                	je     929b <lodepng_has_palette_alpha+0x2e>
    9294:	b8 01 00 00 00       	mov    $0x1,%eax
    9299:	eb 14                	jmp    92af <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    929b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    929f:	8b 45 08             	mov    0x8(%ebp),%eax
    92a2:	8b 40 0c             	mov    0xc(%eax),%eax
    92a5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    92a8:	75 d2                	jne    927c <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    92aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
    92af:	c9                   	leave  
    92b0:	c3                   	ret    

000092b1 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    92b1:	55                   	push   %ebp
    92b2:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    92b4:	8b 45 08             	mov    0x8(%ebp),%eax
    92b7:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    92ba:	85 c0                	test   %eax,%eax
    92bc:	75 1e                	jne    92dc <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    92be:	ff 75 08             	pushl  0x8(%ebp)
    92c1:	e8 7f ff ff ff       	call   9245 <lodepng_is_alpha_type>
    92c6:	83 c4 04             	add    $0x4,%esp
    92c9:	85 c0                	test   %eax,%eax
    92cb:	75 0f                	jne    92dc <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    92cd:	ff 75 08             	pushl  0x8(%ebp)
    92d0:	e8 98 ff ff ff       	call   926d <lodepng_has_palette_alpha>
    92d5:	83 c4 04             	add    $0x4,%esp
    92d8:	85 c0                	test   %eax,%eax
    92da:	74 07                	je     92e3 <lodepng_can_have_alpha+0x32>
    92dc:	b8 01 00 00 00       	mov    $0x1,%eax
    92e1:	eb 05                	jmp    92e8 <lodepng_can_have_alpha+0x37>
    92e3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    92e8:	c9                   	leave  
    92e9:	c3                   	ret    

000092ea <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    92ea:	55                   	push   %ebp
    92eb:	89 e5                	mov    %esp,%ebp
    92ed:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    92f0:	ff 75 14             	pushl  0x14(%ebp)
    92f3:	ff 75 10             	pushl  0x10(%ebp)
    92f6:	e8 d8 fa ff ff       	call   8dd3 <lodepng_get_bpp_lct>
    92fb:	83 c4 08             	add    $0x8,%esp
    92fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    9301:	8b 55 08             	mov    0x8(%ebp),%edx
    9304:	8b 45 0c             	mov    0xc(%ebp),%eax
    9307:	0f af c2             	imul   %edx,%eax
    930a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    930d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9310:	c1 e8 03             	shr    $0x3,%eax
    9313:	89 c2                	mov    %eax,%edx
    9315:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9318:	0f af c2             	imul   %edx,%eax
    931b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    931e:	89 d1                	mov    %edx,%ecx
    9320:	83 e1 07             	and    $0x7,%ecx
    9323:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9326:	0f af d1             	imul   %ecx,%edx
    9329:	83 c2 07             	add    $0x7,%edx
    932c:	c1 ea 03             	shr    $0x3,%edx
    932f:	01 d0                	add    %edx,%eax
}
    9331:	c9                   	leave  
    9332:	c3                   	ret    

00009333 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    9333:	55                   	push   %ebp
    9334:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    9336:	8b 45 10             	mov    0x10(%ebp),%eax
    9339:	8b 50 04             	mov    0x4(%eax),%edx
    933c:	8b 45 10             	mov    0x10(%ebp),%eax
    933f:	8b 00                	mov    (%eax),%eax
    9341:	52                   	push   %edx
    9342:	50                   	push   %eax
    9343:	ff 75 0c             	pushl  0xc(%ebp)
    9346:	ff 75 08             	pushl  0x8(%ebp)
    9349:	e8 9c ff ff ff       	call   92ea <lodepng_get_raw_size_lct>
    934e:	83 c4 10             	add    $0x10,%esp
}
    9351:	c9                   	leave  
    9352:	c3                   	ret    

00009353 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    9353:	55                   	push   %ebp
    9354:	89 e5                	mov    %esp,%ebp
    9356:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    9359:	8b 45 08             	mov    0x8(%ebp),%eax
    935c:	c1 e8 03             	shr    $0x3,%eax
    935f:	0f af 45 10          	imul   0x10(%ebp),%eax
    9363:	8b 55 08             	mov    0x8(%ebp),%edx
    9366:	83 e2 07             	and    $0x7,%edx
    9369:	0f af 55 10          	imul   0x10(%ebp),%edx
    936d:	83 c2 07             	add    $0x7,%edx
    9370:	c1 ea 03             	shr    $0x3,%edx
    9373:	01 d0                	add    %edx,%eax
    9375:	83 c0 01             	add    $0x1,%eax
    9378:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    937b:	8b 45 0c             	mov    0xc(%ebp),%eax
    937e:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    9382:	c9                   	leave  
    9383:	c3                   	ret    

00009384 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    9384:	55                   	push   %ebp
    9385:	89 e5                	mov    %esp,%ebp
    9387:	53                   	push   %ebx
    9388:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    938b:	ff 75 10             	pushl  0x10(%ebp)
    938e:	e8 61 fe ff ff       	call   91f4 <lodepng_get_bpp>
    9393:	83 c4 04             	add    $0x4,%esp
    9396:	89 c3                	mov    %eax,%ebx
    9398:	ff 75 14             	pushl  0x14(%ebp)
    939b:	e8 54 fe ff ff       	call   91f4 <lodepng_get_bpp>
    93a0:	83 c4 04             	add    $0x4,%esp
    93a3:	39 c3                	cmp    %eax,%ebx
    93a5:	76 0d                	jbe    93b4 <lodepng_pixel_overflow+0x30>
    93a7:	ff 75 10             	pushl  0x10(%ebp)
    93aa:	e8 45 fe ff ff       	call   91f4 <lodepng_get_bpp>
    93af:	83 c4 04             	add    $0x4,%esp
    93b2:	eb 0b                	jmp    93bf <lodepng_pixel_overflow+0x3b>
    93b4:	ff 75 14             	pushl  0x14(%ebp)
    93b7:	e8 38 fe ff ff       	call   91f4 <lodepng_get_bpp>
    93bc:	83 c4 04             	add    $0x4,%esp
    93bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    93c2:	8b 55 0c             	mov    0xc(%ebp),%edx
    93c5:	8b 45 08             	mov    0x8(%ebp),%eax
    93c8:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    93cb:	51                   	push   %ecx
    93cc:	52                   	push   %edx
    93cd:	50                   	push   %eax
    93ce:	e8 e9 a3 ff ff       	call   37bc <lodepng_mulofl>
    93d3:	83 c4 0c             	add    $0xc,%esp
    93d6:	85 c0                	test   %eax,%eax
    93d8:	74 0a                	je     93e4 <lodepng_pixel_overflow+0x60>
    93da:	b8 01 00 00 00       	mov    $0x1,%eax
    93df:	e9 b6 00 00 00       	jmp    949a <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    93e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    93e7:	8d 55 f0             	lea    -0x10(%ebp),%edx
    93ea:	52                   	push   %edx
    93eb:	6a 08                	push   $0x8
    93ed:	50                   	push   %eax
    93ee:	e8 c9 a3 ff ff       	call   37bc <lodepng_mulofl>
    93f3:	83 c4 0c             	add    $0xc,%esp
    93f6:	85 c0                	test   %eax,%eax
    93f8:	74 0a                	je     9404 <lodepng_pixel_overflow+0x80>
    93fa:	b8 01 00 00 00       	mov    $0x1,%eax
    93ff:	e9 96 00 00 00       	jmp    949a <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    9404:	8b 45 08             	mov    0x8(%ebp),%eax
    9407:	c1 e8 03             	shr    $0x3,%eax
    940a:	89 c2                	mov    %eax,%edx
    940c:	8d 45 ec             	lea    -0x14(%ebp),%eax
    940f:	50                   	push   %eax
    9410:	ff 75 f8             	pushl  -0x8(%ebp)
    9413:	52                   	push   %edx
    9414:	e8 a3 a3 ff ff       	call   37bc <lodepng_mulofl>
    9419:	83 c4 0c             	add    $0xc,%esp
    941c:	85 c0                	test   %eax,%eax
    941e:	74 07                	je     9427 <lodepng_pixel_overflow+0xa3>
    9420:	b8 01 00 00 00       	mov    $0x1,%eax
    9425:	eb 73                	jmp    949a <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9427:	8b 45 08             	mov    0x8(%ebp),%eax
    942a:	83 e0 07             	and    $0x7,%eax
    942d:	89 c2                	mov    %eax,%edx
    942f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9432:	0f af c2             	imul   %edx,%eax
    9435:	83 c0 07             	add    $0x7,%eax
    9438:	c1 e8 03             	shr    $0x3,%eax
    943b:	89 c1                	mov    %eax,%ecx
    943d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9440:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9443:	52                   	push   %edx
    9444:	51                   	push   %ecx
    9445:	50                   	push   %eax
    9446:	e8 51 a3 ff ff       	call   379c <lodepng_addofl>
    944b:	83 c4 0c             	add    $0xc,%esp
    944e:	85 c0                	test   %eax,%eax
    9450:	74 07                	je     9459 <lodepng_pixel_overflow+0xd5>
    9452:	b8 01 00 00 00       	mov    $0x1,%eax
    9457:	eb 41                	jmp    949a <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9459:	8b 45 ec             	mov    -0x14(%ebp),%eax
    945c:	8d 55 ec             	lea    -0x14(%ebp),%edx
    945f:	52                   	push   %edx
    9460:	6a 05                	push   $0x5
    9462:	50                   	push   %eax
    9463:	e8 34 a3 ff ff       	call   379c <lodepng_addofl>
    9468:	83 c4 0c             	add    $0xc,%esp
    946b:	85 c0                	test   %eax,%eax
    946d:	74 07                	je     9476 <lodepng_pixel_overflow+0xf2>
    946f:	b8 01 00 00 00       	mov    $0x1,%eax
    9474:	eb 24                	jmp    949a <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    9476:	8b 55 0c             	mov    0xc(%ebp),%edx
    9479:	8b 45 ec             	mov    -0x14(%ebp),%eax
    947c:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    947f:	51                   	push   %ecx
    9480:	52                   	push   %edx
    9481:	50                   	push   %eax
    9482:	e8 35 a3 ff ff       	call   37bc <lodepng_mulofl>
    9487:	83 c4 0c             	add    $0xc,%esp
    948a:	85 c0                	test   %eax,%eax
    948c:	74 07                	je     9495 <lodepng_pixel_overflow+0x111>
    948e:	b8 01 00 00 00       	mov    $0x1,%eax
    9493:	eb 05                	jmp    949a <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    9495:	b8 00 00 00 00       	mov    $0x0,%eax
}
    949a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    949d:	c9                   	leave  
    949e:	c3                   	ret    

0000949f <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    949f:	55                   	push   %ebp
    94a0:	89 e5                	mov    %esp,%ebp
    94a2:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    94a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    94ac:	eb 15                	jmp    94c3 <LodePNGUnknownChunks_init+0x24>
    94ae:	8b 45 08             	mov    0x8(%ebp),%eax
    94b1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    94b4:	83 c2 30             	add    $0x30,%edx
    94b7:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    94be:	00 
    94bf:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    94c3:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    94c7:	75 e5                	jne    94ae <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    94c9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    94d0:	eb 15                	jmp    94e7 <LodePNGUnknownChunks_init+0x48>
    94d2:	8b 45 08             	mov    0x8(%ebp),%eax
    94d5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    94d8:	83 c2 34             	add    $0x34,%edx
    94db:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    94e2:	00 
    94e3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    94e7:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    94eb:	75 e5                	jne    94d2 <LodePNGUnknownChunks_init+0x33>
}
    94ed:	90                   	nop
    94ee:	c9                   	leave  
    94ef:	c3                   	ret    

000094f0 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    94f0:	55                   	push   %ebp
    94f1:	89 e5                	mov    %esp,%ebp
    94f3:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    94f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    94fd:	eb 1d                	jmp    951c <LodePNGUnknownChunks_cleanup+0x2c>
    94ff:	8b 45 08             	mov    0x8(%ebp),%eax
    9502:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9505:	83 c2 30             	add    $0x30,%edx
    9508:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    950c:	83 ec 0c             	sub    $0xc,%esp
    950f:	50                   	push   %eax
    9510:	e8 e4 a1 ff ff       	call   36f9 <lodepng_free>
    9515:	83 c4 10             	add    $0x10,%esp
    9518:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    951c:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9520:	75 dd                	jne    94ff <LodePNGUnknownChunks_cleanup+0xf>
}
    9522:	90                   	nop
    9523:	c9                   	leave  
    9524:	c3                   	ret    

00009525 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    9525:	55                   	push   %ebp
    9526:	89 e5                	mov    %esp,%ebp
    9528:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    952b:	83 ec 0c             	sub    $0xc,%esp
    952e:	ff 75 08             	pushl  0x8(%ebp)
    9531:	e8 ba ff ff ff       	call   94f0 <LodePNGUnknownChunks_cleanup>
    9536:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9539:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9540:	e9 b7 00 00 00       	jmp    95fc <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9545:	8b 45 0c             	mov    0xc(%ebp),%eax
    9548:	8b 55 f4             	mov    -0xc(%ebp),%edx
    954b:	83 c2 34             	add    $0x34,%edx
    954e:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    9552:	8b 45 08             	mov    0x8(%ebp),%eax
    9555:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9558:	83 c1 34             	add    $0x34,%ecx
    955b:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    955f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9562:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9565:	83 c2 34             	add    $0x34,%edx
    9568:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    956c:	83 ec 0c             	sub    $0xc,%esp
    956f:	50                   	push   %eax
    9570:	e8 63 a1 ff ff       	call   36d8 <lodepng_malloc>
    9575:	83 c4 10             	add    $0x10,%esp
    9578:	89 c1                	mov    %eax,%ecx
    957a:	8b 45 08             	mov    0x8(%ebp),%eax
    957d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9580:	83 c2 30             	add    $0x30,%edx
    9583:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    9587:	8b 45 08             	mov    0x8(%ebp),%eax
    958a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    958d:	83 c2 30             	add    $0x30,%edx
    9590:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9594:	85 c0                	test   %eax,%eax
    9596:	75 18                	jne    95b0 <LodePNGUnknownChunks_copy+0x8b>
    9598:	8b 45 08             	mov    0x8(%ebp),%eax
    959b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    959e:	83 c2 34             	add    $0x34,%edx
    95a1:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    95a5:	85 c0                	test   %eax,%eax
    95a7:	74 07                	je     95b0 <LodePNGUnknownChunks_copy+0x8b>
    95a9:	b8 53 00 00 00       	mov    $0x53,%eax
    95ae:	eb 5b                	jmp    960b <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    95b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    95b7:	eb 2d                	jmp    95e6 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    95b9:	8b 45 08             	mov    0x8(%ebp),%eax
    95bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95bf:	83 c2 30             	add    $0x30,%edx
    95c2:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    95c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    95c9:	01 c2                	add    %eax,%edx
    95cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    95ce:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    95d1:	83 c1 30             	add    $0x30,%ecx
    95d4:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    95d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    95db:	01 c8                	add    %ecx,%eax
    95dd:	0f b6 00             	movzbl (%eax),%eax
    95e0:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    95e2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    95e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    95e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95ec:	83 c2 34             	add    $0x34,%edx
    95ef:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    95f3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    95f6:	7f c1                	jg     95b9 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    95f8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    95fc:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9600:	0f 85 3f ff ff ff    	jne    9545 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    9606:	b8 00 00 00 00       	mov    $0x0,%eax
}
    960b:	c9                   	leave  
    960c:	c3                   	ret    

0000960d <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    960d:	55                   	push   %ebp
    960e:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    9610:	8b 45 08             	mov    0x8(%ebp),%eax
    9613:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    961a:	8b 45 08             	mov    0x8(%ebp),%eax
    961d:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    9624:	8b 45 08             	mov    0x8(%ebp),%eax
    9627:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    962e:	90                   	nop
    962f:	5d                   	pop    %ebp
    9630:	c3                   	ret    

00009631 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    9631:	55                   	push   %ebp
    9632:	89 e5                	mov    %esp,%ebp
    9634:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9637:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    963e:	eb 38                	jmp    9678 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    9640:	8b 45 08             	mov    0x8(%ebp),%eax
    9643:	8b 40 40             	mov    0x40(%eax),%eax
    9646:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9649:	c1 e2 02             	shl    $0x2,%edx
    964c:	01 d0                	add    %edx,%eax
    964e:	83 ec 0c             	sub    $0xc,%esp
    9651:	50                   	push   %eax
    9652:	e8 75 a3 ff ff       	call   39cc <string_cleanup>
    9657:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    965a:	8b 45 08             	mov    0x8(%ebp),%eax
    965d:	8b 40 44             	mov    0x44(%eax),%eax
    9660:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9663:	c1 e2 02             	shl    $0x2,%edx
    9666:	01 d0                	add    %edx,%eax
    9668:	83 ec 0c             	sub    $0xc,%esp
    966b:	50                   	push   %eax
    966c:	e8 5b a3 ff ff       	call   39cc <string_cleanup>
    9671:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9674:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9678:	8b 45 08             	mov    0x8(%ebp),%eax
    967b:	8b 40 3c             	mov    0x3c(%eax),%eax
    967e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9681:	75 bd                	jne    9640 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    9683:	8b 45 08             	mov    0x8(%ebp),%eax
    9686:	8b 40 40             	mov    0x40(%eax),%eax
    9689:	83 ec 0c             	sub    $0xc,%esp
    968c:	50                   	push   %eax
    968d:	e8 67 a0 ff ff       	call   36f9 <lodepng_free>
    9692:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    9695:	8b 45 08             	mov    0x8(%ebp),%eax
    9698:	8b 40 44             	mov    0x44(%eax),%eax
    969b:	83 ec 0c             	sub    $0xc,%esp
    969e:	50                   	push   %eax
    969f:	e8 55 a0 ff ff       	call   36f9 <lodepng_free>
    96a4:	83 c4 10             	add    $0x10,%esp
}
    96a7:	90                   	nop
    96a8:	c9                   	leave  
    96a9:	c3                   	ret    

000096aa <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    96aa:	55                   	push   %ebp
    96ab:	89 e5                	mov    %esp,%ebp
    96ad:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    96b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    96b7:	8b 45 08             	mov    0x8(%ebp),%eax
    96ba:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    96c1:	8b 45 08             	mov    0x8(%ebp),%eax
    96c4:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    96cb:	8b 45 08             	mov    0x8(%ebp),%eax
    96ce:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    96d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    96dc:	eb 42                	jmp    9720 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    96de:	8b 45 0c             	mov    0xc(%ebp),%eax
    96e1:	8b 40 44             	mov    0x44(%eax),%eax
    96e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96e7:	c1 e2 02             	shl    $0x2,%edx
    96ea:	01 d0                	add    %edx,%eax
    96ec:	8b 10                	mov    (%eax),%edx
    96ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    96f1:	8b 40 40             	mov    0x40(%eax),%eax
    96f4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    96f7:	c1 e1 02             	shl    $0x2,%ecx
    96fa:	01 c8                	add    %ecx,%eax
    96fc:	8b 00                	mov    (%eax),%eax
    96fe:	83 ec 04             	sub    $0x4,%esp
    9701:	52                   	push   %edx
    9702:	50                   	push   %eax
    9703:	ff 75 08             	pushl  0x8(%ebp)
    9706:	e8 4d 01 00 00       	call   9858 <lodepng_add_text>
    970b:	83 c4 10             	add    $0x10,%esp
    970e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9711:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9715:	74 05                	je     971c <LodePNGText_copy+0x72>
    9717:	8b 45 f0             	mov    -0x10(%ebp),%eax
    971a:	eb 14                	jmp    9730 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    971c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9720:	8b 45 0c             	mov    0xc(%ebp),%eax
    9723:	8b 40 3c             	mov    0x3c(%eax),%eax
    9726:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9729:	75 b3                	jne    96de <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    972b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9730:	c9                   	leave  
    9731:	c3                   	ret    

00009732 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    9732:	55                   	push   %ebp
    9733:	89 e5                	mov    %esp,%ebp
    9735:	53                   	push   %ebx
    9736:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9739:	8b 45 08             	mov    0x8(%ebp),%eax
    973c:	8b 40 3c             	mov    0x3c(%eax),%eax
    973f:	83 c0 01             	add    $0x1,%eax
    9742:	c1 e0 02             	shl    $0x2,%eax
    9745:	89 c2                	mov    %eax,%edx
    9747:	8b 45 08             	mov    0x8(%ebp),%eax
    974a:	8b 40 40             	mov    0x40(%eax),%eax
    974d:	52                   	push   %edx
    974e:	50                   	push   %eax
    974f:	e8 9b 9f ff ff       	call   36ef <lodepng_realloc>
    9754:	83 c4 08             	add    $0x8,%esp
    9757:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    975a:	8b 45 08             	mov    0x8(%ebp),%eax
    975d:	8b 40 3c             	mov    0x3c(%eax),%eax
    9760:	83 c0 01             	add    $0x1,%eax
    9763:	c1 e0 02             	shl    $0x2,%eax
    9766:	89 c2                	mov    %eax,%edx
    9768:	8b 45 08             	mov    0x8(%ebp),%eax
    976b:	8b 40 44             	mov    0x44(%eax),%eax
    976e:	52                   	push   %edx
    976f:	50                   	push   %eax
    9770:	e8 7a 9f ff ff       	call   36ef <lodepng_realloc>
    9775:	83 c4 08             	add    $0x8,%esp
    9778:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    977b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    977f:	74 09                	je     978a <lodepng_add_text_sized+0x58>
    9781:	8b 45 08             	mov    0x8(%ebp),%eax
    9784:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9787:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    978a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    978e:	74 09                	je     9799 <lodepng_add_text_sized+0x67>
    9790:	8b 45 08             	mov    0x8(%ebp),%eax
    9793:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9796:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    9799:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    979d:	74 06                	je     97a5 <lodepng_add_text_sized+0x73>
    979f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    97a3:	75 0a                	jne    97af <lodepng_add_text_sized+0x7d>
    97a5:	b8 53 00 00 00       	mov    $0x53,%eax
    97aa:	e9 a4 00 00 00       	jmp    9853 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    97af:	8b 45 08             	mov    0x8(%ebp),%eax
    97b2:	8b 40 3c             	mov    0x3c(%eax),%eax
    97b5:	8d 50 01             	lea    0x1(%eax),%edx
    97b8:	8b 45 08             	mov    0x8(%ebp),%eax
    97bb:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    97be:	8b 45 08             	mov    0x8(%ebp),%eax
    97c1:	8b 50 40             	mov    0x40(%eax),%edx
    97c4:	8b 45 08             	mov    0x8(%ebp),%eax
    97c7:	8b 40 3c             	mov    0x3c(%eax),%eax
    97ca:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97cf:	c1 e0 02             	shl    $0x2,%eax
    97d2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97d5:	83 ec 0c             	sub    $0xc,%esp
    97d8:	ff 75 0c             	pushl  0xc(%ebp)
    97db:	e8 54 a2 ff ff       	call   3a34 <alloc_string>
    97e0:	83 c4 10             	add    $0x10,%esp
    97e3:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    97e5:	8b 45 08             	mov    0x8(%ebp),%eax
    97e8:	8b 50 44             	mov    0x44(%eax),%edx
    97eb:	8b 45 08             	mov    0x8(%ebp),%eax
    97ee:	8b 40 3c             	mov    0x3c(%eax),%eax
    97f1:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97f6:	c1 e0 02             	shl    $0x2,%eax
    97f9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97fc:	83 ec 08             	sub    $0x8,%esp
    97ff:	ff 75 14             	pushl  0x14(%ebp)
    9802:	ff 75 10             	pushl  0x10(%ebp)
    9805:	e8 e5 a1 ff ff       	call   39ef <alloc_string_sized>
    980a:	83 c4 10             	add    $0x10,%esp
    980d:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    980f:	8b 45 08             	mov    0x8(%ebp),%eax
    9812:	8b 50 40             	mov    0x40(%eax),%edx
    9815:	8b 45 08             	mov    0x8(%ebp),%eax
    9818:	8b 40 3c             	mov    0x3c(%eax),%eax
    981b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9820:	c1 e0 02             	shl    $0x2,%eax
    9823:	01 d0                	add    %edx,%eax
    9825:	8b 00                	mov    (%eax),%eax
    9827:	85 c0                	test   %eax,%eax
    9829:	74 1c                	je     9847 <lodepng_add_text_sized+0x115>
    982b:	8b 45 08             	mov    0x8(%ebp),%eax
    982e:	8b 50 44             	mov    0x44(%eax),%edx
    9831:	8b 45 08             	mov    0x8(%ebp),%eax
    9834:	8b 40 3c             	mov    0x3c(%eax),%eax
    9837:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    983c:	c1 e0 02             	shl    $0x2,%eax
    983f:	01 d0                	add    %edx,%eax
    9841:	8b 00                	mov    (%eax),%eax
    9843:	85 c0                	test   %eax,%eax
    9845:	75 07                	jne    984e <lodepng_add_text_sized+0x11c>
    9847:	b8 53 00 00 00       	mov    $0x53,%eax
    984c:	eb 05                	jmp    9853 <lodepng_add_text_sized+0x121>

  return 0;
    984e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9853:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9856:	c9                   	leave  
    9857:	c3                   	ret    

00009858 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9858:	55                   	push   %ebp
    9859:	89 e5                	mov    %esp,%ebp
    985b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    985e:	ff 75 10             	pushl  0x10(%ebp)
    9861:	e8 0e 9f ff ff       	call   3774 <lodepng_strlen>
    9866:	83 c4 04             	add    $0x4,%esp
    9869:	50                   	push   %eax
    986a:	ff 75 10             	pushl  0x10(%ebp)
    986d:	ff 75 0c             	pushl  0xc(%ebp)
    9870:	ff 75 08             	pushl  0x8(%ebp)
    9873:	e8 ba fe ff ff       	call   9732 <lodepng_add_text_sized>
    9878:	83 c4 10             	add    $0x10,%esp
}
    987b:	c9                   	leave  
    987c:	c3                   	ret    

0000987d <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    987d:	55                   	push   %ebp
    987e:	89 e5                	mov    %esp,%ebp
    9880:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    9883:	83 ec 0c             	sub    $0xc,%esp
    9886:	ff 75 08             	pushl  0x8(%ebp)
    9889:	e8 a3 fd ff ff       	call   9631 <LodePNGText_cleanup>
    988e:	83 c4 10             	add    $0x10,%esp
}
    9891:	90                   	nop
    9892:	c9                   	leave  
    9893:	c3                   	ret    

00009894 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    9894:	55                   	push   %ebp
    9895:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    9897:	8b 45 08             	mov    0x8(%ebp),%eax
    989a:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    98a1:	8b 45 08             	mov    0x8(%ebp),%eax
    98a4:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    98ab:	8b 45 08             	mov    0x8(%ebp),%eax
    98ae:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    98b5:	8b 45 08             	mov    0x8(%ebp),%eax
    98b8:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    98bf:	8b 45 08             	mov    0x8(%ebp),%eax
    98c2:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    98c9:	90                   	nop
    98ca:	5d                   	pop    %ebp
    98cb:	c3                   	ret    

000098cc <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    98cc:	55                   	push   %ebp
    98cd:	89 e5                	mov    %esp,%ebp
    98cf:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    98d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    98d9:	eb 6c                	jmp    9947 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    98db:	8b 45 08             	mov    0x8(%ebp),%eax
    98de:	8b 40 4c             	mov    0x4c(%eax),%eax
    98e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98e4:	c1 e2 02             	shl    $0x2,%edx
    98e7:	01 d0                	add    %edx,%eax
    98e9:	83 ec 0c             	sub    $0xc,%esp
    98ec:	50                   	push   %eax
    98ed:	e8 da a0 ff ff       	call   39cc <string_cleanup>
    98f2:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    98f5:	8b 45 08             	mov    0x8(%ebp),%eax
    98f8:	8b 40 50             	mov    0x50(%eax),%eax
    98fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98fe:	c1 e2 02             	shl    $0x2,%edx
    9901:	01 d0                	add    %edx,%eax
    9903:	83 ec 0c             	sub    $0xc,%esp
    9906:	50                   	push   %eax
    9907:	e8 c0 a0 ff ff       	call   39cc <string_cleanup>
    990c:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    990f:	8b 45 08             	mov    0x8(%ebp),%eax
    9912:	8b 40 54             	mov    0x54(%eax),%eax
    9915:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9918:	c1 e2 02             	shl    $0x2,%edx
    991b:	01 d0                	add    %edx,%eax
    991d:	83 ec 0c             	sub    $0xc,%esp
    9920:	50                   	push   %eax
    9921:	e8 a6 a0 ff ff       	call   39cc <string_cleanup>
    9926:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9929:	8b 45 08             	mov    0x8(%ebp),%eax
    992c:	8b 40 58             	mov    0x58(%eax),%eax
    992f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9932:	c1 e2 02             	shl    $0x2,%edx
    9935:	01 d0                	add    %edx,%eax
    9937:	83 ec 0c             	sub    $0xc,%esp
    993a:	50                   	push   %eax
    993b:	e8 8c a0 ff ff       	call   39cc <string_cleanup>
    9940:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9943:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9947:	8b 45 08             	mov    0x8(%ebp),%eax
    994a:	8b 40 48             	mov    0x48(%eax),%eax
    994d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9950:	75 89                	jne    98db <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    9952:	8b 45 08             	mov    0x8(%ebp),%eax
    9955:	8b 40 4c             	mov    0x4c(%eax),%eax
    9958:	83 ec 0c             	sub    $0xc,%esp
    995b:	50                   	push   %eax
    995c:	e8 98 9d ff ff       	call   36f9 <lodepng_free>
    9961:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    9964:	8b 45 08             	mov    0x8(%ebp),%eax
    9967:	8b 40 50             	mov    0x50(%eax),%eax
    996a:	83 ec 0c             	sub    $0xc,%esp
    996d:	50                   	push   %eax
    996e:	e8 86 9d ff ff       	call   36f9 <lodepng_free>
    9973:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    9976:	8b 45 08             	mov    0x8(%ebp),%eax
    9979:	8b 40 54             	mov    0x54(%eax),%eax
    997c:	83 ec 0c             	sub    $0xc,%esp
    997f:	50                   	push   %eax
    9980:	e8 74 9d ff ff       	call   36f9 <lodepng_free>
    9985:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    9988:	8b 45 08             	mov    0x8(%ebp),%eax
    998b:	8b 40 58             	mov    0x58(%eax),%eax
    998e:	83 ec 0c             	sub    $0xc,%esp
    9991:	50                   	push   %eax
    9992:	e8 62 9d ff ff       	call   36f9 <lodepng_free>
    9997:	83 c4 10             	add    $0x10,%esp
}
    999a:	90                   	nop
    999b:	c9                   	leave  
    999c:	c3                   	ret    

0000999d <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    999d:	55                   	push   %ebp
    999e:	89 e5                	mov    %esp,%ebp
    99a0:	56                   	push   %esi
    99a1:	53                   	push   %ebx
    99a2:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    99a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    99ac:	8b 45 08             	mov    0x8(%ebp),%eax
    99af:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    99b6:	8b 45 08             	mov    0x8(%ebp),%eax
    99b9:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    99c0:	8b 45 08             	mov    0x8(%ebp),%eax
    99c3:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    99ca:	8b 45 08             	mov    0x8(%ebp),%eax
    99cd:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    99d4:	8b 45 08             	mov    0x8(%ebp),%eax
    99d7:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    99de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    99e5:	eb 64                	jmp    9a4b <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    99e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    99ea:	8b 40 58             	mov    0x58(%eax),%eax
    99ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
    99f0:	c1 e2 02             	shl    $0x2,%edx
    99f3:	01 d0                	add    %edx,%eax
    99f5:	8b 18                	mov    (%eax),%ebx
    99f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    99fa:	8b 40 54             	mov    0x54(%eax),%eax
    99fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9a00:	c1 e2 02             	shl    $0x2,%edx
    9a03:	01 d0                	add    %edx,%eax
    9a05:	8b 08                	mov    (%eax),%ecx
    9a07:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a0a:	8b 40 50             	mov    0x50(%eax),%eax
    9a0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9a10:	c1 e2 02             	shl    $0x2,%edx
    9a13:	01 d0                	add    %edx,%eax
    9a15:	8b 10                	mov    (%eax),%edx
    9a17:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a1a:	8b 40 4c             	mov    0x4c(%eax),%eax
    9a1d:	8b 75 f4             	mov    -0xc(%ebp),%esi
    9a20:	c1 e6 02             	shl    $0x2,%esi
    9a23:	01 f0                	add    %esi,%eax
    9a25:	8b 00                	mov    (%eax),%eax
    9a27:	83 ec 0c             	sub    $0xc,%esp
    9a2a:	53                   	push   %ebx
    9a2b:	51                   	push   %ecx
    9a2c:	52                   	push   %edx
    9a2d:	50                   	push   %eax
    9a2e:	ff 75 08             	pushl  0x8(%ebp)
    9a31:	e8 e4 01 00 00       	call   9c1a <lodepng_add_itext>
    9a36:	83 c4 20             	add    $0x20,%esp
    9a39:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9a3c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9a40:	74 05                	je     9a47 <LodePNGIText_copy+0xaa>
    9a42:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9a45:	eb 14                	jmp    9a5b <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9a47:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9a4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a4e:	8b 40 48             	mov    0x48(%eax),%eax
    9a51:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9a54:	75 91                	jne    99e7 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    9a56:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9a5b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9a5e:	5b                   	pop    %ebx
    9a5f:	5e                   	pop    %esi
    9a60:	5d                   	pop    %ebp
    9a61:	c3                   	ret    

00009a62 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    9a62:	55                   	push   %ebp
    9a63:	89 e5                	mov    %esp,%ebp
    9a65:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    9a68:	83 ec 0c             	sub    $0xc,%esp
    9a6b:	ff 75 08             	pushl  0x8(%ebp)
    9a6e:	e8 59 fe ff ff       	call   98cc <LodePNGIText_cleanup>
    9a73:	83 c4 10             	add    $0x10,%esp
}
    9a76:	90                   	nop
    9a77:	c9                   	leave  
    9a78:	c3                   	ret    

00009a79 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    9a79:	55                   	push   %ebp
    9a7a:	89 e5                	mov    %esp,%ebp
    9a7c:	53                   	push   %ebx
    9a7d:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    9a80:	8b 45 08             	mov    0x8(%ebp),%eax
    9a83:	8b 40 48             	mov    0x48(%eax),%eax
    9a86:	83 c0 01             	add    $0x1,%eax
    9a89:	c1 e0 02             	shl    $0x2,%eax
    9a8c:	89 c2                	mov    %eax,%edx
    9a8e:	8b 45 08             	mov    0x8(%ebp),%eax
    9a91:	8b 40 4c             	mov    0x4c(%eax),%eax
    9a94:	52                   	push   %edx
    9a95:	50                   	push   %eax
    9a96:	e8 54 9c ff ff       	call   36ef <lodepng_realloc>
    9a9b:	83 c4 08             	add    $0x8,%esp
    9a9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    9aa1:	8b 45 08             	mov    0x8(%ebp),%eax
    9aa4:	8b 40 48             	mov    0x48(%eax),%eax
    9aa7:	83 c0 01             	add    $0x1,%eax
    9aaa:	c1 e0 02             	shl    $0x2,%eax
    9aad:	89 c2                	mov    %eax,%edx
    9aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab2:	8b 40 50             	mov    0x50(%eax),%eax
    9ab5:	52                   	push   %edx
    9ab6:	50                   	push   %eax
    9ab7:	e8 33 9c ff ff       	call   36ef <lodepng_realloc>
    9abc:	83 c4 08             	add    $0x8,%esp
    9abf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    9ac2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ac5:	8b 40 48             	mov    0x48(%eax),%eax
    9ac8:	83 c0 01             	add    $0x1,%eax
    9acb:	c1 e0 02             	shl    $0x2,%eax
    9ace:	89 c2                	mov    %eax,%edx
    9ad0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad3:	8b 40 54             	mov    0x54(%eax),%eax
    9ad6:	52                   	push   %edx
    9ad7:	50                   	push   %eax
    9ad8:	e8 12 9c ff ff       	call   36ef <lodepng_realloc>
    9add:	83 c4 08             	add    $0x8,%esp
    9ae0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    9ae3:	8b 45 08             	mov    0x8(%ebp),%eax
    9ae6:	8b 40 48             	mov    0x48(%eax),%eax
    9ae9:	83 c0 01             	add    $0x1,%eax
    9aec:	c1 e0 02             	shl    $0x2,%eax
    9aef:	89 c2                	mov    %eax,%edx
    9af1:	8b 45 08             	mov    0x8(%ebp),%eax
    9af4:	8b 40 58             	mov    0x58(%eax),%eax
    9af7:	52                   	push   %edx
    9af8:	50                   	push   %eax
    9af9:	e8 f1 9b ff ff       	call   36ef <lodepng_realloc>
    9afe:	83 c4 08             	add    $0x8,%esp
    9b01:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    9b04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9b08:	74 09                	je     9b13 <lodepng_add_itext_sized+0x9a>
    9b0a:	8b 45 08             	mov    0x8(%ebp),%eax
    9b0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9b10:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    9b13:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b17:	74 09                	je     9b22 <lodepng_add_itext_sized+0xa9>
    9b19:	8b 45 08             	mov    0x8(%ebp),%eax
    9b1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9b1f:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    9b22:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9b26:	74 09                	je     9b31 <lodepng_add_itext_sized+0xb8>
    9b28:	8b 45 08             	mov    0x8(%ebp),%eax
    9b2b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9b2e:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    9b31:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9b35:	74 09                	je     9b40 <lodepng_add_itext_sized+0xc7>
    9b37:	8b 45 08             	mov    0x8(%ebp),%eax
    9b3a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9b3d:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    9b40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9b44:	74 12                	je     9b58 <lodepng_add_itext_sized+0xdf>
    9b46:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b4a:	74 0c                	je     9b58 <lodepng_add_itext_sized+0xdf>
    9b4c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9b50:	74 06                	je     9b58 <lodepng_add_itext_sized+0xdf>
    9b52:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9b56:	75 0a                	jne    9b62 <lodepng_add_itext_sized+0xe9>
    9b58:	b8 53 00 00 00       	mov    $0x53,%eax
    9b5d:	e9 b3 00 00 00       	jmp    9c15 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    9b62:	8b 45 08             	mov    0x8(%ebp),%eax
    9b65:	8b 40 48             	mov    0x48(%eax),%eax
    9b68:	8d 50 01             	lea    0x1(%eax),%edx
    9b6b:	8b 45 08             	mov    0x8(%ebp),%eax
    9b6e:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    9b71:	8b 45 08             	mov    0x8(%ebp),%eax
    9b74:	8b 50 4c             	mov    0x4c(%eax),%edx
    9b77:	8b 45 08             	mov    0x8(%ebp),%eax
    9b7a:	8b 40 48             	mov    0x48(%eax),%eax
    9b7d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9b82:	c1 e0 02             	shl    $0x2,%eax
    9b85:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9b88:	83 ec 0c             	sub    $0xc,%esp
    9b8b:	ff 75 0c             	pushl  0xc(%ebp)
    9b8e:	e8 a1 9e ff ff       	call   3a34 <alloc_string>
    9b93:	83 c4 10             	add    $0x10,%esp
    9b96:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    9b98:	8b 45 08             	mov    0x8(%ebp),%eax
    9b9b:	8b 50 50             	mov    0x50(%eax),%edx
    9b9e:	8b 45 08             	mov    0x8(%ebp),%eax
    9ba1:	8b 40 48             	mov    0x48(%eax),%eax
    9ba4:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9ba9:	c1 e0 02             	shl    $0x2,%eax
    9bac:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9baf:	83 ec 0c             	sub    $0xc,%esp
    9bb2:	ff 75 10             	pushl  0x10(%ebp)
    9bb5:	e8 7a 9e ff ff       	call   3a34 <alloc_string>
    9bba:	83 c4 10             	add    $0x10,%esp
    9bbd:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    9bbf:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc2:	8b 50 54             	mov    0x54(%eax),%edx
    9bc5:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc8:	8b 40 48             	mov    0x48(%eax),%eax
    9bcb:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9bd0:	c1 e0 02             	shl    $0x2,%eax
    9bd3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9bd6:	83 ec 0c             	sub    $0xc,%esp
    9bd9:	ff 75 14             	pushl  0x14(%ebp)
    9bdc:	e8 53 9e ff ff       	call   3a34 <alloc_string>
    9be1:	83 c4 10             	add    $0x10,%esp
    9be4:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9be6:	8b 45 08             	mov    0x8(%ebp),%eax
    9be9:	8b 50 58             	mov    0x58(%eax),%edx
    9bec:	8b 45 08             	mov    0x8(%ebp),%eax
    9bef:	8b 40 48             	mov    0x48(%eax),%eax
    9bf2:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9bf7:	c1 e0 02             	shl    $0x2,%eax
    9bfa:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9bfd:	83 ec 08             	sub    $0x8,%esp
    9c00:	ff 75 1c             	pushl  0x1c(%ebp)
    9c03:	ff 75 18             	pushl  0x18(%ebp)
    9c06:	e8 e4 9d ff ff       	call   39ef <alloc_string_sized>
    9c0b:	83 c4 10             	add    $0x10,%esp
    9c0e:	89 03                	mov    %eax,(%ebx)

  return 0;
    9c10:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9c15:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9c18:	c9                   	leave  
    9c19:	c3                   	ret    

00009c1a <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9c1a:	55                   	push   %ebp
    9c1b:	89 e5                	mov    %esp,%ebp
    9c1d:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    9c20:	ff 75 18             	pushl  0x18(%ebp)
    9c23:	e8 4c 9b ff ff       	call   3774 <lodepng_strlen>
    9c28:	83 c4 04             	add    $0x4,%esp
    9c2b:	83 ec 08             	sub    $0x8,%esp
    9c2e:	50                   	push   %eax
    9c2f:	ff 75 18             	pushl  0x18(%ebp)
    9c32:	ff 75 14             	pushl  0x14(%ebp)
    9c35:	ff 75 10             	pushl  0x10(%ebp)
    9c38:	ff 75 0c             	pushl  0xc(%ebp)
    9c3b:	ff 75 08             	pushl  0x8(%ebp)
    9c3e:	e8 36 fe ff ff       	call   9a79 <lodepng_add_itext_sized>
    9c43:	83 c4 20             	add    $0x20,%esp
}
    9c46:	c9                   	leave  
    9c47:	c3                   	ret    

00009c48 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9c48:	55                   	push   %ebp
    9c49:	89 e5                	mov    %esp,%ebp
    9c4b:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9c4e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    9c52:	75 0a                	jne    9c5e <lodepng_assign_icc+0x16>
    9c54:	b8 64 00 00 00       	mov    $0x64,%eax
    9c59:	e9 81 00 00 00       	jmp    9cdf <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9c5e:	83 ec 0c             	sub    $0xc,%esp
    9c61:	ff 75 0c             	pushl  0xc(%ebp)
    9c64:	e8 cb 9d ff ff       	call   3a34 <alloc_string>
    9c69:	83 c4 10             	add    $0x10,%esp
    9c6c:	89 c2                	mov    %eax,%edx
    9c6e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c71:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    9c77:	8b 45 14             	mov    0x14(%ebp),%eax
    9c7a:	83 ec 0c             	sub    $0xc,%esp
    9c7d:	50                   	push   %eax
    9c7e:	e8 55 9a ff ff       	call   36d8 <lodepng_malloc>
    9c83:	83 c4 10             	add    $0x10,%esp
    9c86:	89 c2                	mov    %eax,%edx
    9c88:	8b 45 08             	mov    0x8(%ebp),%eax
    9c8b:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    9c91:	8b 45 08             	mov    0x8(%ebp),%eax
    9c94:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9c9a:	85 c0                	test   %eax,%eax
    9c9c:	74 0d                	je     9cab <lodepng_assign_icc+0x63>
    9c9e:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca1:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9ca7:	85 c0                	test   %eax,%eax
    9ca9:	75 07                	jne    9cb2 <lodepng_assign_icc+0x6a>
    9cab:	b8 53 00 00 00       	mov    $0x53,%eax
    9cb0:	eb 2d                	jmp    9cdf <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    9cb2:	8b 55 14             	mov    0x14(%ebp),%edx
    9cb5:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb8:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9cbe:	83 ec 04             	sub    $0x4,%esp
    9cc1:	52                   	push   %edx
    9cc2:	ff 75 10             	pushl  0x10(%ebp)
    9cc5:	50                   	push   %eax
    9cc6:	e8 4b 9a ff ff       	call   3716 <lodepng_memcpy>
    9ccb:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    9cce:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd1:	8b 55 14             	mov    0x14(%ebp),%edx
    9cd4:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9cda:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9cdf:	c9                   	leave  
    9ce0:	c3                   	ret    

00009ce1 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9ce1:	55                   	push   %ebp
    9ce2:	89 e5                	mov    %esp,%ebp
    9ce4:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9ce7:	8b 45 08             	mov    0x8(%ebp),%eax
    9cea:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9cf0:	85 c0                	test   %eax,%eax
    9cf2:	74 0e                	je     9d02 <lodepng_set_icc+0x21>
    9cf4:	83 ec 0c             	sub    $0xc,%esp
    9cf7:	ff 75 08             	pushl  0x8(%ebp)
    9cfa:	e8 26 00 00 00       	call   9d25 <lodepng_clear_icc>
    9cff:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    9d02:	8b 45 08             	mov    0x8(%ebp),%eax
    9d05:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9d0c:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    9d0f:	ff 75 14             	pushl  0x14(%ebp)
    9d12:	ff 75 10             	pushl  0x10(%ebp)
    9d15:	ff 75 0c             	pushl  0xc(%ebp)
    9d18:	ff 75 08             	pushl  0x8(%ebp)
    9d1b:	e8 28 ff ff ff       	call   9c48 <lodepng_assign_icc>
    9d20:	83 c4 10             	add    $0x10,%esp
}
    9d23:	c9                   	leave  
    9d24:	c3                   	ret    

00009d25 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9d25:	55                   	push   %ebp
    9d26:	89 e5                	mov    %esp,%ebp
    9d28:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9d2b:	8b 45 08             	mov    0x8(%ebp),%eax
    9d2e:	05 c0 00 00 00       	add    $0xc0,%eax
    9d33:	83 ec 0c             	sub    $0xc,%esp
    9d36:	50                   	push   %eax
    9d37:	e8 90 9c ff ff       	call   39cc <string_cleanup>
    9d3c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9d3f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d42:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9d48:	83 ec 0c             	sub    $0xc,%esp
    9d4b:	50                   	push   %eax
    9d4c:	e8 a8 99 ff ff       	call   36f9 <lodepng_free>
    9d51:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9d54:	8b 45 08             	mov    0x8(%ebp),%eax
    9d57:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9d5e:	00 00 00 
  info->iccp_profile_size = 0;
    9d61:	8b 45 08             	mov    0x8(%ebp),%eax
    9d64:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9d6b:	00 00 00 
  info->iccp_defined = 0;
    9d6e:	8b 45 08             	mov    0x8(%ebp),%eax
    9d71:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9d78:	00 00 00 
}
    9d7b:	90                   	nop
    9d7c:	c9                   	leave  
    9d7d:	c3                   	ret    

00009d7e <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9d7e:	55                   	push   %ebp
    9d7f:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9d81:	8b 45 08             	mov    0x8(%ebp),%eax
    9d84:	83 c0 0c             	add    $0xc,%eax
    9d87:	50                   	push   %eax
    9d88:	e8 5a f0 ff ff       	call   8de7 <lodepng_color_mode_init>
    9d8d:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9d90:	8b 45 08             	mov    0x8(%ebp),%eax
    9d93:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9d9a:	8b 45 08             	mov    0x8(%ebp),%eax
    9d9d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9da3:	8b 45 08             	mov    0x8(%ebp),%eax
    9da6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9dad:	8b 45 08             	mov    0x8(%ebp),%eax
    9db0:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9db7:	8b 45 08             	mov    0x8(%ebp),%eax
    9dba:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9dc1:	8b 45 08             	mov    0x8(%ebp),%eax
    9dc4:	8b 50 38             	mov    0x38(%eax),%edx
    9dc7:	8b 45 08             	mov    0x8(%ebp),%eax
    9dca:	89 50 34             	mov    %edx,0x34(%eax)
    9dcd:	8b 45 08             	mov    0x8(%ebp),%eax
    9dd0:	8b 50 34             	mov    0x34(%eax),%edx
    9dd3:	8b 45 08             	mov    0x8(%ebp),%eax
    9dd6:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9dd9:	ff 75 08             	pushl  0x8(%ebp)
    9ddc:	e8 2c f8 ff ff       	call   960d <LodePNGText_init>
    9de1:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9de4:	ff 75 08             	pushl  0x8(%ebp)
    9de7:	e8 a8 fa ff ff       	call   9894 <LodePNGIText_init>
    9dec:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9def:	8b 45 08             	mov    0x8(%ebp),%eax
    9df2:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9df9:	8b 45 08             	mov    0x8(%ebp),%eax
    9dfc:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9e03:	8b 45 08             	mov    0x8(%ebp),%eax
    9e06:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9e0d:	00 00 00 
  info->chrm_defined = 0;
    9e10:	8b 45 08             	mov    0x8(%ebp),%eax
    9e13:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9e1a:	00 00 00 
  info->srgb_defined = 0;
    9e1d:	8b 45 08             	mov    0x8(%ebp),%eax
    9e20:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9e27:	00 00 00 
  info->iccp_defined = 0;
    9e2a:	8b 45 08             	mov    0x8(%ebp),%eax
    9e2d:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9e34:	00 00 00 
  info->iccp_name = NULL;
    9e37:	8b 45 08             	mov    0x8(%ebp),%eax
    9e3a:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9e41:	00 00 00 
  info->iccp_profile = NULL;
    9e44:	8b 45 08             	mov    0x8(%ebp),%eax
    9e47:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9e4e:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9e51:	ff 75 08             	pushl  0x8(%ebp)
    9e54:	e8 46 f6 ff ff       	call   949f <LodePNGUnknownChunks_init>
    9e59:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9e5c:	90                   	nop
    9e5d:	c9                   	leave  
    9e5e:	c3                   	ret    

00009e5f <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9e5f:	55                   	push   %ebp
    9e60:	89 e5                	mov    %esp,%ebp
    9e62:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9e65:	8b 45 08             	mov    0x8(%ebp),%eax
    9e68:	83 c0 0c             	add    $0xc,%eax
    9e6b:	83 ec 0c             	sub    $0xc,%esp
    9e6e:	50                   	push   %eax
    9e6f:	e8 66 f0 ff ff       	call   8eda <lodepng_color_mode_cleanup>
    9e74:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9e77:	83 ec 0c             	sub    $0xc,%esp
    9e7a:	ff 75 08             	pushl  0x8(%ebp)
    9e7d:	e8 af f7 ff ff       	call   9631 <LodePNGText_cleanup>
    9e82:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9e85:	83 ec 0c             	sub    $0xc,%esp
    9e88:	ff 75 08             	pushl  0x8(%ebp)
    9e8b:	e8 3c fa ff ff       	call   98cc <LodePNGIText_cleanup>
    9e90:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9e93:	83 ec 0c             	sub    $0xc,%esp
    9e96:	ff 75 08             	pushl  0x8(%ebp)
    9e99:	e8 87 fe ff ff       	call   9d25 <lodepng_clear_icc>
    9e9e:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9ea1:	83 ec 0c             	sub    $0xc,%esp
    9ea4:	ff 75 08             	pushl  0x8(%ebp)
    9ea7:	e8 44 f6 ff ff       	call   94f0 <LodePNGUnknownChunks_cleanup>
    9eac:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9eaf:	90                   	nop
    9eb0:	c9                   	leave  
    9eb1:	c3                   	ret    

00009eb2 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9eb2:	55                   	push   %ebp
    9eb3:	89 e5                	mov    %esp,%ebp
    9eb5:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9eb8:	83 ec 0c             	sub    $0xc,%esp
    9ebb:	ff 75 08             	pushl  0x8(%ebp)
    9ebe:	e8 9c ff ff ff       	call   9e5f <lodepng_info_cleanup>
    9ec3:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9ec6:	83 ec 04             	sub    $0x4,%esp
    9ec9:	68 e4 00 00 00       	push   $0xe4
    9ece:	ff 75 0c             	pushl  0xc(%ebp)
    9ed1:	ff 75 08             	pushl  0x8(%ebp)
    9ed4:	e8 3d 98 ff ff       	call   3716 <lodepng_memcpy>
    9ed9:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9edc:	8b 45 08             	mov    0x8(%ebp),%eax
    9edf:	83 c0 0c             	add    $0xc,%eax
    9ee2:	83 ec 0c             	sub    $0xc,%esp
    9ee5:	50                   	push   %eax
    9ee6:	e8 fc ee ff ff       	call   8de7 <lodepng_color_mode_init>
    9eeb:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9eee:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ef1:	8d 50 0c             	lea    0xc(%eax),%edx
    9ef4:	8b 45 08             	mov    0x8(%ebp),%eax
    9ef7:	83 c0 0c             	add    $0xc,%eax
    9efa:	83 ec 08             	sub    $0x8,%esp
    9efd:	52                   	push   %edx
    9efe:	50                   	push   %eax
    9eff:	e8 ed ef ff ff       	call   8ef1 <lodepng_color_mode_copy>
    9f04:	83 c4 10             	add    $0x10,%esp
    9f07:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9f0a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9f0e:	74 08                	je     9f18 <lodepng_info_copy+0x66>
    9f10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f13:	e9 b7 00 00 00       	jmp    9fcf <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9f18:	83 ec 08             	sub    $0x8,%esp
    9f1b:	ff 75 0c             	pushl  0xc(%ebp)
    9f1e:	ff 75 08             	pushl  0x8(%ebp)
    9f21:	e8 84 f7 ff ff       	call   96aa <LodePNGText_copy>
    9f26:	83 c4 10             	add    $0x10,%esp
    9f29:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9f2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9f30:	74 08                	je     9f3a <lodepng_info_copy+0x88>
    9f32:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9f35:	e9 95 00 00 00       	jmp    9fcf <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9f3a:	83 ec 08             	sub    $0x8,%esp
    9f3d:	ff 75 0c             	pushl  0xc(%ebp)
    9f40:	ff 75 08             	pushl  0x8(%ebp)
    9f43:	e8 55 fa ff ff       	call   999d <LodePNGIText_copy>
    9f48:	83 c4 10             	add    $0x10,%esp
    9f4b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9f4e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9f52:	74 05                	je     9f59 <lodepng_info_copy+0xa7>
    9f54:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9f57:	eb 76                	jmp    9fcf <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9f59:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f5c:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9f62:	85 c0                	test   %eax,%eax
    9f64:	74 37                	je     9f9d <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9f66:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f69:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9f6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f72:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9f78:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f7b:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9f81:	51                   	push   %ecx
    9f82:	52                   	push   %edx
    9f83:	50                   	push   %eax
    9f84:	ff 75 08             	pushl  0x8(%ebp)
    9f87:	e8 bc fc ff ff       	call   9c48 <lodepng_assign_icc>
    9f8c:	83 c4 10             	add    $0x10,%esp
    9f8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9f92:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9f96:	74 05                	je     9f9d <lodepng_info_copy+0xeb>
    9f98:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9f9b:	eb 32                	jmp    9fcf <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9f9d:	83 ec 0c             	sub    $0xc,%esp
    9fa0:	ff 75 08             	pushl  0x8(%ebp)
    9fa3:	e8 f7 f4 ff ff       	call   949f <LodePNGUnknownChunks_init>
    9fa8:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9fab:	83 ec 08             	sub    $0x8,%esp
    9fae:	ff 75 0c             	pushl  0xc(%ebp)
    9fb1:	ff 75 08             	pushl  0x8(%ebp)
    9fb4:	e8 6c f5 ff ff       	call   9525 <LodePNGUnknownChunks_copy>
    9fb9:	83 c4 10             	add    $0x10,%esp
    9fbc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9fbf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9fc3:	74 05                	je     9fca <lodepng_info_copy+0x118>
    9fc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9fc8:	eb 05                	jmp    9fcf <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9fca:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9fcf:	c9                   	leave  
    9fd0:	c3                   	ret    

00009fd1 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9fd1:	55                   	push   %ebp
    9fd2:	89 e5                	mov    %esp,%ebp
    9fd4:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9fd7:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9fdb:	74 14                	je     9ff1 <addColorBits+0x20>
    9fdd:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9fe1:	75 07                	jne    9fea <addColorBits+0x19>
    9fe3:	b8 03 00 00 00       	mov    $0x3,%eax
    9fe8:	eb 0c                	jmp    9ff6 <addColorBits+0x25>
    9fea:	b8 01 00 00 00       	mov    $0x1,%eax
    9fef:	eb 05                	jmp    9ff6 <addColorBits+0x25>
    9ff1:	b8 07 00 00 00       	mov    $0x7,%eax
    9ff6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9ff9:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ffc:	23 45 fc             	and    -0x4(%ebp),%eax
    9fff:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    a002:	8b 45 10             	mov    0x10(%ebp),%eax
    a005:	ba 01 00 00 00       	mov    $0x1,%edx
    a00a:	89 c1                	mov    %eax,%ecx
    a00c:	d3 e2                	shl    %cl,%edx
    a00e:	89 d0                	mov    %edx,%eax
    a010:	83 e8 01             	sub    $0x1,%eax
    a013:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    a016:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a019:	2b 45 f8             	sub    -0x8(%ebp),%eax
    a01c:	0f af 45 10          	imul   0x10(%ebp),%eax
    a020:	89 c1                	mov    %eax,%ecx
    a022:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    a025:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a029:	75 18                	jne    a043 <addColorBits+0x72>
    a02b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a02e:	0f af 45 10          	imul   0x10(%ebp),%eax
    a032:	c1 e8 03             	shr    $0x3,%eax
    a035:	89 c2                	mov    %eax,%edx
    a037:	8b 45 08             	mov    0x8(%ebp),%eax
    a03a:	01 d0                	add    %edx,%eax
    a03c:	8b 55 14             	mov    0x14(%ebp),%edx
    a03f:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    a041:	eb 1e                	jmp    a061 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    a043:	8b 45 0c             	mov    0xc(%ebp),%eax
    a046:	0f af 45 10          	imul   0x10(%ebp),%eax
    a04a:	c1 e8 03             	shr    $0x3,%eax
    a04d:	8b 55 08             	mov    0x8(%ebp),%edx
    a050:	01 c2                	add    %eax,%edx
    a052:	8b 4d 08             	mov    0x8(%ebp),%ecx
    a055:	01 c8                	add    %ecx,%eax
    a057:	0f b6 08             	movzbl (%eax),%ecx
    a05a:	8b 45 14             	mov    0x14(%ebp),%eax
    a05d:	09 c8                	or     %ecx,%eax
    a05f:	88 02                	mov    %al,(%edx)
}
    a061:	90                   	nop
    a062:	c9                   	leave  
    a063:	c3                   	ret    

0000a064 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    a064:	55                   	push   %ebp
    a065:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    a067:	8b 45 08             	mov    0x8(%ebp),%eax
    a06a:	6a 40                	push   $0x40
    a06c:	6a 00                	push   $0x0
    a06e:	50                   	push   %eax
    a06f:	e8 d5 96 ff ff       	call   3749 <lodepng_memset>
    a074:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    a077:	8b 45 08             	mov    0x8(%ebp),%eax
    a07a:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    a081:	90                   	nop
    a082:	c9                   	leave  
    a083:	c3                   	ret    

0000a084 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    a084:	55                   	push   %ebp
    a085:	89 e5                	mov    %esp,%ebp
    a087:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    a08a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a091:	eb 3b                	jmp    a0ce <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    a093:	8b 45 08             	mov    0x8(%ebp),%eax
    a096:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a099:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a09c:	85 c0                	test   %eax,%eax
    a09e:	74 2a                	je     a0ca <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    a0a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a0a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a0a6:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a0a9:	83 ec 0c             	sub    $0xc,%esp
    a0ac:	50                   	push   %eax
    a0ad:	e8 d2 ff ff ff       	call   a084 <color_tree_cleanup>
    a0b2:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    a0b5:	8b 45 08             	mov    0x8(%ebp),%eax
    a0b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a0bb:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a0be:	83 ec 0c             	sub    $0xc,%esp
    a0c1:	50                   	push   %eax
    a0c2:	e8 32 96 ff ff       	call   36f9 <lodepng_free>
    a0c7:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    a0ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a0ce:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    a0d2:	75 bf                	jne    a093 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    a0d4:	90                   	nop
    a0d5:	c9                   	leave  
    a0d6:	c3                   	ret    

0000a0d7 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a0d7:	55                   	push   %ebp
    a0d8:	89 e5                	mov    %esp,%ebp
    a0da:	53                   	push   %ebx
    a0db:	83 ec 20             	sub    $0x20,%esp
    a0de:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a0e1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a0e4:	8b 55 14             	mov    0x14(%ebp),%edx
    a0e7:	8b 45 18             	mov    0x18(%ebp),%eax
    a0ea:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a0ed:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a0f0:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a0f3:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    a0f6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    a0fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    a104:	eb 76                	jmp    a17c <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a106:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a10a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a10d:	89 c1                	mov    %eax,%ecx
    a10f:	d3 fa                	sar    %cl,%edx
    a111:	89 d0                	mov    %edx,%eax
    a113:	83 e0 01             	and    $0x1,%eax
    a116:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a119:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a11d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a120:	89 c1                	mov    %eax,%ecx
    a122:	d3 fa                	sar    %cl,%edx
    a124:	89 d0                	mov    %edx,%eax
    a126:	83 e0 01             	and    $0x1,%eax
    a129:	01 d8                	add    %ebx,%eax
    a12b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a12e:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a132:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a135:	89 c1                	mov    %eax,%ecx
    a137:	d3 fa                	sar    %cl,%edx
    a139:	89 d0                	mov    %edx,%eax
    a13b:	83 e0 01             	and    $0x1,%eax
    a13e:	01 d8                	add    %ebx,%eax
    a140:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a143:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a147:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a14a:	89 c1                	mov    %eax,%ecx
    a14c:	d3 fa                	sar    %cl,%edx
    a14e:	89 d0                	mov    %edx,%eax
    a150:	83 e0 01             	and    $0x1,%eax
    a153:	01 d8                	add    %ebx,%eax
    a155:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    a158:	8b 45 08             	mov    0x8(%ebp),%eax
    a15b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a15e:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a161:	85 c0                	test   %eax,%eax
    a163:	75 07                	jne    a16c <color_tree_get+0x95>
    a165:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a16a:	eb 2a                	jmp    a196 <color_tree_get+0xbf>
    else tree = tree->children[i];
    a16c:	8b 45 08             	mov    0x8(%ebp),%eax
    a16f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a172:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a175:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    a178:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a17c:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    a180:	7e 84                	jle    a106 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    a182:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    a186:	74 08                	je     a190 <color_tree_get+0xb9>
    a188:	8b 45 08             	mov    0x8(%ebp),%eax
    a18b:	8b 40 40             	mov    0x40(%eax),%eax
    a18e:	eb 05                	jmp    a195 <color_tree_get+0xbe>
    a190:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a195:	90                   	nop
}
    a196:	83 c4 20             	add    $0x20,%esp
    a199:	5b                   	pop    %ebx
    a19a:	5d                   	pop    %ebp
    a19b:	c3                   	ret    

0000a19c <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a19c:	55                   	push   %ebp
    a19d:	89 e5                	mov    %esp,%ebp
    a19f:	53                   	push   %ebx
    a1a0:	83 ec 10             	sub    $0x10,%esp
    a1a3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a1a6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a1a9:	8b 55 14             	mov    0x14(%ebp),%edx
    a1ac:	8b 45 18             	mov    0x18(%ebp),%eax
    a1af:	88 5d f8             	mov    %bl,-0x8(%ebp)
    a1b2:	88 4d f4             	mov    %cl,-0xc(%ebp)
    a1b5:	88 55 f0             	mov    %dl,-0x10(%ebp)
    a1b8:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    a1bb:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    a1bf:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    a1c3:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    a1c7:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    a1cb:	53                   	push   %ebx
    a1cc:	51                   	push   %ecx
    a1cd:	52                   	push   %edx
    a1ce:	50                   	push   %eax
    a1cf:	ff 75 08             	pushl  0x8(%ebp)
    a1d2:	e8 00 ff ff ff       	call   a0d7 <color_tree_get>
    a1d7:	83 c4 14             	add    $0x14,%esp
    a1da:	f7 d0                	not    %eax
    a1dc:	c1 e8 1f             	shr    $0x1f,%eax
    a1df:	0f b6 c0             	movzbl %al,%eax
}
    a1e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a1e5:	c9                   	leave  
    a1e6:	c3                   	ret    

0000a1e7 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    a1e7:	55                   	push   %ebp
    a1e8:	89 e5                	mov    %esp,%ebp
    a1ea:	53                   	push   %ebx
    a1eb:	83 ec 24             	sub    $0x24,%esp
    a1ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a1f1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a1f4:	8b 55 14             	mov    0x14(%ebp),%edx
    a1f7:	8b 45 18             	mov    0x18(%ebp),%eax
    a1fa:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    a1fd:	88 4d e0             	mov    %cl,-0x20(%ebp)
    a200:	88 55 dc             	mov    %dl,-0x24(%ebp)
    a203:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a206:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a20d:	e9 b0 00 00 00       	jmp    a2c2 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a212:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a216:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a219:	89 c1                	mov    %eax,%ecx
    a21b:	d3 fa                	sar    %cl,%edx
    a21d:	89 d0                	mov    %edx,%eax
    a21f:	83 e0 01             	and    $0x1,%eax
    a222:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a225:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a229:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a22c:	89 c1                	mov    %eax,%ecx
    a22e:	d3 fa                	sar    %cl,%edx
    a230:	89 d0                	mov    %edx,%eax
    a232:	83 e0 01             	and    $0x1,%eax
    a235:	01 d8                	add    %ebx,%eax
    a237:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a23a:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a23e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a241:	89 c1                	mov    %eax,%ecx
    a243:	d3 fa                	sar    %cl,%edx
    a245:	89 d0                	mov    %edx,%eax
    a247:	83 e0 01             	and    $0x1,%eax
    a24a:	01 d8                	add    %ebx,%eax
    a24c:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a24f:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    a253:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a256:	89 c1                	mov    %eax,%ecx
    a258:	d3 fa                	sar    %cl,%edx
    a25a:	89 d0                	mov    %edx,%eax
    a25c:	83 e0 01             	and    $0x1,%eax
    a25f:	01 d8                	add    %ebx,%eax
    a261:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    a264:	8b 45 08             	mov    0x8(%ebp),%eax
    a267:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a26a:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a26d:	85 c0                	test   %eax,%eax
    a26f:	75 41                	jne    a2b2 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    a271:	83 ec 0c             	sub    $0xc,%esp
    a274:	6a 44                	push   $0x44
    a276:	e8 5d 94 ff ff       	call   36d8 <lodepng_malloc>
    a27b:	83 c4 10             	add    $0x10,%esp
    a27e:	89 c1                	mov    %eax,%ecx
    a280:	8b 45 08             	mov    0x8(%ebp),%eax
    a283:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a286:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    a289:	8b 45 08             	mov    0x8(%ebp),%eax
    a28c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a28f:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a292:	85 c0                	test   %eax,%eax
    a294:	75 07                	jne    a29d <color_tree_add+0xb6>
    a296:	b8 53 00 00 00       	mov    $0x53,%eax
    a29b:	eb 3d                	jmp    a2da <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    a29d:	8b 45 08             	mov    0x8(%ebp),%eax
    a2a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a2a3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a2a6:	83 ec 0c             	sub    $0xc,%esp
    a2a9:	50                   	push   %eax
    a2aa:	e8 b5 fd ff ff       	call   a064 <color_tree_init>
    a2af:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    a2b2:	8b 45 08             	mov    0x8(%ebp),%eax
    a2b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a2b8:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a2bb:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a2be:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a2c2:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    a2c6:	0f 8e 46 ff ff ff    	jle    a212 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    a2cc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a2cf:	8b 45 08             	mov    0x8(%ebp),%eax
    a2d2:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    a2d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a2da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a2dd:	c9                   	leave  
    a2de:	c3                   	ret    

0000a2df <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a2df:	55                   	push   %ebp
    a2e0:	89 e5                	mov    %esp,%ebp
    a2e2:	53                   	push   %ebx
    a2e3:	83 ec 20             	sub    $0x20,%esp
    a2e6:	8b 5d 18             	mov    0x18(%ebp),%ebx
    a2e9:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    a2ec:	8b 55 20             	mov    0x20(%ebp),%edx
    a2ef:	8b 45 24             	mov    0x24(%ebp),%eax
    a2f2:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a2f5:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a2f8:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a2fb:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a2fe:	8b 45 10             	mov    0x10(%ebp),%eax
    a301:	8b 00                	mov    (%eax),%eax
    a303:	85 c0                	test   %eax,%eax
    a305:	0f 85 ad 00 00 00    	jne    a3b8 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a30b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a30f:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    a312:	8b 45 10             	mov    0x10(%ebp),%eax
    a315:	8b 40 04             	mov    0x4(%eax),%eax
    a318:	83 f8 08             	cmp    $0x8,%eax
    a31b:	75 13                	jne    a330 <rgba8ToPixel+0x51>
    a31d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a320:	8b 45 08             	mov    0x8(%ebp),%eax
    a323:	01 c2                	add    %eax,%edx
    a325:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a329:	88 02                	mov    %al,(%edx)
    a32b:	e9 b4 03 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a330:	8b 45 10             	mov    0x10(%ebp),%eax
    a333:	8b 40 04             	mov    0x4(%eax),%eax
    a336:	83 f8 10             	cmp    $0x10,%eax
    a339:	75 2a                	jne    a365 <rgba8ToPixel+0x86>
    a33b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a33e:	01 c0                	add    %eax,%eax
    a340:	89 c2                	mov    %eax,%edx
    a342:	8b 45 08             	mov    0x8(%ebp),%eax
    a345:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a348:	8b 45 0c             	mov    0xc(%ebp),%eax
    a34b:	01 c0                	add    %eax,%eax
    a34d:	8d 50 01             	lea    0x1(%eax),%edx
    a350:	8b 45 08             	mov    0x8(%ebp),%eax
    a353:	01 d0                	add    %edx,%eax
    a355:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a359:	88 10                	mov    %dl,(%eax)
    a35b:	0f b6 00             	movzbl (%eax),%eax
    a35e:	88 01                	mov    %al,(%ecx)
    a360:	e9 7f 03 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a365:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a369:	8b 45 10             	mov    0x10(%ebp),%eax
    a36c:	8b 40 04             	mov    0x4(%eax),%eax
    a36f:	b9 08 00 00 00       	mov    $0x8,%ecx
    a374:	29 c1                	sub    %eax,%ecx
    a376:	89 c8                	mov    %ecx,%eax
    a378:	89 c1                	mov    %eax,%ecx
    a37a:	d3 ea                	shr    %cl,%edx
    a37c:	89 d0                	mov    %edx,%eax
    a37e:	89 c2                	mov    %eax,%edx
    a380:	8b 45 10             	mov    0x10(%ebp),%eax
    a383:	8b 40 04             	mov    0x4(%eax),%eax
    a386:	bb 01 00 00 00       	mov    $0x1,%ebx
    a38b:	89 c1                	mov    %eax,%ecx
    a38d:	d3 e3                	shl    %cl,%ebx
    a38f:	89 d8                	mov    %ebx,%eax
    a391:	83 e8 01             	sub    $0x1,%eax
    a394:	21 d0                	and    %edx,%eax
    a396:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a399:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a39d:	8b 45 10             	mov    0x10(%ebp),%eax
    a3a0:	8b 40 04             	mov    0x4(%eax),%eax
    a3a3:	52                   	push   %edx
    a3a4:	50                   	push   %eax
    a3a5:	ff 75 0c             	pushl  0xc(%ebp)
    a3a8:	ff 75 08             	pushl  0x8(%ebp)
    a3ab:	e8 21 fc ff ff       	call   9fd1 <addColorBits>
    a3b0:	83 c4 10             	add    $0x10,%esp
    a3b3:	e9 2c 03 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a3b8:	8b 45 10             	mov    0x10(%ebp),%eax
    a3bb:	8b 00                	mov    (%eax),%eax
    a3bd:	83 f8 02             	cmp    $0x2,%eax
    a3c0:	0f 85 ee 00 00 00    	jne    a4b4 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a3c6:	8b 45 10             	mov    0x10(%ebp),%eax
    a3c9:	8b 40 04             	mov    0x4(%eax),%eax
    a3cc:	83 f8 08             	cmp    $0x8,%eax
    a3cf:	75 49                	jne    a41a <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a3d1:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3d4:	89 d0                	mov    %edx,%eax
    a3d6:	01 c0                	add    %eax,%eax
    a3d8:	01 d0                	add    %edx,%eax
    a3da:	89 c2                	mov    %eax,%edx
    a3dc:	8b 45 08             	mov    0x8(%ebp),%eax
    a3df:	01 c2                	add    %eax,%edx
    a3e1:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a3e5:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a3e7:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3ea:	89 d0                	mov    %edx,%eax
    a3ec:	01 c0                	add    %eax,%eax
    a3ee:	01 d0                	add    %edx,%eax
    a3f0:	8d 50 01             	lea    0x1(%eax),%edx
    a3f3:	8b 45 08             	mov    0x8(%ebp),%eax
    a3f6:	01 c2                	add    %eax,%edx
    a3f8:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a3fc:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a3fe:	8b 55 0c             	mov    0xc(%ebp),%edx
    a401:	89 d0                	mov    %edx,%eax
    a403:	01 c0                	add    %eax,%eax
    a405:	01 d0                	add    %edx,%eax
    a407:	8d 50 02             	lea    0x2(%eax),%edx
    a40a:	8b 45 08             	mov    0x8(%ebp),%eax
    a40d:	01 c2                	add    %eax,%edx
    a40f:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a413:	88 02                	mov    %al,(%edx)
    a415:	e9 ca 02 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a41a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a41d:	89 d0                	mov    %edx,%eax
    a41f:	01 c0                	add    %eax,%eax
    a421:	01 d0                	add    %edx,%eax
    a423:	01 c0                	add    %eax,%eax
    a425:	89 c2                	mov    %eax,%edx
    a427:	8b 45 08             	mov    0x8(%ebp),%eax
    a42a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a42d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a430:	89 d0                	mov    %edx,%eax
    a432:	01 c0                	add    %eax,%eax
    a434:	01 d0                	add    %edx,%eax
    a436:	01 c0                	add    %eax,%eax
    a438:	8d 50 01             	lea    0x1(%eax),%edx
    a43b:	8b 45 08             	mov    0x8(%ebp),%eax
    a43e:	01 d0                	add    %edx,%eax
    a440:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a444:	88 10                	mov    %dl,(%eax)
    a446:	0f b6 00             	movzbl (%eax),%eax
    a449:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a44b:	8b 55 0c             	mov    0xc(%ebp),%edx
    a44e:	89 d0                	mov    %edx,%eax
    a450:	01 c0                	add    %eax,%eax
    a452:	01 d0                	add    %edx,%eax
    a454:	01 c0                	add    %eax,%eax
    a456:	8d 50 02             	lea    0x2(%eax),%edx
    a459:	8b 45 08             	mov    0x8(%ebp),%eax
    a45c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a45f:	8b 55 0c             	mov    0xc(%ebp),%edx
    a462:	89 d0                	mov    %edx,%eax
    a464:	01 c0                	add    %eax,%eax
    a466:	01 d0                	add    %edx,%eax
    a468:	01 c0                	add    %eax,%eax
    a46a:	8d 50 03             	lea    0x3(%eax),%edx
    a46d:	8b 45 08             	mov    0x8(%ebp),%eax
    a470:	01 d0                	add    %edx,%eax
    a472:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a476:	88 10                	mov    %dl,(%eax)
    a478:	0f b6 00             	movzbl (%eax),%eax
    a47b:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a47d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a480:	89 d0                	mov    %edx,%eax
    a482:	01 c0                	add    %eax,%eax
    a484:	01 d0                	add    %edx,%eax
    a486:	01 c0                	add    %eax,%eax
    a488:	8d 50 04             	lea    0x4(%eax),%edx
    a48b:	8b 45 08             	mov    0x8(%ebp),%eax
    a48e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a491:	8b 55 0c             	mov    0xc(%ebp),%edx
    a494:	89 d0                	mov    %edx,%eax
    a496:	01 c0                	add    %eax,%eax
    a498:	01 d0                	add    %edx,%eax
    a49a:	01 c0                	add    %eax,%eax
    a49c:	8d 50 05             	lea    0x5(%eax),%edx
    a49f:	8b 45 08             	mov    0x8(%ebp),%eax
    a4a2:	01 d0                	add    %edx,%eax
    a4a4:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a4a8:	88 10                	mov    %dl,(%eax)
    a4aa:	0f b6 00             	movzbl (%eax),%eax
    a4ad:	88 01                	mov    %al,(%ecx)
    a4af:	e9 30 02 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a4b4:	8b 45 10             	mov    0x10(%ebp),%eax
    a4b7:	8b 00                	mov    (%eax),%eax
    a4b9:	83 f8 03             	cmp    $0x3,%eax
    a4bc:	75 6d                	jne    a52b <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a4be:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a4c2:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a4c6:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a4ca:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a4ce:	53                   	push   %ebx
    a4cf:	51                   	push   %ecx
    a4d0:	52                   	push   %edx
    a4d1:	50                   	push   %eax
    a4d2:	ff 75 14             	pushl  0x14(%ebp)
    a4d5:	e8 fd fb ff ff       	call   a0d7 <color_tree_get>
    a4da:	83 c4 14             	add    $0x14,%esp
    a4dd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a4e0:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a4e4:	79 0a                	jns    a4f0 <rgba8ToPixel+0x211>
    a4e6:	b8 52 00 00 00       	mov    $0x52,%eax
    a4eb:	e9 f9 01 00 00       	jmp    a6e9 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a4f0:	8b 45 10             	mov    0x10(%ebp),%eax
    a4f3:	8b 40 04             	mov    0x4(%eax),%eax
    a4f6:	83 f8 08             	cmp    $0x8,%eax
    a4f9:	75 12                	jne    a50d <rgba8ToPixel+0x22e>
    a4fb:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4fe:	8b 45 08             	mov    0x8(%ebp),%eax
    a501:	01 d0                	add    %edx,%eax
    a503:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a506:	88 10                	mov    %dl,(%eax)
    a508:	e9 d7 01 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a50d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a510:	8b 45 10             	mov    0x10(%ebp),%eax
    a513:	8b 40 04             	mov    0x4(%eax),%eax
    a516:	52                   	push   %edx
    a517:	50                   	push   %eax
    a518:	ff 75 0c             	pushl  0xc(%ebp)
    a51b:	ff 75 08             	pushl  0x8(%ebp)
    a51e:	e8 ae fa ff ff       	call   9fd1 <addColorBits>
    a523:	83 c4 10             	add    $0x10,%esp
    a526:	e9 b9 01 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a52b:	8b 45 10             	mov    0x10(%ebp),%eax
    a52e:	8b 00                	mov    (%eax),%eax
    a530:	83 f8 04             	cmp    $0x4,%eax
    a533:	0f 85 9f 00 00 00    	jne    a5d8 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a539:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a53d:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a540:	8b 45 10             	mov    0x10(%ebp),%eax
    a543:	8b 40 04             	mov    0x4(%eax),%eax
    a546:	83 f8 08             	cmp    $0x8,%eax
    a549:	75 2a                	jne    a575 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a54b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a54e:	01 c0                	add    %eax,%eax
    a550:	89 c2                	mov    %eax,%edx
    a552:	8b 45 08             	mov    0x8(%ebp),%eax
    a555:	01 c2                	add    %eax,%edx
    a557:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a55b:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a55d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a560:	01 c0                	add    %eax,%eax
    a562:	8d 50 01             	lea    0x1(%eax),%edx
    a565:	8b 45 08             	mov    0x8(%ebp),%eax
    a568:	01 c2                	add    %eax,%edx
    a56a:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a56e:	88 02                	mov    %al,(%edx)
    a570:	e9 6f 01 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a575:	8b 45 10             	mov    0x10(%ebp),%eax
    a578:	8b 40 04             	mov    0x4(%eax),%eax
    a57b:	83 f8 10             	cmp    $0x10,%eax
    a57e:	0f 85 60 01 00 00    	jne    a6e4 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a584:	8b 45 0c             	mov    0xc(%ebp),%eax
    a587:	c1 e0 02             	shl    $0x2,%eax
    a58a:	89 c2                	mov    %eax,%edx
    a58c:	8b 45 08             	mov    0x8(%ebp),%eax
    a58f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a592:	8b 45 0c             	mov    0xc(%ebp),%eax
    a595:	c1 e0 02             	shl    $0x2,%eax
    a598:	8d 50 01             	lea    0x1(%eax),%edx
    a59b:	8b 45 08             	mov    0x8(%ebp),%eax
    a59e:	01 d0                	add    %edx,%eax
    a5a0:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a5a4:	88 10                	mov    %dl,(%eax)
    a5a6:	0f b6 00             	movzbl (%eax),%eax
    a5a9:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a5ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5ae:	c1 e0 02             	shl    $0x2,%eax
    a5b1:	8d 50 02             	lea    0x2(%eax),%edx
    a5b4:	8b 45 08             	mov    0x8(%ebp),%eax
    a5b7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a5ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5bd:	c1 e0 02             	shl    $0x2,%eax
    a5c0:	8d 50 03             	lea    0x3(%eax),%edx
    a5c3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c6:	01 d0                	add    %edx,%eax
    a5c8:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a5cc:	88 10                	mov    %dl,(%eax)
    a5ce:	0f b6 00             	movzbl (%eax),%eax
    a5d1:	88 01                	mov    %al,(%ecx)
    a5d3:	e9 0c 01 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a5d8:	8b 45 10             	mov    0x10(%ebp),%eax
    a5db:	8b 00                	mov    (%eax),%eax
    a5dd:	83 f8 06             	cmp    $0x6,%eax
    a5e0:	0f 85 fe 00 00 00    	jne    a6e4 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a5e6:	8b 45 10             	mov    0x10(%ebp),%eax
    a5e9:	8b 40 04             	mov    0x4(%eax),%eax
    a5ec:	83 f8 08             	cmp    $0x8,%eax
    a5ef:	75 54                	jne    a645 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a5f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5f4:	c1 e0 02             	shl    $0x2,%eax
    a5f7:	89 c2                	mov    %eax,%edx
    a5f9:	8b 45 08             	mov    0x8(%ebp),%eax
    a5fc:	01 c2                	add    %eax,%edx
    a5fe:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a602:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a604:	8b 45 0c             	mov    0xc(%ebp),%eax
    a607:	c1 e0 02             	shl    $0x2,%eax
    a60a:	8d 50 01             	lea    0x1(%eax),%edx
    a60d:	8b 45 08             	mov    0x8(%ebp),%eax
    a610:	01 c2                	add    %eax,%edx
    a612:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a616:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a618:	8b 45 0c             	mov    0xc(%ebp),%eax
    a61b:	c1 e0 02             	shl    $0x2,%eax
    a61e:	8d 50 02             	lea    0x2(%eax),%edx
    a621:	8b 45 08             	mov    0x8(%ebp),%eax
    a624:	01 c2                	add    %eax,%edx
    a626:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a62a:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a62c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a62f:	c1 e0 02             	shl    $0x2,%eax
    a632:	8d 50 03             	lea    0x3(%eax),%edx
    a635:	8b 45 08             	mov    0x8(%ebp),%eax
    a638:	01 c2                	add    %eax,%edx
    a63a:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a63e:	88 02                	mov    %al,(%edx)
    a640:	e9 9f 00 00 00       	jmp    a6e4 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a645:	8b 45 0c             	mov    0xc(%ebp),%eax
    a648:	c1 e0 03             	shl    $0x3,%eax
    a64b:	89 c2                	mov    %eax,%edx
    a64d:	8b 45 08             	mov    0x8(%ebp),%eax
    a650:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a653:	8b 45 0c             	mov    0xc(%ebp),%eax
    a656:	c1 e0 03             	shl    $0x3,%eax
    a659:	8d 50 01             	lea    0x1(%eax),%edx
    a65c:	8b 45 08             	mov    0x8(%ebp),%eax
    a65f:	01 d0                	add    %edx,%eax
    a661:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a665:	88 10                	mov    %dl,(%eax)
    a667:	0f b6 00             	movzbl (%eax),%eax
    a66a:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a66c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a66f:	c1 e0 03             	shl    $0x3,%eax
    a672:	8d 50 02             	lea    0x2(%eax),%edx
    a675:	8b 45 08             	mov    0x8(%ebp),%eax
    a678:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a67b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a67e:	c1 e0 03             	shl    $0x3,%eax
    a681:	8d 50 03             	lea    0x3(%eax),%edx
    a684:	8b 45 08             	mov    0x8(%ebp),%eax
    a687:	01 d0                	add    %edx,%eax
    a689:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a68d:	88 10                	mov    %dl,(%eax)
    a68f:	0f b6 00             	movzbl (%eax),%eax
    a692:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a694:	8b 45 0c             	mov    0xc(%ebp),%eax
    a697:	c1 e0 03             	shl    $0x3,%eax
    a69a:	8d 50 04             	lea    0x4(%eax),%edx
    a69d:	8b 45 08             	mov    0x8(%ebp),%eax
    a6a0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a6a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6a6:	c1 e0 03             	shl    $0x3,%eax
    a6a9:	8d 50 05             	lea    0x5(%eax),%edx
    a6ac:	8b 45 08             	mov    0x8(%ebp),%eax
    a6af:	01 d0                	add    %edx,%eax
    a6b1:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a6b5:	88 10                	mov    %dl,(%eax)
    a6b7:	0f b6 00             	movzbl (%eax),%eax
    a6ba:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a6bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6bf:	c1 e0 03             	shl    $0x3,%eax
    a6c2:	8d 50 06             	lea    0x6(%eax),%edx
    a6c5:	8b 45 08             	mov    0x8(%ebp),%eax
    a6c8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a6cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6ce:	c1 e0 03             	shl    $0x3,%eax
    a6d1:	8d 50 07             	lea    0x7(%eax),%edx
    a6d4:	8b 45 08             	mov    0x8(%ebp),%eax
    a6d7:	01 d0                	add    %edx,%eax
    a6d9:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a6dd:	88 10                	mov    %dl,(%eax)
    a6df:	0f b6 00             	movzbl (%eax),%eax
    a6e2:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a6e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a6e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a6ec:	c9                   	leave  
    a6ed:	c3                   	ret    

0000a6ee <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a6ee:	55                   	push   %ebp
    a6ef:	89 e5                	mov    %esp,%ebp
    a6f1:	53                   	push   %ebx
    a6f2:	83 ec 20             	sub    $0x20,%esp
    a6f5:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a6f8:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a6fb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a6fe:	8b 45 20             	mov    0x20(%ebp),%eax
    a701:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a705:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a709:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a70d:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a711:	8b 45 10             	mov    0x10(%ebp),%eax
    a714:	8b 00                	mov    (%eax),%eax
    a716:	85 c0                	test   %eax,%eax
    a718:	75 36                	jne    a750 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a71a:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a71e:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a722:	8b 45 0c             	mov    0xc(%ebp),%eax
    a725:	01 c0                	add    %eax,%eax
    a727:	89 c2                	mov    %eax,%edx
    a729:	8b 45 08             	mov    0x8(%ebp),%eax
    a72c:	01 d0                	add    %edx,%eax
    a72e:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a732:	66 c1 ea 08          	shr    $0x8,%dx
    a736:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a738:	8b 45 0c             	mov    0xc(%ebp),%eax
    a73b:	01 c0                	add    %eax,%eax
    a73d:	8d 50 01             	lea    0x1(%eax),%edx
    a740:	8b 45 08             	mov    0x8(%ebp),%eax
    a743:	01 d0                	add    %edx,%eax
    a745:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a749:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a74b:	e9 df 01 00 00       	jmp    a92f <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a750:	8b 45 10             	mov    0x10(%ebp),%eax
    a753:	8b 00                	mov    (%eax),%eax
    a755:	83 f8 02             	cmp    $0x2,%eax
    a758:	0f 85 a6 00 00 00    	jne    a804 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a75e:	8b 55 0c             	mov    0xc(%ebp),%edx
    a761:	89 d0                	mov    %edx,%eax
    a763:	01 c0                	add    %eax,%eax
    a765:	01 d0                	add    %edx,%eax
    a767:	01 c0                	add    %eax,%eax
    a769:	89 c2                	mov    %eax,%edx
    a76b:	8b 45 08             	mov    0x8(%ebp),%eax
    a76e:	01 d0                	add    %edx,%eax
    a770:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a774:	66 c1 ea 08          	shr    $0x8,%dx
    a778:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a77a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a77d:	89 d0                	mov    %edx,%eax
    a77f:	01 c0                	add    %eax,%eax
    a781:	01 d0                	add    %edx,%eax
    a783:	01 c0                	add    %eax,%eax
    a785:	8d 50 01             	lea    0x1(%eax),%edx
    a788:	8b 45 08             	mov    0x8(%ebp),%eax
    a78b:	01 d0                	add    %edx,%eax
    a78d:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a791:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a793:	8b 55 0c             	mov    0xc(%ebp),%edx
    a796:	89 d0                	mov    %edx,%eax
    a798:	01 c0                	add    %eax,%eax
    a79a:	01 d0                	add    %edx,%eax
    a79c:	01 c0                	add    %eax,%eax
    a79e:	8d 50 02             	lea    0x2(%eax),%edx
    a7a1:	8b 45 08             	mov    0x8(%ebp),%eax
    a7a4:	01 d0                	add    %edx,%eax
    a7a6:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a7aa:	66 c1 ea 08          	shr    $0x8,%dx
    a7ae:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a7b0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a7b3:	89 d0                	mov    %edx,%eax
    a7b5:	01 c0                	add    %eax,%eax
    a7b7:	01 d0                	add    %edx,%eax
    a7b9:	01 c0                	add    %eax,%eax
    a7bb:	8d 50 03             	lea    0x3(%eax),%edx
    a7be:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c1:	01 d0                	add    %edx,%eax
    a7c3:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a7c7:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a7c9:	8b 55 0c             	mov    0xc(%ebp),%edx
    a7cc:	89 d0                	mov    %edx,%eax
    a7ce:	01 c0                	add    %eax,%eax
    a7d0:	01 d0                	add    %edx,%eax
    a7d2:	01 c0                	add    %eax,%eax
    a7d4:	8d 50 04             	lea    0x4(%eax),%edx
    a7d7:	8b 45 08             	mov    0x8(%ebp),%eax
    a7da:	01 d0                	add    %edx,%eax
    a7dc:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a7e0:	66 c1 ea 08          	shr    $0x8,%dx
    a7e4:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a7e6:	8b 55 0c             	mov    0xc(%ebp),%edx
    a7e9:	89 d0                	mov    %edx,%eax
    a7eb:	01 c0                	add    %eax,%eax
    a7ed:	01 d0                	add    %edx,%eax
    a7ef:	01 c0                	add    %eax,%eax
    a7f1:	8d 50 05             	lea    0x5(%eax),%edx
    a7f4:	8b 45 08             	mov    0x8(%ebp),%eax
    a7f7:	01 d0                	add    %edx,%eax
    a7f9:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a7fd:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a7ff:	e9 2b 01 00 00       	jmp    a92f <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a804:	8b 45 10             	mov    0x10(%ebp),%eax
    a807:	8b 00                	mov    (%eax),%eax
    a809:	83 f8 04             	cmp    $0x4,%eax
    a80c:	75 64                	jne    a872 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a80e:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a812:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a816:	8b 45 0c             	mov    0xc(%ebp),%eax
    a819:	c1 e0 02             	shl    $0x2,%eax
    a81c:	89 c2                	mov    %eax,%edx
    a81e:	8b 45 08             	mov    0x8(%ebp),%eax
    a821:	01 d0                	add    %edx,%eax
    a823:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a827:	66 c1 ea 08          	shr    $0x8,%dx
    a82b:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a82d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a830:	c1 e0 02             	shl    $0x2,%eax
    a833:	8d 50 01             	lea    0x1(%eax),%edx
    a836:	8b 45 08             	mov    0x8(%ebp),%eax
    a839:	01 d0                	add    %edx,%eax
    a83b:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a83f:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a841:	8b 45 0c             	mov    0xc(%ebp),%eax
    a844:	c1 e0 02             	shl    $0x2,%eax
    a847:	8d 50 02             	lea    0x2(%eax),%edx
    a84a:	8b 45 08             	mov    0x8(%ebp),%eax
    a84d:	01 d0                	add    %edx,%eax
    a84f:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a853:	66 c1 ea 08          	shr    $0x8,%dx
    a857:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a859:	8b 45 0c             	mov    0xc(%ebp),%eax
    a85c:	c1 e0 02             	shl    $0x2,%eax
    a85f:	8d 50 03             	lea    0x3(%eax),%edx
    a862:	8b 45 08             	mov    0x8(%ebp),%eax
    a865:	01 d0                	add    %edx,%eax
    a867:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a86b:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a86d:	e9 bd 00 00 00       	jmp    a92f <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a872:	8b 45 10             	mov    0x10(%ebp),%eax
    a875:	8b 00                	mov    (%eax),%eax
    a877:	83 f8 06             	cmp    $0x6,%eax
    a87a:	0f 85 af 00 00 00    	jne    a92f <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a880:	8b 45 0c             	mov    0xc(%ebp),%eax
    a883:	c1 e0 03             	shl    $0x3,%eax
    a886:	89 c2                	mov    %eax,%edx
    a888:	8b 45 08             	mov    0x8(%ebp),%eax
    a88b:	01 d0                	add    %edx,%eax
    a88d:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a891:	66 c1 ea 08          	shr    $0x8,%dx
    a895:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a897:	8b 45 0c             	mov    0xc(%ebp),%eax
    a89a:	c1 e0 03             	shl    $0x3,%eax
    a89d:	8d 50 01             	lea    0x1(%eax),%edx
    a8a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a8a3:	01 d0                	add    %edx,%eax
    a8a5:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a8a9:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a8ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8ae:	c1 e0 03             	shl    $0x3,%eax
    a8b1:	8d 50 02             	lea    0x2(%eax),%edx
    a8b4:	8b 45 08             	mov    0x8(%ebp),%eax
    a8b7:	01 d0                	add    %edx,%eax
    a8b9:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a8bd:	66 c1 ea 08          	shr    $0x8,%dx
    a8c1:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a8c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8c6:	c1 e0 03             	shl    $0x3,%eax
    a8c9:	8d 50 03             	lea    0x3(%eax),%edx
    a8cc:	8b 45 08             	mov    0x8(%ebp),%eax
    a8cf:	01 d0                	add    %edx,%eax
    a8d1:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a8d5:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a8d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8da:	c1 e0 03             	shl    $0x3,%eax
    a8dd:	8d 50 04             	lea    0x4(%eax),%edx
    a8e0:	8b 45 08             	mov    0x8(%ebp),%eax
    a8e3:	01 d0                	add    %edx,%eax
    a8e5:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a8e9:	66 c1 ea 08          	shr    $0x8,%dx
    a8ed:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a8ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8f2:	c1 e0 03             	shl    $0x3,%eax
    a8f5:	8d 50 05             	lea    0x5(%eax),%edx
    a8f8:	8b 45 08             	mov    0x8(%ebp),%eax
    a8fb:	01 d0                	add    %edx,%eax
    a8fd:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a901:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a903:	8b 45 0c             	mov    0xc(%ebp),%eax
    a906:	c1 e0 03             	shl    $0x3,%eax
    a909:	8d 50 06             	lea    0x6(%eax),%edx
    a90c:	8b 45 08             	mov    0x8(%ebp),%eax
    a90f:	01 d0                	add    %edx,%eax
    a911:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a915:	66 c1 ea 08          	shr    $0x8,%dx
    a919:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a91b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a91e:	c1 e0 03             	shl    $0x3,%eax
    a921:	8d 50 07             	lea    0x7(%eax),%edx
    a924:	8b 45 08             	mov    0x8(%ebp),%eax
    a927:	01 d0                	add    %edx,%eax
    a929:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a92d:	88 10                	mov    %dl,(%eax)
  }
}
    a92f:	90                   	nop
    a930:	83 c4 20             	add    $0x20,%esp
    a933:	5b                   	pop    %ebx
    a934:	5d                   	pop    %ebp
    a935:	c3                   	ret    

0000a936 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a936:	55                   	push   %ebp
    a937:	89 e5                	mov    %esp,%ebp
    a939:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a93c:	8b 45 20             	mov    0x20(%ebp),%eax
    a93f:	8b 00                	mov    (%eax),%eax
    a941:	85 c0                	test   %eax,%eax
    a943:	0f 85 8c 01 00 00    	jne    aad5 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a949:	8b 45 20             	mov    0x20(%ebp),%eax
    a94c:	8b 40 04             	mov    0x4(%eax),%eax
    a94f:	83 f8 08             	cmp    $0x8,%eax
    a952:	75 59                	jne    a9ad <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a954:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a957:	8b 45 18             	mov    0x18(%ebp),%eax
    a95a:	01 d0                	add    %edx,%eax
    a95c:	0f b6 10             	movzbl (%eax),%edx
    a95f:	8b 45 10             	mov    0x10(%ebp),%eax
    a962:	88 10                	mov    %dl,(%eax)
    a964:	8b 45 10             	mov    0x10(%ebp),%eax
    a967:	0f b6 10             	movzbl (%eax),%edx
    a96a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a96d:	88 10                	mov    %dl,(%eax)
    a96f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a972:	0f b6 10             	movzbl (%eax),%edx
    a975:	8b 45 08             	mov    0x8(%ebp),%eax
    a978:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a97a:	8b 45 20             	mov    0x20(%ebp),%eax
    a97d:	8b 40 10             	mov    0x10(%eax),%eax
    a980:	85 c0                	test   %eax,%eax
    a982:	74 1e                	je     a9a2 <getPixelColorRGBA8+0x6c>
    a984:	8b 45 08             	mov    0x8(%ebp),%eax
    a987:	0f b6 00             	movzbl (%eax),%eax
    a98a:	0f b6 d0             	movzbl %al,%edx
    a98d:	8b 45 20             	mov    0x20(%ebp),%eax
    a990:	8b 40 14             	mov    0x14(%eax),%eax
    a993:	39 c2                	cmp    %eax,%edx
    a995:	75 0b                	jne    a9a2 <getPixelColorRGBA8+0x6c>
    a997:	8b 45 14             	mov    0x14(%ebp),%eax
    a99a:	c6 00 00             	movb   $0x0,(%eax)
    a99d:	e9 5e 05 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a9a2:	8b 45 14             	mov    0x14(%ebp),%eax
    a9a5:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9a8:	e9 53 05 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a9ad:	8b 45 20             	mov    0x20(%ebp),%eax
    a9b0:	8b 40 04             	mov    0x4(%eax),%eax
    a9b3:	83 f8 10             	cmp    $0x10,%eax
    a9b6:	0f 85 80 00 00 00    	jne    aa3c <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a9bc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9bf:	01 c0                	add    %eax,%eax
    a9c1:	89 c2                	mov    %eax,%edx
    a9c3:	8b 45 18             	mov    0x18(%ebp),%eax
    a9c6:	01 d0                	add    %edx,%eax
    a9c8:	0f b6 10             	movzbl (%eax),%edx
    a9cb:	8b 45 10             	mov    0x10(%ebp),%eax
    a9ce:	88 10                	mov    %dl,(%eax)
    a9d0:	8b 45 10             	mov    0x10(%ebp),%eax
    a9d3:	0f b6 10             	movzbl (%eax),%edx
    a9d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9d9:	88 10                	mov    %dl,(%eax)
    a9db:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9de:	0f b6 10             	movzbl (%eax),%edx
    a9e1:	8b 45 08             	mov    0x8(%ebp),%eax
    a9e4:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a9e6:	8b 45 20             	mov    0x20(%ebp),%eax
    a9e9:	8b 40 10             	mov    0x10(%eax),%eax
    a9ec:	85 c0                	test   %eax,%eax
    a9ee:	74 41                	je     aa31 <getPixelColorRGBA8+0xfb>
    a9f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9f3:	01 c0                	add    %eax,%eax
    a9f5:	89 c2                	mov    %eax,%edx
    a9f7:	8b 45 18             	mov    0x18(%ebp),%eax
    a9fa:	01 d0                	add    %edx,%eax
    a9fc:	0f b6 00             	movzbl (%eax),%eax
    a9ff:	0f b6 c0             	movzbl %al,%eax
    aa02:	c1 e0 08             	shl    $0x8,%eax
    aa05:	89 c2                	mov    %eax,%edx
    aa07:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa0a:	01 c0                	add    %eax,%eax
    aa0c:	8d 48 01             	lea    0x1(%eax),%ecx
    aa0f:	8b 45 18             	mov    0x18(%ebp),%eax
    aa12:	01 c8                	add    %ecx,%eax
    aa14:	0f b6 00             	movzbl (%eax),%eax
    aa17:	0f b6 c0             	movzbl %al,%eax
    aa1a:	01 c2                	add    %eax,%edx
    aa1c:	8b 45 20             	mov    0x20(%ebp),%eax
    aa1f:	8b 40 14             	mov    0x14(%eax),%eax
    aa22:	39 c2                	cmp    %eax,%edx
    aa24:	75 0b                	jne    aa31 <getPixelColorRGBA8+0xfb>
    aa26:	8b 45 14             	mov    0x14(%ebp),%eax
    aa29:	c6 00 00             	movb   $0x0,(%eax)
    aa2c:	e9 cf 04 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    aa31:	8b 45 14             	mov    0x14(%ebp),%eax
    aa34:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa37:	e9 c4 04 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    aa3c:	8b 45 20             	mov    0x20(%ebp),%eax
    aa3f:	8b 40 04             	mov    0x4(%eax),%eax
    aa42:	ba 01 00 00 00       	mov    $0x1,%edx
    aa47:	89 c1                	mov    %eax,%ecx
    aa49:	d3 e2                	shl    %cl,%edx
    aa4b:	89 d0                	mov    %edx,%eax
    aa4d:	83 e8 01             	sub    $0x1,%eax
    aa50:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    aa53:	8b 45 20             	mov    0x20(%ebp),%eax
    aa56:	8b 50 04             	mov    0x4(%eax),%edx
    aa59:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa5c:	0f af c2             	imul   %edx,%eax
    aa5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    aa62:	8b 45 20             	mov    0x20(%ebp),%eax
    aa65:	8b 40 04             	mov    0x4(%eax),%eax
    aa68:	50                   	push   %eax
    aa69:	ff 75 18             	pushl  0x18(%ebp)
    aa6c:	8d 45 f0             	lea    -0x10(%ebp),%eax
    aa6f:	50                   	push   %eax
    aa70:	e8 06 db ff ff       	call   857b <readBitsFromReversedStream>
    aa75:	83 c4 0c             	add    $0xc,%esp
    aa78:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    aa7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    aa7e:	89 d0                	mov    %edx,%eax
    aa80:	c1 e0 08             	shl    $0x8,%eax
    aa83:	29 d0                	sub    %edx,%eax
    aa85:	ba 00 00 00 00       	mov    $0x0,%edx
    aa8a:	f7 75 f8             	divl   -0x8(%ebp)
    aa8d:	89 c2                	mov    %eax,%edx
    aa8f:	8b 45 10             	mov    0x10(%ebp),%eax
    aa92:	88 10                	mov    %dl,(%eax)
    aa94:	8b 45 10             	mov    0x10(%ebp),%eax
    aa97:	0f b6 10             	movzbl (%eax),%edx
    aa9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa9d:	88 10                	mov    %dl,(%eax)
    aa9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaa2:	0f b6 10             	movzbl (%eax),%edx
    aaa5:	8b 45 08             	mov    0x8(%ebp),%eax
    aaa8:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    aaaa:	8b 45 20             	mov    0x20(%ebp),%eax
    aaad:	8b 40 10             	mov    0x10(%eax),%eax
    aab0:	85 c0                	test   %eax,%eax
    aab2:	74 16                	je     aaca <getPixelColorRGBA8+0x194>
    aab4:	8b 45 20             	mov    0x20(%ebp),%eax
    aab7:	8b 40 14             	mov    0x14(%eax),%eax
    aaba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    aabd:	75 0b                	jne    aaca <getPixelColorRGBA8+0x194>
    aabf:	8b 45 14             	mov    0x14(%ebp),%eax
    aac2:	c6 00 00             	movb   $0x0,(%eax)
    aac5:	e9 36 04 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    aaca:	8b 45 14             	mov    0x14(%ebp),%eax
    aacd:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aad0:	e9 2b 04 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    aad5:	8b 45 20             	mov    0x20(%ebp),%eax
    aad8:	8b 00                	mov    (%eax),%eax
    aada:	83 f8 02             	cmp    $0x2,%eax
    aadd:	0f 85 f5 01 00 00    	jne    acd8 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    aae3:	8b 45 20             	mov    0x20(%ebp),%eax
    aae6:	8b 40 04             	mov    0x4(%eax),%eax
    aae9:	83 f8 08             	cmp    $0x8,%eax
    aaec:	0f 85 a3 00 00 00    	jne    ab95 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    aaf2:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aaf5:	89 d0                	mov    %edx,%eax
    aaf7:	01 c0                	add    %eax,%eax
    aaf9:	01 d0                	add    %edx,%eax
    aafb:	89 c2                	mov    %eax,%edx
    aafd:	8b 45 18             	mov    0x18(%ebp),%eax
    ab00:	01 d0                	add    %edx,%eax
    ab02:	0f b6 10             	movzbl (%eax),%edx
    ab05:	8b 45 08             	mov    0x8(%ebp),%eax
    ab08:	88 10                	mov    %dl,(%eax)
    ab0a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab0d:	89 d0                	mov    %edx,%eax
    ab0f:	01 c0                	add    %eax,%eax
    ab11:	01 d0                	add    %edx,%eax
    ab13:	8d 50 01             	lea    0x1(%eax),%edx
    ab16:	8b 45 18             	mov    0x18(%ebp),%eax
    ab19:	01 d0                	add    %edx,%eax
    ab1b:	0f b6 10             	movzbl (%eax),%edx
    ab1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab21:	88 10                	mov    %dl,(%eax)
    ab23:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab26:	89 d0                	mov    %edx,%eax
    ab28:	01 c0                	add    %eax,%eax
    ab2a:	01 d0                	add    %edx,%eax
    ab2c:	8d 50 02             	lea    0x2(%eax),%edx
    ab2f:	8b 45 18             	mov    0x18(%ebp),%eax
    ab32:	01 d0                	add    %edx,%eax
    ab34:	0f b6 10             	movzbl (%eax),%edx
    ab37:	8b 45 10             	mov    0x10(%ebp),%eax
    ab3a:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    ab3c:	8b 45 20             	mov    0x20(%ebp),%eax
    ab3f:	8b 40 10             	mov    0x10(%eax),%eax
    ab42:	85 c0                	test   %eax,%eax
    ab44:	74 44                	je     ab8a <getPixelColorRGBA8+0x254>
    ab46:	8b 45 08             	mov    0x8(%ebp),%eax
    ab49:	0f b6 00             	movzbl (%eax),%eax
    ab4c:	0f b6 d0             	movzbl %al,%edx
    ab4f:	8b 45 20             	mov    0x20(%ebp),%eax
    ab52:	8b 40 14             	mov    0x14(%eax),%eax
    ab55:	39 c2                	cmp    %eax,%edx
    ab57:	75 31                	jne    ab8a <getPixelColorRGBA8+0x254>
    ab59:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab5c:	0f b6 00             	movzbl (%eax),%eax
    ab5f:	0f b6 d0             	movzbl %al,%edx
    ab62:	8b 45 20             	mov    0x20(%ebp),%eax
    ab65:	8b 40 18             	mov    0x18(%eax),%eax
    ab68:	39 c2                	cmp    %eax,%edx
    ab6a:	75 1e                	jne    ab8a <getPixelColorRGBA8+0x254>
    ab6c:	8b 45 10             	mov    0x10(%ebp),%eax
    ab6f:	0f b6 00             	movzbl (%eax),%eax
    ab72:	0f b6 d0             	movzbl %al,%edx
    ab75:	8b 45 20             	mov    0x20(%ebp),%eax
    ab78:	8b 40 1c             	mov    0x1c(%eax),%eax
    ab7b:	39 c2                	cmp    %eax,%edx
    ab7d:	75 0b                	jne    ab8a <getPixelColorRGBA8+0x254>
    ab7f:	8b 45 14             	mov    0x14(%ebp),%eax
    ab82:	c6 00 00             	movb   $0x0,(%eax)
    ab85:	e9 76 03 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    ab8a:	8b 45 14             	mov    0x14(%ebp),%eax
    ab8d:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab90:	e9 6b 03 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    ab95:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab98:	89 d0                	mov    %edx,%eax
    ab9a:	01 c0                	add    %eax,%eax
    ab9c:	01 d0                	add    %edx,%eax
    ab9e:	01 c0                	add    %eax,%eax
    aba0:	89 c2                	mov    %eax,%edx
    aba2:	8b 45 18             	mov    0x18(%ebp),%eax
    aba5:	01 d0                	add    %edx,%eax
    aba7:	0f b6 10             	movzbl (%eax),%edx
    abaa:	8b 45 08             	mov    0x8(%ebp),%eax
    abad:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    abaf:	8b 55 1c             	mov    0x1c(%ebp),%edx
    abb2:	89 d0                	mov    %edx,%eax
    abb4:	01 c0                	add    %eax,%eax
    abb6:	01 d0                	add    %edx,%eax
    abb8:	01 c0                	add    %eax,%eax
    abba:	8d 50 02             	lea    0x2(%eax),%edx
    abbd:	8b 45 18             	mov    0x18(%ebp),%eax
    abc0:	01 d0                	add    %edx,%eax
    abc2:	0f b6 10             	movzbl (%eax),%edx
    abc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    abc8:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    abca:	8b 55 1c             	mov    0x1c(%ebp),%edx
    abcd:	89 d0                	mov    %edx,%eax
    abcf:	01 c0                	add    %eax,%eax
    abd1:	01 d0                	add    %edx,%eax
    abd3:	01 c0                	add    %eax,%eax
    abd5:	8d 50 04             	lea    0x4(%eax),%edx
    abd8:	8b 45 18             	mov    0x18(%ebp),%eax
    abdb:	01 d0                	add    %edx,%eax
    abdd:	0f b6 10             	movzbl (%eax),%edx
    abe0:	8b 45 10             	mov    0x10(%ebp),%eax
    abe3:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    abe5:	8b 45 20             	mov    0x20(%ebp),%eax
    abe8:	8b 40 10             	mov    0x10(%eax),%eax
    abeb:	85 c0                	test   %eax,%eax
    abed:	0f 84 da 00 00 00    	je     accd <getPixelColorRGBA8+0x397>
    abf3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    abf6:	89 d0                	mov    %edx,%eax
    abf8:	01 c0                	add    %eax,%eax
    abfa:	01 d0                	add    %edx,%eax
    abfc:	01 c0                	add    %eax,%eax
    abfe:	89 c2                	mov    %eax,%edx
    ac00:	8b 45 18             	mov    0x18(%ebp),%eax
    ac03:	01 d0                	add    %edx,%eax
    ac05:	0f b6 00             	movzbl (%eax),%eax
    ac08:	0f b6 c0             	movzbl %al,%eax
    ac0b:	c1 e0 08             	shl    $0x8,%eax
    ac0e:	89 c1                	mov    %eax,%ecx
    ac10:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ac13:	89 d0                	mov    %edx,%eax
    ac15:	01 c0                	add    %eax,%eax
    ac17:	01 d0                	add    %edx,%eax
    ac19:	01 c0                	add    %eax,%eax
    ac1b:	8d 50 01             	lea    0x1(%eax),%edx
    ac1e:	8b 45 18             	mov    0x18(%ebp),%eax
    ac21:	01 d0                	add    %edx,%eax
    ac23:	0f b6 00             	movzbl (%eax),%eax
    ac26:	0f b6 c0             	movzbl %al,%eax
    ac29:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ac2c:	8b 45 20             	mov    0x20(%ebp),%eax
    ac2f:	8b 40 14             	mov    0x14(%eax),%eax
    ac32:	39 c2                	cmp    %eax,%edx
    ac34:	0f 85 93 00 00 00    	jne    accd <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    ac3a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ac3d:	89 d0                	mov    %edx,%eax
    ac3f:	01 c0                	add    %eax,%eax
    ac41:	01 d0                	add    %edx,%eax
    ac43:	01 c0                	add    %eax,%eax
    ac45:	8d 50 02             	lea    0x2(%eax),%edx
    ac48:	8b 45 18             	mov    0x18(%ebp),%eax
    ac4b:	01 d0                	add    %edx,%eax
    ac4d:	0f b6 00             	movzbl (%eax),%eax
    ac50:	0f b6 c0             	movzbl %al,%eax
    ac53:	c1 e0 08             	shl    $0x8,%eax
    ac56:	89 c1                	mov    %eax,%ecx
    ac58:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ac5b:	89 d0                	mov    %edx,%eax
    ac5d:	01 c0                	add    %eax,%eax
    ac5f:	01 d0                	add    %edx,%eax
    ac61:	01 c0                	add    %eax,%eax
    ac63:	8d 50 03             	lea    0x3(%eax),%edx
    ac66:	8b 45 18             	mov    0x18(%ebp),%eax
    ac69:	01 d0                	add    %edx,%eax
    ac6b:	0f b6 00             	movzbl (%eax),%eax
    ac6e:	0f b6 c0             	movzbl %al,%eax
    ac71:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ac74:	8b 45 20             	mov    0x20(%ebp),%eax
    ac77:	8b 40 18             	mov    0x18(%eax),%eax
    ac7a:	39 c2                	cmp    %eax,%edx
    ac7c:	75 4f                	jne    accd <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    ac7e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ac81:	89 d0                	mov    %edx,%eax
    ac83:	01 c0                	add    %eax,%eax
    ac85:	01 d0                	add    %edx,%eax
    ac87:	01 c0                	add    %eax,%eax
    ac89:	8d 50 04             	lea    0x4(%eax),%edx
    ac8c:	8b 45 18             	mov    0x18(%ebp),%eax
    ac8f:	01 d0                	add    %edx,%eax
    ac91:	0f b6 00             	movzbl (%eax),%eax
    ac94:	0f b6 c0             	movzbl %al,%eax
    ac97:	c1 e0 08             	shl    $0x8,%eax
    ac9a:	89 c1                	mov    %eax,%ecx
    ac9c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ac9f:	89 d0                	mov    %edx,%eax
    aca1:	01 c0                	add    %eax,%eax
    aca3:	01 d0                	add    %edx,%eax
    aca5:	01 c0                	add    %eax,%eax
    aca7:	8d 50 05             	lea    0x5(%eax),%edx
    acaa:	8b 45 18             	mov    0x18(%ebp),%eax
    acad:	01 d0                	add    %edx,%eax
    acaf:	0f b6 00             	movzbl (%eax),%eax
    acb2:	0f b6 c0             	movzbl %al,%eax
    acb5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    acb8:	8b 45 20             	mov    0x20(%ebp),%eax
    acbb:	8b 40 1c             	mov    0x1c(%eax),%eax
    acbe:	39 c2                	cmp    %eax,%edx
    acc0:	75 0b                	jne    accd <getPixelColorRGBA8+0x397>
    acc2:	8b 45 14             	mov    0x14(%ebp),%eax
    acc5:	c6 00 00             	movb   $0x0,(%eax)
    acc8:	e9 33 02 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    accd:	8b 45 14             	mov    0x14(%ebp),%eax
    acd0:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    acd3:	e9 28 02 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    acd8:	8b 45 20             	mov    0x20(%ebp),%eax
    acdb:	8b 00                	mov    (%eax),%eax
    acdd:	83 f8 03             	cmp    $0x3,%eax
    ace0:	0f 85 ac 00 00 00    	jne    ad92 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    ace6:	8b 45 20             	mov    0x20(%ebp),%eax
    ace9:	8b 40 04             	mov    0x4(%eax),%eax
    acec:	83 f8 08             	cmp    $0x8,%eax
    acef:	75 13                	jne    ad04 <getPixelColorRGBA8+0x3ce>
    acf1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    acf4:	8b 45 18             	mov    0x18(%ebp),%eax
    acf7:	01 d0                	add    %edx,%eax
    acf9:	0f b6 00             	movzbl (%eax),%eax
    acfc:	0f b6 c0             	movzbl %al,%eax
    acff:	89 45 fc             	mov    %eax,-0x4(%ebp)
    ad02:	eb 28                	jmp    ad2c <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    ad04:	8b 45 20             	mov    0x20(%ebp),%eax
    ad07:	8b 50 04             	mov    0x4(%eax),%edx
    ad0a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad0d:	0f af c2             	imul   %edx,%eax
    ad10:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ad13:	8b 45 20             	mov    0x20(%ebp),%eax
    ad16:	8b 40 04             	mov    0x4(%eax),%eax
    ad19:	50                   	push   %eax
    ad1a:	ff 75 18             	pushl  0x18(%ebp)
    ad1d:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ad20:	50                   	push   %eax
    ad21:	e8 55 d8 ff ff       	call   857b <readBitsFromReversedStream>
    ad26:	83 c4 0c             	add    $0xc,%esp
    ad29:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    ad2c:	8b 45 20             	mov    0x20(%ebp),%eax
    ad2f:	8b 40 08             	mov    0x8(%eax),%eax
    ad32:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ad35:	c1 e2 02             	shl    $0x2,%edx
    ad38:	01 d0                	add    %edx,%eax
    ad3a:	0f b6 10             	movzbl (%eax),%edx
    ad3d:	8b 45 08             	mov    0x8(%ebp),%eax
    ad40:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    ad42:	8b 45 20             	mov    0x20(%ebp),%eax
    ad45:	8b 40 08             	mov    0x8(%eax),%eax
    ad48:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ad4b:	c1 e2 02             	shl    $0x2,%edx
    ad4e:	83 c2 01             	add    $0x1,%edx
    ad51:	01 d0                	add    %edx,%eax
    ad53:	0f b6 10             	movzbl (%eax),%edx
    ad56:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad59:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    ad5b:	8b 45 20             	mov    0x20(%ebp),%eax
    ad5e:	8b 40 08             	mov    0x8(%eax),%eax
    ad61:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ad64:	c1 e2 02             	shl    $0x2,%edx
    ad67:	83 c2 02             	add    $0x2,%edx
    ad6a:	01 d0                	add    %edx,%eax
    ad6c:	0f b6 10             	movzbl (%eax),%edx
    ad6f:	8b 45 10             	mov    0x10(%ebp),%eax
    ad72:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    ad74:	8b 45 20             	mov    0x20(%ebp),%eax
    ad77:	8b 40 08             	mov    0x8(%eax),%eax
    ad7a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ad7d:	c1 e2 02             	shl    $0x2,%edx
    ad80:	83 c2 03             	add    $0x3,%edx
    ad83:	01 d0                	add    %edx,%eax
    ad85:	0f b6 10             	movzbl (%eax),%edx
    ad88:	8b 45 14             	mov    0x14(%ebp),%eax
    ad8b:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ad8d:	e9 6e 01 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    ad92:	8b 45 20             	mov    0x20(%ebp),%eax
    ad95:	8b 00                	mov    (%eax),%eax
    ad97:	83 f8 04             	cmp    $0x4,%eax
    ad9a:	0f 85 95 00 00 00    	jne    ae35 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    ada0:	8b 45 20             	mov    0x20(%ebp),%eax
    ada3:	8b 40 04             	mov    0x4(%eax),%eax
    ada6:	83 f8 08             	cmp    $0x8,%eax
    ada9:	75 44                	jne    adef <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    adab:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adae:	01 c0                	add    %eax,%eax
    adb0:	89 c2                	mov    %eax,%edx
    adb2:	8b 45 18             	mov    0x18(%ebp),%eax
    adb5:	01 d0                	add    %edx,%eax
    adb7:	0f b6 10             	movzbl (%eax),%edx
    adba:	8b 45 10             	mov    0x10(%ebp),%eax
    adbd:	88 10                	mov    %dl,(%eax)
    adbf:	8b 45 10             	mov    0x10(%ebp),%eax
    adc2:	0f b6 10             	movzbl (%eax),%edx
    adc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    adc8:	88 10                	mov    %dl,(%eax)
    adca:	8b 45 0c             	mov    0xc(%ebp),%eax
    adcd:	0f b6 10             	movzbl (%eax),%edx
    add0:	8b 45 08             	mov    0x8(%ebp),%eax
    add3:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    add5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    add8:	01 c0                	add    %eax,%eax
    adda:	8d 50 01             	lea    0x1(%eax),%edx
    addd:	8b 45 18             	mov    0x18(%ebp),%eax
    ade0:	01 d0                	add    %edx,%eax
    ade2:	0f b6 10             	movzbl (%eax),%edx
    ade5:	8b 45 14             	mov    0x14(%ebp),%eax
    ade8:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    adea:	e9 11 01 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    adef:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adf2:	c1 e0 02             	shl    $0x2,%eax
    adf5:	89 c2                	mov    %eax,%edx
    adf7:	8b 45 18             	mov    0x18(%ebp),%eax
    adfa:	01 d0                	add    %edx,%eax
    adfc:	0f b6 10             	movzbl (%eax),%edx
    adff:	8b 45 10             	mov    0x10(%ebp),%eax
    ae02:	88 10                	mov    %dl,(%eax)
    ae04:	8b 45 10             	mov    0x10(%ebp),%eax
    ae07:	0f b6 10             	movzbl (%eax),%edx
    ae0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae0d:	88 10                	mov    %dl,(%eax)
    ae0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae12:	0f b6 10             	movzbl (%eax),%edx
    ae15:	8b 45 08             	mov    0x8(%ebp),%eax
    ae18:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    ae1a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ae1d:	c1 e0 02             	shl    $0x2,%eax
    ae20:	8d 50 02             	lea    0x2(%eax),%edx
    ae23:	8b 45 18             	mov    0x18(%ebp),%eax
    ae26:	01 d0                	add    %edx,%eax
    ae28:	0f b6 10             	movzbl (%eax),%edx
    ae2b:	8b 45 14             	mov    0x14(%ebp),%eax
    ae2e:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ae30:	e9 cb 00 00 00       	jmp    af00 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    ae35:	8b 45 20             	mov    0x20(%ebp),%eax
    ae38:	8b 00                	mov    (%eax),%eax
    ae3a:	83 f8 06             	cmp    $0x6,%eax
    ae3d:	0f 85 bd 00 00 00    	jne    af00 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    ae43:	8b 45 20             	mov    0x20(%ebp),%eax
    ae46:	8b 40 04             	mov    0x4(%eax),%eax
    ae49:	83 f8 08             	cmp    $0x8,%eax
    ae4c:	75 59                	jne    aea7 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    ae4e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ae51:	c1 e0 02             	shl    $0x2,%eax
    ae54:	89 c2                	mov    %eax,%edx
    ae56:	8b 45 18             	mov    0x18(%ebp),%eax
    ae59:	01 d0                	add    %edx,%eax
    ae5b:	0f b6 10             	movzbl (%eax),%edx
    ae5e:	8b 45 08             	mov    0x8(%ebp),%eax
    ae61:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    ae63:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ae66:	c1 e0 02             	shl    $0x2,%eax
    ae69:	8d 50 01             	lea    0x1(%eax),%edx
    ae6c:	8b 45 18             	mov    0x18(%ebp),%eax
    ae6f:	01 d0                	add    %edx,%eax
    ae71:	0f b6 10             	movzbl (%eax),%edx
    ae74:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae77:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    ae79:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ae7c:	c1 e0 02             	shl    $0x2,%eax
    ae7f:	8d 50 02             	lea    0x2(%eax),%edx
    ae82:	8b 45 18             	mov    0x18(%ebp),%eax
    ae85:	01 d0                	add    %edx,%eax
    ae87:	0f b6 10             	movzbl (%eax),%edx
    ae8a:	8b 45 10             	mov    0x10(%ebp),%eax
    ae8d:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    ae8f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ae92:	c1 e0 02             	shl    $0x2,%eax
    ae95:	8d 50 03             	lea    0x3(%eax),%edx
    ae98:	8b 45 18             	mov    0x18(%ebp),%eax
    ae9b:	01 d0                	add    %edx,%eax
    ae9d:	0f b6 10             	movzbl (%eax),%edx
    aea0:	8b 45 14             	mov    0x14(%ebp),%eax
    aea3:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aea5:	eb 59                	jmp    af00 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    aea7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aeaa:	c1 e0 03             	shl    $0x3,%eax
    aead:	89 c2                	mov    %eax,%edx
    aeaf:	8b 45 18             	mov    0x18(%ebp),%eax
    aeb2:	01 d0                	add    %edx,%eax
    aeb4:	0f b6 10             	movzbl (%eax),%edx
    aeb7:	8b 45 08             	mov    0x8(%ebp),%eax
    aeba:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    aebc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aebf:	c1 e0 03             	shl    $0x3,%eax
    aec2:	8d 50 02             	lea    0x2(%eax),%edx
    aec5:	8b 45 18             	mov    0x18(%ebp),%eax
    aec8:	01 d0                	add    %edx,%eax
    aeca:	0f b6 10             	movzbl (%eax),%edx
    aecd:	8b 45 0c             	mov    0xc(%ebp),%eax
    aed0:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    aed2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aed5:	c1 e0 03             	shl    $0x3,%eax
    aed8:	8d 50 04             	lea    0x4(%eax),%edx
    aedb:	8b 45 18             	mov    0x18(%ebp),%eax
    aede:	01 d0                	add    %edx,%eax
    aee0:	0f b6 10             	movzbl (%eax),%edx
    aee3:	8b 45 10             	mov    0x10(%ebp),%eax
    aee6:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    aee8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aeeb:	c1 e0 03             	shl    $0x3,%eax
    aeee:	8d 50 06             	lea    0x6(%eax),%edx
    aef1:	8b 45 18             	mov    0x18(%ebp),%eax
    aef4:	01 d0                	add    %edx,%eax
    aef6:	0f b6 10             	movzbl (%eax),%edx
    aef9:	8b 45 14             	mov    0x14(%ebp),%eax
    aefc:	88 10                	mov    %dl,(%eax)
    }
  }
}
    aefe:	eb 00                	jmp    af00 <getPixelColorRGBA8+0x5ca>
    af00:	90                   	nop
    af01:	c9                   	leave  
    af02:	c3                   	ret    

0000af03 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    af03:	55                   	push   %ebp
    af04:	89 e5                	mov    %esp,%ebp
    af06:	53                   	push   %ebx
    af07:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    af0a:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    af11:	8b 45 14             	mov    0x14(%ebp),%eax
    af14:	8b 00                	mov    (%eax),%eax
    af16:	85 c0                	test   %eax,%eax
    af18:	0f 85 14 02 00 00    	jne    b132 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    af1e:	8b 45 14             	mov    0x14(%ebp),%eax
    af21:	8b 40 04             	mov    0x4(%eax),%eax
    af24:	83 f8 08             	cmp    $0x8,%eax
    af27:	0f 85 a0 00 00 00    	jne    afcd <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af2d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    af34:	eb 39                	jmp    af6f <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    af36:	8b 45 08             	mov    0x8(%ebp),%eax
    af39:	83 c0 01             	add    $0x1,%eax
    af3c:	8b 55 08             	mov    0x8(%ebp),%edx
    af3f:	83 c2 02             	add    $0x2,%edx
    af42:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    af45:	8b 4d 10             	mov    0x10(%ebp),%ecx
    af48:	01 d9                	add    %ebx,%ecx
    af4a:	0f b6 09             	movzbl (%ecx),%ecx
    af4d:	88 0a                	mov    %cl,(%edx)
    af4f:	0f b6 12             	movzbl (%edx),%edx
    af52:	88 10                	mov    %dl,(%eax)
    af54:	0f b6 10             	movzbl (%eax),%edx
    af57:	8b 45 08             	mov    0x8(%ebp),%eax
    af5a:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    af5c:	8b 45 08             	mov    0x8(%ebp),%eax
    af5f:	83 c0 03             	add    $0x3,%eax
    af62:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af65:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    af69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af6c:	01 45 08             	add    %eax,0x8(%ebp)
    af6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af72:	3b 45 0c             	cmp    0xc(%ebp),%eax
    af75:	75 bf                	jne    af36 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    af77:	8b 45 14             	mov    0x14(%ebp),%eax
    af7a:	8b 40 10             	mov    0x10(%eax),%eax
    af7d:	85 c0                	test   %eax,%eax
    af7f:	0f 84 48 06 00 00    	je     b5cd <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    af85:	8b 45 0c             	mov    0xc(%ebp),%eax
    af88:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    af8c:	f7 d8                	neg    %eax
    af8e:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af91:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    af98:	eb 26                	jmp    afc0 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    af9a:	8b 45 08             	mov    0x8(%ebp),%eax
    af9d:	0f b6 00             	movzbl (%eax),%eax
    afa0:	0f b6 d0             	movzbl %al,%edx
    afa3:	8b 45 14             	mov    0x14(%ebp),%eax
    afa6:	8b 40 14             	mov    0x14(%eax),%eax
    afa9:	39 c2                	cmp    %eax,%edx
    afab:	75 09                	jne    afb6 <getPixelColorsRGBA8+0xb3>
    afad:	8b 45 08             	mov    0x8(%ebp),%eax
    afb0:	83 c0 03             	add    $0x3,%eax
    afb3:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afb6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    afba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    afbd:	01 45 08             	add    %eax,0x8(%ebp)
    afc0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    afc3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    afc6:	75 d2                	jne    af9a <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    afc8:	e9 00 06 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    afcd:	8b 45 14             	mov    0x14(%ebp),%eax
    afd0:	8b 40 04             	mov    0x4(%eax),%eax
    afd3:	83 f8 10             	cmp    $0x10,%eax
    afd6:	0f 85 a5 00 00 00    	jne    b081 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afdc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    afe3:	e9 88 00 00 00       	jmp    b070 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    afe8:	8b 45 08             	mov    0x8(%ebp),%eax
    afeb:	83 c0 01             	add    $0x1,%eax
    afee:	8b 55 08             	mov    0x8(%ebp),%edx
    aff1:	83 c2 02             	add    $0x2,%edx
    aff4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    aff7:	01 c9                	add    %ecx,%ecx
    aff9:	89 cb                	mov    %ecx,%ebx
    affb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    affe:	01 d9                	add    %ebx,%ecx
    b000:	0f b6 09             	movzbl (%ecx),%ecx
    b003:	88 0a                	mov    %cl,(%edx)
    b005:	0f b6 12             	movzbl (%edx),%edx
    b008:	88 10                	mov    %dl,(%eax)
    b00a:	0f b6 10             	movzbl (%eax),%edx
    b00d:	8b 45 08             	mov    0x8(%ebp),%eax
    b010:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    b012:	8b 45 08             	mov    0x8(%ebp),%eax
    b015:	8d 50 03             	lea    0x3(%eax),%edx
    b018:	8b 45 14             	mov    0x14(%ebp),%eax
    b01b:	8b 40 10             	mov    0x10(%eax),%eax
    b01e:	85 c0                	test   %eax,%eax
    b020:	74 3d                	je     b05f <getPixelColorsRGBA8+0x15c>
    b022:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b025:	01 c0                	add    %eax,%eax
    b027:	89 c1                	mov    %eax,%ecx
    b029:	8b 45 10             	mov    0x10(%ebp),%eax
    b02c:	01 c8                	add    %ecx,%eax
    b02e:	0f b6 00             	movzbl (%eax),%eax
    b031:	0f b6 c0             	movzbl %al,%eax
    b034:	c1 e0 08             	shl    $0x8,%eax
    b037:	89 c1                	mov    %eax,%ecx
    b039:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b03c:	01 c0                	add    %eax,%eax
    b03e:	8d 58 01             	lea    0x1(%eax),%ebx
    b041:	8b 45 10             	mov    0x10(%ebp),%eax
    b044:	01 d8                	add    %ebx,%eax
    b046:	0f b6 00             	movzbl (%eax),%eax
    b049:	0f b6 c0             	movzbl %al,%eax
    b04c:	01 c1                	add    %eax,%ecx
    b04e:	8b 45 14             	mov    0x14(%ebp),%eax
    b051:	8b 40 14             	mov    0x14(%eax),%eax
    b054:	39 c1                	cmp    %eax,%ecx
    b056:	75 07                	jne    b05f <getPixelColorsRGBA8+0x15c>
    b058:	b8 00 00 00 00       	mov    $0x0,%eax
    b05d:	eb 05                	jmp    b064 <getPixelColorsRGBA8+0x161>
    b05f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b064:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b066:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b06a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b06d:	01 45 08             	add    %eax,0x8(%ebp)
    b070:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b073:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b076:	0f 85 6c ff ff ff    	jne    afe8 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b07c:	e9 4c 05 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b081:	8b 45 14             	mov    0x14(%ebp),%eax
    b084:	8b 40 04             	mov    0x4(%eax),%eax
    b087:	ba 01 00 00 00       	mov    $0x1,%edx
    b08c:	89 c1                	mov    %eax,%ecx
    b08e:	d3 e2                	shl    %cl,%edx
    b090:	89 d0                	mov    %edx,%eax
    b092:	83 e8 01             	sub    $0x1,%eax
    b095:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b098:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b09f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0a6:	eb 79                	jmp    b121 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b0a8:	8b 45 14             	mov    0x14(%ebp),%eax
    b0ab:	8b 40 04             	mov    0x4(%eax),%eax
    b0ae:	50                   	push   %eax
    b0af:	ff 75 10             	pushl  0x10(%ebp)
    b0b2:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b0b5:	50                   	push   %eax
    b0b6:	e8 c0 d4 ff ff       	call   857b <readBitsFromReversedStream>
    b0bb:	83 c4 0c             	add    $0xc,%esp
    b0be:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b0c1:	8b 45 08             	mov    0x8(%ebp),%eax
    b0c4:	8d 48 01             	lea    0x1(%eax),%ecx
    b0c7:	8b 45 08             	mov    0x8(%ebp),%eax
    b0ca:	8d 58 02             	lea    0x2(%eax),%ebx
    b0cd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b0d0:	89 d0                	mov    %edx,%eax
    b0d2:	c1 e0 08             	shl    $0x8,%eax
    b0d5:	29 d0                	sub    %edx,%eax
    b0d7:	ba 00 00 00 00       	mov    $0x0,%edx
    b0dc:	f7 75 f0             	divl   -0x10(%ebp)
    b0df:	88 03                	mov    %al,(%ebx)
    b0e1:	0f b6 03             	movzbl (%ebx),%eax
    b0e4:	88 01                	mov    %al,(%ecx)
    b0e6:	0f b6 11             	movzbl (%ecx),%edx
    b0e9:	8b 45 08             	mov    0x8(%ebp),%eax
    b0ec:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    b0ee:	8b 45 08             	mov    0x8(%ebp),%eax
    b0f1:	8d 50 03             	lea    0x3(%eax),%edx
    b0f4:	8b 45 14             	mov    0x14(%ebp),%eax
    b0f7:	8b 40 10             	mov    0x10(%eax),%eax
    b0fa:	85 c0                	test   %eax,%eax
    b0fc:	74 12                	je     b110 <getPixelColorsRGBA8+0x20d>
    b0fe:	8b 45 14             	mov    0x14(%ebp),%eax
    b101:	8b 40 14             	mov    0x14(%eax),%eax
    b104:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    b107:	75 07                	jne    b110 <getPixelColorsRGBA8+0x20d>
    b109:	b8 00 00 00 00       	mov    $0x0,%eax
    b10e:	eb 05                	jmp    b115 <getPixelColorsRGBA8+0x212>
    b110:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b115:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b117:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b11b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b11e:	01 45 08             	add    %eax,0x8(%ebp)
    b121:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b124:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b127:	0f 85 7b ff ff ff    	jne    b0a8 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b12d:	e9 9b 04 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b132:	8b 45 14             	mov    0x14(%ebp),%eax
    b135:	8b 00                	mov    (%eax),%eax
    b137:	83 f8 02             	cmp    $0x2,%eax
    b13a:	0f 85 41 02 00 00    	jne    b381 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    b140:	8b 45 14             	mov    0x14(%ebp),%eax
    b143:	8b 40 04             	mov    0x4(%eax),%eax
    b146:	83 f8 08             	cmp    $0x8,%eax
    b149:	0f 85 c4 00 00 00    	jne    b213 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b14f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b156:	eb 31                	jmp    b189 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    b158:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b15b:	89 d0                	mov    %edx,%eax
    b15d:	01 c0                	add    %eax,%eax
    b15f:	01 d0                	add    %edx,%eax
    b161:	89 c2                	mov    %eax,%edx
    b163:	8b 45 10             	mov    0x10(%ebp),%eax
    b166:	01 d0                	add    %edx,%eax
    b168:	6a 03                	push   $0x3
    b16a:	50                   	push   %eax
    b16b:	ff 75 08             	pushl  0x8(%ebp)
    b16e:	e8 a3 85 ff ff       	call   3716 <lodepng_memcpy>
    b173:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    b176:	8b 45 08             	mov    0x8(%ebp),%eax
    b179:	83 c0 03             	add    $0x3,%eax
    b17c:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b17f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b183:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b186:	01 45 08             	add    %eax,0x8(%ebp)
    b189:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b18c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b18f:	75 c7                	jne    b158 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b191:	8b 45 14             	mov    0x14(%ebp),%eax
    b194:	8b 40 10             	mov    0x10(%eax),%eax
    b197:	85 c0                	test   %eax,%eax
    b199:	0f 84 2e 04 00 00    	je     b5cd <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b19f:	8b 45 0c             	mov    0xc(%ebp),%eax
    b1a2:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b1a6:	f7 d8                	neg    %eax
    b1a8:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1ab:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b1b2:	eb 52                	jmp    b206 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    b1b4:	8b 45 08             	mov    0x8(%ebp),%eax
    b1b7:	0f b6 00             	movzbl (%eax),%eax
    b1ba:	0f b6 d0             	movzbl %al,%edx
    b1bd:	8b 45 14             	mov    0x14(%ebp),%eax
    b1c0:	8b 40 14             	mov    0x14(%eax),%eax
    b1c3:	39 c2                	cmp    %eax,%edx
    b1c5:	75 35                	jne    b1fc <getPixelColorsRGBA8+0x2f9>
    b1c7:	8b 45 08             	mov    0x8(%ebp),%eax
    b1ca:	83 c0 01             	add    $0x1,%eax
    b1cd:	0f b6 00             	movzbl (%eax),%eax
    b1d0:	0f b6 d0             	movzbl %al,%edx
    b1d3:	8b 45 14             	mov    0x14(%ebp),%eax
    b1d6:	8b 40 18             	mov    0x18(%eax),%eax
    b1d9:	39 c2                	cmp    %eax,%edx
    b1db:	75 1f                	jne    b1fc <getPixelColorsRGBA8+0x2f9>
    b1dd:	8b 45 08             	mov    0x8(%ebp),%eax
    b1e0:	83 c0 02             	add    $0x2,%eax
    b1e3:	0f b6 00             	movzbl (%eax),%eax
    b1e6:	0f b6 d0             	movzbl %al,%edx
    b1e9:	8b 45 14             	mov    0x14(%ebp),%eax
    b1ec:	8b 40 1c             	mov    0x1c(%eax),%eax
    b1ef:	39 c2                	cmp    %eax,%edx
    b1f1:	75 09                	jne    b1fc <getPixelColorsRGBA8+0x2f9>
    b1f3:	8b 45 08             	mov    0x8(%ebp),%eax
    b1f6:	83 c0 03             	add    $0x3,%eax
    b1f9:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1fc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b200:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b203:	01 45 08             	add    %eax,0x8(%ebp)
    b206:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b209:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b20c:	75 a6                	jne    b1b4 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b20e:	e9 ba 03 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b213:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b21a:	e9 51 01 00 00       	jmp    b370 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    b21f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b222:	89 d0                	mov    %edx,%eax
    b224:	01 c0                	add    %eax,%eax
    b226:	01 d0                	add    %edx,%eax
    b228:	01 c0                	add    %eax,%eax
    b22a:	89 c2                	mov    %eax,%edx
    b22c:	8b 45 10             	mov    0x10(%ebp),%eax
    b22f:	01 d0                	add    %edx,%eax
    b231:	0f b6 10             	movzbl (%eax),%edx
    b234:	8b 45 08             	mov    0x8(%ebp),%eax
    b237:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b239:	8b 45 08             	mov    0x8(%ebp),%eax
    b23c:	8d 48 01             	lea    0x1(%eax),%ecx
    b23f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b242:	89 d0                	mov    %edx,%eax
    b244:	01 c0                	add    %eax,%eax
    b246:	01 d0                	add    %edx,%eax
    b248:	01 c0                	add    %eax,%eax
    b24a:	8d 50 02             	lea    0x2(%eax),%edx
    b24d:	8b 45 10             	mov    0x10(%ebp),%eax
    b250:	01 d0                	add    %edx,%eax
    b252:	0f b6 00             	movzbl (%eax),%eax
    b255:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b257:	8b 45 08             	mov    0x8(%ebp),%eax
    b25a:	8d 48 02             	lea    0x2(%eax),%ecx
    b25d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b260:	89 d0                	mov    %edx,%eax
    b262:	01 c0                	add    %eax,%eax
    b264:	01 d0                	add    %edx,%eax
    b266:	01 c0                	add    %eax,%eax
    b268:	8d 50 04             	lea    0x4(%eax),%edx
    b26b:	8b 45 10             	mov    0x10(%ebp),%eax
    b26e:	01 d0                	add    %edx,%eax
    b270:	0f b6 00             	movzbl (%eax),%eax
    b273:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    b275:	8b 45 08             	mov    0x8(%ebp),%eax
    b278:	8d 48 03             	lea    0x3(%eax),%ecx
    b27b:	8b 45 14             	mov    0x14(%ebp),%eax
    b27e:	8b 40 10             	mov    0x10(%eax),%eax
    b281:	85 c0                	test   %eax,%eax
    b283:	0f 84 d6 00 00 00    	je     b35f <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b289:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b28c:	89 d0                	mov    %edx,%eax
    b28e:	01 c0                	add    %eax,%eax
    b290:	01 d0                	add    %edx,%eax
    b292:	01 c0                	add    %eax,%eax
    b294:	89 c2                	mov    %eax,%edx
    b296:	8b 45 10             	mov    0x10(%ebp),%eax
    b299:	01 d0                	add    %edx,%eax
    b29b:	0f b6 00             	movzbl (%eax),%eax
    b29e:	0f b6 c0             	movzbl %al,%eax
    b2a1:	c1 e0 08             	shl    $0x8,%eax
    b2a4:	89 c3                	mov    %eax,%ebx
    b2a6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b2a9:	89 d0                	mov    %edx,%eax
    b2ab:	01 c0                	add    %eax,%eax
    b2ad:	01 d0                	add    %edx,%eax
    b2af:	01 c0                	add    %eax,%eax
    b2b1:	8d 50 01             	lea    0x1(%eax),%edx
    b2b4:	8b 45 10             	mov    0x10(%ebp),%eax
    b2b7:	01 d0                	add    %edx,%eax
    b2b9:	0f b6 00             	movzbl (%eax),%eax
    b2bc:	0f b6 c0             	movzbl %al,%eax
    b2bf:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b2c2:	8b 45 14             	mov    0x14(%ebp),%eax
    b2c5:	8b 40 14             	mov    0x14(%eax),%eax
    b2c8:	39 c2                	cmp    %eax,%edx
    b2ca:	0f 85 8f 00 00 00    	jne    b35f <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b2d0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b2d3:	89 d0                	mov    %edx,%eax
    b2d5:	01 c0                	add    %eax,%eax
    b2d7:	01 d0                	add    %edx,%eax
    b2d9:	01 c0                	add    %eax,%eax
    b2db:	8d 50 02             	lea    0x2(%eax),%edx
    b2de:	8b 45 10             	mov    0x10(%ebp),%eax
    b2e1:	01 d0                	add    %edx,%eax
    b2e3:	0f b6 00             	movzbl (%eax),%eax
    b2e6:	0f b6 c0             	movzbl %al,%eax
    b2e9:	c1 e0 08             	shl    $0x8,%eax
    b2ec:	89 c3                	mov    %eax,%ebx
    b2ee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b2f1:	89 d0                	mov    %edx,%eax
    b2f3:	01 c0                	add    %eax,%eax
    b2f5:	01 d0                	add    %edx,%eax
    b2f7:	01 c0                	add    %eax,%eax
    b2f9:	8d 50 03             	lea    0x3(%eax),%edx
    b2fc:	8b 45 10             	mov    0x10(%ebp),%eax
    b2ff:	01 d0                	add    %edx,%eax
    b301:	0f b6 00             	movzbl (%eax),%eax
    b304:	0f b6 c0             	movzbl %al,%eax
    b307:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b30a:	8b 45 14             	mov    0x14(%ebp),%eax
    b30d:	8b 40 18             	mov    0x18(%eax),%eax
    b310:	39 c2                	cmp    %eax,%edx
    b312:	75 4b                	jne    b35f <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    b314:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b317:	89 d0                	mov    %edx,%eax
    b319:	01 c0                	add    %eax,%eax
    b31b:	01 d0                	add    %edx,%eax
    b31d:	01 c0                	add    %eax,%eax
    b31f:	8d 50 04             	lea    0x4(%eax),%edx
    b322:	8b 45 10             	mov    0x10(%ebp),%eax
    b325:	01 d0                	add    %edx,%eax
    b327:	0f b6 00             	movzbl (%eax),%eax
    b32a:	0f b6 c0             	movzbl %al,%eax
    b32d:	c1 e0 08             	shl    $0x8,%eax
    b330:	89 c3                	mov    %eax,%ebx
    b332:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b335:	89 d0                	mov    %edx,%eax
    b337:	01 c0                	add    %eax,%eax
    b339:	01 d0                	add    %edx,%eax
    b33b:	01 c0                	add    %eax,%eax
    b33d:	8d 50 05             	lea    0x5(%eax),%edx
    b340:	8b 45 10             	mov    0x10(%ebp),%eax
    b343:	01 d0                	add    %edx,%eax
    b345:	0f b6 00             	movzbl (%eax),%eax
    b348:	0f b6 c0             	movzbl %al,%eax
    b34b:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b34e:	8b 45 14             	mov    0x14(%ebp),%eax
    b351:	8b 40 1c             	mov    0x1c(%eax),%eax
    b354:	39 c2                	cmp    %eax,%edx
    b356:	75 07                	jne    b35f <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b358:	b8 00 00 00 00       	mov    $0x0,%eax
    b35d:	eb 05                	jmp    b364 <getPixelColorsRGBA8+0x461>
    b35f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b364:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b366:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b36a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b36d:	01 45 08             	add    %eax,0x8(%ebp)
    b370:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b373:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b376:	0f 85 a3 fe ff ff    	jne    b21f <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b37c:	e9 4c 02 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b381:	8b 45 14             	mov    0x14(%ebp),%eax
    b384:	8b 00                	mov    (%eax),%eax
    b386:	83 f8 03             	cmp    $0x3,%eax
    b389:	0f 85 b4 00 00 00    	jne    b443 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b38f:	8b 45 14             	mov    0x14(%ebp),%eax
    b392:	8b 40 04             	mov    0x4(%eax),%eax
    b395:	83 f8 08             	cmp    $0x8,%eax
    b398:	75 4d                	jne    b3e7 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b39a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3a1:	eb 37                	jmp    b3da <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b3a3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3a6:	8b 45 10             	mov    0x10(%ebp),%eax
    b3a9:	01 d0                	add    %edx,%eax
    b3ab:	0f b6 00             	movzbl (%eax),%eax
    b3ae:	0f b6 c0             	movzbl %al,%eax
    b3b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b3b4:	8b 45 14             	mov    0x14(%ebp),%eax
    b3b7:	8b 40 08             	mov    0x8(%eax),%eax
    b3ba:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b3bd:	c1 e2 02             	shl    $0x2,%edx
    b3c0:	01 d0                	add    %edx,%eax
    b3c2:	6a 04                	push   $0x4
    b3c4:	50                   	push   %eax
    b3c5:	ff 75 08             	pushl  0x8(%ebp)
    b3c8:	e8 49 83 ff ff       	call   3716 <lodepng_memcpy>
    b3cd:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3d0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3d7:	01 45 08             	add    %eax,0x8(%ebp)
    b3da:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3dd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3e0:	75 c1                	jne    b3a3 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b3e2:	e9 e6 01 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b3e7:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3ee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3f5:	eb 3f                	jmp    b436 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b3f7:	8b 45 14             	mov    0x14(%ebp),%eax
    b3fa:	8b 40 04             	mov    0x4(%eax),%eax
    b3fd:	50                   	push   %eax
    b3fe:	ff 75 10             	pushl  0x10(%ebp)
    b401:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b404:	50                   	push   %eax
    b405:	e8 71 d1 ff ff       	call   857b <readBitsFromReversedStream>
    b40a:	83 c4 0c             	add    $0xc,%esp
    b40d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b410:	8b 45 14             	mov    0x14(%ebp),%eax
    b413:	8b 40 08             	mov    0x8(%eax),%eax
    b416:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b419:	c1 e2 02             	shl    $0x2,%edx
    b41c:	01 d0                	add    %edx,%eax
    b41e:	6a 04                	push   $0x4
    b420:	50                   	push   %eax
    b421:	ff 75 08             	pushl  0x8(%ebp)
    b424:	e8 ed 82 ff ff       	call   3716 <lodepng_memcpy>
    b429:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b42c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b430:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b433:	01 45 08             	add    %eax,0x8(%ebp)
    b436:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b439:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b43c:	75 b9                	jne    b3f7 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b43e:	e9 8a 01 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b443:	8b 45 14             	mov    0x14(%ebp),%eax
    b446:	8b 00                	mov    (%eax),%eax
    b448:	83 f8 04             	cmp    $0x4,%eax
    b44b:	0f 85 d1 00 00 00    	jne    b522 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b451:	8b 45 14             	mov    0x14(%ebp),%eax
    b454:	8b 40 04             	mov    0x4(%eax),%eax
    b457:	83 f8 08             	cmp    $0x8,%eax
    b45a:	75 62                	jne    b4be <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b45c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b463:	eb 4c                	jmp    b4b1 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b465:	8b 45 08             	mov    0x8(%ebp),%eax
    b468:	83 c0 01             	add    $0x1,%eax
    b46b:	8b 55 08             	mov    0x8(%ebp),%edx
    b46e:	83 c2 02             	add    $0x2,%edx
    b471:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b474:	01 c9                	add    %ecx,%ecx
    b476:	89 cb                	mov    %ecx,%ebx
    b478:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b47b:	01 d9                	add    %ebx,%ecx
    b47d:	0f b6 09             	movzbl (%ecx),%ecx
    b480:	88 0a                	mov    %cl,(%edx)
    b482:	0f b6 12             	movzbl (%edx),%edx
    b485:	88 10                	mov    %dl,(%eax)
    b487:	0f b6 10             	movzbl (%eax),%edx
    b48a:	8b 45 08             	mov    0x8(%ebp),%eax
    b48d:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b48f:	8b 45 08             	mov    0x8(%ebp),%eax
    b492:	8d 50 03             	lea    0x3(%eax),%edx
    b495:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b498:	01 c0                	add    %eax,%eax
    b49a:	8d 48 01             	lea    0x1(%eax),%ecx
    b49d:	8b 45 10             	mov    0x10(%ebp),%eax
    b4a0:	01 c8                	add    %ecx,%eax
    b4a2:	0f b6 00             	movzbl (%eax),%eax
    b4a5:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4a7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4ae:	01 45 08             	add    %eax,0x8(%ebp)
    b4b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4b4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4b7:	75 ac                	jne    b465 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b4b9:	e9 0f 01 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4c5:	eb 4e                	jmp    b515 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b4c7:	8b 45 08             	mov    0x8(%ebp),%eax
    b4ca:	83 c0 01             	add    $0x1,%eax
    b4cd:	8b 55 08             	mov    0x8(%ebp),%edx
    b4d0:	83 c2 02             	add    $0x2,%edx
    b4d3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b4d6:	c1 e1 02             	shl    $0x2,%ecx
    b4d9:	89 cb                	mov    %ecx,%ebx
    b4db:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b4de:	01 d9                	add    %ebx,%ecx
    b4e0:	0f b6 09             	movzbl (%ecx),%ecx
    b4e3:	88 0a                	mov    %cl,(%edx)
    b4e5:	0f b6 12             	movzbl (%edx),%edx
    b4e8:	88 10                	mov    %dl,(%eax)
    b4ea:	0f b6 10             	movzbl (%eax),%edx
    b4ed:	8b 45 08             	mov    0x8(%ebp),%eax
    b4f0:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b4f2:	8b 45 08             	mov    0x8(%ebp),%eax
    b4f5:	8d 50 03             	lea    0x3(%eax),%edx
    b4f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4fb:	c1 e0 02             	shl    $0x2,%eax
    b4fe:	8d 48 02             	lea    0x2(%eax),%ecx
    b501:	8b 45 10             	mov    0x10(%ebp),%eax
    b504:	01 c8                	add    %ecx,%eax
    b506:	0f b6 00             	movzbl (%eax),%eax
    b509:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b50b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b50f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b512:	01 45 08             	add    %eax,0x8(%ebp)
    b515:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b518:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b51b:	75 aa                	jne    b4c7 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b51d:	e9 ab 00 00 00       	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b522:	8b 45 14             	mov    0x14(%ebp),%eax
    b525:	8b 00                	mov    (%eax),%eax
    b527:	83 f8 06             	cmp    $0x6,%eax
    b52a:	0f 85 9d 00 00 00    	jne    b5cd <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b530:	8b 45 14             	mov    0x14(%ebp),%eax
    b533:	8b 40 04             	mov    0x4(%eax),%eax
    b536:	83 f8 08             	cmp    $0x8,%eax
    b539:	75 17                	jne    b552 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b53b:	8b 45 0c             	mov    0xc(%ebp),%eax
    b53e:	c1 e0 02             	shl    $0x2,%eax
    b541:	50                   	push   %eax
    b542:	ff 75 10             	pushl  0x10(%ebp)
    b545:	ff 75 08             	pushl  0x8(%ebp)
    b548:	e8 c9 81 ff ff       	call   3716 <lodepng_memcpy>
    b54d:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b550:	eb 7b                	jmp    b5cd <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b552:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b559:	eb 6a                	jmp    b5c5 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b55b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b55e:	c1 e0 03             	shl    $0x3,%eax
    b561:	89 c2                	mov    %eax,%edx
    b563:	8b 45 10             	mov    0x10(%ebp),%eax
    b566:	01 d0                	add    %edx,%eax
    b568:	0f b6 10             	movzbl (%eax),%edx
    b56b:	8b 45 08             	mov    0x8(%ebp),%eax
    b56e:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b570:	8b 45 08             	mov    0x8(%ebp),%eax
    b573:	8d 50 01             	lea    0x1(%eax),%edx
    b576:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b579:	c1 e0 03             	shl    $0x3,%eax
    b57c:	8d 48 02             	lea    0x2(%eax),%ecx
    b57f:	8b 45 10             	mov    0x10(%ebp),%eax
    b582:	01 c8                	add    %ecx,%eax
    b584:	0f b6 00             	movzbl (%eax),%eax
    b587:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b589:	8b 45 08             	mov    0x8(%ebp),%eax
    b58c:	8d 50 02             	lea    0x2(%eax),%edx
    b58f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b592:	c1 e0 03             	shl    $0x3,%eax
    b595:	8d 48 04             	lea    0x4(%eax),%ecx
    b598:	8b 45 10             	mov    0x10(%ebp),%eax
    b59b:	01 c8                	add    %ecx,%eax
    b59d:	0f b6 00             	movzbl (%eax),%eax
    b5a0:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b5a2:	8b 45 08             	mov    0x8(%ebp),%eax
    b5a5:	8d 50 03             	lea    0x3(%eax),%edx
    b5a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5ab:	c1 e0 03             	shl    $0x3,%eax
    b5ae:	8d 48 06             	lea    0x6(%eax),%ecx
    b5b1:	8b 45 10             	mov    0x10(%ebp),%eax
    b5b4:	01 c8                	add    %ecx,%eax
    b5b6:	0f b6 00             	movzbl (%eax),%eax
    b5b9:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5bb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5c2:	01 45 08             	add    %eax,0x8(%ebp)
    b5c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5c8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5cb:	75 8e                	jne    b55b <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b5cd:	90                   	nop
    b5ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b5d1:	c9                   	leave  
    b5d2:	c3                   	ret    

0000b5d3 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b5d3:	55                   	push   %ebp
    b5d4:	89 e5                	mov    %esp,%ebp
    b5d6:	53                   	push   %ebx
    b5d7:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b5da:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b5e1:	8b 45 14             	mov    0x14(%ebp),%eax
    b5e4:	8b 00                	mov    (%eax),%eax
    b5e6:	85 c0                	test   %eax,%eax
    b5e8:	0f 85 2a 01 00 00    	jne    b718 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b5ee:	8b 45 14             	mov    0x14(%ebp),%eax
    b5f1:	8b 40 04             	mov    0x4(%eax),%eax
    b5f4:	83 f8 08             	cmp    $0x8,%eax
    b5f7:	75 46                	jne    b63f <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5f9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b600:	eb 30                	jmp    b632 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b602:	8b 45 08             	mov    0x8(%ebp),%eax
    b605:	83 c0 01             	add    $0x1,%eax
    b608:	8b 55 08             	mov    0x8(%ebp),%edx
    b60b:	83 c2 02             	add    $0x2,%edx
    b60e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b611:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b614:	01 d9                	add    %ebx,%ecx
    b616:	0f b6 09             	movzbl (%ecx),%ecx
    b619:	88 0a                	mov    %cl,(%edx)
    b61b:	0f b6 12             	movzbl (%edx),%edx
    b61e:	88 10                	mov    %dl,(%eax)
    b620:	0f b6 10             	movzbl (%eax),%edx
    b623:	8b 45 08             	mov    0x8(%ebp),%eax
    b626:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b628:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b62c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b62f:	01 45 08             	add    %eax,0x8(%ebp)
    b632:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b635:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b638:	75 c8                	jne    b602 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b63a:	e9 a8 03 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b63f:	8b 45 14             	mov    0x14(%ebp),%eax
    b642:	8b 40 04             	mov    0x4(%eax),%eax
    b645:	83 f8 10             	cmp    $0x10,%eax
    b648:	75 4a                	jne    b694 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b64a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b651:	eb 34                	jmp    b687 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b653:	8b 45 08             	mov    0x8(%ebp),%eax
    b656:	83 c0 01             	add    $0x1,%eax
    b659:	8b 55 08             	mov    0x8(%ebp),%edx
    b65c:	83 c2 02             	add    $0x2,%edx
    b65f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b662:	01 c9                	add    %ecx,%ecx
    b664:	89 cb                	mov    %ecx,%ebx
    b666:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b669:	01 d9                	add    %ebx,%ecx
    b66b:	0f b6 09             	movzbl (%ecx),%ecx
    b66e:	88 0a                	mov    %cl,(%edx)
    b670:	0f b6 12             	movzbl (%edx),%edx
    b673:	88 10                	mov    %dl,(%eax)
    b675:	0f b6 10             	movzbl (%eax),%edx
    b678:	8b 45 08             	mov    0x8(%ebp),%eax
    b67b:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b67d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b681:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b684:	01 45 08             	add    %eax,0x8(%ebp)
    b687:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b68a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b68d:	75 c4                	jne    b653 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b68f:	e9 53 03 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b694:	8b 45 14             	mov    0x14(%ebp),%eax
    b697:	8b 40 04             	mov    0x4(%eax),%eax
    b69a:	ba 01 00 00 00       	mov    $0x1,%edx
    b69f:	89 c1                	mov    %eax,%ecx
    b6a1:	d3 e2                	shl    %cl,%edx
    b6a3:	89 d0                	mov    %edx,%eax
    b6a5:	83 e8 01             	sub    $0x1,%eax
    b6a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b6ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6b2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b6b9:	eb 50                	jmp    b70b <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b6bb:	8b 45 14             	mov    0x14(%ebp),%eax
    b6be:	8b 40 04             	mov    0x4(%eax),%eax
    b6c1:	50                   	push   %eax
    b6c2:	ff 75 10             	pushl  0x10(%ebp)
    b6c5:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b6c8:	50                   	push   %eax
    b6c9:	e8 ad ce ff ff       	call   857b <readBitsFromReversedStream>
    b6ce:	83 c4 0c             	add    $0xc,%esp
    b6d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b6d4:	8b 45 08             	mov    0x8(%ebp),%eax
    b6d7:	8d 48 01             	lea    0x1(%eax),%ecx
    b6da:	8b 45 08             	mov    0x8(%ebp),%eax
    b6dd:	8d 58 02             	lea    0x2(%eax),%ebx
    b6e0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b6e3:	89 d0                	mov    %edx,%eax
    b6e5:	c1 e0 08             	shl    $0x8,%eax
    b6e8:	29 d0                	sub    %edx,%eax
    b6ea:	ba 00 00 00 00       	mov    $0x0,%edx
    b6ef:	f7 75 f0             	divl   -0x10(%ebp)
    b6f2:	88 03                	mov    %al,(%ebx)
    b6f4:	0f b6 03             	movzbl (%ebx),%eax
    b6f7:	88 01                	mov    %al,(%ecx)
    b6f9:	0f b6 11             	movzbl (%ecx),%edx
    b6fc:	8b 45 08             	mov    0x8(%ebp),%eax
    b6ff:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b701:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b705:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b708:	01 45 08             	add    %eax,0x8(%ebp)
    b70b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b70e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b711:	75 a8                	jne    b6bb <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b713:	e9 cf 02 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b718:	8b 45 14             	mov    0x14(%ebp),%eax
    b71b:	8b 00                	mov    (%eax),%eax
    b71d:	83 f8 02             	cmp    $0x2,%eax
    b720:	0f 85 9e 00 00 00    	jne    b7c4 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b726:	8b 45 14             	mov    0x14(%ebp),%eax
    b729:	8b 40 04             	mov    0x4(%eax),%eax
    b72c:	83 f8 08             	cmp    $0x8,%eax
    b72f:	75 1d                	jne    b74e <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b731:	8b 55 0c             	mov    0xc(%ebp),%edx
    b734:	89 d0                	mov    %edx,%eax
    b736:	01 c0                	add    %eax,%eax
    b738:	01 d0                	add    %edx,%eax
    b73a:	50                   	push   %eax
    b73b:	ff 75 10             	pushl  0x10(%ebp)
    b73e:	ff 75 08             	pushl  0x8(%ebp)
    b741:	e8 d0 7f ff ff       	call   3716 <lodepng_memcpy>
    b746:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b749:	e9 99 02 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b74e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b755:	eb 60                	jmp    b7b7 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b757:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b75a:	89 d0                	mov    %edx,%eax
    b75c:	01 c0                	add    %eax,%eax
    b75e:	01 d0                	add    %edx,%eax
    b760:	01 c0                	add    %eax,%eax
    b762:	89 c2                	mov    %eax,%edx
    b764:	8b 45 10             	mov    0x10(%ebp),%eax
    b767:	01 d0                	add    %edx,%eax
    b769:	0f b6 10             	movzbl (%eax),%edx
    b76c:	8b 45 08             	mov    0x8(%ebp),%eax
    b76f:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b771:	8b 45 08             	mov    0x8(%ebp),%eax
    b774:	8d 48 01             	lea    0x1(%eax),%ecx
    b777:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b77a:	89 d0                	mov    %edx,%eax
    b77c:	01 c0                	add    %eax,%eax
    b77e:	01 d0                	add    %edx,%eax
    b780:	01 c0                	add    %eax,%eax
    b782:	8d 50 02             	lea    0x2(%eax),%edx
    b785:	8b 45 10             	mov    0x10(%ebp),%eax
    b788:	01 d0                	add    %edx,%eax
    b78a:	0f b6 00             	movzbl (%eax),%eax
    b78d:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b78f:	8b 45 08             	mov    0x8(%ebp),%eax
    b792:	8d 48 02             	lea    0x2(%eax),%ecx
    b795:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b798:	89 d0                	mov    %edx,%eax
    b79a:	01 c0                	add    %eax,%eax
    b79c:	01 d0                	add    %edx,%eax
    b79e:	01 c0                	add    %eax,%eax
    b7a0:	8d 50 04             	lea    0x4(%eax),%edx
    b7a3:	8b 45 10             	mov    0x10(%ebp),%eax
    b7a6:	01 d0                	add    %edx,%eax
    b7a8:	0f b6 00             	movzbl (%eax),%eax
    b7ab:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7ad:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b7b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b7b4:	01 45 08             	add    %eax,0x8(%ebp)
    b7b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b7ba:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b7bd:	75 98                	jne    b757 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b7bf:	e9 23 02 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b7c4:	8b 45 14             	mov    0x14(%ebp),%eax
    b7c7:	8b 00                	mov    (%eax),%eax
    b7c9:	83 f8 03             	cmp    $0x3,%eax
    b7cc:	0f 85 b4 00 00 00    	jne    b886 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b7d2:	8b 45 14             	mov    0x14(%ebp),%eax
    b7d5:	8b 40 04             	mov    0x4(%eax),%eax
    b7d8:	83 f8 08             	cmp    $0x8,%eax
    b7db:	75 4d                	jne    b82a <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b7e4:	eb 37                	jmp    b81d <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b7e6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b7e9:	8b 45 10             	mov    0x10(%ebp),%eax
    b7ec:	01 d0                	add    %edx,%eax
    b7ee:	0f b6 00             	movzbl (%eax),%eax
    b7f1:	0f b6 c0             	movzbl %al,%eax
    b7f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b7f7:	8b 45 14             	mov    0x14(%ebp),%eax
    b7fa:	8b 40 08             	mov    0x8(%eax),%eax
    b7fd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b800:	c1 e2 02             	shl    $0x2,%edx
    b803:	01 d0                	add    %edx,%eax
    b805:	6a 03                	push   $0x3
    b807:	50                   	push   %eax
    b808:	ff 75 08             	pushl  0x8(%ebp)
    b80b:	e8 06 7f ff ff       	call   3716 <lodepng_memcpy>
    b810:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b813:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b817:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b81a:	01 45 08             	add    %eax,0x8(%ebp)
    b81d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b820:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b823:	75 c1                	jne    b7e6 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b825:	e9 bd 01 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b82a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b831:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b838:	eb 3f                	jmp    b879 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b83a:	8b 45 14             	mov    0x14(%ebp),%eax
    b83d:	8b 40 04             	mov    0x4(%eax),%eax
    b840:	50                   	push   %eax
    b841:	ff 75 10             	pushl  0x10(%ebp)
    b844:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b847:	50                   	push   %eax
    b848:	e8 2e cd ff ff       	call   857b <readBitsFromReversedStream>
    b84d:	83 c4 0c             	add    $0xc,%esp
    b850:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b853:	8b 45 14             	mov    0x14(%ebp),%eax
    b856:	8b 40 08             	mov    0x8(%eax),%eax
    b859:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b85c:	c1 e2 02             	shl    $0x2,%edx
    b85f:	01 d0                	add    %edx,%eax
    b861:	6a 03                	push   $0x3
    b863:	50                   	push   %eax
    b864:	ff 75 08             	pushl  0x8(%ebp)
    b867:	e8 aa 7e ff ff       	call   3716 <lodepng_memcpy>
    b86c:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b86f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b873:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b876:	01 45 08             	add    %eax,0x8(%ebp)
    b879:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b87c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b87f:	75 b9                	jne    b83a <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b881:	e9 61 01 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b886:	8b 45 14             	mov    0x14(%ebp),%eax
    b889:	8b 00                	mov    (%eax),%eax
    b88b:	83 f8 04             	cmp    $0x4,%eax
    b88e:	0f 85 a0 00 00 00    	jne    b934 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b894:	8b 45 14             	mov    0x14(%ebp),%eax
    b897:	8b 40 04             	mov    0x4(%eax),%eax
    b89a:	83 f8 08             	cmp    $0x8,%eax
    b89d:	75 4a                	jne    b8e9 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b89f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b8a6:	eb 34                	jmp    b8dc <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b8a8:	8b 45 08             	mov    0x8(%ebp),%eax
    b8ab:	83 c0 01             	add    $0x1,%eax
    b8ae:	8b 55 08             	mov    0x8(%ebp),%edx
    b8b1:	83 c2 02             	add    $0x2,%edx
    b8b4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b8b7:	01 c9                	add    %ecx,%ecx
    b8b9:	89 cb                	mov    %ecx,%ebx
    b8bb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b8be:	01 d9                	add    %ebx,%ecx
    b8c0:	0f b6 09             	movzbl (%ecx),%ecx
    b8c3:	88 0a                	mov    %cl,(%edx)
    b8c5:	0f b6 12             	movzbl (%edx),%edx
    b8c8:	88 10                	mov    %dl,(%eax)
    b8ca:	0f b6 10             	movzbl (%eax),%edx
    b8cd:	8b 45 08             	mov    0x8(%ebp),%eax
    b8d0:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b8d2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b8d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b8d9:	01 45 08             	add    %eax,0x8(%ebp)
    b8dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8df:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b8e2:	75 c4                	jne    b8a8 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b8e4:	e9 fe 00 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b8e9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b8f0:	eb 35                	jmp    b927 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b8f2:	8b 45 08             	mov    0x8(%ebp),%eax
    b8f5:	83 c0 01             	add    $0x1,%eax
    b8f8:	8b 55 08             	mov    0x8(%ebp),%edx
    b8fb:	83 c2 02             	add    $0x2,%edx
    b8fe:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b901:	c1 e1 02             	shl    $0x2,%ecx
    b904:	89 cb                	mov    %ecx,%ebx
    b906:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b909:	01 d9                	add    %ebx,%ecx
    b90b:	0f b6 09             	movzbl (%ecx),%ecx
    b90e:	88 0a                	mov    %cl,(%edx)
    b910:	0f b6 12             	movzbl (%edx),%edx
    b913:	88 10                	mov    %dl,(%eax)
    b915:	0f b6 10             	movzbl (%eax),%edx
    b918:	8b 45 08             	mov    0x8(%ebp),%eax
    b91b:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b91d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b921:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b924:	01 45 08             	add    %eax,0x8(%ebp)
    b927:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b92a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b92d:	75 c3                	jne    b8f2 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b92f:	e9 b3 00 00 00       	jmp    b9e7 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b934:	8b 45 14             	mov    0x14(%ebp),%eax
    b937:	8b 00                	mov    (%eax),%eax
    b939:	83 f8 06             	cmp    $0x6,%eax
    b93c:	0f 85 a5 00 00 00    	jne    b9e7 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b942:	8b 45 14             	mov    0x14(%ebp),%eax
    b945:	8b 40 04             	mov    0x4(%eax),%eax
    b948:	83 f8 08             	cmp    $0x8,%eax
    b94b:	75 38                	jne    b985 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b94d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b954:	eb 25                	jmp    b97b <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b956:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b959:	c1 e0 02             	shl    $0x2,%eax
    b95c:	89 c2                	mov    %eax,%edx
    b95e:	8b 45 10             	mov    0x10(%ebp),%eax
    b961:	01 d0                	add    %edx,%eax
    b963:	6a 03                	push   $0x3
    b965:	50                   	push   %eax
    b966:	ff 75 08             	pushl  0x8(%ebp)
    b969:	e8 a8 7d ff ff       	call   3716 <lodepng_memcpy>
    b96e:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b971:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b975:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b978:	01 45 08             	add    %eax,0x8(%ebp)
    b97b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b97e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b981:	75 d3                	jne    b956 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b983:	eb 62                	jmp    b9e7 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b985:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b98c:	eb 51                	jmp    b9df <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b98e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b991:	c1 e0 03             	shl    $0x3,%eax
    b994:	89 c2                	mov    %eax,%edx
    b996:	8b 45 10             	mov    0x10(%ebp),%eax
    b999:	01 d0                	add    %edx,%eax
    b99b:	0f b6 10             	movzbl (%eax),%edx
    b99e:	8b 45 08             	mov    0x8(%ebp),%eax
    b9a1:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b9a3:	8b 45 08             	mov    0x8(%ebp),%eax
    b9a6:	8d 50 01             	lea    0x1(%eax),%edx
    b9a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b9ac:	c1 e0 03             	shl    $0x3,%eax
    b9af:	8d 48 02             	lea    0x2(%eax),%ecx
    b9b2:	8b 45 10             	mov    0x10(%ebp),%eax
    b9b5:	01 c8                	add    %ecx,%eax
    b9b7:	0f b6 00             	movzbl (%eax),%eax
    b9ba:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b9bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b9bf:	8d 50 02             	lea    0x2(%eax),%edx
    b9c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b9c5:	c1 e0 03             	shl    $0x3,%eax
    b9c8:	8d 48 04             	lea    0x4(%eax),%ecx
    b9cb:	8b 45 10             	mov    0x10(%ebp),%eax
    b9ce:	01 c8                	add    %ecx,%eax
    b9d0:	0f b6 00             	movzbl (%eax),%eax
    b9d3:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b9d5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b9d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b9dc:	01 45 08             	add    %eax,0x8(%ebp)
    b9df:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b9e2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b9e5:	75 a7                	jne    b98e <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b9e7:	90                   	nop
    b9e8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b9eb:	c9                   	leave  
    b9ec:	c3                   	ret    

0000b9ed <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b9ed:	55                   	push   %ebp
    b9ee:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b9f0:	8b 45 20             	mov    0x20(%ebp),%eax
    b9f3:	8b 00                	mov    (%eax),%eax
    b9f5:	85 c0                	test   %eax,%eax
    b9f7:	0f 85 a4 00 00 00    	jne    baa1 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b9fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba00:	01 c0                	add    %eax,%eax
    ba02:	89 c2                	mov    %eax,%edx
    ba04:	8b 45 18             	mov    0x18(%ebp),%eax
    ba07:	01 d0                	add    %edx,%eax
    ba09:	0f b6 00             	movzbl (%eax),%eax
    ba0c:	0f b6 c0             	movzbl %al,%eax
    ba0f:	c1 e0 08             	shl    $0x8,%eax
    ba12:	89 c2                	mov    %eax,%edx
    ba14:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba17:	01 c0                	add    %eax,%eax
    ba19:	8d 48 01             	lea    0x1(%eax),%ecx
    ba1c:	8b 45 18             	mov    0x18(%ebp),%eax
    ba1f:	01 c8                	add    %ecx,%eax
    ba21:	0f b6 00             	movzbl (%eax),%eax
    ba24:	0f b6 c0             	movzbl %al,%eax
    ba27:	01 c2                	add    %eax,%edx
    ba29:	8b 45 10             	mov    0x10(%ebp),%eax
    ba2c:	66 89 10             	mov    %dx,(%eax)
    ba2f:	8b 45 10             	mov    0x10(%ebp),%eax
    ba32:	0f b7 10             	movzwl (%eax),%edx
    ba35:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba38:	66 89 10             	mov    %dx,(%eax)
    ba3b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba3e:	0f b7 10             	movzwl (%eax),%edx
    ba41:	8b 45 08             	mov    0x8(%ebp),%eax
    ba44:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    ba47:	8b 45 20             	mov    0x20(%ebp),%eax
    ba4a:	8b 40 10             	mov    0x10(%eax),%eax
    ba4d:	85 c0                	test   %eax,%eax
    ba4f:	74 43                	je     ba94 <getPixelColorRGBA16+0xa7>
    ba51:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba54:	01 c0                	add    %eax,%eax
    ba56:	89 c2                	mov    %eax,%edx
    ba58:	8b 45 18             	mov    0x18(%ebp),%eax
    ba5b:	01 d0                	add    %edx,%eax
    ba5d:	0f b6 00             	movzbl (%eax),%eax
    ba60:	0f b6 c0             	movzbl %al,%eax
    ba63:	c1 e0 08             	shl    $0x8,%eax
    ba66:	89 c2                	mov    %eax,%edx
    ba68:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba6b:	01 c0                	add    %eax,%eax
    ba6d:	8d 48 01             	lea    0x1(%eax),%ecx
    ba70:	8b 45 18             	mov    0x18(%ebp),%eax
    ba73:	01 c8                	add    %ecx,%eax
    ba75:	0f b6 00             	movzbl (%eax),%eax
    ba78:	0f b6 c0             	movzbl %al,%eax
    ba7b:	01 c2                	add    %eax,%edx
    ba7d:	8b 45 20             	mov    0x20(%ebp),%eax
    ba80:	8b 40 14             	mov    0x14(%eax),%eax
    ba83:	39 c2                	cmp    %eax,%edx
    ba85:	75 0d                	jne    ba94 <getPixelColorRGBA16+0xa7>
    ba87:	8b 45 14             	mov    0x14(%ebp),%eax
    ba8a:	66 c7 00 00 00       	movw   $0x0,(%eax)
    ba8f:	e9 48 03 00 00       	jmp    bddc <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    ba94:	8b 45 14             	mov    0x14(%ebp),%eax
    ba97:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    ba9c:	e9 3b 03 00 00       	jmp    bddc <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    baa1:	8b 45 20             	mov    0x20(%ebp),%eax
    baa4:	8b 00                	mov    (%eax),%eax
    baa6:	83 f8 02             	cmp    $0x2,%eax
    baa9:	0f 85 b6 01 00 00    	jne    bc65 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    baaf:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bab2:	89 d0                	mov    %edx,%eax
    bab4:	01 c0                	add    %eax,%eax
    bab6:	01 d0                	add    %edx,%eax
    bab8:	01 c0                	add    %eax,%eax
    baba:	89 c2                	mov    %eax,%edx
    babc:	8b 45 18             	mov    0x18(%ebp),%eax
    babf:	01 d0                	add    %edx,%eax
    bac1:	0f b6 00             	movzbl (%eax),%eax
    bac4:	0f b6 c0             	movzbl %al,%eax
    bac7:	c1 e0 08             	shl    $0x8,%eax
    baca:	89 c1                	mov    %eax,%ecx
    bacc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bacf:	89 d0                	mov    %edx,%eax
    bad1:	01 c0                	add    %eax,%eax
    bad3:	01 d0                	add    %edx,%eax
    bad5:	01 c0                	add    %eax,%eax
    bad7:	8d 50 01             	lea    0x1(%eax),%edx
    bada:	8b 45 18             	mov    0x18(%ebp),%eax
    badd:	01 d0                	add    %edx,%eax
    badf:	0f b6 00             	movzbl (%eax),%eax
    bae2:	0f b6 c0             	movzbl %al,%eax
    bae5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bae8:	8b 45 08             	mov    0x8(%ebp),%eax
    baeb:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    baee:	8b 55 1c             	mov    0x1c(%ebp),%edx
    baf1:	89 d0                	mov    %edx,%eax
    baf3:	01 c0                	add    %eax,%eax
    baf5:	01 d0                	add    %edx,%eax
    baf7:	01 c0                	add    %eax,%eax
    baf9:	8d 50 02             	lea    0x2(%eax),%edx
    bafc:	8b 45 18             	mov    0x18(%ebp),%eax
    baff:	01 d0                	add    %edx,%eax
    bb01:	0f b6 00             	movzbl (%eax),%eax
    bb04:	0f b6 c0             	movzbl %al,%eax
    bb07:	c1 e0 08             	shl    $0x8,%eax
    bb0a:	89 c1                	mov    %eax,%ecx
    bb0c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb0f:	89 d0                	mov    %edx,%eax
    bb11:	01 c0                	add    %eax,%eax
    bb13:	01 d0                	add    %edx,%eax
    bb15:	01 c0                	add    %eax,%eax
    bb17:	8d 50 03             	lea    0x3(%eax),%edx
    bb1a:	8b 45 18             	mov    0x18(%ebp),%eax
    bb1d:	01 d0                	add    %edx,%eax
    bb1f:	0f b6 00             	movzbl (%eax),%eax
    bb22:	0f b6 c0             	movzbl %al,%eax
    bb25:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bb28:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb2b:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    bb2e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb31:	89 d0                	mov    %edx,%eax
    bb33:	01 c0                	add    %eax,%eax
    bb35:	01 d0                	add    %edx,%eax
    bb37:	01 c0                	add    %eax,%eax
    bb39:	8d 50 04             	lea    0x4(%eax),%edx
    bb3c:	8b 45 18             	mov    0x18(%ebp),%eax
    bb3f:	01 d0                	add    %edx,%eax
    bb41:	0f b6 00             	movzbl (%eax),%eax
    bb44:	0f b6 c0             	movzbl %al,%eax
    bb47:	c1 e0 08             	shl    $0x8,%eax
    bb4a:	89 c1                	mov    %eax,%ecx
    bb4c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb4f:	89 d0                	mov    %edx,%eax
    bb51:	01 c0                	add    %eax,%eax
    bb53:	01 d0                	add    %edx,%eax
    bb55:	01 c0                	add    %eax,%eax
    bb57:	8d 50 05             	lea    0x5(%eax),%edx
    bb5a:	8b 45 18             	mov    0x18(%ebp),%eax
    bb5d:	01 d0                	add    %edx,%eax
    bb5f:	0f b6 00             	movzbl (%eax),%eax
    bb62:	0f b6 c0             	movzbl %al,%eax
    bb65:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bb68:	8b 45 10             	mov    0x10(%ebp),%eax
    bb6b:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    bb6e:	8b 45 20             	mov    0x20(%ebp),%eax
    bb71:	8b 40 10             	mov    0x10(%eax),%eax
    bb74:	85 c0                	test   %eax,%eax
    bb76:	0f 84 dc 00 00 00    	je     bc58 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    bb7c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb7f:	89 d0                	mov    %edx,%eax
    bb81:	01 c0                	add    %eax,%eax
    bb83:	01 d0                	add    %edx,%eax
    bb85:	01 c0                	add    %eax,%eax
    bb87:	89 c2                	mov    %eax,%edx
    bb89:	8b 45 18             	mov    0x18(%ebp),%eax
    bb8c:	01 d0                	add    %edx,%eax
    bb8e:	0f b6 00             	movzbl (%eax),%eax
    bb91:	0f b6 c0             	movzbl %al,%eax
    bb94:	c1 e0 08             	shl    $0x8,%eax
    bb97:	89 c1                	mov    %eax,%ecx
    bb99:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb9c:	89 d0                	mov    %edx,%eax
    bb9e:	01 c0                	add    %eax,%eax
    bba0:	01 d0                	add    %edx,%eax
    bba2:	01 c0                	add    %eax,%eax
    bba4:	8d 50 01             	lea    0x1(%eax),%edx
    bba7:	8b 45 18             	mov    0x18(%ebp),%eax
    bbaa:	01 d0                	add    %edx,%eax
    bbac:	0f b6 00             	movzbl (%eax),%eax
    bbaf:	0f b6 c0             	movzbl %al,%eax
    bbb2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bbb5:	8b 45 20             	mov    0x20(%ebp),%eax
    bbb8:	8b 40 14             	mov    0x14(%eax),%eax
    bbbb:	39 c2                	cmp    %eax,%edx
    bbbd:	0f 85 95 00 00 00    	jne    bc58 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    bbc3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bbc6:	89 d0                	mov    %edx,%eax
    bbc8:	01 c0                	add    %eax,%eax
    bbca:	01 d0                	add    %edx,%eax
    bbcc:	01 c0                	add    %eax,%eax
    bbce:	8d 50 02             	lea    0x2(%eax),%edx
    bbd1:	8b 45 18             	mov    0x18(%ebp),%eax
    bbd4:	01 d0                	add    %edx,%eax
    bbd6:	0f b6 00             	movzbl (%eax),%eax
    bbd9:	0f b6 c0             	movzbl %al,%eax
    bbdc:	c1 e0 08             	shl    $0x8,%eax
    bbdf:	89 c1                	mov    %eax,%ecx
    bbe1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bbe4:	89 d0                	mov    %edx,%eax
    bbe6:	01 c0                	add    %eax,%eax
    bbe8:	01 d0                	add    %edx,%eax
    bbea:	01 c0                	add    %eax,%eax
    bbec:	8d 50 03             	lea    0x3(%eax),%edx
    bbef:	8b 45 18             	mov    0x18(%ebp),%eax
    bbf2:	01 d0                	add    %edx,%eax
    bbf4:	0f b6 00             	movzbl (%eax),%eax
    bbf7:	0f b6 c0             	movzbl %al,%eax
    bbfa:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bbfd:	8b 45 20             	mov    0x20(%ebp),%eax
    bc00:	8b 40 18             	mov    0x18(%eax),%eax
    bc03:	39 c2                	cmp    %eax,%edx
    bc05:	75 51                	jne    bc58 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    bc07:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bc0a:	89 d0                	mov    %edx,%eax
    bc0c:	01 c0                	add    %eax,%eax
    bc0e:	01 d0                	add    %edx,%eax
    bc10:	01 c0                	add    %eax,%eax
    bc12:	8d 50 04             	lea    0x4(%eax),%edx
    bc15:	8b 45 18             	mov    0x18(%ebp),%eax
    bc18:	01 d0                	add    %edx,%eax
    bc1a:	0f b6 00             	movzbl (%eax),%eax
    bc1d:	0f b6 c0             	movzbl %al,%eax
    bc20:	c1 e0 08             	shl    $0x8,%eax
    bc23:	89 c1                	mov    %eax,%ecx
    bc25:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bc28:	89 d0                	mov    %edx,%eax
    bc2a:	01 c0                	add    %eax,%eax
    bc2c:	01 d0                	add    %edx,%eax
    bc2e:	01 c0                	add    %eax,%eax
    bc30:	8d 50 05             	lea    0x5(%eax),%edx
    bc33:	8b 45 18             	mov    0x18(%ebp),%eax
    bc36:	01 d0                	add    %edx,%eax
    bc38:	0f b6 00             	movzbl (%eax),%eax
    bc3b:	0f b6 c0             	movzbl %al,%eax
    bc3e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bc41:	8b 45 20             	mov    0x20(%ebp),%eax
    bc44:	8b 40 1c             	mov    0x1c(%eax),%eax
    bc47:	39 c2                	cmp    %eax,%edx
    bc49:	75 0d                	jne    bc58 <getPixelColorRGBA16+0x26b>
    bc4b:	8b 45 14             	mov    0x14(%ebp),%eax
    bc4e:	66 c7 00 00 00       	movw   $0x0,(%eax)
    bc53:	e9 84 01 00 00       	jmp    bddc <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    bc58:	8b 45 14             	mov    0x14(%ebp),%eax
    bc5b:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bc60:	e9 77 01 00 00       	jmp    bddc <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    bc65:	8b 45 20             	mov    0x20(%ebp),%eax
    bc68:	8b 00                	mov    (%eax),%eax
    bc6a:	83 f8 04             	cmp    $0x4,%eax
    bc6d:	0f 85 86 00 00 00    	jne    bcf9 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    bc73:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc76:	c1 e0 02             	shl    $0x2,%eax
    bc79:	89 c2                	mov    %eax,%edx
    bc7b:	8b 45 18             	mov    0x18(%ebp),%eax
    bc7e:	01 d0                	add    %edx,%eax
    bc80:	0f b6 00             	movzbl (%eax),%eax
    bc83:	0f b6 c0             	movzbl %al,%eax
    bc86:	c1 e0 08             	shl    $0x8,%eax
    bc89:	89 c2                	mov    %eax,%edx
    bc8b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc8e:	c1 e0 02             	shl    $0x2,%eax
    bc91:	8d 48 01             	lea    0x1(%eax),%ecx
    bc94:	8b 45 18             	mov    0x18(%ebp),%eax
    bc97:	01 c8                	add    %ecx,%eax
    bc99:	0f b6 00             	movzbl (%eax),%eax
    bc9c:	0f b6 c0             	movzbl %al,%eax
    bc9f:	01 c2                	add    %eax,%edx
    bca1:	8b 45 10             	mov    0x10(%ebp),%eax
    bca4:	66 89 10             	mov    %dx,(%eax)
    bca7:	8b 45 10             	mov    0x10(%ebp),%eax
    bcaa:	0f b7 10             	movzwl (%eax),%edx
    bcad:	8b 45 0c             	mov    0xc(%ebp),%eax
    bcb0:	66 89 10             	mov    %dx,(%eax)
    bcb3:	8b 45 0c             	mov    0xc(%ebp),%eax
    bcb6:	0f b7 10             	movzwl (%eax),%edx
    bcb9:	8b 45 08             	mov    0x8(%ebp),%eax
    bcbc:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    bcbf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bcc2:	c1 e0 02             	shl    $0x2,%eax
    bcc5:	8d 50 02             	lea    0x2(%eax),%edx
    bcc8:	8b 45 18             	mov    0x18(%ebp),%eax
    bccb:	01 d0                	add    %edx,%eax
    bccd:	0f b6 00             	movzbl (%eax),%eax
    bcd0:	0f b6 c0             	movzbl %al,%eax
    bcd3:	c1 e0 08             	shl    $0x8,%eax
    bcd6:	89 c2                	mov    %eax,%edx
    bcd8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bcdb:	c1 e0 02             	shl    $0x2,%eax
    bcde:	8d 48 03             	lea    0x3(%eax),%ecx
    bce1:	8b 45 18             	mov    0x18(%ebp),%eax
    bce4:	01 c8                	add    %ecx,%eax
    bce6:	0f b6 00             	movzbl (%eax),%eax
    bce9:	0f b6 c0             	movzbl %al,%eax
    bcec:	01 c2                	add    %eax,%edx
    bcee:	8b 45 14             	mov    0x14(%ebp),%eax
    bcf1:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bcf4:	e9 e3 00 00 00       	jmp    bddc <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    bcf9:	8b 45 20             	mov    0x20(%ebp),%eax
    bcfc:	8b 00                	mov    (%eax),%eax
    bcfe:	83 f8 06             	cmp    $0x6,%eax
    bd01:	0f 85 d5 00 00 00    	jne    bddc <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    bd07:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd0a:	c1 e0 03             	shl    $0x3,%eax
    bd0d:	89 c2                	mov    %eax,%edx
    bd0f:	8b 45 18             	mov    0x18(%ebp),%eax
    bd12:	01 d0                	add    %edx,%eax
    bd14:	0f b6 00             	movzbl (%eax),%eax
    bd17:	0f b6 c0             	movzbl %al,%eax
    bd1a:	c1 e0 08             	shl    $0x8,%eax
    bd1d:	89 c2                	mov    %eax,%edx
    bd1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd22:	c1 e0 03             	shl    $0x3,%eax
    bd25:	8d 48 01             	lea    0x1(%eax),%ecx
    bd28:	8b 45 18             	mov    0x18(%ebp),%eax
    bd2b:	01 c8                	add    %ecx,%eax
    bd2d:	0f b6 00             	movzbl (%eax),%eax
    bd30:	0f b6 c0             	movzbl %al,%eax
    bd33:	01 c2                	add    %eax,%edx
    bd35:	8b 45 08             	mov    0x8(%ebp),%eax
    bd38:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    bd3b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd3e:	c1 e0 03             	shl    $0x3,%eax
    bd41:	8d 50 02             	lea    0x2(%eax),%edx
    bd44:	8b 45 18             	mov    0x18(%ebp),%eax
    bd47:	01 d0                	add    %edx,%eax
    bd49:	0f b6 00             	movzbl (%eax),%eax
    bd4c:	0f b6 c0             	movzbl %al,%eax
    bd4f:	c1 e0 08             	shl    $0x8,%eax
    bd52:	89 c2                	mov    %eax,%edx
    bd54:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd57:	c1 e0 03             	shl    $0x3,%eax
    bd5a:	8d 48 03             	lea    0x3(%eax),%ecx
    bd5d:	8b 45 18             	mov    0x18(%ebp),%eax
    bd60:	01 c8                	add    %ecx,%eax
    bd62:	0f b6 00             	movzbl (%eax),%eax
    bd65:	0f b6 c0             	movzbl %al,%eax
    bd68:	01 c2                	add    %eax,%edx
    bd6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    bd6d:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    bd70:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd73:	c1 e0 03             	shl    $0x3,%eax
    bd76:	8d 50 04             	lea    0x4(%eax),%edx
    bd79:	8b 45 18             	mov    0x18(%ebp),%eax
    bd7c:	01 d0                	add    %edx,%eax
    bd7e:	0f b6 00             	movzbl (%eax),%eax
    bd81:	0f b6 c0             	movzbl %al,%eax
    bd84:	c1 e0 08             	shl    $0x8,%eax
    bd87:	89 c2                	mov    %eax,%edx
    bd89:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd8c:	c1 e0 03             	shl    $0x3,%eax
    bd8f:	8d 48 05             	lea    0x5(%eax),%ecx
    bd92:	8b 45 18             	mov    0x18(%ebp),%eax
    bd95:	01 c8                	add    %ecx,%eax
    bd97:	0f b6 00             	movzbl (%eax),%eax
    bd9a:	0f b6 c0             	movzbl %al,%eax
    bd9d:	01 c2                	add    %eax,%edx
    bd9f:	8b 45 10             	mov    0x10(%ebp),%eax
    bda2:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    bda5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bda8:	c1 e0 03             	shl    $0x3,%eax
    bdab:	8d 50 06             	lea    0x6(%eax),%edx
    bdae:	8b 45 18             	mov    0x18(%ebp),%eax
    bdb1:	01 d0                	add    %edx,%eax
    bdb3:	0f b6 00             	movzbl (%eax),%eax
    bdb6:	0f b6 c0             	movzbl %al,%eax
    bdb9:	c1 e0 08             	shl    $0x8,%eax
    bdbc:	89 c2                	mov    %eax,%edx
    bdbe:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bdc1:	c1 e0 03             	shl    $0x3,%eax
    bdc4:	8d 48 07             	lea    0x7(%eax),%ecx
    bdc7:	8b 45 18             	mov    0x18(%ebp),%eax
    bdca:	01 c8                	add    %ecx,%eax
    bdcc:	0f b6 00             	movzbl (%eax),%eax
    bdcf:	0f b6 c0             	movzbl %al,%eax
    bdd2:	01 c2                	add    %eax,%edx
    bdd4:	8b 45 14             	mov    0x14(%ebp),%eax
    bdd7:	66 89 10             	mov    %dx,(%eax)
  }
}
    bdda:	eb 00                	jmp    bddc <getPixelColorRGBA16+0x3ef>
    bddc:	90                   	nop
    bddd:	5d                   	pop    %ebp
    bdde:	c3                   	ret    

0000bddf <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    bddf:	55                   	push   %ebp
    bde0:	89 e5                	mov    %esp,%ebp
    bde2:	56                   	push   %esi
    bde3:	53                   	push   %ebx
    bde4:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    bde7:	8b 55 18             	mov    0x18(%ebp),%edx
    bdea:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bded:	0f af c2             	imul   %edx,%eax
    bdf0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    bdf3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    bdfa:	8b 45 14             	mov    0x14(%ebp),%eax
    bdfd:	8b 00                	mov    (%eax),%eax
    bdff:	83 f8 03             	cmp    $0x3,%eax
    be02:	75 14                	jne    be18 <lodepng_convert+0x39>
    be04:	8b 45 14             	mov    0x14(%ebp),%eax
    be07:	8b 40 08             	mov    0x8(%eax),%eax
    be0a:	85 c0                	test   %eax,%eax
    be0c:	75 0a                	jne    be18 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    be0e:	b8 6b 00 00 00       	mov    $0x6b,%eax
    be13:	e9 19 03 00 00       	jmp    c131 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    be18:	ff 75 14             	pushl  0x14(%ebp)
    be1b:	ff 75 10             	pushl  0x10(%ebp)
    be1e:	e8 b7 d1 ff ff       	call   8fda <lodepng_color_mode_equal>
    be23:	83 c4 08             	add    $0x8,%esp
    be26:	85 c0                	test   %eax,%eax
    be28:	74 2f                	je     be59 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    be2a:	ff 75 14             	pushl  0x14(%ebp)
    be2d:	ff 75 1c             	pushl  0x1c(%ebp)
    be30:	ff 75 18             	pushl  0x18(%ebp)
    be33:	e8 fb d4 ff ff       	call   9333 <lodepng_get_raw_size>
    be38:	83 c4 0c             	add    $0xc,%esp
    be3b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    be3e:	ff 75 dc             	pushl  -0x24(%ebp)
    be41:	ff 75 0c             	pushl  0xc(%ebp)
    be44:	ff 75 08             	pushl  0x8(%ebp)
    be47:	e8 ca 78 ff ff       	call   3716 <lodepng_memcpy>
    be4c:	83 c4 0c             	add    $0xc,%esp
    return 0;
    be4f:	b8 00 00 00 00       	mov    $0x0,%eax
    be54:	e9 d8 02 00 00       	jmp    c131 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    be59:	8b 45 10             	mov    0x10(%ebp),%eax
    be5c:	8b 00                	mov    (%eax),%eax
    be5e:	83 f8 03             	cmp    $0x3,%eax
    be61:	0f 85 16 01 00 00    	jne    bf7d <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    be67:	8b 45 10             	mov    0x10(%ebp),%eax
    be6a:	8b 40 0c             	mov    0xc(%eax),%eax
    be6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    be70:	8b 45 10             	mov    0x10(%ebp),%eax
    be73:	8b 40 08             	mov    0x8(%eax),%eax
    be76:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    be79:	8b 45 10             	mov    0x10(%ebp),%eax
    be7c:	8b 40 04             	mov    0x4(%eax),%eax
    be7f:	ba 01 00 00 00       	mov    $0x1,%edx
    be84:	89 c1                	mov    %eax,%ecx
    be86:	d3 e2                	shl    %cl,%edx
    be88:	89 d0                	mov    %edx,%eax
    be8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    be8d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    be91:	75 5b                	jne    beee <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    be93:	8b 45 14             	mov    0x14(%ebp),%eax
    be96:	8b 40 0c             	mov    0xc(%eax),%eax
    be99:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    be9c:	8b 45 14             	mov    0x14(%ebp),%eax
    be9f:	8b 40 08             	mov    0x8(%eax),%eax
    bea2:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bea5:	8b 45 14             	mov    0x14(%ebp),%eax
    bea8:	8b 00                	mov    (%eax),%eax
    beaa:	83 f8 03             	cmp    $0x3,%eax
    bead:	75 3f                	jne    beee <lodepng_convert+0x10f>
    beaf:	8b 45 14             	mov    0x14(%ebp),%eax
    beb2:	8b 50 04             	mov    0x4(%eax),%edx
    beb5:	8b 45 10             	mov    0x10(%ebp),%eax
    beb8:	8b 40 04             	mov    0x4(%eax),%eax
    bebb:	39 c2                	cmp    %eax,%edx
    bebd:	75 2f                	jne    beee <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bebf:	ff 75 14             	pushl  0x14(%ebp)
    bec2:	ff 75 1c             	pushl  0x1c(%ebp)
    bec5:	ff 75 18             	pushl  0x18(%ebp)
    bec8:	e8 66 d4 ff ff       	call   9333 <lodepng_get_raw_size>
    becd:	83 c4 0c             	add    $0xc,%esp
    bed0:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bed3:	ff 75 d8             	pushl  -0x28(%ebp)
    bed6:	ff 75 0c             	pushl  0xc(%ebp)
    bed9:	ff 75 08             	pushl  0x8(%ebp)
    bedc:	e8 35 78 ff ff       	call   3716 <lodepng_memcpy>
    bee1:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bee4:	b8 00 00 00 00       	mov    $0x0,%eax
    bee9:	e9 43 02 00 00       	jmp    c131 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    beee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bef1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bef4:	7d 06                	jge    befc <lodepng_convert+0x11d>
    bef6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bef9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    befc:	8d 45 90             	lea    -0x70(%ebp),%eax
    beff:	50                   	push   %eax
    bf00:	e8 5f e1 ff ff       	call   a064 <color_tree_init>
    bf05:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bf08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bf0f:	eb 61                	jmp    bf72 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bf11:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf14:	c1 e0 02             	shl    $0x2,%eax
    bf17:	89 c2                	mov    %eax,%edx
    bf19:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf1c:	01 d0                	add    %edx,%eax
    bf1e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bf21:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bf24:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bf27:	83 c0 03             	add    $0x3,%eax
    bf2a:	0f b6 00             	movzbl (%eax),%eax
    bf2d:	0f b6 d8             	movzbl %al,%ebx
    bf30:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bf33:	83 c0 02             	add    $0x2,%eax
    bf36:	0f b6 00             	movzbl (%eax),%eax
    bf39:	0f b6 c8             	movzbl %al,%ecx
    bf3c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bf3f:	83 c0 01             	add    $0x1,%eax
    bf42:	0f b6 00             	movzbl (%eax),%eax
    bf45:	0f b6 d0             	movzbl %al,%edx
    bf48:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bf4b:	0f b6 00             	movzbl (%eax),%eax
    bf4e:	0f b6 c0             	movzbl %al,%eax
    bf51:	83 ec 08             	sub    $0x8,%esp
    bf54:	56                   	push   %esi
    bf55:	53                   	push   %ebx
    bf56:	51                   	push   %ecx
    bf57:	52                   	push   %edx
    bf58:	50                   	push   %eax
    bf59:	8d 45 90             	lea    -0x70(%ebp),%eax
    bf5c:	50                   	push   %eax
    bf5d:	e8 85 e2 ff ff       	call   a1e7 <color_tree_add>
    bf62:	83 c4 20             	add    $0x20,%esp
    bf65:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bf68:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bf6c:	75 0e                	jne    bf7c <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bf6e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bf72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf75:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bf78:	75 97                	jne    bf11 <lodepng_convert+0x132>
    bf7a:	eb 01                	jmp    bf7d <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bf7c:	90                   	nop
    }
  }

  if(!error) {
    bf7d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bf81:	0f 85 8e 01 00 00    	jne    c115 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bf87:	8b 45 14             	mov    0x14(%ebp),%eax
    bf8a:	8b 40 04             	mov    0x4(%eax),%eax
    bf8d:	83 f8 10             	cmp    $0x10,%eax
    bf90:	0f 85 99 00 00 00    	jne    c02f <lodepng_convert+0x250>
    bf96:	8b 45 10             	mov    0x10(%ebp),%eax
    bf99:	8b 40 04             	mov    0x4(%eax),%eax
    bf9c:	83 f8 10             	cmp    $0x10,%eax
    bf9f:	0f 85 8a 00 00 00    	jne    c02f <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bfa5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bfac:	eb 74                	jmp    c022 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bfae:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bfb4:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bfba:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bfc0:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bfc6:	83 ec 04             	sub    $0x4,%esp
    bfc9:	ff 75 14             	pushl  0x14(%ebp)
    bfcc:	ff 75 f4             	pushl  -0xc(%ebp)
    bfcf:	ff 75 0c             	pushl  0xc(%ebp)
    bfd2:	8d 45 88             	lea    -0x78(%ebp),%eax
    bfd5:	50                   	push   %eax
    bfd6:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bfd9:	50                   	push   %eax
    bfda:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bfdd:	50                   	push   %eax
    bfde:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bfe1:	50                   	push   %eax
    bfe2:	e8 06 fa ff ff       	call   b9ed <getPixelColorRGBA16>
    bfe7:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bfea:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bfee:	0f b7 d8             	movzwl %ax,%ebx
    bff1:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bff5:	0f b7 c8             	movzwl %ax,%ecx
    bff8:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bffc:	0f b7 d0             	movzwl %ax,%edx
    bfff:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    c003:	0f b7 c0             	movzwl %ax,%eax
    c006:	83 ec 04             	sub    $0x4,%esp
    c009:	53                   	push   %ebx
    c00a:	51                   	push   %ecx
    c00b:	52                   	push   %edx
    c00c:	50                   	push   %eax
    c00d:	ff 75 10             	pushl  0x10(%ebp)
    c010:	ff 75 f4             	pushl  -0xc(%ebp)
    c013:	ff 75 08             	pushl  0x8(%ebp)
    c016:	e8 d3 e6 ff ff       	call   a6ee <rgba16ToPixel>
    c01b:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    c01e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c022:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c025:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c028:	75 84                	jne    bfae <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    c02a:	e9 e6 00 00 00       	jmp    c115 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    c02f:	8b 45 10             	mov    0x10(%ebp),%eax
    c032:	8b 40 04             	mov    0x4(%eax),%eax
    c035:	83 f8 08             	cmp    $0x8,%eax
    c038:	75 23                	jne    c05d <lodepng_convert+0x27e>
    c03a:	8b 45 10             	mov    0x10(%ebp),%eax
    c03d:	8b 00                	mov    (%eax),%eax
    c03f:	83 f8 06             	cmp    $0x6,%eax
    c042:	75 19                	jne    c05d <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    c044:	ff 75 14             	pushl  0x14(%ebp)
    c047:	ff 75 0c             	pushl  0xc(%ebp)
    c04a:	ff 75 e0             	pushl  -0x20(%ebp)
    c04d:	ff 75 08             	pushl  0x8(%ebp)
    c050:	e8 ae ee ff ff       	call   af03 <getPixelColorsRGBA8>
    c055:	83 c4 10             	add    $0x10,%esp
    c058:	e9 b8 00 00 00       	jmp    c115 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    c05d:	8b 45 10             	mov    0x10(%ebp),%eax
    c060:	8b 40 04             	mov    0x4(%eax),%eax
    c063:	83 f8 08             	cmp    $0x8,%eax
    c066:	75 23                	jne    c08b <lodepng_convert+0x2ac>
    c068:	8b 45 10             	mov    0x10(%ebp),%eax
    c06b:	8b 00                	mov    (%eax),%eax
    c06d:	83 f8 02             	cmp    $0x2,%eax
    c070:	75 19                	jne    c08b <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    c072:	ff 75 14             	pushl  0x14(%ebp)
    c075:	ff 75 0c             	pushl  0xc(%ebp)
    c078:	ff 75 e0             	pushl  -0x20(%ebp)
    c07b:	ff 75 08             	pushl  0x8(%ebp)
    c07e:	e8 50 f5 ff ff       	call   b5d3 <getPixelColorsRGB8>
    c083:	83 c4 10             	add    $0x10,%esp
    c086:	e9 8a 00 00 00       	jmp    c115 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    c08b:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    c08f:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    c093:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    c097:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    c09b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c0a2:	eb 66                	jmp    c10a <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c0a4:	83 ec 04             	sub    $0x4,%esp
    c0a7:	ff 75 14             	pushl  0x14(%ebp)
    c0aa:	ff 75 f4             	pushl  -0xc(%ebp)
    c0ad:	ff 75 0c             	pushl  0xc(%ebp)
    c0b0:	8d 45 84             	lea    -0x7c(%ebp),%eax
    c0b3:	50                   	push   %eax
    c0b4:	8d 45 85             	lea    -0x7b(%ebp),%eax
    c0b7:	50                   	push   %eax
    c0b8:	8d 45 86             	lea    -0x7a(%ebp),%eax
    c0bb:	50                   	push   %eax
    c0bc:	8d 45 87             	lea    -0x79(%ebp),%eax
    c0bf:	50                   	push   %eax
    c0c0:	e8 71 e8 ff ff       	call   a936 <getPixelColorRGBA8>
    c0c5:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    c0c8:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    c0cc:	0f b6 d8             	movzbl %al,%ebx
    c0cf:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    c0d3:	0f b6 c8             	movzbl %al,%ecx
    c0d6:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    c0da:	0f b6 d0             	movzbl %al,%edx
    c0dd:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    c0e1:	0f b6 c0             	movzbl %al,%eax
    c0e4:	53                   	push   %ebx
    c0e5:	51                   	push   %ecx
    c0e6:	52                   	push   %edx
    c0e7:	50                   	push   %eax
    c0e8:	8d 45 90             	lea    -0x70(%ebp),%eax
    c0eb:	50                   	push   %eax
    c0ec:	ff 75 10             	pushl  0x10(%ebp)
    c0ef:	ff 75 f4             	pushl  -0xc(%ebp)
    c0f2:	ff 75 08             	pushl  0x8(%ebp)
    c0f5:	e8 e5 e1 ff ff       	call   a2df <rgba8ToPixel>
    c0fa:	83 c4 20             	add    $0x20,%esp
    c0fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    c100:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c104:	75 0e                	jne    c114 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    c106:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c10a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c10d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c110:	75 92                	jne    c0a4 <lodepng_convert+0x2c5>
    c112:	eb 01                	jmp    c115 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    c114:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c115:	8b 45 10             	mov    0x10(%ebp),%eax
    c118:	8b 00                	mov    (%eax),%eax
    c11a:	83 f8 03             	cmp    $0x3,%eax
    c11d:	75 0f                	jne    c12e <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    c11f:	83 ec 0c             	sub    $0xc,%esp
    c122:	8d 45 90             	lea    -0x70(%ebp),%eax
    c125:	50                   	push   %eax
    c126:	e8 59 df ff ff       	call   a084 <color_tree_cleanup>
    c12b:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    c12e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    c131:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c134:	5b                   	pop    %ebx
    c135:	5e                   	pop    %esi
    c136:	5d                   	pop    %ebp
    c137:	c3                   	ret    

0000c138 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    c138:	55                   	push   %ebp
    c139:	89 e5                	mov    %esp,%ebp
    c13b:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    c13e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    c145:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c14c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    c153:	8b 45 24             	mov    0x24(%ebp),%eax
    c156:	8b 40 04             	mov    0x4(%eax),%eax
    c159:	ba 01 00 00 00       	mov    $0x1,%edx
    c15e:	89 c1                	mov    %eax,%ecx
    c160:	d3 e2                	shl    %cl,%edx
    c162:	89 d0                	mov    %edx,%eax
    c164:	8d 48 ff             	lea    -0x1(%eax),%ecx
    c167:	b8 ff ff 00 00       	mov    $0xffff,%eax
    c16c:	ba 00 00 00 00       	mov    $0x0,%edx
    c171:	f7 f1                	div    %ecx
    c173:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    c176:	8b 45 20             	mov    0x20(%ebp),%eax
    c179:	8b 40 04             	mov    0x4(%eax),%eax
    c17c:	ba 10 00 00 00       	mov    $0x10,%edx
    c181:	29 c2                	sub    %eax,%edx
    c183:	89 d0                	mov    %edx,%eax
    c185:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    c188:	8b 45 24             	mov    0x24(%ebp),%eax
    c18b:	8b 00                	mov    (%eax),%eax
    c18d:	85 c0                	test   %eax,%eax
    c18f:	74 0a                	je     c19b <lodepng_convert_rgb+0x63>
    c191:	8b 45 24             	mov    0x24(%ebp),%eax
    c194:	8b 00                	mov    (%eax),%eax
    c196:	83 f8 04             	cmp    $0x4,%eax
    c199:	75 1b                	jne    c1b6 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    c19b:	8b 45 14             	mov    0x14(%ebp),%eax
    c19e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c1a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c1a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c1a8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    c1ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c1ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
    c1b1:	e9 c2 00 00 00       	jmp    c278 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    c1b6:	8b 45 24             	mov    0x24(%ebp),%eax
    c1b9:	8b 00                	mov    (%eax),%eax
    c1bb:	83 f8 02             	cmp    $0x2,%eax
    c1be:	74 0a                	je     c1ca <lodepng_convert_rgb+0x92>
    c1c0:	8b 45 24             	mov    0x24(%ebp),%eax
    c1c3:	8b 00                	mov    (%eax),%eax
    c1c5:	83 f8 06             	cmp    $0x6,%eax
    c1c8:	75 23                	jne    c1ed <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    c1ca:	8b 45 14             	mov    0x14(%ebp),%eax
    c1cd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c1d1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    c1d4:	8b 45 18             	mov    0x18(%ebp),%eax
    c1d7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c1db:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    c1de:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c1e1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c1e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c1e8:	e9 8b 00 00 00       	jmp    c278 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    c1ed:	8b 45 24             	mov    0x24(%ebp),%eax
    c1f0:	8b 00                	mov    (%eax),%eax
    c1f2:	83 f8 03             	cmp    $0x3,%eax
    c1f5:	75 77                	jne    c26e <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    c1f7:	8b 45 24             	mov    0x24(%ebp),%eax
    c1fa:	8b 40 0c             	mov    0xc(%eax),%eax
    c1fd:	3b 45 14             	cmp    0x14(%ebp),%eax
    c200:	77 0a                	ja     c20c <lodepng_convert_rgb+0xd4>
    c202:	b8 52 00 00 00       	mov    $0x52,%eax
    c207:	e9 cb 01 00 00       	jmp    c3d7 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    c20c:	8b 45 24             	mov    0x24(%ebp),%eax
    c20f:	8b 40 08             	mov    0x8(%eax),%eax
    c212:	8b 55 14             	mov    0x14(%ebp),%edx
    c215:	c1 e2 02             	shl    $0x2,%edx
    c218:	01 d0                	add    %edx,%eax
    c21a:	0f b6 00             	movzbl (%eax),%eax
    c21d:	0f b6 d0             	movzbl %al,%edx
    c220:	89 d0                	mov    %edx,%eax
    c222:	c1 e0 08             	shl    $0x8,%eax
    c225:	01 d0                	add    %edx,%eax
    c227:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    c22a:	8b 45 24             	mov    0x24(%ebp),%eax
    c22d:	8b 40 08             	mov    0x8(%eax),%eax
    c230:	8b 55 14             	mov    0x14(%ebp),%edx
    c233:	c1 e2 02             	shl    $0x2,%edx
    c236:	83 c2 01             	add    $0x1,%edx
    c239:	01 d0                	add    %edx,%eax
    c23b:	0f b6 00             	movzbl (%eax),%eax
    c23e:	0f b6 d0             	movzbl %al,%edx
    c241:	89 d0                	mov    %edx,%eax
    c243:	c1 e0 08             	shl    $0x8,%eax
    c246:	01 d0                	add    %edx,%eax
    c248:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    c24b:	8b 45 24             	mov    0x24(%ebp),%eax
    c24e:	8b 40 08             	mov    0x8(%eax),%eax
    c251:	8b 55 14             	mov    0x14(%ebp),%edx
    c254:	c1 e2 02             	shl    $0x2,%edx
    c257:	83 c2 02             	add    $0x2,%edx
    c25a:	01 d0                	add    %edx,%eax
    c25c:	0f b6 00             	movzbl (%eax),%eax
    c25f:	0f b6 d0             	movzbl %al,%edx
    c262:	89 d0                	mov    %edx,%eax
    c264:	c1 e0 08             	shl    $0x8,%eax
    c267:	01 d0                	add    %edx,%eax
    c269:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c26c:	eb 0a                	jmp    c278 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    c26e:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c273:	e9 5f 01 00 00       	jmp    c3d7 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    c278:	8b 45 20             	mov    0x20(%ebp),%eax
    c27b:	8b 00                	mov    (%eax),%eax
    c27d:	85 c0                	test   %eax,%eax
    c27f:	74 0a                	je     c28b <lodepng_convert_rgb+0x153>
    c281:	8b 45 20             	mov    0x20(%ebp),%eax
    c284:	8b 00                	mov    (%eax),%eax
    c286:	83 f8 04             	cmp    $0x4,%eax
    c289:	75 14                	jne    c29f <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    c28b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c28e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c291:	89 c1                	mov    %eax,%ecx
    c293:	d3 ea                	shr    %cl,%edx
    c295:	8b 45 08             	mov    0x8(%ebp),%eax
    c298:	89 10                	mov    %edx,(%eax)
    c29a:	e9 33 01 00 00       	jmp    c3d2 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    c29f:	8b 45 20             	mov    0x20(%ebp),%eax
    c2a2:	8b 00                	mov    (%eax),%eax
    c2a4:	83 f8 02             	cmp    $0x2,%eax
    c2a7:	74 0a                	je     c2b3 <lodepng_convert_rgb+0x17b>
    c2a9:	8b 45 20             	mov    0x20(%ebp),%eax
    c2ac:	8b 00                	mov    (%eax),%eax
    c2ae:	83 f8 06             	cmp    $0x6,%eax
    c2b1:	75 32                	jne    c2e5 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    c2b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c2b6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c2b9:	89 c1                	mov    %eax,%ecx
    c2bb:	d3 ea                	shr    %cl,%edx
    c2bd:	8b 45 08             	mov    0x8(%ebp),%eax
    c2c0:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    c2c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c2c5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c2c8:	89 c1                	mov    %eax,%ecx
    c2ca:	d3 ea                	shr    %cl,%edx
    c2cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    c2cf:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    c2d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c2d4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c2d7:	89 c1                	mov    %eax,%ecx
    c2d9:	d3 ea                	shr    %cl,%edx
    c2db:	8b 45 10             	mov    0x10(%ebp),%eax
    c2de:	89 10                	mov    %edx,(%eax)
    c2e0:	e9 ed 00 00 00       	jmp    c3d2 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    c2e5:	8b 45 20             	mov    0x20(%ebp),%eax
    c2e8:	8b 00                	mov    (%eax),%eax
    c2ea:	83 f8 03             	cmp    $0x3,%eax
    c2ed:	0f 85 d8 00 00 00    	jne    c3cb <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    c2f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c2f6:	c1 e8 08             	shr    $0x8,%eax
    c2f9:	89 c2                	mov    %eax,%edx
    c2fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c2fe:	0f b6 c0             	movzbl %al,%eax
    c301:	39 c2                	cmp    %eax,%edx
    c303:	75 24                	jne    c329 <lodepng_convert_rgb+0x1f1>
    c305:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c308:	c1 e8 08             	shr    $0x8,%eax
    c30b:	89 c2                	mov    %eax,%edx
    c30d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c310:	0f b6 c0             	movzbl %al,%eax
    c313:	39 c2                	cmp    %eax,%edx
    c315:	75 12                	jne    c329 <lodepng_convert_rgb+0x1f1>
    c317:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c31a:	c1 e8 08             	shr    $0x8,%eax
    c31d:	89 c2                	mov    %eax,%edx
    c31f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c322:	0f b6 c0             	movzbl %al,%eax
    c325:	39 c2                	cmp    %eax,%edx
    c327:	74 0a                	je     c333 <lodepng_convert_rgb+0x1fb>
    c329:	b8 52 00 00 00       	mov    $0x52,%eax
    c32e:	e9 a4 00 00 00       	jmp    c3d7 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c333:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c33a:	eb 79                	jmp    c3b5 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c33c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c33f:	c1 e0 02             	shl    $0x2,%eax
    c342:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c345:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c348:	c1 e8 08             	shr    $0x8,%eax
    c34b:	89 c1                	mov    %eax,%ecx
    c34d:	8b 45 20             	mov    0x20(%ebp),%eax
    c350:	8b 50 08             	mov    0x8(%eax),%edx
    c353:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c356:	01 d0                	add    %edx,%eax
    c358:	0f b6 00             	movzbl (%eax),%eax
    c35b:	0f b6 c0             	movzbl %al,%eax
    c35e:	39 c1                	cmp    %eax,%ecx
    c360:	75 4f                	jne    c3b1 <lodepng_convert_rgb+0x279>
    c362:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c365:	c1 e8 08             	shr    $0x8,%eax
    c368:	89 c1                	mov    %eax,%ecx
    c36a:	8b 45 20             	mov    0x20(%ebp),%eax
    c36d:	8b 40 08             	mov    0x8(%eax),%eax
    c370:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c373:	83 c2 01             	add    $0x1,%edx
    c376:	01 d0                	add    %edx,%eax
    c378:	0f b6 00             	movzbl (%eax),%eax
    c37b:	0f b6 c0             	movzbl %al,%eax
    c37e:	39 c1                	cmp    %eax,%ecx
    c380:	75 2f                	jne    c3b1 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c382:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c385:	c1 e8 08             	shr    $0x8,%eax
    c388:	89 c1                	mov    %eax,%ecx
    c38a:	8b 45 20             	mov    0x20(%ebp),%eax
    c38d:	8b 40 08             	mov    0x8(%eax),%eax
    c390:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c393:	83 c2 02             	add    $0x2,%edx
    c396:	01 d0                	add    %edx,%eax
    c398:	0f b6 00             	movzbl (%eax),%eax
    c39b:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c39e:	39 c1                	cmp    %eax,%ecx
    c3a0:	75 0f                	jne    c3b1 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c3a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c3a5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c3a8:	89 10                	mov    %edx,(%eax)
        return 0;
    c3aa:	b8 00 00 00 00       	mov    $0x0,%eax
    c3af:	eb 26                	jmp    c3d7 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c3b1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c3b5:	8b 45 20             	mov    0x20(%ebp),%eax
    c3b8:	8b 40 0c             	mov    0xc(%eax),%eax
    c3bb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c3be:	0f 87 78 ff ff ff    	ja     c33c <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c3c4:	b8 52 00 00 00       	mov    $0x52,%eax
    c3c9:	eb 0c                	jmp    c3d7 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c3cb:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c3d0:	eb 05                	jmp    c3d7 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c3d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c3d7:	c9                   	leave  
    c3d8:	c3                   	ret    

0000c3d9 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c3d9:	55                   	push   %ebp
    c3da:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c3dc:	8b 45 08             	mov    0x8(%ebp),%eax
    c3df:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c3e5:	8b 45 08             	mov    0x8(%ebp),%eax
    c3e8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c3ef:	8b 45 08             	mov    0x8(%ebp),%eax
    c3f2:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c3f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c3fb:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c3ff:	8b 45 08             	mov    0x8(%ebp),%eax
    c402:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c406:	8b 45 08             	mov    0x8(%ebp),%eax
    c409:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c40d:	8b 45 08             	mov    0x8(%ebp),%eax
    c410:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c414:	8b 45 08             	mov    0x8(%ebp),%eax
    c417:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c41e:	8b 45 08             	mov    0x8(%ebp),%eax
    c421:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c428:	8b 45 08             	mov    0x8(%ebp),%eax
    c42b:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c432:	00 00 00 
  stats->numpixels = 0;
    c435:	8b 45 08             	mov    0x8(%ebp),%eax
    c438:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c43f:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c442:	8b 45 08             	mov    0x8(%ebp),%eax
    c445:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c44c:	00 00 00 
  stats->allow_greyscale = 1;
    c44f:	8b 45 08             	mov    0x8(%ebp),%eax
    c452:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c459:	00 00 00 
}
    c45c:	90                   	nop
    c45d:	5d                   	pop    %ebp
    c45e:	c3                   	ret    

0000c45f <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c45f:	55                   	push   %ebp
    c460:	89 e5                	mov    %esp,%ebp
    c462:	53                   	push   %ebx
    c463:	83 ec 04             	sub    $0x4,%esp
    c466:	8b 45 08             	mov    0x8(%ebp),%eax
    c469:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c46c:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c470:	74 06                	je     c478 <getValueRequiredBits+0x19>
    c472:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c476:	75 07                	jne    c47f <getValueRequiredBits+0x20>
    c478:	b8 01 00 00 00       	mov    $0x1,%eax
    c47d:	eb 6b                	jmp    c4ea <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c47f:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c483:	0f b6 d9             	movzbl %cl,%ebx
    c486:	89 da                	mov    %ebx,%edx
    c488:	89 d0                	mov    %edx,%eax
    c48a:	c1 e0 04             	shl    $0x4,%eax
    c48d:	89 c2                	mov    %eax,%edx
    c48f:	89 d0                	mov    %edx,%eax
    c491:	c1 e0 04             	shl    $0x4,%eax
    c494:	29 d0                	sub    %edx,%eax
    c496:	01 d8                	add    %ebx,%eax
    c498:	66 c1 e8 08          	shr    $0x8,%ax
    c49c:	c0 e8 04             	shr    $0x4,%al
    c49f:	89 c2                	mov    %eax,%edx
    c4a1:	c1 e2 04             	shl    $0x4,%edx
    c4a4:	01 c2                	add    %eax,%edx
    c4a6:	89 c8                	mov    %ecx,%eax
    c4a8:	29 d0                	sub    %edx,%eax
    c4aa:	84 c0                	test   %al,%al
    c4ac:	75 37                	jne    c4e5 <getValueRequiredBits+0x86>
    c4ae:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c4b2:	0f b6 d1             	movzbl %cl,%edx
    c4b5:	89 d0                	mov    %edx,%eax
    c4b7:	01 c0                	add    %eax,%eax
    c4b9:	01 d0                	add    %edx,%eax
    c4bb:	c1 e0 06             	shl    $0x6,%eax
    c4be:	01 d0                	add    %edx,%eax
    c4c0:	66 c1 e8 08          	shr    $0x8,%ax
    c4c4:	c0 e8 06             	shr    $0x6,%al
    c4c7:	ba 55 00 00 00       	mov    $0x55,%edx
    c4cc:	0f af c2             	imul   %edx,%eax
    c4cf:	29 c1                	sub    %eax,%ecx
    c4d1:	89 c8                	mov    %ecx,%eax
    c4d3:	84 c0                	test   %al,%al
    c4d5:	75 07                	jne    c4de <getValueRequiredBits+0x7f>
    c4d7:	b8 02 00 00 00       	mov    $0x2,%eax
    c4dc:	eb 0c                	jmp    c4ea <getValueRequiredBits+0x8b>
    c4de:	b8 04 00 00 00       	mov    $0x4,%eax
    c4e3:	eb 05                	jmp    c4ea <getValueRequiredBits+0x8b>
  return 8;
    c4e5:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c4ea:	83 c4 04             	add    $0x4,%esp
    c4ed:	5b                   	pop    %ebx
    c4ee:	5d                   	pop    %ebp
    c4ef:	c3                   	ret    

0000c4f0 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c4f0:	55                   	push   %ebp
    c4f1:	89 e5                	mov    %esp,%ebp
    c4f3:	56                   	push   %esi
    c4f4:	53                   	push   %ebx
    c4f5:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c4fb:	8b 55 10             	mov    0x10(%ebp),%edx
    c4fe:	8b 45 14             	mov    0x14(%ebp),%eax
    c501:	0f af c2             	imul   %edx,%eax
    c504:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c507:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c50e:	ff 75 18             	pushl  0x18(%ebp)
    c511:	e8 0b cd ff ff       	call   9221 <lodepng_is_greyscale_type>
    c516:	83 c4 04             	add    $0x4,%esp
    c519:	85 c0                	test   %eax,%eax
    c51b:	0f 95 c0             	setne  %al
    c51e:	0f b6 c0             	movzbl %al,%eax
    c521:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c524:	ff 75 18             	pushl  0x18(%ebp)
    c527:	e8 85 cd ff ff       	call   92b1 <lodepng_can_have_alpha>
    c52c:	83 c4 04             	add    $0x4,%esp
    c52f:	85 c0                	test   %eax,%eax
    c531:	0f 94 c0             	sete   %al
    c534:	0f b6 c0             	movzbl %al,%eax
    c537:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c53a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c541:	ff 75 18             	pushl  0x18(%ebp)
    c544:	e8 ab cc ff ff       	call   91f4 <lodepng_get_bpp>
    c549:	83 c4 04             	add    $0x4,%esp
    c54c:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c54f:	8b 45 08             	mov    0x8(%ebp),%eax
    c552:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c558:	83 f8 01             	cmp    $0x1,%eax
    c55b:	75 0d                	jne    c56a <lodepng_compute_color_stats+0x7a>
    c55d:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c561:	75 07                	jne    c56a <lodepng_compute_color_stats+0x7a>
    c563:	b8 01 00 00 00       	mov    $0x1,%eax
    c568:	eb 05                	jmp    c56f <lodepng_compute_color_stats+0x7f>
    c56a:	b8 00 00 00 00       	mov    $0x0,%eax
    c56f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c572:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c579:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c580:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c584:	77 26                	ja     c5ac <lodepng_compute_color_stats+0xbc>
    c586:	8b 45 08             	mov    0x8(%ebp),%eax
    c589:	8b 50 14             	mov    0x14(%eax),%edx
    c58c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c58f:	bb 01 00 00 00       	mov    $0x1,%ebx
    c594:	89 c1                	mov    %eax,%ecx
    c596:	d3 e3                	shl    %cl,%ebx
    c598:	89 d8                	mov    %ebx,%eax
    c59a:	01 d0                	add    %edx,%eax
    c59c:	ba 01 01 00 00       	mov    $0x101,%edx
    c5a1:	3d 01 01 00 00       	cmp    $0x101,%eax
    c5a6:	0f 47 c2             	cmova  %edx,%eax
    c5a9:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c5ac:	8b 45 08             	mov    0x8(%ebp),%eax
    c5af:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c5b5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c5b8:	01 c2                	add    %eax,%edx
    c5ba:	8b 45 08             	mov    0x8(%ebp),%eax
    c5bd:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c5c3:	8b 45 08             	mov    0x8(%ebp),%eax
    c5c6:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c5cc:	85 c0                	test   %eax,%eax
    c5ce:	75 07                	jne    c5d7 <lodepng_compute_color_stats+0xe7>
    c5d0:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c5d7:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c5dd:	50                   	push   %eax
    c5de:	e8 81 da ff ff       	call   a064 <color_tree_init>
    c5e3:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c5e6:	8b 45 08             	mov    0x8(%ebp),%eax
    c5e9:	8b 40 10             	mov    0x10(%eax),%eax
    c5ec:	85 c0                	test   %eax,%eax
    c5ee:	74 07                	je     c5f7 <lodepng_compute_color_stats+0x107>
    c5f0:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c5f7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5fa:	8b 00                	mov    (%eax),%eax
    c5fc:	85 c0                	test   %eax,%eax
    c5fe:	74 07                	je     c607 <lodepng_compute_color_stats+0x117>
    c600:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c607:	8b 45 08             	mov    0x8(%ebp),%eax
    c60a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c610:	83 f8 10             	cmp    $0x10,%eax
    c613:	75 07                	jne    c61c <lodepng_compute_color_stats+0x12c>
    c615:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c61c:	8b 45 08             	mov    0x8(%ebp),%eax
    c61f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c625:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c628:	72 07                	jb     c631 <lodepng_compute_color_stats+0x141>
    c62a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c631:	8b 45 08             	mov    0x8(%ebp),%eax
    c634:	8b 40 14             	mov    0x14(%eax),%eax
    c637:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c63a:	72 07                	jb     c643 <lodepng_compute_color_stats+0x153>
    c63c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c643:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c647:	0f 85 82 00 00 00    	jne    c6cf <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c64d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c654:	eb 6c                	jmp    c6c2 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c656:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c659:	c1 e0 02             	shl    $0x2,%eax
    c65c:	8d 50 10             	lea    0x10(%eax),%edx
    c65f:	8b 45 08             	mov    0x8(%ebp),%eax
    c662:	01 d0                	add    %edx,%eax
    c664:	83 c0 08             	add    $0x8,%eax
    c667:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c66a:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c66d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c670:	83 c0 03             	add    $0x3,%eax
    c673:	0f b6 00             	movzbl (%eax),%eax
    c676:	0f b6 d8             	movzbl %al,%ebx
    c679:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c67c:	83 c0 02             	add    $0x2,%eax
    c67f:	0f b6 00             	movzbl (%eax),%eax
    c682:	0f b6 c8             	movzbl %al,%ecx
    c685:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c688:	83 c0 01             	add    $0x1,%eax
    c68b:	0f b6 00             	movzbl (%eax),%eax
    c68e:	0f b6 d0             	movzbl %al,%edx
    c691:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c694:	0f b6 00             	movzbl (%eax),%eax
    c697:	0f b6 c0             	movzbl %al,%eax
    c69a:	83 ec 08             	sub    $0x8,%esp
    c69d:	56                   	push   %esi
    c69e:	53                   	push   %ebx
    c69f:	51                   	push   %ecx
    c6a0:	52                   	push   %edx
    c6a1:	50                   	push   %eax
    c6a2:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c6a8:	50                   	push   %eax
    c6a9:	e8 39 db ff ff       	call   a1e7 <color_tree_add>
    c6ae:	83 c4 20             	add    $0x20,%esp
    c6b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c6b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c6b8:	0f 85 22 09 00 00    	jne    cfe0 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c6be:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c6c2:	8b 45 08             	mov    0x8(%ebp),%eax
    c6c5:	8b 50 14             	mov    0x14(%eax),%edx
    c6c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6cb:	39 c2                	cmp    %eax,%edx
    c6cd:	77 87                	ja     c656 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c6cf:	8b 45 18             	mov    0x18(%ebp),%eax
    c6d2:	8b 40 04             	mov    0x4(%eax),%eax
    c6d5:	83 f8 10             	cmp    $0x10,%eax
    c6d8:	0f 85 1e 01 00 00    	jne    c7fc <lodepng_compute_color_stats+0x30c>
    c6de:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c6e2:	0f 85 14 01 00 00    	jne    c7fc <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c6e8:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c6ef:	00 00 
    c6f1:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c6f8:	00 00 
    c6fa:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c701:	00 00 
    c703:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c70a:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c70c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c713:	e9 d8 00 00 00       	jmp    c7f0 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c718:	83 ec 04             	sub    $0x4,%esp
    c71b:	ff 75 18             	pushl  0x18(%ebp)
    c71e:	ff 75 f4             	pushl  -0xc(%ebp)
    c721:	ff 75 0c             	pushl  0xc(%ebp)
    c724:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c72a:	50                   	push   %eax
    c72b:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c731:	50                   	push   %eax
    c732:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c738:	50                   	push   %eax
    c739:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c73f:	50                   	push   %eax
    c740:	e8 a8 f2 ff ff       	call   b9ed <getPixelColorRGBA16>
    c745:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c748:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c74f:	66 c1 e8 08          	shr    $0x8,%ax
    c753:	89 c2                	mov    %eax,%edx
    c755:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c75c:	31 d0                	xor    %edx,%eax
    c75e:	0f b7 c0             	movzwl %ax,%eax
    c761:	0f b6 c0             	movzbl %al,%eax
    c764:	85 c0                	test   %eax,%eax
    c766:	75 60                	jne    c7c8 <lodepng_compute_color_stats+0x2d8>
    c768:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c76f:	66 c1 e8 08          	shr    $0x8,%ax
    c773:	89 c2                	mov    %eax,%edx
    c775:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c77c:	31 d0                	xor    %edx,%eax
    c77e:	0f b7 c0             	movzwl %ax,%eax
    c781:	0f b6 c0             	movzbl %al,%eax
    c784:	85 c0                	test   %eax,%eax
    c786:	75 40                	jne    c7c8 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c788:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c78f:	66 c1 e8 08          	shr    $0x8,%ax
    c793:	89 c2                	mov    %eax,%edx
    c795:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c79c:	31 d0                	xor    %edx,%eax
    c79e:	0f b7 c0             	movzwl %ax,%eax
    c7a1:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c7a4:	85 c0                	test   %eax,%eax
    c7a6:	75 20                	jne    c7c8 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c7a8:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c7af:	66 c1 e8 08          	shr    $0x8,%ax
    c7b3:	89 c2                	mov    %eax,%edx
    c7b5:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c7bc:	31 d0                	xor    %edx,%eax
    c7be:	0f b7 c0             	movzwl %ax,%eax
    c7c1:	0f b6 c0             	movzbl %al,%eax
    c7c4:	85 c0                	test   %eax,%eax
    c7c6:	74 24                	je     c7ec <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c7c8:	8b 45 08             	mov    0x8(%ebp),%eax
    c7cb:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c7d2:	00 00 00 
        sixteen = 1;
    c7d5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c7dc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c7e3:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c7ea:	eb 10                	jmp    c7fc <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c7ec:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c7f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c7f3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c7f6:	0f 85 1c ff ff ff    	jne    c718 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c7fc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c800:	0f 84 bd 02 00 00    	je     cac3 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c806:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c80d:	00 00 
    c80f:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c816:	00 00 
    c818:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c81f:	00 00 
    c821:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c828:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c82a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c831:	e9 b1 01 00 00       	jmp    c9e7 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c836:	83 ec 04             	sub    $0x4,%esp
    c839:	ff 75 18             	pushl  0x18(%ebp)
    c83c:	ff 75 f4             	pushl  -0xc(%ebp)
    c83f:	ff 75 0c             	pushl  0xc(%ebp)
    c842:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c848:	50                   	push   %eax
    c849:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c84f:	50                   	push   %eax
    c850:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c856:	50                   	push   %eax
    c857:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c85d:	50                   	push   %eax
    c85e:	e8 8a f1 ff ff       	call   b9ed <getPixelColorRGBA16>
    c863:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c866:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c86a:	75 36                	jne    c8a2 <lodepng_compute_color_stats+0x3b2>
    c86c:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c873:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c87a:	66 39 c2             	cmp    %ax,%dx
    c87d:	75 13                	jne    c892 <lodepng_compute_color_stats+0x3a2>
    c87f:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c886:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c88d:	66 39 c2             	cmp    %ax,%dx
    c890:	74 10                	je     c8a2 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c892:	8b 45 08             	mov    0x8(%ebp),%eax
    c895:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c89b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c8a2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c8a6:	0f 85 1f 01 00 00    	jne    c9cb <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c8ac:	8b 45 08             	mov    0x8(%ebp),%eax
    c8af:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c8b3:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c8ba:	66 39 c2             	cmp    %ax,%dx
    c8bd:	75 2d                	jne    c8ec <lodepng_compute_color_stats+0x3fc>
    c8bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c8c2:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c8c6:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c8cd:	66 39 c2             	cmp    %ax,%dx
    c8d0:	75 1a                	jne    c8ec <lodepng_compute_color_stats+0x3fc>
    c8d2:	8b 45 08             	mov    0x8(%ebp),%eax
    c8d5:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c8d9:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c8e0:	66 39 c2             	cmp    %ax,%dx
    c8e3:	75 07                	jne    c8ec <lodepng_compute_color_stats+0x3fc>
    c8e5:	b8 01 00 00 00       	mov    $0x1,%eax
    c8ea:	eb 05                	jmp    c8f1 <lodepng_compute_color_stats+0x401>
    c8ec:	b8 00 00 00 00       	mov    $0x0,%eax
    c8f1:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c8f4:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c8fb:	66 83 f8 ff          	cmp    $0xffff,%ax
    c8ff:	74 3c                	je     c93d <lodepng_compute_color_stats+0x44d>
    c901:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c908:	66 85 c0             	test   %ax,%ax
    c90b:	75 10                	jne    c91d <lodepng_compute_color_stats+0x42d>
    c90d:	8b 45 08             	mov    0x8(%ebp),%eax
    c910:	8b 40 04             	mov    0x4(%eax),%eax
    c913:	85 c0                	test   %eax,%eax
    c915:	74 26                	je     c93d <lodepng_compute_color_stats+0x44d>
    c917:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c91b:	75 20                	jne    c93d <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c91d:	8b 45 08             	mov    0x8(%ebp),%eax
    c920:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c927:	8b 45 08             	mov    0x8(%ebp),%eax
    c92a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c931:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c938:	e9 8e 00 00 00       	jmp    c9cb <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c93d:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c944:	66 85 c0             	test   %ax,%ax
    c947:	75 4a                	jne    c993 <lodepng_compute_color_stats+0x4a3>
    c949:	8b 45 08             	mov    0x8(%ebp),%eax
    c94c:	8b 40 10             	mov    0x10(%eax),%eax
    c94f:	85 c0                	test   %eax,%eax
    c951:	75 40                	jne    c993 <lodepng_compute_color_stats+0x4a3>
    c953:	8b 45 08             	mov    0x8(%ebp),%eax
    c956:	8b 40 04             	mov    0x4(%eax),%eax
    c959:	85 c0                	test   %eax,%eax
    c95b:	75 36                	jne    c993 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c95d:	8b 45 08             	mov    0x8(%ebp),%eax
    c960:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c967:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c96e:	8b 45 08             	mov    0x8(%ebp),%eax
    c971:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c975:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c97c:	8b 45 08             	mov    0x8(%ebp),%eax
    c97f:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c983:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c98a:	8b 45 08             	mov    0x8(%ebp),%eax
    c98d:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c991:	eb 38                	jmp    c9cb <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c993:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c99a:	66 83 f8 ff          	cmp    $0xffff,%ax
    c99e:	75 2b                	jne    c9cb <lodepng_compute_color_stats+0x4db>
    c9a0:	8b 45 08             	mov    0x8(%ebp),%eax
    c9a3:	8b 40 04             	mov    0x4(%eax),%eax
    c9a6:	85 c0                	test   %eax,%eax
    c9a8:	74 21                	je     c9cb <lodepng_compute_color_stats+0x4db>
    c9aa:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c9ae:	74 1b                	je     c9cb <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c9b0:	8b 45 08             	mov    0x8(%ebp),%eax
    c9b3:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c9ba:	8b 45 08             	mov    0x8(%ebp),%eax
    c9bd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c9c4:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c9cb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c9cf:	74 12                	je     c9e3 <lodepng_compute_color_stats+0x4f3>
    c9d1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c9d5:	74 0c                	je     c9e3 <lodepng_compute_color_stats+0x4f3>
    c9d7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c9db:	74 06                	je     c9e3 <lodepng_compute_color_stats+0x4f3>
    c9dd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c9e1:	75 12                	jne    c9f5 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c9e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c9e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c9ea:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c9ed:	0f 85 43 fe ff ff    	jne    c836 <lodepng_compute_color_stats+0x346>
    c9f3:	eb 01                	jmp    c9f6 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c9f5:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c9f6:	8b 45 08             	mov    0x8(%ebp),%eax
    c9f9:	8b 40 04             	mov    0x4(%eax),%eax
    c9fc:	85 c0                	test   %eax,%eax
    c9fe:	0f 84 e0 05 00 00    	je     cfe4 <lodepng_compute_color_stats+0xaf4>
    ca04:	8b 45 08             	mov    0x8(%ebp),%eax
    ca07:	8b 40 10             	mov    0x10(%eax),%eax
    ca0a:	85 c0                	test   %eax,%eax
    ca0c:	0f 85 d2 05 00 00    	jne    cfe4 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    ca12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ca19:	e9 94 00 00 00       	jmp    cab2 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    ca1e:	83 ec 04             	sub    $0x4,%esp
    ca21:	ff 75 18             	pushl  0x18(%ebp)
    ca24:	ff 75 f4             	pushl  -0xc(%ebp)
    ca27:	ff 75 0c             	pushl  0xc(%ebp)
    ca2a:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    ca30:	50                   	push   %eax
    ca31:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    ca37:	50                   	push   %eax
    ca38:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    ca3e:	50                   	push   %eax
    ca3f:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    ca45:	50                   	push   %eax
    ca46:	e8 a2 ef ff ff       	call   b9ed <getPixelColorRGBA16>
    ca4b:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    ca4e:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    ca55:	66 85 c0             	test   %ax,%ax
    ca58:	74 54                	je     caae <lodepng_compute_color_stats+0x5be>
    ca5a:	8b 45 08             	mov    0x8(%ebp),%eax
    ca5d:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    ca61:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    ca68:	66 39 c2             	cmp    %ax,%dx
    ca6b:	75 41                	jne    caae <lodepng_compute_color_stats+0x5be>
    ca6d:	8b 45 08             	mov    0x8(%ebp),%eax
    ca70:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    ca74:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    ca7b:	66 39 c2             	cmp    %ax,%dx
    ca7e:	75 2e                	jne    caae <lodepng_compute_color_stats+0x5be>
    ca80:	8b 45 08             	mov    0x8(%ebp),%eax
    ca83:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    ca87:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    ca8e:	66 39 c2             	cmp    %ax,%dx
    ca91:	75 1b                	jne    caae <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    ca93:	8b 45 08             	mov    0x8(%ebp),%eax
    ca96:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    ca9d:	8b 45 08             	mov    0x8(%ebp),%eax
    caa0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    caa7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    caae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cab5:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cab8:	0f 85 60 ff ff ff    	jne    ca1e <lodepng_compute_color_stats+0x52e>
    cabe:	e9 21 05 00 00       	jmp    cfe4 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    cac3:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    caca:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    cad1:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    cad8:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    cadf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cae6:	e9 ab 03 00 00       	jmp    ce96 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    caeb:	83 ec 04             	sub    $0x4,%esp
    caee:	ff 75 18             	pushl  0x18(%ebp)
    caf1:	ff 75 f4             	pushl  -0xc(%ebp)
    caf4:	ff 75 0c             	pushl  0xc(%ebp)
    caf7:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cafd:	50                   	push   %eax
    cafe:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cb04:	50                   	push   %eax
    cb05:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cb0b:	50                   	push   %eax
    cb0c:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cb12:	50                   	push   %eax
    cb13:	e8 1e de ff ff       	call   a936 <getPixelColorRGBA8>
    cb18:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    cb1b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cb1f:	75 41                	jne    cb62 <lodepng_compute_color_stats+0x672>
    cb21:	8b 45 08             	mov    0x8(%ebp),%eax
    cb24:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cb2a:	83 f8 07             	cmp    $0x7,%eax
    cb2d:	77 33                	ja     cb62 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    cb2f:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb36:	0f b6 c0             	movzbl %al,%eax
    cb39:	83 ec 0c             	sub    $0xc,%esp
    cb3c:	50                   	push   %eax
    cb3d:	e8 1d f9 ff ff       	call   c45f <getValueRequiredBits>
    cb42:	83 c4 10             	add    $0x10,%esp
    cb45:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    cb48:	8b 45 08             	mov    0x8(%ebp),%eax
    cb4b:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cb51:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    cb54:	73 0c                	jae    cb62 <lodepng_compute_color_stats+0x672>
    cb56:	8b 45 08             	mov    0x8(%ebp),%eax
    cb59:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    cb5c:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    cb62:	8b 45 08             	mov    0x8(%ebp),%eax
    cb65:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cb6b:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    cb6e:	0f 93 c0             	setae  %al
    cb71:	0f b6 c0             	movzbl %al,%eax
    cb74:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    cb77:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cb7b:	75 4f                	jne    cbcc <lodepng_compute_color_stats+0x6dc>
    cb7d:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    cb84:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb8b:	38 c2                	cmp    %al,%dl
    cb8d:	75 12                	jne    cba1 <lodepng_compute_color_stats+0x6b1>
    cb8f:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    cb96:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb9d:	38 c2                	cmp    %al,%dl
    cb9f:	74 2b                	je     cbcc <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    cba1:	8b 45 08             	mov    0x8(%ebp),%eax
    cba4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    cbaa:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    cbb1:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb4:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cbba:	83 f8 07             	cmp    $0x7,%eax
    cbbd:	77 0d                	ja     cbcc <lodepng_compute_color_stats+0x6dc>
    cbbf:	8b 45 08             	mov    0x8(%ebp),%eax
    cbc2:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cbc9:	00 00 00 
      }

      if(!alpha_done) {
    cbcc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cbd0:	0f 85 65 01 00 00    	jne    cd3b <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    cbd6:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cbdd:	0f b6 d0             	movzbl %al,%edx
    cbe0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cbe7:	66 39 c2             	cmp    %ax,%dx
    cbea:	75 33                	jne    cc1f <lodepng_compute_color_stats+0x72f>
    cbec:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cbf3:	0f b6 d0             	movzbl %al,%edx
    cbf6:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf9:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cbfd:	66 39 c2             	cmp    %ax,%dx
    cc00:	75 1d                	jne    cc1f <lodepng_compute_color_stats+0x72f>
    cc02:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cc09:	0f b6 d0             	movzbl %al,%edx
    cc0c:	8b 45 08             	mov    0x8(%ebp),%eax
    cc0f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cc13:	66 39 c2             	cmp    %ax,%dx
    cc16:	75 07                	jne    cc1f <lodepng_compute_color_stats+0x72f>
    cc18:	b8 01 00 00 00       	mov    $0x1,%eax
    cc1d:	eb 05                	jmp    cc24 <lodepng_compute_color_stats+0x734>
    cc1f:	b8 00 00 00 00       	mov    $0x0,%eax
    cc24:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    cc27:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc2e:	3c ff                	cmp    $0xff,%al
    cc30:	74 5a                	je     cc8c <lodepng_compute_color_stats+0x79c>
    cc32:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc39:	84 c0                	test   %al,%al
    cc3b:	75 10                	jne    cc4d <lodepng_compute_color_stats+0x75d>
    cc3d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc40:	8b 40 04             	mov    0x4(%eax),%eax
    cc43:	85 c0                	test   %eax,%eax
    cc45:	74 45                	je     cc8c <lodepng_compute_color_stats+0x79c>
    cc47:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    cc4b:	75 3f                	jne    cc8c <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    cc4d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc50:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cc57:	8b 45 08             	mov    0x8(%ebp),%eax
    cc5a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cc61:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cc68:	8b 45 08             	mov    0x8(%ebp),%eax
    cc6b:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cc71:	83 f8 07             	cmp    $0x7,%eax
    cc74:	0f 87 c1 00 00 00    	ja     cd3b <lodepng_compute_color_stats+0x84b>
    cc7a:	8b 45 08             	mov    0x8(%ebp),%eax
    cc7d:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cc84:	00 00 00 
    cc87:	e9 af 00 00 00       	jmp    cd3b <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    cc8c:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc93:	84 c0                	test   %al,%al
    cc95:	75 53                	jne    ccea <lodepng_compute_color_stats+0x7fa>
    cc97:	8b 45 08             	mov    0x8(%ebp),%eax
    cc9a:	8b 40 10             	mov    0x10(%eax),%eax
    cc9d:	85 c0                	test   %eax,%eax
    cc9f:	75 49                	jne    ccea <lodepng_compute_color_stats+0x7fa>
    cca1:	8b 45 08             	mov    0x8(%ebp),%eax
    cca4:	8b 40 04             	mov    0x4(%eax),%eax
    cca7:	85 c0                	test   %eax,%eax
    cca9:	75 3f                	jne    ccea <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    ccab:	8b 45 08             	mov    0x8(%ebp),%eax
    ccae:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    ccb5:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ccbc:	0f b6 d0             	movzbl %al,%edx
    ccbf:	8b 45 08             	mov    0x8(%ebp),%eax
    ccc2:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    ccc6:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cccd:	0f b6 d0             	movzbl %al,%edx
    ccd0:	8b 45 08             	mov    0x8(%ebp),%eax
    ccd3:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    ccd7:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ccde:	0f b6 d0             	movzbl %al,%edx
    cce1:	8b 45 08             	mov    0x8(%ebp),%eax
    cce4:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cce8:	eb 51                	jmp    cd3b <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    ccea:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ccf1:	3c ff                	cmp    $0xff,%al
    ccf3:	75 46                	jne    cd3b <lodepng_compute_color_stats+0x84b>
    ccf5:	8b 45 08             	mov    0x8(%ebp),%eax
    ccf8:	8b 40 04             	mov    0x4(%eax),%eax
    ccfb:	85 c0                	test   %eax,%eax
    ccfd:	74 3c                	je     cd3b <lodepng_compute_color_stats+0x84b>
    ccff:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    cd03:	74 36                	je     cd3b <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cd05:	8b 45 08             	mov    0x8(%ebp),%eax
    cd08:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cd0f:	8b 45 08             	mov    0x8(%ebp),%eax
    cd12:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cd19:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cd20:	8b 45 08             	mov    0x8(%ebp),%eax
    cd23:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd29:	83 f8 07             	cmp    $0x7,%eax
    cd2c:	77 0d                	ja     cd3b <lodepng_compute_color_stats+0x84b>
    cd2e:	8b 45 08             	mov    0x8(%ebp),%eax
    cd31:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cd38:	00 00 00 
        }
      }

      if(!numcolors_done) {
    cd3b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cd3f:	0f 85 35 01 00 00    	jne    ce7a <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    cd45:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cd4c:	0f b6 d8             	movzbl %al,%ebx
    cd4f:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cd56:	0f b6 c8             	movzbl %al,%ecx
    cd59:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cd60:	0f b6 d0             	movzbl %al,%edx
    cd63:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cd6a:	0f b6 c0             	movzbl %al,%eax
    cd6d:	83 ec 0c             	sub    $0xc,%esp
    cd70:	53                   	push   %ebx
    cd71:	51                   	push   %ecx
    cd72:	52                   	push   %edx
    cd73:	50                   	push   %eax
    cd74:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cd7a:	50                   	push   %eax
    cd7b:	e8 1c d4 ff ff       	call   a19c <color_tree_has>
    cd80:	83 c4 20             	add    $0x20,%esp
    cd83:	85 c0                	test   %eax,%eax
    cd85:	0f 85 ef 00 00 00    	jne    ce7a <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    cd8b:	8b 45 08             	mov    0x8(%ebp),%eax
    cd8e:	8b 70 14             	mov    0x14(%eax),%esi
    cd91:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cd98:	0f b6 d8             	movzbl %al,%ebx
    cd9b:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cda2:	0f b6 c8             	movzbl %al,%ecx
    cda5:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cdac:	0f b6 d0             	movzbl %al,%edx
    cdaf:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cdb6:	0f b6 c0             	movzbl %al,%eax
    cdb9:	83 ec 08             	sub    $0x8,%esp
    cdbc:	56                   	push   %esi
    cdbd:	53                   	push   %ebx
    cdbe:	51                   	push   %ecx
    cdbf:	52                   	push   %edx
    cdc0:	50                   	push   %eax
    cdc1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cdc7:	50                   	push   %eax
    cdc8:	e8 1a d4 ff ff       	call   a1e7 <color_tree_add>
    cdcd:	83 c4 20             	add    $0x20,%esp
    cdd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    cdd3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cdd7:	0f 85 06 02 00 00    	jne    cfe3 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    cddd:	8b 45 08             	mov    0x8(%ebp),%eax
    cde0:	8b 40 14             	mov    0x14(%eax),%eax
    cde3:	3d ff 00 00 00       	cmp    $0xff,%eax
    cde8:	77 6f                	ja     ce59 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    cdea:	8b 45 08             	mov    0x8(%ebp),%eax
    cded:	83 c0 18             	add    $0x18,%eax
    cdf0:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    cdf3:	8b 45 08             	mov    0x8(%ebp),%eax
    cdf6:	8b 40 14             	mov    0x14(%eax),%eax
    cdf9:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    cdfc:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cdff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ce06:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ce09:	01 c2                	add    %eax,%edx
    ce0b:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ce12:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    ce14:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ce17:	c1 e0 02             	shl    $0x2,%eax
    ce1a:	8d 50 01             	lea    0x1(%eax),%edx
    ce1d:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ce20:	01 c2                	add    %eax,%edx
    ce22:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ce29:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    ce2b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ce2e:	c1 e0 02             	shl    $0x2,%eax
    ce31:	8d 50 02             	lea    0x2(%eax),%edx
    ce34:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ce37:	01 c2                	add    %eax,%edx
    ce39:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ce40:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    ce42:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ce45:	c1 e0 02             	shl    $0x2,%eax
    ce48:	8d 50 03             	lea    0x3(%eax),%edx
    ce4b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ce4e:	01 c2                	add    %eax,%edx
    ce50:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ce57:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    ce59:	8b 45 08             	mov    0x8(%ebp),%eax
    ce5c:	8b 40 14             	mov    0x14(%eax),%eax
    ce5f:	8d 50 01             	lea    0x1(%eax),%edx
    ce62:	8b 45 08             	mov    0x8(%ebp),%eax
    ce65:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    ce68:	8b 45 08             	mov    0x8(%ebp),%eax
    ce6b:	8b 40 14             	mov    0x14(%eax),%eax
    ce6e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ce71:	0f 93 c0             	setae  %al
    ce74:	0f b6 c0             	movzbl %al,%eax
    ce77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    ce7a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ce7e:	74 12                	je     ce92 <lodepng_compute_color_stats+0x9a2>
    ce80:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ce84:	74 0c                	je     ce92 <lodepng_compute_color_stats+0x9a2>
    ce86:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ce8a:	74 06                	je     ce92 <lodepng_compute_color_stats+0x9a2>
    ce8c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ce90:	75 12                	jne    cea4 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    ce92:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ce96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ce99:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    ce9c:	0f 85 49 fc ff ff    	jne    caeb <lodepng_compute_color_stats+0x5fb>
    cea2:	eb 01                	jmp    cea5 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cea4:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cea5:	8b 45 08             	mov    0x8(%ebp),%eax
    cea8:	8b 40 04             	mov    0x4(%eax),%eax
    ceab:	85 c0                	test   %eax,%eax
    cead:	0f 84 dd 00 00 00    	je     cf90 <lodepng_compute_color_stats+0xaa0>
    ceb3:	8b 45 08             	mov    0x8(%ebp),%eax
    ceb6:	8b 40 10             	mov    0x10(%eax),%eax
    ceb9:	85 c0                	test   %eax,%eax
    cebb:	0f 85 cf 00 00 00    	jne    cf90 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cec1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cec8:	e9 b7 00 00 00       	jmp    cf84 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cecd:	83 ec 04             	sub    $0x4,%esp
    ced0:	ff 75 18             	pushl  0x18(%ebp)
    ced3:	ff 75 f4             	pushl  -0xc(%ebp)
    ced6:	ff 75 0c             	pushl  0xc(%ebp)
    ced9:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cedf:	50                   	push   %eax
    cee0:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cee6:	50                   	push   %eax
    cee7:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    ceed:	50                   	push   %eax
    ceee:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cef4:	50                   	push   %eax
    cef5:	e8 3c da ff ff       	call   a936 <getPixelColorRGBA8>
    cefa:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cefd:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cf04:	84 c0                	test   %al,%al
    cf06:	74 78                	je     cf80 <lodepng_compute_color_stats+0xa90>
    cf08:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cf0f:	0f b6 d0             	movzbl %al,%edx
    cf12:	8b 45 08             	mov    0x8(%ebp),%eax
    cf15:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cf19:	66 39 c2             	cmp    %ax,%dx
    cf1c:	75 62                	jne    cf80 <lodepng_compute_color_stats+0xa90>
    cf1e:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cf25:	0f b6 d0             	movzbl %al,%edx
    cf28:	8b 45 08             	mov    0x8(%ebp),%eax
    cf2b:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cf2f:	66 39 c2             	cmp    %ax,%dx
    cf32:	75 4c                	jne    cf80 <lodepng_compute_color_stats+0xa90>
    cf34:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cf3b:	0f b6 d0             	movzbl %al,%edx
    cf3e:	8b 45 08             	mov    0x8(%ebp),%eax
    cf41:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cf45:	66 39 c2             	cmp    %ax,%dx
    cf48:	75 36                	jne    cf80 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cf4a:	8b 45 08             	mov    0x8(%ebp),%eax
    cf4d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cf54:	8b 45 08             	mov    0x8(%ebp),%eax
    cf57:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cf5e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cf65:	8b 45 08             	mov    0x8(%ebp),%eax
    cf68:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cf6e:	83 f8 07             	cmp    $0x7,%eax
    cf71:	77 0d                	ja     cf80 <lodepng_compute_color_stats+0xa90>
    cf73:	8b 45 08             	mov    0x8(%ebp),%eax
    cf76:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cf7d:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cf80:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cf84:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cf87:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cf8a:	0f 85 3d ff ff ff    	jne    cecd <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cf90:	8b 45 08             	mov    0x8(%ebp),%eax
    cf93:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cf97:	8b 45 08             	mov    0x8(%ebp),%eax
    cf9a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cf9e:	c1 e0 08             	shl    $0x8,%eax
    cfa1:	01 c2                	add    %eax,%edx
    cfa3:	8b 45 08             	mov    0x8(%ebp),%eax
    cfa6:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cfaa:	8b 45 08             	mov    0x8(%ebp),%eax
    cfad:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cfb1:	8b 45 08             	mov    0x8(%ebp),%eax
    cfb4:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cfb8:	c1 e0 08             	shl    $0x8,%eax
    cfbb:	01 c2                	add    %eax,%edx
    cfbd:	8b 45 08             	mov    0x8(%ebp),%eax
    cfc0:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cfc4:	8b 45 08             	mov    0x8(%ebp),%eax
    cfc7:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cfcb:	8b 45 08             	mov    0x8(%ebp),%eax
    cfce:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cfd2:	c1 e0 08             	shl    $0x8,%eax
    cfd5:	01 c2                	add    %eax,%edx
    cfd7:	8b 45 08             	mov    0x8(%ebp),%eax
    cfda:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cfde:	eb 04                	jmp    cfe4 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    cfe0:	90                   	nop
    cfe1:	eb 01                	jmp    cfe4 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cfe3:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cfe4:	83 ec 0c             	sub    $0xc,%esp
    cfe7:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cfed:	50                   	push   %eax
    cfee:	e8 91 d0 ff ff       	call   a084 <color_tree_cleanup>
    cff3:	83 c4 10             	add    $0x10,%esp
  return error;
    cff6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cff9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cffc:	5b                   	pop    %ebx
    cffd:	5e                   	pop    %esi
    cffe:	5d                   	pop    %ebp
    cfff:	c3                   	ret    

0000d000 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    d000:	55                   	push   %ebp
    d001:	89 e5                	mov    %esp,%ebp
    d003:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    d006:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    d00d:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d010:	50                   	push   %eax
    d011:	e8 d1 bd ff ff       	call   8de7 <lodepng_color_mode_init>
    d016:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    d019:	8b 45 0c             	mov    0xc(%ebp),%eax
    d01c:	c1 e8 08             	shr    $0x8,%eax
    d01f:	88 45 ec             	mov    %al,-0x14(%ebp)
    d022:	8b 45 0c             	mov    0xc(%ebp),%eax
    d025:	88 45 ed             	mov    %al,-0x13(%ebp)
    d028:	8b 45 10             	mov    0x10(%ebp),%eax
    d02b:	c1 e8 08             	shr    $0x8,%eax
    d02e:	88 45 ee             	mov    %al,-0x12(%ebp)
    d031:	8b 45 10             	mov    0x10(%ebp),%eax
    d034:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    d037:	8b 45 14             	mov    0x14(%ebp),%eax
    d03a:	c1 e8 08             	shr    $0x8,%eax
    d03d:	88 45 f0             	mov    %al,-0x10(%ebp)
    d040:	8b 45 14             	mov    0x14(%ebp),%eax
    d043:	88 45 f1             	mov    %al,-0xf(%ebp)
    d046:	8b 45 18             	mov    0x18(%ebp),%eax
    d049:	c1 e8 08             	shr    $0x8,%eax
    d04c:	88 45 f2             	mov    %al,-0xe(%ebp)
    d04f:	8b 45 18             	mov    0x18(%ebp),%eax
    d052:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    d055:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    d05c:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    d063:	83 ec 0c             	sub    $0xc,%esp
    d066:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d069:	50                   	push   %eax
    d06a:	6a 01                	push   $0x1
    d06c:	6a 01                	push   $0x1
    d06e:	8d 45 ec             	lea    -0x14(%ebp),%eax
    d071:	50                   	push   %eax
    d072:	ff 75 08             	pushl  0x8(%ebp)
    d075:	e8 76 f4 ff ff       	call   c4f0 <lodepng_compute_color_stats>
    d07a:	83 c4 20             	add    $0x20,%esp
    d07d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    d080:	83 ec 0c             	sub    $0xc,%esp
    d083:	8d 45 cc             	lea    -0x34(%ebp),%eax
    d086:	50                   	push   %eax
    d087:	e8 4e be ff ff       	call   8eda <lodepng_color_mode_cleanup>
    d08c:	83 c4 10             	add    $0x10,%esp
  return error;
    d08f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d092:	c9                   	leave  
    d093:	c3                   	ret    

0000d094 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    d094:	55                   	push   %ebp
    d095:	89 e5                	mov    %esp,%ebp
    d097:	56                   	push   %esi
    d098:	53                   	push   %ebx
    d099:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    d09c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    d0a3:	8b 45 10             	mov    0x10(%ebp),%eax
    d0a6:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    d0ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    d0af:	8b 45 10             	mov    0x10(%ebp),%eax
    d0b2:	8b 40 10             	mov    0x10(%eax),%eax
    d0b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    d0b8:	8b 45 10             	mov    0x10(%ebp),%eax
    d0bb:	8b 40 04             	mov    0x4(%eax),%eax
    d0be:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    d0c1:	8b 45 10             	mov    0x10(%ebp),%eax
    d0c4:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    d0ca:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    d0cd:	8b 45 08             	mov    0x8(%ebp),%eax
    d0d0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    d0d7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d0db:	74 21                	je     d0fe <auto_choose_color+0x6a>
    d0dd:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    d0e1:	7f 1b                	jg     d0fe <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    d0e3:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    d0ea:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d0f1:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d0f5:	77 07                	ja     d0fe <auto_choose_color+0x6a>
    d0f7:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    d0fe:	8b 45 10             	mov    0x10(%ebp),%eax
    d101:	8b 00                	mov    (%eax),%eax
    d103:	85 c0                	test   %eax,%eax
    d105:	0f 94 c0             	sete   %al
    d108:	0f b6 c0             	movzbl %al,%eax
    d10b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    d10e:	8b 45 10             	mov    0x10(%ebp),%eax
    d111:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    d117:	85 c0                	test   %eax,%eax
    d119:	75 07                	jne    d122 <auto_choose_color+0x8e>
    d11b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    d122:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d126:	75 0d                	jne    d135 <auto_choose_color+0xa1>
    d128:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d12c:	77 07                	ja     d135 <auto_choose_color+0xa1>
    d12e:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    d135:	8b 45 10             	mov    0x10(%ebp),%eax
    d138:	8b 40 14             	mov    0x14(%eax),%eax
    d13b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    d13e:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    d142:	7e 21                	jle    d165 <auto_choose_color+0xd1>
    d144:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    d148:	7e 14                	jle    d15e <auto_choose_color+0xca>
    d14a:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    d14e:	7f 07                	jg     d157 <auto_choose_color+0xc3>
    d150:	b8 04 00 00 00       	mov    $0x4,%eax
    d155:	eb 13                	jmp    d16a <auto_choose_color+0xd6>
    d157:	b8 08 00 00 00       	mov    $0x8,%eax
    d15c:	eb 0c                	jmp    d16a <auto_choose_color+0xd6>
    d15e:	b8 02 00 00 00       	mov    $0x2,%eax
    d163:	eb 05                	jmp    d16a <auto_choose_color+0xd6>
    d165:	b8 01 00 00 00       	mov    $0x1,%eax
    d16a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    d16d:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    d174:	7f 13                	jg     d189 <auto_choose_color+0xf5>
    d176:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    d17a:	77 0d                	ja     d189 <auto_choose_color+0xf5>
    d17c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    d180:	74 07                	je     d189 <auto_choose_color+0xf5>
    d182:	b8 01 00 00 00       	mov    $0x1,%eax
    d187:	eb 05                	jmp    d18e <auto_choose_color+0xfa>
    d189:	b8 00 00 00 00       	mov    $0x0,%eax
    d18e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    d191:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d194:	01 c0                	add    %eax,%eax
    d196:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d199:	7e 07                	jle    d1a2 <auto_choose_color+0x10e>
    d19b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    d1a2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d1a6:	74 15                	je     d1bd <auto_choose_color+0x129>
    d1a8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d1ac:	75 0f                	jne    d1bd <auto_choose_color+0x129>
    d1ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d1b1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d1b4:	77 07                	ja     d1bd <auto_choose_color+0x129>
    d1b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    d1bd:	8b 45 10             	mov    0x10(%ebp),%eax
    d1c0:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    d1c6:	85 c0                	test   %eax,%eax
    d1c8:	75 07                	jne    d1d1 <auto_choose_color+0x13d>
    d1ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    d1d1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d1d5:	0f 84 0a 01 00 00    	je     d2e5 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    d1db:	8b 45 10             	mov    0x10(%ebp),%eax
    d1de:	83 c0 18             	add    $0x18,%eax
    d1e1:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    d1e4:	83 ec 0c             	sub    $0xc,%esp
    d1e7:	ff 75 08             	pushl  0x8(%ebp)
    d1ea:	e8 ef be ff ff       	call   90de <lodepng_palette_clear>
    d1ef:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    d1f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d1f9:	eb 6e                	jmp    d269 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    d1fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d1fe:	c1 e0 02             	shl    $0x2,%eax
    d201:	8d 50 03             	lea    0x3(%eax),%edx
    d204:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d207:	01 d0                	add    %edx,%eax
    d209:	0f b6 00             	movzbl (%eax),%eax
    d20c:	0f b6 d8             	movzbl %al,%ebx
    d20f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d212:	c1 e0 02             	shl    $0x2,%eax
    d215:	8d 50 02             	lea    0x2(%eax),%edx
    d218:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d21b:	01 d0                	add    %edx,%eax
    d21d:	0f b6 00             	movzbl (%eax),%eax
    d220:	0f b6 c8             	movzbl %al,%ecx
    d223:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d226:	c1 e0 02             	shl    $0x2,%eax
    d229:	8d 50 01             	lea    0x1(%eax),%edx
    d22c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d22f:	01 d0                	add    %edx,%eax
    d231:	0f b6 00             	movzbl (%eax),%eax
    d234:	0f b6 d0             	movzbl %al,%edx
    d237:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d23a:	c1 e0 02             	shl    $0x2,%eax
    d23d:	89 c6                	mov    %eax,%esi
    d23f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d242:	01 f0                	add    %esi,%eax
    d244:	0f b6 00             	movzbl (%eax),%eax
    d247:	0f b6 c0             	movzbl %al,%eax
    d24a:	83 ec 0c             	sub    $0xc,%esp
    d24d:	53                   	push   %ebx
    d24e:	51                   	push   %ecx
    d24f:	52                   	push   %edx
    d250:	50                   	push   %eax
    d251:	ff 75 08             	pushl  0x8(%ebp)
    d254:	e8 be be ff ff       	call   9117 <lodepng_palette_add>
    d259:	83 c4 20             	add    $0x20,%esp
    d25c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    d25f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d263:	75 13                	jne    d278 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    d265:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    d269:	8b 45 10             	mov    0x10(%ebp),%eax
    d26c:	8b 50 14             	mov    0x14(%eax),%edx
    d26f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d272:	39 c2                	cmp    %eax,%edx
    d274:	75 85                	jne    d1fb <auto_choose_color+0x167>
    d276:	eb 01                	jmp    d279 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    d278:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    d279:	8b 45 08             	mov    0x8(%ebp),%eax
    d27c:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    d282:	8b 45 08             	mov    0x8(%ebp),%eax
    d285:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d288:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    d28b:	8b 45 0c             	mov    0xc(%ebp),%eax
    d28e:	8b 00                	mov    (%eax),%eax
    d290:	83 f8 03             	cmp    $0x3,%eax
    d293:	0f 85 ec 00 00 00    	jne    d385 <auto_choose_color+0x2f1>
    d299:	8b 45 0c             	mov    0xc(%ebp),%eax
    d29c:	8b 50 0c             	mov    0xc(%eax),%edx
    d29f:	8b 45 08             	mov    0x8(%ebp),%eax
    d2a2:	8b 40 0c             	mov    0xc(%eax),%eax
    d2a5:	39 c2                	cmp    %eax,%edx
    d2a7:	0f 8c d8 00 00 00    	jl     d385 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    d2ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2b0:	8b 50 04             	mov    0x4(%eax),%edx
    d2b3:	8b 45 08             	mov    0x8(%ebp),%eax
    d2b6:	8b 40 04             	mov    0x4(%eax),%eax
    d2b9:	39 c2                	cmp    %eax,%edx
    d2bb:	0f 85 c4 00 00 00    	jne    d385 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    d2c1:	83 ec 0c             	sub    $0xc,%esp
    d2c4:	ff 75 08             	pushl  0x8(%ebp)
    d2c7:	e8 0e bc ff ff       	call   8eda <lodepng_color_mode_cleanup>
    d2cc:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    d2cf:	83 ec 08             	sub    $0x8,%esp
    d2d2:	ff 75 0c             	pushl  0xc(%ebp)
    d2d5:	ff 75 08             	pushl  0x8(%ebp)
    d2d8:	e8 14 bc ff ff       	call   8ef1 <lodepng_color_mode_copy>
    d2dd:	83 c4 10             	add    $0x10,%esp
    d2e0:	e9 a0 00 00 00       	jmp    d385 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    d2e5:	8b 45 08             	mov    0x8(%ebp),%eax
    d2e8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d2eb:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    d2ee:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d2f2:	74 14                	je     d308 <auto_choose_color+0x274>
    d2f4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d2f8:	74 07                	je     d301 <auto_choose_color+0x26d>
    d2fa:	b8 04 00 00 00       	mov    $0x4,%eax
    d2ff:	eb 19                	jmp    d31a <auto_choose_color+0x286>
    d301:	b8 06 00 00 00       	mov    $0x6,%eax
    d306:	eb 12                	jmp    d31a <auto_choose_color+0x286>
    d308:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d30c:	74 07                	je     d315 <auto_choose_color+0x281>
    d30e:	b8 00 00 00 00       	mov    $0x0,%eax
    d313:	eb 05                	jmp    d31a <auto_choose_color+0x286>
    d315:	b8 02 00 00 00       	mov    $0x2,%eax
    d31a:	8b 55 08             	mov    0x8(%ebp),%edx
    d31d:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    d31f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d323:	74 60                	je     d385 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    d325:	8b 45 08             	mov    0x8(%ebp),%eax
    d328:	8b 40 04             	mov    0x4(%eax),%eax
    d32b:	ba 01 00 00 00       	mov    $0x1,%edx
    d330:	89 c1                	mov    %eax,%ecx
    d332:	d3 e2                	shl    %cl,%edx
    d334:	89 d0                	mov    %edx,%eax
    d336:	83 e8 01             	sub    $0x1,%eax
    d339:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d33c:	8b 45 10             	mov    0x10(%ebp),%eax
    d33f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d343:	0f b7 c0             	movzwl %ax,%eax
    d346:	23 45 c8             	and    -0x38(%ebp),%eax
    d349:	89 c2                	mov    %eax,%edx
    d34b:	8b 45 08             	mov    0x8(%ebp),%eax
    d34e:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d351:	8b 45 10             	mov    0x10(%ebp),%eax
    d354:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d358:	0f b7 c0             	movzwl %ax,%eax
    d35b:	23 45 c8             	and    -0x38(%ebp),%eax
    d35e:	89 c2                	mov    %eax,%edx
    d360:	8b 45 08             	mov    0x8(%ebp),%eax
    d363:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d366:	8b 45 10             	mov    0x10(%ebp),%eax
    d369:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d36d:	0f b7 c0             	movzwl %ax,%eax
    d370:	23 45 c8             	and    -0x38(%ebp),%eax
    d373:	89 c2                	mov    %eax,%edx
    d375:	8b 45 08             	mov    0x8(%ebp),%eax
    d378:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d37b:	8b 45 08             	mov    0x8(%ebp),%eax
    d37e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d385:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d388:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d38b:	5b                   	pop    %ebx
    d38c:	5e                   	pop    %esi
    d38d:	5d                   	pop    %ebp
    d38e:	c3                   	ret    

0000d38f <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d38f:	55                   	push   %ebp
    d390:	89 e5                	mov    %esp,%ebp
    d392:	83 ec 1c             	sub    $0x1c,%esp
    d395:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d398:	8b 55 0c             	mov    0xc(%ebp),%edx
    d39b:	8b 45 10             	mov    0x10(%ebp),%eax
    d39e:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d3a2:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d3a6:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d3aa:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d3ae:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d3b2:	29 c2                	sub    %eax,%edx
    d3b4:	89 d0                	mov    %edx,%eax
    d3b6:	99                   	cltd   
    d3b7:	31 d0                	xor    %edx,%eax
    d3b9:	29 d0                	sub    %edx,%eax
    d3bb:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d3bf:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d3c3:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d3c7:	29 c2                	sub    %eax,%edx
    d3c9:	89 d0                	mov    %edx,%eax
    d3cb:	99                   	cltd   
    d3cc:	31 d0                	xor    %edx,%eax
    d3ce:	29 d0                	sub    %edx,%eax
    d3d0:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d3d4:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d3d8:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d3dc:	01 c2                	add    %eax,%edx
    d3de:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d3e2:	29 c2                	sub    %eax,%edx
    d3e4:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d3e8:	29 c2                	sub    %eax,%edx
    d3ea:	89 d0                	mov    %edx,%eax
    d3ec:	99                   	cltd   
    d3ed:	31 d0                	xor    %edx,%eax
    d3ef:	29 d0                	sub    %edx,%eax
    d3f1:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d3f5:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d3f9:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d3fd:	7d 10                	jge    d40f <paethPredictor+0x80>
    d3ff:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d403:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d407:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d40b:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d40f:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d413:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d417:	7d 06                	jge    d41f <paethPredictor+0x90>
    d419:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d41d:	eb 04                	jmp    d423 <paethPredictor+0x94>
    d41f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d423:	c9                   	leave  
    d424:	c3                   	ret    

0000d425 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d425:	55                   	push   %ebp
    d426:	89 e5                	mov    %esp,%ebp
    d428:	56                   	push   %esi
    d429:	53                   	push   %ebx
    d42a:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d42d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d434:	e9 e2 00 00 00       	jmp    d51b <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d439:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d43c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d443:	8b 45 08             	mov    0x8(%ebp),%eax
    d446:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d449:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d44c:	8b 14 85 54 a4 01 00 	mov    0x1a454(,%eax,4),%edx
    d453:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d456:	01 c2                	add    %eax,%edx
    d458:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d45b:	8b 04 85 1c a4 01 00 	mov    0x1a41c(,%eax,4),%eax
    d462:	29 c2                	sub    %eax,%edx
    d464:	89 d0                	mov    %edx,%eax
    d466:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d469:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d46c:	8b 34 85 54 a4 01 00 	mov    0x1a454(,%eax,4),%esi
    d473:	89 d8                	mov    %ebx,%eax
    d475:	ba 00 00 00 00       	mov    $0x0,%edx
    d47a:	f7 f6                	div    %esi
    d47c:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d47e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d481:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d488:	8b 45 0c             	mov    0xc(%ebp),%eax
    d48b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d48e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d491:	8b 14 85 70 a4 01 00 	mov    0x1a470(,%eax,4),%edx
    d498:	8b 45 20             	mov    0x20(%ebp),%eax
    d49b:	01 c2                	add    %eax,%edx
    d49d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4a0:	8b 04 85 38 a4 01 00 	mov    0x1a438(,%eax,4),%eax
    d4a7:	29 c2                	sub    %eax,%edx
    d4a9:	89 d0                	mov    %edx,%eax
    d4ab:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d4ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4b1:	8b 34 85 70 a4 01 00 	mov    0x1a470(,%eax,4),%esi
    d4b8:	89 d8                	mov    %ebx,%eax
    d4ba:	ba 00 00 00 00       	mov    $0x0,%edx
    d4bf:	f7 f6                	div    %esi
    d4c1:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d4c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4c6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d4cd:	8b 45 08             	mov    0x8(%ebp),%eax
    d4d0:	01 d0                	add    %edx,%eax
    d4d2:	8b 00                	mov    (%eax),%eax
    d4d4:	85 c0                	test   %eax,%eax
    d4d6:	75 15                	jne    d4ed <Adam7_getpassvalues+0xc8>
    d4d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d4e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    d4e5:	01 d0                	add    %edx,%eax
    d4e7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d4ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d4f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d4fa:	01 d0                	add    %edx,%eax
    d4fc:	8b 00                	mov    (%eax),%eax
    d4fe:	85 c0                	test   %eax,%eax
    d500:	75 15                	jne    d517 <Adam7_getpassvalues+0xf2>
    d502:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d505:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d50c:	8b 45 08             	mov    0x8(%ebp),%eax
    d50f:	01 d0                	add    %edx,%eax
    d511:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d517:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d51b:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d51f:	0f 85 14 ff ff ff    	jne    d439 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d525:	8b 45 18             	mov    0x18(%ebp),%eax
    d528:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d52e:	8b 45 18             	mov    0x18(%ebp),%eax
    d531:	8b 10                	mov    (%eax),%edx
    d533:	8b 45 14             	mov    0x14(%ebp),%eax
    d536:	89 10                	mov    %edx,(%eax)
    d538:	8b 45 14             	mov    0x14(%ebp),%eax
    d53b:	8b 10                	mov    (%eax),%edx
    d53d:	8b 45 10             	mov    0x10(%ebp),%eax
    d540:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d542:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d549:	e9 40 01 00 00       	jmp    d68e <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d54e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d551:	83 c0 01             	add    $0x1,%eax
    d554:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d55b:	8b 45 10             	mov    0x10(%ebp),%eax
    d55e:	01 c2                	add    %eax,%edx
    d560:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d563:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d56a:	8b 45 10             	mov    0x10(%ebp),%eax
    d56d:	01 c8                	add    %ecx,%eax
    d56f:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d571:	89 c6                	mov    %eax,%esi
    d573:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d576:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d57d:	8b 45 08             	mov    0x8(%ebp),%eax
    d580:	01 c8                	add    %ecx,%eax
    d582:	8b 00                	mov    (%eax),%eax
    d584:	85 c0                	test   %eax,%eax
    d586:	74 49                	je     d5d1 <Adam7_getpassvalues+0x1ac>
    d588:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d58b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d592:	8b 45 0c             	mov    0xc(%ebp),%eax
    d595:	01 c8                	add    %ecx,%eax
    d597:	8b 00                	mov    (%eax),%eax
    d599:	85 c0                	test   %eax,%eax
    d59b:	74 34                	je     d5d1 <Adam7_getpassvalues+0x1ac>
    d59d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5a0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d5a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d5aa:	01 c8                	add    %ecx,%eax
    d5ac:	8b 08                	mov    (%eax),%ecx
    d5ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5b1:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d5b8:	8b 45 08             	mov    0x8(%ebp),%eax
    d5bb:	01 d8                	add    %ebx,%eax
    d5bd:	8b 00                	mov    (%eax),%eax
    d5bf:	0f af 45 24          	imul   0x24(%ebp),%eax
    d5c3:	83 c0 07             	add    $0x7,%eax
    d5c6:	c1 e8 03             	shr    $0x3,%eax
    d5c9:	83 c0 01             	add    $0x1,%eax
    d5cc:	0f af c1             	imul   %ecx,%eax
    d5cf:	eb 05                	jmp    d5d6 <Adam7_getpassvalues+0x1b1>
    d5d1:	b8 00 00 00 00       	mov    $0x0,%eax
    d5d6:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d5d8:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d5da:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5dd:	83 c0 01             	add    $0x1,%eax
    d5e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d5e7:	8b 45 14             	mov    0x14(%ebp),%eax
    d5ea:	01 c2                	add    %eax,%edx
    d5ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5ef:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d5f6:	8b 45 14             	mov    0x14(%ebp),%eax
    d5f9:	01 c8                	add    %ecx,%eax
    d5fb:	8b 00                	mov    (%eax),%eax
    d5fd:	89 c6                	mov    %eax,%esi
    d5ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d602:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d609:	8b 45 0c             	mov    0xc(%ebp),%eax
    d60c:	01 c8                	add    %ecx,%eax
    d60e:	8b 08                	mov    (%eax),%ecx
    d610:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d613:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d61a:	8b 45 08             	mov    0x8(%ebp),%eax
    d61d:	01 d8                	add    %ebx,%eax
    d61f:	8b 00                	mov    (%eax),%eax
    d621:	0f af 45 24          	imul   0x24(%ebp),%eax
    d625:	83 c0 07             	add    $0x7,%eax
    d628:	c1 e8 03             	shr    $0x3,%eax
    d62b:	0f af c1             	imul   %ecx,%eax
    d62e:	01 f0                	add    %esi,%eax
    d630:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d632:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d635:	83 c0 01             	add    $0x1,%eax
    d638:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d63f:	8b 45 18             	mov    0x18(%ebp),%eax
    d642:	01 c2                	add    %eax,%edx
    d644:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d647:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d64e:	8b 45 18             	mov    0x18(%ebp),%eax
    d651:	01 c8                	add    %ecx,%eax
    d653:	8b 00                	mov    (%eax),%eax
    d655:	89 c6                	mov    %eax,%esi
    d657:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d65a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d661:	8b 45 0c             	mov    0xc(%ebp),%eax
    d664:	01 c8                	add    %ecx,%eax
    d666:	8b 08                	mov    (%eax),%ecx
    d668:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d66b:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d672:	8b 45 08             	mov    0x8(%ebp),%eax
    d675:	01 d8                	add    %ebx,%eax
    d677:	8b 00                	mov    (%eax),%eax
    d679:	0f af c1             	imul   %ecx,%eax
    d67c:	0f af 45 24          	imul   0x24(%ebp),%eax
    d680:	83 c0 07             	add    $0x7,%eax
    d683:	c1 e8 03             	shr    $0x3,%eax
    d686:	01 f0                	add    %esi,%eax
    d688:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d68a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d68e:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d692:	0f 85 b6 fe ff ff    	jne    d54e <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d698:	90                   	nop
    d699:	83 c4 10             	add    $0x10,%esp
    d69c:	5b                   	pop    %ebx
    d69d:	5e                   	pop    %esi
    d69e:	5d                   	pop    %ebp
    d69f:	c3                   	ret    

0000d6a0 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d6a0:	55                   	push   %ebp
    d6a1:	89 e5                	mov    %esp,%ebp
    d6a3:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d6a6:	8b 45 10             	mov    0x10(%ebp),%eax
    d6a9:	05 98 00 00 00       	add    $0x98,%eax
    d6ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d6b1:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d6b5:	74 06                	je     d6bd <lodepng_inspect+0x1d>
    d6b7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d6bb:	75 17                	jne    d6d4 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d6bd:	8b 45 10             	mov    0x10(%ebp),%eax
    d6c0:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d6c7:	00 00 00 
    d6ca:	b8 30 00 00 00       	mov    $0x30,%eax
    d6cf:	e9 ce 02 00 00       	jmp    d9a2 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d6d4:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d6d8:	7f 17                	jg     d6f1 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d6da:	8b 45 10             	mov    0x10(%ebp),%eax
    d6dd:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d6e4:	00 00 00 
    d6e7:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d6ec:	e9 b1 02 00 00       	jmp    d9a2 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d6f1:	83 ec 0c             	sub    $0xc,%esp
    d6f4:	ff 75 f4             	pushl  -0xc(%ebp)
    d6f7:	e8 63 c7 ff ff       	call   9e5f <lodepng_info_cleanup>
    d6fc:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d6ff:	83 ec 0c             	sub    $0xc,%esp
    d702:	ff 75 f4             	pushl  -0xc(%ebp)
    d705:	e8 74 c6 ff ff       	call   9d7e <lodepng_info_init>
    d70a:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d70d:	8b 45 14             	mov    0x14(%ebp),%eax
    d710:	0f b6 00             	movzbl (%eax),%eax
    d713:	3c 89                	cmp    $0x89,%al
    d715:	75 5b                	jne    d772 <lodepng_inspect+0xd2>
    d717:	8b 45 14             	mov    0x14(%ebp),%eax
    d71a:	83 c0 01             	add    $0x1,%eax
    d71d:	0f b6 00             	movzbl (%eax),%eax
    d720:	3c 50                	cmp    $0x50,%al
    d722:	75 4e                	jne    d772 <lodepng_inspect+0xd2>
    d724:	8b 45 14             	mov    0x14(%ebp),%eax
    d727:	83 c0 02             	add    $0x2,%eax
    d72a:	0f b6 00             	movzbl (%eax),%eax
    d72d:	3c 4e                	cmp    $0x4e,%al
    d72f:	75 41                	jne    d772 <lodepng_inspect+0xd2>
    d731:	8b 45 14             	mov    0x14(%ebp),%eax
    d734:	83 c0 03             	add    $0x3,%eax
    d737:	0f b6 00             	movzbl (%eax),%eax
    d73a:	3c 47                	cmp    $0x47,%al
    d73c:	75 34                	jne    d772 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d73e:	8b 45 14             	mov    0x14(%ebp),%eax
    d741:	83 c0 04             	add    $0x4,%eax
    d744:	0f b6 00             	movzbl (%eax),%eax
    d747:	3c 0d                	cmp    $0xd,%al
    d749:	75 27                	jne    d772 <lodepng_inspect+0xd2>
    d74b:	8b 45 14             	mov    0x14(%ebp),%eax
    d74e:	83 c0 05             	add    $0x5,%eax
    d751:	0f b6 00             	movzbl (%eax),%eax
    d754:	3c 0a                	cmp    $0xa,%al
    d756:	75 1a                	jne    d772 <lodepng_inspect+0xd2>
    d758:	8b 45 14             	mov    0x14(%ebp),%eax
    d75b:	83 c0 06             	add    $0x6,%eax
    d75e:	0f b6 00             	movzbl (%eax),%eax
    d761:	3c 1a                	cmp    $0x1a,%al
    d763:	75 0d                	jne    d772 <lodepng_inspect+0xd2>
    d765:	8b 45 14             	mov    0x14(%ebp),%eax
    d768:	83 c0 07             	add    $0x7,%eax
    d76b:	0f b6 00             	movzbl (%eax),%eax
    d76e:	3c 0a                	cmp    $0xa,%al
    d770:	74 17                	je     d789 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d772:	8b 45 10             	mov    0x10(%ebp),%eax
    d775:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d77c:	00 00 00 
    d77f:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d784:	e9 19 02 00 00       	jmp    d9a2 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d789:	8b 45 14             	mov    0x14(%ebp),%eax
    d78c:	83 c0 08             	add    $0x8,%eax
    d78f:	83 ec 0c             	sub    $0xc,%esp
    d792:	50                   	push   %eax
    d793:	e8 c2 ae ff ff       	call   865a <lodepng_chunk_length>
    d798:	83 c4 10             	add    $0x10,%esp
    d79b:	83 f8 0d             	cmp    $0xd,%eax
    d79e:	74 17                	je     d7b7 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d7a0:	8b 45 10             	mov    0x10(%ebp),%eax
    d7a3:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d7aa:	00 00 00 
    d7ad:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d7b2:	e9 eb 01 00 00       	jmp    d9a2 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d7b7:	8b 45 14             	mov    0x14(%ebp),%eax
    d7ba:	83 c0 08             	add    $0x8,%eax
    d7bd:	83 ec 08             	sub    $0x8,%esp
    d7c0:	68 8c a4 01 00       	push   $0x1a48c
    d7c5:	50                   	push   %eax
    d7c6:	e8 dc ae ff ff       	call   86a7 <lodepng_chunk_type_equals>
    d7cb:	83 c4 10             	add    $0x10,%esp
    d7ce:	84 c0                	test   %al,%al
    d7d0:	75 17                	jne    d7e9 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d7d2:	8b 45 10             	mov    0x10(%ebp),%eax
    d7d5:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d7dc:	00 00 00 
    d7df:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d7e4:	e9 b9 01 00 00       	jmp    d9a2 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d7e9:	8b 45 14             	mov    0x14(%ebp),%eax
    d7ec:	83 c0 10             	add    $0x10,%eax
    d7ef:	83 ec 0c             	sub    $0xc,%esp
    d7f2:	50                   	push   %eax
    d7f3:	e8 5e 62 ff ff       	call   3a56 <lodepng_read32bitInt>
    d7f8:	83 c4 10             	add    $0x10,%esp
    d7fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d7fe:	8b 45 14             	mov    0x14(%ebp),%eax
    d801:	83 c0 14             	add    $0x14,%eax
    d804:	83 ec 0c             	sub    $0xc,%esp
    d807:	50                   	push   %eax
    d808:	e8 49 62 ff ff       	call   3a56 <lodepng_read32bitInt>
    d80d:	83 c4 10             	add    $0x10,%esp
    d810:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d813:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d817:	74 08                	je     d821 <lodepng_inspect+0x181>
    d819:	8b 45 08             	mov    0x8(%ebp),%eax
    d81c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d81f:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d821:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d825:	74 08                	je     d82f <lodepng_inspect+0x18f>
    d827:	8b 45 0c             	mov    0xc(%ebp),%eax
    d82a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d82d:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d82f:	8b 45 14             	mov    0x14(%ebp),%eax
    d832:	83 c0 18             	add    $0x18,%eax
    d835:	0f b6 00             	movzbl (%eax),%eax
    d838:	0f b6 d0             	movzbl %al,%edx
    d83b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d83e:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d841:	8b 45 14             	mov    0x14(%ebp),%eax
    d844:	83 c0 19             	add    $0x19,%eax
    d847:	0f b6 00             	movzbl (%eax),%eax
    d84a:	0f b6 d0             	movzbl %al,%edx
    d84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d850:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d853:	8b 45 14             	mov    0x14(%ebp),%eax
    d856:	83 c0 1a             	add    $0x1a,%eax
    d859:	0f b6 00             	movzbl (%eax),%eax
    d85c:	0f b6 d0             	movzbl %al,%edx
    d85f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d862:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d864:	8b 45 14             	mov    0x14(%ebp),%eax
    d867:	83 c0 1b             	add    $0x1b,%eax
    d86a:	0f b6 00             	movzbl (%eax),%eax
    d86d:	0f b6 d0             	movzbl %al,%edx
    d870:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d873:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d876:	8b 45 14             	mov    0x14(%ebp),%eax
    d879:	83 c0 1c             	add    $0x1c,%eax
    d87c:	0f b6 00             	movzbl (%eax),%eax
    d87f:	0f b6 d0             	movzbl %al,%edx
    d882:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d885:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d888:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d88c:	74 06                	je     d894 <lodepng_inspect+0x1f4>
    d88e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d892:	75 17                	jne    d8ab <lodepng_inspect+0x20b>
    d894:	8b 45 10             	mov    0x10(%ebp),%eax
    d897:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d89e:	00 00 00 
    d8a1:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d8a6:	e9 f7 00 00 00       	jmp    d9a2 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d8ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8ae:	8b 50 10             	mov    0x10(%eax),%edx
    d8b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8b4:	8b 40 0c             	mov    0xc(%eax),%eax
    d8b7:	83 ec 08             	sub    $0x8,%esp
    d8ba:	52                   	push   %edx
    d8bb:	50                   	push   %eax
    d8bc:	e8 d4 b3 ff ff       	call   8c95 <checkColorValidity>
    d8c1:	83 c4 10             	add    $0x10,%esp
    d8c4:	89 c2                	mov    %eax,%edx
    d8c6:	8b 45 10             	mov    0x10(%ebp),%eax
    d8c9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d8cf:	8b 45 10             	mov    0x10(%ebp),%eax
    d8d2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d8d8:	85 c0                	test   %eax,%eax
    d8da:	74 0e                	je     d8ea <lodepng_inspect+0x24a>
    d8dc:	8b 45 10             	mov    0x10(%ebp),%eax
    d8df:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d8e5:	e9 b8 00 00 00       	jmp    d9a2 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d8ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8ed:	8b 00                	mov    (%eax),%eax
    d8ef:	85 c0                	test   %eax,%eax
    d8f1:	74 17                	je     d90a <lodepng_inspect+0x26a>
    d8f3:	8b 45 10             	mov    0x10(%ebp),%eax
    d8f6:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d8fd:	00 00 00 
    d900:	b8 20 00 00 00       	mov    $0x20,%eax
    d905:	e9 98 00 00 00       	jmp    d9a2 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d90a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d90d:	8b 40 04             	mov    0x4(%eax),%eax
    d910:	85 c0                	test   %eax,%eax
    d912:	74 14                	je     d928 <lodepng_inspect+0x288>
    d914:	8b 45 10             	mov    0x10(%ebp),%eax
    d917:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d91e:	00 00 00 
    d921:	b8 21 00 00 00       	mov    $0x21,%eax
    d926:	eb 7a                	jmp    d9a2 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d928:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d92b:	8b 40 08             	mov    0x8(%eax),%eax
    d92e:	83 f8 01             	cmp    $0x1,%eax
    d931:	76 14                	jbe    d947 <lodepng_inspect+0x2a7>
    d933:	8b 45 10             	mov    0x10(%ebp),%eax
    d936:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d93d:	00 00 00 
    d940:	b8 22 00 00 00       	mov    $0x22,%eax
    d945:	eb 5b                	jmp    d9a2 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d947:	8b 45 10             	mov    0x10(%ebp),%eax
    d94a:	8b 40 18             	mov    0x18(%eax),%eax
    d94d:	85 c0                	test   %eax,%eax
    d94f:	75 48                	jne    d999 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d951:	8b 45 14             	mov    0x14(%ebp),%eax
    d954:	83 c0 1d             	add    $0x1d,%eax
    d957:	83 ec 0c             	sub    $0xc,%esp
    d95a:	50                   	push   %eax
    d95b:	e8 f6 60 ff ff       	call   3a56 <lodepng_read32bitInt>
    d960:	83 c4 10             	add    $0x10,%esp
    d963:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d966:	8b 45 14             	mov    0x14(%ebp),%eax
    d969:	83 c0 0c             	add    $0xc,%eax
    d96c:	83 ec 08             	sub    $0x8,%esp
    d96f:	6a 11                	push   $0x11
    d971:	50                   	push   %eax
    d972:	e8 71 ab ff ff       	call   84e8 <lodepng_crc32>
    d977:	83 c4 10             	add    $0x10,%esp
    d97a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d97d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d980:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d983:	74 14                	je     d999 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d985:	8b 45 10             	mov    0x10(%ebp),%eax
    d988:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d98f:	00 00 00 
    d992:	b8 39 00 00 00       	mov    $0x39,%eax
    d997:	eb 09                	jmp    d9a2 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d999:	8b 45 10             	mov    0x10(%ebp),%eax
    d99c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d9a2:	c9                   	leave  
    d9a3:	c3                   	ret    

0000d9a4 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d9a4:	55                   	push   %ebp
    d9a5:	89 e5                	mov    %esp,%ebp
    d9a7:	56                   	push   %esi
    d9a8:	53                   	push   %ebx
    d9a9:	83 ec 44             	sub    $0x44,%esp
    d9ac:	8b 45 18             	mov    0x18(%ebp),%eax
    d9af:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d9b2:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d9b6:	83 f8 04             	cmp    $0x4,%eax
    d9b9:	0f 87 81 07 00 00    	ja     e140 <unfilterScanline+0x79c>
    d9bf:	8b 04 85 94 a4 01 00 	mov    0x1a494(,%eax,4),%eax
    d9c6:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d9c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d9cf:	eb 19                	jmp    d9ea <unfilterScanline+0x46>
    d9d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d9d4:	8b 45 08             	mov    0x8(%ebp),%eax
    d9d7:	01 c2                	add    %eax,%edx
    d9d9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d9dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9df:	01 c8                	add    %ecx,%eax
    d9e1:	0f b6 00             	movzbl (%eax),%eax
    d9e4:	88 02                	mov    %al,(%edx)
    d9e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d9ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9ed:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d9f0:	75 df                	jne    d9d1 <unfilterScanline+0x2d>
      break;
    d9f2:	e9 50 07 00 00       	jmp    e147 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d9f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d9fe:	eb 19                	jmp    da19 <unfilterScanline+0x75>
    da00:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da03:	8b 45 08             	mov    0x8(%ebp),%eax
    da06:	01 c2                	add    %eax,%edx
    da08:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    da0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    da0e:	01 c8                	add    %ecx,%eax
    da10:	0f b6 00             	movzbl (%eax),%eax
    da13:	88 02                	mov    %al,(%edx)
    da15:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da19:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da1c:	3b 45 14             	cmp    0x14(%ebp),%eax
    da1f:	75 df                	jne    da00 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    da21:	8b 45 14             	mov    0x14(%ebp),%eax
    da24:	89 45 f4             	mov    %eax,-0xc(%ebp)
    da27:	eb 2b                	jmp    da54 <unfilterScanline+0xb0>
    da29:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da2c:	8b 45 08             	mov    0x8(%ebp),%eax
    da2f:	01 c2                	add    %eax,%edx
    da31:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    da34:	8b 45 0c             	mov    0xc(%ebp),%eax
    da37:	01 c8                	add    %ecx,%eax
    da39:	0f b6 08             	movzbl (%eax),%ecx
    da3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da3f:	2b 45 14             	sub    0x14(%ebp),%eax
    da42:	89 c3                	mov    %eax,%ebx
    da44:	8b 45 08             	mov    0x8(%ebp),%eax
    da47:	01 d8                	add    %ebx,%eax
    da49:	0f b6 00             	movzbl (%eax),%eax
    da4c:	01 c8                	add    %ecx,%eax
    da4e:	88 02                	mov    %al,(%edx)
    da50:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da54:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da57:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    da5a:	7c cd                	jl     da29 <unfilterScanline+0x85>
      break;
    da5c:	e9 e6 06 00 00       	jmp    e147 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    da61:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    da65:	74 3c                	je     daa3 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    da67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    da6e:	eb 26                	jmp    da96 <unfilterScanline+0xf2>
    da70:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da73:	8b 45 08             	mov    0x8(%ebp),%eax
    da76:	01 d0                	add    %edx,%eax
    da78:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    da7b:	8b 55 0c             	mov    0xc(%ebp),%edx
    da7e:	01 ca                	add    %ecx,%edx
    da80:	0f b6 0a             	movzbl (%edx),%ecx
    da83:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    da86:	8b 55 10             	mov    0x10(%ebp),%edx
    da89:	01 da                	add    %ebx,%edx
    da8b:	0f b6 12             	movzbl (%edx),%edx
    da8e:	01 ca                	add    %ecx,%edx
    da90:	88 10                	mov    %dl,(%eax)
    da92:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da99:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    da9c:	75 d2                	jne    da70 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    da9e:	e9 a4 06 00 00       	jmp    e147 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    daa3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    daaa:	eb 19                	jmp    dac5 <unfilterScanline+0x121>
    daac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    daaf:	8b 45 08             	mov    0x8(%ebp),%eax
    dab2:	01 c2                	add    %eax,%edx
    dab4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dab7:	8b 45 0c             	mov    0xc(%ebp),%eax
    daba:	01 c8                	add    %ecx,%eax
    dabc:	0f b6 00             	movzbl (%eax),%eax
    dabf:	88 02                	mov    %al,(%edx)
    dac1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dac5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dac8:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dacb:	75 df                	jne    daac <unfilterScanline+0x108>
      }
      break;
    dacd:	e9 75 06 00 00       	jmp    e147 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    dad2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    dad6:	0f 84 8e 00 00 00    	je     db6a <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    dadc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dae3:	eb 28                	jmp    db0d <unfilterScanline+0x169>
    dae5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dae8:	8b 45 08             	mov    0x8(%ebp),%eax
    daeb:	01 d0                	add    %edx,%eax
    daed:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    daf0:	8b 55 0c             	mov    0xc(%ebp),%edx
    daf3:	01 ca                	add    %ecx,%edx
    daf5:	0f b6 12             	movzbl (%edx),%edx
    daf8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    dafb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    dafe:	01 d9                	add    %ebx,%ecx
    db00:	0f b6 09             	movzbl (%ecx),%ecx
    db03:	d0 e9                	shr    %cl
    db05:	01 ca                	add    %ecx,%edx
    db07:	88 10                	mov    %dl,(%eax)
    db09:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    db0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db10:	3b 45 14             	cmp    0x14(%ebp),%eax
    db13:	75 d0                	jne    dae5 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    db15:	8b 45 14             	mov    0x14(%ebp),%eax
    db18:	89 45 f4             	mov    %eax,-0xc(%ebp)
    db1b:	eb 40                	jmp    db5d <unfilterScanline+0x1b9>
    db1d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db20:	8b 45 08             	mov    0x8(%ebp),%eax
    db23:	01 c2                	add    %eax,%edx
    db25:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    db28:	8b 45 0c             	mov    0xc(%ebp),%eax
    db2b:	01 c8                	add    %ecx,%eax
    db2d:	0f b6 08             	movzbl (%eax),%ecx
    db30:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db33:	2b 45 14             	sub    0x14(%ebp),%eax
    db36:	89 c3                	mov    %eax,%ebx
    db38:	8b 45 08             	mov    0x8(%ebp),%eax
    db3b:	01 d8                	add    %ebx,%eax
    db3d:	0f b6 00             	movzbl (%eax),%eax
    db40:	0f b6 d8             	movzbl %al,%ebx
    db43:	8b 75 f4             	mov    -0xc(%ebp),%esi
    db46:	8b 45 10             	mov    0x10(%ebp),%eax
    db49:	01 f0                	add    %esi,%eax
    db4b:	0f b6 00             	movzbl (%eax),%eax
    db4e:	0f b6 c0             	movzbl %al,%eax
    db51:	01 d8                	add    %ebx,%eax
    db53:	d1 f8                	sar    %eax
    db55:	01 c8                	add    %ecx,%eax
    db57:	88 02                	mov    %al,(%edx)
    db59:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    db5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db60:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    db63:	7c b8                	jl     db1d <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    db65:	e9 dd 05 00 00       	jmp    e147 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    db6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    db71:	eb 19                	jmp    db8c <unfilterScanline+0x1e8>
    db73:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db76:	8b 45 08             	mov    0x8(%ebp),%eax
    db79:	01 c2                	add    %eax,%edx
    db7b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    db7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    db81:	01 c8                	add    %ecx,%eax
    db83:	0f b6 00             	movzbl (%eax),%eax
    db86:	88 02                	mov    %al,(%edx)
    db88:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    db8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db8f:	3b 45 14             	cmp    0x14(%ebp),%eax
    db92:	75 df                	jne    db73 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    db94:	8b 45 14             	mov    0x14(%ebp),%eax
    db97:	89 45 f4             	mov    %eax,-0xc(%ebp)
    db9a:	eb 2d                	jmp    dbc9 <unfilterScanline+0x225>
    db9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db9f:	8b 45 08             	mov    0x8(%ebp),%eax
    dba2:	01 c2                	add    %eax,%edx
    dba4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dba7:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbaa:	01 c8                	add    %ecx,%eax
    dbac:	0f b6 08             	movzbl (%eax),%ecx
    dbaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbb2:	2b 45 14             	sub    0x14(%ebp),%eax
    dbb5:	89 c3                	mov    %eax,%ebx
    dbb7:	8b 45 08             	mov    0x8(%ebp),%eax
    dbba:	01 d8                	add    %ebx,%eax
    dbbc:	0f b6 00             	movzbl (%eax),%eax
    dbbf:	d0 e8                	shr    %al
    dbc1:	01 c8                	add    %ecx,%eax
    dbc3:	88 02                	mov    %al,(%edx)
    dbc5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dbc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbcc:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dbcf:	7c cb                	jl     db9c <unfilterScanline+0x1f8>
      }
      break;
    dbd1:	e9 71 05 00 00       	jmp    e147 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    dbd6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    dbda:	0f 84 f9 04 00 00    	je     e0d9 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    dbe0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dbe7:	eb 26                	jmp    dc0f <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    dbe9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbec:	8b 45 08             	mov    0x8(%ebp),%eax
    dbef:	01 d0                	add    %edx,%eax
    dbf1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dbf4:	8b 55 0c             	mov    0xc(%ebp),%edx
    dbf7:	01 ca                	add    %ecx,%edx
    dbf9:	0f b6 0a             	movzbl (%edx),%ecx
    dbfc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    dbff:	8b 55 10             	mov    0x10(%ebp),%edx
    dc02:	01 da                	add    %ebx,%edx
    dc04:	0f b6 12             	movzbl (%edx),%edx
    dc07:	01 ca                	add    %ecx,%edx
    dc09:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    dc0b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dc0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc12:	3b 45 14             	cmp    0x14(%ebp),%eax
    dc15:	75 d2                	jne    dbe9 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    dc17:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    dc1b:	0f 8e db 01 00 00    	jle    ddfc <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    dc21:	e9 c2 01 00 00       	jmp    dde8 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    dc26:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc29:	2b 45 14             	sub    0x14(%ebp),%eax
    dc2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    dc2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc32:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc35:	01 d0                	add    %edx,%eax
    dc37:	0f b6 00             	movzbl (%eax),%eax
    dc3a:	88 45 ef             	mov    %al,-0x11(%ebp)
    dc3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc40:	8d 50 01             	lea    0x1(%eax),%edx
    dc43:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc46:	01 d0                	add    %edx,%eax
    dc48:	0f b6 00             	movzbl (%eax),%eax
    dc4b:	88 45 ee             	mov    %al,-0x12(%ebp)
    dc4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc51:	8d 50 02             	lea    0x2(%eax),%edx
    dc54:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc57:	01 d0                	add    %edx,%eax
    dc59:	0f b6 00             	movzbl (%eax),%eax
    dc5c:	88 45 ed             	mov    %al,-0x13(%ebp)
    dc5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc62:	8d 50 03             	lea    0x3(%eax),%edx
    dc65:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc68:	01 d0                	add    %edx,%eax
    dc6a:	0f b6 00             	movzbl (%eax),%eax
    dc6d:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    dc70:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dc73:	8b 45 08             	mov    0x8(%ebp),%eax
    dc76:	01 d0                	add    %edx,%eax
    dc78:	0f b6 00             	movzbl (%eax),%eax
    dc7b:	88 45 eb             	mov    %al,-0x15(%ebp)
    dc7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc81:	8d 50 01             	lea    0x1(%eax),%edx
    dc84:	8b 45 08             	mov    0x8(%ebp),%eax
    dc87:	01 d0                	add    %edx,%eax
    dc89:	0f b6 00             	movzbl (%eax),%eax
    dc8c:	88 45 ea             	mov    %al,-0x16(%ebp)
    dc8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc92:	8d 50 02             	lea    0x2(%eax),%edx
    dc95:	8b 45 08             	mov    0x8(%ebp),%eax
    dc98:	01 d0                	add    %edx,%eax
    dc9a:	0f b6 00             	movzbl (%eax),%eax
    dc9d:	88 45 e9             	mov    %al,-0x17(%ebp)
    dca0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dca3:	8d 50 03             	lea    0x3(%eax),%edx
    dca6:	8b 45 08             	mov    0x8(%ebp),%eax
    dca9:	01 d0                	add    %edx,%eax
    dcab:	0f b6 00             	movzbl (%eax),%eax
    dcae:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    dcb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcb4:	8b 45 10             	mov    0x10(%ebp),%eax
    dcb7:	01 d0                	add    %edx,%eax
    dcb9:	0f b6 00             	movzbl (%eax),%eax
    dcbc:	88 45 e7             	mov    %al,-0x19(%ebp)
    dcbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcc2:	8d 50 01             	lea    0x1(%eax),%edx
    dcc5:	8b 45 10             	mov    0x10(%ebp),%eax
    dcc8:	01 d0                	add    %edx,%eax
    dcca:	0f b6 00             	movzbl (%eax),%eax
    dccd:	88 45 e6             	mov    %al,-0x1a(%ebp)
    dcd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcd3:	8d 50 02             	lea    0x2(%eax),%edx
    dcd6:	8b 45 10             	mov    0x10(%ebp),%eax
    dcd9:	01 d0                	add    %edx,%eax
    dcdb:	0f b6 00             	movzbl (%eax),%eax
    dcde:	88 45 e5             	mov    %al,-0x1b(%ebp)
    dce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dce4:	8d 50 03             	lea    0x3(%eax),%edx
    dce7:	8b 45 10             	mov    0x10(%ebp),%eax
    dcea:	01 d0                	add    %edx,%eax
    dcec:	0f b6 00             	movzbl (%eax),%eax
    dcef:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    dcf2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dcf5:	8b 45 10             	mov    0x10(%ebp),%eax
    dcf8:	01 d0                	add    %edx,%eax
    dcfa:	0f b6 00             	movzbl (%eax),%eax
    dcfd:	88 45 e3             	mov    %al,-0x1d(%ebp)
    dd00:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dd03:	8d 50 01             	lea    0x1(%eax),%edx
    dd06:	8b 45 10             	mov    0x10(%ebp),%eax
    dd09:	01 d0                	add    %edx,%eax
    dd0b:	0f b6 00             	movzbl (%eax),%eax
    dd0e:	88 45 e2             	mov    %al,-0x1e(%ebp)
    dd11:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dd14:	8d 50 02             	lea    0x2(%eax),%edx
    dd17:	8b 45 10             	mov    0x10(%ebp),%eax
    dd1a:	01 d0                	add    %edx,%eax
    dd1c:	0f b6 00             	movzbl (%eax),%eax
    dd1f:	88 45 e1             	mov    %al,-0x1f(%ebp)
    dd22:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dd25:	8d 50 03             	lea    0x3(%eax),%edx
    dd28:	8b 45 10             	mov    0x10(%ebp),%eax
    dd2b:	01 d0                	add    %edx,%eax
    dd2d:	0f b6 00             	movzbl (%eax),%eax
    dd30:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dd33:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd36:	8b 45 08             	mov    0x8(%ebp),%eax
    dd39:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd3c:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    dd40:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    dd44:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    dd48:	51                   	push   %ecx
    dd49:	52                   	push   %edx
    dd4a:	50                   	push   %eax
    dd4b:	e8 3f f6 ff ff       	call   d38f <paethPredictor>
    dd50:	83 c4 0c             	add    $0xc,%esp
    dd53:	89 c2                	mov    %eax,%edx
    dd55:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    dd59:	01 d0                	add    %edx,%eax
    dd5b:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dd5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd60:	8d 50 01             	lea    0x1(%eax),%edx
    dd63:	8b 45 08             	mov    0x8(%ebp),%eax
    dd66:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd69:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    dd6d:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    dd71:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    dd75:	51                   	push   %ecx
    dd76:	52                   	push   %edx
    dd77:	50                   	push   %eax
    dd78:	e8 12 f6 ff ff       	call   d38f <paethPredictor>
    dd7d:	83 c4 0c             	add    $0xc,%esp
    dd80:	89 c2                	mov    %eax,%edx
    dd82:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    dd86:	01 d0                	add    %edx,%eax
    dd88:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    dd8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd8d:	8d 50 02             	lea    0x2(%eax),%edx
    dd90:	8b 45 08             	mov    0x8(%ebp),%eax
    dd93:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dd96:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    dd9a:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    dd9e:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    dda2:	51                   	push   %ecx
    dda3:	52                   	push   %edx
    dda4:	50                   	push   %eax
    dda5:	e8 e5 f5 ff ff       	call   d38f <paethPredictor>
    ddaa:	83 c4 0c             	add    $0xc,%esp
    ddad:	89 c2                	mov    %eax,%edx
    ddaf:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    ddb3:	01 d0                	add    %edx,%eax
    ddb5:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    ddb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddba:	8d 50 03             	lea    0x3(%eax),%edx
    ddbd:	8b 45 08             	mov    0x8(%ebp),%eax
    ddc0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ddc3:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    ddc7:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    ddcb:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    ddcf:	51                   	push   %ecx
    ddd0:	52                   	push   %edx
    ddd1:	50                   	push   %eax
    ddd2:	e8 b8 f5 ff ff       	call   d38f <paethPredictor>
    ddd7:	83 c4 0c             	add    $0xc,%esp
    ddda:	89 c2                	mov    %eax,%edx
    dddc:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    dde0:	01 d0                	add    %edx,%eax
    dde2:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    dde4:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    dde8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddeb:	83 c0 03             	add    $0x3,%eax
    ddee:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ddf1:	0f 8c 2f fe ff ff    	jl     dc26 <unfilterScanline+0x282>
    ddf7:	e9 d3 02 00 00       	jmp    e0cf <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    ddfc:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    de00:	0f 8e 6a 01 00 00    	jle    df70 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    de06:	e9 51 01 00 00       	jmp    df5c <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    de0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de0e:	2b 45 14             	sub    0x14(%ebp),%eax
    de11:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    de14:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de17:	8b 45 0c             	mov    0xc(%ebp),%eax
    de1a:	01 d0                	add    %edx,%eax
    de1c:	0f b6 00             	movzbl (%eax),%eax
    de1f:	88 45 db             	mov    %al,-0x25(%ebp)
    de22:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de25:	8d 50 01             	lea    0x1(%eax),%edx
    de28:	8b 45 0c             	mov    0xc(%ebp),%eax
    de2b:	01 d0                	add    %edx,%eax
    de2d:	0f b6 00             	movzbl (%eax),%eax
    de30:	88 45 da             	mov    %al,-0x26(%ebp)
    de33:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de36:	8d 50 02             	lea    0x2(%eax),%edx
    de39:	8b 45 0c             	mov    0xc(%ebp),%eax
    de3c:	01 d0                	add    %edx,%eax
    de3e:	0f b6 00             	movzbl (%eax),%eax
    de41:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    de44:	8b 55 dc             	mov    -0x24(%ebp),%edx
    de47:	8b 45 08             	mov    0x8(%ebp),%eax
    de4a:	01 d0                	add    %edx,%eax
    de4c:	0f b6 00             	movzbl (%eax),%eax
    de4f:	88 45 d8             	mov    %al,-0x28(%ebp)
    de52:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de55:	8d 50 01             	lea    0x1(%eax),%edx
    de58:	8b 45 08             	mov    0x8(%ebp),%eax
    de5b:	01 d0                	add    %edx,%eax
    de5d:	0f b6 00             	movzbl (%eax),%eax
    de60:	88 45 d7             	mov    %al,-0x29(%ebp)
    de63:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de66:	8d 50 02             	lea    0x2(%eax),%edx
    de69:	8b 45 08             	mov    0x8(%ebp),%eax
    de6c:	01 d0                	add    %edx,%eax
    de6e:	0f b6 00             	movzbl (%eax),%eax
    de71:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    de74:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de77:	8b 45 10             	mov    0x10(%ebp),%eax
    de7a:	01 d0                	add    %edx,%eax
    de7c:	0f b6 00             	movzbl (%eax),%eax
    de7f:	88 45 d5             	mov    %al,-0x2b(%ebp)
    de82:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de85:	8d 50 01             	lea    0x1(%eax),%edx
    de88:	8b 45 10             	mov    0x10(%ebp),%eax
    de8b:	01 d0                	add    %edx,%eax
    de8d:	0f b6 00             	movzbl (%eax),%eax
    de90:	88 45 d4             	mov    %al,-0x2c(%ebp)
    de93:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de96:	8d 50 02             	lea    0x2(%eax),%edx
    de99:	8b 45 10             	mov    0x10(%ebp),%eax
    de9c:	01 d0                	add    %edx,%eax
    de9e:	0f b6 00             	movzbl (%eax),%eax
    dea1:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    dea4:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dea7:	8b 45 10             	mov    0x10(%ebp),%eax
    deaa:	01 d0                	add    %edx,%eax
    deac:	0f b6 00             	movzbl (%eax),%eax
    deaf:	88 45 d2             	mov    %al,-0x2e(%ebp)
    deb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    deb5:	8d 50 01             	lea    0x1(%eax),%edx
    deb8:	8b 45 10             	mov    0x10(%ebp),%eax
    debb:	01 d0                	add    %edx,%eax
    debd:	0f b6 00             	movzbl (%eax),%eax
    dec0:	88 45 d1             	mov    %al,-0x2f(%ebp)
    dec3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dec6:	8d 50 02             	lea    0x2(%eax),%edx
    dec9:	8b 45 10             	mov    0x10(%ebp),%eax
    decc:	01 d0                	add    %edx,%eax
    dece:	0f b6 00             	movzbl (%eax),%eax
    ded1:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    ded4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ded7:	8b 45 08             	mov    0x8(%ebp),%eax
    deda:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dedd:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    dee1:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    dee5:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    dee9:	51                   	push   %ecx
    deea:	52                   	push   %edx
    deeb:	50                   	push   %eax
    deec:	e8 9e f4 ff ff       	call   d38f <paethPredictor>
    def1:	83 c4 0c             	add    $0xc,%esp
    def4:	89 c2                	mov    %eax,%edx
    def6:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    defa:	01 d0                	add    %edx,%eax
    defc:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    defe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df01:	8d 50 01             	lea    0x1(%eax),%edx
    df04:	8b 45 08             	mov    0x8(%ebp),%eax
    df07:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df0a:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    df0e:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    df12:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    df16:	51                   	push   %ecx
    df17:	52                   	push   %edx
    df18:	50                   	push   %eax
    df19:	e8 71 f4 ff ff       	call   d38f <paethPredictor>
    df1e:	83 c4 0c             	add    $0xc,%esp
    df21:	89 c2                	mov    %eax,%edx
    df23:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    df27:	01 d0                	add    %edx,%eax
    df29:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    df2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df2e:	8d 50 02             	lea    0x2(%eax),%edx
    df31:	8b 45 08             	mov    0x8(%ebp),%eax
    df34:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df37:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    df3b:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    df3f:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    df43:	51                   	push   %ecx
    df44:	52                   	push   %edx
    df45:	50                   	push   %eax
    df46:	e8 44 f4 ff ff       	call   d38f <paethPredictor>
    df4b:	83 c4 0c             	add    $0xc,%esp
    df4e:	89 c2                	mov    %eax,%edx
    df50:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    df54:	01 d0                	add    %edx,%eax
    df56:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    df58:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    df5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df5f:	83 c0 02             	add    $0x2,%eax
    df62:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    df65:	0f 8c a0 fe ff ff    	jl     de0b <unfilterScanline+0x467>
    df6b:	e9 5f 01 00 00       	jmp    e0cf <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    df70:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    df74:	0f 8e 55 01 00 00    	jle    e0cf <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    df7a:	e9 e0 00 00 00       	jmp    e05f <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    df7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df82:	2b 45 14             	sub    0x14(%ebp),%eax
    df85:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    df88:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    df8e:	01 d0                	add    %edx,%eax
    df90:	0f b6 00             	movzbl (%eax),%eax
    df93:	88 45 cb             	mov    %al,-0x35(%ebp)
    df96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df99:	8d 50 01             	lea    0x1(%eax),%edx
    df9c:	8b 45 0c             	mov    0xc(%ebp),%eax
    df9f:	01 d0                	add    %edx,%eax
    dfa1:	0f b6 00             	movzbl (%eax),%eax
    dfa4:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dfa7:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dfaa:	8b 45 08             	mov    0x8(%ebp),%eax
    dfad:	01 d0                	add    %edx,%eax
    dfaf:	0f b6 00             	movzbl (%eax),%eax
    dfb2:	88 45 c9             	mov    %al,-0x37(%ebp)
    dfb5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dfb8:	8d 50 01             	lea    0x1(%eax),%edx
    dfbb:	8b 45 08             	mov    0x8(%ebp),%eax
    dfbe:	01 d0                	add    %edx,%eax
    dfc0:	0f b6 00             	movzbl (%eax),%eax
    dfc3:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dfc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dfc9:	8b 45 10             	mov    0x10(%ebp),%eax
    dfcc:	01 d0                	add    %edx,%eax
    dfce:	0f b6 00             	movzbl (%eax),%eax
    dfd1:	88 45 c7             	mov    %al,-0x39(%ebp)
    dfd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfd7:	8d 50 01             	lea    0x1(%eax),%edx
    dfda:	8b 45 10             	mov    0x10(%ebp),%eax
    dfdd:	01 d0                	add    %edx,%eax
    dfdf:	0f b6 00             	movzbl (%eax),%eax
    dfe2:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dfe5:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dfe8:	8b 45 10             	mov    0x10(%ebp),%eax
    dfeb:	01 d0                	add    %edx,%eax
    dfed:	0f b6 00             	movzbl (%eax),%eax
    dff0:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dff3:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dff6:	8d 50 01             	lea    0x1(%eax),%edx
    dff9:	8b 45 10             	mov    0x10(%ebp),%eax
    dffc:	01 d0                	add    %edx,%eax
    dffe:	0f b6 00             	movzbl (%eax),%eax
    e001:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    e004:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e007:	8b 45 08             	mov    0x8(%ebp),%eax
    e00a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e00d:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    e011:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    e015:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    e019:	51                   	push   %ecx
    e01a:	52                   	push   %edx
    e01b:	50                   	push   %eax
    e01c:	e8 6e f3 ff ff       	call   d38f <paethPredictor>
    e021:	83 c4 0c             	add    $0xc,%esp
    e024:	89 c2                	mov    %eax,%edx
    e026:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    e02a:	01 d0                	add    %edx,%eax
    e02c:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    e02e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e031:	8d 50 01             	lea    0x1(%eax),%edx
    e034:	8b 45 08             	mov    0x8(%ebp),%eax
    e037:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e03a:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    e03e:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    e042:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    e046:	51                   	push   %ecx
    e047:	52                   	push   %edx
    e048:	50                   	push   %eax
    e049:	e8 41 f3 ff ff       	call   d38f <paethPredictor>
    e04e:	83 c4 0c             	add    $0xc,%esp
    e051:	89 c2                	mov    %eax,%edx
    e053:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    e057:	01 d0                	add    %edx,%eax
    e059:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    e05b:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    e05f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e062:	83 c0 01             	add    $0x1,%eax
    e065:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e068:	0f 8c 11 ff ff ff    	jl     df7f <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    e06e:	eb 5f                	jmp    e0cf <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    e070:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e073:	8b 45 08             	mov    0x8(%ebp),%eax
    e076:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    e079:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e07c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e07f:	01 d0                	add    %edx,%eax
    e081:	0f b6 00             	movzbl (%eax),%eax
    e084:	88 45 b7             	mov    %al,-0x49(%ebp)
    e087:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e08a:	2b 45 14             	sub    0x14(%ebp),%eax
    e08d:	89 c2                	mov    %eax,%edx
    e08f:	8b 45 10             	mov    0x10(%ebp),%eax
    e092:	01 d0                	add    %edx,%eax
    e094:	0f b6 00             	movzbl (%eax),%eax
    e097:	0f b6 c8             	movzbl %al,%ecx
    e09a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e09d:	8b 45 10             	mov    0x10(%ebp),%eax
    e0a0:	01 d0                	add    %edx,%eax
    e0a2:	0f b6 00             	movzbl (%eax),%eax
    e0a5:	0f b6 d0             	movzbl %al,%edx
    e0a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0ab:	2b 45 14             	sub    0x14(%ebp),%eax
    e0ae:	89 c6                	mov    %eax,%esi
    e0b0:	8b 45 08             	mov    0x8(%ebp),%eax
    e0b3:	01 f0                	add    %esi,%eax
    e0b5:	0f b6 00             	movzbl (%eax),%eax
    e0b8:	0f b6 c0             	movzbl %al,%eax
    e0bb:	51                   	push   %ecx
    e0bc:	52                   	push   %edx
    e0bd:	50                   	push   %eax
    e0be:	e8 cc f2 ff ff       	call   d38f <paethPredictor>
    e0c3:	83 c4 0c             	add    $0xc,%esp
    e0c6:	02 45 b7             	add    -0x49(%ebp),%al
    e0c9:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    e0cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e0cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0d2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e0d5:	75 99                	jne    e070 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e0d7:	eb 6e                	jmp    e147 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e0d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e0e0:	eb 19                	jmp    e0fb <unfilterScanline+0x757>
          recon[i] = scanline[i];
    e0e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e0e5:	8b 45 08             	mov    0x8(%ebp),%eax
    e0e8:	01 c2                	add    %eax,%edx
    e0ea:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e0ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    e0f0:	01 c8                	add    %ecx,%eax
    e0f2:	0f b6 00             	movzbl (%eax),%eax
    e0f5:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e0f7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e0fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0fe:	3b 45 14             	cmp    0x14(%ebp),%eax
    e101:	75 df                	jne    e0e2 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e103:	8b 45 14             	mov    0x14(%ebp),%eax
    e106:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e109:	eb 2b                	jmp    e136 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    e10b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e10e:	8b 45 08             	mov    0x8(%ebp),%eax
    e111:	01 c2                	add    %eax,%edx
    e113:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e116:	8b 45 0c             	mov    0xc(%ebp),%eax
    e119:	01 c8                	add    %ecx,%eax
    e11b:	0f b6 08             	movzbl (%eax),%ecx
    e11e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e121:	2b 45 14             	sub    0x14(%ebp),%eax
    e124:	89 c3                	mov    %eax,%ebx
    e126:	8b 45 08             	mov    0x8(%ebp),%eax
    e129:	01 d8                	add    %ebx,%eax
    e12b:	0f b6 00             	movzbl (%eax),%eax
    e12e:	01 c8                	add    %ecx,%eax
    e130:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e132:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e136:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e139:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e13c:	7c cd                	jl     e10b <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e13e:	eb 07                	jmp    e147 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    e140:	b8 24 00 00 00       	mov    $0x24,%eax
    e145:	eb 05                	jmp    e14c <unfilterScanline+0x7a8>
  }
  return 0;
    e147:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e14c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e14f:	5b                   	pop    %ebx
    e150:	5e                   	pop    %esi
    e151:	5d                   	pop    %ebp
    e152:	c3                   	ret    

0000e153 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e153:	55                   	push   %ebp
    e154:	89 e5                	mov    %esp,%ebp
    e156:	53                   	push   %ebx
    e157:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    e15a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    e161:	8b 45 18             	mov    0x18(%ebp),%eax
    e164:	83 c0 07             	add    $0x7,%eax
    e167:	c1 e8 03             	shr    $0x3,%eax
    e16a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    e16d:	ff 75 18             	pushl  0x18(%ebp)
    e170:	6a 01                	push   $0x1
    e172:	ff 75 10             	pushl  0x10(%ebp)
    e175:	e8 d9 b1 ff ff       	call   9353 <lodepng_get_raw_size_idat>
    e17a:	83 c4 0c             	add    $0xc,%esp
    e17d:	83 e8 01             	sub    $0x1,%eax
    e180:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    e183:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e18a:	eb 6d                	jmp    e1f9 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    e18c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e18f:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e193:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    e196:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e199:	83 c0 01             	add    $0x1,%eax
    e19c:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e1a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    e1a3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e1a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e1a9:	01 d0                	add    %edx,%eax
    e1ab:	0f b6 00             	movzbl (%eax),%eax
    e1ae:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    e1b1:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    e1b5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e1b8:	8d 4a 01             	lea    0x1(%edx),%ecx
    e1bb:	8b 55 0c             	mov    0xc(%ebp),%edx
    e1be:	01 d1                	add    %edx,%ecx
    e1c0:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    e1c3:	8b 55 08             	mov    0x8(%ebp),%edx
    e1c6:	01 da                	add    %ebx,%edx
    e1c8:	ff 75 ec             	pushl  -0x14(%ebp)
    e1cb:	50                   	push   %eax
    e1cc:	ff 75 f0             	pushl  -0x10(%ebp)
    e1cf:	ff 75 f4             	pushl  -0xc(%ebp)
    e1d2:	51                   	push   %ecx
    e1d3:	52                   	push   %edx
    e1d4:	e8 cb f7 ff ff       	call   d9a4 <unfilterScanline>
    e1d9:	83 c4 18             	add    $0x18,%esp
    e1dc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    e1df:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    e1e3:	74 05                	je     e1ea <unfilter+0x97>
    e1e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e1e8:	eb 1c                	jmp    e206 <unfilter+0xb3>

    prevline = &out[outindex];
    e1ea:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e1ed:	8b 45 08             	mov    0x8(%ebp),%eax
    e1f0:	01 d0                	add    %edx,%eax
    e1f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    e1f5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e1f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e1fc:	3b 45 14             	cmp    0x14(%ebp),%eax
    e1ff:	72 8b                	jb     e18c <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    e201:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e206:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e209:	c9                   	leave  
    e20a:	c3                   	ret    

0000e20b <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e20b:	55                   	push   %ebp
    e20c:	89 e5                	mov    %esp,%ebp
    e20e:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e214:	ff 75 18             	pushl  0x18(%ebp)
    e217:	ff 75 14             	pushl  0x14(%ebp)
    e21a:	ff 75 10             	pushl  0x10(%ebp)
    e21d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    e223:	50                   	push   %eax
    e224:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    e22a:	50                   	push   %eax
    e22b:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    e231:	50                   	push   %eax
    e232:	8d 45 94             	lea    -0x6c(%ebp),%eax
    e235:	50                   	push   %eax
    e236:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e239:	50                   	push   %eax
    e23a:	e8 e6 f1 ff ff       	call   d425 <Adam7_getpassvalues>
    e23f:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    e242:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    e246:	0f 86 0a 01 00 00    	jbe    e356 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    e24c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e253:	e9 ef 00 00 00       	jmp    e347 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    e258:	8b 45 18             	mov    0x18(%ebp),%eax
    e25b:	c1 e8 03             	shr    $0x3,%eax
    e25e:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    e261:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e268:	e9 c6 00 00 00       	jmp    e333 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    e26d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e274:	e9 a6 00 00 00       	jmp    e31f <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    e279:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e27c:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e283:	89 c1                	mov    %eax,%ecx
    e285:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e288:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e28c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e290:	89 c2                	mov    %eax,%edx
    e292:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e295:	01 c2                	add    %eax,%edx
    e297:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e29a:	0f af c2             	imul   %edx,%eax
    e29d:	01 c8                	add    %ecx,%eax
    e29f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e2a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2a5:	8b 14 85 38 a4 01 00 	mov    0x1a438(,%eax,4),%edx
    e2ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2af:	8b 04 85 70 a4 01 00 	mov    0x1a470(,%eax,4),%eax
    e2b6:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e2ba:	01 d0                	add    %edx,%eax
    e2bc:	0f af 45 10          	imul   0x10(%ebp),%eax
    e2c0:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    e2c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2c5:	8b 04 85 54 a4 01 00 	mov    0x1a454(,%eax,4),%eax
    e2cc:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e2d0:	01 c2                	add    %eax,%edx
    e2d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2d5:	8b 04 85 1c a4 01 00 	mov    0x1a41c(,%eax,4),%eax
    e2dc:	01 c2                	add    %eax,%edx
    e2de:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e2e1:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e2e4:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e2e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e2ee:	eb 23                	jmp    e313 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    e2f0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e2f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e2f6:	01 c2                	add    %eax,%edx
    e2f8:	8b 45 08             	mov    0x8(%ebp),%eax
    e2fb:	01 c2                	add    %eax,%edx
    e2fd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e300:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e303:	01 c1                	add    %eax,%ecx
    e305:	8b 45 0c             	mov    0xc(%ebp),%eax
    e308:	01 c8                	add    %ecx,%eax
    e30a:	0f b6 00             	movzbl (%eax),%eax
    e30d:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e30f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e313:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e316:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e319:	72 d5                	jb     e2f0 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e31b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e31f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e322:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e326:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e329:	0f 87 4a ff ff ff    	ja     e279 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e32f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e333:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e336:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e33a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e33d:	0f 87 2a ff ff ff    	ja     e26d <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e343:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e347:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e34b:	0f 85 07 ff ff ff    	jne    e258 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e351:	e9 22 01 00 00       	jmp    e478 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e356:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e35d:	e9 0c 01 00 00       	jmp    e46e <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e362:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e365:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e369:	0f af 45 18          	imul   0x18(%ebp),%eax
    e36d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e370:	8b 45 18             	mov    0x18(%ebp),%eax
    e373:	0f af 45 10          	imul   0x10(%ebp),%eax
    e377:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e37a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e381:	e9 d4 00 00 00       	jmp    e45a <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e386:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e38d:	e9 b4 00 00 00       	jmp    e446 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e392:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e395:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e39c:	c1 e0 03             	shl    $0x3,%eax
    e39f:	89 c1                	mov    %eax,%ecx
    e3a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e3a4:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e3a8:	89 c2                	mov    %eax,%edx
    e3aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e3ad:	0f af 45 18          	imul   0x18(%ebp),%eax
    e3b1:	01 d0                	add    %edx,%eax
    e3b3:	01 c8                	add    %ecx,%eax
    e3b5:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e3bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e3be:	8b 14 85 38 a4 01 00 	mov    0x1a438(,%eax,4),%edx
    e3c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e3c8:	8b 04 85 70 a4 01 00 	mov    0x1a470(,%eax,4),%eax
    e3cf:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e3d3:	01 d0                	add    %edx,%eax
    e3d5:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e3d9:	89 c2                	mov    %eax,%edx
    e3db:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e3de:	8b 0c 85 1c a4 01 00 	mov    0x1a41c(,%eax,4),%ecx
    e3e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e3e8:	8b 04 85 54 a4 01 00 	mov    0x1a454(,%eax,4),%eax
    e3ef:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e3f3:	01 c8                	add    %ecx,%eax
    e3f5:	0f af 45 18          	imul   0x18(%ebp),%eax
    e3f9:	01 d0                	add    %edx,%eax
    e3fb:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e401:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e408:	eb 30                	jmp    e43a <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e40a:	ff 75 0c             	pushl  0xc(%ebp)
    e40d:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e413:	50                   	push   %eax
    e414:	e8 1e a1 ff ff       	call   8537 <readBitFromReversedStream>
    e419:	83 c4 08             	add    $0x8,%esp
    e41c:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e41f:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e423:	50                   	push   %eax
    e424:	ff 75 08             	pushl  0x8(%ebp)
    e427:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e42d:	50                   	push   %eax
    e42e:	e8 86 a1 ff ff       	call   85b9 <setBitOfReversedStream>
    e433:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e436:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e43a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e43d:	3b 45 18             	cmp    0x18(%ebp),%eax
    e440:	72 c8                	jb     e40a <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e442:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e446:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e449:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e44d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e450:	0f 87 3c ff ff ff    	ja     e392 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e456:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e45a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e45d:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e461:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e464:	0f 87 1c ff ff ff    	ja     e386 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e46a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e46e:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e472:	0f 85 ea fe ff ff    	jne    e362 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e478:	90                   	nop
    e479:	c9                   	leave  
    e47a:	c3                   	ret    

0000e47b <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e47b:	55                   	push   %ebp
    e47c:	89 e5                	mov    %esp,%ebp
    e47e:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e481:	8b 45 14             	mov    0x14(%ebp),%eax
    e484:	2b 45 10             	sub    0x10(%ebp),%eax
    e487:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e48a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e491:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e498:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e49f:	eb 4a                	jmp    e4eb <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e4a1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e4a8:	eb 2a                	jmp    e4d4 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e4aa:	ff 75 0c             	pushl  0xc(%ebp)
    e4ad:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e4b0:	50                   	push   %eax
    e4b1:	e8 81 a0 ff ff       	call   8537 <readBitFromReversedStream>
    e4b6:	83 c4 08             	add    $0x8,%esp
    e4b9:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e4bc:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e4c0:	50                   	push   %eax
    e4c1:	ff 75 08             	pushl  0x8(%ebp)
    e4c4:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e4c7:	50                   	push   %eax
    e4c8:	e8 ec a0 ff ff       	call   85b9 <setBitOfReversedStream>
    e4cd:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e4d0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e4d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e4d7:	3b 45 10             	cmp    0x10(%ebp),%eax
    e4da:	7c ce                	jl     e4aa <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e4dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e4df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e4e2:	01 d0                	add    %edx,%eax
    e4e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e4e7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e4eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e4ee:	3b 45 18             	cmp    0x18(%ebp),%eax
    e4f1:	72 ae                	jb     e4a1 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e4f3:	90                   	nop
    e4f4:	c9                   	leave  
    e4f5:	c3                   	ret    

0000e4f6 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e4f6:	55                   	push   %ebp
    e4f7:	89 e5                	mov    %esp,%ebp
    e4f9:	57                   	push   %edi
    e4fa:	56                   	push   %esi
    e4fb:	53                   	push   %ebx
    e4fc:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e502:	8b 45 18             	mov    0x18(%ebp),%eax
    e505:	83 c0 0c             	add    $0xc,%eax
    e508:	50                   	push   %eax
    e509:	e8 e6 ac ff ff       	call   91f4 <lodepng_get_bpp>
    e50e:	83 c4 04             	add    $0x4,%esp
    e511:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e514:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e518:	75 0a                	jne    e524 <postProcessScanlines+0x2e>
    e51a:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e51f:	e9 c3 01 00 00       	jmp    e6e7 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e524:	8b 45 18             	mov    0x18(%ebp),%eax
    e527:	8b 40 08             	mov    0x8(%eax),%eax
    e52a:	85 c0                	test   %eax,%eax
    e52c:	0f 85 a8 00 00 00    	jne    e5da <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e532:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e536:	77 76                	ja     e5ae <postProcessScanlines+0xb8>
    e538:	8b 45 10             	mov    0x10(%ebp),%eax
    e53b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e53f:	89 c2                	mov    %eax,%edx
    e541:	8b 45 10             	mov    0x10(%ebp),%eax
    e544:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e548:	83 c0 07             	add    $0x7,%eax
    e54b:	c1 e8 03             	shr    $0x3,%eax
    e54e:	c1 e0 03             	shl    $0x3,%eax
    e551:	39 c2                	cmp    %eax,%edx
    e553:	74 59                	je     e5ae <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e555:	ff 75 ec             	pushl  -0x14(%ebp)
    e558:	ff 75 14             	pushl  0x14(%ebp)
    e55b:	ff 75 10             	pushl  0x10(%ebp)
    e55e:	ff 75 0c             	pushl  0xc(%ebp)
    e561:	ff 75 0c             	pushl  0xc(%ebp)
    e564:	e8 ea fb ff ff       	call   e153 <unfilter>
    e569:	83 c4 14             	add    $0x14,%esp
    e56c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e56f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e573:	74 08                	je     e57d <postProcessScanlines+0x87>
    e575:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e578:	e9 6a 01 00 00       	jmp    e6e7 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e57d:	8b 45 10             	mov    0x10(%ebp),%eax
    e580:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e584:	83 c0 07             	add    $0x7,%eax
    e587:	c1 e8 03             	shr    $0x3,%eax
    e58a:	c1 e0 03             	shl    $0x3,%eax
    e58d:	89 c2                	mov    %eax,%edx
    e58f:	8b 45 10             	mov    0x10(%ebp),%eax
    e592:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e596:	ff 75 14             	pushl  0x14(%ebp)
    e599:	52                   	push   %edx
    e59a:	50                   	push   %eax
    e59b:	ff 75 0c             	pushl  0xc(%ebp)
    e59e:	ff 75 08             	pushl  0x8(%ebp)
    e5a1:	e8 d5 fe ff ff       	call   e47b <removePaddingBits>
    e5a6:	83 c4 14             	add    $0x14,%esp
    e5a9:	e9 34 01 00 00       	jmp    e6e2 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e5ae:	ff 75 ec             	pushl  -0x14(%ebp)
    e5b1:	ff 75 14             	pushl  0x14(%ebp)
    e5b4:	ff 75 10             	pushl  0x10(%ebp)
    e5b7:	ff 75 0c             	pushl  0xc(%ebp)
    e5ba:	ff 75 08             	pushl  0x8(%ebp)
    e5bd:	e8 91 fb ff ff       	call   e153 <unfilter>
    e5c2:	83 c4 14             	add    $0x14,%esp
    e5c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e5c8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e5cc:	0f 84 10 01 00 00    	je     e6e2 <postProcessScanlines+0x1ec>
    e5d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e5d5:	e9 0d 01 00 00       	jmp    e6e7 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e5da:	ff 75 ec             	pushl  -0x14(%ebp)
    e5dd:	ff 75 14             	pushl  0x14(%ebp)
    e5e0:	ff 75 10             	pushl  0x10(%ebp)
    e5e3:	8d 45 88             	lea    -0x78(%ebp),%eax
    e5e6:	50                   	push   %eax
    e5e7:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e5ed:	50                   	push   %eax
    e5ee:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e5f4:	50                   	push   %eax
    e5f5:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e5f8:	50                   	push   %eax
    e5f9:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e5fc:	50                   	push   %eax
    e5fd:	e8 23 ee ff ff       	call   d425 <Adam7_getpassvalues>
    e602:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e605:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e60c:	e9 b0 00 00 00       	jmp    e6c1 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e611:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e614:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e618:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e61b:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e61f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e622:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e629:	89 cb                	mov    %ecx,%ebx
    e62b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e62e:	01 cb                	add    %ecx,%ebx
    e630:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e633:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e63a:	89 ce                	mov    %ecx,%esi
    e63c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e63f:	01 f1                	add    %esi,%ecx
    e641:	ff 75 ec             	pushl  -0x14(%ebp)
    e644:	52                   	push   %edx
    e645:	50                   	push   %eax
    e646:	53                   	push   %ebx
    e647:	51                   	push   %ecx
    e648:	e8 06 fb ff ff       	call   e153 <unfilter>
    e64d:	83 c4 14             	add    $0x14,%esp
    e650:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e653:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e657:	74 08                	je     e661 <postProcessScanlines+0x16b>
    e659:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e65c:	e9 86 00 00 00       	jmp    e6e7 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e661:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e665:	77 56                	ja     e6bd <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e667:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e66a:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e66e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e671:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e675:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e679:	83 c2 07             	add    $0x7,%edx
    e67c:	c1 ea 03             	shr    $0x3,%edx
    e67f:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e682:	89 d6                	mov    %edx,%esi
    e684:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e687:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e68b:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e68f:	89 d3                	mov    %edx,%ebx
    e691:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e694:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e69b:	89 d1                	mov    %edx,%ecx
    e69d:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6a0:	01 d1                	add    %edx,%ecx
    e6a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e6a5:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e6a9:	89 d7                	mov    %edx,%edi
    e6ab:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6ae:	01 fa                	add    %edi,%edx
    e6b0:	50                   	push   %eax
    e6b1:	56                   	push   %esi
    e6b2:	53                   	push   %ebx
    e6b3:	51                   	push   %ecx
    e6b4:	52                   	push   %edx
    e6b5:	e8 c1 fd ff ff       	call   e47b <removePaddingBits>
    e6ba:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e6bd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e6c1:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e6c5:	0f 85 46 ff ff ff    	jne    e611 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e6cb:	ff 75 ec             	pushl  -0x14(%ebp)
    e6ce:	ff 75 14             	pushl  0x14(%ebp)
    e6d1:	ff 75 10             	pushl  0x10(%ebp)
    e6d4:	ff 75 0c             	pushl  0xc(%ebp)
    e6d7:	ff 75 08             	pushl  0x8(%ebp)
    e6da:	e8 2c fb ff ff       	call   e20b <Adam7_deinterlace>
    e6df:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e6e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e6e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e6ea:	5b                   	pop    %ebx
    e6eb:	5e                   	pop    %esi
    e6ec:	5f                   	pop    %edi
    e6ed:	5d                   	pop    %ebp
    e6ee:	c3                   	ret    

0000e6ef <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e6ef:	55                   	push   %ebp
    e6f0:	89 e5                	mov    %esp,%ebp
    e6f2:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e6f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e6fc:	8b 45 10             	mov    0x10(%ebp),%eax
    e6ff:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e704:	f7 e2                	mul    %edx
    e706:	89 d0                	mov    %edx,%eax
    e708:	d1 e8                	shr    %eax
    e70a:	89 c2                	mov    %eax,%edx
    e70c:	8b 45 08             	mov    0x8(%ebp),%eax
    e70f:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e712:	8b 45 08             	mov    0x8(%ebp),%eax
    e715:	8b 40 0c             	mov    0xc(%eax),%eax
    e718:	85 c0                	test   %eax,%eax
    e71a:	74 0d                	je     e729 <readChunk_PLTE+0x3a>
    e71c:	8b 45 08             	mov    0x8(%ebp),%eax
    e71f:	8b 40 0c             	mov    0xc(%eax),%eax
    e722:	3d 00 01 00 00       	cmp    $0x100,%eax
    e727:	7e 0a                	jle    e733 <readChunk_PLTE+0x44>
    e729:	b8 26 00 00 00       	mov    $0x26,%eax
    e72e:	e9 da 00 00 00       	jmp    e80d <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e733:	83 ec 0c             	sub    $0xc,%esp
    e736:	ff 75 08             	pushl  0x8(%ebp)
    e739:	e8 02 a7 ff ff       	call   8e40 <lodepng_color_mode_alloc_palette>
    e73e:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e741:	8b 45 08             	mov    0x8(%ebp),%eax
    e744:	8b 40 08             	mov    0x8(%eax),%eax
    e747:	85 c0                	test   %eax,%eax
    e749:	75 1e                	jne    e769 <readChunk_PLTE+0x7a>
    e74b:	8b 45 08             	mov    0x8(%ebp),%eax
    e74e:	8b 40 0c             	mov    0xc(%eax),%eax
    e751:	85 c0                	test   %eax,%eax
    e753:	74 14                	je     e769 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e755:	8b 45 08             	mov    0x8(%ebp),%eax
    e758:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e75f:	b8 53 00 00 00       	mov    $0x53,%eax
    e764:	e9 a4 00 00 00       	jmp    e80d <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e769:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e770:	e9 84 00 00 00       	jmp    e7f9 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e775:	8b 45 08             	mov    0x8(%ebp),%eax
    e778:	8b 40 08             	mov    0x8(%eax),%eax
    e77b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e77e:	c1 e2 02             	shl    $0x2,%edx
    e781:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e784:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e787:	8d 50 01             	lea    0x1(%eax),%edx
    e78a:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e78d:	8b 55 0c             	mov    0xc(%ebp),%edx
    e790:	01 d0                	add    %edx,%eax
    e792:	0f b6 00             	movzbl (%eax),%eax
    e795:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e797:	8b 45 08             	mov    0x8(%ebp),%eax
    e79a:	8b 40 08             	mov    0x8(%eax),%eax
    e79d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e7a0:	c1 e2 02             	shl    $0x2,%edx
    e7a3:	83 c2 01             	add    $0x1,%edx
    e7a6:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e7a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7ac:	8d 50 01             	lea    0x1(%eax),%edx
    e7af:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e7b2:	8b 55 0c             	mov    0xc(%ebp),%edx
    e7b5:	01 d0                	add    %edx,%eax
    e7b7:	0f b6 00             	movzbl (%eax),%eax
    e7ba:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e7bc:	8b 45 08             	mov    0x8(%ebp),%eax
    e7bf:	8b 40 08             	mov    0x8(%eax),%eax
    e7c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e7c5:	c1 e2 02             	shl    $0x2,%edx
    e7c8:	83 c2 02             	add    $0x2,%edx
    e7cb:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e7ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7d1:	8d 50 01             	lea    0x1(%eax),%edx
    e7d4:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e7d7:	8b 55 0c             	mov    0xc(%ebp),%edx
    e7da:	01 d0                	add    %edx,%eax
    e7dc:	0f b6 00             	movzbl (%eax),%eax
    e7df:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e7e1:	8b 45 08             	mov    0x8(%ebp),%eax
    e7e4:	8b 40 08             	mov    0x8(%eax),%eax
    e7e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e7ea:	c1 e2 02             	shl    $0x2,%edx
    e7ed:	83 c2 03             	add    $0x3,%edx
    e7f0:	01 d0                	add    %edx,%eax
    e7f2:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e7f5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e7f9:	8b 45 08             	mov    0x8(%ebp),%eax
    e7fc:	8b 40 0c             	mov    0xc(%eax),%eax
    e7ff:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e802:	0f 85 6d ff ff ff    	jne    e775 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e808:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e80d:	c9                   	leave  
    e80e:	c3                   	ret    

0000e80f <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e80f:	55                   	push   %ebp
    e810:	89 e5                	mov    %esp,%ebp
    e812:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e815:	8b 45 08             	mov    0x8(%ebp),%eax
    e818:	8b 00                	mov    (%eax),%eax
    e81a:	83 f8 03             	cmp    $0x3,%eax
    e81d:	75 4d                	jne    e86c <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e81f:	8b 45 08             	mov    0x8(%ebp),%eax
    e822:	8b 40 0c             	mov    0xc(%eax),%eax
    e825:	3b 45 10             	cmp    0x10(%ebp),%eax
    e828:	7d 0a                	jge    e834 <readChunk_tRNS+0x25>
    e82a:	b8 27 00 00 00       	mov    $0x27,%eax
    e82f:	e9 3c 01 00 00       	jmp    e970 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e834:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e83b:	eb 22                	jmp    e85f <readChunk_tRNS+0x50>
    e83d:	8b 45 08             	mov    0x8(%ebp),%eax
    e840:	8b 40 08             	mov    0x8(%eax),%eax
    e843:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e846:	c1 e2 02             	shl    $0x2,%edx
    e849:	83 c2 03             	add    $0x3,%edx
    e84c:	01 c2                	add    %eax,%edx
    e84e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e851:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e854:	01 c8                	add    %ecx,%eax
    e856:	0f b6 00             	movzbl (%eax),%eax
    e859:	88 02                	mov    %al,(%edx)
    e85b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e85f:	8b 45 10             	mov    0x10(%ebp),%eax
    e862:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e865:	75 d6                	jne    e83d <readChunk_tRNS+0x2e>
    e867:	e9 ff 00 00 00       	jmp    e96b <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e86c:	8b 45 08             	mov    0x8(%ebp),%eax
    e86f:	8b 00                	mov    (%eax),%eax
    e871:	85 c0                	test   %eax,%eax
    e873:	75 59                	jne    e8ce <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e875:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e879:	74 0a                	je     e885 <readChunk_tRNS+0x76>
    e87b:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e880:	e9 eb 00 00 00       	jmp    e970 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e885:	8b 45 08             	mov    0x8(%ebp),%eax
    e888:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e88f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e892:	0f b6 00             	movzbl (%eax),%eax
    e895:	0f b6 c0             	movzbl %al,%eax
    e898:	c1 e0 08             	shl    $0x8,%eax
    e89b:	89 c2                	mov    %eax,%edx
    e89d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8a0:	83 c0 01             	add    $0x1,%eax
    e8a3:	0f b6 00             	movzbl (%eax),%eax
    e8a6:	0f b6 c0             	movzbl %al,%eax
    e8a9:	01 c2                	add    %eax,%edx
    e8ab:	8b 45 08             	mov    0x8(%ebp),%eax
    e8ae:	89 50 1c             	mov    %edx,0x1c(%eax)
    e8b1:	8b 45 08             	mov    0x8(%ebp),%eax
    e8b4:	8b 50 1c             	mov    0x1c(%eax),%edx
    e8b7:	8b 45 08             	mov    0x8(%ebp),%eax
    e8ba:	89 50 18             	mov    %edx,0x18(%eax)
    e8bd:	8b 45 08             	mov    0x8(%ebp),%eax
    e8c0:	8b 50 18             	mov    0x18(%eax),%edx
    e8c3:	8b 45 08             	mov    0x8(%ebp),%eax
    e8c6:	89 50 14             	mov    %edx,0x14(%eax)
    e8c9:	e9 9d 00 00 00       	jmp    e96b <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e8ce:	8b 45 08             	mov    0x8(%ebp),%eax
    e8d1:	8b 00                	mov    (%eax),%eax
    e8d3:	83 f8 02             	cmp    $0x2,%eax
    e8d6:	0f 85 88 00 00 00    	jne    e964 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e8dc:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e8e0:	74 0a                	je     e8ec <readChunk_tRNS+0xdd>
    e8e2:	b8 29 00 00 00       	mov    $0x29,%eax
    e8e7:	e9 84 00 00 00       	jmp    e970 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e8ec:	8b 45 08             	mov    0x8(%ebp),%eax
    e8ef:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e8f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8f9:	0f b6 00             	movzbl (%eax),%eax
    e8fc:	0f b6 c0             	movzbl %al,%eax
    e8ff:	c1 e0 08             	shl    $0x8,%eax
    e902:	89 c2                	mov    %eax,%edx
    e904:	8b 45 0c             	mov    0xc(%ebp),%eax
    e907:	83 c0 01             	add    $0x1,%eax
    e90a:	0f b6 00             	movzbl (%eax),%eax
    e90d:	0f b6 c0             	movzbl %al,%eax
    e910:	01 c2                	add    %eax,%edx
    e912:	8b 45 08             	mov    0x8(%ebp),%eax
    e915:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e918:	8b 45 0c             	mov    0xc(%ebp),%eax
    e91b:	83 c0 02             	add    $0x2,%eax
    e91e:	0f b6 00             	movzbl (%eax),%eax
    e921:	0f b6 c0             	movzbl %al,%eax
    e924:	c1 e0 08             	shl    $0x8,%eax
    e927:	89 c2                	mov    %eax,%edx
    e929:	8b 45 0c             	mov    0xc(%ebp),%eax
    e92c:	83 c0 03             	add    $0x3,%eax
    e92f:	0f b6 00             	movzbl (%eax),%eax
    e932:	0f b6 c0             	movzbl %al,%eax
    e935:	01 c2                	add    %eax,%edx
    e937:	8b 45 08             	mov    0x8(%ebp),%eax
    e93a:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e93d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e940:	83 c0 04             	add    $0x4,%eax
    e943:	0f b6 00             	movzbl (%eax),%eax
    e946:	0f b6 c0             	movzbl %al,%eax
    e949:	c1 e0 08             	shl    $0x8,%eax
    e94c:	89 c2                	mov    %eax,%edx
    e94e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e951:	83 c0 05             	add    $0x5,%eax
    e954:	0f b6 00             	movzbl (%eax),%eax
    e957:	0f b6 c0             	movzbl %al,%eax
    e95a:	01 c2                	add    %eax,%edx
    e95c:	8b 45 08             	mov    0x8(%ebp),%eax
    e95f:	89 50 1c             	mov    %edx,0x1c(%eax)
    e962:	eb 07                	jmp    e96b <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e964:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e969:	eb 05                	jmp    e970 <readChunk_tRNS+0x161>

  return 0; /* OK */
    e96b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e970:	c9                   	leave  
    e971:	c3                   	ret    

0000e972 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e972:	55                   	push   %ebp
    e973:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e975:	8b 45 08             	mov    0x8(%ebp),%eax
    e978:	8b 40 0c             	mov    0xc(%eax),%eax
    e97b:	83 f8 03             	cmp    $0x3,%eax
    e97e:	75 63                	jne    e9e3 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e980:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e984:	74 0a                	je     e990 <readChunk_bKGD+0x1e>
    e986:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e98b:	e9 63 01 00 00       	jmp    eaf3 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e990:	8b 45 0c             	mov    0xc(%ebp),%eax
    e993:	0f b6 00             	movzbl (%eax),%eax
    e996:	0f b6 d0             	movzbl %al,%edx
    e999:	8b 45 08             	mov    0x8(%ebp),%eax
    e99c:	8b 40 18             	mov    0x18(%eax),%eax
    e99f:	39 c2                	cmp    %eax,%edx
    e9a1:	7c 0a                	jl     e9ad <readChunk_bKGD+0x3b>
    e9a3:	b8 67 00 00 00       	mov    $0x67,%eax
    e9a8:	e9 46 01 00 00       	jmp    eaf3 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e9ad:	8b 45 08             	mov    0x8(%ebp),%eax
    e9b0:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e9b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9ba:	0f b6 00             	movzbl (%eax),%eax
    e9bd:	0f b6 d0             	movzbl %al,%edx
    e9c0:	8b 45 08             	mov    0x8(%ebp),%eax
    e9c3:	89 50 38             	mov    %edx,0x38(%eax)
    e9c6:	8b 45 08             	mov    0x8(%ebp),%eax
    e9c9:	8b 50 38             	mov    0x38(%eax),%edx
    e9cc:	8b 45 08             	mov    0x8(%ebp),%eax
    e9cf:	89 50 34             	mov    %edx,0x34(%eax)
    e9d2:	8b 45 08             	mov    0x8(%ebp),%eax
    e9d5:	8b 50 34             	mov    0x34(%eax),%edx
    e9d8:	8b 45 08             	mov    0x8(%ebp),%eax
    e9db:	89 50 30             	mov    %edx,0x30(%eax)
    e9de:	e9 0b 01 00 00       	jmp    eaee <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e9e3:	8b 45 08             	mov    0x8(%ebp),%eax
    e9e6:	8b 40 0c             	mov    0xc(%eax),%eax
    e9e9:	85 c0                	test   %eax,%eax
    e9eb:	74 0b                	je     e9f8 <readChunk_bKGD+0x86>
    e9ed:	8b 45 08             	mov    0x8(%ebp),%eax
    e9f0:	8b 40 0c             	mov    0xc(%eax),%eax
    e9f3:	83 f8 04             	cmp    $0x4,%eax
    e9f6:	75 59                	jne    ea51 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e9f8:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e9fc:	74 0a                	je     ea08 <readChunk_bKGD+0x96>
    e9fe:	b8 2c 00 00 00       	mov    $0x2c,%eax
    ea03:	e9 eb 00 00 00       	jmp    eaf3 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    ea08:	8b 45 08             	mov    0x8(%ebp),%eax
    ea0b:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    ea12:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea15:	0f b6 00             	movzbl (%eax),%eax
    ea18:	0f b6 c0             	movzbl %al,%eax
    ea1b:	c1 e0 08             	shl    $0x8,%eax
    ea1e:	89 c2                	mov    %eax,%edx
    ea20:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea23:	83 c0 01             	add    $0x1,%eax
    ea26:	0f b6 00             	movzbl (%eax),%eax
    ea29:	0f b6 c0             	movzbl %al,%eax
    ea2c:	01 c2                	add    %eax,%edx
    ea2e:	8b 45 08             	mov    0x8(%ebp),%eax
    ea31:	89 50 38             	mov    %edx,0x38(%eax)
    ea34:	8b 45 08             	mov    0x8(%ebp),%eax
    ea37:	8b 50 38             	mov    0x38(%eax),%edx
    ea3a:	8b 45 08             	mov    0x8(%ebp),%eax
    ea3d:	89 50 34             	mov    %edx,0x34(%eax)
    ea40:	8b 45 08             	mov    0x8(%ebp),%eax
    ea43:	8b 50 34             	mov    0x34(%eax),%edx
    ea46:	8b 45 08             	mov    0x8(%ebp),%eax
    ea49:	89 50 30             	mov    %edx,0x30(%eax)
    ea4c:	e9 9d 00 00 00       	jmp    eaee <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    ea51:	8b 45 08             	mov    0x8(%ebp),%eax
    ea54:	8b 40 0c             	mov    0xc(%eax),%eax
    ea57:	83 f8 02             	cmp    $0x2,%eax
    ea5a:	74 0f                	je     ea6b <readChunk_bKGD+0xf9>
    ea5c:	8b 45 08             	mov    0x8(%ebp),%eax
    ea5f:	8b 40 0c             	mov    0xc(%eax),%eax
    ea62:	83 f8 06             	cmp    $0x6,%eax
    ea65:	0f 85 83 00 00 00    	jne    eaee <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    ea6b:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    ea6f:	74 07                	je     ea78 <readChunk_bKGD+0x106>
    ea71:	b8 2d 00 00 00       	mov    $0x2d,%eax
    ea76:	eb 7b                	jmp    eaf3 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    ea78:	8b 45 08             	mov    0x8(%ebp),%eax
    ea7b:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    ea82:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea85:	0f b6 00             	movzbl (%eax),%eax
    ea88:	0f b6 c0             	movzbl %al,%eax
    ea8b:	c1 e0 08             	shl    $0x8,%eax
    ea8e:	89 c2                	mov    %eax,%edx
    ea90:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea93:	83 c0 01             	add    $0x1,%eax
    ea96:	0f b6 00             	movzbl (%eax),%eax
    ea99:	0f b6 c0             	movzbl %al,%eax
    ea9c:	01 c2                	add    %eax,%edx
    ea9e:	8b 45 08             	mov    0x8(%ebp),%eax
    eaa1:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    eaa4:	8b 45 0c             	mov    0xc(%ebp),%eax
    eaa7:	83 c0 02             	add    $0x2,%eax
    eaaa:	0f b6 00             	movzbl (%eax),%eax
    eaad:	0f b6 c0             	movzbl %al,%eax
    eab0:	c1 e0 08             	shl    $0x8,%eax
    eab3:	89 c2                	mov    %eax,%edx
    eab5:	8b 45 0c             	mov    0xc(%ebp),%eax
    eab8:	83 c0 03             	add    $0x3,%eax
    eabb:	0f b6 00             	movzbl (%eax),%eax
    eabe:	0f b6 c0             	movzbl %al,%eax
    eac1:	01 c2                	add    %eax,%edx
    eac3:	8b 45 08             	mov    0x8(%ebp),%eax
    eac6:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    eac9:	8b 45 0c             	mov    0xc(%ebp),%eax
    eacc:	83 c0 04             	add    $0x4,%eax
    eacf:	0f b6 00             	movzbl (%eax),%eax
    ead2:	0f b6 c0             	movzbl %al,%eax
    ead5:	c1 e0 08             	shl    $0x8,%eax
    ead8:	89 c2                	mov    %eax,%edx
    eada:	8b 45 0c             	mov    0xc(%ebp),%eax
    eadd:	83 c0 05             	add    $0x5,%eax
    eae0:	0f b6 00             	movzbl (%eax),%eax
    eae3:	0f b6 c0             	movzbl %al,%eax
    eae6:	01 c2                	add    %eax,%edx
    eae8:	8b 45 08             	mov    0x8(%ebp),%eax
    eaeb:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    eaee:	b8 00 00 00 00       	mov    $0x0,%eax
}
    eaf3:	5d                   	pop    %ebp
    eaf4:	c3                   	ret    

0000eaf5 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    eaf5:	55                   	push   %ebp
    eaf6:	89 e5                	mov    %esp,%ebp
    eaf8:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    eafb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    eb02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    eb09:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    eb10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eb14:	0f 85 06 01 00 00    	jne    ec20 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    eb1a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    eb21:	eb 04                	jmp    eb27 <readChunk_tEXt+0x32>
    eb23:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    eb27:	8b 45 10             	mov    0x10(%ebp),%eax
    eb2a:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    eb2d:	73 0f                	jae    eb3e <readChunk_tEXt+0x49>
    eb2f:	8b 55 0c             	mov    0xc(%ebp),%edx
    eb32:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb35:	01 d0                	add    %edx,%eax
    eb37:	0f b6 00             	movzbl (%eax),%eax
    eb3a:	84 c0                	test   %al,%al
    eb3c:	75 e5                	jne    eb23 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eb3e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    eb42:	74 06                	je     eb4a <readChunk_tEXt+0x55>
    eb44:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    eb48:	76 0c                	jbe    eb56 <readChunk_tEXt+0x61>
    eb4a:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eb51:	e9 ca 00 00 00       	jmp    ec20 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    eb56:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb59:	83 c0 01             	add    $0x1,%eax
    eb5c:	83 ec 0c             	sub    $0xc,%esp
    eb5f:	50                   	push   %eax
    eb60:	e8 73 4b ff ff       	call   36d8 <lodepng_malloc>
    eb65:	83 c4 10             	add    $0x10,%esp
    eb68:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eb6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    eb6f:	75 0c                	jne    eb7d <readChunk_tEXt+0x88>
    eb71:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eb78:	e9 a3 00 00 00       	jmp    ec20 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    eb7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb80:	83 ec 04             	sub    $0x4,%esp
    eb83:	50                   	push   %eax
    eb84:	ff 75 0c             	pushl  0xc(%ebp)
    eb87:	ff 75 f0             	pushl  -0x10(%ebp)
    eb8a:	e8 87 4b ff ff       	call   3716 <lodepng_memcpy>
    eb8f:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eb92:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eb95:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb98:	01 d0                	add    %edx,%eax
    eb9a:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    eb9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eba0:	83 c0 01             	add    $0x1,%eax
    eba3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    eba6:	8b 45 10             	mov    0x10(%ebp),%eax
    eba9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    ebac:	72 08                	jb     ebb6 <readChunk_tEXt+0xc1>
    ebae:	8b 45 10             	mov    0x10(%ebp),%eax
    ebb1:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    ebb4:	eb 05                	jmp    ebbb <readChunk_tEXt+0xc6>
    ebb6:	b8 00 00 00 00       	mov    $0x0,%eax
    ebbb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    ebbe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ebc1:	83 c0 01             	add    $0x1,%eax
    ebc4:	83 ec 0c             	sub    $0xc,%esp
    ebc7:	50                   	push   %eax
    ebc8:	e8 0b 4b ff ff       	call   36d8 <lodepng_malloc>
    ebcd:	83 c4 10             	add    $0x10,%esp
    ebd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    ebd3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ebd7:	75 09                	jne    ebe2 <readChunk_tEXt+0xed>
    ebd9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ebe0:	eb 3e                	jmp    ec20 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    ebe2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ebe5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    ebe8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ebeb:	01 ca                	add    %ecx,%edx
    ebed:	83 ec 04             	sub    $0x4,%esp
    ebf0:	50                   	push   %eax
    ebf1:	52                   	push   %edx
    ebf2:	ff 75 ec             	pushl  -0x14(%ebp)
    ebf5:	e8 1c 4b ff ff       	call   3716 <lodepng_memcpy>
    ebfa:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    ebfd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec00:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ec03:	01 d0                	add    %edx,%eax
    ec05:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    ec08:	83 ec 04             	sub    $0x4,%esp
    ec0b:	ff 75 ec             	pushl  -0x14(%ebp)
    ec0e:	ff 75 f0             	pushl  -0x10(%ebp)
    ec11:	ff 75 08             	pushl  0x8(%ebp)
    ec14:	e8 3f ac ff ff       	call   9858 <lodepng_add_text>
    ec19:	83 c4 10             	add    $0x10,%esp
    ec1c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    ec1f:	90                   	nop
  }

  lodepng_free(key);
    ec20:	83 ec 0c             	sub    $0xc,%esp
    ec23:	ff 75 f0             	pushl  -0x10(%ebp)
    ec26:	e8 ce 4a ff ff       	call   36f9 <lodepng_free>
    ec2b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ec2e:	83 ec 0c             	sub    $0xc,%esp
    ec31:	ff 75 ec             	pushl  -0x14(%ebp)
    ec34:	e8 c0 4a ff ff       	call   36f9 <lodepng_free>
    ec39:	83 c4 10             	add    $0x10,%esp

  return error;
    ec3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ec3f:	c9                   	leave  
    ec40:	c3                   	ret    

0000ec41 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ec41:	55                   	push   %ebp
    ec42:	89 e5                	mov    %esp,%ebp
    ec44:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    ec47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ec4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec51:	8b 10                	mov    (%eax),%edx
    ec53:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ec56:	8b 50 04             	mov    0x4(%eax),%edx
    ec59:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    ec5c:	8b 50 08             	mov    0x8(%eax),%edx
    ec5f:	89 55 d8             	mov    %edx,-0x28(%ebp)
    ec62:	8b 50 0c             	mov    0xc(%eax),%edx
    ec65:	89 55 dc             	mov    %edx,-0x24(%ebp)
    ec68:	8b 50 10             	mov    0x10(%eax),%edx
    ec6b:	89 55 e0             	mov    %edx,-0x20(%ebp)
    ec6e:	8b 40 14             	mov    0x14(%eax),%eax
    ec71:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    ec74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    ec7b:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    ec82:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ec89:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ec8d:	0f 85 48 01 00 00    	jne    eddb <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ec93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ec9a:	eb 04                	jmp    eca0 <readChunk_zTXt+0x5f>
    ec9c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eca0:	8b 45 14             	mov    0x14(%ebp),%eax
    eca3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eca6:	73 0f                	jae    ecb7 <readChunk_zTXt+0x76>
    eca8:	8b 55 10             	mov    0x10(%ebp),%edx
    ecab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ecae:	01 d0                	add    %edx,%eax
    ecb0:	0f b6 00             	movzbl (%eax),%eax
    ecb3:	84 c0                	test   %al,%al
    ecb5:	75 e5                	jne    ec9c <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ecb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ecba:	8d 50 02             	lea    0x2(%eax),%edx
    ecbd:	8b 45 14             	mov    0x14(%ebp),%eax
    ecc0:	39 c2                	cmp    %eax,%edx
    ecc2:	72 0c                	jb     ecd0 <readChunk_zTXt+0x8f>
    ecc4:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    eccb:	e9 0b 01 00 00       	jmp    eddb <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ecd0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ecd4:	74 06                	je     ecdc <readChunk_zTXt+0x9b>
    ecd6:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    ecda:	76 0c                	jbe    ece8 <readChunk_zTXt+0xa7>
    ecdc:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ece3:	e9 f3 00 00 00       	jmp    eddb <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    ece8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eceb:	83 c0 01             	add    $0x1,%eax
    ecee:	83 ec 0c             	sub    $0xc,%esp
    ecf1:	50                   	push   %eax
    ecf2:	e8 e1 49 ff ff       	call   36d8 <lodepng_malloc>
    ecf7:	83 c4 10             	add    $0x10,%esp
    ecfa:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ecfd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ed01:	75 0c                	jne    ed0f <readChunk_zTXt+0xce>
    ed03:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ed0a:	e9 cc 00 00 00       	jmp    eddb <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    ed0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ed12:	83 ec 04             	sub    $0x4,%esp
    ed15:	50                   	push   %eax
    ed16:	ff 75 10             	pushl  0x10(%ebp)
    ed19:	ff 75 ec             	pushl  -0x14(%ebp)
    ed1c:	e8 f5 49 ff ff       	call   3716 <lodepng_memcpy>
    ed21:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ed24:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ed27:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ed2a:	01 d0                	add    %edx,%eax
    ed2c:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ed2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ed32:	8d 50 01             	lea    0x1(%eax),%edx
    ed35:	8b 45 10             	mov    0x10(%ebp),%eax
    ed38:	01 d0                	add    %edx,%eax
    ed3a:	0f b6 00             	movzbl (%eax),%eax
    ed3d:	84 c0                	test   %al,%al
    ed3f:	74 0c                	je     ed4d <readChunk_zTXt+0x10c>
    ed41:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ed48:	e9 8e 00 00 00       	jmp    eddb <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    ed4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ed50:	83 c0 02             	add    $0x2,%eax
    ed53:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ed56:	8b 45 14             	mov    0x14(%ebp),%eax
    ed59:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ed5c:	76 09                	jbe    ed67 <readChunk_zTXt+0x126>
    ed5e:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ed65:	eb 74                	jmp    eddb <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    ed67:	8b 45 14             	mov    0x14(%ebp),%eax
    ed6a:	2b 45 e8             	sub    -0x18(%ebp),%eax
    ed6d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    ed70:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed73:	8b 40 30             	mov    0x30(%eax),%eax
    ed76:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    ed79:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ed7c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed7f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ed82:	01 d1                	add    %edx,%ecx
    ed84:	83 ec 08             	sub    $0x8,%esp
    ed87:	8d 55 d0             	lea    -0x30(%ebp),%edx
    ed8a:	52                   	push   %edx
    ed8b:	50                   	push   %eax
    ed8c:	51                   	push   %ecx
    ed8d:	6a 00                	push   $0x0
    ed8f:	8d 45 c8             	lea    -0x38(%ebp),%eax
    ed92:	50                   	push   %eax
    ed93:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ed96:	50                   	push   %eax
    ed97:	e8 f7 93 ff ff       	call   8193 <zlib_decompress>
    ed9c:	83 c4 20             	add    $0x20,%esp
    ed9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    eda2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eda6:	74 11                	je     edb9 <readChunk_zTXt+0x178>
    eda8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    edab:	8b 45 c8             	mov    -0x38(%ebp),%eax
    edae:	39 c2                	cmp    %eax,%edx
    edb0:	7d 07                	jge    edb9 <readChunk_zTXt+0x178>
    edb2:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    edb9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    edbd:	75 1b                	jne    edda <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    edbf:	8b 55 c8             	mov    -0x38(%ebp),%edx
    edc2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    edc5:	52                   	push   %edx
    edc6:	50                   	push   %eax
    edc7:	ff 75 ec             	pushl  -0x14(%ebp)
    edca:	ff 75 08             	pushl  0x8(%ebp)
    edcd:	e8 60 a9 ff ff       	call   9732 <lodepng_add_text_sized>
    edd2:	83 c4 10             	add    $0x10,%esp
    edd5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    edd8:	eb 01                	jmp    eddb <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    edda:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    eddb:	83 ec 0c             	sub    $0xc,%esp
    edde:	ff 75 ec             	pushl  -0x14(%ebp)
    ede1:	e8 13 49 ff ff       	call   36f9 <lodepng_free>
    ede6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ede9:	8b 45 cc             	mov    -0x34(%ebp),%eax
    edec:	83 ec 0c             	sub    $0xc,%esp
    edef:	50                   	push   %eax
    edf0:	e8 04 49 ff ff       	call   36f9 <lodepng_free>
    edf5:	83 c4 10             	add    $0x10,%esp

  return error;
    edf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    edfb:	c9                   	leave  
    edfc:	c3                   	ret    

0000edfd <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    edfd:	55                   	push   %ebp
    edfe:	89 e5                	mov    %esp,%ebp
    ee00:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    ee03:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ee0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee0d:	8b 10                	mov    (%eax),%edx
    ee0f:	89 55 c0             	mov    %edx,-0x40(%ebp)
    ee12:	8b 50 04             	mov    0x4(%eax),%edx
    ee15:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ee18:	8b 50 08             	mov    0x8(%eax),%edx
    ee1b:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ee1e:	8b 50 0c             	mov    0xc(%eax),%edx
    ee21:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ee24:	8b 50 10             	mov    0x10(%eax),%edx
    ee27:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ee2a:	8b 40 14             	mov    0x14(%eax),%eax
    ee2d:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ee30:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ee37:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ee3e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ee45:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ee49:	0f 85 d5 02 00 00    	jne    f124 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    ee4f:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    ee53:	7f 0c                	jg     ee61 <readChunk_iTXt+0x64>
    ee55:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    ee5c:	e9 c3 02 00 00       	jmp    f124 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ee61:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ee68:	eb 04                	jmp    ee6e <readChunk_iTXt+0x71>
    ee6a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ee6e:	8b 45 14             	mov    0x14(%ebp),%eax
    ee71:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    ee74:	73 0f                	jae    ee85 <readChunk_iTXt+0x88>
    ee76:	8b 55 10             	mov    0x10(%ebp),%edx
    ee79:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee7c:	01 d0                	add    %edx,%eax
    ee7e:	0f b6 00             	movzbl (%eax),%eax
    ee81:	84 c0                	test   %al,%al
    ee83:	75 e5                	jne    ee6a <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    ee85:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee88:	8d 50 03             	lea    0x3(%eax),%edx
    ee8b:	8b 45 14             	mov    0x14(%ebp),%eax
    ee8e:	39 c2                	cmp    %eax,%edx
    ee90:	72 0c                	jb     ee9e <readChunk_iTXt+0xa1>
    ee92:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ee99:	e9 86 02 00 00       	jmp    f124 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ee9e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eea2:	74 06                	je     eeaa <readChunk_iTXt+0xad>
    eea4:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    eea8:	76 0c                	jbe    eeb6 <readChunk_iTXt+0xb9>
    eeaa:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eeb1:	e9 6e 02 00 00       	jmp    f124 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    eeb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eeb9:	83 c0 01             	add    $0x1,%eax
    eebc:	83 ec 0c             	sub    $0xc,%esp
    eebf:	50                   	push   %eax
    eec0:	e8 13 48 ff ff       	call   36d8 <lodepng_malloc>
    eec5:	83 c4 10             	add    $0x10,%esp
    eec8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eecb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    eecf:	75 0c                	jne    eedd <readChunk_iTXt+0xe0>
    eed1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eed8:	e9 47 02 00 00       	jmp    f124 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    eedd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eee0:	83 ec 04             	sub    $0x4,%esp
    eee3:	50                   	push   %eax
    eee4:	ff 75 10             	pushl  0x10(%ebp)
    eee7:	ff 75 e8             	pushl  -0x18(%ebp)
    eeea:	e8 27 48 ff ff       	call   3716 <lodepng_memcpy>
    eeef:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eef2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eef5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eef8:	01 d0                	add    %edx,%eax
    eefa:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    eefd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef00:	8d 50 01             	lea    0x1(%eax),%edx
    ef03:	8b 45 10             	mov    0x10(%ebp),%eax
    ef06:	01 d0                	add    %edx,%eax
    ef08:	0f b6 00             	movzbl (%eax),%eax
    ef0b:	0f b6 c0             	movzbl %al,%eax
    ef0e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ef11:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef14:	8d 50 02             	lea    0x2(%eax),%edx
    ef17:	8b 45 10             	mov    0x10(%ebp),%eax
    ef1a:	01 d0                	add    %edx,%eax
    ef1c:	0f b6 00             	movzbl (%eax),%eax
    ef1f:	84 c0                	test   %al,%al
    ef21:	74 0c                	je     ef2f <readChunk_iTXt+0x132>
    ef23:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ef2a:	e9 f5 01 00 00       	jmp    f124 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    ef2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef32:	83 c0 03             	add    $0x3,%eax
    ef35:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ef38:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ef3f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ef42:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ef45:	eb 08                	jmp    ef4f <readChunk_iTXt+0x152>
    ef47:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ef4b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ef4f:	8b 45 14             	mov    0x14(%ebp),%eax
    ef52:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ef55:	73 0f                	jae    ef66 <readChunk_iTXt+0x169>
    ef57:	8b 55 10             	mov    0x10(%ebp),%edx
    ef5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ef5d:	01 d0                	add    %edx,%eax
    ef5f:	0f b6 00             	movzbl (%eax),%eax
    ef62:	84 c0                	test   %al,%al
    ef64:	75 e1                	jne    ef47 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ef66:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef69:	83 c0 01             	add    $0x1,%eax
    ef6c:	83 ec 0c             	sub    $0xc,%esp
    ef6f:	50                   	push   %eax
    ef70:	e8 63 47 ff ff       	call   36d8 <lodepng_malloc>
    ef75:	83 c4 10             	add    $0x10,%esp
    ef78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ef7b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ef7f:	75 0c                	jne    ef8d <readChunk_iTXt+0x190>
    ef81:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ef88:	e9 97 01 00 00       	jmp    f124 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ef8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef90:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ef93:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ef96:	01 ca                	add    %ecx,%edx
    ef98:	83 ec 04             	sub    $0x4,%esp
    ef9b:	50                   	push   %eax
    ef9c:	52                   	push   %edx
    ef9d:	ff 75 e4             	pushl  -0x1c(%ebp)
    efa0:	e8 71 47 ff ff       	call   3716 <lodepng_memcpy>
    efa5:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    efa8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    efab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    efae:	01 d0                	add    %edx,%eax
    efb0:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    efb3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    efb6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    efb9:	01 d0                	add    %edx,%eax
    efbb:	83 c0 01             	add    $0x1,%eax
    efbe:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    efc1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    efc8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    efcb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    efce:	eb 08                	jmp    efd8 <readChunk_iTXt+0x1db>
    efd0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    efd4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    efd8:	8b 45 14             	mov    0x14(%ebp),%eax
    efdb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    efde:	73 0f                	jae    efef <readChunk_iTXt+0x1f2>
    efe0:	8b 55 10             	mov    0x10(%ebp),%edx
    efe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    efe6:	01 d0                	add    %edx,%eax
    efe8:	0f b6 00             	movzbl (%eax),%eax
    efeb:	84 c0                	test   %al,%al
    efed:	75 e1                	jne    efd0 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    efef:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eff2:	83 c0 01             	add    $0x1,%eax
    eff5:	83 ec 0c             	sub    $0xc,%esp
    eff8:	50                   	push   %eax
    eff9:	e8 da 46 ff ff       	call   36d8 <lodepng_malloc>
    effe:	83 c4 10             	add    $0x10,%esp
    f001:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    f004:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    f008:	75 0c                	jne    f016 <readChunk_iTXt+0x219>
    f00a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    f011:	e9 0e 01 00 00       	jmp    f124 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    f016:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f019:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f01c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f01f:	01 ca                	add    %ecx,%edx
    f021:	83 ec 04             	sub    $0x4,%esp
    f024:	50                   	push   %eax
    f025:	52                   	push   %edx
    f026:	ff 75 e0             	pushl  -0x20(%ebp)
    f029:	e8 e8 46 ff ff       	call   3716 <lodepng_memcpy>
    f02e:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    f031:	8b 55 e0             	mov    -0x20(%ebp),%edx
    f034:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f037:	01 d0                	add    %edx,%eax
    f039:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    f03c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f03f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    f042:	01 d0                	add    %edx,%eax
    f044:	83 c0 01             	add    $0x1,%eax
    f047:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    f04a:	8b 45 14             	mov    0x14(%ebp),%eax
    f04d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    f050:	72 08                	jb     f05a <readChunk_iTXt+0x25d>
    f052:	8b 45 14             	mov    0x14(%ebp),%eax
    f055:	2b 45 d8             	sub    -0x28(%ebp),%eax
    f058:	eb 05                	jmp    f05f <readChunk_iTXt+0x262>
    f05a:	b8 00 00 00 00       	mov    $0x0,%eax
    f05f:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    f062:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    f066:	0f 84 90 00 00 00    	je     f0fc <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    f06c:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    f073:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    f07a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f07d:	8b 40 30             	mov    0x30(%eax),%eax
    f080:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    f083:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f086:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f089:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f08c:	01 d1                	add    %edx,%ecx
    f08e:	83 ec 08             	sub    $0x8,%esp
    f091:	8d 55 c0             	lea    -0x40(%ebp),%edx
    f094:	52                   	push   %edx
    f095:	50                   	push   %eax
    f096:	51                   	push   %ecx
    f097:	6a 00                	push   $0x0
    f099:	8d 45 b8             	lea    -0x48(%ebp),%eax
    f09c:	50                   	push   %eax
    f09d:	8d 45 bc             	lea    -0x44(%ebp),%eax
    f0a0:	50                   	push   %eax
    f0a1:	e8 ed 90 ff ff       	call   8193 <zlib_decompress>
    f0a6:	83 c4 20             	add    $0x20,%esp
    f0a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    f0ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f0b0:	74 11                	je     f0c3 <readChunk_iTXt+0x2c6>
    f0b2:	8b 55 c8             	mov    -0x38(%ebp),%edx
    f0b5:	8b 45 b8             	mov    -0x48(%ebp),%eax
    f0b8:	39 c2                	cmp    %eax,%edx
    f0ba:	7d 07                	jge    f0c3 <readChunk_iTXt+0x2c6>
    f0bc:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    f0c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f0c7:	75 22                	jne    f0eb <readChunk_iTXt+0x2ee>
    f0c9:	8b 55 b8             	mov    -0x48(%ebp),%edx
    f0cc:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f0cf:	83 ec 08             	sub    $0x8,%esp
    f0d2:	52                   	push   %edx
    f0d3:	50                   	push   %eax
    f0d4:	ff 75 e0             	pushl  -0x20(%ebp)
    f0d7:	ff 75 e4             	pushl  -0x1c(%ebp)
    f0da:	ff 75 e8             	pushl  -0x18(%ebp)
    f0dd:	ff 75 08             	pushl  0x8(%ebp)
    f0e0:	e8 94 a9 ff ff       	call   9a79 <lodepng_add_itext_sized>
    f0e5:	83 c4 20             	add    $0x20,%esp
    f0e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    f0eb:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f0ee:	83 ec 0c             	sub    $0xc,%esp
    f0f1:	50                   	push   %eax
    f0f2:	e8 02 46 ff ff       	call   36f9 <lodepng_free>
    f0f7:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    f0fa:	eb 27                	jmp    f123 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    f0fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f0ff:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f102:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f105:	01 ca                	add    %ecx,%edx
    f107:	83 ec 08             	sub    $0x8,%esp
    f10a:	50                   	push   %eax
    f10b:	52                   	push   %edx
    f10c:	ff 75 e0             	pushl  -0x20(%ebp)
    f10f:	ff 75 e4             	pushl  -0x1c(%ebp)
    f112:	ff 75 e8             	pushl  -0x18(%ebp)
    f115:	ff 75 08             	pushl  0x8(%ebp)
    f118:	e8 5c a9 ff ff       	call   9a79 <lodepng_add_itext_sized>
    f11d:	83 c4 20             	add    $0x20,%esp
    f120:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    f123:	90                   	nop
  }

  lodepng_free(key);
    f124:	83 ec 0c             	sub    $0xc,%esp
    f127:	ff 75 e8             	pushl  -0x18(%ebp)
    f12a:	e8 ca 45 ff ff       	call   36f9 <lodepng_free>
    f12f:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    f132:	83 ec 0c             	sub    $0xc,%esp
    f135:	ff 75 e4             	pushl  -0x1c(%ebp)
    f138:	e8 bc 45 ff ff       	call   36f9 <lodepng_free>
    f13d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    f140:	83 ec 0c             	sub    $0xc,%esp
    f143:	ff 75 e0             	pushl  -0x20(%ebp)
    f146:	e8 ae 45 ff ff       	call   36f9 <lodepng_free>
    f14b:	83 c4 10             	add    $0x10,%esp

  return error;
    f14e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f151:	c9                   	leave  
    f152:	c3                   	ret    

0000f153 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f153:	55                   	push   %ebp
    f154:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    f156:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    f15a:	74 0a                	je     f166 <readChunk_tIME+0x13>
    f15c:	b8 49 00 00 00       	mov    $0x49,%eax
    f161:	e9 8b 00 00 00       	jmp    f1f1 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    f166:	8b 45 08             	mov    0x8(%ebp),%eax
    f169:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    f170:	8b 45 0c             	mov    0xc(%ebp),%eax
    f173:	0f b6 00             	movzbl (%eax),%eax
    f176:	0f b6 c0             	movzbl %al,%eax
    f179:	c1 e0 08             	shl    $0x8,%eax
    f17c:	89 c2                	mov    %eax,%edx
    f17e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f181:	83 c0 01             	add    $0x1,%eax
    f184:	0f b6 00             	movzbl (%eax),%eax
    f187:	0f b6 c0             	movzbl %al,%eax
    f18a:	01 c2                	add    %eax,%edx
    f18c:	8b 45 08             	mov    0x8(%ebp),%eax
    f18f:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    f192:	8b 45 0c             	mov    0xc(%ebp),%eax
    f195:	83 c0 02             	add    $0x2,%eax
    f198:	0f b6 00             	movzbl (%eax),%eax
    f19b:	0f b6 d0             	movzbl %al,%edx
    f19e:	8b 45 08             	mov    0x8(%ebp),%eax
    f1a1:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    f1a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1a7:	83 c0 03             	add    $0x3,%eax
    f1aa:	0f b6 00             	movzbl (%eax),%eax
    f1ad:	0f b6 d0             	movzbl %al,%edx
    f1b0:	8b 45 08             	mov    0x8(%ebp),%eax
    f1b3:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    f1b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1b9:	83 c0 04             	add    $0x4,%eax
    f1bc:	0f b6 00             	movzbl (%eax),%eax
    f1bf:	0f b6 d0             	movzbl %al,%edx
    f1c2:	8b 45 08             	mov    0x8(%ebp),%eax
    f1c5:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    f1c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1cb:	83 c0 05             	add    $0x5,%eax
    f1ce:	0f b6 00             	movzbl (%eax),%eax
    f1d1:	0f b6 d0             	movzbl %al,%edx
    f1d4:	8b 45 08             	mov    0x8(%ebp),%eax
    f1d7:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    f1da:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1dd:	83 c0 06             	add    $0x6,%eax
    f1e0:	0f b6 00             	movzbl (%eax),%eax
    f1e3:	0f b6 d0             	movzbl %al,%edx
    f1e6:	8b 45 08             	mov    0x8(%ebp),%eax
    f1e9:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    f1ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f1f1:	5d                   	pop    %ebp
    f1f2:	c3                   	ret    

0000f1f3 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f1f3:	55                   	push   %ebp
    f1f4:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    f1f6:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    f1fa:	74 0a                	je     f206 <readChunk_pHYs+0x13>
    f1fc:	b8 4a 00 00 00       	mov    $0x4a,%eax
    f201:	e9 ba 00 00 00       	jmp    f2c0 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    f206:	8b 45 08             	mov    0x8(%ebp),%eax
    f209:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f210:	8b 45 0c             	mov    0xc(%ebp),%eax
    f213:	0f b6 00             	movzbl (%eax),%eax
    f216:	0f b6 c0             	movzbl %al,%eax
    f219:	c1 e0 08             	shl    $0x8,%eax
    f21c:	89 c2                	mov    %eax,%edx
    f21e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f221:	83 c0 01             	add    $0x1,%eax
    f224:	0f b6 00             	movzbl (%eax),%eax
    f227:	0f b6 c0             	movzbl %al,%eax
    f22a:	01 d0                	add    %edx,%eax
    f22c:	c1 e0 08             	shl    $0x8,%eax
    f22f:	89 c2                	mov    %eax,%edx
    f231:	8b 45 0c             	mov    0xc(%ebp),%eax
    f234:	83 c0 02             	add    $0x2,%eax
    f237:	0f b6 00             	movzbl (%eax),%eax
    f23a:	0f b6 c0             	movzbl %al,%eax
    f23d:	01 d0                	add    %edx,%eax
    f23f:	c1 e0 08             	shl    $0x8,%eax
    f242:	89 c2                	mov    %eax,%edx
    f244:	8b 45 0c             	mov    0xc(%ebp),%eax
    f247:	83 c0 03             	add    $0x3,%eax
    f24a:	0f b6 00             	movzbl (%eax),%eax
    f24d:	0f b6 c0             	movzbl %al,%eax
    f250:	01 c2                	add    %eax,%edx
    f252:	8b 45 08             	mov    0x8(%ebp),%eax
    f255:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    f258:	8b 45 0c             	mov    0xc(%ebp),%eax
    f25b:	83 c0 04             	add    $0x4,%eax
    f25e:	0f b6 00             	movzbl (%eax),%eax
    f261:	0f b6 c0             	movzbl %al,%eax
    f264:	c1 e0 08             	shl    $0x8,%eax
    f267:	89 c2                	mov    %eax,%edx
    f269:	8b 45 0c             	mov    0xc(%ebp),%eax
    f26c:	83 c0 05             	add    $0x5,%eax
    f26f:	0f b6 00             	movzbl (%eax),%eax
    f272:	0f b6 c0             	movzbl %al,%eax
    f275:	01 d0                	add    %edx,%eax
    f277:	c1 e0 08             	shl    $0x8,%eax
    f27a:	89 c2                	mov    %eax,%edx
    f27c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f27f:	83 c0 06             	add    $0x6,%eax
    f282:	0f b6 00             	movzbl (%eax),%eax
    f285:	0f b6 c0             	movzbl %al,%eax
    f288:	01 d0                	add    %edx,%eax
    f28a:	c1 e0 08             	shl    $0x8,%eax
    f28d:	89 c2                	mov    %eax,%edx
    f28f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f292:	83 c0 07             	add    $0x7,%eax
    f295:	0f b6 00             	movzbl (%eax),%eax
    f298:	0f b6 c0             	movzbl %al,%eax
    f29b:	01 c2                	add    %eax,%edx
    f29d:	8b 45 08             	mov    0x8(%ebp),%eax
    f2a0:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    f2a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2a9:	83 c0 08             	add    $0x8,%eax
    f2ac:	0f b6 00             	movzbl (%eax),%eax
    f2af:	0f b6 d0             	movzbl %al,%edx
    f2b2:	8b 45 08             	mov    0x8(%ebp),%eax
    f2b5:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    f2bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f2c0:	5d                   	pop    %ebp
    f2c1:	c3                   	ret    

0000f2c2 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f2c2:	55                   	push   %ebp
    f2c3:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    f2c5:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    f2c9:	74 07                	je     f2d2 <readChunk_gAMA+0x10>
    f2cb:	b8 60 00 00 00       	mov    $0x60,%eax
    f2d0:	eb 5d                	jmp    f32f <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    f2d2:	8b 45 08             	mov    0x8(%ebp),%eax
    f2d5:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    f2dc:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f2df:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2e2:	0f b6 00             	movzbl (%eax),%eax
    f2e5:	0f b6 c0             	movzbl %al,%eax
    f2e8:	c1 e0 08             	shl    $0x8,%eax
    f2eb:	89 c2                	mov    %eax,%edx
    f2ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2f0:	83 c0 01             	add    $0x1,%eax
    f2f3:	0f b6 00             	movzbl (%eax),%eax
    f2f6:	0f b6 c0             	movzbl %al,%eax
    f2f9:	01 d0                	add    %edx,%eax
    f2fb:	c1 e0 08             	shl    $0x8,%eax
    f2fe:	89 c2                	mov    %eax,%edx
    f300:	8b 45 0c             	mov    0xc(%ebp),%eax
    f303:	83 c0 02             	add    $0x2,%eax
    f306:	0f b6 00             	movzbl (%eax),%eax
    f309:	0f b6 c0             	movzbl %al,%eax
    f30c:	01 d0                	add    %edx,%eax
    f30e:	c1 e0 08             	shl    $0x8,%eax
    f311:	89 c2                	mov    %eax,%edx
    f313:	8b 45 0c             	mov    0xc(%ebp),%eax
    f316:	83 c0 03             	add    $0x3,%eax
    f319:	0f b6 00             	movzbl (%eax),%eax
    f31c:	0f b6 c0             	movzbl %al,%eax
    f31f:	01 c2                	add    %eax,%edx
    f321:	8b 45 08             	mov    0x8(%ebp),%eax
    f324:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f32a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f32f:	5d                   	pop    %ebp
    f330:	c3                   	ret    

0000f331 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f331:	55                   	push   %ebp
    f332:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f334:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f338:	74 0a                	je     f344 <readChunk_cHRM+0x13>
    f33a:	b8 61 00 00 00       	mov    $0x61,%eax
    f33f:	e9 7f 02 00 00       	jmp    f5c3 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f344:	8b 45 08             	mov    0x8(%ebp),%eax
    f347:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f34e:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f351:	8b 45 0c             	mov    0xc(%ebp),%eax
    f354:	0f b6 00             	movzbl (%eax),%eax
    f357:	0f b6 c0             	movzbl %al,%eax
    f35a:	c1 e0 08             	shl    $0x8,%eax
    f35d:	89 c2                	mov    %eax,%edx
    f35f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f362:	83 c0 01             	add    $0x1,%eax
    f365:	0f b6 00             	movzbl (%eax),%eax
    f368:	0f b6 c0             	movzbl %al,%eax
    f36b:	01 d0                	add    %edx,%eax
    f36d:	c1 e0 08             	shl    $0x8,%eax
    f370:	89 c2                	mov    %eax,%edx
    f372:	8b 45 0c             	mov    0xc(%ebp),%eax
    f375:	83 c0 02             	add    $0x2,%eax
    f378:	0f b6 00             	movzbl (%eax),%eax
    f37b:	0f b6 c0             	movzbl %al,%eax
    f37e:	01 d0                	add    %edx,%eax
    f380:	c1 e0 08             	shl    $0x8,%eax
    f383:	89 c2                	mov    %eax,%edx
    f385:	8b 45 0c             	mov    0xc(%ebp),%eax
    f388:	83 c0 03             	add    $0x3,%eax
    f38b:	0f b6 00             	movzbl (%eax),%eax
    f38e:	0f b6 c0             	movzbl %al,%eax
    f391:	01 c2                	add    %eax,%edx
    f393:	8b 45 08             	mov    0x8(%ebp),%eax
    f396:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f39c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f39f:	83 c0 04             	add    $0x4,%eax
    f3a2:	0f b6 00             	movzbl (%eax),%eax
    f3a5:	0f b6 c0             	movzbl %al,%eax
    f3a8:	c1 e0 08             	shl    $0x8,%eax
    f3ab:	89 c2                	mov    %eax,%edx
    f3ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3b0:	83 c0 05             	add    $0x5,%eax
    f3b3:	0f b6 00             	movzbl (%eax),%eax
    f3b6:	0f b6 c0             	movzbl %al,%eax
    f3b9:	01 d0                	add    %edx,%eax
    f3bb:	c1 e0 08             	shl    $0x8,%eax
    f3be:	89 c2                	mov    %eax,%edx
    f3c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3c3:	83 c0 06             	add    $0x6,%eax
    f3c6:	0f b6 00             	movzbl (%eax),%eax
    f3c9:	0f b6 c0             	movzbl %al,%eax
    f3cc:	01 d0                	add    %edx,%eax
    f3ce:	c1 e0 08             	shl    $0x8,%eax
    f3d1:	89 c2                	mov    %eax,%edx
    f3d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3d6:	83 c0 07             	add    $0x7,%eax
    f3d9:	0f b6 00             	movzbl (%eax),%eax
    f3dc:	0f b6 c0             	movzbl %al,%eax
    f3df:	01 c2                	add    %eax,%edx
    f3e1:	8b 45 08             	mov    0x8(%ebp),%eax
    f3e4:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f3ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3ed:	83 c0 08             	add    $0x8,%eax
    f3f0:	0f b6 00             	movzbl (%eax),%eax
    f3f3:	0f b6 c0             	movzbl %al,%eax
    f3f6:	c1 e0 08             	shl    $0x8,%eax
    f3f9:	89 c2                	mov    %eax,%edx
    f3fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3fe:	83 c0 09             	add    $0x9,%eax
    f401:	0f b6 00             	movzbl (%eax),%eax
    f404:	0f b6 c0             	movzbl %al,%eax
    f407:	01 d0                	add    %edx,%eax
    f409:	c1 e0 08             	shl    $0x8,%eax
    f40c:	89 c2                	mov    %eax,%edx
    f40e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f411:	83 c0 0a             	add    $0xa,%eax
    f414:	0f b6 00             	movzbl (%eax),%eax
    f417:	0f b6 c0             	movzbl %al,%eax
    f41a:	01 d0                	add    %edx,%eax
    f41c:	c1 e0 08             	shl    $0x8,%eax
    f41f:	89 c2                	mov    %eax,%edx
    f421:	8b 45 0c             	mov    0xc(%ebp),%eax
    f424:	83 c0 0b             	add    $0xb,%eax
    f427:	0f b6 00             	movzbl (%eax),%eax
    f42a:	0f b6 c0             	movzbl %al,%eax
    f42d:	01 c2                	add    %eax,%edx
    f42f:	8b 45 08             	mov    0x8(%ebp),%eax
    f432:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f438:	8b 45 0c             	mov    0xc(%ebp),%eax
    f43b:	83 c0 0c             	add    $0xc,%eax
    f43e:	0f b6 00             	movzbl (%eax),%eax
    f441:	0f b6 c0             	movzbl %al,%eax
    f444:	c1 e0 08             	shl    $0x8,%eax
    f447:	89 c2                	mov    %eax,%edx
    f449:	8b 45 0c             	mov    0xc(%ebp),%eax
    f44c:	83 c0 0d             	add    $0xd,%eax
    f44f:	0f b6 00             	movzbl (%eax),%eax
    f452:	0f b6 c0             	movzbl %al,%eax
    f455:	01 d0                	add    %edx,%eax
    f457:	c1 e0 08             	shl    $0x8,%eax
    f45a:	89 c2                	mov    %eax,%edx
    f45c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f45f:	83 c0 0e             	add    $0xe,%eax
    f462:	0f b6 00             	movzbl (%eax),%eax
    f465:	0f b6 c0             	movzbl %al,%eax
    f468:	01 d0                	add    %edx,%eax
    f46a:	c1 e0 08             	shl    $0x8,%eax
    f46d:	89 c2                	mov    %eax,%edx
    f46f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f472:	83 c0 0f             	add    $0xf,%eax
    f475:	0f b6 00             	movzbl (%eax),%eax
    f478:	0f b6 c0             	movzbl %al,%eax
    f47b:	01 c2                	add    %eax,%edx
    f47d:	8b 45 08             	mov    0x8(%ebp),%eax
    f480:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f486:	8b 45 0c             	mov    0xc(%ebp),%eax
    f489:	83 c0 10             	add    $0x10,%eax
    f48c:	0f b6 00             	movzbl (%eax),%eax
    f48f:	0f b6 c0             	movzbl %al,%eax
    f492:	c1 e0 08             	shl    $0x8,%eax
    f495:	89 c2                	mov    %eax,%edx
    f497:	8b 45 0c             	mov    0xc(%ebp),%eax
    f49a:	83 c0 11             	add    $0x11,%eax
    f49d:	0f b6 00             	movzbl (%eax),%eax
    f4a0:	0f b6 c0             	movzbl %al,%eax
    f4a3:	01 d0                	add    %edx,%eax
    f4a5:	c1 e0 08             	shl    $0x8,%eax
    f4a8:	89 c2                	mov    %eax,%edx
    f4aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4ad:	83 c0 12             	add    $0x12,%eax
    f4b0:	0f b6 00             	movzbl (%eax),%eax
    f4b3:	0f b6 c0             	movzbl %al,%eax
    f4b6:	01 d0                	add    %edx,%eax
    f4b8:	c1 e0 08             	shl    $0x8,%eax
    f4bb:	89 c2                	mov    %eax,%edx
    f4bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4c0:	83 c0 13             	add    $0x13,%eax
    f4c3:	0f b6 00             	movzbl (%eax),%eax
    f4c6:	0f b6 c0             	movzbl %al,%eax
    f4c9:	01 c2                	add    %eax,%edx
    f4cb:	8b 45 08             	mov    0x8(%ebp),%eax
    f4ce:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f4d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4d7:	83 c0 14             	add    $0x14,%eax
    f4da:	0f b6 00             	movzbl (%eax),%eax
    f4dd:	0f b6 c0             	movzbl %al,%eax
    f4e0:	c1 e0 08             	shl    $0x8,%eax
    f4e3:	89 c2                	mov    %eax,%edx
    f4e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4e8:	83 c0 15             	add    $0x15,%eax
    f4eb:	0f b6 00             	movzbl (%eax),%eax
    f4ee:	0f b6 c0             	movzbl %al,%eax
    f4f1:	01 d0                	add    %edx,%eax
    f4f3:	c1 e0 08             	shl    $0x8,%eax
    f4f6:	89 c2                	mov    %eax,%edx
    f4f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4fb:	83 c0 16             	add    $0x16,%eax
    f4fe:	0f b6 00             	movzbl (%eax),%eax
    f501:	0f b6 c0             	movzbl %al,%eax
    f504:	01 d0                	add    %edx,%eax
    f506:	c1 e0 08             	shl    $0x8,%eax
    f509:	89 c2                	mov    %eax,%edx
    f50b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f50e:	83 c0 17             	add    $0x17,%eax
    f511:	0f b6 00             	movzbl (%eax),%eax
    f514:	0f b6 c0             	movzbl %al,%eax
    f517:	01 c2                	add    %eax,%edx
    f519:	8b 45 08             	mov    0x8(%ebp),%eax
    f51c:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f522:	8b 45 0c             	mov    0xc(%ebp),%eax
    f525:	83 c0 18             	add    $0x18,%eax
    f528:	0f b6 00             	movzbl (%eax),%eax
    f52b:	0f b6 c0             	movzbl %al,%eax
    f52e:	c1 e0 08             	shl    $0x8,%eax
    f531:	89 c2                	mov    %eax,%edx
    f533:	8b 45 0c             	mov    0xc(%ebp),%eax
    f536:	83 c0 19             	add    $0x19,%eax
    f539:	0f b6 00             	movzbl (%eax),%eax
    f53c:	0f b6 c0             	movzbl %al,%eax
    f53f:	01 d0                	add    %edx,%eax
    f541:	c1 e0 08             	shl    $0x8,%eax
    f544:	89 c2                	mov    %eax,%edx
    f546:	8b 45 0c             	mov    0xc(%ebp),%eax
    f549:	83 c0 1a             	add    $0x1a,%eax
    f54c:	0f b6 00             	movzbl (%eax),%eax
    f54f:	0f b6 c0             	movzbl %al,%eax
    f552:	01 d0                	add    %edx,%eax
    f554:	c1 e0 08             	shl    $0x8,%eax
    f557:	89 c2                	mov    %eax,%edx
    f559:	8b 45 0c             	mov    0xc(%ebp),%eax
    f55c:	83 c0 1b             	add    $0x1b,%eax
    f55f:	0f b6 00             	movzbl (%eax),%eax
    f562:	0f b6 c0             	movzbl %al,%eax
    f565:	01 c2                	add    %eax,%edx
    f567:	8b 45 08             	mov    0x8(%ebp),%eax
    f56a:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f570:	8b 45 0c             	mov    0xc(%ebp),%eax
    f573:	83 c0 1c             	add    $0x1c,%eax
    f576:	0f b6 00             	movzbl (%eax),%eax
    f579:	0f b6 c0             	movzbl %al,%eax
    f57c:	c1 e0 08             	shl    $0x8,%eax
    f57f:	89 c2                	mov    %eax,%edx
    f581:	8b 45 0c             	mov    0xc(%ebp),%eax
    f584:	83 c0 1d             	add    $0x1d,%eax
    f587:	0f b6 00             	movzbl (%eax),%eax
    f58a:	0f b6 c0             	movzbl %al,%eax
    f58d:	01 d0                	add    %edx,%eax
    f58f:	c1 e0 08             	shl    $0x8,%eax
    f592:	89 c2                	mov    %eax,%edx
    f594:	8b 45 0c             	mov    0xc(%ebp),%eax
    f597:	83 c0 1e             	add    $0x1e,%eax
    f59a:	0f b6 00             	movzbl (%eax),%eax
    f59d:	0f b6 c0             	movzbl %al,%eax
    f5a0:	01 d0                	add    %edx,%eax
    f5a2:	c1 e0 08             	shl    $0x8,%eax
    f5a5:	89 c2                	mov    %eax,%edx
    f5a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5aa:	83 c0 1f             	add    $0x1f,%eax
    f5ad:	0f b6 00             	movzbl (%eax),%eax
    f5b0:	0f b6 c0             	movzbl %al,%eax
    f5b3:	01 c2                	add    %eax,%edx
    f5b5:	8b 45 08             	mov    0x8(%ebp),%eax
    f5b8:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f5be:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f5c3:	5d                   	pop    %ebp
    f5c4:	c3                   	ret    

0000f5c5 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f5c5:	55                   	push   %ebp
    f5c6:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f5c8:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f5cc:	74 07                	je     f5d5 <readChunk_sRGB+0x10>
    f5ce:	b8 62 00 00 00       	mov    $0x62,%eax
    f5d3:	eb 24                	jmp    f5f9 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f5d5:	8b 45 08             	mov    0x8(%ebp),%eax
    f5d8:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f5df:	00 00 00 
  info->srgb_intent = data[0];
    f5e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5e5:	0f b6 00             	movzbl (%eax),%eax
    f5e8:	0f b6 d0             	movzbl %al,%edx
    f5eb:	8b 45 08             	mov    0x8(%ebp),%eax
    f5ee:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f5f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f5f9:	5d                   	pop    %ebp
    f5fa:	c3                   	ret    

0000f5fb <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f5fb:	55                   	push   %ebp
    f5fc:	89 e5                	mov    %esp,%ebp
    f5fe:	53                   	push   %ebx
    f5ff:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f602:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f609:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f610:	8b 45 0c             	mov    0xc(%ebp),%eax
    f613:	8b 10                	mov    (%eax),%edx
    f615:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f618:	8b 50 04             	mov    0x4(%eax),%edx
    f61b:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f61e:	8b 50 08             	mov    0x8(%eax),%edx
    f621:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f624:	8b 50 0c             	mov    0xc(%eax),%edx
    f627:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f62a:	8b 50 10             	mov    0x10(%eax),%edx
    f62d:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f630:	8b 40 14             	mov    0x14(%eax),%eax
    f633:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f636:	8b 45 08             	mov    0x8(%ebp),%eax
    f639:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f640:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f643:	8b 45 08             	mov    0x8(%ebp),%eax
    f646:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f64c:	85 c0                	test   %eax,%eax
    f64e:	74 0e                	je     f65e <readChunk_iCCP+0x63>
    f650:	83 ec 0c             	sub    $0xc,%esp
    f653:	ff 75 08             	pushl  0x8(%ebp)
    f656:	e8 ca a6 ff ff       	call   9d25 <lodepng_clear_icc>
    f65b:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f65e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f665:	eb 04                	jmp    f66b <readChunk_iCCP+0x70>
    f667:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f66b:	8b 45 14             	mov    0x14(%ebp),%eax
    f66e:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f671:	73 0f                	jae    f682 <readChunk_iCCP+0x87>
    f673:	8b 55 10             	mov    0x10(%ebp),%edx
    f676:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f679:	01 d0                	add    %edx,%eax
    f67b:	0f b6 00             	movzbl (%eax),%eax
    f67e:	84 c0                	test   %al,%al
    f680:	75 e5                	jne    f667 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f682:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f685:	8d 50 02             	lea    0x2(%eax),%edx
    f688:	8b 45 14             	mov    0x14(%ebp),%eax
    f68b:	39 c2                	cmp    %eax,%edx
    f68d:	72 0a                	jb     f699 <readChunk_iCCP+0x9e>
    f68f:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f694:	e9 46 01 00 00       	jmp    f7df <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f699:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f69d:	74 06                	je     f6a5 <readChunk_iCCP+0xaa>
    f69f:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f6a3:	76 0a                	jbe    f6af <readChunk_iCCP+0xb4>
    f6a5:	b8 59 00 00 00       	mov    $0x59,%eax
    f6aa:	e9 30 01 00 00       	jmp    f7df <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f6af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f6b2:	83 c0 01             	add    $0x1,%eax
    f6b5:	83 ec 0c             	sub    $0xc,%esp
    f6b8:	50                   	push   %eax
    f6b9:	e8 1a 40 ff ff       	call   36d8 <lodepng_malloc>
    f6be:	83 c4 10             	add    $0x10,%esp
    f6c1:	89 c2                	mov    %eax,%edx
    f6c3:	8b 45 08             	mov    0x8(%ebp),%eax
    f6c6:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f6cc:	8b 45 08             	mov    0x8(%ebp),%eax
    f6cf:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f6d5:	85 c0                	test   %eax,%eax
    f6d7:	75 0a                	jne    f6e3 <readChunk_iCCP+0xe8>
    f6d9:	b8 53 00 00 00       	mov    $0x53,%eax
    f6de:	e9 fc 00 00 00       	jmp    f7df <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f6e3:	8b 45 08             	mov    0x8(%ebp),%eax
    f6e6:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f6ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f6ef:	01 d0                	add    %edx,%eax
    f6f1:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f6f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f6fb:	eb 1f                	jmp    f71c <readChunk_iCCP+0x121>
    f6fd:	8b 45 08             	mov    0x8(%ebp),%eax
    f700:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f706:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f709:	01 d0                	add    %edx,%eax
    f70b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f70e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f711:	01 ca                	add    %ecx,%edx
    f713:	0f b6 12             	movzbl (%edx),%edx
    f716:	88 10                	mov    %dl,(%eax)
    f718:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f71c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f71f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f722:	75 d9                	jne    f6fd <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f724:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f727:	8d 50 01             	lea    0x1(%eax),%edx
    f72a:	8b 45 10             	mov    0x10(%ebp),%eax
    f72d:	01 d0                	add    %edx,%eax
    f72f:	0f b6 00             	movzbl (%eax),%eax
    f732:	84 c0                	test   %al,%al
    f734:	74 0a                	je     f740 <readChunk_iCCP+0x145>
    f736:	b8 48 00 00 00       	mov    $0x48,%eax
    f73b:	e9 9f 00 00 00       	jmp    f7df <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f740:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f743:	83 c0 02             	add    $0x2,%eax
    f746:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f749:	8b 45 14             	mov    0x14(%ebp),%eax
    f74c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f74f:	76 0a                	jbe    f75b <readChunk_iCCP+0x160>
    f751:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f756:	e9 84 00 00 00       	jmp    f7df <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f75b:	8b 45 14             	mov    0x14(%ebp),%eax
    f75e:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f761:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f764:	8b 45 0c             	mov    0xc(%ebp),%eax
    f767:	8b 40 34             	mov    0x34(%eax),%eax
    f76a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f76d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f770:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f773:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f776:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f779:	8b 55 08             	mov    0x8(%ebp),%edx
    f77c:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f782:	83 ec 08             	sub    $0x8,%esp
    f785:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f788:	52                   	push   %edx
    f789:	50                   	push   %eax
    f78a:	53                   	push   %ebx
    f78b:	6a 00                	push   $0x0
    f78d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f790:	50                   	push   %eax
    f791:	51                   	push   %ecx
    f792:	e8 fc 89 ff ff       	call   8193 <zlib_decompress>
    f797:	83 c4 20             	add    $0x20,%esp
    f79a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f79d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f7a1:	74 11                	je     f7b4 <readChunk_iCCP+0x1b9>
    f7a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f7a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f7a9:	39 c2                	cmp    %eax,%edx
    f7ab:	7d 07                	jge    f7b4 <readChunk_iCCP+0x1b9>
    f7ad:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f7b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f7b7:	89 c2                	mov    %eax,%edx
    f7b9:	8b 45 08             	mov    0x8(%ebp),%eax
    f7bc:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f7c2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f7c6:	75 14                	jne    f7dc <readChunk_iCCP+0x1e1>
    f7c8:	8b 45 08             	mov    0x8(%ebp),%eax
    f7cb:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f7d1:	85 c0                	test   %eax,%eax
    f7d3:	75 07                	jne    f7dc <readChunk_iCCP+0x1e1>
    f7d5:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f7dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f7df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f7e2:	c9                   	leave  
    f7e3:	c3                   	ret    

0000f7e4 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f7e4:	55                   	push   %ebp
    f7e5:	89 e5                	mov    %esp,%ebp
    f7e7:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f7ea:	8b 55 0c             	mov    0xc(%ebp),%edx
    f7ed:	8b 45 10             	mov    0x10(%ebp),%eax
    f7f0:	01 d0                	add    %edx,%eax
    f7f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f7f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f7fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f803:	8b 45 0c             	mov    0xc(%ebp),%eax
    f806:	83 c0 04             	add    $0x4,%eax
    f809:	3b 45 14             	cmp    0x14(%ebp),%eax
    f80c:	7e 0a                	jle    f818 <lodepng_inspect_chunk+0x34>
    f80e:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f813:	e9 43 03 00 00       	jmp    fb5b <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f818:	ff 75 ec             	pushl  -0x14(%ebp)
    f81b:	e8 3a 8e ff ff       	call   865a <lodepng_chunk_length>
    f820:	83 c4 04             	add    $0x4,%esp
    f823:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f826:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f829:	85 c0                	test   %eax,%eax
    f82b:	79 0a                	jns    f837 <lodepng_inspect_chunk+0x53>
    f82d:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f832:	e9 24 03 00 00       	jmp    fb5b <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f837:	ff 75 ec             	pushl  -0x14(%ebp)
    f83a:	e8 53 8f ff ff       	call   8792 <lodepng_chunk_data_const>
    f83f:	83 c4 04             	add    $0x4,%esp
    f842:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f845:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f848:	8d 50 04             	lea    0x4(%eax),%edx
    f84b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f84e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f851:	8b 55 14             	mov    0x14(%ebp),%edx
    f854:	8b 45 10             	mov    0x10(%ebp),%eax
    f857:	01 d0                	add    %edx,%eax
    f859:	39 c1                	cmp    %eax,%ecx
    f85b:	76 0a                	jbe    f867 <lodepng_inspect_chunk+0x83>
    f85d:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f862:	e9 f4 02 00 00       	jmp    fb5b <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f867:	68 a8 a4 01 00       	push   $0x1a4a8
    f86c:	ff 75 ec             	pushl  -0x14(%ebp)
    f86f:	e8 33 8e ff ff       	call   86a7 <lodepng_chunk_type_equals>
    f874:	83 c4 08             	add    $0x8,%esp
    f877:	84 c0                	test   %al,%al
    f879:	74 24                	je     f89f <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f87b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f87e:	8b 55 08             	mov    0x8(%ebp),%edx
    f881:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f887:	83 ec 04             	sub    $0x4,%esp
    f88a:	50                   	push   %eax
    f88b:	ff 75 e4             	pushl  -0x1c(%ebp)
    f88e:	52                   	push   %edx
    f88f:	e8 5b ee ff ff       	call   e6ef <readChunk_PLTE>
    f894:	83 c4 10             	add    $0x10,%esp
    f897:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f89a:	e9 8a 02 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f89f:	83 ec 08             	sub    $0x8,%esp
    f8a2:	68 ad a4 01 00       	push   $0x1a4ad
    f8a7:	ff 75 ec             	pushl  -0x14(%ebp)
    f8aa:	e8 f8 8d ff ff       	call   86a7 <lodepng_chunk_type_equals>
    f8af:	83 c4 10             	add    $0x10,%esp
    f8b2:	84 c0                	test   %al,%al
    f8b4:	74 24                	je     f8da <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f8b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f8b9:	8b 55 08             	mov    0x8(%ebp),%edx
    f8bc:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f8c2:	83 ec 04             	sub    $0x4,%esp
    f8c5:	50                   	push   %eax
    f8c6:	ff 75 e4             	pushl  -0x1c(%ebp)
    f8c9:	52                   	push   %edx
    f8ca:	e8 40 ef ff ff       	call   e80f <readChunk_tRNS>
    f8cf:	83 c4 10             	add    $0x10,%esp
    f8d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f8d5:	e9 4f 02 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f8da:	83 ec 08             	sub    $0x8,%esp
    f8dd:	68 b2 a4 01 00       	push   $0x1a4b2
    f8e2:	ff 75 ec             	pushl  -0x14(%ebp)
    f8e5:	e8 bd 8d ff ff       	call   86a7 <lodepng_chunk_type_equals>
    f8ea:	83 c4 10             	add    $0x10,%esp
    f8ed:	84 c0                	test   %al,%al
    f8ef:	74 24                	je     f915 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f8f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f8f4:	8b 55 08             	mov    0x8(%ebp),%edx
    f8f7:	81 c2 98 00 00 00    	add    $0x98,%edx
    f8fd:	83 ec 04             	sub    $0x4,%esp
    f900:	50                   	push   %eax
    f901:	ff 75 e4             	pushl  -0x1c(%ebp)
    f904:	52                   	push   %edx
    f905:	e8 68 f0 ff ff       	call   e972 <readChunk_bKGD>
    f90a:	83 c4 10             	add    $0x10,%esp
    f90d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f910:	e9 14 02 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f915:	83 ec 08             	sub    $0x8,%esp
    f918:	68 b7 a4 01 00       	push   $0x1a4b7
    f91d:	ff 75 ec             	pushl  -0x14(%ebp)
    f920:	e8 82 8d ff ff       	call   86a7 <lodepng_chunk_type_equals>
    f925:	83 c4 10             	add    $0x10,%esp
    f928:	84 c0                	test   %al,%al
    f92a:	74 24                	je     f950 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f92c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f92f:	8b 55 08             	mov    0x8(%ebp),%edx
    f932:	81 c2 98 00 00 00    	add    $0x98,%edx
    f938:	83 ec 04             	sub    $0x4,%esp
    f93b:	50                   	push   %eax
    f93c:	ff 75 e4             	pushl  -0x1c(%ebp)
    f93f:	52                   	push   %edx
    f940:	e8 b0 f1 ff ff       	call   eaf5 <readChunk_tEXt>
    f945:	83 c4 10             	add    $0x10,%esp
    f948:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f94b:	e9 d9 01 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f950:	83 ec 08             	sub    $0x8,%esp
    f953:	68 bc a4 01 00       	push   $0x1a4bc
    f958:	ff 75 ec             	pushl  -0x14(%ebp)
    f95b:	e8 47 8d ff ff       	call   86a7 <lodepng_chunk_type_equals>
    f960:	83 c4 10             	add    $0x10,%esp
    f963:	84 c0                	test   %al,%al
    f965:	74 25                	je     f98c <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f967:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f96a:	8b 45 08             	mov    0x8(%ebp),%eax
    f96d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f970:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f976:	52                   	push   %edx
    f977:	ff 75 e4             	pushl  -0x1c(%ebp)
    f97a:	50                   	push   %eax
    f97b:	51                   	push   %ecx
    f97c:	e8 c0 f2 ff ff       	call   ec41 <readChunk_zTXt>
    f981:	83 c4 10             	add    $0x10,%esp
    f984:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f987:	e9 9d 01 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f98c:	83 ec 08             	sub    $0x8,%esp
    f98f:	68 c1 a4 01 00       	push   $0x1a4c1
    f994:	ff 75 ec             	pushl  -0x14(%ebp)
    f997:	e8 0b 8d ff ff       	call   86a7 <lodepng_chunk_type_equals>
    f99c:	83 c4 10             	add    $0x10,%esp
    f99f:	84 c0                	test   %al,%al
    f9a1:	74 25                	je     f9c8 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f9a3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f9a6:	8b 45 08             	mov    0x8(%ebp),%eax
    f9a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f9ac:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f9b2:	52                   	push   %edx
    f9b3:	ff 75 e4             	pushl  -0x1c(%ebp)
    f9b6:	50                   	push   %eax
    f9b7:	51                   	push   %ecx
    f9b8:	e8 40 f4 ff ff       	call   edfd <readChunk_iTXt>
    f9bd:	83 c4 10             	add    $0x10,%esp
    f9c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f9c3:	e9 61 01 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f9c8:	83 ec 08             	sub    $0x8,%esp
    f9cb:	68 c6 a4 01 00       	push   $0x1a4c6
    f9d0:	ff 75 ec             	pushl  -0x14(%ebp)
    f9d3:	e8 cf 8c ff ff       	call   86a7 <lodepng_chunk_type_equals>
    f9d8:	83 c4 10             	add    $0x10,%esp
    f9db:	84 c0                	test   %al,%al
    f9dd:	74 24                	je     fa03 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f9df:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f9e2:	8b 55 08             	mov    0x8(%ebp),%edx
    f9e5:	81 c2 98 00 00 00    	add    $0x98,%edx
    f9eb:	83 ec 04             	sub    $0x4,%esp
    f9ee:	50                   	push   %eax
    f9ef:	ff 75 e4             	pushl  -0x1c(%ebp)
    f9f2:	52                   	push   %edx
    f9f3:	e8 5b f7 ff ff       	call   f153 <readChunk_tIME>
    f9f8:	83 c4 10             	add    $0x10,%esp
    f9fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f9fe:	e9 26 01 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fa03:	83 ec 08             	sub    $0x8,%esp
    fa06:	68 cb a4 01 00       	push   $0x1a4cb
    fa0b:	ff 75 ec             	pushl  -0x14(%ebp)
    fa0e:	e8 94 8c ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fa13:	83 c4 10             	add    $0x10,%esp
    fa16:	84 c0                	test   %al,%al
    fa18:	74 24                	je     fa3e <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fa1a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fa1d:	8b 55 08             	mov    0x8(%ebp),%edx
    fa20:	81 c2 98 00 00 00    	add    $0x98,%edx
    fa26:	83 ec 04             	sub    $0x4,%esp
    fa29:	50                   	push   %eax
    fa2a:	ff 75 e4             	pushl  -0x1c(%ebp)
    fa2d:	52                   	push   %edx
    fa2e:	e8 c0 f7 ff ff       	call   f1f3 <readChunk_pHYs>
    fa33:	83 c4 10             	add    $0x10,%esp
    fa36:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fa39:	e9 eb 00 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fa3e:	83 ec 08             	sub    $0x8,%esp
    fa41:	68 d0 a4 01 00       	push   $0x1a4d0
    fa46:	ff 75 ec             	pushl  -0x14(%ebp)
    fa49:	e8 59 8c ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fa4e:	83 c4 10             	add    $0x10,%esp
    fa51:	84 c0                	test   %al,%al
    fa53:	74 24                	je     fa79 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fa55:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fa58:	8b 55 08             	mov    0x8(%ebp),%edx
    fa5b:	81 c2 98 00 00 00    	add    $0x98,%edx
    fa61:	83 ec 04             	sub    $0x4,%esp
    fa64:	50                   	push   %eax
    fa65:	ff 75 e4             	pushl  -0x1c(%ebp)
    fa68:	52                   	push   %edx
    fa69:	e8 54 f8 ff ff       	call   f2c2 <readChunk_gAMA>
    fa6e:	83 c4 10             	add    $0x10,%esp
    fa71:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fa74:	e9 b0 00 00 00       	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fa79:	83 ec 08             	sub    $0x8,%esp
    fa7c:	68 d5 a4 01 00       	push   $0x1a4d5
    fa81:	ff 75 ec             	pushl  -0x14(%ebp)
    fa84:	e8 1e 8c ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fa89:	83 c4 10             	add    $0x10,%esp
    fa8c:	84 c0                	test   %al,%al
    fa8e:	74 21                	je     fab1 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fa90:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fa93:	8b 55 08             	mov    0x8(%ebp),%edx
    fa96:	81 c2 98 00 00 00    	add    $0x98,%edx
    fa9c:	83 ec 04             	sub    $0x4,%esp
    fa9f:	50                   	push   %eax
    faa0:	ff 75 e4             	pushl  -0x1c(%ebp)
    faa3:	52                   	push   %edx
    faa4:	e8 88 f8 ff ff       	call   f331 <readChunk_cHRM>
    faa9:	83 c4 10             	add    $0x10,%esp
    faac:	89 45 f0             	mov    %eax,-0x10(%ebp)
    faaf:	eb 78                	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fab1:	83 ec 08             	sub    $0x8,%esp
    fab4:	68 da a4 01 00       	push   $0x1a4da
    fab9:	ff 75 ec             	pushl  -0x14(%ebp)
    fabc:	e8 e6 8b ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fac1:	83 c4 10             	add    $0x10,%esp
    fac4:	84 c0                	test   %al,%al
    fac6:	74 21                	je     fae9 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fac8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    facb:	8b 55 08             	mov    0x8(%ebp),%edx
    face:	81 c2 98 00 00 00    	add    $0x98,%edx
    fad4:	83 ec 04             	sub    $0x4,%esp
    fad7:	50                   	push   %eax
    fad8:	ff 75 e4             	pushl  -0x1c(%ebp)
    fadb:	52                   	push   %edx
    fadc:	e8 e4 fa ff ff       	call   f5c5 <readChunk_sRGB>
    fae1:	83 c4 10             	add    $0x10,%esp
    fae4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fae7:	eb 40                	jmp    fb29 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fae9:	83 ec 08             	sub    $0x8,%esp
    faec:	68 df a4 01 00       	push   $0x1a4df
    faf1:	ff 75 ec             	pushl  -0x14(%ebp)
    faf4:	e8 ae 8b ff ff       	call   86a7 <lodepng_chunk_type_equals>
    faf9:	83 c4 10             	add    $0x10,%esp
    fafc:	84 c0                	test   %al,%al
    fafe:	74 22                	je     fb22 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fb00:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fb03:	8b 45 08             	mov    0x8(%ebp),%eax
    fb06:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fb09:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fb0f:	52                   	push   %edx
    fb10:	ff 75 e4             	pushl  -0x1c(%ebp)
    fb13:	50                   	push   %eax
    fb14:	51                   	push   %ecx
    fb15:	e8 e1 fa ff ff       	call   f5fb <readChunk_iCCP>
    fb1a:	83 c4 10             	add    $0x10,%esp
    fb1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fb20:	eb 07                	jmp    fb29 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    fb22:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    fb29:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fb2d:	75 29                	jne    fb58 <lodepng_inspect_chunk+0x374>
    fb2f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fb33:	75 23                	jne    fb58 <lodepng_inspect_chunk+0x374>
    fb35:	8b 45 08             	mov    0x8(%ebp),%eax
    fb38:	8b 40 18             	mov    0x18(%eax),%eax
    fb3b:	85 c0                	test   %eax,%eax
    fb3d:	75 19                	jne    fb58 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    fb3f:	83 ec 0c             	sub    $0xc,%esp
    fb42:	ff 75 ec             	pushl  -0x14(%ebp)
    fb45:	e8 53 8c ff ff       	call   879d <lodepng_chunk_check_crc>
    fb4a:	83 c4 10             	add    $0x10,%esp
    fb4d:	85 c0                	test   %eax,%eax
    fb4f:	74 07                	je     fb58 <lodepng_inspect_chunk+0x374>
    fb51:	b8 39 00 00 00       	mov    $0x39,%eax
    fb56:	eb 03                	jmp    fb5b <lodepng_inspect_chunk+0x377>
  }

  return error;
    fb58:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    fb5b:	c9                   	leave  
    fb5c:	c3                   	ret    

0000fb5d <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    fb5d:	55                   	push   %ebp
    fb5e:	89 e5                	mov    %esp,%ebp
    fb60:	56                   	push   %esi
    fb61:	53                   	push   %ebx
    fb62:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    fb65:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    fb69:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    fb70:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    fb77:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    fb7e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    fb85:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    fb8c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    fb93:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    fb9a:	8b 45 08             	mov    0x8(%ebp),%eax
    fb9d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    fba3:	8b 45 10             	mov    0x10(%ebp),%eax
    fba6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    fbac:	8b 45 10             	mov    0x10(%ebp),%eax
    fbaf:	8b 10                	mov    (%eax),%edx
    fbb1:	8b 45 0c             	mov    0xc(%ebp),%eax
    fbb4:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    fbb6:	83 ec 0c             	sub    $0xc,%esp
    fbb9:	ff 75 1c             	pushl  0x1c(%ebp)
    fbbc:	ff 75 18             	pushl  0x18(%ebp)
    fbbf:	ff 75 14             	pushl  0x14(%ebp)
    fbc2:	ff 75 10             	pushl  0x10(%ebp)
    fbc5:	ff 75 0c             	pushl  0xc(%ebp)
    fbc8:	e8 d3 da ff ff       	call   d6a0 <lodepng_inspect>
    fbcd:	83 c4 20             	add    $0x20,%esp
    fbd0:	89 c2                	mov    %eax,%edx
    fbd2:	8b 45 14             	mov    0x14(%ebp),%eax
    fbd5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    fbdb:	8b 45 14             	mov    0x14(%ebp),%eax
    fbde:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbe4:	85 c0                	test   %eax,%eax
    fbe6:	0f 85 24 0a 00 00    	jne    10610 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    fbec:	8b 45 14             	mov    0x14(%ebp),%eax
    fbef:	8d 58 78             	lea    0x78(%eax),%ebx
    fbf2:	8b 45 14             	mov    0x14(%ebp),%eax
    fbf5:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    fbfb:	8b 45 10             	mov    0x10(%ebp),%eax
    fbfe:	8b 10                	mov    (%eax),%edx
    fc00:	8b 45 0c             	mov    0xc(%ebp),%eax
    fc03:	8b 00                	mov    (%eax),%eax
    fc05:	53                   	push   %ebx
    fc06:	51                   	push   %ecx
    fc07:	52                   	push   %edx
    fc08:	50                   	push   %eax
    fc09:	e8 76 97 ff ff       	call   9384 <lodepng_pixel_overflow>
    fc0e:	83 c4 10             	add    $0x10,%esp
    fc11:	85 c0                	test   %eax,%eax
    fc13:	74 12                	je     fc27 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    fc15:	8b 45 14             	mov    0x14(%ebp),%eax
    fc18:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    fc1f:	00 00 00 
    fc22:	e9 ea 09 00 00       	jmp    10611 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    fc27:	83 ec 0c             	sub    $0xc,%esp
    fc2a:	ff 75 1c             	pushl  0x1c(%ebp)
    fc2d:	e8 a6 3a ff ff       	call   36d8 <lodepng_malloc>
    fc32:	83 c4 10             	add    $0x10,%esp
    fc35:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    fc38:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    fc3c:	75 12                	jne    fc50 <decodeGeneric+0xf3>
    fc3e:	8b 45 14             	mov    0x14(%ebp),%eax
    fc41:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    fc48:	00 00 00 
    fc4b:	e9 c1 09 00 00       	jmp    10611 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    fc50:	8b 45 18             	mov    0x18(%ebp),%eax
    fc53:	83 c0 21             	add    $0x21,%eax
    fc56:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    fc59:	e9 81 06 00 00       	jmp    102df <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    fc5e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fc61:	8b 45 18             	mov    0x18(%ebp),%eax
    fc64:	29 c2                	sub    %eax,%edx
    fc66:	89 d0                	mov    %edx,%eax
    fc68:	83 c0 0c             	add    $0xc,%eax
    fc6b:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fc6e:	7f 08                	jg     fc78 <decodeGeneric+0x11b>
    fc70:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fc73:	3b 45 18             	cmp    0x18(%ebp),%eax
    fc76:	73 20                	jae    fc98 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fc78:	8b 45 14             	mov    0x14(%ebp),%eax
    fc7b:	8b 40 20             	mov    0x20(%eax),%eax
    fc7e:	85 c0                	test   %eax,%eax
    fc80:	0f 85 72 06 00 00    	jne    102f8 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    fc86:	8b 45 14             	mov    0x14(%ebp),%eax
    fc89:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    fc90:	00 00 00 
    fc93:	e9 6a 06 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    fc98:	83 ec 0c             	sub    $0xc,%esp
    fc9b:	ff 75 f0             	pushl  -0x10(%ebp)
    fc9e:	e8 b7 89 ff ff       	call   865a <lodepng_chunk_length>
    fca3:	83 c4 10             	add    $0x10,%esp
    fca6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    fca9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcac:	85 c0                	test   %eax,%eax
    fcae:	79 20                	jns    fcd0 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fcb0:	8b 45 14             	mov    0x14(%ebp),%eax
    fcb3:	8b 40 20             	mov    0x20(%eax),%eax
    fcb6:	85 c0                	test   %eax,%eax
    fcb8:	0f 85 3d 06 00 00    	jne    102fb <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    fcbe:	8b 45 14             	mov    0x14(%ebp),%eax
    fcc1:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    fcc8:	00 00 00 
    fccb:	e9 32 06 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    fcd0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fcd3:	8b 45 18             	mov    0x18(%ebp),%eax
    fcd6:	29 c2                	sub    %eax,%edx
    fcd8:	89 d0                	mov    %edx,%eax
    fcda:	89 c2                	mov    %eax,%edx
    fcdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcdf:	01 d0                	add    %edx,%eax
    fce1:	83 c0 0c             	add    $0xc,%eax
    fce4:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fce7:	7f 10                	jg     fcf9 <decodeGeneric+0x19c>
    fce9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcec:	8d 50 0c             	lea    0xc(%eax),%edx
    fcef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fcf2:	01 d0                	add    %edx,%eax
    fcf4:	3b 45 18             	cmp    0x18(%ebp),%eax
    fcf7:	73 12                	jae    fd0b <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    fcf9:	8b 45 14             	mov    0x14(%ebp),%eax
    fcfc:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    fd03:	00 00 00 
    fd06:	e9 f7 05 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    fd0b:	83 ec 0c             	sub    $0xc,%esp
    fd0e:	ff 75 f0             	pushl  -0x10(%ebp)
    fd11:	e8 7c 8a ff ff       	call   8792 <lodepng_chunk_data_const>
    fd16:	83 c4 10             	add    $0x10,%esp
    fd19:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    fd1c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    fd23:	83 ec 08             	sub    $0x8,%esp
    fd26:	68 e4 a4 01 00       	push   $0x1a4e4
    fd2b:	ff 75 f0             	pushl  -0x10(%ebp)
    fd2e:	e8 74 89 ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fd33:	83 c4 10             	add    $0x10,%esp
    fd36:	84 c0                	test   %al,%al
    fd38:	74 79                	je     fdb3 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    fd3a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd3d:	83 ec 04             	sub    $0x4,%esp
    fd40:	8d 55 bc             	lea    -0x44(%ebp),%edx
    fd43:	52                   	push   %edx
    fd44:	50                   	push   %eax
    fd45:	ff 75 ec             	pushl  -0x14(%ebp)
    fd48:	e8 4f 3a ff ff       	call   379c <lodepng_addofl>
    fd4d:	83 c4 10             	add    $0x10,%esp
    fd50:	85 c0                	test   %eax,%eax
    fd52:	74 12                	je     fd66 <decodeGeneric+0x209>
    fd54:	8b 45 14             	mov    0x14(%ebp),%eax
    fd57:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fd5e:	00 00 00 
    fd61:	e9 9c 05 00 00       	jmp    10302 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    fd66:	8b 45 bc             	mov    -0x44(%ebp),%eax
    fd69:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fd6c:	7e 13                	jle    fd81 <decodeGeneric+0x224>
    fd6e:	8b 45 14             	mov    0x14(%ebp),%eax
    fd71:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fd78:	00 00 00 
    fd7b:	90                   	nop
    fd7c:	e9 81 05 00 00       	jmp    10302 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    fd81:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd84:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    fd87:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fd8a:	01 ca                	add    %ecx,%edx
    fd8c:	83 ec 04             	sub    $0x4,%esp
    fd8f:	50                   	push   %eax
    fd90:	ff 75 d0             	pushl  -0x30(%ebp)
    fd93:	52                   	push   %edx
    fd94:	e8 7d 39 ff ff       	call   3716 <lodepng_memcpy>
    fd99:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    fd9c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fd9f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fda2:	01 d0                	add    %edx,%eax
    fda4:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    fda7:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    fdae:	e9 db 04 00 00       	jmp    1028e <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fdb3:	83 ec 08             	sub    $0x8,%esp
    fdb6:	68 e9 a4 01 00       	push   $0x1a4e9
    fdbb:	ff 75 f0             	pushl  -0x10(%ebp)
    fdbe:	e8 e4 88 ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fdc3:	83 c4 10             	add    $0x10,%esp
    fdc6:	84 c0                	test   %al,%al
    fdc8:	74 09                	je     fdd3 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fdca:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fdce:	e9 bb 04 00 00       	jmp    1028e <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fdd3:	83 ec 08             	sub    $0x8,%esp
    fdd6:	68 a8 a4 01 00       	push   $0x1a4a8
    fddb:	ff 75 f0             	pushl  -0x10(%ebp)
    fdde:	e8 c4 88 ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fde3:	83 c4 10             	add    $0x10,%esp
    fde6:	84 c0                	test   %al,%al
    fde8:	74 44                	je     fe2e <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fdea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fded:	8b 55 14             	mov    0x14(%ebp),%edx
    fdf0:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fdf6:	83 ec 04             	sub    $0x4,%esp
    fdf9:	50                   	push   %eax
    fdfa:	ff 75 d0             	pushl  -0x30(%ebp)
    fdfd:	52                   	push   %edx
    fdfe:	e8 ec e8 ff ff       	call   e6ef <readChunk_PLTE>
    fe03:	83 c4 10             	add    $0x10,%esp
    fe06:	89 c2                	mov    %eax,%edx
    fe08:	8b 45 14             	mov    0x14(%ebp),%eax
    fe0b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe11:	8b 45 14             	mov    0x14(%ebp),%eax
    fe14:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe1a:	85 c0                	test   %eax,%eax
    fe1c:	0f 85 dc 04 00 00    	jne    102fe <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fe22:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fe29:	e9 60 04 00 00       	jmp    1028e <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fe2e:	83 ec 08             	sub    $0x8,%esp
    fe31:	68 ad a4 01 00       	push   $0x1a4ad
    fe36:	ff 75 f0             	pushl  -0x10(%ebp)
    fe39:	e8 69 88 ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fe3e:	83 c4 10             	add    $0x10,%esp
    fe41:	84 c0                	test   %al,%al
    fe43:	74 3d                	je     fe82 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fe45:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe48:	8b 55 14             	mov    0x14(%ebp),%edx
    fe4b:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fe51:	83 ec 04             	sub    $0x4,%esp
    fe54:	50                   	push   %eax
    fe55:	ff 75 d0             	pushl  -0x30(%ebp)
    fe58:	52                   	push   %edx
    fe59:	e8 b1 e9 ff ff       	call   e80f <readChunk_tRNS>
    fe5e:	83 c4 10             	add    $0x10,%esp
    fe61:	89 c2                	mov    %eax,%edx
    fe63:	8b 45 14             	mov    0x14(%ebp),%eax
    fe66:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe6c:	8b 45 14             	mov    0x14(%ebp),%eax
    fe6f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe75:	85 c0                	test   %eax,%eax
    fe77:	0f 84 11 04 00 00    	je     1028e <decodeGeneric+0x731>
    fe7d:	e9 80 04 00 00       	jmp    10302 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fe82:	83 ec 08             	sub    $0x8,%esp
    fe85:	68 b2 a4 01 00       	push   $0x1a4b2
    fe8a:	ff 75 f0             	pushl  -0x10(%ebp)
    fe8d:	e8 15 88 ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fe92:	83 c4 10             	add    $0x10,%esp
    fe95:	84 c0                	test   %al,%al
    fe97:	74 3d                	je     fed6 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fe99:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe9c:	8b 55 14             	mov    0x14(%ebp),%edx
    fe9f:	81 c2 98 00 00 00    	add    $0x98,%edx
    fea5:	83 ec 04             	sub    $0x4,%esp
    fea8:	50                   	push   %eax
    fea9:	ff 75 d0             	pushl  -0x30(%ebp)
    feac:	52                   	push   %edx
    fead:	e8 c0 ea ff ff       	call   e972 <readChunk_bKGD>
    feb2:	83 c4 10             	add    $0x10,%esp
    feb5:	89 c2                	mov    %eax,%edx
    feb7:	8b 45 14             	mov    0x14(%ebp),%eax
    feba:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fec0:	8b 45 14             	mov    0x14(%ebp),%eax
    fec3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fec9:	85 c0                	test   %eax,%eax
    fecb:	0f 84 bd 03 00 00    	je     1028e <decodeGeneric+0x731>
    fed1:	e9 2c 04 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fed6:	83 ec 08             	sub    $0x8,%esp
    fed9:	68 b7 a4 01 00       	push   $0x1a4b7
    fede:	ff 75 f0             	pushl  -0x10(%ebp)
    fee1:	e8 c1 87 ff ff       	call   86a7 <lodepng_chunk_type_equals>
    fee6:	83 c4 10             	add    $0x10,%esp
    fee9:	84 c0                	test   %al,%al
    feeb:	74 4b                	je     ff38 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    feed:	8b 45 14             	mov    0x14(%ebp),%eax
    fef0:	8b 40 28             	mov    0x28(%eax),%eax
    fef3:	85 c0                	test   %eax,%eax
    fef5:	0f 84 93 03 00 00    	je     1028e <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fefb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fefe:	8b 55 14             	mov    0x14(%ebp),%edx
    ff01:	81 c2 98 00 00 00    	add    $0x98,%edx
    ff07:	83 ec 04             	sub    $0x4,%esp
    ff0a:	50                   	push   %eax
    ff0b:	ff 75 d0             	pushl  -0x30(%ebp)
    ff0e:	52                   	push   %edx
    ff0f:	e8 e1 eb ff ff       	call   eaf5 <readChunk_tEXt>
    ff14:	83 c4 10             	add    $0x10,%esp
    ff17:	89 c2                	mov    %eax,%edx
    ff19:	8b 45 14             	mov    0x14(%ebp),%eax
    ff1c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    ff22:	8b 45 14             	mov    0x14(%ebp),%eax
    ff25:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff2b:	85 c0                	test   %eax,%eax
    ff2d:	0f 84 5b 03 00 00    	je     1028e <decodeGeneric+0x731>
    ff33:	e9 ca 03 00 00       	jmp    10302 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    ff38:	83 ec 08             	sub    $0x8,%esp
    ff3b:	68 bc a4 01 00       	push   $0x1a4bc
    ff40:	ff 75 f0             	pushl  -0x10(%ebp)
    ff43:	e8 5f 87 ff ff       	call   86a7 <lodepng_chunk_type_equals>
    ff48:	83 c4 10             	add    $0x10,%esp
    ff4b:	84 c0                	test   %al,%al
    ff4d:	74 4c                	je     ff9b <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    ff4f:	8b 45 14             	mov    0x14(%ebp),%eax
    ff52:	8b 40 28             	mov    0x28(%eax),%eax
    ff55:	85 c0                	test   %eax,%eax
    ff57:	0f 84 31 03 00 00    	je     1028e <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    ff5d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    ff60:	8b 45 14             	mov    0x14(%ebp),%eax
    ff63:	8b 4d 14             	mov    0x14(%ebp),%ecx
    ff66:	81 c1 98 00 00 00    	add    $0x98,%ecx
    ff6c:	52                   	push   %edx
    ff6d:	ff 75 d0             	pushl  -0x30(%ebp)
    ff70:	50                   	push   %eax
    ff71:	51                   	push   %ecx
    ff72:	e8 ca ec ff ff       	call   ec41 <readChunk_zTXt>
    ff77:	83 c4 10             	add    $0x10,%esp
    ff7a:	89 c2                	mov    %eax,%edx
    ff7c:	8b 45 14             	mov    0x14(%ebp),%eax
    ff7f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    ff85:	8b 45 14             	mov    0x14(%ebp),%eax
    ff88:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff8e:	85 c0                	test   %eax,%eax
    ff90:	0f 84 f8 02 00 00    	je     1028e <decodeGeneric+0x731>
    ff96:	e9 67 03 00 00       	jmp    10302 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    ff9b:	83 ec 08             	sub    $0x8,%esp
    ff9e:	68 c1 a4 01 00       	push   $0x1a4c1
    ffa3:	ff 75 f0             	pushl  -0x10(%ebp)
    ffa6:	e8 fc 86 ff ff       	call   86a7 <lodepng_chunk_type_equals>
    ffab:	83 c4 10             	add    $0x10,%esp
    ffae:	84 c0                	test   %al,%al
    ffb0:	74 4c                	je     fffe <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    ffb2:	8b 45 14             	mov    0x14(%ebp),%eax
    ffb5:	8b 40 28             	mov    0x28(%eax),%eax
    ffb8:	85 c0                	test   %eax,%eax
    ffba:	0f 84 ce 02 00 00    	je     1028e <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    ffc0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    ffc3:	8b 45 14             	mov    0x14(%ebp),%eax
    ffc6:	8b 4d 14             	mov    0x14(%ebp),%ecx
    ffc9:	81 c1 98 00 00 00    	add    $0x98,%ecx
    ffcf:	52                   	push   %edx
    ffd0:	ff 75 d0             	pushl  -0x30(%ebp)
    ffd3:	50                   	push   %eax
    ffd4:	51                   	push   %ecx
    ffd5:	e8 23 ee ff ff       	call   edfd <readChunk_iTXt>
    ffda:	83 c4 10             	add    $0x10,%esp
    ffdd:	89 c2                	mov    %eax,%edx
    ffdf:	8b 45 14             	mov    0x14(%ebp),%eax
    ffe2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    ffe8:	8b 45 14             	mov    0x14(%ebp),%eax
    ffeb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fff1:	85 c0                	test   %eax,%eax
    fff3:	0f 84 95 02 00 00    	je     1028e <decodeGeneric+0x731>
    fff9:	e9 04 03 00 00       	jmp    10302 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fffe:	83 ec 08             	sub    $0x8,%esp
   10001:	68 c6 a4 01 00       	push   $0x1a4c6
   10006:	ff 75 f0             	pushl  -0x10(%ebp)
   10009:	e8 99 86 ff ff       	call   86a7 <lodepng_chunk_type_equals>
   1000e:	83 c4 10             	add    $0x10,%esp
   10011:	84 c0                	test   %al,%al
   10013:	74 3d                	je     10052 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
   10015:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10018:	8b 55 14             	mov    0x14(%ebp),%edx
   1001b:	81 c2 98 00 00 00    	add    $0x98,%edx
   10021:	83 ec 04             	sub    $0x4,%esp
   10024:	50                   	push   %eax
   10025:	ff 75 d0             	pushl  -0x30(%ebp)
   10028:	52                   	push   %edx
   10029:	e8 25 f1 ff ff       	call   f153 <readChunk_tIME>
   1002e:	83 c4 10             	add    $0x10,%esp
   10031:	89 c2                	mov    %eax,%edx
   10033:	8b 45 14             	mov    0x14(%ebp),%eax
   10036:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1003c:	8b 45 14             	mov    0x14(%ebp),%eax
   1003f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10045:	85 c0                	test   %eax,%eax
   10047:	0f 84 41 02 00 00    	je     1028e <decodeGeneric+0x731>
   1004d:	e9 b0 02 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   10052:	83 ec 08             	sub    $0x8,%esp
   10055:	68 cb a4 01 00       	push   $0x1a4cb
   1005a:	ff 75 f0             	pushl  -0x10(%ebp)
   1005d:	e8 45 86 ff ff       	call   86a7 <lodepng_chunk_type_equals>
   10062:	83 c4 10             	add    $0x10,%esp
   10065:	84 c0                	test   %al,%al
   10067:	74 3d                	je     100a6 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
   10069:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1006c:	8b 55 14             	mov    0x14(%ebp),%edx
   1006f:	81 c2 98 00 00 00    	add    $0x98,%edx
   10075:	83 ec 04             	sub    $0x4,%esp
   10078:	50                   	push   %eax
   10079:	ff 75 d0             	pushl  -0x30(%ebp)
   1007c:	52                   	push   %edx
   1007d:	e8 71 f1 ff ff       	call   f1f3 <readChunk_pHYs>
   10082:	83 c4 10             	add    $0x10,%esp
   10085:	89 c2                	mov    %eax,%edx
   10087:	8b 45 14             	mov    0x14(%ebp),%eax
   1008a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10090:	8b 45 14             	mov    0x14(%ebp),%eax
   10093:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10099:	85 c0                	test   %eax,%eax
   1009b:	0f 84 ed 01 00 00    	je     1028e <decodeGeneric+0x731>
   100a1:	e9 5c 02 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   100a6:	83 ec 08             	sub    $0x8,%esp
   100a9:	68 d0 a4 01 00       	push   $0x1a4d0
   100ae:	ff 75 f0             	pushl  -0x10(%ebp)
   100b1:	e8 f1 85 ff ff       	call   86a7 <lodepng_chunk_type_equals>
   100b6:	83 c4 10             	add    $0x10,%esp
   100b9:	84 c0                	test   %al,%al
   100bb:	74 3d                	je     100fa <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
   100bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   100c0:	8b 55 14             	mov    0x14(%ebp),%edx
   100c3:	81 c2 98 00 00 00    	add    $0x98,%edx
   100c9:	83 ec 04             	sub    $0x4,%esp
   100cc:	50                   	push   %eax
   100cd:	ff 75 d0             	pushl  -0x30(%ebp)
   100d0:	52                   	push   %edx
   100d1:	e8 ec f1 ff ff       	call   f2c2 <readChunk_gAMA>
   100d6:	83 c4 10             	add    $0x10,%esp
   100d9:	89 c2                	mov    %eax,%edx
   100db:	8b 45 14             	mov    0x14(%ebp),%eax
   100de:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   100e4:	8b 45 14             	mov    0x14(%ebp),%eax
   100e7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   100ed:	85 c0                	test   %eax,%eax
   100ef:	0f 84 99 01 00 00    	je     1028e <decodeGeneric+0x731>
   100f5:	e9 08 02 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   100fa:	83 ec 08             	sub    $0x8,%esp
   100fd:	68 d5 a4 01 00       	push   $0x1a4d5
   10102:	ff 75 f0             	pushl  -0x10(%ebp)
   10105:	e8 9d 85 ff ff       	call   86a7 <lodepng_chunk_type_equals>
   1010a:	83 c4 10             	add    $0x10,%esp
   1010d:	84 c0                	test   %al,%al
   1010f:	74 3d                	je     1014e <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   10111:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10114:	8b 55 14             	mov    0x14(%ebp),%edx
   10117:	81 c2 98 00 00 00    	add    $0x98,%edx
   1011d:	83 ec 04             	sub    $0x4,%esp
   10120:	50                   	push   %eax
   10121:	ff 75 d0             	pushl  -0x30(%ebp)
   10124:	52                   	push   %edx
   10125:	e8 07 f2 ff ff       	call   f331 <readChunk_cHRM>
   1012a:	83 c4 10             	add    $0x10,%esp
   1012d:	89 c2                	mov    %eax,%edx
   1012f:	8b 45 14             	mov    0x14(%ebp),%eax
   10132:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10138:	8b 45 14             	mov    0x14(%ebp),%eax
   1013b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10141:	85 c0                	test   %eax,%eax
   10143:	0f 84 45 01 00 00    	je     1028e <decodeGeneric+0x731>
   10149:	e9 b4 01 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   1014e:	83 ec 08             	sub    $0x8,%esp
   10151:	68 da a4 01 00       	push   $0x1a4da
   10156:	ff 75 f0             	pushl  -0x10(%ebp)
   10159:	e8 49 85 ff ff       	call   86a7 <lodepng_chunk_type_equals>
   1015e:	83 c4 10             	add    $0x10,%esp
   10161:	84 c0                	test   %al,%al
   10163:	74 3d                	je     101a2 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   10165:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10168:	8b 55 14             	mov    0x14(%ebp),%edx
   1016b:	81 c2 98 00 00 00    	add    $0x98,%edx
   10171:	83 ec 04             	sub    $0x4,%esp
   10174:	50                   	push   %eax
   10175:	ff 75 d0             	pushl  -0x30(%ebp)
   10178:	52                   	push   %edx
   10179:	e8 47 f4 ff ff       	call   f5c5 <readChunk_sRGB>
   1017e:	83 c4 10             	add    $0x10,%esp
   10181:	89 c2                	mov    %eax,%edx
   10183:	8b 45 14             	mov    0x14(%ebp),%eax
   10186:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1018c:	8b 45 14             	mov    0x14(%ebp),%eax
   1018f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10195:	85 c0                	test   %eax,%eax
   10197:	0f 84 f1 00 00 00    	je     1028e <decodeGeneric+0x731>
   1019d:	e9 60 01 00 00       	jmp    10302 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   101a2:	83 ec 08             	sub    $0x8,%esp
   101a5:	68 df a4 01 00       	push   $0x1a4df
   101aa:	ff 75 f0             	pushl  -0x10(%ebp)
   101ad:	e8 f5 84 ff ff       	call   86a7 <lodepng_chunk_type_equals>
   101b2:	83 c4 10             	add    $0x10,%esp
   101b5:	84 c0                	test   %al,%al
   101b7:	74 3e                	je     101f7 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   101b9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   101bc:	8b 45 14             	mov    0x14(%ebp),%eax
   101bf:	8b 4d 14             	mov    0x14(%ebp),%ecx
   101c2:	81 c1 98 00 00 00    	add    $0x98,%ecx
   101c8:	52                   	push   %edx
   101c9:	ff 75 d0             	pushl  -0x30(%ebp)
   101cc:	50                   	push   %eax
   101cd:	51                   	push   %ecx
   101ce:	e8 28 f4 ff ff       	call   f5fb <readChunk_iCCP>
   101d3:	83 c4 10             	add    $0x10,%esp
   101d6:	89 c2                	mov    %eax,%edx
   101d8:	8b 45 14             	mov    0x14(%ebp),%eax
   101db:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   101e1:	8b 45 14             	mov    0x14(%ebp),%eax
   101e4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101ea:	85 c0                	test   %eax,%eax
   101ec:	0f 84 9c 00 00 00    	je     1028e <decodeGeneric+0x731>
   101f2:	e9 0b 01 00 00       	jmp    10302 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   101f7:	8b 45 14             	mov    0x14(%ebp),%eax
   101fa:	8b 40 1c             	mov    0x1c(%eax),%eax
   101fd:	85 c0                	test   %eax,%eax
   101ff:	75 24                	jne    10225 <decodeGeneric+0x6c8>
   10201:	83 ec 0c             	sub    $0xc,%esp
   10204:	ff 75 f0             	pushl  -0x10(%ebp)
   10207:	e8 30 85 ff ff       	call   873c <lodepng_chunk_ancillary>
   1020c:	83 c4 10             	add    $0x10,%esp
   1020f:	84 c0                	test   %al,%al
   10211:	75 12                	jne    10225 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   10213:	8b 45 14             	mov    0x14(%ebp),%eax
   10216:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   1021d:	00 00 00 
   10220:	e9 dd 00 00 00       	jmp    10302 <decodeGeneric+0x7a5>
      }

      unknown = 1;
   10225:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   1022c:	8b 45 14             	mov    0x14(%ebp),%eax
   1022f:	8b 40 2c             	mov    0x2c(%eax),%eax
   10232:	85 c0                	test   %eax,%eax
   10234:	74 58                	je     1028e <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   10236:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10239:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   1023c:	83 c0 58             	add    $0x58,%eax
   1023f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10246:	8b 45 14             	mov    0x14(%ebp),%eax
   10249:	01 d0                	add    %edx,%eax
   1024b:	8d 50 10             	lea    0x10(%eax),%edx
   1024e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10251:	83 e8 01             	sub    $0x1,%eax
   10254:	83 c0 54             	add    $0x54,%eax
   10257:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   1025e:	8b 45 14             	mov    0x14(%ebp),%eax
   10261:	01 c8                	add    %ecx,%eax
   10263:	83 c0 14             	add    $0x14,%eax
   10266:	83 ec 04             	sub    $0x4,%esp
   10269:	ff 75 f0             	pushl  -0x10(%ebp)
   1026c:	52                   	push   %edx
   1026d:	50                   	push   %eax
   1026e:	e8 15 88 ff ff       	call   8a88 <lodepng_chunk_append>
   10273:	83 c4 10             	add    $0x10,%esp
   10276:	89 c2                	mov    %eax,%edx
   10278:	8b 45 14             	mov    0x14(%ebp),%eax
   1027b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10281:	8b 45 14             	mov    0x14(%ebp),%eax
   10284:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1028a:	85 c0                	test   %eax,%eax
   1028c:	75 73                	jne    10301 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   1028e:	8b 45 14             	mov    0x14(%ebp),%eax
   10291:	8b 40 18             	mov    0x18(%eax),%eax
   10294:	85 c0                	test   %eax,%eax
   10296:	75 27                	jne    102bf <decodeGeneric+0x762>
   10298:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1029c:	75 21                	jne    102bf <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   1029e:	83 ec 0c             	sub    $0xc,%esp
   102a1:	ff 75 f0             	pushl  -0x10(%ebp)
   102a4:	e8 f4 84 ff ff       	call   879d <lodepng_chunk_check_crc>
   102a9:	83 c4 10             	add    $0x10,%esp
   102ac:	85 c0                	test   %eax,%eax
   102ae:	74 0f                	je     102bf <decodeGeneric+0x762>
   102b0:	8b 45 14             	mov    0x14(%ebp),%eax
   102b3:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   102ba:	00 00 00 
   102bd:	eb 43                	jmp    10302 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   102bf:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   102c3:	75 1a                	jne    102df <decodeGeneric+0x782>
   102c5:	8b 55 1c             	mov    0x1c(%ebp),%edx
   102c8:	8b 45 18             	mov    0x18(%ebp),%eax
   102cb:	01 d0                	add    %edx,%eax
   102cd:	83 ec 08             	sub    $0x8,%esp
   102d0:	50                   	push   %eax
   102d1:	ff 75 f0             	pushl  -0x10(%ebp)
   102d4:	e8 3f 86 ff ff       	call   8918 <lodepng_chunk_next_const>
   102d9:	83 c4 10             	add    $0x10,%esp
   102dc:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   102df:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   102e3:	75 1d                	jne    10302 <decodeGeneric+0x7a5>
   102e5:	8b 45 14             	mov    0x14(%ebp),%eax
   102e8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102ee:	85 c0                	test   %eax,%eax
   102f0:	0f 84 68 f9 ff ff    	je     fc5e <decodeGeneric+0x101>
   102f6:	eb 0a                	jmp    10302 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   102f8:	90                   	nop
   102f9:	eb 07                	jmp    10302 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   102fb:	90                   	nop
   102fc:	eb 04                	jmp    10302 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   102fe:	90                   	nop
   102ff:	eb 01                	jmp    10302 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10301:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   10302:	8b 45 14             	mov    0x14(%ebp),%eax
   10305:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1030b:	85 c0                	test   %eax,%eax
   1030d:	75 28                	jne    10337 <decodeGeneric+0x7da>
   1030f:	8b 45 14             	mov    0x14(%ebp),%eax
   10312:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   10318:	83 f8 03             	cmp    $0x3,%eax
   1031b:	75 1a                	jne    10337 <decodeGeneric+0x7da>
   1031d:	8b 45 14             	mov    0x14(%ebp),%eax
   10320:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10326:	85 c0                	test   %eax,%eax
   10328:	75 0d                	jne    10337 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   1032a:	8b 45 14             	mov    0x14(%ebp),%eax
   1032d:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   10334:	00 00 00 
  }

  if(!state->error) {
   10337:	8b 45 14             	mov    0x14(%ebp),%eax
   1033a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10340:	85 c0                	test   %eax,%eax
   10342:	0f 85 d2 01 00 00    	jne    1051a <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   10348:	8b 45 14             	mov    0x14(%ebp),%eax
   1034b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   10351:	85 c0                	test   %eax,%eax
   10353:	75 3a                	jne    1038f <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10355:	8b 45 14             	mov    0x14(%ebp),%eax
   10358:	05 a4 00 00 00       	add    $0xa4,%eax
   1035d:	83 ec 0c             	sub    $0xc,%esp
   10360:	50                   	push   %eax
   10361:	e8 8e 8e ff ff       	call   91f4 <lodepng_get_bpp>
   10366:	83 c4 10             	add    $0x10,%esp
   10369:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   1036c:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   1036f:	8b 45 10             	mov    0x10(%ebp),%eax
   10372:	8b 10                	mov    (%eax),%edx
   10374:	8b 45 0c             	mov    0xc(%ebp),%eax
   10377:	8b 00                	mov    (%eax),%eax
   10379:	83 ec 04             	sub    $0x4,%esp
   1037c:	51                   	push   %ecx
   1037d:	52                   	push   %edx
   1037e:	50                   	push   %eax
   1037f:	e8 cf 8f ff ff       	call   9353 <lodepng_get_raw_size_idat>
   10384:	83 c4 10             	add    $0x10,%esp
   10387:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1038a:	e9 60 01 00 00       	jmp    104ef <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   1038f:	8b 45 14             	mov    0x14(%ebp),%eax
   10392:	05 a4 00 00 00       	add    $0xa4,%eax
   10397:	83 ec 0c             	sub    $0xc,%esp
   1039a:	50                   	push   %eax
   1039b:	e8 54 8e ff ff       	call   91f4 <lodepng_get_bpp>
   103a0:	83 c4 10             	add    $0x10,%esp
   103a3:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   103a6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   103ad:	8b 45 c8             	mov    -0x38(%ebp),%eax
   103b0:	8b 55 10             	mov    0x10(%ebp),%edx
   103b3:	8b 12                	mov    (%edx),%edx
   103b5:	83 c2 07             	add    $0x7,%edx
   103b8:	89 d1                	mov    %edx,%ecx
   103ba:	c1 e9 03             	shr    $0x3,%ecx
   103bd:	8b 55 0c             	mov    0xc(%ebp),%edx
   103c0:	8b 12                	mov    (%edx),%edx
   103c2:	83 c2 07             	add    $0x7,%edx
   103c5:	c1 ea 03             	shr    $0x3,%edx
   103c8:	83 ec 04             	sub    $0x4,%esp
   103cb:	50                   	push   %eax
   103cc:	51                   	push   %ecx
   103cd:	52                   	push   %edx
   103ce:	e8 80 8f ff ff       	call   9353 <lodepng_get_raw_size_idat>
   103d3:	83 c4 10             	add    $0x10,%esp
   103d6:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   103d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   103dc:	8b 00                	mov    (%eax),%eax
   103de:	83 f8 04             	cmp    $0x4,%eax
   103e1:	76 2c                	jbe    1040f <decodeGeneric+0x8b2>
   103e3:	8b 45 c8             	mov    -0x38(%ebp),%eax
   103e6:	8b 55 10             	mov    0x10(%ebp),%edx
   103e9:	8b 12                	mov    (%edx),%edx
   103eb:	83 c2 07             	add    $0x7,%edx
   103ee:	89 d1                	mov    %edx,%ecx
   103f0:	c1 e9 03             	shr    $0x3,%ecx
   103f3:	8b 55 0c             	mov    0xc(%ebp),%edx
   103f6:	8b 12                	mov    (%edx),%edx
   103f8:	83 c2 03             	add    $0x3,%edx
   103fb:	c1 ea 03             	shr    $0x3,%edx
   103fe:	83 ec 04             	sub    $0x4,%esp
   10401:	50                   	push   %eax
   10402:	51                   	push   %ecx
   10403:	52                   	push   %edx
   10404:	e8 4a 8f ff ff       	call   9353 <lodepng_get_raw_size_idat>
   10409:	83 c4 10             	add    $0x10,%esp
   1040c:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   1040f:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10412:	8b 55 10             	mov    0x10(%ebp),%edx
   10415:	8b 12                	mov    (%edx),%edx
   10417:	83 c2 03             	add    $0x3,%edx
   1041a:	89 d1                	mov    %edx,%ecx
   1041c:	c1 e9 03             	shr    $0x3,%ecx
   1041f:	8b 55 0c             	mov    0xc(%ebp),%edx
   10422:	8b 12                	mov    (%edx),%edx
   10424:	83 c2 03             	add    $0x3,%edx
   10427:	c1 ea 02             	shr    $0x2,%edx
   1042a:	83 ec 04             	sub    $0x4,%esp
   1042d:	50                   	push   %eax
   1042e:	51                   	push   %ecx
   1042f:	52                   	push   %edx
   10430:	e8 1e 8f ff ff       	call   9353 <lodepng_get_raw_size_idat>
   10435:	83 c4 10             	add    $0x10,%esp
   10438:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   1043b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1043e:	8b 00                	mov    (%eax),%eax
   10440:	83 f8 02             	cmp    $0x2,%eax
   10443:	76 2c                	jbe    10471 <decodeGeneric+0x914>
   10445:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10448:	8b 55 10             	mov    0x10(%ebp),%edx
   1044b:	8b 12                	mov    (%edx),%edx
   1044d:	83 c2 03             	add    $0x3,%edx
   10450:	89 d1                	mov    %edx,%ecx
   10452:	c1 e9 02             	shr    $0x2,%ecx
   10455:	8b 55 0c             	mov    0xc(%ebp),%edx
   10458:	8b 12                	mov    (%edx),%edx
   1045a:	83 c2 01             	add    $0x1,%edx
   1045d:	c1 ea 02             	shr    $0x2,%edx
   10460:	83 ec 04             	sub    $0x4,%esp
   10463:	50                   	push   %eax
   10464:	51                   	push   %ecx
   10465:	52                   	push   %edx
   10466:	e8 e8 8e ff ff       	call   9353 <lodepng_get_raw_size_idat>
   1046b:	83 c4 10             	add    $0x10,%esp
   1046e:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   10471:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10474:	8b 55 10             	mov    0x10(%ebp),%edx
   10477:	8b 12                	mov    (%edx),%edx
   10479:	83 c2 01             	add    $0x1,%edx
   1047c:	89 d1                	mov    %edx,%ecx
   1047e:	c1 e9 02             	shr    $0x2,%ecx
   10481:	8b 55 0c             	mov    0xc(%ebp),%edx
   10484:	8b 12                	mov    (%edx),%edx
   10486:	83 c2 01             	add    $0x1,%edx
   10489:	d1 ea                	shr    %edx
   1048b:	83 ec 04             	sub    $0x4,%esp
   1048e:	50                   	push   %eax
   1048f:	51                   	push   %ecx
   10490:	52                   	push   %edx
   10491:	e8 bd 8e ff ff       	call   9353 <lodepng_get_raw_size_idat>
   10496:	83 c4 10             	add    $0x10,%esp
   10499:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   1049c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1049f:	8b 00                	mov    (%eax),%eax
   104a1:	83 f8 01             	cmp    $0x1,%eax
   104a4:	76 27                	jbe    104cd <decodeGeneric+0x970>
   104a6:	8b 45 c8             	mov    -0x38(%ebp),%eax
   104a9:	8b 55 10             	mov    0x10(%ebp),%edx
   104ac:	8b 12                	mov    (%edx),%edx
   104ae:	83 c2 01             	add    $0x1,%edx
   104b1:	89 d1                	mov    %edx,%ecx
   104b3:	d1 e9                	shr    %ecx
   104b5:	8b 55 0c             	mov    0xc(%ebp),%edx
   104b8:	8b 12                	mov    (%edx),%edx
   104ba:	d1 ea                	shr    %edx
   104bc:	83 ec 04             	sub    $0x4,%esp
   104bf:	50                   	push   %eax
   104c0:	51                   	push   %ecx
   104c1:	52                   	push   %edx
   104c2:	e8 8c 8e ff ff       	call   9353 <lodepng_get_raw_size_idat>
   104c7:	83 c4 10             	add    $0x10,%esp
   104ca:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   104cd:	8b 55 c8             	mov    -0x38(%ebp),%edx
   104d0:	8b 45 10             	mov    0x10(%ebp),%eax
   104d3:	8b 00                	mov    (%eax),%eax
   104d5:	d1 e8                	shr    %eax
   104d7:	89 c1                	mov    %eax,%ecx
   104d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   104dc:	8b 00                	mov    (%eax),%eax
   104de:	83 ec 04             	sub    $0x4,%esp
   104e1:	52                   	push   %edx
   104e2:	51                   	push   %ecx
   104e3:	50                   	push   %eax
   104e4:	e8 6a 8e ff ff       	call   9353 <lodepng_get_raw_size_idat>
   104e9:	83 c4 10             	add    $0x10,%esp
   104ec:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   104ef:	8b 45 14             	mov    0x14(%ebp),%eax
   104f2:	83 ec 08             	sub    $0x8,%esp
   104f5:	50                   	push   %eax
   104f6:	ff 75 ec             	pushl  -0x14(%ebp)
   104f9:	ff 75 d8             	pushl  -0x28(%ebp)
   104fc:	ff 75 e8             	pushl  -0x18(%ebp)
   104ff:	8d 45 c0             	lea    -0x40(%ebp),%eax
   10502:	50                   	push   %eax
   10503:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   10506:	50                   	push   %eax
   10507:	e8 87 7c ff ff       	call   8193 <zlib_decompress>
   1050c:	83 c4 20             	add    $0x20,%esp
   1050f:	89 c2                	mov    %eax,%edx
   10511:	8b 45 14             	mov    0x14(%ebp),%eax
   10514:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   1051a:	8b 45 14             	mov    0x14(%ebp),%eax
   1051d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10523:	85 c0                	test   %eax,%eax
   10525:	75 15                	jne    1053c <decodeGeneric+0x9df>
   10527:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1052a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1052d:	74 0d                	je     1053c <decodeGeneric+0x9df>
   1052f:	8b 45 14             	mov    0x14(%ebp),%eax
   10532:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10539:	00 00 00 
  lodepng_free(idat);
   1053c:	83 ec 0c             	sub    $0xc,%esp
   1053f:	ff 75 d8             	pushl  -0x28(%ebp)
   10542:	e8 b2 31 ff ff       	call   36f9 <lodepng_free>
   10547:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   1054a:	8b 45 14             	mov    0x14(%ebp),%eax
   1054d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10553:	85 c0                	test   %eax,%eax
   10555:	75 4f                	jne    105a6 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   10557:	8b 45 14             	mov    0x14(%ebp),%eax
   1055a:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   10560:	8b 45 10             	mov    0x10(%ebp),%eax
   10563:	8b 10                	mov    (%eax),%edx
   10565:	8b 45 0c             	mov    0xc(%ebp),%eax
   10568:	8b 00                	mov    (%eax),%eax
   1056a:	83 ec 04             	sub    $0x4,%esp
   1056d:	51                   	push   %ecx
   1056e:	52                   	push   %edx
   1056f:	50                   	push   %eax
   10570:	e8 be 8d ff ff       	call   9333 <lodepng_get_raw_size>
   10575:	83 c4 10             	add    $0x10,%esp
   10578:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1057b:	83 ec 0c             	sub    $0xc,%esp
   1057e:	ff 75 e4             	pushl  -0x1c(%ebp)
   10581:	e8 52 31 ff ff       	call   36d8 <lodepng_malloc>
   10586:	83 c4 10             	add    $0x10,%esp
   10589:	89 c2                	mov    %eax,%edx
   1058b:	8b 45 08             	mov    0x8(%ebp),%eax
   1058e:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   10590:	8b 45 08             	mov    0x8(%ebp),%eax
   10593:	8b 00                	mov    (%eax),%eax
   10595:	85 c0                	test   %eax,%eax
   10597:	75 0d                	jne    105a6 <decodeGeneric+0xa49>
   10599:	8b 45 14             	mov    0x14(%ebp),%eax
   1059c:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   105a3:	00 00 00 
  }
  if(!state->error) {
   105a6:	8b 45 14             	mov    0x14(%ebp),%eax
   105a9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   105af:	85 c0                	test   %eax,%eax
   105b1:	75 4c                	jne    105ff <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   105b3:	8b 45 08             	mov    0x8(%ebp),%eax
   105b6:	8b 00                	mov    (%eax),%eax
   105b8:	83 ec 04             	sub    $0x4,%esp
   105bb:	ff 75 e4             	pushl  -0x1c(%ebp)
   105be:	6a 00                	push   $0x0
   105c0:	50                   	push   %eax
   105c1:	e8 83 31 ff ff       	call   3749 <lodepng_memset>
   105c6:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   105c9:	8b 45 14             	mov    0x14(%ebp),%eax
   105cc:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   105d2:	8b 45 10             	mov    0x10(%ebp),%eax
   105d5:	8b 18                	mov    (%eax),%ebx
   105d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   105da:	8b 08                	mov    (%eax),%ecx
   105dc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   105df:	8b 45 08             	mov    0x8(%ebp),%eax
   105e2:	8b 00                	mov    (%eax),%eax
   105e4:	83 ec 0c             	sub    $0xc,%esp
   105e7:	56                   	push   %esi
   105e8:	53                   	push   %ebx
   105e9:	51                   	push   %ecx
   105ea:	52                   	push   %edx
   105eb:	50                   	push   %eax
   105ec:	e8 05 df ff ff       	call   e4f6 <postProcessScanlines>
   105f1:	83 c4 20             	add    $0x20,%esp
   105f4:	89 c2                	mov    %eax,%edx
   105f6:	8b 45 14             	mov    0x14(%ebp),%eax
   105f9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   105ff:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10602:	83 ec 0c             	sub    $0xc,%esp
   10605:	50                   	push   %eax
   10606:	e8 ee 30 ff ff       	call   36f9 <lodepng_free>
   1060b:	83 c4 10             	add    $0x10,%esp
   1060e:	eb 01                	jmp    10611 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   10610:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   10611:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10614:	5b                   	pop    %ebx
   10615:	5e                   	pop    %esi
   10616:	5d                   	pop    %ebp
   10617:	c3                   	ret    

00010618 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10618:	55                   	push   %ebp
   10619:	89 e5                	mov    %esp,%ebp
   1061b:	56                   	push   %esi
   1061c:	53                   	push   %ebx
   1061d:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   10620:	8b 45 08             	mov    0x8(%ebp),%eax
   10623:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10629:	83 ec 08             	sub    $0x8,%esp
   1062c:	ff 75 1c             	pushl  0x1c(%ebp)
   1062f:	ff 75 18             	pushl  0x18(%ebp)
   10632:	ff 75 14             	pushl  0x14(%ebp)
   10635:	ff 75 10             	pushl  0x10(%ebp)
   10638:	ff 75 0c             	pushl  0xc(%ebp)
   1063b:	ff 75 08             	pushl  0x8(%ebp)
   1063e:	e8 1a f5 ff ff       	call   fb5d <decodeGeneric>
   10643:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10646:	8b 45 14             	mov    0x14(%ebp),%eax
   10649:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1064f:	85 c0                	test   %eax,%eax
   10651:	74 0e                	je     10661 <lodepng_decode+0x49>
   10653:	8b 45 14             	mov    0x14(%ebp),%eax
   10656:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1065c:	e9 55 01 00 00       	jmp    107b6 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   10661:	8b 45 14             	mov    0x14(%ebp),%eax
   10664:	8b 40 24             	mov    0x24(%eax),%eax
   10667:	85 c0                	test   %eax,%eax
   10669:	74 20                	je     1068b <lodepng_decode+0x73>
   1066b:	8b 45 14             	mov    0x14(%ebp),%eax
   1066e:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10674:	8b 45 14             	mov    0x14(%ebp),%eax
   10677:	83 c0 78             	add    $0x78,%eax
   1067a:	83 ec 08             	sub    $0x8,%esp
   1067d:	52                   	push   %edx
   1067e:	50                   	push   %eax
   1067f:	e8 56 89 ff ff       	call   8fda <lodepng_color_mode_equal>
   10684:	83 c4 10             	add    $0x10,%esp
   10687:	85 c0                	test   %eax,%eax
   10689:	74 54                	je     106df <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   1068b:	8b 45 14             	mov    0x14(%ebp),%eax
   1068e:	8b 40 24             	mov    0x24(%eax),%eax
   10691:	85 c0                	test   %eax,%eax
   10693:	0f 85 13 01 00 00    	jne    107ac <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   10699:	8b 45 14             	mov    0x14(%ebp),%eax
   1069c:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   106a2:	8b 45 14             	mov    0x14(%ebp),%eax
   106a5:	83 c0 78             	add    $0x78,%eax
   106a8:	83 ec 08             	sub    $0x8,%esp
   106ab:	52                   	push   %edx
   106ac:	50                   	push   %eax
   106ad:	e8 3f 88 ff ff       	call   8ef1 <lodepng_color_mode_copy>
   106b2:	83 c4 10             	add    $0x10,%esp
   106b5:	89 c2                	mov    %eax,%edx
   106b7:	8b 45 14             	mov    0x14(%ebp),%eax
   106ba:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   106c0:	8b 45 14             	mov    0x14(%ebp),%eax
   106c3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   106c9:	85 c0                	test   %eax,%eax
   106cb:	0f 84 db 00 00 00    	je     107ac <lodepng_decode+0x194>
   106d1:	8b 45 14             	mov    0x14(%ebp),%eax
   106d4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   106da:	e9 d7 00 00 00       	jmp    107b6 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   106df:	8b 45 08             	mov    0x8(%ebp),%eax
   106e2:	8b 00                	mov    (%eax),%eax
   106e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   106e7:	8b 45 14             	mov    0x14(%ebp),%eax
   106ea:	8b 40 78             	mov    0x78(%eax),%eax
   106ed:	83 f8 02             	cmp    $0x2,%eax
   106f0:	74 20                	je     10712 <lodepng_decode+0xfa>
   106f2:	8b 45 14             	mov    0x14(%ebp),%eax
   106f5:	8b 40 78             	mov    0x78(%eax),%eax
   106f8:	83 f8 06             	cmp    $0x6,%eax
   106fb:	74 15                	je     10712 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   106fd:	8b 45 14             	mov    0x14(%ebp),%eax
   10700:	8b 40 7c             	mov    0x7c(%eax),%eax
   10703:	83 f8 08             	cmp    $0x8,%eax
   10706:	74 0a                	je     10712 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10708:	b8 38 00 00 00       	mov    $0x38,%eax
   1070d:	e9 a4 00 00 00       	jmp    107b6 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   10712:	8b 45 14             	mov    0x14(%ebp),%eax
   10715:	8d 48 78             	lea    0x78(%eax),%ecx
   10718:	8b 45 10             	mov    0x10(%ebp),%eax
   1071b:	8b 10                	mov    (%eax),%edx
   1071d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10720:	8b 00                	mov    (%eax),%eax
   10722:	83 ec 04             	sub    $0x4,%esp
   10725:	51                   	push   %ecx
   10726:	52                   	push   %edx
   10727:	50                   	push   %eax
   10728:	e8 06 8c ff ff       	call   9333 <lodepng_get_raw_size>
   1072d:	83 c4 10             	add    $0x10,%esp
   10730:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10733:	83 ec 0c             	sub    $0xc,%esp
   10736:	ff 75 f0             	pushl  -0x10(%ebp)
   10739:	e8 9a 2f ff ff       	call   36d8 <lodepng_malloc>
   1073e:	83 c4 10             	add    $0x10,%esp
   10741:	89 c2                	mov    %eax,%edx
   10743:	8b 45 08             	mov    0x8(%ebp),%eax
   10746:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10748:	8b 45 08             	mov    0x8(%ebp),%eax
   1074b:	8b 00                	mov    (%eax),%eax
   1074d:	85 c0                	test   %eax,%eax
   1074f:	75 0f                	jne    10760 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   10751:	8b 45 14             	mov    0x14(%ebp),%eax
   10754:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1075b:	00 00 00 
   1075e:	eb 3c                	jmp    1079c <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10760:	8b 45 10             	mov    0x10(%ebp),%eax
   10763:	8b 08                	mov    (%eax),%ecx
   10765:	8b 45 0c             	mov    0xc(%ebp),%eax
   10768:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   1076a:	8b 45 14             	mov    0x14(%ebp),%eax
   1076d:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10773:	8b 45 14             	mov    0x14(%ebp),%eax
   10776:	8d 58 78             	lea    0x78(%eax),%ebx
   10779:	8b 45 08             	mov    0x8(%ebp),%eax
   1077c:	8b 00                	mov    (%eax),%eax
   1077e:	83 ec 08             	sub    $0x8,%esp
   10781:	51                   	push   %ecx
   10782:	52                   	push   %edx
   10783:	56                   	push   %esi
   10784:	53                   	push   %ebx
   10785:	ff 75 f4             	pushl  -0xc(%ebp)
   10788:	50                   	push   %eax
   10789:	e8 51 b6 ff ff       	call   bddf <lodepng_convert>
   1078e:	83 c4 20             	add    $0x20,%esp
   10791:	89 c2                	mov    %eax,%edx
   10793:	8b 45 14             	mov    0x14(%ebp),%eax
   10796:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   1079c:	83 ec 0c             	sub    $0xc,%esp
   1079f:	ff 75 f4             	pushl  -0xc(%ebp)
   107a2:	e8 52 2f ff ff       	call   36f9 <lodepng_free>
   107a7:	83 c4 10             	add    $0x10,%esp
   107aa:	eb 01                	jmp    107ad <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   107ac:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   107ad:	8b 45 14             	mov    0x14(%ebp),%eax
   107b0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   107b6:	8d 65 f8             	lea    -0x8(%ebp),%esp
   107b9:	5b                   	pop    %ebx
   107ba:	5e                   	pop    %esi
   107bb:	5d                   	pop    %ebp
   107bc:	c3                   	ret    

000107bd <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   107bd:	55                   	push   %ebp
   107be:	89 e5                	mov    %esp,%ebp
   107c0:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   107c6:	83 ec 0c             	sub    $0xc,%esp
   107c9:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   107cf:	50                   	push   %eax
   107d0:	e8 d9 01 00 00       	call   109ae <lodepng_state_init>
   107d5:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   107d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   107db:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   107e1:	8b 45 20             	mov    0x20(%ebp),%eax
   107e4:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   107ea:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   107f1:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   107f4:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   107fb:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   107fe:	83 ec 08             	sub    $0x8,%esp
   10801:	ff 75 18             	pushl  0x18(%ebp)
   10804:	ff 75 14             	pushl  0x14(%ebp)
   10807:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1080d:	50                   	push   %eax
   1080e:	ff 75 10             	pushl  0x10(%ebp)
   10811:	ff 75 0c             	pushl  0xc(%ebp)
   10814:	ff 75 08             	pushl  0x8(%ebp)
   10817:	e8 fc fd ff ff       	call   10618 <lodepng_decode>
   1081c:	83 c4 20             	add    $0x20,%esp
   1081f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   10822:	83 ec 0c             	sub    $0xc,%esp
   10825:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1082b:	50                   	push   %eax
   1082c:	e8 d7 01 00 00       	call   10a08 <lodepng_state_cleanup>
   10831:	83 c4 10             	add    $0x10,%esp
  return error;
   10834:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10837:	c9                   	leave  
   10838:	c3                   	ret    

00010839 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10839:	55                   	push   %ebp
   1083a:	89 e5                	mov    %esp,%ebp
   1083c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   1083f:	83 ec 04             	sub    $0x4,%esp
   10842:	6a 08                	push   $0x8
   10844:	6a 06                	push   $0x6
   10846:	ff 75 18             	pushl  0x18(%ebp)
   10849:	ff 75 14             	pushl  0x14(%ebp)
   1084c:	ff 75 10             	pushl  0x10(%ebp)
   1084f:	ff 75 0c             	pushl  0xc(%ebp)
   10852:	ff 75 08             	pushl  0x8(%ebp)
   10855:	e8 63 ff ff ff       	call   107bd <lodepng_decode_memory>
   1085a:	83 c4 20             	add    $0x20,%esp
}
   1085d:	c9                   	leave  
   1085e:	c3                   	ret    

0001085f <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   1085f:	55                   	push   %ebp
   10860:	89 e5                	mov    %esp,%ebp
   10862:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   10865:	83 ec 04             	sub    $0x4,%esp
   10868:	6a 08                	push   $0x8
   1086a:	6a 02                	push   $0x2
   1086c:	ff 75 18             	pushl  0x18(%ebp)
   1086f:	ff 75 14             	pushl  0x14(%ebp)
   10872:	ff 75 10             	pushl  0x10(%ebp)
   10875:	ff 75 0c             	pushl  0xc(%ebp)
   10878:	ff 75 08             	pushl  0x8(%ebp)
   1087b:	e8 3d ff ff ff       	call   107bd <lodepng_decode_memory>
   10880:	83 c4 20             	add    $0x20,%esp
}
   10883:	c9                   	leave  
   10884:	c3                   	ret    

00010885 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   10885:	55                   	push   %ebp
   10886:	89 e5                	mov    %esp,%ebp
   10888:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   1088b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   10892:	8b 45 08             	mov    0x8(%ebp),%eax
   10895:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   1089b:	8b 45 10             	mov    0x10(%ebp),%eax
   1089e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   108a4:	8b 45 10             	mov    0x10(%ebp),%eax
   108a7:	8b 10                	mov    (%eax),%edx
   108a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   108ac:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   108ae:	83 ec 04             	sub    $0x4,%esp
   108b1:	ff 75 14             	pushl  0x14(%ebp)
   108b4:	8d 45 ec             	lea    -0x14(%ebp),%eax
   108b7:	50                   	push   %eax
   108b8:	8d 45 f0             	lea    -0x10(%ebp),%eax
   108bb:	50                   	push   %eax
   108bc:	e8 70 32 ff ff       	call   3b31 <lodepng_load_file>
   108c1:	83 c4 10             	add    $0x10,%esp
   108c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   108c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   108cb:	75 25                	jne    108f2 <lodepng_decode_file+0x6d>
   108cd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   108d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108d3:	83 ec 04             	sub    $0x4,%esp
   108d6:	ff 75 1c             	pushl  0x1c(%ebp)
   108d9:	ff 75 18             	pushl  0x18(%ebp)
   108dc:	52                   	push   %edx
   108dd:	50                   	push   %eax
   108de:	ff 75 10             	pushl  0x10(%ebp)
   108e1:	ff 75 0c             	pushl  0xc(%ebp)
   108e4:	ff 75 08             	pushl  0x8(%ebp)
   108e7:	e8 d1 fe ff ff       	call   107bd <lodepng_decode_memory>
   108ec:	83 c4 20             	add    $0x20,%esp
   108ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   108f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108f5:	83 ec 0c             	sub    $0xc,%esp
   108f8:	50                   	push   %eax
   108f9:	e8 fb 2d ff ff       	call   36f9 <lodepng_free>
   108fe:	83 c4 10             	add    $0x10,%esp
  return error;
   10901:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10904:	c9                   	leave  
   10905:	c3                   	ret    

00010906 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10906:	55                   	push   %ebp
   10907:	89 e5                	mov    %esp,%ebp
   10909:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   1090c:	83 ec 08             	sub    $0x8,%esp
   1090f:	6a 08                	push   $0x8
   10911:	6a 06                	push   $0x6
   10913:	ff 75 14             	pushl  0x14(%ebp)
   10916:	ff 75 10             	pushl  0x10(%ebp)
   10919:	ff 75 0c             	pushl  0xc(%ebp)
   1091c:	ff 75 08             	pushl  0x8(%ebp)
   1091f:	e8 61 ff ff ff       	call   10885 <lodepng_decode_file>
   10924:	83 c4 20             	add    $0x20,%esp
}
   10927:	c9                   	leave  
   10928:	c3                   	ret    

00010929 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10929:	55                   	push   %ebp
   1092a:	89 e5                	mov    %esp,%ebp
   1092c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   1092f:	83 ec 08             	sub    $0x8,%esp
   10932:	6a 08                	push   $0x8
   10934:	6a 02                	push   $0x2
   10936:	ff 75 14             	pushl  0x14(%ebp)
   10939:	ff 75 10             	pushl  0x10(%ebp)
   1093c:	ff 75 0c             	pushl  0xc(%ebp)
   1093f:	ff 75 08             	pushl  0x8(%ebp)
   10942:	e8 3e ff ff ff       	call   10885 <lodepng_decode_file>
   10947:	83 c4 20             	add    $0x20,%esp
}
   1094a:	c9                   	leave  
   1094b:	c3                   	ret    

0001094c <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   1094c:	55                   	push   %ebp
   1094d:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   1094f:	8b 45 08             	mov    0x8(%ebp),%eax
   10952:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10959:	8b 45 08             	mov    0x8(%ebp),%eax
   1095c:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   10963:	8b 45 08             	mov    0x8(%ebp),%eax
   10966:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   1096d:	8b 45 08             	mov    0x8(%ebp),%eax
   10970:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   10977:	8b 45 08             	mov    0x8(%ebp),%eax
   1097a:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   10981:	8b 45 08             	mov    0x8(%ebp),%eax
   10984:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   1098b:	8b 45 08             	mov    0x8(%ebp),%eax
   1098e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   10995:	8b 45 08             	mov    0x8(%ebp),%eax
   10998:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   1099f:	8b 45 08             	mov    0x8(%ebp),%eax
   109a2:	50                   	push   %eax
   109a3:	e8 ff 7a ff ff       	call   84a7 <lodepng_decompress_settings_init>
   109a8:	83 c4 04             	add    $0x4,%esp
}
   109ab:	90                   	nop
   109ac:	c9                   	leave  
   109ad:	c3                   	ret    

000109ae <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   109ae:	55                   	push   %ebp
   109af:	89 e5                	mov    %esp,%ebp
   109b1:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   109b4:	8b 45 08             	mov    0x8(%ebp),%eax
   109b7:	50                   	push   %eax
   109b8:	e8 8f ff ff ff       	call   1094c <lodepng_decoder_settings_init>
   109bd:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   109c0:	8b 45 08             	mov    0x8(%ebp),%eax
   109c3:	83 c0 38             	add    $0x38,%eax
   109c6:	83 ec 0c             	sub    $0xc,%esp
   109c9:	50                   	push   %eax
   109ca:	e8 fc 30 00 00       	call   13acb <lodepng_encoder_settings_init>
   109cf:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   109d2:	8b 45 08             	mov    0x8(%ebp),%eax
   109d5:	83 c0 78             	add    $0x78,%eax
   109d8:	83 ec 0c             	sub    $0xc,%esp
   109db:	50                   	push   %eax
   109dc:	e8 06 84 ff ff       	call   8de7 <lodepng_color_mode_init>
   109e1:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   109e4:	8b 45 08             	mov    0x8(%ebp),%eax
   109e7:	05 98 00 00 00       	add    $0x98,%eax
   109ec:	83 ec 0c             	sub    $0xc,%esp
   109ef:	50                   	push   %eax
   109f0:	e8 89 93 ff ff       	call   9d7e <lodepng_info_init>
   109f5:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   109f8:	8b 45 08             	mov    0x8(%ebp),%eax
   109fb:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   10a02:	00 00 00 
}
   10a05:	90                   	nop
   10a06:	c9                   	leave  
   10a07:	c3                   	ret    

00010a08 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10a08:	55                   	push   %ebp
   10a09:	89 e5                	mov    %esp,%ebp
   10a0b:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   10a0e:	8b 45 08             	mov    0x8(%ebp),%eax
   10a11:	83 c0 78             	add    $0x78,%eax
   10a14:	83 ec 0c             	sub    $0xc,%esp
   10a17:	50                   	push   %eax
   10a18:	e8 bd 84 ff ff       	call   8eda <lodepng_color_mode_cleanup>
   10a1d:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   10a20:	8b 45 08             	mov    0x8(%ebp),%eax
   10a23:	05 98 00 00 00       	add    $0x98,%eax
   10a28:	83 ec 0c             	sub    $0xc,%esp
   10a2b:	50                   	push   %eax
   10a2c:	e8 2e 94 ff ff       	call   9e5f <lodepng_info_cleanup>
   10a31:	83 c4 10             	add    $0x10,%esp
}
   10a34:	90                   	nop
   10a35:	c9                   	leave  
   10a36:	c3                   	ret    

00010a37 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10a37:	55                   	push   %ebp
   10a38:	89 e5                	mov    %esp,%ebp
   10a3a:	57                   	push   %edi
   10a3b:	56                   	push   %esi
   10a3c:	53                   	push   %ebx
   10a3d:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   10a40:	83 ec 0c             	sub    $0xc,%esp
   10a43:	ff 75 08             	pushl  0x8(%ebp)
   10a46:	e8 bd ff ff ff       	call   10a08 <lodepng_state_cleanup>
   10a4b:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   10a4e:	8b 55 08             	mov    0x8(%ebp),%edx
   10a51:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a54:	89 c3                	mov    %eax,%ebx
   10a56:	b8 60 00 00 00       	mov    $0x60,%eax
   10a5b:	89 d7                	mov    %edx,%edi
   10a5d:	89 de                	mov    %ebx,%esi
   10a5f:	89 c1                	mov    %eax,%ecx
   10a61:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   10a63:	8b 45 08             	mov    0x8(%ebp),%eax
   10a66:	83 c0 78             	add    $0x78,%eax
   10a69:	83 ec 0c             	sub    $0xc,%esp
   10a6c:	50                   	push   %eax
   10a6d:	e8 75 83 ff ff       	call   8de7 <lodepng_color_mode_init>
   10a72:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   10a75:	8b 45 08             	mov    0x8(%ebp),%eax
   10a78:	05 98 00 00 00       	add    $0x98,%eax
   10a7d:	83 ec 0c             	sub    $0xc,%esp
   10a80:	50                   	push   %eax
   10a81:	e8 f8 92 ff ff       	call   9d7e <lodepng_info_init>
   10a86:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10a89:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a8c:	8d 50 78             	lea    0x78(%eax),%edx
   10a8f:	8b 45 08             	mov    0x8(%ebp),%eax
   10a92:	83 c0 78             	add    $0x78,%eax
   10a95:	83 ec 08             	sub    $0x8,%esp
   10a98:	52                   	push   %edx
   10a99:	50                   	push   %eax
   10a9a:	e8 52 84 ff ff       	call   8ef1 <lodepng_color_mode_copy>
   10a9f:	83 c4 10             	add    $0x10,%esp
   10aa2:	89 c2                	mov    %eax,%edx
   10aa4:	8b 45 08             	mov    0x8(%ebp),%eax
   10aa7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10aad:	8b 45 08             	mov    0x8(%ebp),%eax
   10ab0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10ab6:	85 c0                	test   %eax,%eax
   10ab8:	75 36                	jne    10af0 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   10aba:	8b 45 0c             	mov    0xc(%ebp),%eax
   10abd:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   10ac3:	8b 45 08             	mov    0x8(%ebp),%eax
   10ac6:	05 98 00 00 00       	add    $0x98,%eax
   10acb:	83 ec 08             	sub    $0x8,%esp
   10ace:	52                   	push   %edx
   10acf:	50                   	push   %eax
   10ad0:	e8 dd 93 ff ff       	call   9eb2 <lodepng_info_copy>
   10ad5:	83 c4 10             	add    $0x10,%esp
   10ad8:	89 c2                	mov    %eax,%edx
   10ada:	8b 45 08             	mov    0x8(%ebp),%eax
   10add:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10ae3:	8b 45 08             	mov    0x8(%ebp),%eax
   10ae6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10aec:	85 c0                	test   %eax,%eax
   10aee:	eb 01                	jmp    10af1 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10af0:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   10af1:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10af4:	5b                   	pop    %ebx
   10af5:	5e                   	pop    %esi
   10af6:	5f                   	pop    %edi
   10af7:	5d                   	pop    %ebp
   10af8:	c3                   	ret    

00010af9 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10af9:	55                   	push   %ebp
   10afa:	89 e5                	mov    %esp,%ebp
   10afc:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   10aff:	8b 45 08             	mov    0x8(%ebp),%eax
   10b02:	8b 40 04             	mov    0x4(%eax),%eax
   10b05:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10b08:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10b0c:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   10b10:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   10b14:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10b18:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10b1c:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   10b20:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   10b24:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10b28:	8b 45 08             	mov    0x8(%ebp),%eax
   10b2b:	8b 40 04             	mov    0x4(%eax),%eax
   10b2e:	83 c0 08             	add    $0x8,%eax
   10b31:	50                   	push   %eax
   10b32:	ff 75 08             	pushl  0x8(%ebp)
   10b35:	e8 f8 2d ff ff       	call   3932 <ucvector_resize>
   10b3a:	83 c4 08             	add    $0x8,%esp
   10b3d:	85 c0                	test   %eax,%eax
   10b3f:	75 07                	jne    10b48 <writeSignature+0x4f>
   10b41:	b8 53 00 00 00       	mov    $0x53,%eax
   10b46:	eb 1e                	jmp    10b66 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10b48:	8b 45 08             	mov    0x8(%ebp),%eax
   10b4b:	8b 10                	mov    (%eax),%edx
   10b4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10b50:	01 c2                	add    %eax,%edx
   10b52:	6a 08                	push   $0x8
   10b54:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10b57:	50                   	push   %eax
   10b58:	52                   	push   %edx
   10b59:	e8 b8 2b ff ff       	call   3716 <lodepng_memcpy>
   10b5e:	83 c4 0c             	add    $0xc,%esp
  return 0;
   10b61:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b66:	c9                   	leave  
   10b67:	c3                   	ret    

00010b68 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   10b68:	55                   	push   %ebp
   10b69:	89 e5                	mov    %esp,%ebp
   10b6b:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10b6e:	68 8c a4 01 00       	push   $0x1a48c
   10b73:	6a 0d                	push   $0xd
   10b75:	ff 75 08             	pushl  0x8(%ebp)
   10b78:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10b7b:	50                   	push   %eax
   10b7c:	e8 cf 7f ff ff       	call   8b50 <lodepng_chunk_init>
   10b81:	83 c4 10             	add    $0x10,%esp
   10b84:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10b87:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10b8b:	74 05                	je     10b92 <addChunk_IHDR+0x2a>
   10b8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10b90:	eb 6d                	jmp    10bff <addChunk_IHDR+0x97>
  data = chunk + 8;
   10b92:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b95:	83 c0 08             	add    $0x8,%eax
   10b98:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10b9b:	ff 75 0c             	pushl  0xc(%ebp)
   10b9e:	ff 75 f8             	pushl  -0x8(%ebp)
   10ba1:	e8 f3 2e ff ff       	call   3a99 <lodepng_set32bitInt>
   10ba6:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   10ba9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bac:	83 c0 04             	add    $0x4,%eax
   10baf:	ff 75 10             	pushl  0x10(%ebp)
   10bb2:	50                   	push   %eax
   10bb3:	e8 e1 2e ff ff       	call   3a99 <lodepng_set32bitInt>
   10bb8:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10bbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bbe:	83 c0 08             	add    $0x8,%eax
   10bc1:	8b 55 18             	mov    0x18(%ebp),%edx
   10bc4:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   10bc6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bc9:	83 c0 09             	add    $0x9,%eax
   10bcc:	8b 55 14             	mov    0x14(%ebp),%edx
   10bcf:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   10bd1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bd4:	83 c0 0a             	add    $0xa,%eax
   10bd7:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10bda:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bdd:	83 c0 0b             	add    $0xb,%eax
   10be0:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   10be3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10be6:	83 c0 0c             	add    $0xc,%eax
   10be9:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10bec:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10bee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10bf1:	50                   	push   %eax
   10bf2:	e8 02 7c ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   10bf7:	83 c4 04             	add    $0x4,%esp
  return 0;
   10bfa:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10bff:	c9                   	leave  
   10c00:	c3                   	ret    

00010c01 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   10c01:	55                   	push   %ebp
   10c02:	89 e5                	mov    %esp,%ebp
   10c04:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10c07:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10c0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c11:	8b 50 0c             	mov    0xc(%eax),%edx
   10c14:	89 d0                	mov    %edx,%eax
   10c16:	01 c0                	add    %eax,%eax
   10c18:	01 d0                	add    %edx,%eax
   10c1a:	68 a8 a4 01 00       	push   $0x1a4a8
   10c1f:	50                   	push   %eax
   10c20:	ff 75 08             	pushl  0x8(%ebp)
   10c23:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10c26:	50                   	push   %eax
   10c27:	e8 24 7f ff ff       	call   8b50 <lodepng_chunk_init>
   10c2c:	83 c4 10             	add    $0x10,%esp
   10c2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10c32:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c36:	74 08                	je     10c40 <addChunk_PLTE+0x3f>
   10c38:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c3b:	e9 95 00 00 00       	jmp    10cd5 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   10c40:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10c47:	eb 70                	jmp    10cb9 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10c49:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10c4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10c4f:	8d 50 01             	lea    0x1(%eax),%edx
   10c52:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10c55:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10c58:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c5b:	8b 40 08             	mov    0x8(%eax),%eax
   10c5e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10c61:	c1 e1 02             	shl    $0x2,%ecx
   10c64:	01 c8                	add    %ecx,%eax
   10c66:	0f b6 00             	movzbl (%eax),%eax
   10c69:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10c6b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10c6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10c71:	8d 50 01             	lea    0x1(%eax),%edx
   10c74:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10c77:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c7d:	8b 40 08             	mov    0x8(%eax),%eax
   10c80:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10c83:	c1 e1 02             	shl    $0x2,%ecx
   10c86:	83 c1 01             	add    $0x1,%ecx
   10c89:	01 c8                	add    %ecx,%eax
   10c8b:	0f b6 00             	movzbl (%eax),%eax
   10c8e:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   10c90:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10c93:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10c96:	8d 50 01             	lea    0x1(%eax),%edx
   10c99:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10c9c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10c9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ca2:	8b 40 08             	mov    0x8(%eax),%eax
   10ca5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10ca8:	c1 e1 02             	shl    $0x2,%ecx
   10cab:	83 c1 02             	add    $0x2,%ecx
   10cae:	01 c8                	add    %ecx,%eax
   10cb0:	0f b6 00             	movzbl (%eax),%eax
   10cb3:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   10cb5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10cb9:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cbc:	8b 40 0c             	mov    0xc(%eax),%eax
   10cbf:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   10cc2:	75 85                	jne    10c49 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   10cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cc7:	50                   	push   %eax
   10cc8:	e8 2c 7b ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   10ccd:	83 c4 04             	add    $0x4,%esp
  return 0;
   10cd0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10cd5:	c9                   	leave  
   10cd6:	c3                   	ret    

00010cd7 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10cd7:	55                   	push   %ebp
   10cd8:	89 e5                	mov    %esp,%ebp
   10cda:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10cdd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   10ce4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ce7:	8b 00                	mov    (%eax),%eax
   10ce9:	83 f8 03             	cmp    $0x3,%eax
   10cec:	0f 85 ae 00 00 00    	jne    10da0 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   10cf2:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cf5:	8b 40 0c             	mov    0xc(%eax),%eax
   10cf8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10cfb:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cfe:	8b 40 0c             	mov    0xc(%eax),%eax
   10d01:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10d04:	eb 23                	jmp    10d29 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10d06:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d09:	8b 40 08             	mov    0x8(%eax),%eax
   10d0c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10d0f:	83 ea 01             	sub    $0x1,%edx
   10d12:	c1 e2 02             	shl    $0x2,%edx
   10d15:	83 c2 03             	add    $0x3,%edx
   10d18:	01 d0                	add    %edx,%eax
   10d1a:	0f b6 00             	movzbl (%eax),%eax
   10d1d:	3c ff                	cmp    $0xff,%al
   10d1f:	75 10                	jne    10d31 <addChunk_tRNS+0x5a>
      --amount;
   10d21:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10d25:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10d29:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10d2d:	75 d7                	jne    10d06 <addChunk_tRNS+0x2f>
   10d2f:	eb 01                	jmp    10d32 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10d31:	90                   	nop
      --amount;
    }
    if(amount) {
   10d32:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10d36:	0f 84 63 01 00 00    	je     10e9f <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10d3c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10d3f:	68 ad a4 01 00       	push   $0x1a4ad
   10d44:	50                   	push   %eax
   10d45:	ff 75 08             	pushl  0x8(%ebp)
   10d48:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10d4b:	50                   	push   %eax
   10d4c:	e8 ff 7d ff ff       	call   8b50 <lodepng_chunk_init>
   10d51:	83 c4 10             	add    $0x10,%esp
   10d54:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10d57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10d5b:	74 08                	je     10d65 <addChunk_tRNS+0x8e>
   10d5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d60:	e9 52 01 00 00       	jmp    10eb7 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   10d65:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10d6c:	eb 25                	jmp    10d93 <addChunk_tRNS+0xbc>
   10d6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d71:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10d74:	83 c2 08             	add    $0x8,%edx
   10d77:	01 c2                	add    %eax,%edx
   10d79:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d7c:	8b 40 08             	mov    0x8(%eax),%eax
   10d7f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10d82:	c1 e1 02             	shl    $0x2,%ecx
   10d85:	83 c1 03             	add    $0x3,%ecx
   10d88:	01 c8                	add    %ecx,%eax
   10d8a:	0f b6 00             	movzbl (%eax),%eax
   10d8d:	88 02                	mov    %al,(%edx)
   10d8f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10d93:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10d96:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10d99:	75 d3                	jne    10d6e <addChunk_tRNS+0x97>
   10d9b:	e9 ff 00 00 00       	jmp    10e9f <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10da0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10da3:	8b 00                	mov    (%eax),%eax
   10da5:	85 c0                	test   %eax,%eax
   10da7:	75 59                	jne    10e02 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10da9:	8b 45 0c             	mov    0xc(%ebp),%eax
   10dac:	8b 40 10             	mov    0x10(%eax),%eax
   10daf:	85 c0                	test   %eax,%eax
   10db1:	0f 84 e8 00 00 00    	je     10e9f <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10db7:	68 ad a4 01 00       	push   $0x1a4ad
   10dbc:	6a 02                	push   $0x2
   10dbe:	ff 75 08             	pushl  0x8(%ebp)
   10dc1:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10dc4:	50                   	push   %eax
   10dc5:	e8 86 7d ff ff       	call   8b50 <lodepng_chunk_init>
   10dca:	83 c4 10             	add    $0x10,%esp
   10dcd:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10dd0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10dd4:	74 08                	je     10dde <addChunk_tRNS+0x107>
   10dd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10dd9:	e9 d9 00 00 00       	jmp    10eb7 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10dde:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10de1:	8d 50 08             	lea    0x8(%eax),%edx
   10de4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10de7:	8b 40 14             	mov    0x14(%eax),%eax
   10dea:	c1 e8 08             	shr    $0x8,%eax
   10ded:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10def:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10df2:	8d 50 09             	lea    0x9(%eax),%edx
   10df5:	8b 45 0c             	mov    0xc(%ebp),%eax
   10df8:	8b 40 14             	mov    0x14(%eax),%eax
   10dfb:	88 02                	mov    %al,(%edx)
   10dfd:	e9 9d 00 00 00       	jmp    10e9f <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10e02:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e05:	8b 00                	mov    (%eax),%eax
   10e07:	83 f8 02             	cmp    $0x2,%eax
   10e0a:	0f 85 8f 00 00 00    	jne    10e9f <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10e10:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e13:	8b 40 10             	mov    0x10(%eax),%eax
   10e16:	85 c0                	test   %eax,%eax
   10e18:	0f 84 81 00 00 00    	je     10e9f <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10e1e:	68 ad a4 01 00       	push   $0x1a4ad
   10e23:	6a 06                	push   $0x6
   10e25:	ff 75 08             	pushl  0x8(%ebp)
   10e28:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10e2b:	50                   	push   %eax
   10e2c:	e8 1f 7d ff ff       	call   8b50 <lodepng_chunk_init>
   10e31:	83 c4 10             	add    $0x10,%esp
   10e34:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10e37:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10e3b:	74 05                	je     10e42 <addChunk_tRNS+0x16b>
   10e3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e40:	eb 75                	jmp    10eb7 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10e42:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e45:	8d 50 08             	lea    0x8(%eax),%edx
   10e48:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e4b:	8b 40 14             	mov    0x14(%eax),%eax
   10e4e:	c1 e8 08             	shr    $0x8,%eax
   10e51:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10e53:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e56:	8d 50 09             	lea    0x9(%eax),%edx
   10e59:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e5c:	8b 40 14             	mov    0x14(%eax),%eax
   10e5f:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10e61:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e64:	8d 50 0a             	lea    0xa(%eax),%edx
   10e67:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e6a:	8b 40 18             	mov    0x18(%eax),%eax
   10e6d:	c1 e8 08             	shr    $0x8,%eax
   10e70:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10e72:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e75:	8d 50 0b             	lea    0xb(%eax),%edx
   10e78:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e7b:	8b 40 18             	mov    0x18(%eax),%eax
   10e7e:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10e80:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e83:	8d 50 0c             	lea    0xc(%eax),%edx
   10e86:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e89:	8b 40 1c             	mov    0x1c(%eax),%eax
   10e8c:	c1 e8 08             	shr    $0x8,%eax
   10e8f:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10e91:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e94:	8d 50 0d             	lea    0xd(%eax),%edx
   10e97:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e9a:	8b 40 1c             	mov    0x1c(%eax),%eax
   10e9d:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10e9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ea2:	85 c0                	test   %eax,%eax
   10ea4:	74 0c                	je     10eb2 <addChunk_tRNS+0x1db>
   10ea6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ea9:	50                   	push   %eax
   10eaa:	e8 4a 79 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   10eaf:	83 c4 04             	add    $0x4,%esp
  return 0;
   10eb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10eb7:	c9                   	leave  
   10eb8:	c3                   	ret    

00010eb9 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10eb9:	55                   	push   %ebp
   10eba:	89 e5                	mov    %esp,%ebp
   10ebc:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10ebf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10ec6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10ecd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10ed4:	83 ec 0c             	sub    $0xc,%esp
   10ed7:	ff 75 14             	pushl  0x14(%ebp)
   10eda:	ff 75 10             	pushl  0x10(%ebp)
   10edd:	ff 75 0c             	pushl  0xc(%ebp)
   10ee0:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10ee3:	50                   	push   %eax
   10ee4:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10ee7:	50                   	push   %eax
   10ee8:	e8 fb 74 ff ff       	call   83e8 <zlib_compress>
   10eed:	83 c4 20             	add    $0x20,%esp
   10ef0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10ef3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ef7:	75 1b                	jne    10f14 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10efc:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10eff:	50                   	push   %eax
   10f00:	68 e4 a4 01 00       	push   $0x1a4e4
   10f05:	52                   	push   %edx
   10f06:	ff 75 08             	pushl  0x8(%ebp)
   10f09:	e8 ea 7c ff ff       	call   8bf8 <lodepng_chunk_createv>
   10f0e:	83 c4 10             	add    $0x10,%esp
   10f11:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10f14:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10f17:	83 ec 0c             	sub    $0xc,%esp
   10f1a:	50                   	push   %eax
   10f1b:	e8 d9 27 ff ff       	call   36f9 <lodepng_free>
   10f20:	83 c4 10             	add    $0x10,%esp
  return error;
   10f23:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10f26:	c9                   	leave  
   10f27:	c3                   	ret    

00010f28 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10f28:	55                   	push   %ebp
   10f29:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10f2b:	6a 00                	push   $0x0
   10f2d:	68 e9 a4 01 00       	push   $0x1a4e9
   10f32:	6a 00                	push   $0x0
   10f34:	ff 75 08             	pushl  0x8(%ebp)
   10f37:	e8 bc 7c ff ff       	call   8bf8 <lodepng_chunk_createv>
   10f3c:	83 c4 10             	add    $0x10,%esp
}
   10f3f:	c9                   	leave  
   10f40:	c3                   	ret    

00010f41 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10f41:	55                   	push   %ebp
   10f42:	89 e5                	mov    %esp,%ebp
   10f44:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10f47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10f4e:	ff 75 0c             	pushl  0xc(%ebp)
   10f51:	e8 1e 28 ff ff       	call   3774 <lodepng_strlen>
   10f56:	83 c4 04             	add    $0x4,%esp
   10f59:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10f5c:	ff 75 10             	pushl  0x10(%ebp)
   10f5f:	e8 10 28 ff ff       	call   3774 <lodepng_strlen>
   10f64:	83 c4 04             	add    $0x4,%esp
   10f67:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10f6a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f6d:	8d 50 01             	lea    0x1(%eax),%edx
   10f70:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10f73:	01 d0                	add    %edx,%eax
   10f75:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10f78:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10f7c:	7e 06                	jle    10f84 <addChunk_tEXt+0x43>
   10f7e:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10f82:	7e 07                	jle    10f8b <addChunk_tEXt+0x4a>
   10f84:	b8 59 00 00 00       	mov    $0x59,%eax
   10f89:	eb 74                	jmp    10fff <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10f8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10f8e:	68 b7 a4 01 00       	push   $0x1a4b7
   10f93:	50                   	push   %eax
   10f94:	ff 75 08             	pushl  0x8(%ebp)
   10f97:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10f9a:	50                   	push   %eax
   10f9b:	e8 b0 7b ff ff       	call   8b50 <lodepng_chunk_init>
   10fa0:	83 c4 10             	add    $0x10,%esp
   10fa3:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10fa6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10faa:	74 05                	je     10fb1 <addChunk_tEXt+0x70>
   10fac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10faf:	eb 4e                	jmp    10fff <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10fb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10fb4:	83 c0 08             	add    $0x8,%eax
   10fb7:	ff 75 fc             	pushl  -0x4(%ebp)
   10fba:	ff 75 0c             	pushl  0xc(%ebp)
   10fbd:	50                   	push   %eax
   10fbe:	e8 53 27 ff ff       	call   3716 <lodepng_memcpy>
   10fc3:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10fc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10fc9:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10fcc:	83 c2 08             	add    $0x8,%edx
   10fcf:	01 d0                	add    %edx,%eax
   10fd1:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10fd4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10fd7:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10fda:	83 c2 09             	add    $0x9,%edx
   10fdd:	01 d0                	add    %edx,%eax
   10fdf:	ff 75 f8             	pushl  -0x8(%ebp)
   10fe2:	ff 75 10             	pushl  0x10(%ebp)
   10fe5:	50                   	push   %eax
   10fe6:	e8 2b 27 ff ff       	call   3716 <lodepng_memcpy>
   10feb:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10fee:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ff1:	50                   	push   %eax
   10ff2:	e8 02 78 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   10ff7:	83 c4 04             	add    $0x4,%esp
  return 0;
   10ffa:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10fff:	c9                   	leave  
   11000:	c3                   	ret    

00011001 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   11001:	55                   	push   %ebp
   11002:	89 e5                	mov    %esp,%ebp
   11004:	53                   	push   %ebx
   11005:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11008:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   1100f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   11016:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   1101d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11024:	ff 75 10             	pushl  0x10(%ebp)
   11027:	e8 48 27 ff ff       	call   3774 <lodepng_strlen>
   1102c:	83 c4 04             	add    $0x4,%esp
   1102f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   11032:	ff 75 0c             	pushl  0xc(%ebp)
   11035:	e8 3a 27 ff ff       	call   3774 <lodepng_strlen>
   1103a:	83 c4 04             	add    $0x4,%esp
   1103d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11040:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11044:	7e 06                	jle    1104c <addChunk_zTXt+0x4b>
   11046:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   1104a:	7e 0a                	jle    11056 <addChunk_zTXt+0x55>
   1104c:	b8 59 00 00 00       	mov    $0x59,%eax
   11051:	e9 c8 00 00 00       	jmp    1111e <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   11056:	83 ec 0c             	sub    $0xc,%esp
   11059:	ff 75 14             	pushl  0x14(%ebp)
   1105c:	ff 75 f0             	pushl  -0x10(%ebp)
   1105f:	ff 75 10             	pushl  0x10(%ebp)
   11062:	8d 45 dc             	lea    -0x24(%ebp),%eax
   11065:	50                   	push   %eax
   11066:	8d 45 e0             	lea    -0x20(%ebp),%eax
   11069:	50                   	push   %eax
   1106a:	e8 79 73 ff ff       	call   83e8 <zlib_compress>
   1106f:	83 c4 20             	add    $0x20,%esp
   11072:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   11075:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11079:	75 29                	jne    110a4 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   1107b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1107e:	8d 50 02             	lea    0x2(%eax),%edx
   11081:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11084:	01 d0                	add    %edx,%eax
   11086:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   11089:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1108c:	68 bc a4 01 00       	push   $0x1a4bc
   11091:	50                   	push   %eax
   11092:	ff 75 08             	pushl  0x8(%ebp)
   11095:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11098:	50                   	push   %eax
   11099:	e8 b2 7a ff ff       	call   8b50 <lodepng_chunk_init>
   1109e:	83 c4 10             	add    $0x10,%esp
   110a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   110a4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   110a8:	75 62                	jne    1110c <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   110aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   110ad:	83 c0 08             	add    $0x8,%eax
   110b0:	83 ec 04             	sub    $0x4,%esp
   110b3:	ff 75 ec             	pushl  -0x14(%ebp)
   110b6:	ff 75 0c             	pushl  0xc(%ebp)
   110b9:	50                   	push   %eax
   110ba:	e8 57 26 ff ff       	call   3716 <lodepng_memcpy>
   110bf:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   110c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   110c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   110c8:	83 c2 08             	add    $0x8,%edx
   110cb:	01 d0                	add    %edx,%eax
   110cd:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   110d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   110d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   110d6:	83 c2 09             	add    $0x9,%edx
   110d9:	01 d0                	add    %edx,%eax
   110db:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   110de:	8b 55 dc             	mov    -0x24(%ebp),%edx
   110e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   110e4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   110e7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   110ea:	83 c3 0a             	add    $0xa,%ebx
   110ed:	01 d9                	add    %ebx,%ecx
   110ef:	83 ec 04             	sub    $0x4,%esp
   110f2:	52                   	push   %edx
   110f3:	50                   	push   %eax
   110f4:	51                   	push   %ecx
   110f5:	e8 1c 26 ff ff       	call   3716 <lodepng_memcpy>
   110fa:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   110fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11100:	83 ec 0c             	sub    $0xc,%esp
   11103:	50                   	push   %eax
   11104:	e8 f0 76 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   11109:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1110c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1110f:	83 ec 0c             	sub    $0xc,%esp
   11112:	50                   	push   %eax
   11113:	e8 e1 25 ff ff       	call   36f9 <lodepng_free>
   11118:	83 c4 10             	add    $0x10,%esp
  return error;
   1111b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1111e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11121:	c9                   	leave  
   11122:	c3                   	ret    

00011123 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   11123:	55                   	push   %ebp
   11124:	89 e5                	mov    %esp,%ebp
   11126:	53                   	push   %ebx
   11127:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   1112a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11131:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   11138:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   1113f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11146:	ff 75 1c             	pushl  0x1c(%ebp)
   11149:	e8 26 26 ff ff       	call   3774 <lodepng_strlen>
   1114e:	83 c4 04             	add    $0x4,%esp
   11151:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   11154:	ff 75 10             	pushl  0x10(%ebp)
   11157:	e8 18 26 ff ff       	call   3774 <lodepng_strlen>
   1115c:	83 c4 04             	add    $0x4,%esp
   1115f:	89 45 ec             	mov    %eax,-0x14(%ebp)
   11162:	ff 75 14             	pushl  0x14(%ebp)
   11165:	e8 0a 26 ff ff       	call   3774 <lodepng_strlen>
   1116a:	83 c4 04             	add    $0x4,%esp
   1116d:	89 45 e8             	mov    %eax,-0x18(%ebp)
   11170:	ff 75 18             	pushl  0x18(%ebp)
   11173:	e8 fc 25 ff ff       	call   3774 <lodepng_strlen>
   11178:	83 c4 04             	add    $0x4,%esp
   1117b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1117e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11182:	7e 06                	jle    1118a <addChunk_iTXt+0x67>
   11184:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   11188:	7e 0a                	jle    11194 <addChunk_iTXt+0x71>
   1118a:	b8 59 00 00 00       	mov    $0x59,%eax
   1118f:	e9 9a 01 00 00       	jmp    1132e <addChunk_iTXt+0x20b>

  if(compress) {
   11194:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11198:	74 1f                	je     111b9 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   1119a:	83 ec 0c             	sub    $0xc,%esp
   1119d:	ff 75 20             	pushl  0x20(%ebp)
   111a0:	ff 75 f0             	pushl  -0x10(%ebp)
   111a3:	ff 75 1c             	pushl  0x1c(%ebp)
   111a6:	8d 45 d0             	lea    -0x30(%ebp),%eax
   111a9:	50                   	push   %eax
   111aa:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   111ad:	50                   	push   %eax
   111ae:	e8 35 72 ff ff       	call   83e8 <zlib_compress>
   111b3:	83 c4 20             	add    $0x20,%esp
   111b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   111b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   111bd:	75 44                	jne    11203 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   111bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
   111c2:	8d 50 03             	lea    0x3(%eax),%edx
   111c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111c8:	01 d0                	add    %edx,%eax
   111ca:	8d 50 01             	lea    0x1(%eax),%edx
   111cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   111d0:	01 d0                	add    %edx,%eax
   111d2:	8d 50 01             	lea    0x1(%eax),%edx
   111d5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   111d9:	74 05                	je     111e0 <addChunk_iTXt+0xbd>
   111db:	8b 45 d0             	mov    -0x30(%ebp),%eax
   111de:	eb 03                	jmp    111e3 <addChunk_iTXt+0xc0>
   111e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   111e3:	01 d0                	add    %edx,%eax
   111e5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   111e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   111eb:	68 c1 a4 01 00       	push   $0x1a4c1
   111f0:	50                   	push   %eax
   111f1:	ff 75 08             	pushl  0x8(%ebp)
   111f4:	8d 45 d8             	lea    -0x28(%ebp),%eax
   111f7:	50                   	push   %eax
   111f8:	e8 53 79 ff ff       	call   8b50 <lodepng_chunk_init>
   111fd:	83 c4 10             	add    $0x10,%esp
   11200:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11203:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11207:	0f 85 0f 01 00 00    	jne    1131c <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   1120d:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   11214:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11217:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1121a:	01 d0                	add    %edx,%eax
   1121c:	83 ec 04             	sub    $0x4,%esp
   1121f:	ff 75 ec             	pushl  -0x14(%ebp)
   11222:	ff 75 10             	pushl  0x10(%ebp)
   11225:	50                   	push   %eax
   11226:	e8 eb 24 ff ff       	call   3716 <lodepng_memcpy>
   1122b:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   1122e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11231:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11234:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11237:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1123a:	8d 50 01             	lea    0x1(%eax),%edx
   1123d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11240:	01 c8                	add    %ecx,%eax
   11242:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   11245:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11248:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1124b:	8d 50 01             	lea    0x1(%eax),%edx
   1124e:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11251:	01 c8                	add    %ecx,%eax
   11253:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11257:	0f 95 c2             	setne  %dl
   1125a:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   1125c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1125f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11262:	8d 50 01             	lea    0x1(%eax),%edx
   11265:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11268:	01 c8                	add    %ecx,%eax
   1126a:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   1126d:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11270:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11273:	01 d0                	add    %edx,%eax
   11275:	83 ec 04             	sub    $0x4,%esp
   11278:	ff 75 e8             	pushl  -0x18(%ebp)
   1127b:	ff 75 14             	pushl  0x14(%ebp)
   1127e:	50                   	push   %eax
   1127f:	e8 92 24 ff ff       	call   3716 <lodepng_memcpy>
   11284:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   11287:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1128a:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   1128d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11290:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11293:	8d 50 01             	lea    0x1(%eax),%edx
   11296:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11299:	01 c8                	add    %ecx,%eax
   1129b:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   1129e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   112a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   112a4:	01 d0                	add    %edx,%eax
   112a6:	83 ec 04             	sub    $0x4,%esp
   112a9:	ff 75 e4             	pushl  -0x1c(%ebp)
   112ac:	ff 75 18             	pushl  0x18(%ebp)
   112af:	50                   	push   %eax
   112b0:	e8 61 24 ff ff       	call   3716 <lodepng_memcpy>
   112b5:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   112b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   112bb:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   112be:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   112c1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   112c4:	8d 50 01             	lea    0x1(%eax),%edx
   112c7:	89 55 dc             	mov    %edx,-0x24(%ebp)
   112ca:	01 c8                	add    %ecx,%eax
   112cc:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   112cf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   112d3:	74 1e                	je     112f3 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   112d5:	8b 55 d0             	mov    -0x30(%ebp),%edx
   112d8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   112db:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   112de:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   112e1:	01 d9                	add    %ebx,%ecx
   112e3:	83 ec 04             	sub    $0x4,%esp
   112e6:	52                   	push   %edx
   112e7:	50                   	push   %eax
   112e8:	51                   	push   %ecx
   112e9:	e8 28 24 ff ff       	call   3716 <lodepng_memcpy>
   112ee:	83 c4 10             	add    $0x10,%esp
   112f1:	eb 1a                	jmp    1130d <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   112f3:	8b 55 d8             	mov    -0x28(%ebp),%edx
   112f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   112f9:	01 d0                	add    %edx,%eax
   112fb:	83 ec 04             	sub    $0x4,%esp
   112fe:	ff 75 f0             	pushl  -0x10(%ebp)
   11301:	ff 75 1c             	pushl  0x1c(%ebp)
   11304:	50                   	push   %eax
   11305:	e8 0c 24 ff ff       	call   3716 <lodepng_memcpy>
   1130a:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   1130d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11310:	83 ec 0c             	sub    $0xc,%esp
   11313:	50                   	push   %eax
   11314:	e8 e0 74 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   11319:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1131c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1131f:	83 ec 0c             	sub    $0xc,%esp
   11322:	50                   	push   %eax
   11323:	e8 d1 23 ff ff       	call   36f9 <lodepng_free>
   11328:	83 c4 10             	add    $0x10,%esp
  return error;
   1132b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1132e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11331:	c9                   	leave  
   11332:	c3                   	ret    

00011333 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   11333:	55                   	push   %ebp
   11334:	89 e5                	mov    %esp,%ebp
   11336:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   11339:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   11340:	8b 45 0c             	mov    0xc(%ebp),%eax
   11343:	8b 40 0c             	mov    0xc(%eax),%eax
   11346:	85 c0                	test   %eax,%eax
   11348:	74 0b                	je     11355 <addChunk_bKGD+0x22>
   1134a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1134d:	8b 40 0c             	mov    0xc(%eax),%eax
   11350:	83 f8 04             	cmp    $0x4,%eax
   11353:	75 4b                	jne    113a0 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   11355:	68 b2 a4 01 00       	push   $0x1a4b2
   1135a:	6a 02                	push   $0x2
   1135c:	ff 75 08             	pushl  0x8(%ebp)
   1135f:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11362:	50                   	push   %eax
   11363:	e8 e8 77 ff ff       	call   8b50 <lodepng_chunk_init>
   11368:	83 c4 10             	add    $0x10,%esp
   1136b:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1136e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11372:	74 08                	je     1137c <addChunk_bKGD+0x49>
   11374:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11377:	e9 19 01 00 00       	jmp    11495 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   1137c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1137f:	8d 50 08             	lea    0x8(%eax),%edx
   11382:	8b 45 0c             	mov    0xc(%ebp),%eax
   11385:	8b 40 30             	mov    0x30(%eax),%eax
   11388:	c1 e8 08             	shr    $0x8,%eax
   1138b:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   1138d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11390:	8d 50 09             	lea    0x9(%eax),%edx
   11393:	8b 45 0c             	mov    0xc(%ebp),%eax
   11396:	8b 40 30             	mov    0x30(%eax),%eax
   11399:	88 02                	mov    %al,(%edx)
   1139b:	e9 dd 00 00 00       	jmp    1147d <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   113a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   113a3:	8b 40 0c             	mov    0xc(%eax),%eax
   113a6:	83 f8 02             	cmp    $0x2,%eax
   113a9:	74 0f                	je     113ba <addChunk_bKGD+0x87>
   113ab:	8b 45 0c             	mov    0xc(%ebp),%eax
   113ae:	8b 40 0c             	mov    0xc(%eax),%eax
   113b1:	83 f8 06             	cmp    $0x6,%eax
   113b4:	0f 85 86 00 00 00    	jne    11440 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   113ba:	68 b2 a4 01 00       	push   $0x1a4b2
   113bf:	6a 06                	push   $0x6
   113c1:	ff 75 08             	pushl  0x8(%ebp)
   113c4:	8d 45 f0             	lea    -0x10(%ebp),%eax
   113c7:	50                   	push   %eax
   113c8:	e8 83 77 ff ff       	call   8b50 <lodepng_chunk_init>
   113cd:	83 c4 10             	add    $0x10,%esp
   113d0:	89 45 f8             	mov    %eax,-0x8(%ebp)
   113d3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   113d7:	74 08                	je     113e1 <addChunk_bKGD+0xae>
   113d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113dc:	e9 b4 00 00 00       	jmp    11495 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   113e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   113e4:	8d 50 08             	lea    0x8(%eax),%edx
   113e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   113ea:	8b 40 30             	mov    0x30(%eax),%eax
   113ed:	c1 e8 08             	shr    $0x8,%eax
   113f0:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   113f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   113f5:	8d 50 09             	lea    0x9(%eax),%edx
   113f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   113fb:	8b 40 30             	mov    0x30(%eax),%eax
   113fe:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   11400:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11403:	8d 50 0a             	lea    0xa(%eax),%edx
   11406:	8b 45 0c             	mov    0xc(%ebp),%eax
   11409:	8b 40 34             	mov    0x34(%eax),%eax
   1140c:	c1 e8 08             	shr    $0x8,%eax
   1140f:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   11411:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11414:	8d 50 0b             	lea    0xb(%eax),%edx
   11417:	8b 45 0c             	mov    0xc(%ebp),%eax
   1141a:	8b 40 34             	mov    0x34(%eax),%eax
   1141d:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   1141f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11422:	8d 50 0c             	lea    0xc(%eax),%edx
   11425:	8b 45 0c             	mov    0xc(%ebp),%eax
   11428:	8b 40 38             	mov    0x38(%eax),%eax
   1142b:	c1 e8 08             	shr    $0x8,%eax
   1142e:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   11430:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11433:	8d 50 0d             	lea    0xd(%eax),%edx
   11436:	8b 45 0c             	mov    0xc(%ebp),%eax
   11439:	8b 40 38             	mov    0x38(%eax),%eax
   1143c:	88 02                	mov    %al,(%edx)
   1143e:	eb 3d                	jmp    1147d <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   11440:	8b 45 0c             	mov    0xc(%ebp),%eax
   11443:	8b 40 0c             	mov    0xc(%eax),%eax
   11446:	83 f8 03             	cmp    $0x3,%eax
   11449:	75 32                	jne    1147d <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   1144b:	68 b2 a4 01 00       	push   $0x1a4b2
   11450:	6a 01                	push   $0x1
   11452:	ff 75 08             	pushl  0x8(%ebp)
   11455:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11458:	50                   	push   %eax
   11459:	e8 f2 76 ff ff       	call   8b50 <lodepng_chunk_init>
   1145e:	83 c4 10             	add    $0x10,%esp
   11461:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11464:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11468:	74 05                	je     1146f <addChunk_bKGD+0x13c>
   1146a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1146d:	eb 26                	jmp    11495 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   1146f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11472:	8d 50 08             	lea    0x8(%eax),%edx
   11475:	8b 45 0c             	mov    0xc(%ebp),%eax
   11478:	8b 40 30             	mov    0x30(%eax),%eax
   1147b:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   1147d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11480:	85 c0                	test   %eax,%eax
   11482:	74 0c                	je     11490 <addChunk_bKGD+0x15d>
   11484:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11487:	50                   	push   %eax
   11488:	e8 6c 73 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   1148d:	83 c4 04             	add    $0x4,%esp
  return 0;
   11490:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11495:	c9                   	leave  
   11496:	c3                   	ret    

00011497 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   11497:	55                   	push   %ebp
   11498:	89 e5                	mov    %esp,%ebp
   1149a:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   1149d:	68 c6 a4 01 00       	push   $0x1a4c6
   114a2:	6a 07                	push   $0x7
   114a4:	ff 75 08             	pushl  0x8(%ebp)
   114a7:	8d 45 f8             	lea    -0x8(%ebp),%eax
   114aa:	50                   	push   %eax
   114ab:	e8 a0 76 ff ff       	call   8b50 <lodepng_chunk_init>
   114b0:	83 c4 10             	add    $0x10,%esp
   114b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
   114b6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   114ba:	74 05                	je     114c1 <addChunk_tIME+0x2a>
   114bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   114bf:	eb 74                	jmp    11535 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   114c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114c4:	8d 50 08             	lea    0x8(%eax),%edx
   114c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   114ca:	8b 00                	mov    (%eax),%eax
   114cc:	c1 e8 08             	shr    $0x8,%eax
   114cf:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   114d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114d4:	8d 50 09             	lea    0x9(%eax),%edx
   114d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   114da:	8b 00                	mov    (%eax),%eax
   114dc:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   114de:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114e1:	8d 50 0a             	lea    0xa(%eax),%edx
   114e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   114e7:	8b 40 04             	mov    0x4(%eax),%eax
   114ea:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   114ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114ef:	8d 50 0b             	lea    0xb(%eax),%edx
   114f2:	8b 45 0c             	mov    0xc(%ebp),%eax
   114f5:	8b 40 08             	mov    0x8(%eax),%eax
   114f8:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   114fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114fd:	8d 50 0c             	lea    0xc(%eax),%edx
   11500:	8b 45 0c             	mov    0xc(%ebp),%eax
   11503:	8b 40 0c             	mov    0xc(%eax),%eax
   11506:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11508:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1150b:	8d 50 0d             	lea    0xd(%eax),%edx
   1150e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11511:	8b 40 10             	mov    0x10(%eax),%eax
   11514:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   11516:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11519:	8d 50 0e             	lea    0xe(%eax),%edx
   1151c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1151f:	8b 40 14             	mov    0x14(%eax),%eax
   11522:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11524:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11527:	50                   	push   %eax
   11528:	e8 cc 72 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   1152d:	83 c4 04             	add    $0x4,%esp
  return 0;
   11530:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11535:	c9                   	leave  
   11536:	c3                   	ret    

00011537 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11537:	55                   	push   %ebp
   11538:	89 e5                	mov    %esp,%ebp
   1153a:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   1153d:	68 cb a4 01 00       	push   $0x1a4cb
   11542:	6a 09                	push   $0x9
   11544:	ff 75 08             	pushl  0x8(%ebp)
   11547:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1154a:	50                   	push   %eax
   1154b:	e8 00 76 ff ff       	call   8b50 <lodepng_chunk_init>
   11550:	83 c4 10             	add    $0x10,%esp
   11553:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11556:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1155a:	74 05                	je     11561 <addChunk_pHYs+0x2a>
   1155c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1155f:	eb 51                	jmp    115b2 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   11561:	8b 45 0c             	mov    0xc(%ebp),%eax
   11564:	8b 40 7c             	mov    0x7c(%eax),%eax
   11567:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1156a:	83 c2 08             	add    $0x8,%edx
   1156d:	50                   	push   %eax
   1156e:	52                   	push   %edx
   1156f:	e8 25 25 ff ff       	call   3a99 <lodepng_set32bitInt>
   11574:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   11577:	8b 45 0c             	mov    0xc(%ebp),%eax
   1157a:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   11580:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11583:	83 c2 0c             	add    $0xc,%edx
   11586:	50                   	push   %eax
   11587:	52                   	push   %edx
   11588:	e8 0c 25 ff ff       	call   3a99 <lodepng_set32bitInt>
   1158d:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   11590:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11593:	8d 50 10             	lea    0x10(%eax),%edx
   11596:	8b 45 0c             	mov    0xc(%ebp),%eax
   11599:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   1159f:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   115a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   115a4:	50                   	push   %eax
   115a5:	e8 4f 72 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   115aa:	83 c4 04             	add    $0x4,%esp
  return 0;
   115ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
   115b2:	c9                   	leave  
   115b3:	c3                   	ret    

000115b4 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   115b4:	55                   	push   %ebp
   115b5:	89 e5                	mov    %esp,%ebp
   115b7:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   115ba:	68 d0 a4 01 00       	push   $0x1a4d0
   115bf:	6a 04                	push   $0x4
   115c1:	ff 75 08             	pushl  0x8(%ebp)
   115c4:	8d 45 f8             	lea    -0x8(%ebp),%eax
   115c7:	50                   	push   %eax
   115c8:	e8 83 75 ff ff       	call   8b50 <lodepng_chunk_init>
   115cd:	83 c4 10             	add    $0x10,%esp
   115d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
   115d3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   115d7:	74 05                	je     115de <addChunk_gAMA+0x2a>
   115d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   115dc:	eb 2a                	jmp    11608 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   115de:	8b 45 0c             	mov    0xc(%ebp),%eax
   115e1:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   115e7:	8b 55 f8             	mov    -0x8(%ebp),%edx
   115ea:	83 c2 08             	add    $0x8,%edx
   115ed:	50                   	push   %eax
   115ee:	52                   	push   %edx
   115ef:	e8 a5 24 ff ff       	call   3a99 <lodepng_set32bitInt>
   115f4:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   115f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   115fa:	50                   	push   %eax
   115fb:	e8 f9 71 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   11600:	83 c4 04             	add    $0x4,%esp
  return 0;
   11603:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11608:	c9                   	leave  
   11609:	c3                   	ret    

0001160a <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   1160a:	55                   	push   %ebp
   1160b:	89 e5                	mov    %esp,%ebp
   1160d:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   11610:	68 d5 a4 01 00       	push   $0x1a4d5
   11615:	6a 20                	push   $0x20
   11617:	ff 75 08             	pushl  0x8(%ebp)
   1161a:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1161d:	50                   	push   %eax
   1161e:	e8 2d 75 ff ff       	call   8b50 <lodepng_chunk_init>
   11623:	83 c4 10             	add    $0x10,%esp
   11626:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11629:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1162d:	74 08                	je     11637 <addChunk_cHRM+0x2d>
   1162f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11632:	e9 d9 00 00 00       	jmp    11710 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11637:	8b 45 0c             	mov    0xc(%ebp),%eax
   1163a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   11640:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11643:	83 c2 08             	add    $0x8,%edx
   11646:	50                   	push   %eax
   11647:	52                   	push   %edx
   11648:	e8 4c 24 ff ff       	call   3a99 <lodepng_set32bitInt>
   1164d:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   11650:	8b 45 0c             	mov    0xc(%ebp),%eax
   11653:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11659:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1165c:	83 c2 0c             	add    $0xc,%edx
   1165f:	50                   	push   %eax
   11660:	52                   	push   %edx
   11661:	e8 33 24 ff ff       	call   3a99 <lodepng_set32bitInt>
   11666:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   11669:	8b 45 0c             	mov    0xc(%ebp),%eax
   1166c:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   11672:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11675:	83 c2 10             	add    $0x10,%edx
   11678:	50                   	push   %eax
   11679:	52                   	push   %edx
   1167a:	e8 1a 24 ff ff       	call   3a99 <lodepng_set32bitInt>
   1167f:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   11682:	8b 45 0c             	mov    0xc(%ebp),%eax
   11685:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   1168b:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1168e:	83 c2 14             	add    $0x14,%edx
   11691:	50                   	push   %eax
   11692:	52                   	push   %edx
   11693:	e8 01 24 ff ff       	call   3a99 <lodepng_set32bitInt>
   11698:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   1169b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1169e:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   116a4:	8b 55 f8             	mov    -0x8(%ebp),%edx
   116a7:	83 c2 18             	add    $0x18,%edx
   116aa:	50                   	push   %eax
   116ab:	52                   	push   %edx
   116ac:	e8 e8 23 ff ff       	call   3a99 <lodepng_set32bitInt>
   116b1:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   116b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   116b7:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   116bd:	8b 55 f8             	mov    -0x8(%ebp),%edx
   116c0:	83 c2 1c             	add    $0x1c,%edx
   116c3:	50                   	push   %eax
   116c4:	52                   	push   %edx
   116c5:	e8 cf 23 ff ff       	call   3a99 <lodepng_set32bitInt>
   116ca:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   116cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   116d0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   116d6:	8b 55 f8             	mov    -0x8(%ebp),%edx
   116d9:	83 c2 20             	add    $0x20,%edx
   116dc:	50                   	push   %eax
   116dd:	52                   	push   %edx
   116de:	e8 b6 23 ff ff       	call   3a99 <lodepng_set32bitInt>
   116e3:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   116e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   116e9:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   116ef:	8b 55 f8             	mov    -0x8(%ebp),%edx
   116f2:	83 c2 24             	add    $0x24,%edx
   116f5:	50                   	push   %eax
   116f6:	52                   	push   %edx
   116f7:	e8 9d 23 ff ff       	call   3a99 <lodepng_set32bitInt>
   116fc:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   116ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11702:	50                   	push   %eax
   11703:	e8 f1 70 ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   11708:	83 c4 04             	add    $0x4,%esp
  return 0;
   1170b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11710:	c9                   	leave  
   11711:	c3                   	ret    

00011712 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   11712:	55                   	push   %ebp
   11713:	89 e5                	mov    %esp,%ebp
   11715:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11718:	8b 45 0c             	mov    0xc(%ebp),%eax
   1171b:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11721:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   11724:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11727:	50                   	push   %eax
   11728:	68 da a4 01 00       	push   $0x1a4da
   1172d:	6a 01                	push   $0x1
   1172f:	ff 75 08             	pushl  0x8(%ebp)
   11732:	e8 c1 74 ff ff       	call   8bf8 <lodepng_chunk_createv>
   11737:	83 c4 10             	add    $0x10,%esp
}
   1173a:	c9                   	leave  
   1173b:	c3                   	ret    

0001173c <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   1173c:	55                   	push   %ebp
   1173d:	89 e5                	mov    %esp,%ebp
   1173f:	53                   	push   %ebx
   11740:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11743:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   1174a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   11751:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11758:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   1175f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11762:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11768:	50                   	push   %eax
   11769:	e8 06 20 ff ff       	call   3774 <lodepng_strlen>
   1176e:	83 c4 04             	add    $0x4,%esp
   11771:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11774:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11778:	7e 06                	jle    11780 <addChunk_iCCP+0x44>
   1177a:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   1177e:	7e 0a                	jle    1178a <addChunk_iCCP+0x4e>
   11780:	b8 59 00 00 00       	mov    $0x59,%eax
   11785:	e9 df 00 00 00       	jmp    11869 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   1178a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1178d:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11793:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11795:	8b 45 0c             	mov    0xc(%ebp),%eax
   11798:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   1179e:	83 ec 0c             	sub    $0xc,%esp
   117a1:	ff 75 10             	pushl  0x10(%ebp)
   117a4:	52                   	push   %edx
   117a5:	50                   	push   %eax
   117a6:	8d 45 e0             	lea    -0x20(%ebp),%eax
   117a9:	50                   	push   %eax
   117aa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   117ad:	50                   	push   %eax
   117ae:	e8 35 6c ff ff       	call   83e8 <zlib_compress>
   117b3:	83 c4 20             	add    $0x20,%esp
   117b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   117b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   117bd:	75 29                	jne    117e8 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   117bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   117c2:	8d 50 02             	lea    0x2(%eax),%edx
   117c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   117c8:	01 d0                	add    %edx,%eax
   117ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   117cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   117d0:	68 df a4 01 00       	push   $0x1a4df
   117d5:	50                   	push   %eax
   117d6:	ff 75 08             	pushl  0x8(%ebp)
   117d9:	8d 45 e8             	lea    -0x18(%ebp),%eax
   117dc:	50                   	push   %eax
   117dd:	e8 6e 73 ff ff       	call   8b50 <lodepng_chunk_init>
   117e2:	83 c4 10             	add    $0x10,%esp
   117e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   117e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   117ec:	75 69                	jne    11857 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   117ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   117f1:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   117f7:	8b 55 e8             	mov    -0x18(%ebp),%edx
   117fa:	83 c2 08             	add    $0x8,%edx
   117fd:	83 ec 04             	sub    $0x4,%esp
   11800:	ff 75 f0             	pushl  -0x10(%ebp)
   11803:	50                   	push   %eax
   11804:	52                   	push   %edx
   11805:	e8 0c 1f ff ff       	call   3716 <lodepng_memcpy>
   1180a:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   1180d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11810:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11813:	83 c2 08             	add    $0x8,%edx
   11816:	01 d0                	add    %edx,%eax
   11818:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   1181b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1181e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11821:	83 c2 09             	add    $0x9,%edx
   11824:	01 d0                	add    %edx,%eax
   11826:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11829:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1182c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1182f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   11832:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11835:	83 c3 0a             	add    $0xa,%ebx
   11838:	01 d9                	add    %ebx,%ecx
   1183a:	83 ec 04             	sub    $0x4,%esp
   1183d:	52                   	push   %edx
   1183e:	50                   	push   %eax
   1183f:	51                   	push   %ecx
   11840:	e8 d1 1e ff ff       	call   3716 <lodepng_memcpy>
   11845:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11848:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1184b:	83 ec 0c             	sub    $0xc,%esp
   1184e:	50                   	push   %eax
   1184f:	e8 a5 6f ff ff       	call   87f9 <lodepng_chunk_generate_crc>
   11854:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11857:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1185a:	83 ec 0c             	sub    $0xc,%esp
   1185d:	50                   	push   %eax
   1185e:	e8 96 1e ff ff       	call   36f9 <lodepng_free>
   11863:	83 c4 10             	add    $0x10,%esp
  return error;
   11866:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11869:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1186c:	c9                   	leave  
   1186d:	c3                   	ret    

0001186e <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   1186e:	55                   	push   %ebp
   1186f:	89 e5                	mov    %esp,%ebp
   11871:	56                   	push   %esi
   11872:	53                   	push   %ebx
   11873:	83 ec 14             	sub    $0x14,%esp
   11876:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11879:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   1187c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   11880:	83 f8 04             	cmp    $0x4,%eax
   11883:	0f 87 41 03 00 00    	ja     11bca <filterScanline+0x35c>
   11889:	8b 04 85 f0 a4 01 00 	mov    0x1a4f0(,%eax,4),%eax
   11890:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   11892:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11899:	eb 19                	jmp    118b4 <filterScanline+0x46>
   1189b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1189e:	8b 45 08             	mov    0x8(%ebp),%eax
   118a1:	01 c2                	add    %eax,%edx
   118a3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   118a6:	8b 45 0c             	mov    0xc(%ebp),%eax
   118a9:	01 c8                	add    %ecx,%eax
   118ab:	0f b6 00             	movzbl (%eax),%eax
   118ae:	88 02                	mov    %al,(%edx)
   118b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118b7:	3b 45 14             	cmp    0x14(%ebp),%eax
   118ba:	75 df                	jne    1189b <filterScanline+0x2d>
      break;
   118bc:	e9 0a 03 00 00       	jmp    11bcb <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   118c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   118c8:	eb 19                	jmp    118e3 <filterScanline+0x75>
   118ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118cd:	8b 45 08             	mov    0x8(%ebp),%eax
   118d0:	01 c2                	add    %eax,%edx
   118d2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   118d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   118d8:	01 c8                	add    %ecx,%eax
   118da:	0f b6 00             	movzbl (%eax),%eax
   118dd:	88 02                	mov    %al,(%edx)
   118df:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118e6:	3b 45 18             	cmp    0x18(%ebp),%eax
   118e9:	75 df                	jne    118ca <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   118eb:	8b 45 18             	mov    0x18(%ebp),%eax
   118ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
   118f1:	eb 2d                	jmp    11920 <filterScanline+0xb2>
   118f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118f6:	8b 45 08             	mov    0x8(%ebp),%eax
   118f9:	01 c2                	add    %eax,%edx
   118fb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   118fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   11901:	01 c8                	add    %ecx,%eax
   11903:	0f b6 08             	movzbl (%eax),%ecx
   11906:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11909:	2b 45 18             	sub    0x18(%ebp),%eax
   1190c:	89 c3                	mov    %eax,%ebx
   1190e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11911:	01 d8                	add    %ebx,%eax
   11913:	0f b6 00             	movzbl (%eax),%eax
   11916:	29 c1                	sub    %eax,%ecx
   11918:	89 c8                	mov    %ecx,%eax
   1191a:	88 02                	mov    %al,(%edx)
   1191c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11920:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11923:	3b 45 14             	cmp    0x14(%ebp),%eax
   11926:	7c cb                	jl     118f3 <filterScanline+0x85>
      break;
   11928:	e9 9e 02 00 00       	jmp    11bcb <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   1192d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11931:	74 3e                	je     11971 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   11933:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1193a:	eb 28                	jmp    11964 <filterScanline+0xf6>
   1193c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1193f:	8b 45 08             	mov    0x8(%ebp),%eax
   11942:	01 d0                	add    %edx,%eax
   11944:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11947:	8b 55 0c             	mov    0xc(%ebp),%edx
   1194a:	01 ca                	add    %ecx,%edx
   1194c:	0f b6 0a             	movzbl (%edx),%ecx
   1194f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11952:	8b 55 10             	mov    0x10(%ebp),%edx
   11955:	01 da                	add    %ebx,%edx
   11957:	0f b6 12             	movzbl (%edx),%edx
   1195a:	29 d1                	sub    %edx,%ecx
   1195c:	89 ca                	mov    %ecx,%edx
   1195e:	88 10                	mov    %dl,(%eax)
   11960:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11964:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11967:	3b 45 14             	cmp    0x14(%ebp),%eax
   1196a:	75 d0                	jne    1193c <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   1196c:	e9 5a 02 00 00       	jmp    11bcb <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   11971:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11978:	eb 19                	jmp    11993 <filterScanline+0x125>
   1197a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1197d:	8b 45 08             	mov    0x8(%ebp),%eax
   11980:	01 c2                	add    %eax,%edx
   11982:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11985:	8b 45 0c             	mov    0xc(%ebp),%eax
   11988:	01 c8                	add    %ecx,%eax
   1198a:	0f b6 00             	movzbl (%eax),%eax
   1198d:	88 02                	mov    %al,(%edx)
   1198f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11993:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11996:	3b 45 14             	cmp    0x14(%ebp),%eax
   11999:	75 df                	jne    1197a <filterScanline+0x10c>
      }
      break;
   1199b:	e9 2b 02 00 00       	jmp    11bcb <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   119a0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   119a4:	0f 84 90 00 00 00    	je     11a3a <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   119aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   119b1:	eb 28                	jmp    119db <filterScanline+0x16d>
   119b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   119b6:	8b 45 08             	mov    0x8(%ebp),%eax
   119b9:	01 d0                	add    %edx,%eax
   119bb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   119be:	8b 55 0c             	mov    0xc(%ebp),%edx
   119c1:	01 ca                	add    %ecx,%edx
   119c3:	0f b6 12             	movzbl (%edx),%edx
   119c6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   119c9:	8b 4d 10             	mov    0x10(%ebp),%ecx
   119cc:	01 d9                	add    %ebx,%ecx
   119ce:	0f b6 09             	movzbl (%ecx),%ecx
   119d1:	d0 e9                	shr    %cl
   119d3:	29 ca                	sub    %ecx,%edx
   119d5:	88 10                	mov    %dl,(%eax)
   119d7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   119db:	8b 45 f4             	mov    -0xc(%ebp),%eax
   119de:	3b 45 18             	cmp    0x18(%ebp),%eax
   119e1:	75 d0                	jne    119b3 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   119e3:	8b 45 18             	mov    0x18(%ebp),%eax
   119e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
   119e9:	eb 42                	jmp    11a2d <filterScanline+0x1bf>
   119eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   119ee:	8b 45 08             	mov    0x8(%ebp),%eax
   119f1:	01 c2                	add    %eax,%edx
   119f3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   119f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   119f9:	01 c8                	add    %ecx,%eax
   119fb:	0f b6 08             	movzbl (%eax),%ecx
   119fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a01:	2b 45 18             	sub    0x18(%ebp),%eax
   11a04:	89 c3                	mov    %eax,%ebx
   11a06:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a09:	01 d8                	add    %ebx,%eax
   11a0b:	0f b6 00             	movzbl (%eax),%eax
   11a0e:	0f b6 d8             	movzbl %al,%ebx
   11a11:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11a14:	8b 45 10             	mov    0x10(%ebp),%eax
   11a17:	01 f0                	add    %esi,%eax
   11a19:	0f b6 00             	movzbl (%eax),%eax
   11a1c:	0f b6 c0             	movzbl %al,%eax
   11a1f:	01 d8                	add    %ebx,%eax
   11a21:	d1 f8                	sar    %eax
   11a23:	29 c1                	sub    %eax,%ecx
   11a25:	89 c8                	mov    %ecx,%eax
   11a27:	88 02                	mov    %al,(%edx)
   11a29:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a30:	3b 45 14             	cmp    0x14(%ebp),%eax
   11a33:	7c b6                	jl     119eb <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11a35:	e9 91 01 00 00       	jmp    11bcb <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11a3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11a41:	eb 19                	jmp    11a5c <filterScanline+0x1ee>
   11a43:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a46:	8b 45 08             	mov    0x8(%ebp),%eax
   11a49:	01 c2                	add    %eax,%edx
   11a4b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a51:	01 c8                	add    %ecx,%eax
   11a53:	0f b6 00             	movzbl (%eax),%eax
   11a56:	88 02                	mov    %al,(%edx)
   11a58:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a5f:	3b 45 18             	cmp    0x18(%ebp),%eax
   11a62:	75 df                	jne    11a43 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   11a64:	8b 45 18             	mov    0x18(%ebp),%eax
   11a67:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11a6a:	eb 2f                	jmp    11a9b <filterScanline+0x22d>
   11a6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a6f:	8b 45 08             	mov    0x8(%ebp),%eax
   11a72:	01 c2                	add    %eax,%edx
   11a74:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11a77:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a7a:	01 c8                	add    %ecx,%eax
   11a7c:	0f b6 08             	movzbl (%eax),%ecx
   11a7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a82:	2b 45 18             	sub    0x18(%ebp),%eax
   11a85:	89 c3                	mov    %eax,%ebx
   11a87:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a8a:	01 d8                	add    %ebx,%eax
   11a8c:	0f b6 00             	movzbl (%eax),%eax
   11a8f:	d0 e8                	shr    %al
   11a91:	29 c1                	sub    %eax,%ecx
   11a93:	89 c8                	mov    %ecx,%eax
   11a95:	88 02                	mov    %al,(%edx)
   11a97:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a9e:	3b 45 14             	cmp    0x14(%ebp),%eax
   11aa1:	7c c9                	jl     11a6c <filterScanline+0x1fe>
      }
      break;
   11aa3:	e9 23 01 00 00       	jmp    11bcb <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   11aa8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11aac:	0f 84 af 00 00 00    	je     11b61 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   11ab2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11ab9:	eb 28                	jmp    11ae3 <filterScanline+0x275>
   11abb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11abe:	8b 45 08             	mov    0x8(%ebp),%eax
   11ac1:	01 d0                	add    %edx,%eax
   11ac3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11ac6:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ac9:	01 ca                	add    %ecx,%edx
   11acb:	0f b6 0a             	movzbl (%edx),%ecx
   11ace:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11ad1:	8b 55 10             	mov    0x10(%ebp),%edx
   11ad4:	01 da                	add    %ebx,%edx
   11ad6:	0f b6 12             	movzbl (%edx),%edx
   11ad9:	29 d1                	sub    %edx,%ecx
   11adb:	89 ca                	mov    %ecx,%edx
   11add:	88 10                	mov    %dl,(%eax)
   11adf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11ae3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ae6:	3b 45 18             	cmp    0x18(%ebp),%eax
   11ae9:	75 d0                	jne    11abb <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11aeb:	8b 45 18             	mov    0x18(%ebp),%eax
   11aee:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11af1:	eb 64                	jmp    11b57 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   11af3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11af6:	8b 45 08             	mov    0x8(%ebp),%eax
   11af9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11afc:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11aff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b02:	01 d0                	add    %edx,%eax
   11b04:	0f b6 00             	movzbl (%eax),%eax
   11b07:	88 45 e7             	mov    %al,-0x19(%ebp)
   11b0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b0d:	2b 45 18             	sub    0x18(%ebp),%eax
   11b10:	89 c2                	mov    %eax,%edx
   11b12:	8b 45 10             	mov    0x10(%ebp),%eax
   11b15:	01 d0                	add    %edx,%eax
   11b17:	0f b6 00             	movzbl (%eax),%eax
   11b1a:	0f b6 c8             	movzbl %al,%ecx
   11b1d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11b20:	8b 45 10             	mov    0x10(%ebp),%eax
   11b23:	01 d0                	add    %edx,%eax
   11b25:	0f b6 00             	movzbl (%eax),%eax
   11b28:	0f b6 d0             	movzbl %al,%edx
   11b2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b2e:	2b 45 18             	sub    0x18(%ebp),%eax
   11b31:	89 c6                	mov    %eax,%esi
   11b33:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b36:	01 f0                	add    %esi,%eax
   11b38:	0f b6 00             	movzbl (%eax),%eax
   11b3b:	0f b6 c0             	movzbl %al,%eax
   11b3e:	51                   	push   %ecx
   11b3f:	52                   	push   %edx
   11b40:	50                   	push   %eax
   11b41:	e8 49 b8 ff ff       	call   d38f <paethPredictor>
   11b46:	83 c4 0c             	add    $0xc,%esp
   11b49:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11b4d:	29 c1                	sub    %eax,%ecx
   11b4f:	89 c8                	mov    %ecx,%eax
   11b51:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   11b53:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11b57:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b5a:	3b 45 14             	cmp    0x14(%ebp),%eax
   11b5d:	7c 94                	jl     11af3 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   11b5f:	eb 6a                	jmp    11bcb <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11b61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11b68:	eb 19                	jmp    11b83 <filterScanline+0x315>
   11b6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11b6d:	8b 45 08             	mov    0x8(%ebp),%eax
   11b70:	01 c2                	add    %eax,%edx
   11b72:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11b75:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b78:	01 c8                	add    %ecx,%eax
   11b7a:	0f b6 00             	movzbl (%eax),%eax
   11b7d:	88 02                	mov    %al,(%edx)
   11b7f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11b83:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b86:	3b 45 18             	cmp    0x18(%ebp),%eax
   11b89:	75 df                	jne    11b6a <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11b8b:	8b 45 18             	mov    0x18(%ebp),%eax
   11b8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11b91:	eb 2d                	jmp    11bc0 <filterScanline+0x352>
   11b93:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11b96:	8b 45 08             	mov    0x8(%ebp),%eax
   11b99:	01 c2                	add    %eax,%edx
   11b9b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11b9e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ba1:	01 c8                	add    %ecx,%eax
   11ba3:	0f b6 08             	movzbl (%eax),%ecx
   11ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ba9:	2b 45 18             	sub    0x18(%ebp),%eax
   11bac:	89 c3                	mov    %eax,%ebx
   11bae:	8b 45 0c             	mov    0xc(%ebp),%eax
   11bb1:	01 d8                	add    %ebx,%eax
   11bb3:	0f b6 00             	movzbl (%eax),%eax
   11bb6:	29 c1                	sub    %eax,%ecx
   11bb8:	89 c8                	mov    %ecx,%eax
   11bba:	88 02                	mov    %al,(%edx)
   11bbc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11bc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11bc3:	3b 45 14             	cmp    0x14(%ebp),%eax
   11bc6:	7c cb                	jl     11b93 <filterScanline+0x325>
      }
      break;
   11bc8:	eb 01                	jmp    11bcb <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11bca:	90                   	nop
  }
}
   11bcb:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11bce:	5b                   	pop    %ebx
   11bcf:	5e                   	pop    %esi
   11bd0:	5d                   	pop    %ebp
   11bd1:	c3                   	ret    

00011bd2 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   11bd2:	55                   	push   %ebp
   11bd3:	89 e5                	mov    %esp,%ebp
   11bd5:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11bd8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   11bdf:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11be6:	7e 08                	jle    11bf0 <ilog2+0x1e>
   11be8:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11bec:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   11bf0:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11bf7:	7e 08                	jle    11c01 <ilog2+0x2f>
   11bf9:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11bfd:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   11c01:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11c05:	7e 08                	jle    11c0f <ilog2+0x3d>
   11c07:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11c0b:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   11c0f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   11c13:	7e 08                	jle    11c1d <ilog2+0x4b>
   11c15:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11c19:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11c1d:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   11c21:	7e 04                	jle    11c27 <ilog2+0x55>
   11c23:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11c27:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11c2a:	c9                   	leave  
   11c2b:	c3                   	ret    

00011c2c <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11c2c:	55                   	push   %ebp
   11c2d:	89 e5                	mov    %esp,%ebp
   11c2f:	56                   	push   %esi
   11c30:	53                   	push   %ebx
   11c31:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   11c34:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11c38:	75 07                	jne    11c41 <ilog2i+0x15>
   11c3a:	b8 00 00 00 00       	mov    $0x0,%eax
   11c3f:	eb 30                	jmp    11c71 <ilog2i+0x45>
  l = ilog2(i);
   11c41:	ff 75 08             	pushl  0x8(%ebp)
   11c44:	e8 89 ff ff ff       	call   11bd2 <ilog2>
   11c49:	83 c4 04             	add    $0x4,%esp
   11c4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   11c4f:	8b 45 08             	mov    0x8(%ebp),%eax
   11c52:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11c56:	89 c3                	mov    %eax,%ebx
   11c58:	8b 55 08             	mov    0x8(%ebp),%edx
   11c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c5e:	be 01 00 00 00       	mov    $0x1,%esi
   11c63:	89 c1                	mov    %eax,%ecx
   11c65:	d3 e6                	shl    %cl,%esi
   11c67:	89 f0                	mov    %esi,%eax
   11c69:	29 c2                	sub    %eax,%edx
   11c6b:	89 d0                	mov    %edx,%eax
   11c6d:	01 c0                	add    %eax,%eax
   11c6f:	01 d8                	add    %ebx,%eax
}
   11c71:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11c74:	5b                   	pop    %ebx
   11c75:	5e                   	pop    %esi
   11c76:	5d                   	pop    %ebp
   11c77:	c3                   	ret    

00011c78 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   11c78:	55                   	push   %ebp
   11c79:	89 e5                	mov    %esp,%ebp
   11c7b:	53                   	push   %ebx
   11c7c:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   11c82:	ff 75 18             	pushl  0x18(%ebp)
   11c85:	e8 6a 75 ff ff       	call   91f4 <lodepng_get_bpp>
   11c8a:	83 c4 04             	add    $0x4,%esp
   11c8d:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   11c90:	ff 75 b8             	pushl  -0x48(%ebp)
   11c93:	6a 01                	push   $0x1
   11c95:	ff 75 10             	pushl  0x10(%ebp)
   11c98:	e8 b6 76 ff ff       	call   9353 <lodepng_get_raw_size_idat>
   11c9d:	83 c4 0c             	add    $0xc,%esp
   11ca0:	83 e8 01             	sub    $0x1,%eax
   11ca3:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   11ca6:	8b 45 b8             	mov    -0x48(%ebp),%eax
   11ca9:	83 c0 07             	add    $0x7,%eax
   11cac:	c1 e8 03             	shr    $0x3,%eax
   11caf:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   11cb2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11cb9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   11cc0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11cc3:	8b 40 2c             	mov    0x2c(%eax),%eax
   11cc6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11cc9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11ccc:	8b 40 28             	mov    0x28(%eax),%eax
   11ccf:	85 c0                	test   %eax,%eax
   11cd1:	74 1c                	je     11cef <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11cd3:	8b 45 18             	mov    0x18(%ebp),%eax
   11cd6:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11cd8:	83 f8 03             	cmp    $0x3,%eax
   11cdb:	74 0b                	je     11ce8 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11cdd:	8b 45 18             	mov    0x18(%ebp),%eax
   11ce0:	8b 40 04             	mov    0x4(%eax),%eax
   11ce3:	83 f8 07             	cmp    $0x7,%eax
   11ce6:	77 07                	ja     11cef <filter+0x77>
   11ce8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   11cef:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   11cf3:	75 0a                	jne    11cff <filter+0x87>
   11cf5:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11cfa:	e9 5b 07 00 00       	jmp    1245a <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   11cff:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11d03:	77 7b                	ja     11d80 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11d05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d08:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11d0b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11d12:	eb 5f                	jmp    11d73 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11d14:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d17:	83 c0 01             	add    $0x1,%eax
   11d1a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d1e:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   11d21:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d24:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d28:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11d2b:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11d2e:	8b 45 08             	mov    0x8(%ebp),%eax
   11d31:	01 c2                	add    %eax,%edx
   11d33:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11d37:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11d39:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11d3d:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11d40:	8b 55 0c             	mov    0xc(%ebp),%edx
   11d43:	01 d1                	add    %edx,%ecx
   11d45:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11d48:	8d 5a 01             	lea    0x1(%edx),%ebx
   11d4b:	8b 55 08             	mov    0x8(%ebp),%edx
   11d4e:	01 da                	add    %ebx,%edx
   11d50:	50                   	push   %eax
   11d51:	ff 75 b0             	pushl  -0x50(%ebp)
   11d54:	ff 75 b4             	pushl  -0x4c(%ebp)
   11d57:	ff 75 f4             	pushl  -0xc(%ebp)
   11d5a:	51                   	push   %ecx
   11d5b:	52                   	push   %edx
   11d5c:	e8 0d fb ff ff       	call   1186e <filterScanline>
   11d61:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11d64:	8b 55 98             	mov    -0x68(%ebp),%edx
   11d67:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d6a:	01 d0                	add    %edx,%eax
   11d6c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11d6f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11d73:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d76:	3b 45 14             	cmp    0x14(%ebp),%eax
   11d79:	75 99                	jne    11d14 <filter+0x9c>
   11d7b:	e9 d7 06 00 00       	jmp    12457 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11d80:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11d84:	0f 85 e3 01 00 00    	jne    11f6d <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11d8a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11d91:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   11d95:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11d99:	eb 2d                	jmp    11dc8 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11d9b:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11d9f:	83 ec 0c             	sub    $0xc,%esp
   11da2:	ff 75 b4             	pushl  -0x4c(%ebp)
   11da5:	e8 2e 19 ff ff       	call   36d8 <lodepng_malloc>
   11daa:	83 c4 10             	add    $0x10,%esp
   11dad:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11db1:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11db5:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11db9:	85 c0                	test   %eax,%eax
   11dbb:	75 07                	jne    11dc4 <filter+0x14c>
   11dbd:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11dc4:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11dc8:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11dcc:	75 cd                	jne    11d9b <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11dce:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11dd2:	0f 85 6c 01 00 00    	jne    11f44 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11dd8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ddf:	e9 54 01 00 00       	jmp    11f38 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11de4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11de8:	e9 d5 00 00 00       	jmp    11ec2 <filter+0x24a>
          size_t sum = 0;
   11ded:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11df4:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11df8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dfb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11dff:	89 c1                	mov    %eax,%ecx
   11e01:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e04:	01 c1                	add    %eax,%ecx
   11e06:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11e0a:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11e0e:	83 ec 08             	sub    $0x8,%esp
   11e11:	52                   	push   %edx
   11e12:	ff 75 b0             	pushl  -0x50(%ebp)
   11e15:	ff 75 b4             	pushl  -0x4c(%ebp)
   11e18:	ff 75 f4             	pushl  -0xc(%ebp)
   11e1b:	51                   	push   %ecx
   11e1c:	50                   	push   %eax
   11e1d:	e8 4c fa ff ff       	call   1186e <filterScanline>
   11e22:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11e25:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11e29:	75 2d                	jne    11e58 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11e2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11e32:	eb 1a                	jmp    11e4e <filter+0x1d6>
   11e34:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11e38:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11e3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e3f:	01 d0                	add    %edx,%eax
   11e41:	0f b6 00             	movzbl (%eax),%eax
   11e44:	0f b6 c0             	movzbl %al,%eax
   11e47:	01 45 d8             	add    %eax,-0x28(%ebp)
   11e4a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e4e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e51:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11e54:	75 de                	jne    11e34 <filter+0x1bc>
   11e56:	eb 4b                	jmp    11ea3 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11e58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11e5f:	eb 3a                	jmp    11e9b <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11e61:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11e65:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11e69:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e6c:	01 d0                	add    %edx,%eax
   11e6e:	0f b6 00             	movzbl (%eax),%eax
   11e71:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11e74:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11e78:	84 c0                	test   %al,%al
   11e7a:	78 06                	js     11e82 <filter+0x20a>
   11e7c:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11e80:	eb 0d                	jmp    11e8f <filter+0x217>
   11e82:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11e86:	ba ff 00 00 00       	mov    $0xff,%edx
   11e8b:	29 c2                	sub    %eax,%edx
   11e8d:	89 d0                	mov    %edx,%eax
   11e8f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11e92:	01 d0                	add    %edx,%eax
   11e94:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11e97:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e9b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e9e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11ea1:	75 be                	jne    11e61 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11ea3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11ea7:	74 08                	je     11eb1 <filter+0x239>
   11ea9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11eac:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11eaf:	7d 0d                	jge    11ebe <filter+0x246>
            bestType = type;
   11eb1:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11eb5:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11eb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ebb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11ebe:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11ec2:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11ec6:	0f 85 21 ff ff ff    	jne    11ded <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11ecc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ecf:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ed3:	89 c2                	mov    %eax,%edx
   11ed5:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ed8:	01 d0                	add    %edx,%eax
   11eda:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11edd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ee0:	83 c0 01             	add    $0x1,%eax
   11ee3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ee7:	89 c2                	mov    %eax,%edx
   11ee9:	8b 45 08             	mov    0x8(%ebp),%eax
   11eec:	01 c2                	add    %eax,%edx
   11eee:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11ef2:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11ef4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11efb:	eb 2f                	jmp    11f2c <filter+0x2b4>
   11efd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f00:	83 c0 01             	add    $0x1,%eax
   11f03:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f07:	89 c2                	mov    %eax,%edx
   11f09:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11f0c:	01 d0                	add    %edx,%eax
   11f0e:	8d 50 01             	lea    0x1(%eax),%edx
   11f11:	8b 45 08             	mov    0x8(%ebp),%eax
   11f14:	01 c2                	add    %eax,%edx
   11f16:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11f1a:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11f1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11f21:	01 c8                	add    %ecx,%eax
   11f23:	0f b6 00             	movzbl (%eax),%eax
   11f26:	88 02                	mov    %al,(%edx)
   11f28:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11f2c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f2f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11f32:	75 c9                	jne    11efd <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11f34:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11f38:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11f3b:	3b 45 14             	cmp    0x14(%ebp),%eax
   11f3e:	0f 85 a0 fe ff ff    	jne    11de4 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11f44:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11f48:	eb 18                	jmp    11f62 <filter+0x2ea>
   11f4a:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11f4e:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11f52:	83 ec 0c             	sub    $0xc,%esp
   11f55:	50                   	push   %eax
   11f56:	e8 9e 17 ff ff       	call   36f9 <lodepng_free>
   11f5b:	83 c4 10             	add    $0x10,%esp
   11f5e:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11f62:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11f66:	75 e2                	jne    11f4a <filter+0x2d2>
   11f68:	e9 ea 04 00 00       	jmp    12457 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11f6d:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11f71:	0f 85 17 02 00 00    	jne    1218e <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11f77:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11f7e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11f85:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11f8c:	eb 33                	jmp    11fc1 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11f8e:	83 ec 0c             	sub    $0xc,%esp
   11f91:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f94:	e8 3f 17 ff ff       	call   36d8 <lodepng_malloc>
   11f99:	83 c4 10             	add    $0x10,%esp
   11f9c:	89 c2                	mov    %eax,%edx
   11f9e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11fa1:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11fa8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11fab:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11fb2:	85 c0                	test   %eax,%eax
   11fb4:	75 07                	jne    11fbd <filter+0x345>
   11fb6:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11fbd:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11fc1:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11fc5:	75 c7                	jne    11f8e <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11fc7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11fcb:	0f 85 8f 01 00 00    	jne    12160 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11fd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11fd8:	e9 77 01 00 00       	jmp    12154 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11fdd:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11fe4:	e9 f4 00 00 00       	jmp    120dd <filter+0x465>
          size_t sum = 0;
   11fe9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11ff0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11ff3:	0f b6 d0             	movzbl %al,%edx
   11ff6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ff9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ffd:	89 c1                	mov    %eax,%ecx
   11fff:	8b 45 0c             	mov    0xc(%ebp),%eax
   12002:	01 c1                	add    %eax,%ecx
   12004:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12007:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   1200e:	83 ec 08             	sub    $0x8,%esp
   12011:	52                   	push   %edx
   12012:	ff 75 b0             	pushl  -0x50(%ebp)
   12015:	ff 75 b4             	pushl  -0x4c(%ebp)
   12018:	ff 75 f4             	pushl  -0xc(%ebp)
   1201b:	51                   	push   %ecx
   1201c:	50                   	push   %eax
   1201d:	e8 4c f8 ff ff       	call   1186e <filterScanline>
   12022:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   12025:	83 ec 04             	sub    $0x4,%esp
   12028:	68 00 04 00 00       	push   $0x400
   1202d:	6a 00                	push   $0x0
   1202f:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   12035:	50                   	push   %eax
   12036:	e8 0e 17 ff ff       	call   3749 <lodepng_memset>
   1203b:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   1203e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12045:	eb 2a                	jmp    12071 <filter+0x3f9>
   12047:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1204a:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   12051:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12054:	01 d0                	add    %edx,%eax
   12056:	0f b6 00             	movzbl (%eax),%eax
   12059:	0f b6 c0             	movzbl %al,%eax
   1205c:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   12063:	83 c2 01             	add    $0x1,%edx
   12066:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   1206d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12071:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12074:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12077:	75 ce                	jne    12047 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   12079:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1207c:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   12083:	8d 50 01             	lea    0x1(%eax),%edx
   12086:	8b 45 d0             	mov    -0x30(%ebp),%eax
   12089:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   12090:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12097:	eb 1d                	jmp    120b6 <filter+0x43e>
            sum += ilog2i(count[x]);
   12099:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1209c:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   120a3:	83 ec 0c             	sub    $0xc,%esp
   120a6:	50                   	push   %eax
   120a7:	e8 80 fb ff ff       	call   11c2c <ilog2i>
   120ac:	83 c4 10             	add    $0x10,%esp
   120af:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   120b2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   120b6:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   120bd:	75 da                	jne    12099 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   120bf:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   120c3:	74 08                	je     120cd <filter+0x455>
   120c5:	8b 45 c8             	mov    -0x38(%ebp),%eax
   120c8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   120cb:	7e 0c                	jle    120d9 <filter+0x461>
            bestType = type;
   120cd:	8b 45 d0             	mov    -0x30(%ebp),%eax
   120d0:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   120d3:	8b 45 c8             	mov    -0x38(%ebp),%eax
   120d6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   120d9:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   120dd:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   120e1:	0f 85 02 ff ff ff    	jne    11fe9 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   120e7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120ea:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120ee:	89 c2                	mov    %eax,%edx
   120f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   120f3:	01 d0                	add    %edx,%eax
   120f5:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   120f8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120fb:	83 c0 01             	add    $0x1,%eax
   120fe:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12102:	89 c2                	mov    %eax,%edx
   12104:	8b 45 08             	mov    0x8(%ebp),%eax
   12107:	01 d0                	add    %edx,%eax
   12109:	8b 55 cc             	mov    -0x34(%ebp),%edx
   1210c:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1210e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12115:	eb 31                	jmp    12148 <filter+0x4d0>
   12117:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1211a:	83 c0 01             	add    $0x1,%eax
   1211d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12121:	89 c2                	mov    %eax,%edx
   12123:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12126:	01 d0                	add    %edx,%eax
   12128:	8d 50 01             	lea    0x1(%eax),%edx
   1212b:	8b 45 08             	mov    0x8(%ebp),%eax
   1212e:	01 c2                	add    %eax,%edx
   12130:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12133:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   1213a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1213d:	01 c8                	add    %ecx,%eax
   1213f:	0f b6 00             	movzbl (%eax),%eax
   12142:	88 02                	mov    %al,(%edx)
   12144:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12148:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1214b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1214e:	75 c7                	jne    12117 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   12150:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12154:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12157:	3b 45 14             	cmp    0x14(%ebp),%eax
   1215a:	0f 85 7d fe ff ff    	jne    11fdd <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12160:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12167:	eb 1a                	jmp    12183 <filter+0x50b>
   12169:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1216c:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12173:	83 ec 0c             	sub    $0xc,%esp
   12176:	50                   	push   %eax
   12177:	e8 7d 15 ff ff       	call   36f9 <lodepng_free>
   1217c:	83 c4 10             	add    $0x10,%esp
   1217f:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12183:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12187:	75 e0                	jne    12169 <filter+0x4f1>
   12189:	e9 c9 02 00 00       	jmp    12457 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   1218e:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   12192:	0f 85 89 00 00 00    	jne    12221 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   12198:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1219f:	eb 73                	jmp    12214 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   121a1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   121a4:	83 c0 01             	add    $0x1,%eax
   121a7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   121ab:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   121ae:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   121b1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   121b5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   121b8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   121bb:	8b 50 30             	mov    0x30(%eax),%edx
   121be:	8b 45 ec             	mov    -0x14(%ebp),%eax
   121c1:	01 d0                	add    %edx,%eax
   121c3:	0f b6 00             	movzbl (%eax),%eax
   121c6:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   121c9:	8b 55 a8             	mov    -0x58(%ebp),%edx
   121cc:	8b 45 08             	mov    0x8(%ebp),%eax
   121cf:	01 c2                	add    %eax,%edx
   121d1:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   121d5:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   121d7:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   121db:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   121de:	8b 55 0c             	mov    0xc(%ebp),%edx
   121e1:	01 d1                	add    %edx,%ecx
   121e3:	8b 55 a8             	mov    -0x58(%ebp),%edx
   121e6:	8d 5a 01             	lea    0x1(%edx),%ebx
   121e9:	8b 55 08             	mov    0x8(%ebp),%edx
   121ec:	01 da                	add    %ebx,%edx
   121ee:	83 ec 08             	sub    $0x8,%esp
   121f1:	50                   	push   %eax
   121f2:	ff 75 b0             	pushl  -0x50(%ebp)
   121f5:	ff 75 b4             	pushl  -0x4c(%ebp)
   121f8:	ff 75 f4             	pushl  -0xc(%ebp)
   121fb:	51                   	push   %ecx
   121fc:	52                   	push   %edx
   121fd:	e8 6c f6 ff ff       	call   1186e <filterScanline>
   12202:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   12205:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12208:	8b 45 0c             	mov    0xc(%ebp),%eax
   1220b:	01 d0                	add    %edx,%eax
   1220d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   12210:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12214:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12217:	3b 45 14             	cmp    0x14(%ebp),%eax
   1221a:	75 85                	jne    121a1 <filter+0x529>
   1221c:	e9 36 02 00 00       	jmp    12457 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   12221:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   12225:	0f 85 25 02 00 00    	jne    12450 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   1222b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   12232:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12239:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   12240:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12243:	83 ec 04             	sub    $0x4,%esp
   12246:	6a 24                	push   $0x24
   12248:	50                   	push   %eax
   12249:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   1224f:	50                   	push   %eax
   12250:	e8 c1 14 ff ff       	call   3716 <lodepng_memcpy>
   12255:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   12258:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   1225f:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   12262:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   12269:	00 00 00 
    zlibsettings.custom_deflate = 0;
   1226c:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   12273:	00 00 00 
    for(type = 0; type != 5; ++type) {
   12276:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1227d:	eb 33                	jmp    122b2 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   1227f:	83 ec 0c             	sub    $0xc,%esp
   12282:	ff 75 b4             	pushl  -0x4c(%ebp)
   12285:	e8 4e 14 ff ff       	call   36d8 <lodepng_malloc>
   1228a:	83 c4 10             	add    $0x10,%esp
   1228d:	89 c2                	mov    %eax,%edx
   1228f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12292:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   12299:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1229c:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   122a3:	85 c0                	test   %eax,%eax
   122a5:	75 07                	jne    122ae <filter+0x636>
   122a7:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   122ae:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   122b2:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   122b6:	75 c7                	jne    1227f <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   122b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   122bc:	0f 85 63 01 00 00    	jne    12425 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   122c2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   122c9:	e9 4b 01 00 00       	jmp    12419 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   122ce:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   122d5:	e9 c8 00 00 00       	jmp    123a2 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   122da:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122dd:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   122e0:	8b 45 c0             	mov    -0x40(%ebp),%eax
   122e3:	0f b6 d0             	movzbl %al,%edx
   122e6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122e9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122ed:	89 c1                	mov    %eax,%ecx
   122ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   122f2:	01 c1                	add    %eax,%ecx
   122f4:	8b 45 c0             	mov    -0x40(%ebp),%eax
   122f7:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   122fe:	83 ec 08             	sub    $0x8,%esp
   12301:	52                   	push   %edx
   12302:	ff 75 b0             	pushl  -0x50(%ebp)
   12305:	ff 75 b4             	pushl  -0x4c(%ebp)
   12308:	ff 75 f4             	pushl  -0xc(%ebp)
   1230b:	51                   	push   %ecx
   1230c:	50                   	push   %eax
   1230d:	e8 5c f5 ff ff       	call   1186e <filterScanline>
   12312:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   12315:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12318:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   1231f:	00 00 00 00 
          dummy = 0;
   12323:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   1232a:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   1232d:	8b 55 ac             	mov    -0x54(%ebp),%edx
   12330:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12333:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1233a:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   12340:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   12343:	c1 e3 02             	shl    $0x2,%ebx
   12346:	01 cb                	add    %ecx,%ebx
   12348:	83 ec 0c             	sub    $0xc,%esp
   1234b:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   12351:	51                   	push   %ecx
   12352:	52                   	push   %edx
   12353:	50                   	push   %eax
   12354:	53                   	push   %ebx
   12355:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   1235b:	50                   	push   %eax
   1235c:	e8 87 60 ff ff       	call   83e8 <zlib_compress>
   12361:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   12364:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   1236a:	83 ec 0c             	sub    $0xc,%esp
   1236d:	50                   	push   %eax
   1236e:	e8 86 13 ff ff       	call   36f9 <lodepng_free>
   12373:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   12376:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   1237a:	74 0f                	je     1238b <filter+0x713>
   1237c:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1237f:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12386:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   12389:	7d 13                	jge    1239e <filter+0x726>
            bestType = type;
   1238b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1238e:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   12391:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12394:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   1239b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   1239e:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   123a2:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   123a6:	0f 85 2e ff ff ff    	jne    122da <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   123ac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   123af:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   123b3:	89 c2                	mov    %eax,%edx
   123b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   123b8:	01 d0                	add    %edx,%eax
   123ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   123bd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   123c0:	83 c0 01             	add    $0x1,%eax
   123c3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   123c7:	89 c2                	mov    %eax,%edx
   123c9:	8b 45 08             	mov    0x8(%ebp),%eax
   123cc:	01 d0                	add    %edx,%eax
   123ce:	8b 55 bc             	mov    -0x44(%ebp),%edx
   123d1:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   123d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   123da:	eb 31                	jmp    1240d <filter+0x795>
   123dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   123df:	83 c0 01             	add    $0x1,%eax
   123e2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   123e6:	89 c2                	mov    %eax,%edx
   123e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   123eb:	01 d0                	add    %edx,%eax
   123ed:	8d 50 01             	lea    0x1(%eax),%edx
   123f0:	8b 45 08             	mov    0x8(%ebp),%eax
   123f3:	01 c2                	add    %eax,%edx
   123f5:	8b 45 bc             	mov    -0x44(%ebp),%eax
   123f8:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   123ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12402:	01 c8                	add    %ecx,%eax
   12404:	0f b6 00             	movzbl (%eax),%eax
   12407:	88 02                	mov    %al,(%edx)
   12409:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1240d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12410:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12413:	75 c7                	jne    123dc <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12415:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12419:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1241c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1241f:	0f 85 a9 fe ff ff    	jne    122ce <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12425:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1242c:	eb 1a                	jmp    12448 <filter+0x7d0>
   1242e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12431:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12438:	83 ec 0c             	sub    $0xc,%esp
   1243b:	50                   	push   %eax
   1243c:	e8 b8 12 ff ff       	call   36f9 <lodepng_free>
   12441:	83 c4 10             	add    $0x10,%esp
   12444:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12448:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1244c:	75 e0                	jne    1242e <filter+0x7b6>
   1244e:	eb 07                	jmp    12457 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   12450:	b8 58 00 00 00       	mov    $0x58,%eax
   12455:	eb 03                	jmp    1245a <filter+0x7e2>

  return error;
   12457:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   1245a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1245d:	c9                   	leave  
   1245e:	c3                   	ret    

0001245f <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   1245f:	55                   	push   %ebp
   12460:	89 e5                	mov    %esp,%ebp
   12462:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   12465:	8b 45 10             	mov    0x10(%ebp),%eax
   12468:	2b 45 14             	sub    0x14(%ebp),%eax
   1246b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   1246e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12475:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   1247c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12483:	eb 65                	jmp    124ea <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   12485:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1248c:	eb 2a                	jmp    124b8 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   1248e:	ff 75 0c             	pushl  0xc(%ebp)
   12491:	8d 45 e8             	lea    -0x18(%ebp),%eax
   12494:	50                   	push   %eax
   12495:	e8 9d 60 ff ff       	call   8537 <readBitFromReversedStream>
   1249a:	83 c4 08             	add    $0x8,%esp
   1249d:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   124a0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   124a4:	50                   	push   %eax
   124a5:	ff 75 08             	pushl  0x8(%ebp)
   124a8:	8d 45 ec             	lea    -0x14(%ebp),%eax
   124ab:	50                   	push   %eax
   124ac:	e8 08 61 ff ff       	call   85b9 <setBitOfReversedStream>
   124b1:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   124b4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   124b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   124bb:	3b 45 14             	cmp    0x14(%ebp),%eax
   124be:	7c ce                	jl     1248e <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   124c0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   124c7:	eb 15                	jmp    124de <addPaddingBits+0x7f>
   124c9:	6a 00                	push   $0x0
   124cb:	ff 75 08             	pushl  0x8(%ebp)
   124ce:	8d 45 ec             	lea    -0x14(%ebp),%eax
   124d1:	50                   	push   %eax
   124d2:	e8 e2 60 ff ff       	call   85b9 <setBitOfReversedStream>
   124d7:	83 c4 0c             	add    $0xc,%esp
   124da:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   124de:	8b 45 f8             	mov    -0x8(%ebp),%eax
   124e1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   124e4:	75 e3                	jne    124c9 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   124e6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   124ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124ed:	3b 45 18             	cmp    0x18(%ebp),%eax
   124f0:	75 93                	jne    12485 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   124f2:	90                   	nop
   124f3:	c9                   	leave  
   124f4:	c3                   	ret    

000124f5 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   124f5:	55                   	push   %ebp
   124f6:	89 e5                	mov    %esp,%ebp
   124f8:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   124fe:	ff 75 18             	pushl  0x18(%ebp)
   12501:	ff 75 14             	pushl  0x14(%ebp)
   12504:	ff 75 10             	pushl  0x10(%ebp)
   12507:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   1250d:	50                   	push   %eax
   1250e:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   12514:	50                   	push   %eax
   12515:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   1251b:	50                   	push   %eax
   1251c:	8d 45 94             	lea    -0x6c(%ebp),%eax
   1251f:	50                   	push   %eax
   12520:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12523:	50                   	push   %eax
   12524:	e8 fc ae ff ff       	call   d425 <Adam7_getpassvalues>
   12529:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   1252c:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   12530:	0f 86 0a 01 00 00    	jbe    12640 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12536:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1253d:	e9 ef 00 00 00       	jmp    12631 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   12542:	8b 45 18             	mov    0x18(%ebp),%eax
   12545:	c1 e8 03             	shr    $0x3,%eax
   12548:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   1254b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12552:	e9 c6 00 00 00       	jmp    1261d <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   12557:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1255e:	e9 a6 00 00 00       	jmp    12609 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   12563:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12566:	8b 14 85 38 a4 01 00 	mov    0x1a438(,%eax,4),%edx
   1256d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12570:	8b 04 85 70 a4 01 00 	mov    0x1a470(,%eax,4),%eax
   12577:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1257b:	01 d0                	add    %edx,%eax
   1257d:	0f af 45 10          	imul   0x10(%ebp),%eax
   12581:	89 c2                	mov    %eax,%edx
   12583:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12586:	8b 04 85 54 a4 01 00 	mov    0x1a454(,%eax,4),%eax
   1258d:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   12591:	01 c2                	add    %eax,%edx
   12593:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12596:	8b 04 85 1c a4 01 00 	mov    0x1a41c(,%eax,4),%eax
   1259d:	01 c2                	add    %eax,%edx
   1259f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125a2:	0f af c2             	imul   %edx,%eax
   125a5:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   125a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125ab:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   125b2:	89 c1                	mov    %eax,%ecx
   125b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125b7:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   125bb:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   125bf:	89 c2                	mov    %eax,%edx
   125c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   125c4:	01 c2                	add    %eax,%edx
   125c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125c9:	0f af c2             	imul   %edx,%eax
   125cc:	01 c8                	add    %ecx,%eax
   125ce:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   125d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   125d8:	eb 23                	jmp    125fd <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   125da:	8b 55 d8             	mov    -0x28(%ebp),%edx
   125dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   125e0:	01 c2                	add    %eax,%edx
   125e2:	8b 45 08             	mov    0x8(%ebp),%eax
   125e5:	01 c2                	add    %eax,%edx
   125e7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   125ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
   125ed:	01 c1                	add    %eax,%ecx
   125ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   125f2:	01 c8                	add    %ecx,%eax
   125f4:	0f b6 00             	movzbl (%eax),%eax
   125f7:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   125f9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   125fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12600:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12603:	72 d5                	jb     125da <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12605:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12609:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1260c:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12610:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12613:	0f 87 4a ff ff ff    	ja     12563 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12619:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1261d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12620:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12624:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12627:	0f 87 2a ff ff ff    	ja     12557 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   1262d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12631:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12635:	0f 85 07 ff ff ff    	jne    12542 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1263b:	e9 22 01 00 00       	jmp    12762 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12640:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12647:	e9 0c 01 00 00       	jmp    12758 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   1264c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1264f:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12653:	0f af 45 18          	imul   0x18(%ebp),%eax
   12657:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   1265a:	8b 45 18             	mov    0x18(%ebp),%eax
   1265d:	0f af 45 10          	imul   0x10(%ebp),%eax
   12661:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12664:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1266b:	e9 d4 00 00 00       	jmp    12744 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   12670:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12677:	e9 b4 00 00 00       	jmp    12730 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   1267c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1267f:	8b 14 85 38 a4 01 00 	mov    0x1a438(,%eax,4),%edx
   12686:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12689:	8b 04 85 70 a4 01 00 	mov    0x1a470(,%eax,4),%eax
   12690:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   12694:	01 d0                	add    %edx,%eax
   12696:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   1269a:	89 c2                	mov    %eax,%edx
   1269c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1269f:	8b 0c 85 1c a4 01 00 	mov    0x1a41c(,%eax,4),%ecx
   126a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   126a9:	8b 04 85 54 a4 01 00 	mov    0x1a454(,%eax,4),%eax
   126b0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   126b4:	01 c8                	add    %ecx,%eax
   126b6:	0f af 45 18          	imul   0x18(%ebp),%eax
   126ba:	01 d0                	add    %edx,%eax
   126bc:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   126c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   126c5:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   126cc:	c1 e0 03             	shl    $0x3,%eax
   126cf:	89 c1                	mov    %eax,%ecx
   126d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   126d4:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   126d8:	89 c2                	mov    %eax,%edx
   126da:	8b 45 ec             	mov    -0x14(%ebp),%eax
   126dd:	0f af 45 18          	imul   0x18(%ebp),%eax
   126e1:	01 d0                	add    %edx,%eax
   126e3:	01 c8                	add    %ecx,%eax
   126e5:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   126eb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   126f2:	eb 30                	jmp    12724 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   126f4:	ff 75 0c             	pushl  0xc(%ebp)
   126f7:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   126fd:	50                   	push   %eax
   126fe:	e8 34 5e ff ff       	call   8537 <readBitFromReversedStream>
   12703:	83 c4 08             	add    $0x8,%esp
   12706:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12709:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   1270d:	50                   	push   %eax
   1270e:	ff 75 08             	pushl  0x8(%ebp)
   12711:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12717:	50                   	push   %eax
   12718:	e8 9c 5e ff ff       	call   85b9 <setBitOfReversedStream>
   1271d:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   12720:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   12724:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12727:	3b 45 18             	cmp    0x18(%ebp),%eax
   1272a:	72 c8                	jb     126f4 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1272c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12730:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12733:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12737:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1273a:	0f 87 3c ff ff ff    	ja     1267c <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12740:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12744:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12747:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   1274b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1274e:	0f 87 1c ff ff ff    	ja     12670 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12754:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12758:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1275c:	0f 85 ea fe ff ff    	jne    1264c <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12762:	90                   	nop
   12763:	c9                   	leave  
   12764:	c3                   	ret    

00012765 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   12765:	55                   	push   %ebp
   12766:	89 e5                	mov    %esp,%ebp
   12768:	57                   	push   %edi
   12769:	56                   	push   %esi
   1276a:	53                   	push   %ebx
   1276b:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   12771:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12774:	83 c0 0c             	add    $0xc,%eax
   12777:	50                   	push   %eax
   12778:	e8 77 6a ff ff       	call   91f4 <lodepng_get_bpp>
   1277d:	83 c4 04             	add    $0x4,%esp
   12780:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   12783:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   1278a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1278d:	8b 40 08             	mov    0x8(%eax),%eax
   12790:	85 c0                	test   %eax,%eax
   12792:	0f 85 49 01 00 00    	jne    128e1 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   12798:	8b 45 14             	mov    0x14(%ebp),%eax
   1279b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1279f:	83 c0 07             	add    $0x7,%eax
   127a2:	c1 e8 03             	shr    $0x3,%eax
   127a5:	83 c0 01             	add    $0x1,%eax
   127a8:	0f af 45 18          	imul   0x18(%ebp),%eax
   127ac:	89 c2                	mov    %eax,%edx
   127ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   127b1:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   127b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   127b6:	8b 00                	mov    (%eax),%eax
   127b8:	83 ec 0c             	sub    $0xc,%esp
   127bb:	50                   	push   %eax
   127bc:	e8 17 0f ff ff       	call   36d8 <lodepng_malloc>
   127c1:	83 c4 10             	add    $0x10,%esp
   127c4:	89 c2                	mov    %eax,%edx
   127c6:	8b 45 08             	mov    0x8(%ebp),%eax
   127c9:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   127cb:	8b 45 08             	mov    0x8(%ebp),%eax
   127ce:	8b 00                	mov    (%eax),%eax
   127d0:	85 c0                	test   %eax,%eax
   127d2:	75 10                	jne    127e4 <preProcessScanlines+0x7f>
   127d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   127d7:	8b 00                	mov    (%eax),%eax
   127d9:	85 c0                	test   %eax,%eax
   127db:	74 07                	je     127e4 <preProcessScanlines+0x7f>
   127dd:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   127e4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   127e8:	0f 85 fb 02 00 00    	jne    12ae9 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   127ee:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   127f2:	0f 87 bd 00 00 00    	ja     128b5 <preProcessScanlines+0x150>
   127f8:	8b 45 14             	mov    0x14(%ebp),%eax
   127fb:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   127ff:	89 c2                	mov    %eax,%edx
   12801:	8b 45 14             	mov    0x14(%ebp),%eax
   12804:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12808:	83 c0 07             	add    $0x7,%eax
   1280b:	c1 e8 03             	shr    $0x3,%eax
   1280e:	c1 e0 03             	shl    $0x3,%eax
   12811:	39 c2                	cmp    %eax,%edx
   12813:	0f 84 9c 00 00 00    	je     128b5 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12819:	8b 45 14             	mov    0x14(%ebp),%eax
   1281c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12820:	83 c0 07             	add    $0x7,%eax
   12823:	c1 e8 03             	shr    $0x3,%eax
   12826:	0f af 45 18          	imul   0x18(%ebp),%eax
   1282a:	83 ec 0c             	sub    $0xc,%esp
   1282d:	50                   	push   %eax
   1282e:	e8 a5 0e ff ff       	call   36d8 <lodepng_malloc>
   12833:	83 c4 10             	add    $0x10,%esp
   12836:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12839:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1283d:	75 07                	jne    12846 <preProcessScanlines+0xe1>
   1283f:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12846:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1284a:	75 56                	jne    128a2 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   1284c:	8b 45 14             	mov    0x14(%ebp),%eax
   1284f:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12853:	89 c2                	mov    %eax,%edx
   12855:	8b 45 14             	mov    0x14(%ebp),%eax
   12858:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1285c:	83 c0 07             	add    $0x7,%eax
   1285f:	c1 e8 03             	shr    $0x3,%eax
   12862:	c1 e0 03             	shl    $0x3,%eax
   12865:	83 ec 0c             	sub    $0xc,%esp
   12868:	ff 75 18             	pushl  0x18(%ebp)
   1286b:	52                   	push   %edx
   1286c:	50                   	push   %eax
   1286d:	ff 75 10             	pushl  0x10(%ebp)
   12870:	ff 75 d8             	pushl  -0x28(%ebp)
   12873:	e8 e7 fb ff ff       	call   1245f <addPaddingBits>
   12878:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   1287b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1287e:	8d 50 0c             	lea    0xc(%eax),%edx
   12881:	8b 45 08             	mov    0x8(%ebp),%eax
   12884:	8b 00                	mov    (%eax),%eax
   12886:	83 ec 08             	sub    $0x8,%esp
   12889:	ff 75 20             	pushl  0x20(%ebp)
   1288c:	52                   	push   %edx
   1288d:	ff 75 18             	pushl  0x18(%ebp)
   12890:	ff 75 14             	pushl  0x14(%ebp)
   12893:	ff 75 d8             	pushl  -0x28(%ebp)
   12896:	50                   	push   %eax
   12897:	e8 dc f3 ff ff       	call   11c78 <filter>
   1289c:	83 c4 20             	add    $0x20,%esp
   1289f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   128a2:	83 ec 0c             	sub    $0xc,%esp
   128a5:	ff 75 d8             	pushl  -0x28(%ebp)
   128a8:	e8 4c 0e ff ff       	call   36f9 <lodepng_free>
   128ad:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   128b0:	e9 34 02 00 00       	jmp    12ae9 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   128b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128b8:	8d 50 0c             	lea    0xc(%eax),%edx
   128bb:	8b 45 08             	mov    0x8(%ebp),%eax
   128be:	8b 00                	mov    (%eax),%eax
   128c0:	83 ec 08             	sub    $0x8,%esp
   128c3:	ff 75 20             	pushl  0x20(%ebp)
   128c6:	52                   	push   %edx
   128c7:	ff 75 18             	pushl  0x18(%ebp)
   128ca:	ff 75 14             	pushl  0x14(%ebp)
   128cd:	ff 75 10             	pushl  0x10(%ebp)
   128d0:	50                   	push   %eax
   128d1:	e8 a2 f3 ff ff       	call   11c78 <filter>
   128d6:	83 c4 20             	add    $0x20,%esp
   128d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   128dc:	e9 08 02 00 00       	jmp    12ae9 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   128e1:	ff 75 dc             	pushl  -0x24(%ebp)
   128e4:	ff 75 18             	pushl  0x18(%ebp)
   128e7:	ff 75 14             	pushl  0x14(%ebp)
   128ea:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   128f0:	50                   	push   %eax
   128f1:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   128f7:	50                   	push   %eax
   128f8:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   128fe:	50                   	push   %eax
   128ff:	8d 45 98             	lea    -0x68(%ebp),%eax
   12902:	50                   	push   %eax
   12903:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12906:	50                   	push   %eax
   12907:	e8 19 ab ff ff       	call   d425 <Adam7_getpassvalues>
   1290c:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   1290f:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12915:	8b 45 0c             	mov    0xc(%ebp),%eax
   12918:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   1291a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1291d:	8b 00                	mov    (%eax),%eax
   1291f:	83 ec 0c             	sub    $0xc,%esp
   12922:	50                   	push   %eax
   12923:	e8 b0 0d ff ff       	call   36d8 <lodepng_malloc>
   12928:	83 c4 10             	add    $0x10,%esp
   1292b:	89 c2                	mov    %eax,%edx
   1292d:	8b 45 08             	mov    0x8(%ebp),%eax
   12930:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   12932:	8b 45 08             	mov    0x8(%ebp),%eax
   12935:	8b 00                	mov    (%eax),%eax
   12937:	85 c0                	test   %eax,%eax
   12939:	75 07                	jne    12942 <preProcessScanlines+0x1dd>
   1293b:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   12942:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12945:	83 ec 0c             	sub    $0xc,%esp
   12948:	50                   	push   %eax
   12949:	e8 8a 0d ff ff       	call   36d8 <lodepng_malloc>
   1294e:	83 c4 10             	add    $0x10,%esp
   12951:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   12954:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12958:	75 0e                	jne    12968 <preProcessScanlines+0x203>
   1295a:	8b 45 94             	mov    -0x6c(%ebp),%eax
   1295d:	85 c0                	test   %eax,%eax
   1295f:	74 07                	je     12968 <preProcessScanlines+0x203>
   12961:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12968:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1296c:	0f 85 69 01 00 00    	jne    12adb <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   12972:	83 ec 0c             	sub    $0xc,%esp
   12975:	ff 75 dc             	pushl  -0x24(%ebp)
   12978:	ff 75 18             	pushl  0x18(%ebp)
   1297b:	ff 75 14             	pushl  0x14(%ebp)
   1297e:	ff 75 10             	pushl  0x10(%ebp)
   12981:	ff 75 d4             	pushl  -0x2c(%ebp)
   12984:	e8 6c fb ff ff       	call   124f5 <Adam7_interlace>
   12989:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   1298c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   12993:	e9 36 01 00 00       	jmp    12ace <preProcessScanlines+0x369>
        if(bpp < 8) {
   12998:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   1299c:	0f 87 d6 00 00 00    	ja     12a78 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   129a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   129a5:	83 c0 01             	add    $0x1,%eax
   129a8:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   129af:	8b 45 e0             	mov    -0x20(%ebp),%eax
   129b2:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   129b9:	29 c2                	sub    %eax,%edx
   129bb:	89 d0                	mov    %edx,%eax
   129bd:	83 ec 0c             	sub    $0xc,%esp
   129c0:	50                   	push   %eax
   129c1:	e8 12 0d ff ff       	call   36d8 <lodepng_malloc>
   129c6:	83 c4 10             	add    $0x10,%esp
   129c9:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   129cc:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   129d0:	75 0c                	jne    129de <preProcessScanlines+0x279>
   129d2:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   129d9:	e9 fd 00 00 00       	jmp    12adb <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   129de:	8b 45 e0             	mov    -0x20(%ebp),%eax
   129e1:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   129e5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   129e8:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   129ec:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   129f0:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   129f2:	8b 55 e0             	mov    -0x20(%ebp),%edx
   129f5:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   129f9:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   129fd:	83 c2 07             	add    $0x7,%edx
   12a00:	c1 ea 03             	shr    $0x3,%edx
   12a03:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12a06:	89 d1                	mov    %edx,%ecx
   12a08:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12a0b:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   12a12:	89 d6                	mov    %edx,%esi
   12a14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12a17:	01 f2                	add    %esi,%edx
   12a19:	83 ec 0c             	sub    $0xc,%esp
   12a1c:	50                   	push   %eax
   12a1d:	53                   	push   %ebx
   12a1e:	51                   	push   %ecx
   12a1f:	52                   	push   %edx
   12a20:	ff 75 d0             	pushl  -0x30(%ebp)
   12a23:	e8 37 fa ff ff       	call   1245f <addPaddingBits>
   12a28:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12a2b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a2e:	8d 58 0c             	lea    0xc(%eax),%ebx
   12a31:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12a34:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12a38:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12a3b:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12a3f:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12a42:	8b 31                	mov    (%ecx),%esi
   12a44:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12a47:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12a4e:	01 f1                	add    %esi,%ecx
   12a50:	83 ec 08             	sub    $0x8,%esp
   12a53:	ff 75 20             	pushl  0x20(%ebp)
   12a56:	53                   	push   %ebx
   12a57:	52                   	push   %edx
   12a58:	50                   	push   %eax
   12a59:	ff 75 d0             	pushl  -0x30(%ebp)
   12a5c:	51                   	push   %ecx
   12a5d:	e8 16 f2 ff ff       	call   11c78 <filter>
   12a62:	83 c4 20             	add    $0x20,%esp
   12a65:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   12a68:	83 ec 0c             	sub    $0xc,%esp
   12a6b:	ff 75 d0             	pushl  -0x30(%ebp)
   12a6e:	e8 86 0c ff ff       	call   36f9 <lodepng_free>
   12a73:	83 c4 10             	add    $0x10,%esp
   12a76:	eb 4c                	jmp    12ac4 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   12a78:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a7b:	8d 70 0c             	lea    0xc(%eax),%esi
   12a7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12a81:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12a85:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12a88:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12a8c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12a8f:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   12a96:	89 cb                	mov    %ecx,%ebx
   12a98:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   12a9b:	01 cb                	add    %ecx,%ebx
   12a9d:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12aa0:	8b 39                	mov    (%ecx),%edi
   12aa2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12aa5:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12aac:	01 f9                	add    %edi,%ecx
   12aae:	83 ec 08             	sub    $0x8,%esp
   12ab1:	ff 75 20             	pushl  0x20(%ebp)
   12ab4:	56                   	push   %esi
   12ab5:	52                   	push   %edx
   12ab6:	50                   	push   %eax
   12ab7:	53                   	push   %ebx
   12ab8:	51                   	push   %ecx
   12ab9:	e8 ba f1 ff ff       	call   11c78 <filter>
   12abe:	83 c4 20             	add    $0x20,%esp
   12ac1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12ac4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12ac8:	75 10                	jne    12ada <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   12aca:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   12ace:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   12ad2:	0f 85 c0 fe ff ff    	jne    12998 <preProcessScanlines+0x233>
   12ad8:	eb 01                	jmp    12adb <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12ada:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12adb:	83 ec 0c             	sub    $0xc,%esp
   12ade:	ff 75 d4             	pushl  -0x2c(%ebp)
   12ae1:	e8 13 0c ff ff       	call   36f9 <lodepng_free>
   12ae6:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12ae9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12aec:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12aef:	5b                   	pop    %ebx
   12af0:	5e                   	pop    %esi
   12af1:	5f                   	pop    %edi
   12af2:	5d                   	pop    %ebp
   12af3:	c3                   	ret    

00012af4 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   12af4:	55                   	push   %ebp
   12af5:	89 e5                	mov    %esp,%ebp
   12af7:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12afa:	8b 45 0c             	mov    0xc(%ebp),%eax
   12afd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   12b00:	eb 47                	jmp    12b49 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   12b02:	8b 45 08             	mov    0x8(%ebp),%eax
   12b05:	8d 50 04             	lea    0x4(%eax),%edx
   12b08:	8b 45 08             	mov    0x8(%ebp),%eax
   12b0b:	ff 75 fc             	pushl  -0x4(%ebp)
   12b0e:	52                   	push   %edx
   12b0f:	50                   	push   %eax
   12b10:	e8 73 5f ff ff       	call   8a88 <lodepng_chunk_append>
   12b15:	83 c4 0c             	add    $0xc,%esp
   12b18:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12b1b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12b1f:	74 05                	je     12b26 <addUnknownChunks+0x32>
   12b21:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12b24:	eb 37                	jmp    12b5d <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12b26:	8b 45 08             	mov    0x8(%ebp),%eax
   12b29:	8b 50 04             	mov    0x4(%eax),%edx
   12b2c:	8b 45 08             	mov    0x8(%ebp),%eax
   12b2f:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   12b32:	8b 55 10             	mov    0x10(%ebp),%edx
   12b35:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b38:	01 d0                	add    %edx,%eax
   12b3a:	50                   	push   %eax
   12b3b:	ff 75 fc             	pushl  -0x4(%ebp)
   12b3e:	e8 ff 5c ff ff       	call   8842 <lodepng_chunk_next>
   12b43:	83 c4 08             	add    $0x8,%esp
   12b46:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12b49:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12b4c:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b4f:	29 c2                	sub    %eax,%edx
   12b51:	89 d0                	mov    %edx,%eax
   12b53:	3b 45 10             	cmp    0x10(%ebp),%eax
   12b56:	7c aa                	jl     12b02 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12b58:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12b5d:	c9                   	leave  
   12b5e:	c3                   	ret    

00012b5f <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   12b5f:	55                   	push   %ebp
   12b60:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   12b62:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12b66:	77 07                	ja     12b6f <isGrayICCProfile+0x10>
   12b68:	b8 00 00 00 00       	mov    $0x0,%eax
   12b6d:	eb 40                	jmp    12baf <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12b6f:	8b 45 08             	mov    0x8(%ebp),%eax
   12b72:	83 c0 10             	add    $0x10,%eax
   12b75:	0f b6 00             	movzbl (%eax),%eax
   12b78:	3c 47                	cmp    $0x47,%al
   12b7a:	75 2e                	jne    12baa <isGrayICCProfile+0x4b>
   12b7c:	8b 45 08             	mov    0x8(%ebp),%eax
   12b7f:	83 c0 11             	add    $0x11,%eax
   12b82:	0f b6 00             	movzbl (%eax),%eax
   12b85:	3c 52                	cmp    $0x52,%al
   12b87:	75 21                	jne    12baa <isGrayICCProfile+0x4b>
   12b89:	8b 45 08             	mov    0x8(%ebp),%eax
   12b8c:	83 c0 12             	add    $0x12,%eax
   12b8f:	0f b6 00             	movzbl (%eax),%eax
   12b92:	3c 41                	cmp    $0x41,%al
   12b94:	75 14                	jne    12baa <isGrayICCProfile+0x4b>
   12b96:	8b 45 08             	mov    0x8(%ebp),%eax
   12b99:	83 c0 13             	add    $0x13,%eax
   12b9c:	0f b6 00             	movzbl (%eax),%eax
   12b9f:	3c 59                	cmp    $0x59,%al
   12ba1:	75 07                	jne    12baa <isGrayICCProfile+0x4b>
   12ba3:	b8 01 00 00 00       	mov    $0x1,%eax
   12ba8:	eb 05                	jmp    12baf <isGrayICCProfile+0x50>
   12baa:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12baf:	5d                   	pop    %ebp
   12bb0:	c3                   	ret    

00012bb1 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   12bb1:	55                   	push   %ebp
   12bb2:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   12bb4:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12bb8:	77 07                	ja     12bc1 <isRGBICCProfile+0x10>
   12bba:	b8 00 00 00 00       	mov    $0x0,%eax
   12bbf:	eb 40                	jmp    12c01 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   12bc1:	8b 45 08             	mov    0x8(%ebp),%eax
   12bc4:	83 c0 10             	add    $0x10,%eax
   12bc7:	0f b6 00             	movzbl (%eax),%eax
   12bca:	3c 52                	cmp    $0x52,%al
   12bcc:	75 2e                	jne    12bfc <isRGBICCProfile+0x4b>
   12bce:	8b 45 08             	mov    0x8(%ebp),%eax
   12bd1:	83 c0 11             	add    $0x11,%eax
   12bd4:	0f b6 00             	movzbl (%eax),%eax
   12bd7:	3c 47                	cmp    $0x47,%al
   12bd9:	75 21                	jne    12bfc <isRGBICCProfile+0x4b>
   12bdb:	8b 45 08             	mov    0x8(%ebp),%eax
   12bde:	83 c0 12             	add    $0x12,%eax
   12be1:	0f b6 00             	movzbl (%eax),%eax
   12be4:	3c 42                	cmp    $0x42,%al
   12be6:	75 14                	jne    12bfc <isRGBICCProfile+0x4b>
   12be8:	8b 45 08             	mov    0x8(%ebp),%eax
   12beb:	83 c0 13             	add    $0x13,%eax
   12bee:	0f b6 00             	movzbl (%eax),%eax
   12bf1:	3c 20                	cmp    $0x20,%al
   12bf3:	75 07                	jne    12bfc <isRGBICCProfile+0x4b>
   12bf5:	b8 01 00 00 00       	mov    $0x1,%eax
   12bfa:	eb 05                	jmp    12c01 <isRGBICCProfile+0x50>
   12bfc:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12c01:	5d                   	pop    %ebp
   12c02:	c3                   	ret    

00012c03 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12c03:	55                   	push   %ebp
   12c04:	89 e5                	mov    %esp,%ebp
   12c06:	57                   	push   %edi
   12c07:	56                   	push   %esi
   12c08:	53                   	push   %ebx
   12c09:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   12c0f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12c16:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12c1d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12c20:	6a 00                	push   $0x0
   12c22:	6a 00                	push   $0x0
   12c24:	50                   	push   %eax
   12c25:	e8 6f 0d ff ff       	call   3999 <ucvector_init>
   12c2a:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12c2d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c30:	05 98 00 00 00       	add    $0x98,%eax
   12c35:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12c38:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c3e:	50                   	push   %eax
   12c3f:	e8 3a 71 ff ff       	call   9d7e <lodepng_info_init>
   12c44:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12c47:	8b 45 08             	mov    0x8(%ebp),%eax
   12c4a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   12c50:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12c59:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c5c:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   12c63:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   12c66:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c69:	8b 40 0c             	mov    0xc(%eax),%eax
   12c6c:	83 f8 03             	cmp    $0x3,%eax
   12c6f:	74 0a                	je     12c7b <lodepng_encode+0x78>
   12c71:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c74:	8b 40 6c             	mov    0x6c(%eax),%eax
   12c77:	85 c0                	test   %eax,%eax
   12c79:	74 29                	je     12ca4 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12c7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c7e:	8b 40 18             	mov    0x18(%eax),%eax
   12c81:	85 c0                	test   %eax,%eax
   12c83:	74 0d                	je     12c92 <lodepng_encode+0x8f>
   12c85:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c88:	8b 40 18             	mov    0x18(%eax),%eax
   12c8b:	3d 00 01 00 00       	cmp    $0x100,%eax
   12c90:	7e 12                	jle    12ca4 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   12c92:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c95:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   12c9c:	00 00 00 
    goto cleanup;
   12c9f:	e9 78 0c 00 00       	jmp    1391c <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   12ca4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ca7:	8b 40 38             	mov    0x38(%eax),%eax
   12caa:	83 f8 02             	cmp    $0x2,%eax
   12cad:	76 12                	jbe    12cc1 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   12caf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cb2:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12cb9:	00 00 00 
    goto cleanup;
   12cbc:	e9 5b 0c 00 00       	jmp    1391c <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   12cc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cc4:	8b 40 08             	mov    0x8(%eax),%eax
   12cc7:	83 f8 01             	cmp    $0x1,%eax
   12cca:	76 12                	jbe    12cde <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   12ccc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ccf:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12cd6:	00 00 00 
    goto cleanup;
   12cd9:	e9 3e 0c 00 00       	jmp    1391c <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   12cde:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ce1:	8b 50 10             	mov    0x10(%eax),%edx
   12ce4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ce7:	8b 40 0c             	mov    0xc(%eax),%eax
   12cea:	52                   	push   %edx
   12ceb:	50                   	push   %eax
   12cec:	e8 a4 5f ff ff       	call   8c95 <checkColorValidity>
   12cf1:	83 c4 08             	add    $0x8,%esp
   12cf4:	89 c2                	mov    %eax,%edx
   12cf6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cf9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12cff:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d02:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d08:	85 c0                	test   %eax,%eax
   12d0a:	0f 85 c6 0b 00 00    	jne    138d6 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   12d10:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d13:	8b 50 7c             	mov    0x7c(%eax),%edx
   12d16:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d19:	8b 40 78             	mov    0x78(%eax),%eax
   12d1c:	52                   	push   %edx
   12d1d:	50                   	push   %eax
   12d1e:	e8 72 5f ff ff       	call   8c95 <checkColorValidity>
   12d23:	83 c4 08             	add    $0x8,%esp
   12d26:	89 c2                	mov    %eax,%edx
   12d28:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d2b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12d31:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d34:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d3a:	85 c0                	test   %eax,%eax
   12d3c:	0f 85 97 0b 00 00    	jne    138d9 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12d42:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d45:	05 98 00 00 00       	add    $0x98,%eax
   12d4a:	83 ec 08             	sub    $0x8,%esp
   12d4d:	50                   	push   %eax
   12d4e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d54:	50                   	push   %eax
   12d55:	e8 58 71 ff ff       	call   9eb2 <lodepng_info_copy>
   12d5a:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12d5d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d60:	8b 40 5c             	mov    0x5c(%eax),%eax
   12d63:	85 c0                	test   %eax,%eax
   12d65:	0f 84 3c 02 00 00    	je     12fa7 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12d6b:	83 ec 0c             	sub    $0xc,%esp
   12d6e:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12d74:	50                   	push   %eax
   12d75:	e8 5f 96 ff ff       	call   c3d9 <lodepng_color_stats_init>
   12d7a:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12d7d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d80:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12d86:	85 c0                	test   %eax,%eax
   12d88:	74 2d                	je     12db7 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12d8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d8d:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12d93:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d96:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12d9c:	83 ec 08             	sub    $0x8,%esp
   12d9f:	52                   	push   %edx
   12da0:	50                   	push   %eax
   12da1:	e8 b9 fd ff ff       	call   12b5f <isGrayICCProfile>
   12da6:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12da9:	85 c0                	test   %eax,%eax
   12dab:	74 0a                	je     12db7 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12dad:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12db4:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12db7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12dba:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12dc0:	85 c0                	test   %eax,%eax
   12dc2:	74 2d                	je     12df1 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12dc4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12dc7:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12dcd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12dd0:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12dd6:	83 ec 08             	sub    $0x8,%esp
   12dd9:	52                   	push   %edx
   12dda:	50                   	push   %eax
   12ddb:	e8 d1 fd ff ff       	call   12bb1 <isRGBICCProfile>
   12de0:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12de3:	85 c0                	test   %eax,%eax
   12de5:	74 0a                	je     12df1 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12de7:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12dee:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12df1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12df4:	83 c0 78             	add    $0x78,%eax
   12df7:	83 ec 0c             	sub    $0xc,%esp
   12dfa:	50                   	push   %eax
   12dfb:	ff 75 18             	pushl  0x18(%ebp)
   12dfe:	ff 75 14             	pushl  0x14(%ebp)
   12e01:	ff 75 10             	pushl  0x10(%ebp)
   12e04:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12e0a:	50                   	push   %eax
   12e0b:	e8 e0 96 ff ff       	call   c4f0 <lodepng_compute_color_stats>
   12e10:	83 c4 20             	add    $0x20,%esp
   12e13:	89 c2                	mov    %eax,%edx
   12e15:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e18:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e1e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e21:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e27:	85 c0                	test   %eax,%eax
   12e29:	0f 85 ad 0a 00 00    	jne    138dc <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12e2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e32:	8b 40 2c             	mov    0x2c(%eax),%eax
   12e35:	85 c0                	test   %eax,%eax
   12e37:	0f 84 be 00 00 00    	je     12efb <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12e3d:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12e44:	00 00 00 
   12e47:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12e4e:	00 00 00 
   12e51:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12e58:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12e5b:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12e61:	83 ec 04             	sub    $0x4,%esp
   12e64:	6a 10                	push   $0x10
   12e66:	6a 02                	push   $0x2
   12e68:	50                   	push   %eax
   12e69:	e8 15 61 ff ff       	call   8f83 <lodepng_color_mode_make>
   12e6e:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12e71:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e74:	8d 58 0c             	lea    0xc(%eax),%ebx
   12e77:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e7a:	8b 48 38             	mov    0x38(%eax),%ecx
   12e7d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e80:	8b 50 34             	mov    0x34(%eax),%edx
   12e83:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e86:	8b 40 30             	mov    0x30(%eax),%eax
   12e89:	53                   	push   %ebx
   12e8a:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12e90:	53                   	push   %ebx
   12e91:	51                   	push   %ecx
   12e92:	52                   	push   %edx
   12e93:	50                   	push   %eax
   12e94:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12e9a:	50                   	push   %eax
   12e9b:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12ea1:	50                   	push   %eax
   12ea2:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12ea8:	50                   	push   %eax
   12ea9:	e8 8a 92 ff ff       	call   c138 <lodepng_convert_rgb>
   12eae:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12eb1:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12eb7:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12ebd:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12ec3:	83 ec 0c             	sub    $0xc,%esp
   12ec6:	68 ff ff 00 00       	push   $0xffff
   12ecb:	51                   	push   %ecx
   12ecc:	52                   	push   %edx
   12ecd:	50                   	push   %eax
   12ece:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12ed4:	50                   	push   %eax
   12ed5:	e8 26 a1 ff ff       	call   d000 <lodepng_color_stats_add>
   12eda:	83 c4 20             	add    $0x20,%esp
   12edd:	89 c2                	mov    %eax,%edx
   12edf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ee2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ee8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eeb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ef1:	85 c0                	test   %eax,%eax
   12ef3:	74 06                	je     12efb <lodepng_encode+0x2f8>
   12ef5:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12ef6:	e9 e1 09 00 00       	jmp    138dc <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12efb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12efe:	8d 50 78             	lea    0x78(%eax),%edx
   12f01:	83 ec 04             	sub    $0x4,%esp
   12f04:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12f0a:	50                   	push   %eax
   12f0b:	52                   	push   %edx
   12f0c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f12:	83 c0 0c             	add    $0xc,%eax
   12f15:	50                   	push   %eax
   12f16:	e8 79 a1 ff ff       	call   d094 <auto_choose_color>
   12f1b:	83 c4 10             	add    $0x10,%esp
   12f1e:	89 c2                	mov    %eax,%edx
   12f20:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f23:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12f29:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f2c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f32:	85 c0                	test   %eax,%eax
   12f34:	0f 85 a5 09 00 00    	jne    138df <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12f3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f3d:	8b 40 2c             	mov    0x2c(%eax),%eax
   12f40:	85 c0                	test   %eax,%eax
   12f42:	74 63                	je     12fa7 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12f44:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f47:	8d 58 0c             	lea    0xc(%eax),%ebx
   12f4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f4d:	8b 48 38             	mov    0x38(%eax),%ecx
   12f50:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f53:	8b 50 34             	mov    0x34(%eax),%edx
   12f56:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f59:	8b 40 30             	mov    0x30(%eax),%eax
   12f5c:	53                   	push   %ebx
   12f5d:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12f63:	83 c3 0c             	add    $0xc,%ebx
   12f66:	53                   	push   %ebx
   12f67:	51                   	push   %ecx
   12f68:	52                   	push   %edx
   12f69:	50                   	push   %eax
   12f6a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f70:	83 c0 38             	add    $0x38,%eax
   12f73:	50                   	push   %eax
   12f74:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f7a:	83 c0 34             	add    $0x34,%eax
   12f7d:	50                   	push   %eax
   12f7e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f84:	83 c0 30             	add    $0x30,%eax
   12f87:	50                   	push   %eax
   12f88:	e8 ab 91 ff ff       	call   c138 <lodepng_convert_rgb>
   12f8d:	83 c4 20             	add    $0x20,%esp
   12f90:	85 c0                	test   %eax,%eax
   12f92:	74 13                	je     12fa7 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12f94:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f97:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12f9e:	00 00 00 
        goto cleanup;
   12fa1:	90                   	nop
   12fa2:	e9 75 09 00 00       	jmp    1391c <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12fa7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12faa:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12fb0:	85 c0                	test   %eax,%eax
   12fb2:	0f 84 b2 00 00 00    	je     1306a <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12fb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12fbb:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12fc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12fc4:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12fca:	83 ec 08             	sub    $0x8,%esp
   12fcd:	52                   	push   %edx
   12fce:	50                   	push   %eax
   12fcf:	e8 8b fb ff ff       	call   12b5f <isGrayICCProfile>
   12fd4:	83 c4 10             	add    $0x10,%esp
   12fd7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12fda:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12fdd:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12fe3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12fe6:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12fec:	83 ec 08             	sub    $0x8,%esp
   12fef:	52                   	push   %edx
   12ff0:	50                   	push   %eax
   12ff1:	e8 bb fb ff ff       	call   12bb1 <isRGBICCProfile>
   12ff6:	83 c4 10             	add    $0x10,%esp
   12ff9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12ffc:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13002:	85 c0                	test   %eax,%eax
   13004:	74 0b                	je     13011 <lodepng_encode+0x40e>
   13006:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1300c:	83 f8 04             	cmp    $0x4,%eax
   1300f:	75 07                	jne    13018 <lodepng_encode+0x415>
   13011:	b8 01 00 00 00       	mov    $0x1,%eax
   13016:	eb 05                	jmp    1301d <lodepng_encode+0x41a>
   13018:	b8 00 00 00 00       	mov    $0x0,%eax
   1301d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   13020:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   13024:	75 18                	jne    1303e <lodepng_encode+0x43b>
   13026:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   1302a:	75 12                	jne    1303e <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   1302c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1302f:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   13036:	00 00 00 
      goto cleanup;
   13039:	e9 de 08 00 00       	jmp    1391c <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   1303e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   13041:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   13044:	74 24                	je     1306a <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   13046:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13049:	8b 40 5c             	mov    0x5c(%eax),%eax
   1304c:	85 c0                	test   %eax,%eax
   1304e:	74 07                	je     13057 <lodepng_encode+0x454>
   13050:	ba 66 00 00 00       	mov    $0x66,%edx
   13055:	eb 05                	jmp    1305c <lodepng_encode+0x459>
   13057:	ba 65 00 00 00       	mov    $0x65,%edx
   1305c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1305f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   13065:	e9 b2 08 00 00       	jmp    1391c <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   1306a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1306d:	83 c0 78             	add    $0x78,%eax
   13070:	83 ec 08             	sub    $0x8,%esp
   13073:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   13079:	83 c2 0c             	add    $0xc,%edx
   1307c:	52                   	push   %edx
   1307d:	50                   	push   %eax
   1307e:	e8 57 5f ff ff       	call   8fda <lodepng_color_mode_equal>
   13083:	83 c4 10             	add    $0x10,%esp
   13086:	85 c0                	test   %eax,%eax
   13088:	0f 85 f8 00 00 00    	jne    13186 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   1308e:	8b 55 14             	mov    0x14(%ebp),%edx
   13091:	8b 45 18             	mov    0x18(%ebp),%eax
   13094:	89 d3                	mov    %edx,%ebx
   13096:	0f af d8             	imul   %eax,%ebx
   13099:	83 ec 0c             	sub    $0xc,%esp
   1309c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130a2:	83 c0 0c             	add    $0xc,%eax
   130a5:	50                   	push   %eax
   130a6:	e8 49 61 ff ff       	call   91f4 <lodepng_get_bpp>
   130ab:	83 c4 10             	add    $0x10,%esp
   130ae:	0f af c3             	imul   %ebx,%eax
   130b1:	83 c0 07             	add    $0x7,%eax
   130b4:	c1 e8 03             	shr    $0x3,%eax
   130b7:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   130ba:	83 ec 0c             	sub    $0xc,%esp
   130bd:	ff 75 cc             	pushl  -0x34(%ebp)
   130c0:	e8 13 06 ff ff       	call   36d8 <lodepng_malloc>
   130c5:	83 c4 10             	add    $0x10,%esp
   130c8:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   130cb:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   130cf:	75 13                	jne    130e4 <lodepng_encode+0x4e1>
   130d1:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   130d5:	74 0d                	je     130e4 <lodepng_encode+0x4e1>
   130d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130da:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   130e1:	00 00 00 
    if(!state->error) {
   130e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130e7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130ed:	85 c0                	test   %eax,%eax
   130ef:	75 33                	jne    13124 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   130f1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130f4:	83 c0 78             	add    $0x78,%eax
   130f7:	83 ec 08             	sub    $0x8,%esp
   130fa:	ff 75 18             	pushl  0x18(%ebp)
   130fd:	ff 75 14             	pushl  0x14(%ebp)
   13100:	50                   	push   %eax
   13101:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13107:	83 c0 0c             	add    $0xc,%eax
   1310a:	50                   	push   %eax
   1310b:	ff 75 10             	pushl  0x10(%ebp)
   1310e:	ff 75 c8             	pushl  -0x38(%ebp)
   13111:	e8 c9 8c ff ff       	call   bddf <lodepng_convert>
   13116:	83 c4 20             	add    $0x20,%esp
   13119:	89 c2                	mov    %eax,%edx
   1311b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1311e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   13124:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13127:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1312d:	85 c0                	test   %eax,%eax
   1312f:	75 35                	jne    13166 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   13131:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13134:	83 c0 38             	add    $0x38,%eax
   13137:	83 ec 04             	sub    $0x4,%esp
   1313a:	50                   	push   %eax
   1313b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13141:	50                   	push   %eax
   13142:	ff 75 18             	pushl  0x18(%ebp)
   13145:	ff 75 14             	pushl  0x14(%ebp)
   13148:	ff 75 c8             	pushl  -0x38(%ebp)
   1314b:	8d 45 bc             	lea    -0x44(%ebp),%eax
   1314e:	50                   	push   %eax
   1314f:	8d 45 c0             	lea    -0x40(%ebp),%eax
   13152:	50                   	push   %eax
   13153:	e8 0d f6 ff ff       	call   12765 <preProcessScanlines>
   13158:	83 c4 20             	add    $0x20,%esp
   1315b:	89 c2                	mov    %eax,%edx
   1315d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13160:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   13166:	83 ec 0c             	sub    $0xc,%esp
   13169:	ff 75 c8             	pushl  -0x38(%ebp)
   1316c:	e8 88 05 ff ff       	call   36f9 <lodepng_free>
   13171:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   13174:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13177:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1317d:	85 c0                	test   %eax,%eax
   1317f:	74 4b                	je     131cc <lodepng_encode+0x5c9>
   13181:	e9 96 07 00 00       	jmp    1391c <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   13186:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13189:	83 c0 38             	add    $0x38,%eax
   1318c:	83 ec 04             	sub    $0x4,%esp
   1318f:	50                   	push   %eax
   13190:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13196:	50                   	push   %eax
   13197:	ff 75 18             	pushl  0x18(%ebp)
   1319a:	ff 75 14             	pushl  0x14(%ebp)
   1319d:	ff 75 10             	pushl  0x10(%ebp)
   131a0:	8d 45 bc             	lea    -0x44(%ebp),%eax
   131a3:	50                   	push   %eax
   131a4:	8d 45 c0             	lea    -0x40(%ebp),%eax
   131a7:	50                   	push   %eax
   131a8:	e8 b8 f5 ff ff       	call   12765 <preProcessScanlines>
   131ad:	83 c4 20             	add    $0x20,%esp
   131b0:	89 c2                	mov    %eax,%edx
   131b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131b5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   131bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131be:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131c4:	85 c0                	test   %eax,%eax
   131c6:	0f 85 16 07 00 00    	jne    138e2 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   131cc:	83 ec 0c             	sub    $0xc,%esp
   131cf:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131d2:	50                   	push   %eax
   131d3:	e8 21 d9 ff ff       	call   10af9 <writeSignature>
   131d8:	83 c4 10             	add    $0x10,%esp
   131db:	89 c2                	mov    %eax,%edx
   131dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131e0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   131e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131e9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131ef:	85 c0                	test   %eax,%eax
   131f1:	0f 85 ee 06 00 00    	jne    138e5 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   131f7:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   131fd:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   13203:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13209:	83 ec 08             	sub    $0x8,%esp
   1320c:	51                   	push   %ecx
   1320d:	52                   	push   %edx
   1320e:	50                   	push   %eax
   1320f:	ff 75 18             	pushl  0x18(%ebp)
   13212:	ff 75 14             	pushl  0x14(%ebp)
   13215:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13218:	50                   	push   %eax
   13219:	e8 4a d9 ff ff       	call   10b68 <addChunk_IHDR>
   1321e:	83 c4 20             	add    $0x20,%esp
   13221:	89 c2                	mov    %eax,%edx
   13223:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13226:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1322c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1322f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13235:	85 c0                	test   %eax,%eax
   13237:	0f 85 ab 06 00 00    	jne    138e8 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   1323d:	8b 45 98             	mov    -0x68(%ebp),%eax
   13240:	85 c0                	test   %eax,%eax
   13242:	74 33                	je     13277 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   13244:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   13247:	8b 45 98             	mov    -0x68(%ebp),%eax
   1324a:	83 ec 04             	sub    $0x4,%esp
   1324d:	52                   	push   %edx
   1324e:	50                   	push   %eax
   1324f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13252:	50                   	push   %eax
   13253:	e8 9c f8 ff ff       	call   12af4 <addUnknownChunks>
   13258:	83 c4 10             	add    $0x10,%esp
   1325b:	89 c2                	mov    %eax,%edx
   1325d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13260:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13266:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13269:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1326f:	85 c0                	test   %eax,%eax
   13271:	0f 85 74 06 00 00    	jne    138eb <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   13277:	8b 45 88             	mov    -0x78(%ebp),%eax
   1327a:	85 c0                	test   %eax,%eax
   1327c:	74 39                	je     132b7 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   1327e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13281:	83 c0 38             	add    $0x38,%eax
   13284:	83 ec 04             	sub    $0x4,%esp
   13287:	50                   	push   %eax
   13288:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1328e:	50                   	push   %eax
   1328f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13292:	50                   	push   %eax
   13293:	e8 a4 e4 ff ff       	call   1173c <addChunk_iCCP>
   13298:	83 c4 10             	add    $0x10,%esp
   1329b:	89 c2                	mov    %eax,%edx
   1329d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   132a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132af:	85 c0                	test   %eax,%eax
   132b1:	0f 85 37 06 00 00    	jne    138ee <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   132b7:	8b 45 80             	mov    -0x80(%ebp),%eax
   132ba:	85 c0                	test   %eax,%eax
   132bc:	74 32                	je     132f0 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   132be:	83 ec 08             	sub    $0x8,%esp
   132c1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   132c7:	50                   	push   %eax
   132c8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   132cb:	50                   	push   %eax
   132cc:	e8 41 e4 ff ff       	call   11712 <addChunk_sRGB>
   132d1:	83 c4 10             	add    $0x10,%esp
   132d4:	89 c2                	mov    %eax,%edx
   132d6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132d9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   132df:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132e2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132e8:	85 c0                	test   %eax,%eax
   132ea:	0f 85 01 06 00 00    	jne    138f1 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   132f0:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   132f6:	85 c0                	test   %eax,%eax
   132f8:	74 32                	je     1332c <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   132fa:	83 ec 08             	sub    $0x8,%esp
   132fd:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13303:	50                   	push   %eax
   13304:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13307:	50                   	push   %eax
   13308:	e8 a7 e2 ff ff       	call   115b4 <addChunk_gAMA>
   1330d:	83 c4 10             	add    $0x10,%esp
   13310:	89 c2                	mov    %eax,%edx
   13312:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13315:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1331b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1331e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13324:	85 c0                	test   %eax,%eax
   13326:	0f 85 c8 05 00 00    	jne    138f4 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   1332c:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   13332:	85 c0                	test   %eax,%eax
   13334:	74 32                	je     13368 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   13336:	83 ec 08             	sub    $0x8,%esp
   13339:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1333f:	50                   	push   %eax
   13340:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13343:	50                   	push   %eax
   13344:	e8 c1 e2 ff ff       	call   1160a <addChunk_cHRM>
   13349:	83 c4 10             	add    $0x10,%esp
   1334c:	89 c2                	mov    %eax,%edx
   1334e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13351:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13357:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1335a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13360:	85 c0                	test   %eax,%eax
   13362:	0f 85 8f 05 00 00    	jne    138f7 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   13368:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1336e:	83 f8 03             	cmp    $0x3,%eax
   13371:	75 35                	jne    133a8 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   13373:	83 ec 08             	sub    $0x8,%esp
   13376:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1337c:	83 c0 0c             	add    $0xc,%eax
   1337f:	50                   	push   %eax
   13380:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13383:	50                   	push   %eax
   13384:	e8 78 d8 ff ff       	call   10c01 <addChunk_PLTE>
   13389:	83 c4 10             	add    $0x10,%esp
   1338c:	89 c2                	mov    %eax,%edx
   1338e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13391:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13397:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1339a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133a0:	85 c0                	test   %eax,%eax
   133a2:	0f 85 52 05 00 00    	jne    138fa <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   133a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ab:	8b 40 6c             	mov    0x6c(%eax),%eax
   133ae:	85 c0                	test   %eax,%eax
   133b0:	74 4b                	je     133fd <lodepng_encode+0x7fa>
   133b2:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   133b8:	83 f8 02             	cmp    $0x2,%eax
   133bb:	74 0b                	je     133c8 <lodepng_encode+0x7c5>
   133bd:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   133c3:	83 f8 06             	cmp    $0x6,%eax
   133c6:	75 35                	jne    133fd <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   133c8:	83 ec 08             	sub    $0x8,%esp
   133cb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   133d1:	83 c0 0c             	add    $0xc,%eax
   133d4:	50                   	push   %eax
   133d5:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133d8:	50                   	push   %eax
   133d9:	e8 23 d8 ff ff       	call   10c01 <addChunk_PLTE>
   133de:	83 c4 10             	add    $0x10,%esp
   133e1:	89 c2                	mov    %eax,%edx
   133e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133e6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   133ec:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ef:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133f5:	85 c0                	test   %eax,%eax
   133f7:	0f 85 00 05 00 00    	jne    138fd <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   133fd:	83 ec 08             	sub    $0x8,%esp
   13400:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13406:	83 c0 0c             	add    $0xc,%eax
   13409:	50                   	push   %eax
   1340a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1340d:	50                   	push   %eax
   1340e:	e8 c4 d8 ff ff       	call   10cd7 <addChunk_tRNS>
   13413:	83 c4 10             	add    $0x10,%esp
   13416:	89 c2                	mov    %eax,%edx
   13418:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1341b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13421:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13424:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1342a:	85 c0                	test   %eax,%eax
   1342c:	0f 85 ce 04 00 00    	jne    13900 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   13432:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13438:	85 c0                	test   %eax,%eax
   1343a:	74 32                	je     1346e <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   1343c:	83 ec 08             	sub    $0x8,%esp
   1343f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13445:	50                   	push   %eax
   13446:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13449:	50                   	push   %eax
   1344a:	e8 e4 de ff ff       	call   11333 <addChunk_bKGD>
   1344f:	83 c4 10             	add    $0x10,%esp
   13452:	89 c2                	mov    %eax,%edx
   13454:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13457:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1345d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13460:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13466:	85 c0                	test   %eax,%eax
   13468:	0f 85 95 04 00 00    	jne    13903 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   1346e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   13474:	85 c0                	test   %eax,%eax
   13476:	74 32                	je     134aa <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   13478:	83 ec 08             	sub    $0x8,%esp
   1347b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13481:	50                   	push   %eax
   13482:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13485:	50                   	push   %eax
   13486:	e8 ac e0 ff ff       	call   11537 <addChunk_pHYs>
   1348b:	83 c4 10             	add    $0x10,%esp
   1348e:	89 c2                	mov    %eax,%edx
   13490:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13493:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13499:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1349c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134a2:	85 c0                	test   %eax,%eax
   134a4:	0f 85 5c 04 00 00    	jne    13906 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   134aa:	8b 45 9c             	mov    -0x64(%ebp),%eax
   134ad:	85 c0                	test   %eax,%eax
   134af:	74 33                	je     134e4 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   134b1:	8b 55 a8             	mov    -0x58(%ebp),%edx
   134b4:	8b 45 9c             	mov    -0x64(%ebp),%eax
   134b7:	83 ec 04             	sub    $0x4,%esp
   134ba:	52                   	push   %edx
   134bb:	50                   	push   %eax
   134bc:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134bf:	50                   	push   %eax
   134c0:	e8 2f f6 ff ff       	call   12af4 <addUnknownChunks>
   134c5:	83 c4 10             	add    $0x10,%esp
   134c8:	89 c2                	mov    %eax,%edx
   134ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134cd:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   134d3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134d6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134dc:	85 c0                	test   %eax,%eax
   134de:	0f 85 25 04 00 00    	jne    13909 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   134e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134e7:	8d 48 38             	lea    0x38(%eax),%ecx
   134ea:	8b 55 bc             	mov    -0x44(%ebp),%edx
   134ed:	8b 45 c0             	mov    -0x40(%ebp),%eax
   134f0:	51                   	push   %ecx
   134f1:	52                   	push   %edx
   134f2:	50                   	push   %eax
   134f3:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134f6:	50                   	push   %eax
   134f7:	e8 bd d9 ff ff       	call   10eb9 <addChunk_IDAT>
   134fc:	83 c4 10             	add    $0x10,%esp
   134ff:	89 c2                	mov    %eax,%edx
   13501:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13504:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1350a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1350d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13513:	85 c0                	test   %eax,%eax
   13515:	0f 85 f1 03 00 00    	jne    1390c <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   1351b:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   13521:	85 c0                	test   %eax,%eax
   13523:	74 35                	je     1355a <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   13525:	83 ec 08             	sub    $0x8,%esp
   13528:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1352e:	83 c0 60             	add    $0x60,%eax
   13531:	50                   	push   %eax
   13532:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13535:	50                   	push   %eax
   13536:	e8 5c df ff ff       	call   11497 <addChunk_tIME>
   1353b:	83 c4 10             	add    $0x10,%esp
   1353e:	89 c2                	mov    %eax,%edx
   13540:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13543:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13549:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1354c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13552:	85 c0                	test   %eax,%eax
   13554:	0f 85 b5 03 00 00    	jne    1390f <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   1355a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13561:	e9 12 01 00 00       	jmp    13678 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   13566:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1356c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1356f:	c1 e2 02             	shl    $0x2,%edx
   13572:	01 d0                	add    %edx,%eax
   13574:	8b 00                	mov    (%eax),%eax
   13576:	83 ec 0c             	sub    $0xc,%esp
   13579:	50                   	push   %eax
   1357a:	e8 f5 01 ff ff       	call   3774 <lodepng_strlen>
   1357f:	83 c4 10             	add    $0x10,%esp
   13582:	83 f8 4f             	cmp    $0x4f,%eax
   13585:	7e 12                	jle    13599 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   13587:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1358a:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13591:	00 00 00 
        goto cleanup;
   13594:	e9 83 03 00 00       	jmp    1391c <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   13599:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1359f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   135a2:	c1 e2 02             	shl    $0x2,%edx
   135a5:	01 d0                	add    %edx,%eax
   135a7:	8b 00                	mov    (%eax),%eax
   135a9:	83 ec 0c             	sub    $0xc,%esp
   135ac:	50                   	push   %eax
   135ad:	e8 c2 01 ff ff       	call   3774 <lodepng_strlen>
   135b2:	83 c4 10             	add    $0x10,%esp
   135b5:	85 c0                	test   %eax,%eax
   135b7:	7f 12                	jg     135cb <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   135b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135bc:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   135c3:	00 00 00 
        goto cleanup;
   135c6:	e9 51 03 00 00       	jmp    1391c <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   135cb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135ce:	8b 40 74             	mov    0x74(%eax),%eax
   135d1:	85 c0                	test   %eax,%eax
   135d3:	74 52                	je     13627 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   135d5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135d8:	8d 48 38             	lea    0x38(%eax),%ecx
   135db:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   135e1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   135e4:	c1 e2 02             	shl    $0x2,%edx
   135e7:	01 d0                	add    %edx,%eax
   135e9:	8b 10                	mov    (%eax),%edx
   135eb:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   135f1:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   135f4:	c1 e3 02             	shl    $0x2,%ebx
   135f7:	01 d8                	add    %ebx,%eax
   135f9:	8b 00                	mov    (%eax),%eax
   135fb:	51                   	push   %ecx
   135fc:	52                   	push   %edx
   135fd:	50                   	push   %eax
   135fe:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13601:	50                   	push   %eax
   13602:	e8 fa d9 ff ff       	call   11001 <addChunk_zTXt>
   13607:	83 c4 10             	add    $0x10,%esp
   1360a:	89 c2                	mov    %eax,%edx
   1360c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1360f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13615:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13618:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1361e:	85 c0                	test   %eax,%eax
   13620:	74 52                	je     13674 <lodepng_encode+0xa71>
   13622:	e9 f5 02 00 00       	jmp    1391c <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13627:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1362d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13630:	c1 e2 02             	shl    $0x2,%edx
   13633:	01 d0                	add    %edx,%eax
   13635:	8b 10                	mov    (%eax),%edx
   13637:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1363d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   13640:	c1 e1 02             	shl    $0x2,%ecx
   13643:	01 c8                	add    %ecx,%eax
   13645:	8b 00                	mov    (%eax),%eax
   13647:	83 ec 04             	sub    $0x4,%esp
   1364a:	52                   	push   %edx
   1364b:	50                   	push   %eax
   1364c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1364f:	50                   	push   %eax
   13650:	e8 ec d8 ff ff       	call   10f41 <addChunk_tEXt>
   13655:	83 c4 10             	add    $0x10,%esp
   13658:	89 c2                	mov    %eax,%edx
   1365a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1365d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13663:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13666:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1366c:	85 c0                	test   %eax,%eax
   1366e:	0f 85 9e 02 00 00    	jne    13912 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13674:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13678:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1367e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13681:	0f 85 df fe ff ff    	jne    13566 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   13687:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1368a:	8b 40 70             	mov    0x70(%eax),%eax
   1368d:	85 c0                	test   %eax,%eax
   1368f:	0f 84 e3 00 00 00    	je     13778 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   13695:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   1369c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   136a3:	e9 85 00 00 00       	jmp    1372d <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   136a8:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   136ae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   136b1:	c1 e2 02             	shl    $0x2,%edx
   136b4:	01 d0                	add    %edx,%eax
   136b6:	8b 00                	mov    (%eax),%eax
   136b8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   136bb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   136be:	0f b6 00             	movzbl (%eax),%eax
   136c1:	3c 4c                	cmp    $0x4c,%al
   136c3:	75 64                	jne    13729 <lodepng_encode+0xb26>
   136c5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   136c8:	83 c0 01             	add    $0x1,%eax
   136cb:	0f b6 00             	movzbl (%eax),%eax
   136ce:	3c 6f                	cmp    $0x6f,%al
   136d0:	75 57                	jne    13729 <lodepng_encode+0xb26>
   136d2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   136d5:	83 c0 02             	add    $0x2,%eax
   136d8:	0f b6 00             	movzbl (%eax),%eax
   136db:	3c 64                	cmp    $0x64,%al
   136dd:	75 4a                	jne    13729 <lodepng_encode+0xb26>
   136df:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   136e2:	83 c0 03             	add    $0x3,%eax
   136e5:	0f b6 00             	movzbl (%eax),%eax
   136e8:	3c 65                	cmp    $0x65,%al
   136ea:	75 3d                	jne    13729 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   136ec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   136ef:	83 c0 04             	add    $0x4,%eax
   136f2:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   136f5:	3c 50                	cmp    $0x50,%al
   136f7:	75 30                	jne    13729 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   136f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   136fc:	83 c0 05             	add    $0x5,%eax
   136ff:	0f b6 00             	movzbl (%eax),%eax
   13702:	3c 4e                	cmp    $0x4e,%al
   13704:	75 23                	jne    13729 <lodepng_encode+0xb26>
   13706:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13709:	83 c0 06             	add    $0x6,%eax
   1370c:	0f b6 00             	movzbl (%eax),%eax
   1370f:	3c 47                	cmp    $0x47,%al
   13711:	75 16                	jne    13729 <lodepng_encode+0xb26>
   13713:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13716:	83 c0 07             	add    $0x7,%eax
   13719:	0f b6 00             	movzbl (%eax),%eax
   1371c:	84 c0                	test   %al,%al
   1371e:	75 09                	jne    13729 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   13720:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13727:	eb 13                	jmp    1373c <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13729:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1372d:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13733:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13736:	0f 85 6c ff ff ff    	jne    136a8 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   1373c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13740:	75 36                	jne    13778 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   13742:	a1 a0 e5 01 00       	mov    0x1e5a0,%eax
   13747:	83 ec 04             	sub    $0x4,%esp
   1374a:	50                   	push   %eax
   1374b:	68 04 a5 01 00       	push   $0x1a504
   13750:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13753:	50                   	push   %eax
   13754:	e8 e8 d7 ff ff       	call   10f41 <addChunk_tEXt>
   13759:	83 c4 10             	add    $0x10,%esp
   1375c:	89 c2                	mov    %eax,%edx
   1375e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13761:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13767:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1376a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13770:	85 c0                	test   %eax,%eax
   13772:	0f 85 9d 01 00 00    	jne    13915 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13778:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1377f:	e9 e6 00 00 00       	jmp    1386a <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   13784:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   1378a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1378d:	c1 e2 02             	shl    $0x2,%edx
   13790:	01 d0                	add    %edx,%eax
   13792:	8b 00                	mov    (%eax),%eax
   13794:	83 ec 0c             	sub    $0xc,%esp
   13797:	50                   	push   %eax
   13798:	e8 d7 ff fe ff       	call   3774 <lodepng_strlen>
   1379d:	83 c4 10             	add    $0x10,%esp
   137a0:	83 f8 4f             	cmp    $0x4f,%eax
   137a3:	7e 12                	jle    137b7 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   137a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137a8:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   137af:	00 00 00 
        goto cleanup;
   137b2:	e9 65 01 00 00       	jmp    1391c <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   137b7:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   137bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   137c0:	c1 e2 02             	shl    $0x2,%edx
   137c3:	01 d0                	add    %edx,%eax
   137c5:	8b 00                	mov    (%eax),%eax
   137c7:	83 ec 0c             	sub    $0xc,%esp
   137ca:	50                   	push   %eax
   137cb:	e8 a4 ff fe ff       	call   3774 <lodepng_strlen>
   137d0:	83 c4 10             	add    $0x10,%esp
   137d3:	85 c0                	test   %eax,%eax
   137d5:	7f 12                	jg     137e9 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   137d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137da:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   137e1:	00 00 00 
        goto cleanup;
   137e4:	e9 33 01 00 00       	jmp    1391c <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   137e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137ec:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   137ef:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   137f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   137f8:	c1 e2 02             	shl    $0x2,%edx
   137fb:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   137fd:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   137ff:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13805:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13808:	c1 e2 02             	shl    $0x2,%edx
   1380b:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1380d:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1380f:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13815:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13818:	c1 e2 02             	shl    $0x2,%edx
   1381b:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1381d:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1381f:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13825:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13828:	c1 e2 02             	shl    $0x2,%edx
   1382b:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1382d:	8b 10                	mov    (%eax),%edx
   1382f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13832:	8b 40 74             	mov    0x74(%eax),%eax
   13835:	83 ec 04             	sub    $0x4,%esp
   13838:	57                   	push   %edi
   13839:	56                   	push   %esi
   1383a:	53                   	push   %ebx
   1383b:	51                   	push   %ecx
   1383c:	52                   	push   %edx
   1383d:	50                   	push   %eax
   1383e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13841:	50                   	push   %eax
   13842:	e8 dc d8 ff ff       	call   11123 <addChunk_iTXt>
   13847:	83 c4 20             	add    $0x20,%esp
   1384a:	89 c2                	mov    %eax,%edx
   1384c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1384f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13855:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13858:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1385e:	85 c0                	test   %eax,%eax
   13860:	0f 85 b2 00 00 00    	jne    13918 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13866:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1386a:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   13870:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13873:	0f 85 0b ff ff ff    	jne    13784 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   13879:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1387c:	85 c0                	test   %eax,%eax
   1387e:	74 2f                	je     138af <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   13880:	8b 55 ac             	mov    -0x54(%ebp),%edx
   13883:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13886:	83 ec 04             	sub    $0x4,%esp
   13889:	52                   	push   %edx
   1388a:	50                   	push   %eax
   1388b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1388e:	50                   	push   %eax
   1388f:	e8 60 f2 ff ff       	call   12af4 <addUnknownChunks>
   13894:	83 c4 10             	add    $0x10,%esp
   13897:	89 c2                	mov    %eax,%edx
   13899:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1389c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   138a2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138a5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   138ab:	85 c0                	test   %eax,%eax
   138ad:	75 6c                	jne    1391b <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   138af:	83 ec 0c             	sub    $0xc,%esp
   138b2:	8d 45 b0             	lea    -0x50(%ebp),%eax
   138b5:	50                   	push   %eax
   138b6:	e8 6d d6 ff ff       	call   10f28 <addChunk_IEND>
   138bb:	83 c4 10             	add    $0x10,%esp
   138be:	89 c2                	mov    %eax,%edx
   138c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138c3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   138c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138cc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   138d2:	85 c0                	test   %eax,%eax
   138d4:	eb 46                	jmp    1391c <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   138d6:	90                   	nop
   138d7:	eb 43                	jmp    1391c <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   138d9:	90                   	nop
   138da:	eb 40                	jmp    1391c <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   138dc:	90                   	nop
   138dd:	eb 3d                	jmp    1391c <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   138df:	90                   	nop
   138e0:	eb 3a                	jmp    1391c <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   138e2:	90                   	nop
   138e3:	eb 37                	jmp    1391c <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   138e5:	90                   	nop
   138e6:	eb 34                	jmp    1391c <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   138e8:	90                   	nop
   138e9:	eb 31                	jmp    1391c <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   138eb:	90                   	nop
   138ec:	eb 2e                	jmp    1391c <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   138ee:	90                   	nop
   138ef:	eb 2b                	jmp    1391c <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   138f1:	90                   	nop
   138f2:	eb 28                	jmp    1391c <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   138f4:	90                   	nop
   138f5:	eb 25                	jmp    1391c <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   138f7:	90                   	nop
   138f8:	eb 22                	jmp    1391c <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   138fa:	90                   	nop
   138fb:	eb 1f                	jmp    1391c <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   138fd:	90                   	nop
   138fe:	eb 1c                	jmp    1391c <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   13900:	90                   	nop
   13901:	eb 19                	jmp    1391c <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13903:	90                   	nop
   13904:	eb 16                	jmp    1391c <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13906:	90                   	nop
   13907:	eb 13                	jmp    1391c <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13909:	90                   	nop
   1390a:	eb 10                	jmp    1391c <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   1390c:	90                   	nop
   1390d:	eb 0d                	jmp    1391c <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   1390f:	90                   	nop
   13910:	eb 0a                	jmp    1391c <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   13912:	90                   	nop
   13913:	eb 07                	jmp    1391c <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13915:	90                   	nop
   13916:	eb 04                	jmp    1391c <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13918:	90                   	nop
   13919:	eb 01                	jmp    1391c <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   1391b:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   1391c:	83 ec 0c             	sub    $0xc,%esp
   1391f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13925:	50                   	push   %eax
   13926:	e8 34 65 ff ff       	call   9e5f <lodepng_info_cleanup>
   1392b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   1392e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13931:	83 ec 0c             	sub    $0xc,%esp
   13934:	50                   	push   %eax
   13935:	e8 bf fd fe ff       	call   36f9 <lodepng_free>
   1393a:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   1393d:	8b 55 b0             	mov    -0x50(%ebp),%edx
   13940:	8b 45 08             	mov    0x8(%ebp),%eax
   13943:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13945:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13948:	8b 45 0c             	mov    0xc(%ebp),%eax
   1394b:	89 10                	mov    %edx,(%eax)

  return state->error;
   1394d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13950:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13956:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13959:	5b                   	pop    %ebx
   1395a:	5e                   	pop    %esi
   1395b:	5f                   	pop    %edi
   1395c:	5d                   	pop    %ebp
   1395d:	c3                   	ret    

0001395e <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   1395e:	55                   	push   %ebp
   1395f:	89 e5                	mov    %esp,%ebp
   13961:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   13967:	83 ec 0c             	sub    $0xc,%esp
   1396a:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13970:	50                   	push   %eax
   13971:	e8 38 d0 ff ff       	call   109ae <lodepng_state_init>
   13976:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   13979:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1397c:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   13982:	8b 45 20             	mov    0x20(%ebp),%eax
   13985:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   1398b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1398e:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   13994:	8b 45 20             	mov    0x20(%ebp),%eax
   13997:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   1399d:	83 ec 08             	sub    $0x8,%esp
   139a0:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   139a6:	50                   	push   %eax
   139a7:	ff 75 18             	pushl  0x18(%ebp)
   139aa:	ff 75 14             	pushl  0x14(%ebp)
   139ad:	ff 75 10             	pushl  0x10(%ebp)
   139b0:	ff 75 0c             	pushl  0xc(%ebp)
   139b3:	ff 75 08             	pushl  0x8(%ebp)
   139b6:	e8 48 f2 ff ff       	call   12c03 <lodepng_encode>
   139bb:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   139be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   139c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   139c4:	83 ec 0c             	sub    $0xc,%esp
   139c7:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   139cd:	50                   	push   %eax
   139ce:	e8 35 d0 ff ff       	call   10a08 <lodepng_state_cleanup>
   139d3:	83 c4 10             	add    $0x10,%esp
  return error;
   139d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   139d9:	c9                   	leave  
   139da:	c3                   	ret    

000139db <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   139db:	55                   	push   %ebp
   139dc:	89 e5                	mov    %esp,%ebp
   139de:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   139e1:	83 ec 04             	sub    $0x4,%esp
   139e4:	6a 08                	push   $0x8
   139e6:	6a 06                	push   $0x6
   139e8:	ff 75 18             	pushl  0x18(%ebp)
   139eb:	ff 75 14             	pushl  0x14(%ebp)
   139ee:	ff 75 10             	pushl  0x10(%ebp)
   139f1:	ff 75 0c             	pushl  0xc(%ebp)
   139f4:	ff 75 08             	pushl  0x8(%ebp)
   139f7:	e8 62 ff ff ff       	call   1395e <lodepng_encode_memory>
   139fc:	83 c4 20             	add    $0x20,%esp
}
   139ff:	c9                   	leave  
   13a00:	c3                   	ret    

00013a01 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13a01:	55                   	push   %ebp
   13a02:	89 e5                	mov    %esp,%ebp
   13a04:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13a07:	83 ec 04             	sub    $0x4,%esp
   13a0a:	6a 08                	push   $0x8
   13a0c:	6a 02                	push   $0x2
   13a0e:	ff 75 18             	pushl  0x18(%ebp)
   13a11:	ff 75 14             	pushl  0x14(%ebp)
   13a14:	ff 75 10             	pushl  0x10(%ebp)
   13a17:	ff 75 0c             	pushl  0xc(%ebp)
   13a1a:	ff 75 08             	pushl  0x8(%ebp)
   13a1d:	e8 3c ff ff ff       	call   1395e <lodepng_encode_memory>
   13a22:	83 c4 20             	add    $0x20,%esp
}
   13a25:	c9                   	leave  
   13a26:	c3                   	ret    

00013a27 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13a27:	55                   	push   %ebp
   13a28:	89 e5                	mov    %esp,%ebp
   13a2a:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13a2d:	83 ec 04             	sub    $0x4,%esp
   13a30:	ff 75 1c             	pushl  0x1c(%ebp)
   13a33:	ff 75 18             	pushl  0x18(%ebp)
   13a36:	ff 75 14             	pushl  0x14(%ebp)
   13a39:	ff 75 10             	pushl  0x10(%ebp)
   13a3c:	ff 75 0c             	pushl  0xc(%ebp)
   13a3f:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13a42:	50                   	push   %eax
   13a43:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13a46:	50                   	push   %eax
   13a47:	e8 12 ff ff ff       	call   1395e <lodepng_encode_memory>
   13a4c:	83 c4 20             	add    $0x20,%esp
   13a4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   13a52:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13a56:	75 19                	jne    13a71 <lodepng_encode_file+0x4a>
   13a58:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13a5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13a5e:	83 ec 04             	sub    $0x4,%esp
   13a61:	ff 75 08             	pushl  0x8(%ebp)
   13a64:	52                   	push   %edx
   13a65:	50                   	push   %eax
   13a66:	e8 36 01 ff ff       	call   3ba1 <lodepng_save_file>
   13a6b:	83 c4 10             	add    $0x10,%esp
   13a6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   13a71:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13a74:	83 ec 0c             	sub    $0xc,%esp
   13a77:	50                   	push   %eax
   13a78:	e8 7c fc fe ff       	call   36f9 <lodepng_free>
   13a7d:	83 c4 10             	add    $0x10,%esp
  return error;
   13a80:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13a83:	c9                   	leave  
   13a84:	c3                   	ret    

00013a85 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13a85:	55                   	push   %ebp
   13a86:	89 e5                	mov    %esp,%ebp
   13a88:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   13a8b:	83 ec 08             	sub    $0x8,%esp
   13a8e:	6a 08                	push   $0x8
   13a90:	6a 06                	push   $0x6
   13a92:	ff 75 14             	pushl  0x14(%ebp)
   13a95:	ff 75 10             	pushl  0x10(%ebp)
   13a98:	ff 75 0c             	pushl  0xc(%ebp)
   13a9b:	ff 75 08             	pushl  0x8(%ebp)
   13a9e:	e8 84 ff ff ff       	call   13a27 <lodepng_encode_file>
   13aa3:	83 c4 20             	add    $0x20,%esp
}
   13aa6:	c9                   	leave  
   13aa7:	c3                   	ret    

00013aa8 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13aa8:	55                   	push   %ebp
   13aa9:	89 e5                	mov    %esp,%ebp
   13aab:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   13aae:	83 ec 08             	sub    $0x8,%esp
   13ab1:	6a 08                	push   $0x8
   13ab3:	6a 02                	push   $0x2
   13ab5:	ff 75 14             	pushl  0x14(%ebp)
   13ab8:	ff 75 10             	pushl  0x10(%ebp)
   13abb:	ff 75 0c             	pushl  0xc(%ebp)
   13abe:	ff 75 08             	pushl  0x8(%ebp)
   13ac1:	e8 61 ff ff ff       	call   13a27 <lodepng_encode_file>
   13ac6:	83 c4 20             	add    $0x20,%esp
}
   13ac9:	c9                   	leave  
   13aca:	c3                   	ret    

00013acb <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   13acb:	55                   	push   %ebp
   13acc:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   13ace:	8b 45 08             	mov    0x8(%ebp),%eax
   13ad1:	50                   	push   %eax
   13ad2:	e8 71 49 ff ff       	call   8448 <lodepng_compress_settings_init>
   13ad7:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13ada:	8b 45 08             	mov    0x8(%ebp),%eax
   13add:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   13ae4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ae7:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   13aee:	8b 45 08             	mov    0x8(%ebp),%eax
   13af1:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13af8:	8b 45 08             	mov    0x8(%ebp),%eax
   13afb:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   13b02:	8b 45 08             	mov    0x8(%ebp),%eax
   13b05:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13b0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b0f:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13b16:	8b 45 08             	mov    0x8(%ebp),%eax
   13b19:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   13b20:	90                   	nop
   13b21:	c9                   	leave  
   13b22:	c3                   	ret    

00013b23 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   13b23:	55                   	push   %ebp
   13b24:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13b26:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13b2a:	0f 87 c1 03 00 00    	ja     13ef1 <lodepng_error_text+0x3ce>
   13b30:	8b 45 08             	mov    0x8(%ebp),%eax
   13b33:	c1 e0 02             	shl    $0x2,%eax
   13b36:	05 40 b8 01 00       	add    $0x1b840,%eax
   13b3b:	8b 00                	mov    (%eax),%eax
   13b3d:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   13b3f:	b8 0c a5 01 00       	mov    $0x1a50c,%eax
   13b44:	e9 ad 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13b49:	b8 29 a5 01 00       	mov    $0x1a529,%eax
   13b4e:	e9 a3 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   13b53:	b8 3c a5 01 00       	mov    $0x1a53c,%eax
   13b58:	e9 99 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13b5d:	b8 74 a5 01 00       	mov    $0x1a574,%eax
   13b62:	e9 8f 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   13b67:	b8 ac a5 01 00       	mov    $0x1a5ac,%eax
   13b6c:	e9 85 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   13b71:	b8 ac a5 01 00       	mov    $0x1a5ac,%eax
   13b76:	e9 7b 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13b7b:	b8 ac a5 01 00       	mov    $0x1a5ac,%eax
   13b80:	e9 71 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   13b85:	b8 dc a5 01 00       	mov    $0x1a5dc,%eax
   13b8a:	e9 67 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13b8f:	b8 10 a6 01 00       	mov    $0x1a610,%eax
   13b94:	e9 5d 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   13b99:	b8 44 a6 01 00       	mov    $0x1a644,%eax
   13b9e:	e9 53 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   13ba3:	b8 10 a6 01 00       	mov    $0x1a610,%eax
   13ba8:	e9 49 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13bad:	b8 6c a6 01 00       	mov    $0x1a66c,%eax
   13bb2:	e9 3f 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13bb7:	b8 a4 a6 01 00       	mov    $0x1a6a4,%eax
   13bbc:	e9 35 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   13bc1:	b8 10 a6 01 00       	mov    $0x1a610,%eax
   13bc6:	e9 2b 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13bcb:	b8 dc a6 01 00       	mov    $0x1a6dc,%eax
   13bd0:	e9 21 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13bd5:	b8 0c a7 01 00       	mov    $0x1a70c,%eax
   13bda:	e9 17 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   13bdf:	b8 2c a7 01 00       	mov    $0x1a72c,%eax
   13be4:	e9 0d 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13be9:	b8 58 a7 01 00       	mov    $0x1a758,%eax
   13bee:	e9 03 03 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   13bf3:	b8 98 a7 01 00       	mov    $0x1a798,%eax
   13bf8:	e9 f9 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13bfd:	b8 c0 a7 01 00       	mov    $0x1a7c0,%eax
   13c02:	e9 ef 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13c07:	b8 f4 a7 01 00       	mov    $0x1a7f4,%eax
   13c0c:	e9 e5 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   13c11:	b8 18 a8 01 00       	mov    $0x1a818,%eax
   13c16:	e9 db 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13c1b:	b8 50 a8 01 00       	mov    $0x1a850,%eax
   13c20:	e9 d1 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13c25:	b8 70 a8 01 00       	mov    $0x1a870,%eax
   13c2a:	e9 c7 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13c2f:	b8 8f a8 01 00       	mov    $0x1a88f,%eax
   13c34:	e9 bd 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13c39:	b8 a9 a8 01 00       	mov    $0x1a8a9,%eax
   13c3e:	e9 b3 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   13c43:	b8 c8 a8 01 00       	mov    $0x1a8c8,%eax
   13c48:	e9 a9 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13c4d:	b8 04 a9 01 00       	mov    $0x1a904,%eax
   13c52:	e9 9f 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   13c57:	b8 28 a9 01 00       	mov    $0x1a928,%eax
   13c5c:	e9 95 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   13c61:	b8 54 a9 01 00       	mov    $0x1a954,%eax
   13c66:	e9 8b 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13c6b:	b8 78 a9 01 00       	mov    $0x1a978,%eax
   13c70:	e9 81 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   13c75:	b8 b8 a9 01 00       	mov    $0x1a9b8,%eax
   13c7a:	e9 77 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13c7f:	b8 e8 a9 01 00       	mov    $0x1a9e8,%eax
   13c84:	e9 6d 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   13c89:	b8 10 aa 01 00       	mov    $0x1aa10,%eax
   13c8e:	e9 63 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   13c93:	b8 54 aa 01 00       	mov    $0x1aa54,%eax
   13c98:	e9 59 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   13c9d:	b8 80 aa 01 00       	mov    $0x1aa80,%eax
   13ca2:	e9 4f 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   13ca7:	b8 b0 aa 01 00       	mov    $0x1aab0,%eax
   13cac:	e9 45 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   13cb1:	b8 d8 aa 01 00       	mov    $0x1aad8,%eax
   13cb6:	e9 3b 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13cbb:	b8 20 ab 01 00       	mov    $0x1ab20,%eax
   13cc0:	e9 31 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   13cc5:	b8 20 ab 01 00       	mov    $0x1ab20,%eax
   13cca:	e9 27 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   13ccf:	b8 5c ab 01 00       	mov    $0x1ab5c,%eax
   13cd4:	e9 1d 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13cd9:	b8 90 ab 01 00       	mov    $0x1ab90,%eax
   13cde:	e9 13 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   13ce3:	b8 b3 ab 01 00       	mov    $0x1abb3,%eax
   13ce8:	e9 09 02 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   13ced:	b8 d0 ab 01 00       	mov    $0x1abd0,%eax
   13cf2:	e9 ff 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13cf7:	b8 0c ac 01 00       	mov    $0x1ac0c,%eax
   13cfc:	e9 f5 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   13d01:	b8 3c ac 01 00       	mov    $0x1ac3c,%eax
   13d06:	e9 eb 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13d0b:	b8 88 ac 01 00       	mov    $0x1ac88,%eax
   13d10:	e9 e1 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13d15:	b8 c0 ac 01 00       	mov    $0x1acc0,%eax
   13d1a:	e9 d7 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13d1f:	b8 00 ad 01 00       	mov    $0x1ad00,%eax
   13d24:	e9 cd 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13d29:	b8 2c ad 01 00       	mov    $0x1ad2c,%eax
   13d2e:	e9 c3 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13d33:	b8 78 ad 01 00       	mov    $0x1ad78,%eax
   13d38:	e9 b9 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13d3d:	b8 cc ad 01 00       	mov    $0x1adcc,%eax
   13d42:	e9 af 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13d47:	b8 00 ae 01 00       	mov    $0x1ae00,%eax
   13d4c:	e9 a5 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13d51:	b8 50 ae 01 00       	mov    $0x1ae50,%eax
   13d56:	e9 9b 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13d5b:	b8 8c ae 01 00       	mov    $0x1ae8c,%eax
   13d60:	e9 91 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   13d65:	b8 ec ae 01 00       	mov    $0x1aeec,%eax
   13d6a:	e9 87 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13d6f:	b8 4c af 01 00       	mov    $0x1af4c,%eax
   13d74:	e9 7d 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   13d79:	b8 a8 af 01 00       	mov    $0x1afa8,%eax
   13d7e:	e9 73 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13d83:	b8 ec af 01 00       	mov    $0x1afec,%eax
   13d88:	e9 69 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13d8d:	b8 28 b0 01 00       	mov    $0x1b028,%eax
   13d92:	e9 5f 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13d97:	b8 85 b0 01 00       	mov    $0x1b085,%eax
   13d9c:	e9 55 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13da1:	b8 9d b0 01 00       	mov    $0x1b09d,%eax
   13da6:	e9 4b 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13dab:	b8 b8 b0 01 00       	mov    $0x1b0b8,%eax
   13db0:	e9 41 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13db5:	b8 f4 b0 01 00       	mov    $0x1b0f4,%eax
   13dba:	e9 37 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13dbf:	b8 24 b1 01 00       	mov    $0x1b124,%eax
   13dc4:	e9 2d 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13dc9:	b8 44 b1 01 00       	mov    $0x1b144,%eax
   13dce:	e9 23 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13dd3:	b8 64 b1 01 00       	mov    $0x1b164,%eax
   13dd8:	e9 19 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13ddd:	b8 84 b1 01 00       	mov    $0x1b184,%eax
   13de2:	e9 0f 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13de7:	b8 a8 b1 01 00       	mov    $0x1b1a8,%eax
   13dec:	e9 05 01 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13df1:	b8 d0 b1 01 00       	mov    $0x1b1d0,%eax
   13df6:	e9 fb 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13dfb:	b8 2d b2 01 00       	mov    $0x1b22d,%eax
   13e00:	e9 f1 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13e05:	b8 48 b2 01 00       	mov    $0x1b248,%eax
   13e0a:	e9 e7 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13e0f:	b8 84 b2 01 00       	mov    $0x1b284,%eax
   13e14:	e9 dd 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13e19:	b8 b8 b2 01 00       	mov    $0x1b2b8,%eax
   13e1e:	e9 d3 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13e23:	b8 0c b3 01 00       	mov    $0x1b30c,%eax
   13e28:	e9 c9 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13e2d:	b8 58 b3 01 00       	mov    $0x1b358,%eax
   13e32:	e9 bf 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13e37:	b8 94 b3 01 00       	mov    $0x1b394,%eax
   13e3c:	e9 b5 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13e41:	b8 b8 b3 01 00       	mov    $0x1b3b8,%eax
   13e46:	e9 ab 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13e4b:	b8 d8 b3 01 00       	mov    $0x1b3d8,%eax
   13e50:	e9 a1 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13e55:	b8 00 b4 01 00       	mov    $0x1b400,%eax
   13e5a:	e9 97 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13e5f:	b8 20 b4 01 00       	mov    $0x1b420,%eax
   13e64:	e9 8d 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13e69:	b8 4c b4 01 00       	mov    $0x1b44c,%eax
   13e6e:	e9 83 00 00 00       	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13e73:	b8 7b b4 01 00       	mov    $0x1b47b,%eax
   13e78:	eb 7c                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13e7a:	b8 93 b4 01 00       	mov    $0x1b493,%eax
   13e7f:	eb 75                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13e81:	b8 ab b4 01 00       	mov    $0x1b4ab,%eax
   13e86:	eb 6e                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13e88:	b8 c3 b4 01 00       	mov    $0x1b4c3,%eax
   13e8d:	eb 67                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13e8f:	b8 e4 b4 01 00       	mov    $0x1b4e4,%eax
   13e94:	eb 60                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13e96:	b8 34 b5 01 00       	mov    $0x1b534,%eax
   13e9b:	eb 59                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13e9d:	b8 88 b5 01 00       	mov    $0x1b588,%eax
   13ea2:	eb 52                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13ea4:	b8 dc b5 01 00       	mov    $0x1b5dc,%eax
   13ea9:	eb 4b                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13eab:	b8 24 b6 01 00       	mov    $0x1b624,%eax
   13eb0:	eb 44                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13eb2:	b8 68 b6 01 00       	mov    $0x1b668,%eax
   13eb7:	eb 3d                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13eb9:	b8 84 b6 01 00       	mov    $0x1b684,%eax
   13ebe:	eb 36                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13ec0:	b8 bc b6 01 00       	mov    $0x1b6bc,%eax
   13ec5:	eb 2f                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13ec7:	b8 10 b7 01 00       	mov    $0x1b710,%eax
   13ecc:	eb 28                	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13ece:	b8 40 b7 01 00       	mov    $0x1b740,%eax
   13ed3:	eb 21                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13ed5:	b8 90 b7 01 00       	mov    $0x1b790,%eax
   13eda:	eb 1a                	jmp    13ef6 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13edc:	b8 bc b7 01 00       	mov    $0x1b7bc,%eax
   13ee1:	eb 13                	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13ee3:	b8 e8 b7 01 00       	mov    $0x1b7e8,%eax
   13ee8:	eb 0c                	jmp    13ef6 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13eea:	b8 0c b8 01 00       	mov    $0x1b80c,%eax
   13eef:	eb 05                	jmp    13ef6 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13ef1:	b8 2b b8 01 00       	mov    $0x1b82b,%eax
}
   13ef6:	5d                   	pop    %ebp
   13ef7:	c3                   	ret    

00013ef8 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13ef8:	55                   	push   %ebp
   13ef9:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13efb:	8b 45 08             	mov    0x8(%ebp),%eax
   13efe:	8b 40 28             	mov    0x28(%eax),%eax
   13f01:	83 f8 01             	cmp    $0x1,%eax
   13f04:	75 08                	jne    13f0e <GetImage+0x16>
   13f06:	8b 45 08             	mov    0x8(%ebp),%eax
   13f09:	8b 40 54             	mov    0x54(%eax),%eax
   13f0c:	eb 09                	jmp    13f17 <GetImage+0x1f>
   13f0e:	8b 45 08             	mov    0x8(%ebp),%eax
   13f11:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13f17:	5d                   	pop    %ebp
   13f18:	c3                   	ret    

00013f19 <GetWidth>:

int GetWidth(Context* ctx){
   13f19:	55                   	push   %ebp
   13f1a:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13f1c:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1f:	8b 40 10             	mov    0x10(%eax),%eax
}
   13f22:	5d                   	pop    %ebp
   13f23:	c3                   	ret    

00013f24 <GetHeight>:

int GetHeight(Context* ctx){
   13f24:	55                   	push   %ebp
   13f25:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13f27:	8b 45 08             	mov    0x8(%ebp),%eax
   13f2a:	8b 40 14             	mov    0x14(%eax),%eax
}
   13f2d:	5d                   	pop    %ebp
   13f2e:	c3                   	ret    

00013f2f <GetImageSize>:

uint GetImageSize(Context* ctx){
   13f2f:	55                   	push   %ebp
   13f30:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13f32:	8b 45 08             	mov    0x8(%ebp),%eax
   13f35:	8b 50 10             	mov    0x10(%eax),%edx
   13f38:	8b 45 08             	mov    0x8(%ebp),%eax
   13f3b:	8b 40 14             	mov    0x14(%eax),%eax
   13f3e:	0f af d0             	imul   %eax,%edx
   13f41:	8b 45 08             	mov    0x8(%ebp),%eax
   13f44:	8b 40 28             	mov    0x28(%eax),%eax
   13f47:	0f af c2             	imul   %edx,%eax
}
   13f4a:	5d                   	pop    %ebp
   13f4b:	c3                   	ret    

00013f4c <_Clip>:

uchar _Clip(const int x){
   13f4c:	55                   	push   %ebp
   13f4d:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13f4f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13f53:	78 15                	js     13f6a <_Clip+0x1e>
   13f55:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13f5c:	7f 05                	jg     13f63 <_Clip+0x17>
   13f5e:	8b 45 08             	mov    0x8(%ebp),%eax
   13f61:	eb 0c                	jmp    13f6f <_Clip+0x23>
   13f63:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13f68:	eb 05                	jmp    13f6f <_Clip+0x23>
   13f6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13f6f:	5d                   	pop    %ebp
   13f70:	c3                   	ret    

00013f71 <_Skip>:

void _Skip(Context* ctx, int c){
   13f71:	55                   	push   %ebp
   13f72:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13f74:	8b 45 08             	mov    0x8(%ebp),%eax
   13f77:	8b 50 04             	mov    0x4(%eax),%edx
   13f7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f7d:	01 c2                	add    %eax,%edx
   13f7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f82:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13f85:	8b 45 08             	mov    0x8(%ebp),%eax
   13f88:	8b 40 08             	mov    0x8(%eax),%eax
   13f8b:	2b 45 0c             	sub    0xc(%ebp),%eax
   13f8e:	89 c2                	mov    %eax,%edx
   13f90:	8b 45 08             	mov    0x8(%ebp),%eax
   13f93:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13f96:	8b 45 08             	mov    0x8(%ebp),%eax
   13f99:	8b 40 0c             	mov    0xc(%eax),%eax
   13f9c:	2b 45 0c             	sub    0xc(%ebp),%eax
   13f9f:	89 c2                	mov    %eax,%edx
   13fa1:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa4:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13fa7:	8b 45 08             	mov    0x8(%ebp),%eax
   13faa:	8b 40 08             	mov    0x8(%eax),%eax
   13fad:	85 c0                	test   %eax,%eax
   13faf:	79 09                	jns    13fba <_Skip+0x49>
   13fb1:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13fba:	90                   	nop
   13fbb:	5d                   	pop    %ebp
   13fbc:	c3                   	ret    

00013fbd <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13fbd:	55                   	push   %ebp
   13fbe:	89 e5                	mov    %esp,%ebp
   13fc0:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13fc3:	8b 45 08             	mov    0x8(%ebp),%eax
   13fc6:	8b 40 08             	mov    0x8(%eax),%eax
   13fc9:	83 f8 01             	cmp    $0x1,%eax
   13fcc:	7f 0b                	jg     13fd9 <_DecodeLength+0x1c>
   13fce:	8b 45 08             	mov    0x8(%ebp),%eax
   13fd1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13fd7:	eb 45                	jmp    1401e <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13fd9:	8b 45 08             	mov    0x8(%ebp),%eax
   13fdc:	8b 40 04             	mov    0x4(%eax),%eax
   13fdf:	83 ec 0c             	sub    $0xc,%esp
   13fe2:	50                   	push   %eax
   13fe3:	e8 38 00 00 00       	call   14020 <_Decode2Bytes>
   13fe8:	83 c4 10             	add    $0x10,%esp
   13feb:	89 c2                	mov    %eax,%edx
   13fed:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff0:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13ff3:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff6:	8b 50 0c             	mov    0xc(%eax),%edx
   13ff9:	8b 45 08             	mov    0x8(%ebp),%eax
   13ffc:	8b 40 08             	mov    0x8(%eax),%eax
   13fff:	39 c2                	cmp    %eax,%edx
   14001:	7e 0b                	jle    1400e <_DecodeLength+0x51>
   14003:	8b 45 08             	mov    0x8(%ebp),%eax
   14006:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1400c:	eb 10                	jmp    1401e <_DecodeLength+0x61>
    _Skip(ctx, 2);
   1400e:	83 ec 08             	sub    $0x8,%esp
   14011:	6a 02                	push   $0x2
   14013:	ff 75 08             	pushl  0x8(%ebp)
   14016:	e8 56 ff ff ff       	call   13f71 <_Skip>
   1401b:	83 c4 10             	add    $0x10,%esp
}
   1401e:	c9                   	leave  
   1401f:	c3                   	ret    

00014020 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   14020:	55                   	push   %ebp
   14021:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   14023:	8b 45 08             	mov    0x8(%ebp),%eax
   14026:	0f b6 00             	movzbl (%eax),%eax
   14029:	0f b6 c0             	movzbl %al,%eax
   1402c:	c1 e0 08             	shl    $0x8,%eax
   1402f:	89 c2                	mov    %eax,%edx
   14031:	8b 45 08             	mov    0x8(%ebp),%eax
   14034:	83 c0 01             	add    $0x1,%eax
   14037:	0f b6 00             	movzbl (%eax),%eax
   1403a:	0f b6 c0             	movzbl %al,%eax
   1403d:	09 d0                	or     %edx,%eax
}
   1403f:	5d                   	pop    %ebp
   14040:	c3                   	ret    

00014041 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   14041:	55                   	push   %ebp
   14042:	89 e5                	mov    %esp,%ebp
   14044:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   14047:	8b 45 08             	mov    0x8(%ebp),%eax
   1404a:	8b 55 10             	mov    0x10(%ebp),%edx
   1404d:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   14050:	8b 45 14             	mov    0x14(%ebp),%eax
   14053:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   14058:	89 c2                	mov    %eax,%edx
   1405a:	8b 45 08             	mov    0x8(%ebp),%eax
   1405d:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   14060:	8b 45 08             	mov    0x8(%ebp),%eax
   14063:	8b 40 08             	mov    0x8(%eax),%eax
   14066:	83 f8 01             	cmp    $0x1,%eax
   14069:	7e 1d                	jle    14088 <_DecodeJPEG+0x47>
   1406b:	8b 45 08             	mov    0x8(%ebp),%eax
   1406e:	8b 40 04             	mov    0x4(%eax),%eax
   14071:	0f b6 00             	movzbl (%eax),%eax
   14074:	3c ff                	cmp    $0xff,%al
   14076:	75 10                	jne    14088 <_DecodeJPEG+0x47>
   14078:	8b 45 08             	mov    0x8(%ebp),%eax
   1407b:	8b 40 04             	mov    0x4(%eax),%eax
   1407e:	83 c0 01             	add    $0x1,%eax
   14081:	0f b6 00             	movzbl (%eax),%eax
   14084:	3c d8                	cmp    $0xd8,%al
   14086:	74 0a                	je     14092 <_DecodeJPEG+0x51>
   14088:	b8 01 00 00 00       	mov    $0x1,%eax
   1408d:	e9 56 01 00 00       	jmp    141e8 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   14092:	6a 02                	push   $0x2
   14094:	ff 75 08             	pushl  0x8(%ebp)
   14097:	e8 d5 fe ff ff       	call   13f71 <_Skip>
   1409c:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   1409f:	e9 0a 01 00 00       	jmp    141ae <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   140a4:	8b 45 08             	mov    0x8(%ebp),%eax
   140a7:	8b 40 08             	mov    0x8(%eax),%eax
   140aa:	85 c0                	test   %eax,%eax
   140ac:	78 0d                	js     140bb <_DecodeJPEG+0x7a>
   140ae:	8b 45 08             	mov    0x8(%ebp),%eax
   140b1:	8b 40 04             	mov    0x4(%eax),%eax
   140b4:	0f b6 00             	movzbl (%eax),%eax
   140b7:	3c ff                	cmp    $0xff,%al
   140b9:	74 0a                	je     140c5 <_DecodeJPEG+0x84>
   140bb:	b8 05 00 00 00       	mov    $0x5,%eax
   140c0:	e9 23 01 00 00       	jmp    141e8 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   140c5:	6a 02                	push   $0x2
   140c7:	ff 75 08             	pushl  0x8(%ebp)
   140ca:	e8 a2 fe ff ff       	call   13f71 <_Skip>
   140cf:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   140d2:	8b 45 08             	mov    0x8(%ebp),%eax
   140d5:	8b 40 04             	mov    0x4(%eax),%eax
   140d8:	83 e8 01             	sub    $0x1,%eax
   140db:	0f b6 00             	movzbl (%eax),%eax
   140de:	0f b6 c0             	movzbl %al,%eax
   140e1:	3d da 00 00 00       	cmp    $0xda,%eax
   140e6:	74 71                	je     14159 <_DecodeJPEG+0x118>
   140e8:	3d da 00 00 00       	cmp    $0xda,%eax
   140ed:	7f 10                	jg     140ff <_DecodeJPEG+0xbe>
   140ef:	3d c0 00 00 00       	cmp    $0xc0,%eax
   140f4:	74 20                	je     14116 <_DecodeJPEG+0xd5>
   140f6:	3d c4 00 00 00       	cmp    $0xc4,%eax
   140fb:	74 2c                	je     14129 <_DecodeJPEG+0xe8>
   140fd:	eb 7d                	jmp    1417c <_DecodeJPEG+0x13b>
   140ff:	3d dd 00 00 00       	cmp    $0xdd,%eax
   14104:	74 43                	je     14149 <_DecodeJPEG+0x108>
   14106:	3d fe 00 00 00       	cmp    $0xfe,%eax
   1410b:	74 5f                	je     1416c <_DecodeJPEG+0x12b>
   1410d:	3d db 00 00 00       	cmp    $0xdb,%eax
   14112:	74 25                	je     14139 <_DecodeJPEG+0xf8>
   14114:	eb 66                	jmp    1417c <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   14116:	83 ec 0c             	sub    $0xc,%esp
   14119:	ff 75 08             	pushl  0x8(%ebp)
   1411c:	e8 c9 00 00 00       	call   141ea <_DecodeSOF>
   14121:	83 c4 10             	add    $0x10,%esp
   14124:	e9 85 00 00 00       	jmp    141ae <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   14129:	83 ec 0c             	sub    $0xc,%esp
   1412c:	ff 75 08             	pushl  0x8(%ebp)
   1412f:	e8 28 05 00 00       	call   1465c <_DecodeDHT>
   14134:	83 c4 10             	add    $0x10,%esp
   14137:	eb 75                	jmp    141ae <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   14139:	83 ec 0c             	sub    $0xc,%esp
   1413c:	ff 75 08             	pushl  0x8(%ebp)
   1413f:	e8 05 07 00 00       	call   14849 <_DecodeDQT>
   14144:	83 c4 10             	add    $0x10,%esp
   14147:	eb 65                	jmp    141ae <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   14149:	83 ec 0c             	sub    $0xc,%esp
   1414c:	ff 75 08             	pushl  0x8(%ebp)
   1414f:	e8 ff 07 00 00       	call   14953 <_DecodeDRI>
   14154:	83 c4 10             	add    $0x10,%esp
   14157:	eb 55                	jmp    141ae <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   14159:	83 ec 08             	sub    $0x8,%esp
   1415c:	ff 75 0c             	pushl  0xc(%ebp)
   1415f:	ff 75 08             	pushl  0x8(%ebp)
   14162:	e8 56 08 00 00       	call   149bd <_DecodeSOS>
   14167:	83 c4 10             	add    $0x10,%esp
   1416a:	eb 42                	jmp    141ae <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   1416c:	83 ec 0c             	sub    $0xc,%esp
   1416f:	ff 75 08             	pushl  0x8(%ebp)
   14172:	e8 a8 15 00 00       	call   1571f <_SkipMarker>
   14177:	83 c4 10             	add    $0x10,%esp
   1417a:	eb 32                	jmp    141ae <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   1417c:	8b 45 08             	mov    0x8(%ebp),%eax
   1417f:	8b 40 04             	mov    0x4(%eax),%eax
   14182:	83 e8 01             	sub    $0x1,%eax
   14185:	0f b6 00             	movzbl (%eax),%eax
   14188:	0f b6 c0             	movzbl %al,%eax
   1418b:	25 f0 00 00 00       	and    $0xf0,%eax
   14190:	3d e0 00 00 00       	cmp    $0xe0,%eax
   14195:	75 10                	jne    141a7 <_DecodeJPEG+0x166>
   14197:	83 ec 0c             	sub    $0xc,%esp
   1419a:	ff 75 08             	pushl  0x8(%ebp)
   1419d:	e8 7d 15 00 00       	call   1571f <_SkipMarker>
   141a2:	83 c4 10             	add    $0x10,%esp
   141a5:	eb 07                	jmp    141ae <_DecodeJPEG+0x16d>
                else return Unsupported;
   141a7:	b8 02 00 00 00       	mov    $0x2,%eax
   141ac:	eb 3a                	jmp    141e8 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   141ae:	8b 45 08             	mov    0x8(%ebp),%eax
   141b1:	8b 00                	mov    (%eax),%eax
   141b3:	85 c0                	test   %eax,%eax
   141b5:	0f 84 e9 fe ff ff    	je     140a4 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   141bb:	8b 45 08             	mov    0x8(%ebp),%eax
   141be:	8b 00                	mov    (%eax),%eax
   141c0:	83 f8 06             	cmp    $0x6,%eax
   141c3:	74 07                	je     141cc <_DecodeJPEG+0x18b>
   141c5:	8b 45 08             	mov    0x8(%ebp),%eax
   141c8:	8b 00                	mov    (%eax),%eax
   141ca:	eb 1c                	jmp    141e8 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   141cc:	8b 45 08             	mov    0x8(%ebp),%eax
   141cf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   141d5:	83 ec 0c             	sub    $0xc,%esp
   141d8:	ff 75 08             	pushl  0x8(%ebp)
   141db:	e8 6b 15 00 00       	call   1574b <_Convert>
   141e0:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   141e3:	8b 45 08             	mov    0x8(%ebp),%eax
   141e6:	8b 00                	mov    (%eax),%eax
 }
   141e8:	c9                   	leave  
   141e9:	c3                   	ret    

000141ea <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   141ea:	55                   	push   %ebp
   141eb:	89 e5                	mov    %esp,%ebp
   141ed:	53                   	push   %ebx
   141ee:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   141f1:	83 ec 0c             	sub    $0xc,%esp
   141f4:	ff 75 08             	pushl  0x8(%ebp)
   141f7:	e8 c1 fd ff ff       	call   13fbd <_DecodeLength>
   141fc:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   141ff:	8b 45 08             	mov    0x8(%ebp),%eax
   14202:	8b 00                	mov    (%eax),%eax
   14204:	85 c0                	test   %eax,%eax
   14206:	0f 85 4a 04 00 00    	jne    14656 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   1420c:	8b 45 08             	mov    0x8(%ebp),%eax
   1420f:	8b 40 0c             	mov    0xc(%eax),%eax
   14212:	83 f8 08             	cmp    $0x8,%eax
   14215:	7f 0e                	jg     14225 <_DecodeSOF+0x3b>
   14217:	8b 45 08             	mov    0x8(%ebp),%eax
   1421a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14220:	e9 32 04 00 00       	jmp    14657 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   14225:	8b 45 08             	mov    0x8(%ebp),%eax
   14228:	8b 40 04             	mov    0x4(%eax),%eax
   1422b:	0f b6 00             	movzbl (%eax),%eax
   1422e:	3c 08                	cmp    $0x8,%al
   14230:	74 0e                	je     14240 <_DecodeSOF+0x56>
   14232:	8b 45 08             	mov    0x8(%ebp),%eax
   14235:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1423b:	e9 17 04 00 00       	jmp    14657 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   14240:	8b 45 08             	mov    0x8(%ebp),%eax
   14243:	8b 40 04             	mov    0x4(%eax),%eax
   14246:	83 c0 01             	add    $0x1,%eax
   14249:	83 ec 0c             	sub    $0xc,%esp
   1424c:	50                   	push   %eax
   1424d:	e8 ce fd ff ff       	call   14020 <_Decode2Bytes>
   14252:	83 c4 10             	add    $0x10,%esp
   14255:	89 c2                	mov    %eax,%edx
   14257:	8b 45 08             	mov    0x8(%ebp),%eax
   1425a:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   1425d:	8b 45 08             	mov    0x8(%ebp),%eax
   14260:	8b 40 04             	mov    0x4(%eax),%eax
   14263:	83 c0 03             	add    $0x3,%eax
   14266:	83 ec 0c             	sub    $0xc,%esp
   14269:	50                   	push   %eax
   1426a:	e8 b1 fd ff ff       	call   14020 <_Decode2Bytes>
   1426f:	83 c4 10             	add    $0x10,%esp
   14272:	89 c2                	mov    %eax,%edx
   14274:	8b 45 08             	mov    0x8(%ebp),%eax
   14277:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   1427a:	8b 45 08             	mov    0x8(%ebp),%eax
   1427d:	8b 40 04             	mov    0x4(%eax),%eax
   14280:	83 c0 05             	add    $0x5,%eax
   14283:	0f b6 00             	movzbl (%eax),%eax
   14286:	0f b6 d0             	movzbl %al,%edx
   14289:	8b 45 08             	mov    0x8(%ebp),%eax
   1428c:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   1428f:	83 ec 08             	sub    $0x8,%esp
   14292:	6a 06                	push   $0x6
   14294:	ff 75 08             	pushl  0x8(%ebp)
   14297:	e8 d5 fc ff ff       	call   13f71 <_Skip>
   1429c:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   1429f:	8b 45 08             	mov    0x8(%ebp),%eax
   142a2:	8b 40 28             	mov    0x28(%eax),%eax
   142a5:	83 f8 01             	cmp    $0x1,%eax
   142a8:	74 13                	je     142bd <_DecodeSOF+0xd3>
   142aa:	83 f8 03             	cmp    $0x3,%eax
   142ad:	74 0e                	je     142bd <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   142af:	8b 45 08             	mov    0x8(%ebp),%eax
   142b2:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   142b8:	e9 9a 03 00 00       	jmp    14657 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   142bd:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   142be:	8b 45 08             	mov    0x8(%ebp),%eax
   142c1:	8b 48 0c             	mov    0xc(%eax),%ecx
   142c4:	8b 45 08             	mov    0x8(%ebp),%eax
   142c7:	8b 50 28             	mov    0x28(%eax),%edx
   142ca:	89 d0                	mov    %edx,%eax
   142cc:	01 c0                	add    %eax,%eax
   142ce:	01 d0                	add    %edx,%eax
   142d0:	39 c1                	cmp    %eax,%ecx
   142d2:	7d 0e                	jge    142e2 <_DecodeSOF+0xf8>
   142d4:	8b 45 08             	mov    0x8(%ebp),%eax
   142d7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   142dd:	e9 75 03 00 00       	jmp    14657 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   142e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   142e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   142f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   142f7:	8b 45 08             	mov    0x8(%ebp),%eax
   142fa:	83 c0 2c             	add    $0x2c,%eax
   142fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14300:	e9 50 01 00 00       	jmp    14455 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   14305:	8b 45 08             	mov    0x8(%ebp),%eax
   14308:	8b 40 04             	mov    0x4(%eax),%eax
   1430b:	0f b6 00             	movzbl (%eax),%eax
   1430e:	0f b6 d0             	movzbl %al,%edx
   14311:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14314:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   14316:	8b 45 08             	mov    0x8(%ebp),%eax
   14319:	8b 40 04             	mov    0x4(%eax),%eax
   1431c:	83 c0 01             	add    $0x1,%eax
   1431f:	0f b6 00             	movzbl (%eax),%eax
   14322:	c0 e8 04             	shr    $0x4,%al
   14325:	0f b6 d0             	movzbl %al,%edx
   14328:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1432b:	89 50 04             	mov    %edx,0x4(%eax)
   1432e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14331:	8b 40 04             	mov    0x4(%eax),%eax
   14334:	85 c0                	test   %eax,%eax
   14336:	75 0e                	jne    14346 <_DecodeSOF+0x15c>
   14338:	8b 45 08             	mov    0x8(%ebp),%eax
   1433b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14341:	e9 11 03 00 00       	jmp    14657 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   14346:	8b 45 08             	mov    0x8(%ebp),%eax
   14349:	8b 40 04             	mov    0x4(%eax),%eax
   1434c:	83 c0 01             	add    $0x1,%eax
   1434f:	0f b6 00             	movzbl (%eax),%eax
   14352:	0f b6 c0             	movzbl %al,%eax
   14355:	83 e0 0f             	and    $0xf,%eax
   14358:	89 c2                	mov    %eax,%edx
   1435a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1435d:	89 50 08             	mov    %edx,0x8(%eax)
   14360:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14363:	8b 40 08             	mov    0x8(%eax),%eax
   14366:	85 c0                	test   %eax,%eax
   14368:	75 0e                	jne    14378 <_DecodeSOF+0x18e>
   1436a:	8b 45 08             	mov    0x8(%ebp),%eax
   1436d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14373:	e9 df 02 00 00       	jmp    14657 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   14378:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1437b:	8b 50 04             	mov    0x4(%eax),%edx
   1437e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14381:	8b 40 04             	mov    0x4(%eax),%eax
   14384:	83 e8 01             	sub    $0x1,%eax
   14387:	21 d0                	and    %edx,%eax
   14389:	85 c0                	test   %eax,%eax
   1438b:	74 0e                	je     1439b <_DecodeSOF+0x1b1>
   1438d:	8b 45 08             	mov    0x8(%ebp),%eax
   14390:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14396:	e9 bc 02 00 00       	jmp    14657 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   1439b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1439e:	8b 50 08             	mov    0x8(%eax),%edx
   143a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   143a4:	8b 40 08             	mov    0x8(%eax),%eax
   143a7:	83 e8 01             	sub    $0x1,%eax
   143aa:	21 d0                	and    %edx,%eax
   143ac:	85 c0                	test   %eax,%eax
   143ae:	74 0e                	je     143be <_DecodeSOF+0x1d4>
   143b0:	8b 45 08             	mov    0x8(%ebp),%eax
   143b3:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   143b9:	e9 99 02 00 00       	jmp    14657 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   143be:	8b 45 08             	mov    0x8(%ebp),%eax
   143c1:	8b 40 04             	mov    0x4(%eax),%eax
   143c4:	83 c0 02             	add    $0x2,%eax
   143c7:	0f b6 00             	movzbl (%eax),%eax
   143ca:	0f b6 d0             	movzbl %al,%edx
   143cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   143d0:	89 50 18             	mov    %edx,0x18(%eax)
   143d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   143d6:	8b 40 18             	mov    0x18(%eax),%eax
   143d9:	25 fc 00 00 00       	and    $0xfc,%eax
   143de:	85 c0                	test   %eax,%eax
   143e0:	74 0e                	je     143f0 <_DecodeSOF+0x206>
   143e2:	8b 45 08             	mov    0x8(%ebp),%eax
   143e5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143eb:	e9 67 02 00 00       	jmp    14657 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   143f0:	83 ec 08             	sub    $0x8,%esp
   143f3:	6a 03                	push   $0x3
   143f5:	ff 75 08             	pushl  0x8(%ebp)
   143f8:	e8 74 fb ff ff       	call   13f71 <_Skip>
   143fd:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   14400:	8b 45 08             	mov    0x8(%ebp),%eax
   14403:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14409:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1440c:	8b 40 18             	mov    0x18(%eax),%eax
   1440f:	bb 01 00 00 00       	mov    $0x1,%ebx
   14414:	89 c1                	mov    %eax,%ecx
   14416:	d3 e3                	shl    %cl,%ebx
   14418:	89 d8                	mov    %ebx,%eax
   1441a:	09 c2                	or     %eax,%edx
   1441c:	8b 45 08             	mov    0x8(%ebp),%eax
   1441f:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   14425:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14428:	8b 40 04             	mov    0x4(%eax),%eax
   1442b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1442e:	7e 09                	jle    14439 <_DecodeSOF+0x24f>
   14430:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14433:	8b 40 04             	mov    0x4(%eax),%eax
   14436:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14439:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1443c:	8b 40 08             	mov    0x8(%eax),%eax
   1443f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14442:	7e 09                	jle    1444d <_DecodeSOF+0x263>
   14444:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14447:	8b 40 08             	mov    0x8(%eax),%eax
   1444a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1444d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14451:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14455:	8b 45 08             	mov    0x8(%ebp),%eax
   14458:	8b 40 28             	mov    0x28(%eax),%eax
   1445b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1445e:	0f 8f a1 fe ff ff    	jg     14305 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   14464:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14467:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1446e:	8b 45 08             	mov    0x8(%ebp),%eax
   14471:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   14474:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14477:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1447e:	8b 45 08             	mov    0x8(%ebp),%eax
   14481:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   14484:	8b 45 08             	mov    0x8(%ebp),%eax
   14487:	8b 50 10             	mov    0x10(%eax),%edx
   1448a:	8b 45 08             	mov    0x8(%ebp),%eax
   1448d:	8b 40 20             	mov    0x20(%eax),%eax
   14490:	01 d0                	add    %edx,%eax
   14492:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14495:	8b 45 08             	mov    0x8(%ebp),%eax
   14498:	8b 58 20             	mov    0x20(%eax),%ebx
   1449b:	89 c8                	mov    %ecx,%eax
   1449d:	99                   	cltd   
   1449e:	f7 fb                	idiv   %ebx
   144a0:	89 c2                	mov    %eax,%edx
   144a2:	8b 45 08             	mov    0x8(%ebp),%eax
   144a5:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   144a8:	8b 45 08             	mov    0x8(%ebp),%eax
   144ab:	8b 50 14             	mov    0x14(%eax),%edx
   144ae:	8b 45 08             	mov    0x8(%ebp),%eax
   144b1:	8b 40 24             	mov    0x24(%eax),%eax
   144b4:	01 d0                	add    %edx,%eax
   144b6:	8d 48 ff             	lea    -0x1(%eax),%ecx
   144b9:	8b 45 08             	mov    0x8(%ebp),%eax
   144bc:	8b 58 24             	mov    0x24(%eax),%ebx
   144bf:	89 c8                	mov    %ecx,%eax
   144c1:	99                   	cltd   
   144c2:	f7 fb                	idiv   %ebx
   144c4:	89 c2                	mov    %eax,%edx
   144c6:	8b 45 08             	mov    0x8(%ebp),%eax
   144c9:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   144cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   144d3:	8b 45 08             	mov    0x8(%ebp),%eax
   144d6:	83 c0 2c             	add    $0x2c,%eax
   144d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
   144dc:	e9 fd 00 00 00       	jmp    145de <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   144e1:	8b 45 08             	mov    0x8(%ebp),%eax
   144e4:	8b 50 10             	mov    0x10(%eax),%edx
   144e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144ea:	8b 40 04             	mov    0x4(%eax),%eax
   144ed:	0f af d0             	imul   %eax,%edx
   144f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   144f3:	01 d0                	add    %edx,%eax
   144f5:	83 e8 01             	sub    $0x1,%eax
   144f8:	99                   	cltd   
   144f9:	f7 7d ec             	idivl  -0x14(%ebp)
   144fc:	89 c2                	mov    %eax,%edx
   144fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14501:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   14504:	8b 45 08             	mov    0x8(%ebp),%eax
   14507:	8b 50 14             	mov    0x14(%eax),%edx
   1450a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1450d:	8b 40 08             	mov    0x8(%eax),%eax
   14510:	0f af d0             	imul   %eax,%edx
   14513:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14516:	01 d0                	add    %edx,%eax
   14518:	83 e8 01             	sub    $0x1,%eax
   1451b:	99                   	cltd   
   1451c:	f7 7d f0             	idivl  -0x10(%ebp)
   1451f:	89 c2                	mov    %eax,%edx
   14521:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14524:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14527:	8b 45 08             	mov    0x8(%ebp),%eax
   1452a:	8b 50 18             	mov    0x18(%eax),%edx
   1452d:	8b 45 08             	mov    0x8(%ebp),%eax
   14530:	8b 40 20             	mov    0x20(%eax),%eax
   14533:	0f af d0             	imul   %eax,%edx
   14536:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14539:	8b 40 04             	mov    0x4(%eax),%eax
   1453c:	0f af c2             	imul   %edx,%eax
   1453f:	99                   	cltd   
   14540:	f7 7d ec             	idivl  -0x14(%ebp)
   14543:	89 c2                	mov    %eax,%edx
   14545:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14548:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   1454b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1454e:	8b 40 0c             	mov    0xc(%eax),%eax
   14551:	83 f8 02             	cmp    $0x2,%eax
   14554:	7f 0b                	jg     14561 <_DecodeSOF+0x377>
   14556:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14559:	8b 40 04             	mov    0x4(%eax),%eax
   1455c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1455f:	75 16                	jne    14577 <_DecodeSOF+0x38d>
   14561:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14564:	8b 40 10             	mov    0x10(%eax),%eax
   14567:	83 f8 02             	cmp    $0x2,%eax
   1456a:	7f 19                	jg     14585 <_DecodeSOF+0x39b>
   1456c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1456f:	8b 40 08             	mov    0x8(%eax),%eax
   14572:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14575:	74 0e                	je     14585 <_DecodeSOF+0x39b>
   14577:	8b 45 08             	mov    0x8(%ebp),%eax
   1457a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14580:	e9 d2 00 00 00       	jmp    14657 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   14585:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14588:	8b 48 14             	mov    0x14(%eax),%ecx
   1458b:	8b 45 08             	mov    0x8(%ebp),%eax
   1458e:	8b 50 1c             	mov    0x1c(%eax),%edx
   14591:	8b 45 08             	mov    0x8(%ebp),%eax
   14594:	8b 40 24             	mov    0x24(%eax),%eax
   14597:	0f af d0             	imul   %eax,%edx
   1459a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1459d:	8b 40 08             	mov    0x8(%eax),%eax
   145a0:	0f af c2             	imul   %edx,%eax
   145a3:	99                   	cltd   
   145a4:	f7 7d f0             	idivl  -0x10(%ebp)
   145a7:	0f af c1             	imul   %ecx,%eax
   145aa:	83 ec 0c             	sub    $0xc,%esp
   145ad:	50                   	push   %eax
   145ae:	e8 45 c5 fe ff       	call   af8 <malloc>
   145b3:	83 c4 10             	add    $0x10,%esp
   145b6:	89 c2                	mov    %eax,%edx
   145b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   145bb:	89 50 28             	mov    %edx,0x28(%eax)
   145be:	8b 45 e8             	mov    -0x18(%ebp),%eax
   145c1:	8b 40 28             	mov    0x28(%eax),%eax
   145c4:	85 c0                	test   %eax,%eax
   145c6:	75 0e                	jne    145d6 <_DecodeSOF+0x3ec>
   145c8:	8b 45 08             	mov    0x8(%ebp),%eax
   145cb:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   145d1:	e9 81 00 00 00       	jmp    14657 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   145d6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   145da:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   145de:	8b 45 08             	mov    0x8(%ebp),%eax
   145e1:	8b 40 28             	mov    0x28(%eax),%eax
   145e4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   145e7:	0f 8f f4 fe ff ff    	jg     144e1 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   145ed:	8b 45 08             	mov    0x8(%ebp),%eax
   145f0:	8b 40 28             	mov    0x28(%eax),%eax
   145f3:	83 f8 03             	cmp    $0x3,%eax
   145f6:	75 47                	jne    1463f <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   145f8:	8b 45 08             	mov    0x8(%ebp),%eax
   145fb:	8b 50 10             	mov    0x10(%eax),%edx
   145fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14601:	8b 40 14             	mov    0x14(%eax),%eax
   14604:	0f af d0             	imul   %eax,%edx
   14607:	8b 45 08             	mov    0x8(%ebp),%eax
   1460a:	8b 40 28             	mov    0x28(%eax),%eax
   1460d:	0f af c2             	imul   %edx,%eax
   14610:	83 ec 0c             	sub    $0xc,%esp
   14613:	50                   	push   %eax
   14614:	e8 df c4 fe ff       	call   af8 <malloc>
   14619:	83 c4 10             	add    $0x10,%esp
   1461c:	89 c2                	mov    %eax,%edx
   1461e:	8b 45 08             	mov    0x8(%ebp),%eax
   14621:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14627:	8b 45 08             	mov    0x8(%ebp),%eax
   1462a:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   14630:	85 c0                	test   %eax,%eax
   14632:	75 0b                	jne    1463f <_DecodeSOF+0x455>
   14634:	8b 45 08             	mov    0x8(%ebp),%eax
   14637:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1463d:	eb 18                	jmp    14657 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1463f:	8b 45 08             	mov    0x8(%ebp),%eax
   14642:	8b 40 0c             	mov    0xc(%eax),%eax
   14645:	83 ec 08             	sub    $0x8,%esp
   14648:	50                   	push   %eax
   14649:	ff 75 08             	pushl  0x8(%ebp)
   1464c:	e8 20 f9 ff ff       	call   13f71 <_Skip>
   14651:	83 c4 10             	add    $0x10,%esp
   14654:	eb 01                	jmp    14657 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   14656:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   14657:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1465a:	c9                   	leave  
   1465b:	c3                   	ret    

0001465c <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   1465c:	55                   	push   %ebp
   1465d:	89 e5                	mov    %esp,%ebp
   1465f:	53                   	push   %ebx
   14660:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   14663:	83 ec 0c             	sub    $0xc,%esp
   14666:	ff 75 08             	pushl  0x8(%ebp)
   14669:	e8 4f f9 ff ff       	call   13fbd <_DecodeLength>
   1466e:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14671:	8b 45 08             	mov    0x8(%ebp),%eax
   14674:	8b 00                	mov    (%eax),%eax
   14676:	85 c0                	test   %eax,%eax
   14678:	0f 85 c5 01 00 00    	jne    14843 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   1467e:	e9 9c 01 00 00       	jmp    1481f <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   14683:	8b 45 08             	mov    0x8(%ebp),%eax
   14686:	8b 40 04             	mov    0x4(%eax),%eax
   14689:	0f b6 00             	movzbl (%eax),%eax
   1468c:	0f b6 c0             	movzbl %al,%eax
   1468f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14692:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14695:	25 ec 00 00 00       	and    $0xec,%eax
   1469a:	85 c0                	test   %eax,%eax
   1469c:	74 0e                	je     146ac <_DecodeDHT+0x50>
   1469e:	8b 45 08             	mov    0x8(%ebp),%eax
   146a1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146a7:	e9 98 01 00 00       	jmp    14844 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   146ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146af:	83 e0 02             	and    $0x2,%eax
   146b2:	85 c0                	test   %eax,%eax
   146b4:	74 0e                	je     146c4 <_DecodeDHT+0x68>
   146b6:	8b 45 08             	mov    0x8(%ebp),%eax
   146b9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   146bf:	e9 80 01 00 00       	jmp    14844 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   146c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146c7:	c1 f8 03             	sar    $0x3,%eax
   146ca:	0b 45 f4             	or     -0xc(%ebp),%eax
   146cd:	83 e0 03             	and    $0x3,%eax
   146d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   146d3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   146da:	eb 1c                	jmp    146f8 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   146dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146df:	8d 50 ff             	lea    -0x1(%eax),%edx
   146e2:	8b 45 08             	mov    0x8(%ebp),%eax
   146e5:	8b 48 04             	mov    0x4(%eax),%ecx
   146e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146eb:	01 c8                	add    %ecx,%eax
   146ed:	0f b6 00             	movzbl (%eax),%eax
   146f0:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   146f4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   146f8:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   146fc:	7e de                	jle    146dc <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   146fe:	83 ec 08             	sub    $0x8,%esp
   14701:	6a 11                	push   $0x11
   14703:	ff 75 08             	pushl  0x8(%ebp)
   14706:	e8 66 f8 ff ff       	call   13f71 <_Skip>
   1470b:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   1470e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14711:	c1 e0 11             	shl    $0x11,%eax
   14714:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1471a:	8b 45 08             	mov    0x8(%ebp),%eax
   1471d:	01 d0                	add    %edx,%eax
   1471f:	83 c0 08             	add    $0x8,%eax
   14722:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14725:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   1472c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1472f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14732:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14739:	e9 be 00 00 00       	jmp    147fc <_DecodeDHT+0x1a0>
            spread >>= 1;
   1473e:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   14741:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14744:	83 e8 01             	sub    $0x1,%eax
   14747:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   1474c:	0f b6 c0             	movzbl %al,%eax
   1474f:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   14752:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14756:	0f 84 9b 00 00 00    	je     147f7 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   1475c:	8b 45 08             	mov    0x8(%ebp),%eax
   1475f:	8b 40 0c             	mov    0xc(%eax),%eax
   14762:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14765:	7d 0e                	jge    14775 <_DecodeDHT+0x119>
   14767:	8b 45 08             	mov    0x8(%ebp),%eax
   1476a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14770:	e9 cf 00 00 00       	jmp    14844 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   14775:	b8 10 00 00 00       	mov    $0x10,%eax
   1477a:	2b 45 f0             	sub    -0x10(%ebp),%eax
   1477d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14780:	89 c1                	mov    %eax,%ecx
   14782:	d3 e2                	shl    %cl,%edx
   14784:	89 d0                	mov    %edx,%eax
   14786:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   14789:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1478d:	79 0e                	jns    1479d <_DecodeDHT+0x141>
   1478f:	8b 45 08             	mov    0x8(%ebp),%eax
   14792:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14798:	e9 a7 00 00 00       	jmp    14844 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   1479d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   147a4:	eb 36                	jmp    147dc <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   147a6:	8b 45 08             	mov    0x8(%ebp),%eax
   147a9:	8b 50 04             	mov    0x4(%eax),%edx
   147ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147af:	01 d0                	add    %edx,%eax
   147b1:	0f b6 00             	movzbl (%eax),%eax
   147b4:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   147b6:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   147b9:	eb 14                	jmp    147cf <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   147bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147be:	89 c2                	mov    %eax,%edx
   147c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   147c3:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   147c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   147c8:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   147cb:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   147cf:	89 d8                	mov    %ebx,%eax
   147d1:	8d 58 ff             	lea    -0x1(%eax),%ebx
   147d4:	85 c0                	test   %eax,%eax
   147d6:	75 e3                	jne    147bb <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   147d8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   147dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147df:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   147e2:	7c c2                	jl     147a6 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   147e4:	83 ec 08             	sub    $0x8,%esp
   147e7:	ff 75 e0             	pushl  -0x20(%ebp)
   147ea:	ff 75 08             	pushl  0x8(%ebp)
   147ed:	e8 7f f7 ff ff       	call   13f71 <_Skip>
   147f2:	83 c4 10             	add    $0x10,%esp
   147f5:	eb 01                	jmp    147f8 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   147f7:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   147f8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   147fc:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14800:	0f 8e 38 ff ff ff    	jle    1473e <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14806:	eb 0a                	jmp    14812 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14808:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1480b:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   1480e:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14812:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14815:	8d 50 ff             	lea    -0x1(%eax),%edx
   14818:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1481b:	85 c0                	test   %eax,%eax
   1481d:	75 e9                	jne    14808 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   1481f:	8b 45 08             	mov    0x8(%ebp),%eax
   14822:	8b 40 0c             	mov    0xc(%eax),%eax
   14825:	83 f8 10             	cmp    $0x10,%eax
   14828:	0f 8f 55 fe ff ff    	jg     14683 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1482e:	8b 45 08             	mov    0x8(%ebp),%eax
   14831:	8b 40 0c             	mov    0xc(%eax),%eax
   14834:	85 c0                	test   %eax,%eax
   14836:	74 0c                	je     14844 <_DecodeDHT+0x1e8>
   14838:	8b 45 08             	mov    0x8(%ebp),%eax
   1483b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14841:	eb 01                	jmp    14844 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   14843:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14844:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14847:	c9                   	leave  
   14848:	c3                   	ret    

00014849 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14849:	55                   	push   %ebp
   1484a:	89 e5                	mov    %esp,%ebp
   1484c:	53                   	push   %ebx
   1484d:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   14850:	83 ec 0c             	sub    $0xc,%esp
   14853:	ff 75 08             	pushl  0x8(%ebp)
   14856:	e8 62 f7 ff ff       	call   13fbd <_DecodeLength>
   1485b:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1485e:	8b 45 08             	mov    0x8(%ebp),%eax
   14861:	8b 00                	mov    (%eax),%eax
   14863:	85 c0                	test   %eax,%eax
   14865:	0f 85 e2 00 00 00    	jne    1494d <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   1486b:	e9 b8 00 00 00       	jmp    14928 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   14870:	8b 45 08             	mov    0x8(%ebp),%eax
   14873:	8b 40 04             	mov    0x4(%eax),%eax
   14876:	0f b6 00             	movzbl (%eax),%eax
   14879:	0f b6 c0             	movzbl %al,%eax
   1487c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   1487f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14882:	25 ec 00 00 00       	and    $0xec,%eax
   14887:	85 c0                	test   %eax,%eax
   14889:	74 0e                	je     14899 <_DecodeDQT+0x50>
   1488b:	8b 45 08             	mov    0x8(%ebp),%eax
   1488e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14894:	e9 b5 00 00 00       	jmp    1494e <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   14899:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1489c:	83 e0 10             	and    $0x10,%eax
   1489f:	85 c0                	test   %eax,%eax
   148a1:	74 0e                	je     148b1 <_DecodeDQT+0x68>
   148a3:	8b 45 08             	mov    0x8(%ebp),%eax
   148a6:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   148ac:	e9 9d 00 00 00       	jmp    1494e <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   148b1:	8b 45 08             	mov    0x8(%ebp),%eax
   148b4:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   148ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
   148bd:	bb 01 00 00 00       	mov    $0x1,%ebx
   148c2:	89 c1                	mov    %eax,%ecx
   148c4:	d3 e3                	shl    %cl,%ebx
   148c6:	89 d8                	mov    %ebx,%eax
   148c8:	09 c2                	or     %eax,%edx
   148ca:	8b 45 08             	mov    0x8(%ebp),%eax
   148cd:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   148d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   148d6:	c1 e0 06             	shl    $0x6,%eax
   148d9:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   148df:	8b 45 08             	mov    0x8(%ebp),%eax
   148e2:	01 d0                	add    %edx,%eax
   148e4:	83 c0 08             	add    $0x8,%eax
   148e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   148ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   148f1:	eb 1f                	jmp    14912 <_DecodeDQT+0xc9>
   148f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   148f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148f9:	01 c2                	add    %eax,%edx
   148fb:	8b 45 08             	mov    0x8(%ebp),%eax
   148fe:	8b 40 04             	mov    0x4(%eax),%eax
   14901:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14904:	83 c1 01             	add    $0x1,%ecx
   14907:	01 c8                	add    %ecx,%eax
   14909:	0f b6 00             	movzbl (%eax),%eax
   1490c:	88 02                	mov    %al,(%edx)
   1490e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14912:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14916:	7e db                	jle    148f3 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14918:	83 ec 08             	sub    $0x8,%esp
   1491b:	6a 41                	push   $0x41
   1491d:	ff 75 08             	pushl  0x8(%ebp)
   14920:	e8 4c f6 ff ff       	call   13f71 <_Skip>
   14925:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14928:	8b 45 08             	mov    0x8(%ebp),%eax
   1492b:	8b 40 0c             	mov    0xc(%eax),%eax
   1492e:	83 f8 40             	cmp    $0x40,%eax
   14931:	0f 8f 39 ff ff ff    	jg     14870 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14937:	8b 45 08             	mov    0x8(%ebp),%eax
   1493a:	8b 40 0c             	mov    0xc(%eax),%eax
   1493d:	85 c0                	test   %eax,%eax
   1493f:	74 0d                	je     1494e <_DecodeDQT+0x105>
   14941:	8b 45 08             	mov    0x8(%ebp),%eax
   14944:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1494a:	90                   	nop
   1494b:	eb 01                	jmp    1494e <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1494d:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1494e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14951:	c9                   	leave  
   14952:	c3                   	ret    

00014953 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   14953:	55                   	push   %ebp
   14954:	89 e5                	mov    %esp,%ebp
   14956:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14959:	83 ec 0c             	sub    $0xc,%esp
   1495c:	ff 75 08             	pushl  0x8(%ebp)
   1495f:	e8 59 f6 ff ff       	call   13fbd <_DecodeLength>
   14964:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14967:	8b 45 08             	mov    0x8(%ebp),%eax
   1496a:	8b 00                	mov    (%eax),%eax
   1496c:	85 c0                	test   %eax,%eax
   1496e:	75 4a                	jne    149ba <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   14970:	8b 45 08             	mov    0x8(%ebp),%eax
   14973:	8b 40 0c             	mov    0xc(%eax),%eax
   14976:	83 f8 01             	cmp    $0x1,%eax
   14979:	7f 0b                	jg     14986 <_DecodeDRI+0x33>
   1497b:	8b 45 08             	mov    0x8(%ebp),%eax
   1497e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14984:	eb 35                	jmp    149bb <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   14986:	8b 45 08             	mov    0x8(%ebp),%eax
   14989:	8b 40 04             	mov    0x4(%eax),%eax
   1498c:	83 ec 0c             	sub    $0xc,%esp
   1498f:	50                   	push   %eax
   14990:	e8 8b f6 ff ff       	call   14020 <_Decode2Bytes>
   14995:	83 c4 10             	add    $0x10,%esp
   14998:	89 c2                	mov    %eax,%edx
   1499a:	8b 45 08             	mov    0x8(%ebp),%eax
   1499d:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   149a3:	8b 45 08             	mov    0x8(%ebp),%eax
   149a6:	8b 40 0c             	mov    0xc(%eax),%eax
   149a9:	83 ec 08             	sub    $0x8,%esp
   149ac:	50                   	push   %eax
   149ad:	ff 75 08             	pushl  0x8(%ebp)
   149b0:	e8 bc f5 ff ff       	call   13f71 <_Skip>
   149b5:	83 c4 10             	add    $0x10,%esp
   149b8:	eb 01                	jmp    149bb <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   149ba:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   149bb:	c9                   	leave  
   149bc:	c3                   	ret    

000149bd <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   149bd:	55                   	push   %ebp
   149be:	89 e5                	mov    %esp,%ebp
   149c0:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   149c3:	8b 45 08             	mov    0x8(%ebp),%eax
   149c6:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   149cc:	89 45 e0             	mov    %eax,-0x20(%ebp)
   149cf:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   149d6:	83 ec 0c             	sub    $0xc,%esp
   149d9:	ff 75 08             	pushl  0x8(%ebp)
   149dc:	e8 dc f5 ff ff       	call   13fbd <_DecodeLength>
   149e1:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   149e4:	8b 45 08             	mov    0x8(%ebp),%eax
   149e7:	8b 00                	mov    (%eax),%eax
   149e9:	85 c0                	test   %eax,%eax
   149eb:	0f 85 c2 02 00 00    	jne    14cb3 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   149f1:	8b 45 08             	mov    0x8(%ebp),%eax
   149f4:	8b 50 0c             	mov    0xc(%eax),%edx
   149f7:	8b 45 08             	mov    0x8(%ebp),%eax
   149fa:	8b 40 28             	mov    0x28(%eax),%eax
   149fd:	83 c0 02             	add    $0x2,%eax
   14a00:	01 c0                	add    %eax,%eax
   14a02:	39 c2                	cmp    %eax,%edx
   14a04:	7c 16                	jl     14a1c <_DecodeSOS+0x5f>
   14a06:	8b 45 08             	mov    0x8(%ebp),%eax
   14a09:	8b 40 04             	mov    0x4(%eax),%eax
   14a0c:	0f b6 00             	movzbl (%eax),%eax
   14a0f:	0f b6 d0             	movzbl %al,%edx
   14a12:	8b 45 08             	mov    0x8(%ebp),%eax
   14a15:	8b 40 28             	mov    0x28(%eax),%eax
   14a18:	39 c2                	cmp    %eax,%edx
   14a1a:	74 0e                	je     14a2a <_DecodeSOS+0x6d>
   14a1c:	8b 45 08             	mov    0x8(%ebp),%eax
   14a1f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a25:	e9 8d 02 00 00       	jmp    14cb7 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14a2a:	83 ec 08             	sub    $0x8,%esp
   14a2d:	6a 01                	push   $0x1
   14a2f:	ff 75 08             	pushl  0x8(%ebp)
   14a32:	e8 3a f5 ff ff       	call   13f71 <_Skip>
   14a37:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14a3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a41:	8b 45 08             	mov    0x8(%ebp),%eax
   14a44:	83 c0 2c             	add    $0x2c,%eax
   14a47:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14a4a:	e9 ba 00 00 00       	jmp    14b09 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   14a4f:	8b 45 08             	mov    0x8(%ebp),%eax
   14a52:	8b 40 04             	mov    0x4(%eax),%eax
   14a55:	0f b6 00             	movzbl (%eax),%eax
   14a58:	0f b6 d0             	movzbl %al,%edx
   14a5b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14a5e:	8b 00                	mov    (%eax),%eax
   14a60:	39 c2                	cmp    %eax,%edx
   14a62:	74 0e                	je     14a72 <_DecodeSOS+0xb5>
   14a64:	8b 45 08             	mov    0x8(%ebp),%eax
   14a67:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a6d:	e9 45 02 00 00       	jmp    14cb7 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   14a72:	8b 45 08             	mov    0x8(%ebp),%eax
   14a75:	8b 40 04             	mov    0x4(%eax),%eax
   14a78:	83 c0 01             	add    $0x1,%eax
   14a7b:	0f b6 00             	movzbl (%eax),%eax
   14a7e:	0f b6 c0             	movzbl %al,%eax
   14a81:	25 ec 00 00 00       	and    $0xec,%eax
   14a86:	85 c0                	test   %eax,%eax
   14a88:	74 0e                	je     14a98 <_DecodeSOS+0xdb>
   14a8a:	8b 45 08             	mov    0x8(%ebp),%eax
   14a8d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a93:	e9 1f 02 00 00       	jmp    14cb7 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   14a98:	8b 45 08             	mov    0x8(%ebp),%eax
   14a9b:	8b 40 04             	mov    0x4(%eax),%eax
   14a9e:	83 c0 01             	add    $0x1,%eax
   14aa1:	0f b6 00             	movzbl (%eax),%eax
   14aa4:	0f b6 c0             	movzbl %al,%eax
   14aa7:	83 e0 02             	and    $0x2,%eax
   14aaa:	85 c0                	test   %eax,%eax
   14aac:	74 0e                	je     14abc <_DecodeSOS+0xff>
   14aae:	8b 45 08             	mov    0x8(%ebp),%eax
   14ab1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14ab7:	e9 fb 01 00 00       	jmp    14cb7 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   14abc:	8b 45 08             	mov    0x8(%ebp),%eax
   14abf:	8b 40 04             	mov    0x4(%eax),%eax
   14ac2:	83 c0 01             	add    $0x1,%eax
   14ac5:	0f b6 00             	movzbl (%eax),%eax
   14ac8:	c0 e8 04             	shr    $0x4,%al
   14acb:	0f b6 d0             	movzbl %al,%edx
   14ace:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ad1:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   14ad4:	8b 45 08             	mov    0x8(%ebp),%eax
   14ad7:	8b 40 04             	mov    0x4(%eax),%eax
   14ada:	83 c0 01             	add    $0x1,%eax
   14add:	0f b6 00             	movzbl (%eax),%eax
   14ae0:	0f b6 c0             	movzbl %al,%eax
   14ae3:	83 e0 01             	and    $0x1,%eax
   14ae6:	83 c8 02             	or     $0x2,%eax
   14ae9:	89 c2                	mov    %eax,%edx
   14aeb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14aee:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   14af1:	83 ec 08             	sub    $0x8,%esp
   14af4:	6a 02                	push   $0x2
   14af6:	ff 75 08             	pushl  0x8(%ebp)
   14af9:	e8 73 f4 ff ff       	call   13f71 <_Skip>
   14afe:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14b01:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14b05:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14b09:	8b 45 08             	mov    0x8(%ebp),%eax
   14b0c:	8b 40 28             	mov    0x28(%eax),%eax
   14b0f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14b12:	0f 8f 37 ff ff ff    	jg     14a4f <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14b18:	8b 45 08             	mov    0x8(%ebp),%eax
   14b1b:	8b 40 04             	mov    0x4(%eax),%eax
   14b1e:	0f b6 00             	movzbl (%eax),%eax
   14b21:	84 c0                	test   %al,%al
   14b23:	75 10                	jne    14b35 <_DecodeSOS+0x178>
   14b25:	8b 45 08             	mov    0x8(%ebp),%eax
   14b28:	8b 40 04             	mov    0x4(%eax),%eax
   14b2b:	83 c0 01             	add    $0x1,%eax
   14b2e:	0f b6 00             	movzbl (%eax),%eax
   14b31:	3c 3f                	cmp    $0x3f,%al
   14b33:	74 0e                	je     14b43 <_DecodeSOS+0x186>
   14b35:	8b 45 08             	mov    0x8(%ebp),%eax
   14b38:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b3e:	e9 74 01 00 00       	jmp    14cb7 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   14b43:	8b 45 08             	mov    0x8(%ebp),%eax
   14b46:	8b 40 04             	mov    0x4(%eax),%eax
   14b49:	83 c0 02             	add    $0x2,%eax
   14b4c:	0f b6 00             	movzbl (%eax),%eax
   14b4f:	84 c0                	test   %al,%al
   14b51:	74 0e                	je     14b61 <_DecodeSOS+0x1a4>
   14b53:	8b 45 08             	mov    0x8(%ebp),%eax
   14b56:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14b5c:	e9 56 01 00 00       	jmp    14cb7 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   14b61:	8b 45 08             	mov    0x8(%ebp),%eax
   14b64:	8b 40 0c             	mov    0xc(%eax),%eax
   14b67:	83 ec 08             	sub    $0x8,%esp
   14b6a:	50                   	push   %eax
   14b6b:	ff 75 08             	pushl  0x8(%ebp)
   14b6e:	e8 fe f3 ff ff       	call   13f71 <_Skip>
   14b73:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14b76:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14b7d:	e9 17 01 00 00       	jmp    14c99 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14b82:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14b89:	e9 f8 00 00 00       	jmp    14c86 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14b8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14b95:	8b 45 08             	mov    0x8(%ebp),%eax
   14b98:	83 c0 2c             	add    $0x2c,%eax
   14b9b:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14b9e:	e9 8d 00 00 00       	jmp    14c30 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   14ba3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14baa:	eb 71                	jmp    14c1d <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14bac:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14bb3:	eb 59                	jmp    14c0e <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   14bb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14bb8:	8b 50 28             	mov    0x28(%eax),%edx
   14bbb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14bbe:	8b 40 08             	mov    0x8(%eax),%eax
   14bc1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14bc5:	89 c1                	mov    %eax,%ecx
   14bc7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14bca:	01 c1                	add    %eax,%ecx
   14bcc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14bcf:	8b 40 14             	mov    0x14(%eax),%eax
   14bd2:	0f af c8             	imul   %eax,%ecx
   14bd5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14bd8:	8b 40 04             	mov    0x4(%eax),%eax
   14bdb:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14bdf:	01 c1                	add    %eax,%ecx
   14be1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14be4:	01 c8                	add    %ecx,%eax
   14be6:	c1 e0 03             	shl    $0x3,%eax
   14be9:	01 d0                	add    %edx,%eax
   14beb:	50                   	push   %eax
   14bec:	ff 75 dc             	pushl  -0x24(%ebp)
   14bef:	ff 75 0c             	pushl  0xc(%ebp)
   14bf2:	ff 75 08             	pushl  0x8(%ebp)
   14bf5:	e8 bf 00 00 00       	call   14cb9 <_DecodeBlock>
   14bfa:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14bfd:	8b 45 08             	mov    0x8(%ebp),%eax
   14c00:	8b 00                	mov    (%eax),%eax
   14c02:	85 c0                	test   %eax,%eax
   14c04:	0f 85 ac 00 00 00    	jne    14cb6 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14c0a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14c0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14c11:	8b 40 04             	mov    0x4(%eax),%eax
   14c14:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14c17:	7f 9c                	jg     14bb5 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14c19:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14c1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14c20:	8b 40 08             	mov    0x8(%eax),%eax
   14c23:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14c26:	7f 84                	jg     14bac <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14c28:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14c2c:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14c30:	8b 45 08             	mov    0x8(%ebp),%eax
   14c33:	8b 40 28             	mov    0x28(%eax),%eax
   14c36:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14c39:	0f 8f 64 ff ff ff    	jg     14ba3 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   14c3f:	8b 45 08             	mov    0x8(%ebp),%eax
   14c42:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14c48:	85 c0                	test   %eax,%eax
   14c4a:	74 36                	je     14c82 <_DecodeSOS+0x2c5>
   14c4c:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   14c50:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14c54:	75 2c                	jne    14c82 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   14c56:	83 ec 0c             	sub    $0xc,%esp
   14c59:	ff 75 08             	pushl  0x8(%ebp)
   14c5c:	e8 9f 0a 00 00       	call   15700 <_ByteAlign>
   14c61:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   14c64:	83 ec 08             	sub    $0x8,%esp
   14c67:	6a 10                	push   $0x10
   14c69:	ff 75 08             	pushl  0x8(%ebp)
   14c6c:	e8 ce 04 00 00       	call   1513f <_GetBits>
   14c71:	83 c4 10             	add    $0x10,%esp
   14c74:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   14c77:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14c80:	eb 35                	jmp    14cb7 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14c82:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14c86:	8b 45 08             	mov    0x8(%ebp),%eax
   14c89:	8b 40 18             	mov    0x18(%eax),%eax
   14c8c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14c8f:	0f 8f f9 fe ff ff    	jg     14b8e <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14c95:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14c99:	8b 45 08             	mov    0x8(%ebp),%eax
   14c9c:	8b 40 1c             	mov    0x1c(%eax),%eax
   14c9f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14ca2:	0f 8f da fe ff ff    	jg     14b82 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   14ca8:	8b 45 08             	mov    0x8(%ebp),%eax
   14cab:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   14cb1:	eb 04                	jmp    14cb7 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14cb3:	90                   	nop
   14cb4:	eb 01                	jmp    14cb7 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   14cb6:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14cb7:	c9                   	leave  
   14cb8:	c3                   	ret    

00014cb9 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14cb9:	55                   	push   %ebp
   14cba:	89 e5                	mov    %esp,%ebp
   14cbc:	53                   	push   %ebx
   14cbd:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   14cc0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14cc7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cca:	05 c0 01 08 00       	add    $0x801c0,%eax
   14ccf:	83 ec 04             	sub    $0x4,%esp
   14cd2:	68 00 01 00 00       	push   $0x100
   14cd7:	6a 00                	push   $0x0
   14cd9:	50                   	push   %eax
   14cda:	e8 04 b8 fe ff       	call   4e3 <memset>
   14cdf:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   14ce2:	8b 45 10             	mov    0x10(%ebp),%eax
   14ce5:	8b 40 20             	mov    0x20(%eax),%eax
   14ce8:	c1 e0 11             	shl    $0x11,%eax
   14ceb:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14cf1:	8b 45 08             	mov    0x8(%ebp),%eax
   14cf4:	01 d0                	add    %edx,%eax
   14cf6:	83 c0 08             	add    $0x8,%eax
   14cf9:	83 ec 04             	sub    $0x4,%esp
   14cfc:	6a 00                	push   $0x0
   14cfe:	50                   	push   %eax
   14cff:	ff 75 08             	pushl  0x8(%ebp)
   14d02:	e8 86 01 00 00       	call   14e8d <_GetVLC>
   14d07:	83 c4 10             	add    $0x10,%esp
   14d0a:	89 c2                	mov    %eax,%edx
   14d0c:	8b 45 10             	mov    0x10(%ebp),%eax
   14d0f:	8b 40 24             	mov    0x24(%eax),%eax
   14d12:	01 c2                	add    %eax,%edx
   14d14:	8b 45 10             	mov    0x10(%ebp),%eax
   14d17:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14d1a:	8b 45 10             	mov    0x10(%ebp),%eax
   14d1d:	8b 50 24             	mov    0x24(%eax),%edx
   14d20:	8b 45 10             	mov    0x10(%ebp),%eax
   14d23:	8b 48 18             	mov    0x18(%eax),%ecx
   14d26:	8b 45 08             	mov    0x8(%ebp),%eax
   14d29:	c1 e1 06             	shl    $0x6,%ecx
   14d2c:	01 c8                	add    %ecx,%eax
   14d2e:	05 b8 00 00 00       	add    $0xb8,%eax
   14d33:	0f b6 00             	movzbl (%eax),%eax
   14d36:	0f b6 c0             	movzbl %al,%eax
   14d39:	0f af d0             	imul   %eax,%edx
   14d3c:	8b 45 08             	mov    0x8(%ebp),%eax
   14d3f:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14d45:	8b 45 10             	mov    0x10(%ebp),%eax
   14d48:	8b 40 1c             	mov    0x1c(%eax),%eax
   14d4b:	c1 e0 11             	shl    $0x11,%eax
   14d4e:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14d54:	8b 45 08             	mov    0x8(%ebp),%eax
   14d57:	01 d0                	add    %edx,%eax
   14d59:	8d 50 08             	lea    0x8(%eax),%edx
   14d5c:	83 ec 04             	sub    $0x4,%esp
   14d5f:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14d62:	50                   	push   %eax
   14d63:	52                   	push   %edx
   14d64:	ff 75 08             	pushl  0x8(%ebp)
   14d67:	e8 21 01 00 00       	call   14e8d <_GetVLC>
   14d6c:	83 c4 10             	add    $0x10,%esp
   14d6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14d72:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14d76:	84 c0                	test   %al,%al
   14d78:	0f 84 92 00 00 00    	je     14e10 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14d7e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14d82:	0f b6 c0             	movzbl %al,%eax
   14d85:	83 e0 0f             	and    $0xf,%eax
   14d88:	85 c0                	test   %eax,%eax
   14d8a:	75 16                	jne    14da2 <_DecodeBlock+0xe9>
   14d8c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14d90:	3c f0                	cmp    $0xf0,%al
   14d92:	74 0e                	je     14da2 <_DecodeBlock+0xe9>
   14d94:	8b 45 08             	mov    0x8(%ebp),%eax
   14d97:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14d9d:	e9 e6 00 00 00       	jmp    14e88 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14da2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14da6:	c0 e8 04             	shr    $0x4,%al
   14da9:	0f b6 c0             	movzbl %al,%eax
   14dac:	83 c0 01             	add    $0x1,%eax
   14daf:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14db2:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14db6:	7e 0e                	jle    14dc6 <_DecodeBlock+0x10d>
   14db8:	8b 45 08             	mov    0x8(%ebp),%eax
   14dbb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14dc1:	e9 c2 00 00 00       	jmp    14e88 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14dc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14dc9:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dcc:	01 d0                	add    %edx,%eax
   14dce:	0f b6 00             	movzbl (%eax),%eax
   14dd1:	0f be c8             	movsbl %al,%ecx
   14dd4:	8b 45 10             	mov    0x10(%ebp),%eax
   14dd7:	8b 50 18             	mov    0x18(%eax),%edx
   14dda:	8b 45 08             	mov    0x8(%ebp),%eax
   14ddd:	c1 e2 06             	shl    $0x6,%edx
   14de0:	01 c2                	add    %eax,%edx
   14de2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14de5:	01 d0                	add    %edx,%eax
   14de7:	05 b8 00 00 00       	add    $0xb8,%eax
   14dec:	0f b6 00             	movzbl (%eax),%eax
   14def:	0f b6 c0             	movzbl %al,%eax
   14df2:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14df6:	89 c2                	mov    %eax,%edx
   14df8:	8b 45 08             	mov    0x8(%ebp),%eax
   14dfb:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14e01:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14e04:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14e08:	0f 8e 37 ff ff ff    	jle    14d45 <_DecodeBlock+0x8c>
   14e0e:	eb 01                	jmp    14e11 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14e10:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14e11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14e18:	eb 24                	jmp    14e3e <_DecodeBlock+0x185>
   14e1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e1d:	05 70 00 02 00       	add    $0x20070,%eax
   14e22:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14e29:	8b 45 08             	mov    0x8(%ebp),%eax
   14e2c:	01 d0                	add    %edx,%eax
   14e2e:	83 ec 0c             	sub    $0xc,%esp
   14e31:	50                   	push   %eax
   14e32:	e8 32 03 00 00       	call   15169 <_RowIDCT>
   14e37:	83 c4 10             	add    $0x10,%esp
   14e3a:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14e3e:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14e42:	7e d6                	jle    14e1a <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14e44:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14e4b:	eb 35                	jmp    14e82 <_DecodeBlock+0x1c9>
   14e4d:	8b 45 10             	mov    0x10(%ebp),%eax
   14e50:	8b 40 14             	mov    0x14(%eax),%eax
   14e53:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14e56:	8b 55 14             	mov    0x14(%ebp),%edx
   14e59:	01 d1                	add    %edx,%ecx
   14e5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14e5e:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14e64:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14e6b:	8b 55 08             	mov    0x8(%ebp),%edx
   14e6e:	01 da                	add    %ebx,%edx
   14e70:	83 ec 04             	sub    $0x4,%esp
   14e73:	50                   	push   %eax
   14e74:	51                   	push   %ecx
   14e75:	52                   	push   %edx
   14e76:	e8 7b 05 00 00       	call   153f6 <_ColIDCT>
   14e7b:	83 c4 10             	add    $0x10,%esp
   14e7e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14e82:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14e86:	7e c5                	jle    14e4d <_DecodeBlock+0x194>
}
   14e88:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14e8b:	c9                   	leave  
   14e8c:	c3                   	ret    

00014e8d <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14e8d:	55                   	push   %ebp
   14e8e:	89 e5                	mov    %esp,%ebp
   14e90:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14e93:	83 ec 08             	sub    $0x8,%esp
   14e96:	6a 10                	push   $0x10
   14e98:	ff 75 08             	pushl  0x8(%ebp)
   14e9b:	e8 c2 00 00 00       	call   14f62 <_ShowBits>
   14ea0:	83 c4 10             	add    $0x10,%esp
   14ea3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14ea6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ea9:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14eac:	8b 45 0c             	mov    0xc(%ebp),%eax
   14eaf:	01 d0                	add    %edx,%eax
   14eb1:	0f b6 00             	movzbl (%eax),%eax
   14eb4:	0f b6 c0             	movzbl %al,%eax
   14eb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14eba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14ebe:	75 13                	jne    14ed3 <_GetVLC+0x46>
   14ec0:	8b 45 08             	mov    0x8(%ebp),%eax
   14ec3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ec9:	b8 00 00 00 00       	mov    $0x0,%eax
   14ece:	e9 8d 00 00 00       	jmp    14f60 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14ed3:	83 ec 08             	sub    $0x8,%esp
   14ed6:	ff 75 f0             	pushl  -0x10(%ebp)
   14ed9:	ff 75 08             	pushl  0x8(%ebp)
   14edc:	e8 25 02 00 00       	call   15106 <_SkipBits>
   14ee1:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14ee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ee7:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14eea:	8b 45 0c             	mov    0xc(%ebp),%eax
   14eed:	01 d0                	add    %edx,%eax
   14eef:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14ef3:	0f b6 c0             	movzbl %al,%eax
   14ef6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14ef9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14efd:	74 0a                	je     14f09 <_GetVLC+0x7c>
   14eff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14f02:	89 c2                	mov    %eax,%edx
   14f04:	8b 45 10             	mov    0x10(%ebp),%eax
   14f07:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14f0c:	83 e0 0f             	and    $0xf,%eax
   14f0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14f12:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14f16:	75 07                	jne    14f1f <_GetVLC+0x92>
   14f18:	b8 00 00 00 00       	mov    $0x0,%eax
   14f1d:	eb 41                	jmp    14f60 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14f1f:	83 ec 08             	sub    $0x8,%esp
   14f22:	ff 75 f0             	pushl  -0x10(%ebp)
   14f25:	ff 75 08             	pushl  0x8(%ebp)
   14f28:	e8 12 02 00 00       	call   1513f <_GetBits>
   14f2d:	83 c4 10             	add    $0x10,%esp
   14f30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14f33:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f36:	83 e8 01             	sub    $0x1,%eax
   14f39:	ba 01 00 00 00       	mov    $0x1,%edx
   14f3e:	89 c1                	mov    %eax,%ecx
   14f40:	d3 e2                	shl    %cl,%edx
   14f42:	89 d0                	mov    %edx,%eax
   14f44:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14f47:	7e 14                	jle    14f5d <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14f49:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f4c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14f51:	89 c1                	mov    %eax,%ecx
   14f53:	d3 e2                	shl    %cl,%edx
   14f55:	89 d0                	mov    %edx,%eax
   14f57:	83 c0 01             	add    $0x1,%eax
   14f5a:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14f5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14f60:	c9                   	leave  
   14f61:	c3                   	ret    

00014f62 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14f62:	55                   	push   %ebp
   14f63:	89 e5                	mov    %esp,%ebp
   14f65:	53                   	push   %ebx
   14f66:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14f69:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14f6d:	0f 85 4f 01 00 00    	jne    150c2 <_ShowBits+0x160>
   14f73:	b8 00 00 00 00       	mov    $0x0,%eax
   14f78:	e9 83 01 00 00       	jmp    15100 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14f7d:	8b 45 08             	mov    0x8(%ebp),%eax
   14f80:	8b 40 08             	mov    0x8(%eax),%eax
   14f83:	85 c0                	test   %eax,%eax
   14f85:	7f 33                	jg     14fba <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14f87:	8b 45 08             	mov    0x8(%ebp),%eax
   14f8a:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14f90:	c1 e0 08             	shl    $0x8,%eax
   14f93:	0c ff                	or     $0xff,%al
   14f95:	89 c2                	mov    %eax,%edx
   14f97:	8b 45 08             	mov    0x8(%ebp),%eax
   14f9a:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14fa0:	8b 45 08             	mov    0x8(%ebp),%eax
   14fa3:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14fa9:	8d 50 08             	lea    0x8(%eax),%edx
   14fac:	8b 45 08             	mov    0x8(%ebp),%eax
   14faf:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14fb5:	e9 08 01 00 00       	jmp    150c2 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14fba:	8b 45 08             	mov    0x8(%ebp),%eax
   14fbd:	8b 40 04             	mov    0x4(%eax),%eax
   14fc0:	8d 48 01             	lea    0x1(%eax),%ecx
   14fc3:	8b 55 08             	mov    0x8(%ebp),%edx
   14fc6:	89 4a 04             	mov    %ecx,0x4(%edx)
   14fc9:	0f b6 00             	movzbl (%eax),%eax
   14fcc:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14fcf:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd2:	8b 40 08             	mov    0x8(%eax),%eax
   14fd5:	8d 50 ff             	lea    -0x1(%eax),%edx
   14fd8:	8b 45 08             	mov    0x8(%ebp),%eax
   14fdb:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14fde:	8b 45 08             	mov    0x8(%ebp),%eax
   14fe1:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14fe7:	8d 50 08             	lea    0x8(%eax),%edx
   14fea:	8b 45 08             	mov    0x8(%ebp),%eax
   14fed:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14ff3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ff6:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14ffc:	c1 e0 08             	shl    $0x8,%eax
   14fff:	89 c2                	mov    %eax,%edx
   15001:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   15005:	09 c2                	or     %eax,%edx
   15007:	8b 45 08             	mov    0x8(%ebp),%eax
   1500a:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   15010:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   15014:	0f 85 a8 00 00 00    	jne    150c2 <_ShowBits+0x160>
            if(ctx->size){
   1501a:	8b 45 08             	mov    0x8(%ebp),%eax
   1501d:	8b 40 08             	mov    0x8(%eax),%eax
   15020:	85 c0                	test   %eax,%eax
   15022:	0f 84 91 00 00 00    	je     150b9 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   15028:	8b 45 08             	mov    0x8(%ebp),%eax
   1502b:	8b 40 04             	mov    0x4(%eax),%eax
   1502e:	8d 48 01             	lea    0x1(%eax),%ecx
   15031:	8b 55 08             	mov    0x8(%ebp),%edx
   15034:	89 4a 04             	mov    %ecx,0x4(%edx)
   15037:	0f b6 00             	movzbl (%eax),%eax
   1503a:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   1503d:	8b 45 08             	mov    0x8(%ebp),%eax
   15040:	8b 40 08             	mov    0x8(%eax),%eax
   15043:	8d 50 ff             	lea    -0x1(%eax),%edx
   15046:	8b 45 08             	mov    0x8(%ebp),%eax
   15049:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   1504c:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15050:	85 c0                	test   %eax,%eax
   15052:	74 62                	je     150b6 <_ShowBits+0x154>
   15054:	3d d9 00 00 00       	cmp    $0xd9,%eax
   15059:	75 0c                	jne    15067 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   1505b:	8b 45 08             	mov    0x8(%ebp),%eax
   1505e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   15065:	eb 5b                	jmp    150c2 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   15067:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1506b:	25 f8 00 00 00       	and    $0xf8,%eax
   15070:	3d d0 00 00 00       	cmp    $0xd0,%eax
   15075:	74 0b                	je     15082 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   15077:	8b 45 08             	mov    0x8(%ebp),%eax
   1507a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   15080:	eb 40                	jmp    150c2 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   15082:	8b 45 08             	mov    0x8(%ebp),%eax
   15085:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   1508b:	c1 e0 08             	shl    $0x8,%eax
   1508e:	89 c2                	mov    %eax,%edx
   15090:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   15094:	09 c2                	or     %eax,%edx
   15096:	8b 45 08             	mov    0x8(%ebp),%eax
   15099:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   1509f:	8b 45 08             	mov    0x8(%ebp),%eax
   150a2:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   150a8:	8d 50 08             	lea    0x8(%eax),%edx
   150ab:	8b 45 08             	mov    0x8(%ebp),%eax
   150ae:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   150b4:	eb 0c                	jmp    150c2 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   150b6:	90                   	nop
   150b7:	eb 09                	jmp    150c2 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   150b9:	8b 45 08             	mov    0x8(%ebp),%eax
   150bc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   150c2:	8b 45 08             	mov    0x8(%ebp),%eax
   150c5:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   150cb:	3b 45 0c             	cmp    0xc(%ebp),%eax
   150ce:	0f 8c a9 fe ff ff    	jl     14f7d <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   150d4:	8b 45 08             	mov    0x8(%ebp),%eax
   150d7:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   150dd:	8b 45 08             	mov    0x8(%ebp),%eax
   150e0:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   150e6:	2b 45 0c             	sub    0xc(%ebp),%eax
   150e9:	89 c1                	mov    %eax,%ecx
   150eb:	d3 fa                	sar    %cl,%edx
   150ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   150f0:	bb 01 00 00 00       	mov    $0x1,%ebx
   150f5:	89 c1                	mov    %eax,%ecx
   150f7:	d3 e3                	shl    %cl,%ebx
   150f9:	89 d8                	mov    %ebx,%eax
   150fb:	83 e8 01             	sub    $0x1,%eax
   150fe:	21 d0                	and    %edx,%eax
}
   15100:	83 c4 10             	add    $0x10,%esp
   15103:	5b                   	pop    %ebx
   15104:	5d                   	pop    %ebp
   15105:	c3                   	ret    

00015106 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   15106:	55                   	push   %ebp
   15107:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   15109:	8b 45 08             	mov    0x8(%ebp),%eax
   1510c:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15112:	3b 45 0c             	cmp    0xc(%ebp),%eax
   15115:	7d 0e                	jge    15125 <_SkipBits+0x1f>
   15117:	ff 75 0c             	pushl  0xc(%ebp)
   1511a:	ff 75 08             	pushl  0x8(%ebp)
   1511d:	e8 40 fe ff ff       	call   14f62 <_ShowBits>
   15122:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   15125:	8b 45 08             	mov    0x8(%ebp),%eax
   15128:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1512e:	2b 45 0c             	sub    0xc(%ebp),%eax
   15131:	89 c2                	mov    %eax,%edx
   15133:	8b 45 08             	mov    0x8(%ebp),%eax
   15136:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1513c:	90                   	nop
   1513d:	c9                   	leave  
   1513e:	c3                   	ret    

0001513f <_GetBits>:

int _GetBits(Context* ctx, int bits){
   1513f:	55                   	push   %ebp
   15140:	89 e5                	mov    %esp,%ebp
   15142:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   15145:	ff 75 0c             	pushl  0xc(%ebp)
   15148:	ff 75 08             	pushl  0x8(%ebp)
   1514b:	e8 12 fe ff ff       	call   14f62 <_ShowBits>
   15150:	83 c4 08             	add    $0x8,%esp
   15153:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   15156:	ff 75 0c             	pushl  0xc(%ebp)
   15159:	ff 75 08             	pushl  0x8(%ebp)
   1515c:	e8 a5 ff ff ff       	call   15106 <_SkipBits>
   15161:	83 c4 08             	add    $0x8,%esp
    return res;
   15164:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   15167:	c9                   	leave  
   15168:	c3                   	ret    

00015169 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   15169:	55                   	push   %ebp
   1516a:	89 e5                	mov    %esp,%ebp
   1516c:	57                   	push   %edi
   1516d:	56                   	push   %esi
   1516e:	53                   	push   %ebx
   1516f:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   15172:	8b 45 08             	mov    0x8(%ebp),%eax
   15175:	83 c0 10             	add    $0x10,%eax
   15178:	8b 00                	mov    (%eax),%eax
   1517a:	c1 e0 0b             	shl    $0xb,%eax
   1517d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   15180:	8b 45 08             	mov    0x8(%ebp),%eax
   15183:	8b 40 18             	mov    0x18(%eax),%eax
   15186:	89 45 ec             	mov    %eax,-0x14(%ebp)
   15189:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1518c:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   1518f:	8b 55 08             	mov    0x8(%ebp),%edx
   15192:	8b 52 08             	mov    0x8(%edx),%edx
   15195:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15198:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   1519b:	8b 55 08             	mov    0x8(%ebp),%edx
   1519e:	8b 52 04             	mov    0x4(%edx),%edx
   151a1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   151a4:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   151a7:	8b 55 08             	mov    0x8(%ebp),%edx
   151aa:	8b 52 1c             	mov    0x1c(%edx),%edx
   151ad:	89 55 e0             	mov    %edx,-0x20(%ebp)
   151b0:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   151b3:	8b 55 08             	mov    0x8(%ebp),%edx
   151b6:	8b 52 14             	mov    0x14(%edx),%edx
   151b9:	89 55 dc             	mov    %edx,-0x24(%ebp)
   151bc:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   151bf:	8b 55 08             	mov    0x8(%ebp),%edx
   151c2:	8b 52 0c             	mov    0xc(%edx),%edx
   151c5:	89 55 d8             	mov    %edx,-0x28(%ebp)
   151c8:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   151cb:	85 c0                	test   %eax,%eax
   151cd:	75 68                	jne    15237 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   151cf:	8b 45 08             	mov    0x8(%ebp),%eax
   151d2:	8d 48 04             	lea    0x4(%eax),%ecx
   151d5:	8b 45 08             	mov    0x8(%ebp),%eax
   151d8:	8d 58 08             	lea    0x8(%eax),%ebx
   151db:	8b 45 08             	mov    0x8(%ebp),%eax
   151de:	8d 70 0c             	lea    0xc(%eax),%esi
   151e1:	8b 45 08             	mov    0x8(%ebp),%eax
   151e4:	8d 78 10             	lea    0x10(%eax),%edi
   151e7:	8b 45 08             	mov    0x8(%ebp),%eax
   151ea:	83 c0 14             	add    $0x14,%eax
   151ed:	89 45 c0             	mov    %eax,-0x40(%ebp)
   151f0:	8b 45 08             	mov    0x8(%ebp),%eax
   151f3:	83 c0 18             	add    $0x18,%eax
   151f6:	89 45 bc             	mov    %eax,-0x44(%ebp)
   151f9:	8b 45 08             	mov    0x8(%ebp),%eax
   151fc:	8d 50 1c             	lea    0x1c(%eax),%edx
   151ff:	8b 45 08             	mov    0x8(%ebp),%eax
   15202:	8b 00                	mov    (%eax),%eax
   15204:	c1 e0 03             	shl    $0x3,%eax
   15207:	89 02                	mov    %eax,(%edx)
   15209:	8b 02                	mov    (%edx),%eax
   1520b:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1520e:	89 02                	mov    %eax,(%edx)
   15210:	89 d0                	mov    %edx,%eax
   15212:	8b 00                	mov    (%eax),%eax
   15214:	8b 55 c0             	mov    -0x40(%ebp),%edx
   15217:	89 02                	mov    %eax,(%edx)
   15219:	89 d0                	mov    %edx,%eax
   1521b:	8b 00                	mov    (%eax),%eax
   1521d:	89 07                	mov    %eax,(%edi)
   1521f:	8b 07                	mov    (%edi),%eax
   15221:	89 06                	mov    %eax,(%esi)
   15223:	8b 06                	mov    (%esi),%eax
   15225:	89 03                	mov    %eax,(%ebx)
   15227:	8b 03                	mov    (%ebx),%eax
   15229:	89 01                	mov    %eax,(%ecx)
   1522b:	8b 11                	mov    (%ecx),%edx
   1522d:	8b 45 08             	mov    0x8(%ebp),%eax
   15230:	89 10                	mov    %edx,(%eax)
        return;
   15232:	e9 b7 01 00 00       	jmp    153ee <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   15237:	8b 45 08             	mov    0x8(%ebp),%eax
   1523a:	8b 00                	mov    (%eax),%eax
   1523c:	c1 e0 0b             	shl    $0xb,%eax
   1523f:	83 e8 80             	sub    $0xffffff80,%eax
   15242:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   15245:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15248:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1524b:	01 d0                	add    %edx,%eax
   1524d:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15253:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   15256:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15259:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1525f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15262:	01 d0                	add    %edx,%eax
   15264:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   15267:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1526a:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15270:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15273:	01 d0                	add    %edx,%eax
   15275:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   15278:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1527b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1527e:	01 d0                	add    %edx,%eax
   15280:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15286:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   15289:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1528c:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15292:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15295:	01 d0                	add    %edx,%eax
   15297:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   1529a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1529d:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   152a3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   152a6:	01 d0                	add    %edx,%eax
   152a8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   152ab:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   152ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152b1:	01 d0                	add    %edx,%eax
   152b3:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   152b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152b9:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   152bc:	8b 55 e8             	mov    -0x18(%ebp),%edx
   152bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
   152c2:	01 d0                	add    %edx,%eax
   152c4:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   152ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   152cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   152d0:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   152d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152d9:	01 d0                	add    %edx,%eax
   152db:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   152de:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152e1:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   152e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152ea:	01 d0                	add    %edx,%eax
   152ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   152ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   152f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152f5:	01 d0                	add    %edx,%eax
   152f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   152fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152fd:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   15300:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15303:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15306:	01 d0                	add    %edx,%eax
   15308:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   1530b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1530e:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   15311:	8b 55 d0             	mov    -0x30(%ebp),%edx
   15314:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15317:	01 d0                	add    %edx,%eax
   15319:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   1531c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1531f:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   15322:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15325:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15328:	01 d0                	add    %edx,%eax
   1532a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   1532d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15330:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15333:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15336:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15339:	01 d0                	add    %edx,%eax
   1533b:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15341:	83 e8 80             	sub    $0xffffff80,%eax
   15344:	c1 f8 08             	sar    $0x8,%eax
   15347:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   1534a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1534d:	2b 45 e0             	sub    -0x20(%ebp),%eax
   15350:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15356:	83 e8 80             	sub    $0xffffff80,%eax
   15359:	c1 f8 08             	sar    $0x8,%eax
   1535c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   1535f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15362:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15365:	01 d0                	add    %edx,%eax
   15367:	c1 f8 08             	sar    $0x8,%eax
   1536a:	89 c2                	mov    %eax,%edx
   1536c:	8b 45 08             	mov    0x8(%ebp),%eax
   1536f:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   15371:	8b 45 08             	mov    0x8(%ebp),%eax
   15374:	83 c0 04             	add    $0x4,%eax
   15377:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1537a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1537d:	01 ca                	add    %ecx,%edx
   1537f:	c1 fa 08             	sar    $0x8,%edx
   15382:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   15384:	8b 45 08             	mov    0x8(%ebp),%eax
   15387:	83 c0 08             	add    $0x8,%eax
   1538a:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   1538d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15390:	01 ca                	add    %ecx,%edx
   15392:	c1 fa 08             	sar    $0x8,%edx
   15395:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   15397:	8b 45 08             	mov    0x8(%ebp),%eax
   1539a:	83 c0 0c             	add    $0xc,%eax
   1539d:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   153a0:	8b 55 dc             	mov    -0x24(%ebp),%edx
   153a3:	01 ca                	add    %ecx,%edx
   153a5:	c1 fa 08             	sar    $0x8,%edx
   153a8:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   153aa:	8b 45 08             	mov    0x8(%ebp),%eax
   153ad:	8d 50 10             	lea    0x10(%eax),%edx
   153b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   153b3:	2b 45 dc             	sub    -0x24(%ebp),%eax
   153b6:	c1 f8 08             	sar    $0x8,%eax
   153b9:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   153bb:	8b 45 08             	mov    0x8(%ebp),%eax
   153be:	8d 50 14             	lea    0x14(%eax),%edx
   153c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   153c4:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   153c7:	c1 f8 08             	sar    $0x8,%eax
   153ca:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   153cc:	8b 45 08             	mov    0x8(%ebp),%eax
   153cf:	8d 50 18             	lea    0x18(%eax),%edx
   153d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   153d5:	2b 45 ec             	sub    -0x14(%ebp),%eax
   153d8:	c1 f8 08             	sar    $0x8,%eax
   153db:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   153dd:	8b 45 08             	mov    0x8(%ebp),%eax
   153e0:	8d 50 1c             	lea    0x1c(%eax),%edx
   153e3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   153e6:	2b 45 f0             	sub    -0x10(%ebp),%eax
   153e9:	c1 f8 08             	sar    $0x8,%eax
   153ec:	89 02                	mov    %eax,(%edx)
}
   153ee:	83 c4 38             	add    $0x38,%esp
   153f1:	5b                   	pop    %ebx
   153f2:	5e                   	pop    %esi
   153f3:	5f                   	pop    %edi
   153f4:	5d                   	pop    %ebp
   153f5:	c3                   	ret    

000153f6 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   153f6:	55                   	push   %ebp
   153f7:	89 e5                	mov    %esp,%ebp
   153f9:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   153fc:	8b 45 08             	mov    0x8(%ebp),%eax
   153ff:	83 e8 80             	sub    $0xffffff80,%eax
   15402:	8b 00                	mov    (%eax),%eax
   15404:	c1 e0 08             	shl    $0x8,%eax
   15407:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   1540a:	8b 45 08             	mov    0x8(%ebp),%eax
   1540d:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15413:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15416:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15419:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   1541c:	8b 55 08             	mov    0x8(%ebp),%edx
   1541f:	8b 52 40             	mov    0x40(%edx),%edx
   15422:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15425:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15428:	8b 55 08             	mov    0x8(%ebp),%edx
   1542b:	8b 52 20             	mov    0x20(%edx),%edx
   1542e:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15431:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15434:	8b 55 08             	mov    0x8(%ebp),%edx
   15437:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   1543d:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15440:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   15443:	8b 55 08             	mov    0x8(%ebp),%edx
   15446:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   1544c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1544f:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   15452:	8b 55 08             	mov    0x8(%ebp),%edx
   15455:	8b 52 60             	mov    0x60(%edx),%edx
   15458:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1545b:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1545e:	85 c0                	test   %eax,%eax
   15460:	75 45                	jne    154a7 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   15462:	8b 45 08             	mov    0x8(%ebp),%eax
   15465:	8b 00                	mov    (%eax),%eax
   15467:	83 c0 20             	add    $0x20,%eax
   1546a:	c1 f8 06             	sar    $0x6,%eax
   1546d:	83 e8 80             	sub    $0xffffff80,%eax
   15470:	50                   	push   %eax
   15471:	e8 d6 ea ff ff       	call   13f4c <_Clip>
   15476:	83 c4 04             	add    $0x4,%esp
   15479:	0f b6 c0             	movzbl %al,%eax
   1547c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   1547f:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   15486:	eb 14                	jmp    1549c <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   15488:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1548b:	89 c2                	mov    %eax,%edx
   1548d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15490:	88 10                	mov    %dl,(%eax)
            out += stride;
   15492:	8b 45 10             	mov    0x10(%ebp),%eax
   15495:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   15498:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   1549c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   154a0:	75 e6                	jne    15488 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   154a2:	e9 57 02 00 00       	jmp    156fe <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   154a7:	8b 45 08             	mov    0x8(%ebp),%eax
   154aa:	8b 00                	mov    (%eax),%eax
   154ac:	c1 e0 08             	shl    $0x8,%eax
   154af:	05 00 20 00 00       	add    $0x2000,%eax
   154b4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   154b7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   154ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
   154bd:	01 d0                	add    %edx,%eax
   154bf:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   154c5:	83 c0 04             	add    $0x4,%eax
   154c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   154cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154ce:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   154d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   154d7:	01 d0                	add    %edx,%eax
   154d9:	c1 f8 03             	sar    $0x3,%eax
   154dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   154df:	8b 45 e8             	mov    -0x18(%ebp),%eax
   154e2:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   154e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   154eb:	01 d0                	add    %edx,%eax
   154ed:	c1 f8 03             	sar    $0x3,%eax
   154f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   154f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   154f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154f9:	01 d0                	add    %edx,%eax
   154fb:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15501:	83 c0 04             	add    $0x4,%eax
   15504:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15507:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1550a:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15510:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15513:	01 d0                	add    %edx,%eax
   15515:	c1 f8 03             	sar    $0x3,%eax
   15518:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   1551b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1551e:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15524:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15527:	01 d0                	add    %edx,%eax
   15529:	c1 f8 03             	sar    $0x3,%eax
   1552c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1552f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15532:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15535:	01 d0                	add    %edx,%eax
   15537:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   1553a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1553d:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   15540:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15543:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15546:	01 d0                	add    %edx,%eax
   15548:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1554e:	83 c0 04             	add    $0x4,%eax
   15551:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   15554:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15557:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1555d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15560:	01 d0                	add    %edx,%eax
   15562:	c1 f8 03             	sar    $0x3,%eax
   15565:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   15568:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1556b:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15571:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15574:	01 d0                	add    %edx,%eax
   15576:	c1 f8 03             	sar    $0x3,%eax
   15579:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   1557c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1557f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15582:	01 d0                	add    %edx,%eax
   15584:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   15587:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1558a:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   1558d:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15590:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15593:	01 d0                	add    %edx,%eax
   15595:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   15598:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1559b:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   1559e:	8b 55 dc             	mov    -0x24(%ebp),%edx
   155a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155a4:	01 d0                	add    %edx,%eax
   155a6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   155a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155ac:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   155af:	8b 55 fc             	mov    -0x4(%ebp),%edx
   155b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   155b5:	01 d0                	add    %edx,%eax
   155b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   155ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
   155bd:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   155c0:	8b 55 ec             	mov    -0x14(%ebp),%edx
   155c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   155c6:	01 d0                	add    %edx,%eax
   155c8:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   155ce:	83 e8 80             	sub    $0xffffff80,%eax
   155d1:	c1 f8 08             	sar    $0x8,%eax
   155d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   155d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155da:	2b 45 e8             	sub    -0x18(%ebp),%eax
   155dd:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   155e3:	83 e8 80             	sub    $0xffffff80,%eax
   155e6:	c1 f8 08             	sar    $0x8,%eax
   155e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   155ec:	8b 55 e0             	mov    -0x20(%ebp),%edx
   155ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
   155f2:	01 d0                	add    %edx,%eax
   155f4:	c1 f8 0e             	sar    $0xe,%eax
   155f7:	83 e8 80             	sub    $0xffffff80,%eax
   155fa:	50                   	push   %eax
   155fb:	e8 4c e9 ff ff       	call   13f4c <_Clip>
   15600:	83 c4 04             	add    $0x4,%esp
   15603:	89 c2                	mov    %eax,%edx
   15605:	8b 45 0c             	mov    0xc(%ebp),%eax
   15608:	88 10                	mov    %dl,(%eax)
   1560a:	8b 45 10             	mov    0x10(%ebp),%eax
   1560d:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   15610:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15613:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15616:	01 d0                	add    %edx,%eax
   15618:	c1 f8 0e             	sar    $0xe,%eax
   1561b:	83 e8 80             	sub    $0xffffff80,%eax
   1561e:	50                   	push   %eax
   1561f:	e8 28 e9 ff ff       	call   13f4c <_Clip>
   15624:	83 c4 04             	add    $0x4,%esp
   15627:	89 c2                	mov    %eax,%edx
   15629:	8b 45 0c             	mov    0xc(%ebp),%eax
   1562c:	88 10                	mov    %dl,(%eax)
   1562e:	8b 45 10             	mov    0x10(%ebp),%eax
   15631:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15634:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15637:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1563a:	01 d0                	add    %edx,%eax
   1563c:	c1 f8 0e             	sar    $0xe,%eax
   1563f:	83 e8 80             	sub    $0xffffff80,%eax
   15642:	50                   	push   %eax
   15643:	e8 04 e9 ff ff       	call   13f4c <_Clip>
   15648:	83 c4 04             	add    $0x4,%esp
   1564b:	89 c2                	mov    %eax,%edx
   1564d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15650:	88 10                	mov    %dl,(%eax)
   15652:	8b 45 10             	mov    0x10(%ebp),%eax
   15655:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15658:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1565b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1565e:	01 d0                	add    %edx,%eax
   15660:	c1 f8 0e             	sar    $0xe,%eax
   15663:	83 e8 80             	sub    $0xffffff80,%eax
   15666:	50                   	push   %eax
   15667:	e8 e0 e8 ff ff       	call   13f4c <_Clip>
   1566c:	83 c4 04             	add    $0x4,%esp
   1566f:	89 c2                	mov    %eax,%edx
   15671:	8b 45 0c             	mov    0xc(%ebp),%eax
   15674:	88 10                	mov    %dl,(%eax)
   15676:	8b 45 10             	mov    0x10(%ebp),%eax
   15679:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   1567c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1567f:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15682:	c1 f8 0e             	sar    $0xe,%eax
   15685:	83 e8 80             	sub    $0xffffff80,%eax
   15688:	50                   	push   %eax
   15689:	e8 be e8 ff ff       	call   13f4c <_Clip>
   1568e:	83 c4 04             	add    $0x4,%esp
   15691:	89 c2                	mov    %eax,%edx
   15693:	8b 45 0c             	mov    0xc(%ebp),%eax
   15696:	88 10                	mov    %dl,(%eax)
   15698:	8b 45 10             	mov    0x10(%ebp),%eax
   1569b:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   1569e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   156a1:	2b 45 ec             	sub    -0x14(%ebp),%eax
   156a4:	c1 f8 0e             	sar    $0xe,%eax
   156a7:	83 e8 80             	sub    $0xffffff80,%eax
   156aa:	50                   	push   %eax
   156ab:	e8 9c e8 ff ff       	call   13f4c <_Clip>
   156b0:	83 c4 04             	add    $0x4,%esp
   156b3:	89 c2                	mov    %eax,%edx
   156b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   156b8:	88 10                	mov    %dl,(%eax)
   156ba:	8b 45 10             	mov    0x10(%ebp),%eax
   156bd:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   156c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156c3:	2b 45 f4             	sub    -0xc(%ebp),%eax
   156c6:	c1 f8 0e             	sar    $0xe,%eax
   156c9:	83 e8 80             	sub    $0xffffff80,%eax
   156cc:	50                   	push   %eax
   156cd:	e8 7a e8 ff ff       	call   13f4c <_Clip>
   156d2:	83 c4 04             	add    $0x4,%esp
   156d5:	89 c2                	mov    %eax,%edx
   156d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   156da:	88 10                	mov    %dl,(%eax)
   156dc:	8b 45 10             	mov    0x10(%ebp),%eax
   156df:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   156e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156e5:	2b 45 f8             	sub    -0x8(%ebp),%eax
   156e8:	c1 f8 0e             	sar    $0xe,%eax
   156eb:	83 e8 80             	sub    $0xffffff80,%eax
   156ee:	50                   	push   %eax
   156ef:	e8 58 e8 ff ff       	call   13f4c <_Clip>
   156f4:	83 c4 04             	add    $0x4,%esp
   156f7:	89 c2                	mov    %eax,%edx
   156f9:	8b 45 0c             	mov    0xc(%ebp),%eax
   156fc:	88 10                	mov    %dl,(%eax)
}
   156fe:	c9                   	leave  
   156ff:	c3                   	ret    

00015700 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   15700:	55                   	push   %ebp
   15701:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15703:	8b 45 08             	mov    0x8(%ebp),%eax
   15706:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1570c:	25 f8 00 00 00       	and    $0xf8,%eax
   15711:	89 c2                	mov    %eax,%edx
   15713:	8b 45 08             	mov    0x8(%ebp),%eax
   15716:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1571c:	90                   	nop
   1571d:	5d                   	pop    %ebp
   1571e:	c3                   	ret    

0001571f <_SkipMarker>:

void _SkipMarker(Context* ctx){
   1571f:	55                   	push   %ebp
   15720:	89 e5                	mov    %esp,%ebp
   15722:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15725:	83 ec 0c             	sub    $0xc,%esp
   15728:	ff 75 08             	pushl  0x8(%ebp)
   1572b:	e8 8d e8 ff ff       	call   13fbd <_DecodeLength>
   15730:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   15733:	8b 45 08             	mov    0x8(%ebp),%eax
   15736:	8b 40 0c             	mov    0xc(%eax),%eax
   15739:	83 ec 08             	sub    $0x8,%esp
   1573c:	50                   	push   %eax
   1573d:	ff 75 08             	pushl  0x8(%ebp)
   15740:	e8 2c e8 ff ff       	call   13f71 <_Skip>
   15745:	83 c4 10             	add    $0x10,%esp
}
   15748:	90                   	nop
   15749:	c9                   	leave  
   1574a:	c3                   	ret    

0001574b <_Convert>:

void _Convert(Context* ctx){
   1574b:	55                   	push   %ebp
   1574c:	89 e5                	mov    %esp,%ebp
   1574e:	57                   	push   %edi
   1574f:	56                   	push   %esi
   15750:	53                   	push   %ebx
   15751:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15754:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1575b:	8b 45 08             	mov    0x8(%ebp),%eax
   1575e:	83 c0 2c             	add    $0x2c,%eax
   15761:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15764:	e9 b2 00 00 00       	jmp    1581b <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15769:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1576c:	8b 50 0c             	mov    0xc(%eax),%edx
   1576f:	8b 45 08             	mov    0x8(%ebp),%eax
   15772:	8b 40 10             	mov    0x10(%eax),%eax
   15775:	39 c2                	cmp    %eax,%edx
   15777:	7d 11                	jge    1578a <_Convert+0x3f>
   15779:	83 ec 08             	sub    $0x8,%esp
   1577c:	ff 75 e0             	pushl  -0x20(%ebp)
   1577f:	ff 75 08             	pushl  0x8(%ebp)
   15782:	e8 79 02 00 00       	call   15a00 <_UpsampleH>
   15787:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   1578a:	8b 45 08             	mov    0x8(%ebp),%eax
   1578d:	8b 00                	mov    (%eax),%eax
   1578f:	85 c0                	test   %eax,%eax
   15791:	0f 85 5d 02 00 00    	jne    159f4 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   15797:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1579a:	8b 50 10             	mov    0x10(%eax),%edx
   1579d:	8b 45 08             	mov    0x8(%ebp),%eax
   157a0:	8b 40 14             	mov    0x14(%eax),%eax
   157a3:	39 c2                	cmp    %eax,%edx
   157a5:	7d 11                	jge    157b8 <_Convert+0x6d>
   157a7:	83 ec 08             	sub    $0x8,%esp
   157aa:	ff 75 e0             	pushl  -0x20(%ebp)
   157ad:	ff 75 08             	pushl  0x8(%ebp)
   157b0:	e8 db 05 00 00       	call   15d90 <_UpsampleV>
   157b5:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   157b8:	8b 45 08             	mov    0x8(%ebp),%eax
   157bb:	8b 00                	mov    (%eax),%eax
   157bd:	85 c0                	test   %eax,%eax
   157bf:	0f 85 32 02 00 00    	jne    159f7 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   157c5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   157c8:	8b 50 0c             	mov    0xc(%eax),%edx
   157cb:	8b 45 08             	mov    0x8(%ebp),%eax
   157ce:	8b 40 10             	mov    0x10(%eax),%eax
   157d1:	39 c2                	cmp    %eax,%edx
   157d3:	7c 94                	jl     15769 <_Convert+0x1e>
   157d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   157d8:	8b 50 10             	mov    0x10(%eax),%edx
   157db:	8b 45 08             	mov    0x8(%ebp),%eax
   157de:	8b 40 14             	mov    0x14(%eax),%eax
   157e1:	39 c2                	cmp    %eax,%edx
   157e3:	7c 84                	jl     15769 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   157e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   157e8:	8b 50 0c             	mov    0xc(%eax),%edx
   157eb:	8b 45 08             	mov    0x8(%ebp),%eax
   157ee:	8b 40 10             	mov    0x10(%eax),%eax
   157f1:	39 c2                	cmp    %eax,%edx
   157f3:	7c 10                	jl     15805 <_Convert+0xba>
   157f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   157f8:	8b 50 10             	mov    0x10(%eax),%edx
   157fb:	8b 45 08             	mov    0x8(%ebp),%eax
   157fe:	8b 40 14             	mov    0x14(%eax),%eax
   15801:	39 c2                	cmp    %eax,%edx
   15803:	7d 0e                	jge    15813 <_Convert+0xc8>
   15805:	8b 45 08             	mov    0x8(%ebp),%eax
   15808:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   1580e:	e9 e5 01 00 00       	jmp    159f8 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15813:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15817:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   1581b:	8b 45 08             	mov    0x8(%ebp),%eax
   1581e:	8b 40 28             	mov    0x28(%eax),%eax
   15821:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15824:	7f 9f                	jg     157c5 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15826:	8b 45 08             	mov    0x8(%ebp),%eax
   15829:	8b 40 28             	mov    0x28(%eax),%eax
   1582c:	83 f8 03             	cmp    $0x3,%eax
   1582f:	0f 85 3d 01 00 00    	jne    15972 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15835:	8b 45 08             	mov    0x8(%ebp),%eax
   15838:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1583e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   15841:	8b 45 08             	mov    0x8(%ebp),%eax
   15844:	8b 40 54             	mov    0x54(%eax),%eax
   15847:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   1584a:	8b 45 08             	mov    0x8(%ebp),%eax
   1584d:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   15853:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   15856:	8b 45 08             	mov    0x8(%ebp),%eax
   15859:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1585f:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   15862:	8b 45 08             	mov    0x8(%ebp),%eax
   15865:	8b 40 14             	mov    0x14(%eax),%eax
   15868:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1586b:	e9 f3 00 00 00       	jmp    15963 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   15870:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   15877:	e9 b6 00 00 00       	jmp    15932 <_Convert+0x1e7>
                register int y = py[x] << 8;
   1587c:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1587f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15882:	01 d0                	add    %edx,%eax
   15884:	0f b6 00             	movzbl (%eax),%eax
   15887:	0f b6 c0             	movzbl %al,%eax
   1588a:	c1 e0 08             	shl    $0x8,%eax
   1588d:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   1588f:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15892:	8b 45 cc             	mov    -0x34(%ebp),%eax
   15895:	01 d0                	add    %edx,%eax
   15897:	0f b6 00             	movzbl (%eax),%eax
   1589a:	0f b6 c0             	movzbl %al,%eax
   1589d:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   158a0:	8b 55 dc             	mov    -0x24(%ebp),%edx
   158a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
   158a6:	01 d0                	add    %edx,%eax
   158a8:	0f b6 00             	movzbl (%eax),%eax
   158ab:	0f b6 c0             	movzbl %al,%eax
   158ae:	83 c0 80             	add    $0xffffff80,%eax
   158b1:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   158b3:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   158b6:	8d 46 01             	lea    0x1(%esi),%eax
   158b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   158bc:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   158bf:	89 c8                	mov    %ecx,%eax
   158c1:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   158c7:	01 d8                	add    %ebx,%eax
   158c9:	83 e8 80             	sub    $0xffffff80,%eax
   158cc:	c1 f8 08             	sar    $0x8,%eax
   158cf:	83 ec 0c             	sub    $0xc,%esp
   158d2:	50                   	push   %eax
   158d3:	e8 74 e6 ff ff       	call   13f4c <_Clip>
   158d8:	83 c4 10             	add    $0x10,%esp
   158db:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   158dd:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   158e0:	8d 46 01             	lea    0x1(%esi),%eax
   158e3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   158e6:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   158e9:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   158ec:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   158f3:	01 d0                	add    %edx,%eax
   158f5:	83 e8 80             	sub    $0xffffff80,%eax
   158f8:	c1 f8 08             	sar    $0x8,%eax
   158fb:	83 ec 0c             	sub    $0xc,%esp
   158fe:	50                   	push   %eax
   158ff:	e8 48 e6 ff ff       	call   13f4c <_Clip>
   15904:	83 c4 10             	add    $0x10,%esp
   15907:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15909:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1590c:	8d 46 01             	lea    0x1(%esi),%eax
   1590f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15912:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15918:	01 d8                	add    %ebx,%eax
   1591a:	83 e8 80             	sub    $0xffffff80,%eax
   1591d:	c1 f8 08             	sar    $0x8,%eax
   15920:	83 ec 0c             	sub    $0xc,%esp
   15923:	50                   	push   %eax
   15924:	e8 23 e6 ff ff       	call   13f4c <_Clip>
   15929:	83 c4 10             	add    $0x10,%esp
   1592c:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   1592e:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   15932:	8b 45 08             	mov    0x8(%ebp),%eax
   15935:	8b 40 10             	mov    0x10(%eax),%eax
   15938:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   1593b:	0f 8f 3b ff ff ff    	jg     1587c <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   15941:	8b 45 08             	mov    0x8(%ebp),%eax
   15944:	8b 40 40             	mov    0x40(%eax),%eax
   15947:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   1594a:	8b 45 08             	mov    0x8(%ebp),%eax
   1594d:	8b 40 6c             	mov    0x6c(%eax),%eax
   15950:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   15953:	8b 45 08             	mov    0x8(%ebp),%eax
   15956:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1595c:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   1595f:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   15963:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15967:	0f 85 03 ff ff ff    	jne    15870 <_Convert+0x125>
   1596d:	e9 86 00 00 00       	jmp    159f8 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   15972:	8b 45 08             	mov    0x8(%ebp),%eax
   15975:	8b 50 38             	mov    0x38(%eax),%edx
   15978:	8b 45 08             	mov    0x8(%ebp),%eax
   1597b:	8b 40 40             	mov    0x40(%eax),%eax
   1597e:	39 c2                	cmp    %eax,%edx
   15980:	74 76                	je     159f8 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   15982:	8b 45 08             	mov    0x8(%ebp),%eax
   15985:	8b 50 54             	mov    0x54(%eax),%edx
   15988:	8b 45 08             	mov    0x8(%ebp),%eax
   1598b:	8b 40 40             	mov    0x40(%eax),%eax
   1598e:	01 d0                	add    %edx,%eax
   15990:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   15993:	8b 45 08             	mov    0x8(%ebp),%eax
   15996:	8b 50 54             	mov    0x54(%eax),%edx
   15999:	8b 45 08             	mov    0x8(%ebp),%eax
   1599c:	8b 40 38             	mov    0x38(%eax),%eax
   1599f:	01 d0                	add    %edx,%eax
   159a1:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   159a4:	8b 45 08             	mov    0x8(%ebp),%eax
   159a7:	8b 40 3c             	mov    0x3c(%eax),%eax
   159aa:	83 e8 01             	sub    $0x1,%eax
   159ad:	89 45 bc             	mov    %eax,-0x44(%ebp)
   159b0:	eb 2e                	jmp    159e0 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   159b2:	8b 45 08             	mov    0x8(%ebp),%eax
   159b5:	8b 40 38             	mov    0x38(%eax),%eax
   159b8:	83 ec 04             	sub    $0x4,%esp
   159bb:	50                   	push   %eax
   159bc:	ff 75 c4             	pushl  -0x3c(%ebp)
   159bf:	ff 75 c0             	pushl  -0x40(%ebp)
   159c2:	e8 72 ac fe ff       	call   639 <memmove>
   159c7:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   159ca:	8b 45 08             	mov    0x8(%ebp),%eax
   159cd:	8b 40 40             	mov    0x40(%eax),%eax
   159d0:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   159d3:	8b 45 08             	mov    0x8(%ebp),%eax
   159d6:	8b 40 38             	mov    0x38(%eax),%eax
   159d9:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   159dc:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   159e0:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   159e4:	75 cc                	jne    159b2 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   159e6:	8b 45 08             	mov    0x8(%ebp),%eax
   159e9:	8b 50 38             	mov    0x38(%eax),%edx
   159ec:	8b 45 08             	mov    0x8(%ebp),%eax
   159ef:	89 50 40             	mov    %edx,0x40(%eax)
   159f2:	eb 04                	jmp    159f8 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   159f4:	90                   	nop
   159f5:	eb 01                	jmp    159f8 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   159f7:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   159f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
   159fb:	5b                   	pop    %ebx
   159fc:	5e                   	pop    %esi
   159fd:	5f                   	pop    %edi
   159fe:	5d                   	pop    %ebp
   159ff:	c3                   	ret    

00015a00 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   15a00:	55                   	push   %ebp
   15a01:	89 e5                	mov    %esp,%ebp
   15a03:	53                   	push   %ebx
   15a04:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15a07:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a0a:	8b 40 0c             	mov    0xc(%eax),%eax
   15a0d:	83 e8 03             	sub    $0x3,%eax
   15a10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15a13:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a16:	8b 50 0c             	mov    0xc(%eax),%edx
   15a19:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a1c:	8b 40 10             	mov    0x10(%eax),%eax
   15a1f:	0f af c2             	imul   %edx,%eax
   15a22:	01 c0                	add    %eax,%eax
   15a24:	83 ec 0c             	sub    $0xc,%esp
   15a27:	50                   	push   %eax
   15a28:	e8 cb b0 fe ff       	call   af8 <malloc>
   15a2d:	83 c4 10             	add    $0x10,%esp
   15a30:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15a33:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15a37:	75 0e                	jne    15a47 <_UpsampleH+0x47>
   15a39:	8b 45 08             	mov    0x8(%ebp),%eax
   15a3c:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15a42:	e9 44 03 00 00       	jmp    15d8b <_UpsampleH+0x38b>
    lin = c->pixels;
   15a47:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a4a:	8b 40 28             	mov    0x28(%eax),%eax
   15a4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   15a50:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15a53:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   15a56:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a59:	8b 40 10             	mov    0x10(%eax),%eax
   15a5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   15a5f:	e9 e0 02 00 00       	jmp    15d44 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   15a64:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a67:	0f b6 00             	movzbl (%eax),%eax
   15a6a:	0f b6 c0             	movzbl %al,%eax
   15a6d:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15a73:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a76:	83 c0 01             	add    $0x1,%eax
   15a79:	0f b6 00             	movzbl (%eax),%eax
   15a7c:	0f b6 c0             	movzbl %al,%eax
   15a7f:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a82:	01 d0                	add    %edx,%eax
   15a84:	83 ec 0c             	sub    $0xc,%esp
   15a87:	50                   	push   %eax
   15a88:	e8 c4 06 00 00       	call   16151 <CF>
   15a8d:	83 c4 10             	add    $0x10,%esp
   15a90:	89 c2                	mov    %eax,%edx
   15a92:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a95:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   15a97:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a9a:	8d 58 01             	lea    0x1(%eax),%ebx
   15a9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aa0:	0f b6 00             	movzbl (%eax),%eax
   15aa3:	0f b6 c0             	movzbl %al,%eax
   15aa6:	6b c8 68             	imul   $0x68,%eax,%ecx
   15aa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aac:	83 c0 01             	add    $0x1,%eax
   15aaf:	0f b6 00             	movzbl (%eax),%eax
   15ab2:	0f b6 d0             	movzbl %al,%edx
   15ab5:	89 d0                	mov    %edx,%eax
   15ab7:	01 c0                	add    %eax,%eax
   15ab9:	01 d0                	add    %edx,%eax
   15abb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ac2:	01 d0                	add    %edx,%eax
   15ac4:	01 c1                	add    %eax,%ecx
   15ac6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ac9:	83 c0 02             	add    $0x2,%eax
   15acc:	0f b6 00             	movzbl (%eax),%eax
   15acf:	0f b6 d0             	movzbl %al,%edx
   15ad2:	89 d0                	mov    %edx,%eax
   15ad4:	01 c0                	add    %eax,%eax
   15ad6:	01 d0                	add    %edx,%eax
   15ad8:	f7 d8                	neg    %eax
   15ada:	01 c8                	add    %ecx,%eax
   15adc:	83 ec 0c             	sub    $0xc,%esp
   15adf:	50                   	push   %eax
   15ae0:	e8 6c 06 00 00       	call   16151 <CF>
   15ae5:	83 c4 10             	add    $0x10,%esp
   15ae8:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15aea:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15aed:	8d 58 02             	lea    0x2(%eax),%ebx
   15af0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15af3:	0f b6 00             	movzbl (%eax),%eax
   15af6:	0f b6 c0             	movzbl %al,%eax
   15af9:	c1 e0 02             	shl    $0x2,%eax
   15afc:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b03:	29 c2                	sub    %eax,%edx
   15b05:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b08:	83 c0 01             	add    $0x1,%eax
   15b0b:	0f b6 00             	movzbl (%eax),%eax
   15b0e:	0f b6 c0             	movzbl %al,%eax
   15b11:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15b14:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15b17:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b1a:	83 c0 02             	add    $0x2,%eax
   15b1d:	0f b6 00             	movzbl (%eax),%eax
   15b20:	0f b6 d0             	movzbl %al,%edx
   15b23:	89 d0                	mov    %edx,%eax
   15b25:	c1 e0 03             	shl    $0x3,%eax
   15b28:	01 d0                	add    %edx,%eax
   15b2a:	f7 d8                	neg    %eax
   15b2c:	01 c8                	add    %ecx,%eax
   15b2e:	83 ec 0c             	sub    $0xc,%esp
   15b31:	50                   	push   %eax
   15b32:	e8 1a 06 00 00       	call   16151 <CF>
   15b37:	83 c4 10             	add    $0x10,%esp
   15b3a:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15b3c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15b43:	e9 fa 00 00 00       	jmp    15c42 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15b48:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b4b:	01 c0                	add    %eax,%eax
   15b4d:	8d 50 03             	lea    0x3(%eax),%edx
   15b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b53:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15b56:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15b59:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b5c:	01 d0                	add    %edx,%eax
   15b5e:	0f b6 00             	movzbl (%eax),%eax
   15b61:	0f b6 d0             	movzbl %al,%edx
   15b64:	89 d0                	mov    %edx,%eax
   15b66:	c1 e0 03             	shl    $0x3,%eax
   15b69:	01 d0                	add    %edx,%eax
   15b6b:	f7 d8                	neg    %eax
   15b6d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15b70:	8d 4a 01             	lea    0x1(%edx),%ecx
   15b73:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b76:	01 ca                	add    %ecx,%edx
   15b78:	0f b6 12             	movzbl (%edx),%edx
   15b7b:	0f b6 d2             	movzbl %dl,%edx
   15b7e:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15b81:	01 c2                	add    %eax,%edx
   15b83:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b86:	8d 48 02             	lea    0x2(%eax),%ecx
   15b89:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b8c:	01 c8                	add    %ecx,%eax
   15b8e:	0f b6 00             	movzbl (%eax),%eax
   15b91:	0f b6 c0             	movzbl %al,%eax
   15b94:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15b97:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15b9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b9d:	8d 50 03             	lea    0x3(%eax),%edx
   15ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ba3:	01 d0                	add    %edx,%eax
   15ba5:	0f b6 00             	movzbl (%eax),%eax
   15ba8:	0f b6 d0             	movzbl %al,%edx
   15bab:	89 d0                	mov    %edx,%eax
   15bad:	01 c0                	add    %eax,%eax
   15baf:	01 d0                	add    %edx,%eax
   15bb1:	f7 d8                	neg    %eax
   15bb3:	01 c8                	add    %ecx,%eax
   15bb5:	83 ec 0c             	sub    $0xc,%esp
   15bb8:	50                   	push   %eax
   15bb9:	e8 93 05 00 00       	call   16151 <CF>
   15bbe:	83 c4 10             	add    $0x10,%esp
   15bc1:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   15bc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15bc6:	01 c0                	add    %eax,%eax
   15bc8:	8d 50 04             	lea    0x4(%eax),%edx
   15bcb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bce:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15bd1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15bd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bd7:	01 d0                	add    %edx,%eax
   15bd9:	0f b6 00             	movzbl (%eax),%eax
   15bdc:	0f b6 d0             	movzbl %al,%edx
   15bdf:	89 d0                	mov    %edx,%eax
   15be1:	01 c0                	add    %eax,%eax
   15be3:	01 d0                	add    %edx,%eax
   15be5:	f7 d8                	neg    %eax
   15be7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15bea:	8d 4a 01             	lea    0x1(%edx),%ecx
   15bed:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15bf0:	01 ca                	add    %ecx,%edx
   15bf2:	0f b6 12             	movzbl (%edx),%edx
   15bf5:	0f b6 d2             	movzbl %dl,%edx
   15bf8:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15bfb:	01 c2                	add    %eax,%edx
   15bfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15c00:	8d 48 02             	lea    0x2(%eax),%ecx
   15c03:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c06:	01 c8                	add    %ecx,%eax
   15c08:	0f b6 00             	movzbl (%eax),%eax
   15c0b:	0f b6 c0             	movzbl %al,%eax
   15c0e:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15c11:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15c14:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15c17:	8d 50 03             	lea    0x3(%eax),%edx
   15c1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c1d:	01 d0                	add    %edx,%eax
   15c1f:	0f b6 00             	movzbl (%eax),%eax
   15c22:	0f b6 d0             	movzbl %al,%edx
   15c25:	89 d0                	mov    %edx,%eax
   15c27:	c1 e0 03             	shl    $0x3,%eax
   15c2a:	01 d0                	add    %edx,%eax
   15c2c:	f7 d8                	neg    %eax
   15c2e:	01 c8                	add    %ecx,%eax
   15c30:	83 ec 0c             	sub    $0xc,%esp
   15c33:	50                   	push   %eax
   15c34:	e8 18 05 00 00       	call   16151 <CF>
   15c39:	83 c4 10             	add    $0x10,%esp
   15c3c:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15c3e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15c42:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15c45:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15c48:	0f 8c fa fe ff ff    	jl     15b48 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15c4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c51:	8b 40 14             	mov    0x14(%eax),%eax
   15c54:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   15c57:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c5a:	8b 40 0c             	mov    0xc(%eax),%eax
   15c5d:	01 c0                	add    %eax,%eax
   15c5f:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   15c62:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c65:	8d 58 fd             	lea    -0x3(%eax),%ebx
   15c68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c6b:	83 e8 01             	sub    $0x1,%eax
   15c6e:	0f b6 00             	movzbl (%eax),%eax
   15c71:	0f b6 c0             	movzbl %al,%eax
   15c74:	c1 e0 02             	shl    $0x2,%eax
   15c77:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c7e:	29 c2                	sub    %eax,%edx
   15c80:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c83:	83 e8 02             	sub    $0x2,%eax
   15c86:	0f b6 00             	movzbl (%eax),%eax
   15c89:	0f b6 c0             	movzbl %al,%eax
   15c8c:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15c8f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15c92:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c95:	83 e8 03             	sub    $0x3,%eax
   15c98:	0f b6 00             	movzbl (%eax),%eax
   15c9b:	0f b6 d0             	movzbl %al,%edx
   15c9e:	89 d0                	mov    %edx,%eax
   15ca0:	c1 e0 03             	shl    $0x3,%eax
   15ca3:	01 d0                	add    %edx,%eax
   15ca5:	f7 d8                	neg    %eax
   15ca7:	01 c8                	add    %ecx,%eax
   15ca9:	83 ec 0c             	sub    $0xc,%esp
   15cac:	50                   	push   %eax
   15cad:	e8 9f 04 00 00       	call   16151 <CF>
   15cb2:	83 c4 10             	add    $0x10,%esp
   15cb5:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15cba:	8d 58 fe             	lea    -0x2(%eax),%ebx
   15cbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cc0:	83 e8 01             	sub    $0x1,%eax
   15cc3:	0f b6 00             	movzbl (%eax),%eax
   15cc6:	0f b6 c0             	movzbl %al,%eax
   15cc9:	6b c8 68             	imul   $0x68,%eax,%ecx
   15ccc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ccf:	83 e8 02             	sub    $0x2,%eax
   15cd2:	0f b6 00             	movzbl (%eax),%eax
   15cd5:	0f b6 d0             	movzbl %al,%edx
   15cd8:	89 d0                	mov    %edx,%eax
   15cda:	01 c0                	add    %eax,%eax
   15cdc:	01 d0                	add    %edx,%eax
   15cde:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ce5:	01 d0                	add    %edx,%eax
   15ce7:	01 c1                	add    %eax,%ecx
   15ce9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cec:	83 e8 03             	sub    $0x3,%eax
   15cef:	0f b6 00             	movzbl (%eax),%eax
   15cf2:	0f b6 d0             	movzbl %al,%edx
   15cf5:	89 d0                	mov    %edx,%eax
   15cf7:	01 c0                	add    %eax,%eax
   15cf9:	01 d0                	add    %edx,%eax
   15cfb:	f7 d8                	neg    %eax
   15cfd:	01 c8                	add    %ecx,%eax
   15cff:	83 ec 0c             	sub    $0xc,%esp
   15d02:	50                   	push   %eax
   15d03:	e8 49 04 00 00       	call   16151 <CF>
   15d08:	83 c4 10             	add    $0x10,%esp
   15d0b:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15d0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d10:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15d13:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d16:	83 e8 01             	sub    $0x1,%eax
   15d19:	0f b6 00             	movzbl (%eax),%eax
   15d1c:	0f b6 c0             	movzbl %al,%eax
   15d1f:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15d25:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d28:	83 e8 02             	sub    $0x2,%eax
   15d2b:	0f b6 00             	movzbl (%eax),%eax
   15d2e:	0f b6 c0             	movzbl %al,%eax
   15d31:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15d34:	01 d0                	add    %edx,%eax
   15d36:	83 ec 0c             	sub    $0xc,%esp
   15d39:	50                   	push   %eax
   15d3a:	e8 12 04 00 00       	call   16151 <CF>
   15d3f:	83 c4 10             	add    $0x10,%esp
   15d42:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15d44:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15d47:	8d 50 ff             	lea    -0x1(%eax),%edx
   15d4a:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15d4d:	85 c0                	test   %eax,%eax
   15d4f:	0f 85 0f fd ff ff    	jne    15a64 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15d55:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d58:	8b 40 0c             	mov    0xc(%eax),%eax
   15d5b:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15d5e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d61:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15d64:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d67:	8b 50 0c             	mov    0xc(%eax),%edx
   15d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d6d:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15d70:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d73:	8b 40 28             	mov    0x28(%eax),%eax
   15d76:	83 ec 0c             	sub    $0xc,%esp
   15d79:	50                   	push   %eax
   15d7a:	e8 37 ac fe ff       	call   9b6 <free>
   15d7f:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15d82:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d85:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15d88:	89 50 28             	mov    %edx,0x28(%eax)
}
   15d8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15d8e:	c9                   	leave  
   15d8f:	c3                   	ret    

00015d90 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15d90:	55                   	push   %ebp
   15d91:	89 e5                	mov    %esp,%ebp
   15d93:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   15d96:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d99:	8b 40 0c             	mov    0xc(%eax),%eax
   15d9c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15d9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15da2:	8b 40 14             	mov    0x14(%eax),%eax
   15da5:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15da8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15dab:	01 c0                	add    %eax,%eax
   15dad:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15db0:	8b 45 0c             	mov    0xc(%ebp),%eax
   15db3:	8b 50 0c             	mov    0xc(%eax),%edx
   15db6:	8b 45 0c             	mov    0xc(%ebp),%eax
   15db9:	8b 40 10             	mov    0x10(%eax),%eax
   15dbc:	0f af c2             	imul   %edx,%eax
   15dbf:	01 c0                	add    %eax,%eax
   15dc1:	83 ec 0c             	sub    $0xc,%esp
   15dc4:	50                   	push   %eax
   15dc5:	e8 2e ad fe ff       	call   af8 <malloc>
   15dca:	83 c4 10             	add    $0x10,%esp
   15dcd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15dd0:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15dd4:	75 0e                	jne    15de4 <_UpsampleV+0x54>
   15dd6:	8b 45 08             	mov    0x8(%ebp),%eax
   15dd9:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15ddf:	e9 6b 03 00 00       	jmp    1614f <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15de4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15deb:	e9 1d 03 00 00       	jmp    1610d <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15df0:	8b 45 0c             	mov    0xc(%ebp),%eax
   15df3:	8b 50 28             	mov    0x28(%eax),%edx
   15df6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15df9:	01 d0                	add    %edx,%eax
   15dfb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15dfe:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15e01:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15e04:	01 d0                	add    %edx,%eax
   15e06:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e0c:	0f b6 00             	movzbl (%eax),%eax
   15e0f:	0f b6 c0             	movzbl %al,%eax
   15e12:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15e18:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15e1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e1e:	01 c8                	add    %ecx,%eax
   15e20:	0f b6 00             	movzbl (%eax),%eax
   15e23:	0f b6 c0             	movzbl %al,%eax
   15e26:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15e29:	01 d0                	add    %edx,%eax
   15e2b:	83 ec 0c             	sub    $0xc,%esp
   15e2e:	50                   	push   %eax
   15e2f:	e8 1d 03 00 00       	call   16151 <CF>
   15e34:	83 c4 10             	add    $0x10,%esp
   15e37:	89 c2                	mov    %eax,%edx
   15e39:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e3c:	88 10                	mov    %dl,(%eax)
   15e3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e41:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15e44:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e47:	0f b6 00             	movzbl (%eax),%eax
   15e4a:	0f b6 c0             	movzbl %al,%eax
   15e4d:	6b c8 68             	imul   $0x68,%eax,%ecx
   15e50:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15e53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e56:	01 d0                	add    %edx,%eax
   15e58:	0f b6 00             	movzbl (%eax),%eax
   15e5b:	0f b6 d0             	movzbl %al,%edx
   15e5e:	89 d0                	mov    %edx,%eax
   15e60:	01 c0                	add    %eax,%eax
   15e62:	01 d0                	add    %edx,%eax
   15e64:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15e6b:	01 d0                	add    %edx,%eax
   15e6d:	01 c1                	add    %eax,%ecx
   15e6f:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15e72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e75:	01 d0                	add    %edx,%eax
   15e77:	0f b6 00             	movzbl (%eax),%eax
   15e7a:	0f b6 d0             	movzbl %al,%edx
   15e7d:	89 d0                	mov    %edx,%eax
   15e7f:	01 c0                	add    %eax,%eax
   15e81:	01 d0                	add    %edx,%eax
   15e83:	f7 d8                	neg    %eax
   15e85:	01 c8                	add    %ecx,%eax
   15e87:	83 ec 0c             	sub    $0xc,%esp
   15e8a:	50                   	push   %eax
   15e8b:	e8 c1 02 00 00       	call   16151 <CF>
   15e90:	83 c4 10             	add    $0x10,%esp
   15e93:	89 c2                	mov    %eax,%edx
   15e95:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e98:	88 10                	mov    %dl,(%eax)
   15e9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e9d:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15ea0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ea3:	0f b6 00             	movzbl (%eax),%eax
   15ea6:	0f b6 c0             	movzbl %al,%eax
   15ea9:	c1 e0 02             	shl    $0x2,%eax
   15eac:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15eb3:	89 d1                	mov    %edx,%ecx
   15eb5:	29 c1                	sub    %eax,%ecx
   15eb7:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15eba:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ebd:	01 d0                	add    %edx,%eax
   15ebf:	0f b6 00             	movzbl (%eax),%eax
   15ec2:	0f b6 c0             	movzbl %al,%eax
   15ec5:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15ec8:	01 c1                	add    %eax,%ecx
   15eca:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ecd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ed0:	01 d0                	add    %edx,%eax
   15ed2:	0f b6 00             	movzbl (%eax),%eax
   15ed5:	0f b6 d0             	movzbl %al,%edx
   15ed8:	89 d0                	mov    %edx,%eax
   15eda:	c1 e0 03             	shl    $0x3,%eax
   15edd:	01 d0                	add    %edx,%eax
   15edf:	f7 d8                	neg    %eax
   15ee1:	01 c8                	add    %ecx,%eax
   15ee3:	83 ec 0c             	sub    $0xc,%esp
   15ee6:	50                   	push   %eax
   15ee7:	e8 65 02 00 00       	call   16151 <CF>
   15eec:	83 c4 10             	add    $0x10,%esp
   15eef:	89 c2                	mov    %eax,%edx
   15ef1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ef4:	88 10                	mov    %dl,(%eax)
   15ef6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15ef9:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15efc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15eff:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15f02:	8b 45 0c             	mov    0xc(%ebp),%eax
   15f05:	8b 40 10             	mov    0x10(%eax),%eax
   15f08:	83 e8 03             	sub    $0x3,%eax
   15f0b:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15f0e:	e9 e6 00 00 00       	jmp    15ff9 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15f13:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f16:	f7 d8                	neg    %eax
   15f18:	89 c2                	mov    %eax,%edx
   15f1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f1d:	01 d0                	add    %edx,%eax
   15f1f:	0f b6 00             	movzbl (%eax),%eax
   15f22:	0f b6 d0             	movzbl %al,%edx
   15f25:	89 d0                	mov    %edx,%eax
   15f27:	c1 e0 03             	shl    $0x3,%eax
   15f2a:	01 d0                	add    %edx,%eax
   15f2c:	f7 d8                	neg    %eax
   15f2e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15f31:	0f b6 12             	movzbl (%edx),%edx
   15f34:	0f b6 d2             	movzbl %dl,%edx
   15f37:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15f3a:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15f3d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15f40:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f43:	01 d0                	add    %edx,%eax
   15f45:	0f b6 00             	movzbl (%eax),%eax
   15f48:	0f b6 c0             	movzbl %al,%eax
   15f4b:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15f4e:	01 c1                	add    %eax,%ecx
   15f50:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15f53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f56:	01 d0                	add    %edx,%eax
   15f58:	0f b6 00             	movzbl (%eax),%eax
   15f5b:	0f b6 d0             	movzbl %al,%edx
   15f5e:	89 d0                	mov    %edx,%eax
   15f60:	01 c0                	add    %eax,%eax
   15f62:	01 d0                	add    %edx,%eax
   15f64:	f7 d8                	neg    %eax
   15f66:	01 c8                	add    %ecx,%eax
   15f68:	83 ec 0c             	sub    $0xc,%esp
   15f6b:	50                   	push   %eax
   15f6c:	e8 e0 01 00 00       	call   16151 <CF>
   15f71:	83 c4 10             	add    $0x10,%esp
   15f74:	89 c2                	mov    %eax,%edx
   15f76:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f79:	88 10                	mov    %dl,(%eax)
   15f7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15f7e:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15f81:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f84:	f7 d8                	neg    %eax
   15f86:	89 c2                	mov    %eax,%edx
   15f88:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f8b:	01 d0                	add    %edx,%eax
   15f8d:	0f b6 00             	movzbl (%eax),%eax
   15f90:	0f b6 d0             	movzbl %al,%edx
   15f93:	89 d0                	mov    %edx,%eax
   15f95:	01 c0                	add    %eax,%eax
   15f97:	01 d0                	add    %edx,%eax
   15f99:	f7 d8                	neg    %eax
   15f9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15f9e:	0f b6 12             	movzbl (%edx),%edx
   15fa1:	0f b6 d2             	movzbl %dl,%edx
   15fa4:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15fa7:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15faa:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15fad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fb0:	01 d0                	add    %edx,%eax
   15fb2:	0f b6 00             	movzbl (%eax),%eax
   15fb5:	0f b6 c0             	movzbl %al,%eax
   15fb8:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15fbb:	01 c1                	add    %eax,%ecx
   15fbd:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fc3:	01 d0                	add    %edx,%eax
   15fc5:	0f b6 00             	movzbl (%eax),%eax
   15fc8:	0f b6 d0             	movzbl %al,%edx
   15fcb:	89 d0                	mov    %edx,%eax
   15fcd:	c1 e0 03             	shl    $0x3,%eax
   15fd0:	01 d0                	add    %edx,%eax
   15fd2:	f7 d8                	neg    %eax
   15fd4:	01 c8                	add    %ecx,%eax
   15fd6:	83 ec 0c             	sub    $0xc,%esp
   15fd9:	50                   	push   %eax
   15fda:	e8 72 01 00 00       	call   16151 <CF>
   15fdf:	83 c4 10             	add    $0x10,%esp
   15fe2:	89 c2                	mov    %eax,%edx
   15fe4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15fe7:	88 10                	mov    %dl,(%eax)
   15fe9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15fec:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15fef:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ff2:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15ff5:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15ff9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15ffd:	0f 85 10 ff ff ff    	jne    15f13 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   16003:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16006:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   16009:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1600c:	0f b6 00             	movzbl (%eax),%eax
   1600f:	0f b6 c0             	movzbl %al,%eax
   16012:	c1 e0 02             	shl    $0x2,%eax
   16015:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1601c:	29 c2                	sub    %eax,%edx
   1601e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16021:	f7 d8                	neg    %eax
   16023:	89 c1                	mov    %eax,%ecx
   16025:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16028:	01 c8                	add    %ecx,%eax
   1602a:	0f b6 00             	movzbl (%eax),%eax
   1602d:	0f b6 c0             	movzbl %al,%eax
   16030:	6b c0 6d             	imul   $0x6d,%eax,%eax
   16033:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   16036:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16039:	f7 d8                	neg    %eax
   1603b:	89 c2                	mov    %eax,%edx
   1603d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16040:	01 d0                	add    %edx,%eax
   16042:	0f b6 00             	movzbl (%eax),%eax
   16045:	0f b6 d0             	movzbl %al,%edx
   16048:	89 d0                	mov    %edx,%eax
   1604a:	c1 e0 03             	shl    $0x3,%eax
   1604d:	01 d0                	add    %edx,%eax
   1604f:	f7 d8                	neg    %eax
   16051:	01 c8                	add    %ecx,%eax
   16053:	83 ec 0c             	sub    $0xc,%esp
   16056:	50                   	push   %eax
   16057:	e8 f5 00 00 00       	call   16151 <CF>
   1605c:	83 c4 10             	add    $0x10,%esp
   1605f:	89 c2                	mov    %eax,%edx
   16061:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16064:	88 10                	mov    %dl,(%eax)
   16066:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16069:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   1606c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1606f:	0f b6 00             	movzbl (%eax),%eax
   16072:	0f b6 c0             	movzbl %al,%eax
   16075:	6b c8 68             	imul   $0x68,%eax,%ecx
   16078:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1607b:	f7 d8                	neg    %eax
   1607d:	89 c2                	mov    %eax,%edx
   1607f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16082:	01 d0                	add    %edx,%eax
   16084:	0f b6 00             	movzbl (%eax),%eax
   16087:	0f b6 d0             	movzbl %al,%edx
   1608a:	89 d0                	mov    %edx,%eax
   1608c:	01 c0                	add    %eax,%eax
   1608e:	01 d0                	add    %edx,%eax
   16090:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   16097:	01 d0                	add    %edx,%eax
   16099:	01 c1                	add    %eax,%ecx
   1609b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1609e:	f7 d8                	neg    %eax
   160a0:	89 c2                	mov    %eax,%edx
   160a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   160a5:	01 d0                	add    %edx,%eax
   160a7:	0f b6 00             	movzbl (%eax),%eax
   160aa:	0f b6 d0             	movzbl %al,%edx
   160ad:	89 d0                	mov    %edx,%eax
   160af:	01 c0                	add    %eax,%eax
   160b1:	01 d0                	add    %edx,%eax
   160b3:	f7 d8                	neg    %eax
   160b5:	01 c8                	add    %ecx,%eax
   160b7:	83 ec 0c             	sub    $0xc,%esp
   160ba:	50                   	push   %eax
   160bb:	e8 91 00 00 00       	call   16151 <CF>
   160c0:	83 c4 10             	add    $0x10,%esp
   160c3:	89 c2                	mov    %eax,%edx
   160c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   160c8:	88 10                	mov    %dl,(%eax)
   160ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   160cd:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   160d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   160d3:	0f b6 00             	movzbl (%eax),%eax
   160d6:	0f b6 c0             	movzbl %al,%eax
   160d9:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   160df:	8b 45 e0             	mov    -0x20(%ebp),%eax
   160e2:	f7 d8                	neg    %eax
   160e4:	89 c1                	mov    %eax,%ecx
   160e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   160e9:	01 c8                	add    %ecx,%eax
   160eb:	0f b6 00             	movzbl (%eax),%eax
   160ee:	0f b6 c0             	movzbl %al,%eax
   160f1:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   160f4:	01 d0                	add    %edx,%eax
   160f6:	83 ec 0c             	sub    $0xc,%esp
   160f9:	50                   	push   %eax
   160fa:	e8 52 00 00 00       	call   16151 <CF>
   160ff:	83 c4 10             	add    $0x10,%esp
   16102:	89 c2                	mov    %eax,%edx
   16104:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16107:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   16109:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1610d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16110:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16113:	0f 8c d7 fc ff ff    	jl     15df0 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   16119:	8b 45 0c             	mov    0xc(%ebp),%eax
   1611c:	8b 40 10             	mov    0x10(%eax),%eax
   1611f:	8d 14 00             	lea    (%eax,%eax,1),%edx
   16122:	8b 45 0c             	mov    0xc(%ebp),%eax
   16125:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   16128:	8b 45 0c             	mov    0xc(%ebp),%eax
   1612b:	8b 50 0c             	mov    0xc(%eax),%edx
   1612e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16131:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16134:	8b 45 0c             	mov    0xc(%ebp),%eax
   16137:	8b 40 28             	mov    0x28(%eax),%eax
   1613a:	83 ec 0c             	sub    $0xc,%esp
   1613d:	50                   	push   %eax
   1613e:	e8 73 a8 fe ff       	call   9b6 <free>
   16143:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   16146:	8b 45 0c             	mov    0xc(%ebp),%eax
   16149:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1614c:	89 50 28             	mov    %edx,0x28(%eax)
}
   1614f:	c9                   	leave  
   16150:	c3                   	ret    

00016151 <CF>:

uchar CF(const int x){
   16151:	55                   	push   %ebp
   16152:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   16154:	8b 45 08             	mov    0x8(%ebp),%eax
   16157:	83 c0 40             	add    $0x40,%eax
   1615a:	c1 f8 07             	sar    $0x7,%eax
   1615d:	50                   	push   %eax
   1615e:	e8 e9 dd ff ff       	call   13f4c <_Clip>
   16163:	83 c4 04             	add    $0x4,%esp
}
   16166:	c9                   	leave  
   16167:	c3                   	ret    
