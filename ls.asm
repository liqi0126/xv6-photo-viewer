
_ls：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <fmtname>:
#include "user.h"
#include "fs.h"

char*
fmtname(char *path)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	53                   	push   %ebx
       4:	83 ec 14             	sub    $0x14,%esp
  static char buf[DIRSIZ+1];
  char *p;
  
  // Find first character after last slash.
  for(p=path+strlen(path); p >= path && *p != '/'; p--)
       7:	83 ec 0c             	sub    $0xc,%esp
       a:	ff 75 08             	pushl  0x8(%ebp)
       d:	e8 c9 03 00 00       	call   3db <strlen>
      12:	83 c4 10             	add    $0x10,%esp
      15:	89 c2                	mov    %eax,%edx
      17:	8b 45 08             	mov    0x8(%ebp),%eax
      1a:	01 d0                	add    %edx,%eax
      1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      1f:	eb 04                	jmp    25 <fmtname+0x25>
      21:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
      25:	8b 45 f4             	mov    -0xc(%ebp),%eax
      28:	3b 45 08             	cmp    0x8(%ebp),%eax
      2b:	72 0a                	jb     37 <fmtname+0x37>
      2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
      30:	0f b6 00             	movzbl (%eax),%eax
      33:	3c 2f                	cmp    $0x2f,%al
      35:	75 ea                	jne    21 <fmtname+0x21>
    ;
  p++;
      37:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  
  // Return blank-padded name.
  if(strlen(p) >= DIRSIZ)
      3b:	83 ec 0c             	sub    $0xc,%esp
      3e:	ff 75 f4             	pushl  -0xc(%ebp)
      41:	e8 95 03 00 00       	call   3db <strlen>
      46:	83 c4 10             	add    $0x10,%esp
      49:	83 f8 1d             	cmp    $0x1d,%eax
      4c:	76 05                	jbe    53 <fmtname+0x53>
    return p;
      4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
      51:	eb 60                	jmp    b3 <fmtname+0xb3>
  memmove(buf, p, strlen(p));
      53:	83 ec 0c             	sub    $0xc,%esp
      56:	ff 75 f4             	pushl  -0xc(%ebp)
      59:	e8 7d 03 00 00       	call   3db <strlen>
      5e:	83 c4 10             	add    $0x10,%esp
      61:	83 ec 04             	sub    $0x4,%esp
      64:	50                   	push   %eax
      65:	ff 75 f4             	pushl  -0xc(%ebp)
      68:	68 60 e8 01 00       	push   $0x1e860
      6d:	e8 e6 04 00 00       	call   558 <memmove>
      72:	83 c4 10             	add    $0x10,%esp
  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
      75:	83 ec 0c             	sub    $0xc,%esp
      78:	ff 75 f4             	pushl  -0xc(%ebp)
      7b:	e8 5b 03 00 00       	call   3db <strlen>
      80:	83 c4 10             	add    $0x10,%esp
      83:	ba 1e 00 00 00       	mov    $0x1e,%edx
      88:	89 d3                	mov    %edx,%ebx
      8a:	29 c3                	sub    %eax,%ebx
      8c:	83 ec 0c             	sub    $0xc,%esp
      8f:	ff 75 f4             	pushl  -0xc(%ebp)
      92:	e8 44 03 00 00       	call   3db <strlen>
      97:	83 c4 10             	add    $0x10,%esp
      9a:	05 60 e8 01 00       	add    $0x1e860,%eax
      9f:	83 ec 04             	sub    $0x4,%esp
      a2:	53                   	push   %ebx
      a3:	6a 20                	push   $0x20
      a5:	50                   	push   %eax
      a6:	e8 57 03 00 00       	call   402 <memset>
      ab:	83 c4 10             	add    $0x10,%esp
  return buf;
      ae:	b8 60 e8 01 00       	mov    $0x1e860,%eax
}
      b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
      b6:	c9                   	leave  
      b7:	c3                   	ret    

000000b8 <ls>:

void
ls(char *path)
{
      b8:	55                   	push   %ebp
      b9:	89 e5                	mov    %esp,%ebp
      bb:	57                   	push   %edi
      bc:	56                   	push   %esi
      bd:	53                   	push   %ebx
      be:	81 ec 4c 02 00 00    	sub    $0x24c,%esp
  char buf[512], *p;
  int fd;
  struct dirent de;
  struct stat st;
  
  if((fd = open(path, 0)) < 0){
      c4:	83 ec 08             	sub    $0x8,%esp
      c7:	6a 00                	push   $0x0
      c9:	ff 75 08             	pushl  0x8(%ebp)
      cc:	e8 0c 05 00 00       	call   5dd <open>
      d1:	83 c4 10             	add    $0x10,%esp
      d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      d7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
      db:	79 1a                	jns    f7 <ls+0x3f>
    printf(2, "ls: cannot open %s\n", path);
      dd:	83 ec 04             	sub    $0x4,%esp
      e0:	ff 75 08             	pushl  0x8(%ebp)
      e3:	68 a0 60 01 00       	push   $0x160a0
      e8:	6a 02                	push   $0x2
      ea:	e8 55 06 00 00       	call   744 <printf>
      ef:	83 c4 10             	add    $0x10,%esp
    return;
      f2:	e9 e3 01 00 00       	jmp    2da <ls+0x222>
  }
  
  if(fstat(fd, &st) < 0){
      f7:	83 ec 08             	sub    $0x8,%esp
      fa:	8d 85 ac fd ff ff    	lea    -0x254(%ebp),%eax
     100:	50                   	push   %eax
     101:	ff 75 e4             	pushl  -0x1c(%ebp)
     104:	e8 ec 04 00 00       	call   5f5 <fstat>
     109:	83 c4 10             	add    $0x10,%esp
     10c:	85 c0                	test   %eax,%eax
     10e:	79 28                	jns    138 <ls+0x80>
    printf(2, "ls: cannot stat %s\n", path);
     110:	83 ec 04             	sub    $0x4,%esp
     113:	ff 75 08             	pushl  0x8(%ebp)
     116:	68 b4 60 01 00       	push   $0x160b4
     11b:	6a 02                	push   $0x2
     11d:	e8 22 06 00 00       	call   744 <printf>
     122:	83 c4 10             	add    $0x10,%esp
    close(fd);
     125:	83 ec 0c             	sub    $0xc,%esp
     128:	ff 75 e4             	pushl  -0x1c(%ebp)
     12b:	e8 95 04 00 00       	call   5c5 <close>
     130:	83 c4 10             	add    $0x10,%esp
    return;
     133:	e9 a2 01 00 00       	jmp    2da <ls+0x222>
  }
  
  switch(st.type){
     138:	0f b7 85 ac fd ff ff 	movzwl -0x254(%ebp),%eax
     13f:	98                   	cwtl   
     140:	83 f8 01             	cmp    $0x1,%eax
     143:	74 48                	je     18d <ls+0xd5>
     145:	83 f8 02             	cmp    $0x2,%eax
     148:	0f 85 7e 01 00 00    	jne    2cc <ls+0x214>
  case T_FILE:
    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
     14e:	8b bd bc fd ff ff    	mov    -0x244(%ebp),%edi
     154:	8b b5 b4 fd ff ff    	mov    -0x24c(%ebp),%esi
     15a:	0f b7 85 ac fd ff ff 	movzwl -0x254(%ebp),%eax
     161:	0f bf d8             	movswl %ax,%ebx
     164:	83 ec 0c             	sub    $0xc,%esp
     167:	ff 75 08             	pushl  0x8(%ebp)
     16a:	e8 91 fe ff ff       	call   0 <fmtname>
     16f:	83 c4 10             	add    $0x10,%esp
     172:	83 ec 08             	sub    $0x8,%esp
     175:	57                   	push   %edi
     176:	56                   	push   %esi
     177:	53                   	push   %ebx
     178:	50                   	push   %eax
     179:	68 c8 60 01 00       	push   $0x160c8
     17e:	6a 01                	push   $0x1
     180:	e8 bf 05 00 00       	call   744 <printf>
     185:	83 c4 20             	add    $0x20,%esp
    break;
     188:	e9 3f 01 00 00       	jmp    2cc <ls+0x214>
  
  case T_DIR:
    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
     18d:	83 ec 0c             	sub    $0xc,%esp
     190:	ff 75 08             	pushl  0x8(%ebp)
     193:	e8 43 02 00 00       	call   3db <strlen>
     198:	83 c4 10             	add    $0x10,%esp
     19b:	83 c0 20             	add    $0x20,%eax
     19e:	3d 00 02 00 00       	cmp    $0x200,%eax
     1a3:	76 17                	jbe    1bc <ls+0x104>
      printf(1, "ls: path too long\n");
     1a5:	83 ec 08             	sub    $0x8,%esp
     1a8:	68 d5 60 01 00       	push   $0x160d5
     1ad:	6a 01                	push   $0x1
     1af:	e8 90 05 00 00       	call   744 <printf>
     1b4:	83 c4 10             	add    $0x10,%esp
      break;
     1b7:	e9 10 01 00 00       	jmp    2cc <ls+0x214>
    }
    strcpy(buf, path);
     1bc:	83 ec 08             	sub    $0x8,%esp
     1bf:	ff 75 08             	pushl  0x8(%ebp)
     1c2:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     1c8:	50                   	push   %eax
     1c9:	e8 9e 01 00 00       	call   36c <strcpy>
     1ce:	83 c4 10             	add    $0x10,%esp
    p = buf+strlen(buf);
     1d1:	83 ec 0c             	sub    $0xc,%esp
     1d4:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     1da:	50                   	push   %eax
     1db:	e8 fb 01 00 00       	call   3db <strlen>
     1e0:	83 c4 10             	add    $0x10,%esp
     1e3:	89 c2                	mov    %eax,%edx
     1e5:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     1eb:	01 d0                	add    %edx,%eax
     1ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
    *p++ = '/';
     1f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
     1f3:	8d 50 01             	lea    0x1(%eax),%edx
     1f6:	89 55 e0             	mov    %edx,-0x20(%ebp)
     1f9:	c6 00 2f             	movb   $0x2f,(%eax)
    while(read(fd, &de, sizeof(de)) == sizeof(de)){
     1fc:	e9 aa 00 00 00       	jmp    2ab <ls+0x1f3>
      if(de.inum == 0)
     201:	0f b7 85 c0 fd ff ff 	movzwl -0x240(%ebp),%eax
     208:	66 85 c0             	test   %ax,%ax
     20b:	75 05                	jne    212 <ls+0x15a>
        continue;
     20d:	e9 99 00 00 00       	jmp    2ab <ls+0x1f3>
      memmove(p, de.name, DIRSIZ);
     212:	83 ec 04             	sub    $0x4,%esp
     215:	6a 1e                	push   $0x1e
     217:	8d 85 c0 fd ff ff    	lea    -0x240(%ebp),%eax
     21d:	83 c0 02             	add    $0x2,%eax
     220:	50                   	push   %eax
     221:	ff 75 e0             	pushl  -0x20(%ebp)
     224:	e8 2f 03 00 00       	call   558 <memmove>
     229:	83 c4 10             	add    $0x10,%esp
      p[DIRSIZ] = 0;
     22c:	8b 45 e0             	mov    -0x20(%ebp),%eax
     22f:	83 c0 1e             	add    $0x1e,%eax
     232:	c6 00 00             	movb   $0x0,(%eax)
      if(stat(buf, &st) < 0){
     235:	83 ec 08             	sub    $0x8,%esp
     238:	8d 85 ac fd ff ff    	lea    -0x254(%ebp),%eax
     23e:	50                   	push   %eax
     23f:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     245:	50                   	push   %eax
     246:	e8 73 02 00 00       	call   4be <stat>
     24b:	83 c4 10             	add    $0x10,%esp
     24e:	85 c0                	test   %eax,%eax
     250:	79 1b                	jns    26d <ls+0x1b5>
        printf(1, "ls: cannot stat %s\n", buf);
     252:	83 ec 04             	sub    $0x4,%esp
     255:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     25b:	50                   	push   %eax
     25c:	68 b4 60 01 00       	push   $0x160b4
     261:	6a 01                	push   $0x1
     263:	e8 dc 04 00 00       	call   744 <printf>
     268:	83 c4 10             	add    $0x10,%esp
        continue;
     26b:	eb 3e                	jmp    2ab <ls+0x1f3>
      }
      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
     26d:	8b bd bc fd ff ff    	mov    -0x244(%ebp),%edi
     273:	8b b5 b4 fd ff ff    	mov    -0x24c(%ebp),%esi
     279:	0f b7 85 ac fd ff ff 	movzwl -0x254(%ebp),%eax
     280:	0f bf d8             	movswl %ax,%ebx
     283:	83 ec 0c             	sub    $0xc,%esp
     286:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
     28c:	50                   	push   %eax
     28d:	e8 6e fd ff ff       	call   0 <fmtname>
     292:	83 c4 10             	add    $0x10,%esp
     295:	83 ec 08             	sub    $0x8,%esp
     298:	57                   	push   %edi
     299:	56                   	push   %esi
     29a:	53                   	push   %ebx
     29b:	50                   	push   %eax
     29c:	68 c8 60 01 00       	push   $0x160c8
     2a1:	6a 01                	push   $0x1
     2a3:	e8 9c 04 00 00       	call   744 <printf>
     2a8:	83 c4 20             	add    $0x20,%esp
      break;
    }
    strcpy(buf, path);
    p = buf+strlen(buf);
    *p++ = '/';
    while(read(fd, &de, sizeof(de)) == sizeof(de)){
     2ab:	83 ec 04             	sub    $0x4,%esp
     2ae:	6a 20                	push   $0x20
     2b0:	8d 85 c0 fd ff ff    	lea    -0x240(%ebp),%eax
     2b6:	50                   	push   %eax
     2b7:	ff 75 e4             	pushl  -0x1c(%ebp)
     2ba:	e8 f6 02 00 00       	call   5b5 <read>
     2bf:	83 c4 10             	add    $0x10,%esp
     2c2:	83 f8 20             	cmp    $0x20,%eax
     2c5:	0f 84 36 ff ff ff    	je     201 <ls+0x149>
        printf(1, "ls: cannot stat %s\n", buf);
        continue;
      }
      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
    }
    break;
     2cb:	90                   	nop
  }
  close(fd);
     2cc:	83 ec 0c             	sub    $0xc,%esp
     2cf:	ff 75 e4             	pushl  -0x1c(%ebp)
     2d2:	e8 ee 02 00 00       	call   5c5 <close>
     2d7:	83 c4 10             	add    $0x10,%esp
}
     2da:	8d 65 f4             	lea    -0xc(%ebp),%esp
     2dd:	5b                   	pop    %ebx
     2de:	5e                   	pop    %esi
     2df:	5f                   	pop    %edi
     2e0:	5d                   	pop    %ebp
     2e1:	c3                   	ret    

000002e2 <main>:

int
main(int argc, char *argv[])
{
     2e2:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     2e6:	83 e4 f0             	and    $0xfffffff0,%esp
     2e9:	ff 71 fc             	pushl  -0x4(%ecx)
     2ec:	55                   	push   %ebp
     2ed:	89 e5                	mov    %esp,%ebp
     2ef:	53                   	push   %ebx
     2f0:	51                   	push   %ecx
     2f1:	83 ec 10             	sub    $0x10,%esp
     2f4:	89 cb                	mov    %ecx,%ebx
  int i;

  if(argc < 2){
     2f6:	83 3b 01             	cmpl   $0x1,(%ebx)
     2f9:	7f 15                	jg     310 <main+0x2e>
    ls(".");
     2fb:	83 ec 0c             	sub    $0xc,%esp
     2fe:	68 e8 60 01 00       	push   $0x160e8
     303:	e8 b0 fd ff ff       	call   b8 <ls>
     308:	83 c4 10             	add    $0x10,%esp
    exit();
     30b:	e8 8d 02 00 00       	call   59d <exit>
  }
  for(i=1; i<argc; i++)
     310:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
     317:	eb 21                	jmp    33a <main+0x58>
    ls(argv[i]);
     319:	8b 45 f4             	mov    -0xc(%ebp),%eax
     31c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
     323:	8b 43 04             	mov    0x4(%ebx),%eax
     326:	01 d0                	add    %edx,%eax
     328:	8b 00                	mov    (%eax),%eax
     32a:	83 ec 0c             	sub    $0xc,%esp
     32d:	50                   	push   %eax
     32e:	e8 85 fd ff ff       	call   b8 <ls>
     333:	83 c4 10             	add    $0x10,%esp

  if(argc < 2){
    ls(".");
    exit();
  }
  for(i=1; i<argc; i++)
     336:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     33a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     33d:	3b 03                	cmp    (%ebx),%eax
     33f:	7c d8                	jl     319 <main+0x37>
    ls(argv[i]);
  exit();
     341:	e8 57 02 00 00       	call   59d <exit>

00000346 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     346:	55                   	push   %ebp
     347:	89 e5                	mov    %esp,%ebp
     349:	57                   	push   %edi
     34a:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     34b:	8b 4d 08             	mov    0x8(%ebp),%ecx
     34e:	8b 55 10             	mov    0x10(%ebp),%edx
     351:	8b 45 0c             	mov    0xc(%ebp),%eax
     354:	89 cb                	mov    %ecx,%ebx
     356:	89 df                	mov    %ebx,%edi
     358:	89 d1                	mov    %edx,%ecx
     35a:	fc                   	cld    
     35b:	f3 aa                	rep stos %al,%es:(%edi)
     35d:	89 ca                	mov    %ecx,%edx
     35f:	89 fb                	mov    %edi,%ebx
     361:	89 5d 08             	mov    %ebx,0x8(%ebp)
     364:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     367:	90                   	nop
     368:	5b                   	pop    %ebx
     369:	5f                   	pop    %edi
     36a:	5d                   	pop    %ebp
     36b:	c3                   	ret    

0000036c <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     36c:	55                   	push   %ebp
     36d:	89 e5                	mov    %esp,%ebp
     36f:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     372:	8b 45 08             	mov    0x8(%ebp),%eax
     375:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     378:	90                   	nop
     379:	8b 45 08             	mov    0x8(%ebp),%eax
     37c:	8d 50 01             	lea    0x1(%eax),%edx
     37f:	89 55 08             	mov    %edx,0x8(%ebp)
     382:	8b 55 0c             	mov    0xc(%ebp),%edx
     385:	8d 4a 01             	lea    0x1(%edx),%ecx
     388:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     38b:	0f b6 12             	movzbl (%edx),%edx
     38e:	88 10                	mov    %dl,(%eax)
     390:	0f b6 00             	movzbl (%eax),%eax
     393:	84 c0                	test   %al,%al
     395:	75 e2                	jne    379 <strcpy+0xd>
    ;
  return os;
     397:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     39a:	c9                   	leave  
     39b:	c3                   	ret    

0000039c <strcmp>:

int
strcmp(const char *p, const char *q)
{
     39c:	55                   	push   %ebp
     39d:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     39f:	eb 08                	jmp    3a9 <strcmp+0xd>
    p++, q++;
     3a1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     3a5:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     3a9:	8b 45 08             	mov    0x8(%ebp),%eax
     3ac:	0f b6 00             	movzbl (%eax),%eax
     3af:	84 c0                	test   %al,%al
     3b1:	74 10                	je     3c3 <strcmp+0x27>
     3b3:	8b 45 08             	mov    0x8(%ebp),%eax
     3b6:	0f b6 10             	movzbl (%eax),%edx
     3b9:	8b 45 0c             	mov    0xc(%ebp),%eax
     3bc:	0f b6 00             	movzbl (%eax),%eax
     3bf:	38 c2                	cmp    %al,%dl
     3c1:	74 de                	je     3a1 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     3c3:	8b 45 08             	mov    0x8(%ebp),%eax
     3c6:	0f b6 00             	movzbl (%eax),%eax
     3c9:	0f b6 d0             	movzbl %al,%edx
     3cc:	8b 45 0c             	mov    0xc(%ebp),%eax
     3cf:	0f b6 00             	movzbl (%eax),%eax
     3d2:	0f b6 c0             	movzbl %al,%eax
     3d5:	29 c2                	sub    %eax,%edx
     3d7:	89 d0                	mov    %edx,%eax
}
     3d9:	5d                   	pop    %ebp
     3da:	c3                   	ret    

000003db <strlen>:

uint
strlen(char *s)
{
     3db:	55                   	push   %ebp
     3dc:	89 e5                	mov    %esp,%ebp
     3de:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     3e1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     3e8:	eb 04                	jmp    3ee <strlen+0x13>
     3ea:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     3ee:	8b 55 fc             	mov    -0x4(%ebp),%edx
     3f1:	8b 45 08             	mov    0x8(%ebp),%eax
     3f4:	01 d0                	add    %edx,%eax
     3f6:	0f b6 00             	movzbl (%eax),%eax
     3f9:	84 c0                	test   %al,%al
     3fb:	75 ed                	jne    3ea <strlen+0xf>
    ;
  return n;
     3fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     400:	c9                   	leave  
     401:	c3                   	ret    

00000402 <memset>:

void*
memset(void *dst, int c, uint n)
{
     402:	55                   	push   %ebp
     403:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     405:	8b 45 10             	mov    0x10(%ebp),%eax
     408:	50                   	push   %eax
     409:	ff 75 0c             	pushl  0xc(%ebp)
     40c:	ff 75 08             	pushl  0x8(%ebp)
     40f:	e8 32 ff ff ff       	call   346 <stosb>
     414:	83 c4 0c             	add    $0xc,%esp
  return dst;
     417:	8b 45 08             	mov    0x8(%ebp),%eax
}
     41a:	c9                   	leave  
     41b:	c3                   	ret    

0000041c <strchr>:

char*
strchr(const char *s, char c)
{
     41c:	55                   	push   %ebp
     41d:	89 e5                	mov    %esp,%ebp
     41f:	83 ec 04             	sub    $0x4,%esp
     422:	8b 45 0c             	mov    0xc(%ebp),%eax
     425:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     428:	eb 14                	jmp    43e <strchr+0x22>
    if(*s == c)
     42a:	8b 45 08             	mov    0x8(%ebp),%eax
     42d:	0f b6 00             	movzbl (%eax),%eax
     430:	3a 45 fc             	cmp    -0x4(%ebp),%al
     433:	75 05                	jne    43a <strchr+0x1e>
      return (char*)s;
     435:	8b 45 08             	mov    0x8(%ebp),%eax
     438:	eb 13                	jmp    44d <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     43a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     43e:	8b 45 08             	mov    0x8(%ebp),%eax
     441:	0f b6 00             	movzbl (%eax),%eax
     444:	84 c0                	test   %al,%al
     446:	75 e2                	jne    42a <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     448:	b8 00 00 00 00       	mov    $0x0,%eax
}
     44d:	c9                   	leave  
     44e:	c3                   	ret    

0000044f <gets>:

char*
gets(char *buf, int max)
{
     44f:	55                   	push   %ebp
     450:	89 e5                	mov    %esp,%ebp
     452:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     455:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     45c:	eb 42                	jmp    4a0 <gets+0x51>
    cc = read(0, &c, 1);
     45e:	83 ec 04             	sub    $0x4,%esp
     461:	6a 01                	push   $0x1
     463:	8d 45 ef             	lea    -0x11(%ebp),%eax
     466:	50                   	push   %eax
     467:	6a 00                	push   $0x0
     469:	e8 47 01 00 00       	call   5b5 <read>
     46e:	83 c4 10             	add    $0x10,%esp
     471:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     474:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     478:	7e 33                	jle    4ad <gets+0x5e>
      break;
    buf[i++] = c;
     47a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     47d:	8d 50 01             	lea    0x1(%eax),%edx
     480:	89 55 f4             	mov    %edx,-0xc(%ebp)
     483:	89 c2                	mov    %eax,%edx
     485:	8b 45 08             	mov    0x8(%ebp),%eax
     488:	01 c2                	add    %eax,%edx
     48a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     48e:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     490:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     494:	3c 0a                	cmp    $0xa,%al
     496:	74 16                	je     4ae <gets+0x5f>
     498:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     49c:	3c 0d                	cmp    $0xd,%al
     49e:	74 0e                	je     4ae <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     4a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     4a3:	83 c0 01             	add    $0x1,%eax
     4a6:	3b 45 0c             	cmp    0xc(%ebp),%eax
     4a9:	7c b3                	jl     45e <gets+0xf>
     4ab:	eb 01                	jmp    4ae <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     4ad:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     4ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
     4b1:	8b 45 08             	mov    0x8(%ebp),%eax
     4b4:	01 d0                	add    %edx,%eax
     4b6:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     4b9:	8b 45 08             	mov    0x8(%ebp),%eax
}
     4bc:	c9                   	leave  
     4bd:	c3                   	ret    

000004be <stat>:

int
stat(char *n, struct stat *st)
{
     4be:	55                   	push   %ebp
     4bf:	89 e5                	mov    %esp,%ebp
     4c1:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     4c4:	83 ec 08             	sub    $0x8,%esp
     4c7:	6a 00                	push   $0x0
     4c9:	ff 75 08             	pushl  0x8(%ebp)
     4cc:	e8 0c 01 00 00       	call   5dd <open>
     4d1:	83 c4 10             	add    $0x10,%esp
     4d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     4d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     4db:	79 07                	jns    4e4 <stat+0x26>
    return -1;
     4dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     4e2:	eb 25                	jmp    509 <stat+0x4b>
  r = fstat(fd, st);
     4e4:	83 ec 08             	sub    $0x8,%esp
     4e7:	ff 75 0c             	pushl  0xc(%ebp)
     4ea:	ff 75 f4             	pushl  -0xc(%ebp)
     4ed:	e8 03 01 00 00       	call   5f5 <fstat>
     4f2:	83 c4 10             	add    $0x10,%esp
     4f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     4f8:	83 ec 0c             	sub    $0xc,%esp
     4fb:	ff 75 f4             	pushl  -0xc(%ebp)
     4fe:	e8 c2 00 00 00       	call   5c5 <close>
     503:	83 c4 10             	add    $0x10,%esp
  return r;
     506:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     509:	c9                   	leave  
     50a:	c3                   	ret    

0000050b <atoi>:

int
atoi(const char *s)
{
     50b:	55                   	push   %ebp
     50c:	89 e5                	mov    %esp,%ebp
     50e:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     511:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     518:	eb 25                	jmp    53f <atoi+0x34>
    n = n*10 + *s++ - '0';
     51a:	8b 55 fc             	mov    -0x4(%ebp),%edx
     51d:	89 d0                	mov    %edx,%eax
     51f:	c1 e0 02             	shl    $0x2,%eax
     522:	01 d0                	add    %edx,%eax
     524:	01 c0                	add    %eax,%eax
     526:	89 c1                	mov    %eax,%ecx
     528:	8b 45 08             	mov    0x8(%ebp),%eax
     52b:	8d 50 01             	lea    0x1(%eax),%edx
     52e:	89 55 08             	mov    %edx,0x8(%ebp)
     531:	0f b6 00             	movzbl (%eax),%eax
     534:	0f be c0             	movsbl %al,%eax
     537:	01 c8                	add    %ecx,%eax
     539:	83 e8 30             	sub    $0x30,%eax
     53c:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     53f:	8b 45 08             	mov    0x8(%ebp),%eax
     542:	0f b6 00             	movzbl (%eax),%eax
     545:	3c 2f                	cmp    $0x2f,%al
     547:	7e 0a                	jle    553 <atoi+0x48>
     549:	8b 45 08             	mov    0x8(%ebp),%eax
     54c:	0f b6 00             	movzbl (%eax),%eax
     54f:	3c 39                	cmp    $0x39,%al
     551:	7e c7                	jle    51a <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     553:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     556:	c9                   	leave  
     557:	c3                   	ret    

00000558 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     558:	55                   	push   %ebp
     559:	89 e5                	mov    %esp,%ebp
     55b:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     55e:	8b 45 08             	mov    0x8(%ebp),%eax
     561:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     564:	8b 45 0c             	mov    0xc(%ebp),%eax
     567:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     56a:	eb 17                	jmp    583 <memmove+0x2b>
    *dst++ = *src++;
     56c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     56f:	8d 50 01             	lea    0x1(%eax),%edx
     572:	89 55 fc             	mov    %edx,-0x4(%ebp)
     575:	8b 55 f8             	mov    -0x8(%ebp),%edx
     578:	8d 4a 01             	lea    0x1(%edx),%ecx
     57b:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     57e:	0f b6 12             	movzbl (%edx),%edx
     581:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     583:	8b 45 10             	mov    0x10(%ebp),%eax
     586:	8d 50 ff             	lea    -0x1(%eax),%edx
     589:	89 55 10             	mov    %edx,0x10(%ebp)
     58c:	85 c0                	test   %eax,%eax
     58e:	7f dc                	jg     56c <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     590:	8b 45 08             	mov    0x8(%ebp),%eax
}
     593:	c9                   	leave  
     594:	c3                   	ret    

00000595 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     595:	b8 01 00 00 00       	mov    $0x1,%eax
     59a:	cd 40                	int    $0x40
     59c:	c3                   	ret    

0000059d <exit>:
SYSCALL(exit)
     59d:	b8 02 00 00 00       	mov    $0x2,%eax
     5a2:	cd 40                	int    $0x40
     5a4:	c3                   	ret    

000005a5 <wait>:
SYSCALL(wait)
     5a5:	b8 03 00 00 00       	mov    $0x3,%eax
     5aa:	cd 40                	int    $0x40
     5ac:	c3                   	ret    

000005ad <pipe>:
SYSCALL(pipe)
     5ad:	b8 04 00 00 00       	mov    $0x4,%eax
     5b2:	cd 40                	int    $0x40
     5b4:	c3                   	ret    

000005b5 <read>:
SYSCALL(read)
     5b5:	b8 05 00 00 00       	mov    $0x5,%eax
     5ba:	cd 40                	int    $0x40
     5bc:	c3                   	ret    

000005bd <write>:
SYSCALL(write)
     5bd:	b8 10 00 00 00       	mov    $0x10,%eax
     5c2:	cd 40                	int    $0x40
     5c4:	c3                   	ret    

000005c5 <close>:
SYSCALL(close)
     5c5:	b8 15 00 00 00       	mov    $0x15,%eax
     5ca:	cd 40                	int    $0x40
     5cc:	c3                   	ret    

000005cd <kill>:
SYSCALL(kill)
     5cd:	b8 06 00 00 00       	mov    $0x6,%eax
     5d2:	cd 40                	int    $0x40
     5d4:	c3                   	ret    

000005d5 <exec>:
SYSCALL(exec)
     5d5:	b8 07 00 00 00       	mov    $0x7,%eax
     5da:	cd 40                	int    $0x40
     5dc:	c3                   	ret    

000005dd <open>:
SYSCALL(open)
     5dd:	b8 0f 00 00 00       	mov    $0xf,%eax
     5e2:	cd 40                	int    $0x40
     5e4:	c3                   	ret    

000005e5 <mknod>:
SYSCALL(mknod)
     5e5:	b8 11 00 00 00       	mov    $0x11,%eax
     5ea:	cd 40                	int    $0x40
     5ec:	c3                   	ret    

000005ed <unlink>:
SYSCALL(unlink)
     5ed:	b8 12 00 00 00       	mov    $0x12,%eax
     5f2:	cd 40                	int    $0x40
     5f4:	c3                   	ret    

000005f5 <fstat>:
SYSCALL(fstat)
     5f5:	b8 08 00 00 00       	mov    $0x8,%eax
     5fa:	cd 40                	int    $0x40
     5fc:	c3                   	ret    

000005fd <link>:
SYSCALL(link)
     5fd:	b8 13 00 00 00       	mov    $0x13,%eax
     602:	cd 40                	int    $0x40
     604:	c3                   	ret    

00000605 <mkdir>:
SYSCALL(mkdir)
     605:	b8 14 00 00 00       	mov    $0x14,%eax
     60a:	cd 40                	int    $0x40
     60c:	c3                   	ret    

0000060d <chdir>:
SYSCALL(chdir)
     60d:	b8 09 00 00 00       	mov    $0x9,%eax
     612:	cd 40                	int    $0x40
     614:	c3                   	ret    

00000615 <dup>:
SYSCALL(dup)
     615:	b8 0a 00 00 00       	mov    $0xa,%eax
     61a:	cd 40                	int    $0x40
     61c:	c3                   	ret    

0000061d <getpid>:
SYSCALL(getpid)
     61d:	b8 0b 00 00 00       	mov    $0xb,%eax
     622:	cd 40                	int    $0x40
     624:	c3                   	ret    

00000625 <sbrk>:
SYSCALL(sbrk)
     625:	b8 0c 00 00 00       	mov    $0xc,%eax
     62a:	cd 40                	int    $0x40
     62c:	c3                   	ret    

0000062d <sleep>:
SYSCALL(sleep)
     62d:	b8 0d 00 00 00       	mov    $0xd,%eax
     632:	cd 40                	int    $0x40
     634:	c3                   	ret    

00000635 <uptime>:
SYSCALL(uptime)
     635:	b8 0e 00 00 00       	mov    $0xe,%eax
     63a:	cd 40                	int    $0x40
     63c:	c3                   	ret    

0000063d <createwindow>:
SYSCALL(createwindow)
     63d:	b8 16 00 00 00       	mov    $0x16,%eax
     642:	cd 40                	int    $0x40
     644:	c3                   	ret    

00000645 <repaintwindow>:
SYSCALL(repaintwindow)
     645:	b8 17 00 00 00       	mov    $0x17,%eax
     64a:	cd 40                	int    $0x40
     64c:	c3                   	ret    

0000064d <getmessage>:
SYSCALL(getmessage)
     64d:	b8 18 00 00 00       	mov    $0x18,%eax
     652:	cd 40                	int    $0x40
     654:	c3                   	ret    

00000655 <settimer>:
SYSCALL(settimer)
     655:	b8 19 00 00 00       	mov    $0x19,%eax
     65a:	cd 40                	int    $0x40
     65c:	c3                   	ret    

0000065d <updatewindow>:
SYSCALL(updatewindow)
     65d:	b8 1a 00 00 00       	mov    $0x1a,%eax
     662:	cd 40                	int    $0x40
     664:	c3                   	ret    

00000665 <destroywindow>:
SYSCALL(destroywindow)
     665:	b8 1b 00 00 00       	mov    $0x1b,%eax
     66a:	cd 40                	int    $0x40
     66c:	c3                   	ret    

0000066d <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     66d:	55                   	push   %ebp
     66e:	89 e5                	mov    %esp,%ebp
     670:	83 ec 18             	sub    $0x18,%esp
     673:	8b 45 0c             	mov    0xc(%ebp),%eax
     676:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     679:	83 ec 04             	sub    $0x4,%esp
     67c:	6a 01                	push   $0x1
     67e:	8d 45 f4             	lea    -0xc(%ebp),%eax
     681:	50                   	push   %eax
     682:	ff 75 08             	pushl  0x8(%ebp)
     685:	e8 33 ff ff ff       	call   5bd <write>
     68a:	83 c4 10             	add    $0x10,%esp
}
     68d:	90                   	nop
     68e:	c9                   	leave  
     68f:	c3                   	ret    

00000690 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     690:	55                   	push   %ebp
     691:	89 e5                	mov    %esp,%ebp
     693:	53                   	push   %ebx
     694:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     697:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     69e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     6a2:	74 17                	je     6bb <printint+0x2b>
     6a4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     6a8:	79 11                	jns    6bb <printint+0x2b>
    neg = 1;
     6aa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     6b1:	8b 45 0c             	mov    0xc(%ebp),%eax
     6b4:	f7 d8                	neg    %eax
     6b6:	89 45 ec             	mov    %eax,-0x14(%ebp)
     6b9:	eb 06                	jmp    6c1 <printint+0x31>
  } else {
    x = xx;
     6bb:	8b 45 0c             	mov    0xc(%ebp),%eax
     6be:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     6c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     6c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     6cb:	8d 41 01             	lea    0x1(%ecx),%eax
     6ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
     6d1:	8b 5d 10             	mov    0x10(%ebp),%ebx
     6d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
     6d7:	ba 00 00 00 00       	mov    $0x0,%edx
     6dc:	f7 f3                	div    %ebx
     6de:	89 d0                	mov    %edx,%eax
     6e0:	0f b6 80 20 e4 01 00 	movzbl 0x1e420(%eax),%eax
     6e7:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     6eb:	8b 5d 10             	mov    0x10(%ebp),%ebx
     6ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
     6f1:	ba 00 00 00 00       	mov    $0x0,%edx
     6f6:	f7 f3                	div    %ebx
     6f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
     6fb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     6ff:	75 c7                	jne    6c8 <printint+0x38>
  if(neg)
     701:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     705:	74 2d                	je     734 <printint+0xa4>
    buf[i++] = '-';
     707:	8b 45 f4             	mov    -0xc(%ebp),%eax
     70a:	8d 50 01             	lea    0x1(%eax),%edx
     70d:	89 55 f4             	mov    %edx,-0xc(%ebp)
     710:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     715:	eb 1d                	jmp    734 <printint+0xa4>
    putc(fd, buf[i]);
     717:	8d 55 dc             	lea    -0x24(%ebp),%edx
     71a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     71d:	01 d0                	add    %edx,%eax
     71f:	0f b6 00             	movzbl (%eax),%eax
     722:	0f be c0             	movsbl %al,%eax
     725:	83 ec 08             	sub    $0x8,%esp
     728:	50                   	push   %eax
     729:	ff 75 08             	pushl  0x8(%ebp)
     72c:	e8 3c ff ff ff       	call   66d <putc>
     731:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     734:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     738:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     73c:	79 d9                	jns    717 <printint+0x87>
    putc(fd, buf[i]);
}
     73e:	90                   	nop
     73f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     742:	c9                   	leave  
     743:	c3                   	ret    

00000744 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     744:	55                   	push   %ebp
     745:	89 e5                	mov    %esp,%ebp
     747:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     74a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     751:	8d 45 0c             	lea    0xc(%ebp),%eax
     754:	83 c0 04             	add    $0x4,%eax
     757:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     75a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     761:	e9 59 01 00 00       	jmp    8bf <printf+0x17b>
    c = fmt[i] & 0xff;
     766:	8b 55 0c             	mov    0xc(%ebp),%edx
     769:	8b 45 f0             	mov    -0x10(%ebp),%eax
     76c:	01 d0                	add    %edx,%eax
     76e:	0f b6 00             	movzbl (%eax),%eax
     771:	0f be c0             	movsbl %al,%eax
     774:	25 ff 00 00 00       	and    $0xff,%eax
     779:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     77c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     780:	75 2c                	jne    7ae <printf+0x6a>
      if(c == '%'){
     782:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     786:	75 0c                	jne    794 <printf+0x50>
        state = '%';
     788:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     78f:	e9 27 01 00 00       	jmp    8bb <printf+0x177>
      } else {
        putc(fd, c);
     794:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     797:	0f be c0             	movsbl %al,%eax
     79a:	83 ec 08             	sub    $0x8,%esp
     79d:	50                   	push   %eax
     79e:	ff 75 08             	pushl  0x8(%ebp)
     7a1:	e8 c7 fe ff ff       	call   66d <putc>
     7a6:	83 c4 10             	add    $0x10,%esp
     7a9:	e9 0d 01 00 00       	jmp    8bb <printf+0x177>
      }
    } else if(state == '%'){
     7ae:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     7b2:	0f 85 03 01 00 00    	jne    8bb <printf+0x177>
      if(c == 'd'){
     7b8:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     7bc:	75 1e                	jne    7dc <printf+0x98>
        printint(fd, *ap, 10, 1);
     7be:	8b 45 e8             	mov    -0x18(%ebp),%eax
     7c1:	8b 00                	mov    (%eax),%eax
     7c3:	6a 01                	push   $0x1
     7c5:	6a 0a                	push   $0xa
     7c7:	50                   	push   %eax
     7c8:	ff 75 08             	pushl  0x8(%ebp)
     7cb:	e8 c0 fe ff ff       	call   690 <printint>
     7d0:	83 c4 10             	add    $0x10,%esp
        ap++;
     7d3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     7d7:	e9 d8 00 00 00       	jmp    8b4 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     7dc:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     7e0:	74 06                	je     7e8 <printf+0xa4>
     7e2:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     7e6:	75 1e                	jne    806 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     7e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
     7eb:	8b 00                	mov    (%eax),%eax
     7ed:	6a 00                	push   $0x0
     7ef:	6a 10                	push   $0x10
     7f1:	50                   	push   %eax
     7f2:	ff 75 08             	pushl  0x8(%ebp)
     7f5:	e8 96 fe ff ff       	call   690 <printint>
     7fa:	83 c4 10             	add    $0x10,%esp
        ap++;
     7fd:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     801:	e9 ae 00 00 00       	jmp    8b4 <printf+0x170>
      } else if(c == 's'){
     806:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     80a:	75 43                	jne    84f <printf+0x10b>
        s = (char*)*ap;
     80c:	8b 45 e8             	mov    -0x18(%ebp),%eax
     80f:	8b 00                	mov    (%eax),%eax
     811:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     814:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     818:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     81c:	75 25                	jne    843 <printf+0xff>
          s = "(null)";
     81e:	c7 45 f4 ea 60 01 00 	movl   $0x160ea,-0xc(%ebp)
        while(*s != 0){
     825:	eb 1c                	jmp    843 <printf+0xff>
          putc(fd, *s);
     827:	8b 45 f4             	mov    -0xc(%ebp),%eax
     82a:	0f b6 00             	movzbl (%eax),%eax
     82d:	0f be c0             	movsbl %al,%eax
     830:	83 ec 08             	sub    $0x8,%esp
     833:	50                   	push   %eax
     834:	ff 75 08             	pushl  0x8(%ebp)
     837:	e8 31 fe ff ff       	call   66d <putc>
     83c:	83 c4 10             	add    $0x10,%esp
          s++;
     83f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     843:	8b 45 f4             	mov    -0xc(%ebp),%eax
     846:	0f b6 00             	movzbl (%eax),%eax
     849:	84 c0                	test   %al,%al
     84b:	75 da                	jne    827 <printf+0xe3>
     84d:	eb 65                	jmp    8b4 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     84f:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     853:	75 1d                	jne    872 <printf+0x12e>
        putc(fd, *ap);
     855:	8b 45 e8             	mov    -0x18(%ebp),%eax
     858:	8b 00                	mov    (%eax),%eax
     85a:	0f be c0             	movsbl %al,%eax
     85d:	83 ec 08             	sub    $0x8,%esp
     860:	50                   	push   %eax
     861:	ff 75 08             	pushl  0x8(%ebp)
     864:	e8 04 fe ff ff       	call   66d <putc>
     869:	83 c4 10             	add    $0x10,%esp
        ap++;
     86c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     870:	eb 42                	jmp    8b4 <printf+0x170>
      } else if(c == '%'){
     872:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     876:	75 17                	jne    88f <printf+0x14b>
        putc(fd, c);
     878:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     87b:	0f be c0             	movsbl %al,%eax
     87e:	83 ec 08             	sub    $0x8,%esp
     881:	50                   	push   %eax
     882:	ff 75 08             	pushl  0x8(%ebp)
     885:	e8 e3 fd ff ff       	call   66d <putc>
     88a:	83 c4 10             	add    $0x10,%esp
     88d:	eb 25                	jmp    8b4 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     88f:	83 ec 08             	sub    $0x8,%esp
     892:	6a 25                	push   $0x25
     894:	ff 75 08             	pushl  0x8(%ebp)
     897:	e8 d1 fd ff ff       	call   66d <putc>
     89c:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     89f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     8a2:	0f be c0             	movsbl %al,%eax
     8a5:	83 ec 08             	sub    $0x8,%esp
     8a8:	50                   	push   %eax
     8a9:	ff 75 08             	pushl  0x8(%ebp)
     8ac:	e8 bc fd ff ff       	call   66d <putc>
     8b1:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     8b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     8bb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     8bf:	8b 55 0c             	mov    0xc(%ebp),%edx
     8c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
     8c5:	01 d0                	add    %edx,%eax
     8c7:	0f b6 00             	movzbl (%eax),%eax
     8ca:	84 c0                	test   %al,%al
     8cc:	0f 85 94 fe ff ff    	jne    766 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     8d2:	90                   	nop
     8d3:	c9                   	leave  
     8d4:	c3                   	ret    

000008d5 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     8d5:	55                   	push   %ebp
     8d6:	89 e5                	mov    %esp,%ebp
     8d8:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     8db:	8b 45 08             	mov    0x8(%ebp),%eax
     8de:	83 e8 08             	sub    $0x8,%eax
     8e1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     8e4:	a1 88 e8 01 00       	mov    0x1e888,%eax
     8e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
     8ec:	eb 24                	jmp    912 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     8ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
     8f1:	8b 00                	mov    (%eax),%eax
     8f3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     8f6:	77 12                	ja     90a <free+0x35>
     8f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
     8fb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     8fe:	77 24                	ja     924 <free+0x4f>
     900:	8b 45 fc             	mov    -0x4(%ebp),%eax
     903:	8b 00                	mov    (%eax),%eax
     905:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     908:	77 1a                	ja     924 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     90a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     90d:	8b 00                	mov    (%eax),%eax
     90f:	89 45 fc             	mov    %eax,-0x4(%ebp)
     912:	8b 45 f8             	mov    -0x8(%ebp),%eax
     915:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     918:	76 d4                	jbe    8ee <free+0x19>
     91a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     91d:	8b 00                	mov    (%eax),%eax
     91f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     922:	76 ca                	jbe    8ee <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     924:	8b 45 f8             	mov    -0x8(%ebp),%eax
     927:	8b 40 04             	mov    0x4(%eax),%eax
     92a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     931:	8b 45 f8             	mov    -0x8(%ebp),%eax
     934:	01 c2                	add    %eax,%edx
     936:	8b 45 fc             	mov    -0x4(%ebp),%eax
     939:	8b 00                	mov    (%eax),%eax
     93b:	39 c2                	cmp    %eax,%edx
     93d:	75 24                	jne    963 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     93f:	8b 45 f8             	mov    -0x8(%ebp),%eax
     942:	8b 50 04             	mov    0x4(%eax),%edx
     945:	8b 45 fc             	mov    -0x4(%ebp),%eax
     948:	8b 00                	mov    (%eax),%eax
     94a:	8b 40 04             	mov    0x4(%eax),%eax
     94d:	01 c2                	add    %eax,%edx
     94f:	8b 45 f8             	mov    -0x8(%ebp),%eax
     952:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     955:	8b 45 fc             	mov    -0x4(%ebp),%eax
     958:	8b 00                	mov    (%eax),%eax
     95a:	8b 10                	mov    (%eax),%edx
     95c:	8b 45 f8             	mov    -0x8(%ebp),%eax
     95f:	89 10                	mov    %edx,(%eax)
     961:	eb 0a                	jmp    96d <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     963:	8b 45 fc             	mov    -0x4(%ebp),%eax
     966:	8b 10                	mov    (%eax),%edx
     968:	8b 45 f8             	mov    -0x8(%ebp),%eax
     96b:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     96d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     970:	8b 40 04             	mov    0x4(%eax),%eax
     973:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     97a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     97d:	01 d0                	add    %edx,%eax
     97f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     982:	75 20                	jne    9a4 <free+0xcf>
    p->s.size += bp->s.size;
     984:	8b 45 fc             	mov    -0x4(%ebp),%eax
     987:	8b 50 04             	mov    0x4(%eax),%edx
     98a:	8b 45 f8             	mov    -0x8(%ebp),%eax
     98d:	8b 40 04             	mov    0x4(%eax),%eax
     990:	01 c2                	add    %eax,%edx
     992:	8b 45 fc             	mov    -0x4(%ebp),%eax
     995:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     998:	8b 45 f8             	mov    -0x8(%ebp),%eax
     99b:	8b 10                	mov    (%eax),%edx
     99d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     9a0:	89 10                	mov    %edx,(%eax)
     9a2:	eb 08                	jmp    9ac <free+0xd7>
  } else
    p->s.ptr = bp;
     9a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
     9a7:	8b 55 f8             	mov    -0x8(%ebp),%edx
     9aa:	89 10                	mov    %edx,(%eax)
  freep = p;
     9ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
     9af:	a3 88 e8 01 00       	mov    %eax,0x1e888
}
     9b4:	90                   	nop
     9b5:	c9                   	leave  
     9b6:	c3                   	ret    

000009b7 <morecore>:

static Header*
morecore(uint nu)
{
     9b7:	55                   	push   %ebp
     9b8:	89 e5                	mov    %esp,%ebp
     9ba:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     9bd:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     9c4:	77 07                	ja     9cd <morecore+0x16>
    nu = 4096;
     9c6:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     9cd:	8b 45 08             	mov    0x8(%ebp),%eax
     9d0:	c1 e0 03             	shl    $0x3,%eax
     9d3:	83 ec 0c             	sub    $0xc,%esp
     9d6:	50                   	push   %eax
     9d7:	e8 49 fc ff ff       	call   625 <sbrk>
     9dc:	83 c4 10             	add    $0x10,%esp
     9df:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     9e2:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     9e6:	75 07                	jne    9ef <morecore+0x38>
    return 0;
     9e8:	b8 00 00 00 00       	mov    $0x0,%eax
     9ed:	eb 26                	jmp    a15 <morecore+0x5e>
  hp = (Header*)p;
     9ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
     9f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     9f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
     9f8:	8b 55 08             	mov    0x8(%ebp),%edx
     9fb:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     9fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a01:	83 c0 08             	add    $0x8,%eax
     a04:	83 ec 0c             	sub    $0xc,%esp
     a07:	50                   	push   %eax
     a08:	e8 c8 fe ff ff       	call   8d5 <free>
     a0d:	83 c4 10             	add    $0x10,%esp
  return freep;
     a10:	a1 88 e8 01 00       	mov    0x1e888,%eax
}
     a15:	c9                   	leave  
     a16:	c3                   	ret    

00000a17 <malloc>:

void*
malloc(uint nbytes)
{
     a17:	55                   	push   %ebp
     a18:	89 e5                	mov    %esp,%ebp
     a1a:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     a1d:	8b 45 08             	mov    0x8(%ebp),%eax
     a20:	83 c0 07             	add    $0x7,%eax
     a23:	c1 e8 03             	shr    $0x3,%eax
     a26:	83 c0 01             	add    $0x1,%eax
     a29:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     a2c:	a1 88 e8 01 00       	mov    0x1e888,%eax
     a31:	89 45 f0             	mov    %eax,-0x10(%ebp)
     a34:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     a38:	75 23                	jne    a5d <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     a3a:	c7 45 f0 80 e8 01 00 	movl   $0x1e880,-0x10(%ebp)
     a41:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a44:	a3 88 e8 01 00       	mov    %eax,0x1e888
     a49:	a1 88 e8 01 00       	mov    0x1e888,%eax
     a4e:	a3 80 e8 01 00       	mov    %eax,0x1e880
    base.s.size = 0;
     a53:	c7 05 84 e8 01 00 00 	movl   $0x0,0x1e884
     a5a:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     a5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a60:	8b 00                	mov    (%eax),%eax
     a62:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     a65:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a68:	8b 40 04             	mov    0x4(%eax),%eax
     a6b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     a6e:	72 4d                	jb     abd <malloc+0xa6>
      if(p->s.size == nunits)
     a70:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a73:	8b 40 04             	mov    0x4(%eax),%eax
     a76:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     a79:	75 0c                	jne    a87 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     a7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a7e:	8b 10                	mov    (%eax),%edx
     a80:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a83:	89 10                	mov    %edx,(%eax)
     a85:	eb 26                	jmp    aad <malloc+0x96>
      else {
        p->s.size -= nunits;
     a87:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a8a:	8b 40 04             	mov    0x4(%eax),%eax
     a8d:	2b 45 ec             	sub    -0x14(%ebp),%eax
     a90:	89 c2                	mov    %eax,%edx
     a92:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a95:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     a98:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a9b:	8b 40 04             	mov    0x4(%eax),%eax
     a9e:	c1 e0 03             	shl    $0x3,%eax
     aa1:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     aa7:	8b 55 ec             	mov    -0x14(%ebp),%edx
     aaa:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     aad:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ab0:	a3 88 e8 01 00       	mov    %eax,0x1e888
      return (void*)(p + 1);
     ab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ab8:	83 c0 08             	add    $0x8,%eax
     abb:	eb 3b                	jmp    af8 <malloc+0xe1>
    }
    if(p == freep)
     abd:	a1 88 e8 01 00       	mov    0x1e888,%eax
     ac2:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     ac5:	75 1e                	jne    ae5 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     ac7:	83 ec 0c             	sub    $0xc,%esp
     aca:	ff 75 ec             	pushl  -0x14(%ebp)
     acd:	e8 e5 fe ff ff       	call   9b7 <morecore>
     ad2:	83 c4 10             	add    $0x10,%esp
     ad5:	89 45 f4             	mov    %eax,-0xc(%ebp)
     ad8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     adc:	75 07                	jne    ae5 <malloc+0xce>
        return 0;
     ade:	b8 00 00 00 00       	mov    $0x0,%eax
     ae3:	eb 13                	jmp    af8 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     ae5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ae8:	89 45 f0             	mov    %eax,-0x10(%ebp)
     aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     aee:	8b 00                	mov    (%eax),%eax
     af0:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     af3:	e9 6d ff ff ff       	jmp    a65 <malloc+0x4e>
}
     af8:	c9                   	leave  
     af9:	c3                   	ret    

00000afa <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     afa:	55                   	push   %ebp
     afb:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     afd:	a1 8c e8 01 00       	mov    0x1e88c,%eax
     b02:	83 c0 01             	add    $0x1,%eax
     b05:	a3 8c e8 01 00       	mov    %eax,0x1e88c
    g_seed = (214013*g_seed+2531011);
     b0a:	a1 8c e8 01 00       	mov    0x1e88c,%eax
     b0f:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     b15:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     b1a:	a3 8c e8 01 00       	mov    %eax,0x1e88c
    return (g_seed>>16)&0x7FFF;
     b1f:	a1 8c e8 01 00       	mov    0x1e88c,%eax
     b24:	c1 e8 10             	shr    $0x10,%eax
     b27:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     b2c:	5d                   	pop    %ebp
     b2d:	c3                   	ret    

00000b2e <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     b2e:	55                   	push   %ebp
     b2f:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     b31:	d9 45 08             	flds   0x8(%ebp)
     b34:	d9 ee                	fldz   
     b36:	d9 c9                	fxch   %st(1)
     b38:	df e9                	fucomip %st(1),%st
     b3a:	dd d8                	fstp   %st(0)
     b3c:	76 05                	jbe    b43 <abs+0x15>
     b3e:	d9 45 08             	flds   0x8(%ebp)
     b41:	eb 05                	jmp    b48 <abs+0x1a>
	return -x;
     b43:	d9 45 08             	flds   0x8(%ebp)
     b46:	d9 e0                	fchs   
}
     b48:	5d                   	pop    %ebp
     b49:	c3                   	ret    

00000b4a <pow>:

float pow(float a, int b)
{
     b4a:	55                   	push   %ebp
     b4b:	89 e5                	mov    %esp,%ebp
     b4d:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     b50:	d9 45 08             	flds   0x8(%ebp)
     b53:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     b56:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     b5a:	7e 17                	jle    b73 <pow+0x29>
		while (--b)
     b5c:	eb 09                	jmp    b67 <pow+0x1d>
			r *= a;
     b5e:	d9 45 fc             	flds   -0x4(%ebp)
     b61:	d8 4d 08             	fmuls  0x8(%ebp)
     b64:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     b67:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     b6b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     b6f:	75 ed                	jne    b5e <pow+0x14>
     b71:	eb 2a                	jmp    b9d <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     b73:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     b77:	79 1f                	jns    b98 <pow+0x4e>
		while (++b)
     b79:	eb 09                	jmp    b84 <pow+0x3a>
			r *= a;
     b7b:	d9 45 fc             	flds   -0x4(%ebp)
     b7e:	d8 4d 08             	fmuls  0x8(%ebp)
     b81:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     b84:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     b88:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     b8c:	75 ed                	jne    b7b <pow+0x31>
			r *= a;
		r = 1.0 / r;
     b8e:	d9 e8                	fld1   
     b90:	d8 75 fc             	fdivs  -0x4(%ebp)
     b93:	d9 5d fc             	fstps  -0x4(%ebp)
     b96:	eb 05                	jmp    b9d <pow+0x53>
	}
	else r = 0;
     b98:	d9 ee                	fldz   
     b9a:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     b9d:	d9 45 fc             	flds   -0x4(%ebp)
}
     ba0:	c9                   	leave  
     ba1:	c3                   	ret    

00000ba2 <sqrt>:

float sqrt(float number) {
     ba2:	55                   	push   %ebp
     ba3:	89 e5                	mov    %esp,%ebp
     ba5:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     ba8:	d9 ee                	fldz   
     baa:	d9 45 08             	flds   0x8(%ebp)
     bad:	d9 c9                	fxch   %st(1)
     baf:	df e9                	fucomip %st(1),%st
     bb1:	dd d8                	fstp   %st(0)
     bb3:	76 06                	jbe    bbb <sqrt+0x19>
		return -1;
     bb5:	d9 e8                	fld1   
     bb7:	d9 e0                	fchs   
     bb9:	eb 3a                	jmp    bf5 <sqrt+0x53>
	}

	new_guess = 1;
     bbb:	d9 e8                	fld1   
     bbd:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     bc0:	d9 45 fc             	flds   -0x4(%ebp)
     bc3:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     bc6:	d9 45 08             	flds   0x8(%ebp)
     bc9:	d8 75 f8             	fdivs  -0x8(%ebp)
     bcc:	d8 45 f8             	fadds  -0x8(%ebp)
     bcf:	d9 05 f8 60 01 00    	flds   0x160f8
     bd5:	de f9                	fdivrp %st,%st(1)
     bd7:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     bda:	d9 45 fc             	flds   -0x4(%ebp)
     bdd:	d9 45 f8             	flds   -0x8(%ebp)
     be0:	df e9                	fucomip %st(1),%st
     be2:	dd d8                	fstp   %st(0)
     be4:	7a da                	jp     bc0 <sqrt+0x1e>
     be6:	d9 45 fc             	flds   -0x4(%ebp)
     be9:	d9 45 f8             	flds   -0x8(%ebp)
     bec:	df e9                	fucomip %st(1),%st
     bee:	dd d8                	fstp   %st(0)
     bf0:	75 ce                	jne    bc0 <sqrt+0x1e>

	return new_guess;
     bf2:	d9 45 fc             	flds   -0x4(%ebp)
}
     bf5:	c9                   	leave  
     bf6:	c3                   	ret    

00000bf7 <cos>:

float cos(float x)
{
     bf7:	55                   	push   %ebp
     bf8:	89 e5                	mov    %esp,%ebp
     bfa:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     bfd:	d9 e8                	fld1   
     bff:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     c02:	d9 45 08             	flds   0x8(%ebp)
     c05:	dd 05 00 61 01 00    	fldl   0x16100
     c0b:	d9 c9                	fxch   %st(1)
     c0d:	df e9                	fucomip %st(1),%st
     c0f:	dd d8                	fstp   %st(0)
     c11:	77 0f                	ja     c22 <cos+0x2b>
     c13:	d9 45 08             	flds   0x8(%ebp)
     c16:	dd 05 08 61 01 00    	fldl   0x16108
     c1c:	df e9                	fucomip %st(1),%st
     c1e:	dd d8                	fstp   %st(0)
     c20:	76 3c                	jbe    c5e <cos+0x67>
     c22:	d9 45 08             	flds   0x8(%ebp)
     c25:	d9 45 08             	flds   0x8(%ebp)
     c28:	dd 05 00 61 01 00    	fldl   0x16100
     c2e:	de f9                	fdivrp %st,%st(1)
     c30:	d9 7d e2             	fnstcw -0x1e(%ebp)
     c33:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     c37:	b4 0c                	mov    $0xc,%ah
     c39:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     c3d:	d9 6d e0             	fldcw  -0x20(%ebp)
     c40:	db 5d dc             	fistpl -0x24(%ebp)
     c43:	d9 6d e2             	fldcw  -0x1e(%ebp)
     c46:	8b 45 dc             	mov    -0x24(%ebp),%eax
     c49:	01 c0                	add    %eax,%eax
     c4b:	89 45 d8             	mov    %eax,-0x28(%ebp)
     c4e:	db 45 d8             	fildl  -0x28(%ebp)
     c51:	dd 05 10 61 01 00    	fldl   0x16110
     c57:	de c9                	fmulp  %st,%st(1)
     c59:	de e9                	fsubrp %st,%st(1)
     c5b:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     c5e:	d9 45 08             	flds   0x8(%ebp)
     c61:	dd 05 10 61 01 00    	fldl   0x16110
     c67:	d9 c9                	fxch   %st(1)
     c69:	df e9                	fucomip %st(1),%st
     c6b:	dd d8                	fstp   %st(0)
     c6d:	76 0e                	jbe    c7d <cos+0x86>
     c6f:	d9 45 08             	flds   0x8(%ebp)
     c72:	dd 05 00 61 01 00    	fldl   0x16100
     c78:	de e9                	fsubrp %st,%st(1)
     c7a:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     c7d:	d9 45 08             	flds   0x8(%ebp)
     c80:	dd 05 18 61 01 00    	fldl   0x16118
     c86:	df e9                	fucomip %st(1),%st
     c88:	dd d8                	fstp   %st(0)
     c8a:	76 0e                	jbe    c9a <cos+0xa3>
     c8c:	d9 45 08             	flds   0x8(%ebp)
     c8f:	dd 05 00 61 01 00    	fldl   0x16100
     c95:	de c1                	faddp  %st,%st(1)
     c97:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     c9a:	d9 45 08             	flds   0x8(%ebp)
     c9d:	dd 05 20 61 01 00    	fldl   0x16120
     ca3:	d9 c9                	fxch   %st(1)
     ca5:	df e9                	fucomip %st(1),%st
     ca7:	dd d8                	fstp   %st(0)
     ca9:	76 16                	jbe    cc1 <cos+0xca>
    {
        x -= PI;
     cab:	d9 45 08             	flds   0x8(%ebp)
     cae:	dd 05 10 61 01 00    	fldl   0x16110
     cb4:	de e9                	fsubrp %st,%st(1)
     cb6:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     cb9:	d9 45 f4             	flds   -0xc(%ebp)
     cbc:	d9 e0                	fchs   
     cbe:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     cc1:	d9 45 08             	flds   0x8(%ebp)
     cc4:	dd 05 28 61 01 00    	fldl   0x16128
     cca:	df e9                	fucomip %st(1),%st
     ccc:	dd d8                	fstp   %st(0)
     cce:	76 16                	jbe    ce6 <cos+0xef>
    {
        x += PI;
     cd0:	d9 45 08             	flds   0x8(%ebp)
     cd3:	dd 05 10 61 01 00    	fldl   0x16110
     cd9:	de c1                	faddp  %st,%st(1)
     cdb:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     cde:	d9 45 f4             	flds   -0xc(%ebp)
     ce1:	d9 e0                	fchs   
     ce3:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     ce6:	d9 45 08             	flds   0x8(%ebp)
     ce9:	dd 05 30 61 01 00    	fldl   0x16130
     cef:	d9 c9                	fxch   %st(1)
     cf1:	df e9                	fucomip %st(1),%st
     cf3:	dd d8                	fstp   %st(0)
     cf5:	76 28                	jbe    d1f <cos+0x128>
     cf7:	d9 45 08             	flds   0x8(%ebp)
     cfa:	dd 05 20 61 01 00    	fldl   0x16120
     d00:	de e1                	fsubp  %st,%st(1)
     d02:	d9 5d e4             	fstps  -0x1c(%ebp)
     d05:	d9 45 e4             	flds   -0x1c(%ebp)
     d08:	83 ec 0c             	sub    $0xc,%esp
     d0b:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     d0f:	d9 1c 24             	fstps  (%esp)
     d12:	e8 83 00 00 00       	call   d9a <sin>
     d17:	83 c4 10             	add    $0x10,%esp
     d1a:	d8 4d f4             	fmuls  -0xc(%ebp)
     d1d:	eb 79                	jmp    d98 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     d1f:	83 ec 08             	sub    $0x8,%esp
     d22:	6a 02                	push   $0x2
     d24:	ff 75 08             	pushl  0x8(%ebp)
     d27:	e8 1e fe ff ff       	call   b4a <pow>
     d2c:	83 c4 10             	add    $0x10,%esp
     d2f:	d9 05 f8 60 01 00    	flds   0x160f8
     d35:	de f9                	fdivrp %st,%st(1)
     d37:	d9 e8                	fld1   
     d39:	de e1                	fsubp  %st,%st(1)
     d3b:	d9 5d d8             	fstps  -0x28(%ebp)
     d3e:	83 ec 08             	sub    $0x8,%esp
     d41:	6a 04                	push   $0x4
     d43:	ff 75 08             	pushl  0x8(%ebp)
     d46:	e8 ff fd ff ff       	call   b4a <pow>
     d4b:	83 c4 10             	add    $0x10,%esp
     d4e:	d9 05 38 61 01 00    	flds   0x16138
     d54:	de f9                	fdivrp %st,%st(1)
     d56:	d8 45 d8             	fadds  -0x28(%ebp)
     d59:	d9 5d d8             	fstps  -0x28(%ebp)
     d5c:	83 ec 08             	sub    $0x8,%esp
     d5f:	6a 06                	push   $0x6
     d61:	ff 75 08             	pushl  0x8(%ebp)
     d64:	e8 e1 fd ff ff       	call   b4a <pow>
     d69:	83 c4 10             	add    $0x10,%esp
     d6c:	d9 05 3c 61 01 00    	flds   0x1613c
     d72:	de f9                	fdivrp %st,%st(1)
     d74:	d8 6d d8             	fsubrs -0x28(%ebp)
     d77:	d9 5d d8             	fstps  -0x28(%ebp)
     d7a:	83 ec 08             	sub    $0x8,%esp
     d7d:	6a 08                	push   $0x8
     d7f:	ff 75 08             	pushl  0x8(%ebp)
     d82:	e8 c3 fd ff ff       	call   b4a <pow>
     d87:	83 c4 10             	add    $0x10,%esp
     d8a:	d9 05 40 61 01 00    	flds   0x16140
     d90:	de f9                	fdivrp %st,%st(1)
     d92:	d8 45 d8             	fadds  -0x28(%ebp)
     d95:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     d98:	c9                   	leave  
     d99:	c3                   	ret    

00000d9a <sin>:

float sin(float x)
{
     d9a:	55                   	push   %ebp
     d9b:	89 e5                	mov    %esp,%ebp
     d9d:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     da0:	d9 e8                	fld1   
     da2:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     da5:	d9 45 08             	flds   0x8(%ebp)
     da8:	dd 05 00 61 01 00    	fldl   0x16100
     dae:	d9 c9                	fxch   %st(1)
     db0:	df e9                	fucomip %st(1),%st
     db2:	dd d8                	fstp   %st(0)
     db4:	77 0f                	ja     dc5 <sin+0x2b>
     db6:	d9 45 08             	flds   0x8(%ebp)
     db9:	dd 05 08 61 01 00    	fldl   0x16108
     dbf:	df e9                	fucomip %st(1),%st
     dc1:	dd d8                	fstp   %st(0)
     dc3:	76 3c                	jbe    e01 <sin+0x67>
     dc5:	d9 45 08             	flds   0x8(%ebp)
     dc8:	d9 45 08             	flds   0x8(%ebp)
     dcb:	dd 05 00 61 01 00    	fldl   0x16100
     dd1:	de f9                	fdivrp %st,%st(1)
     dd3:	d9 7d e2             	fnstcw -0x1e(%ebp)
     dd6:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     dda:	b4 0c                	mov    $0xc,%ah
     ddc:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     de0:	d9 6d e0             	fldcw  -0x20(%ebp)
     de3:	db 5d dc             	fistpl -0x24(%ebp)
     de6:	d9 6d e2             	fldcw  -0x1e(%ebp)
     de9:	8b 45 dc             	mov    -0x24(%ebp),%eax
     dec:	01 c0                	add    %eax,%eax
     dee:	89 45 d8             	mov    %eax,-0x28(%ebp)
     df1:	db 45 d8             	fildl  -0x28(%ebp)
     df4:	dd 05 10 61 01 00    	fldl   0x16110
     dfa:	de c9                	fmulp  %st,%st(1)
     dfc:	de e9                	fsubrp %st,%st(1)
     dfe:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     e01:	d9 45 08             	flds   0x8(%ebp)
     e04:	dd 05 10 61 01 00    	fldl   0x16110
     e0a:	d9 c9                	fxch   %st(1)
     e0c:	df e9                	fucomip %st(1),%st
     e0e:	dd d8                	fstp   %st(0)
     e10:	76 0e                	jbe    e20 <sin+0x86>
     e12:	d9 45 08             	flds   0x8(%ebp)
     e15:	dd 05 00 61 01 00    	fldl   0x16100
     e1b:	de e9                	fsubrp %st,%st(1)
     e1d:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     e20:	d9 45 08             	flds   0x8(%ebp)
     e23:	dd 05 18 61 01 00    	fldl   0x16118
     e29:	df e9                	fucomip %st(1),%st
     e2b:	dd d8                	fstp   %st(0)
     e2d:	76 0e                	jbe    e3d <sin+0xa3>
     e2f:	d9 45 08             	flds   0x8(%ebp)
     e32:	dd 05 00 61 01 00    	fldl   0x16100
     e38:	de c1                	faddp  %st,%st(1)
     e3a:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     e3d:	d9 45 08             	flds   0x8(%ebp)
     e40:	dd 05 20 61 01 00    	fldl   0x16120
     e46:	d9 c9                	fxch   %st(1)
     e48:	df e9                	fucomip %st(1),%st
     e4a:	dd d8                	fstp   %st(0)
     e4c:	76 16                	jbe    e64 <sin+0xca>
    {
        x -= PI;
     e4e:	d9 45 08             	flds   0x8(%ebp)
     e51:	dd 05 10 61 01 00    	fldl   0x16110
     e57:	de e9                	fsubrp %st,%st(1)
     e59:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     e5c:	d9 45 f4             	flds   -0xc(%ebp)
     e5f:	d9 e0                	fchs   
     e61:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     e64:	d9 45 08             	flds   0x8(%ebp)
     e67:	dd 05 28 61 01 00    	fldl   0x16128
     e6d:	df e9                	fucomip %st(1),%st
     e6f:	dd d8                	fstp   %st(0)
     e71:	76 16                	jbe    e89 <sin+0xef>
    {
        x += PI;
     e73:	d9 45 08             	flds   0x8(%ebp)
     e76:	dd 05 10 61 01 00    	fldl   0x16110
     e7c:	de c1                	faddp  %st,%st(1)
     e7e:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     e81:	d9 45 f4             	flds   -0xc(%ebp)
     e84:	d9 e0                	fchs   
     e86:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     e89:	d9 ee                	fldz   
     e8b:	d9 45 08             	flds   0x8(%ebp)
     e8e:	d9 c9                	fxch   %st(1)
     e90:	df e9                	fucomip %st(1),%st
     e92:	dd d8                	fstp   %st(0)
     e94:	76 10                	jbe    ea6 <sin+0x10c>
    {
        x *= -1;
     e96:	d9 45 08             	flds   0x8(%ebp)
     e99:	d9 e0                	fchs   
     e9b:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     e9e:	d9 45 f4             	flds   -0xc(%ebp)
     ea1:	d9 e0                	fchs   
     ea3:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     ea6:	d9 45 08             	flds   0x8(%ebp)
     ea9:	dd 05 30 61 01 00    	fldl   0x16130
     eaf:	d9 c9                	fxch   %st(1)
     eb1:	df e9                	fucomip %st(1),%st
     eb3:	dd d8                	fstp   %st(0)
     eb5:	76 28                	jbe    edf <sin+0x145>
     eb7:	d9 45 08             	flds   0x8(%ebp)
     eba:	dd 05 20 61 01 00    	fldl   0x16120
     ec0:	de e1                	fsubp  %st,%st(1)
     ec2:	d9 5d e4             	fstps  -0x1c(%ebp)
     ec5:	d9 45 e4             	flds   -0x1c(%ebp)
     ec8:	83 ec 0c             	sub    $0xc,%esp
     ecb:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     ecf:	d9 1c 24             	fstps  (%esp)
     ed2:	e8 20 fd ff ff       	call   bf7 <cos>
     ed7:	83 c4 10             	add    $0x10,%esp
     eda:	d8 4d f4             	fmuls  -0xc(%ebp)
     edd:	eb 7a                	jmp    f59 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     edf:	83 ec 08             	sub    $0x8,%esp
     ee2:	6a 03                	push   $0x3
     ee4:	ff 75 08             	pushl  0x8(%ebp)
     ee7:	e8 5e fc ff ff       	call   b4a <pow>
     eec:	83 c4 10             	add    $0x10,%esp
     eef:	d9 05 44 61 01 00    	flds   0x16144
     ef5:	de f9                	fdivrp %st,%st(1)
     ef7:	d9 45 08             	flds   0x8(%ebp)
     efa:	de e1                	fsubp  %st,%st(1)
     efc:	d9 5d d8             	fstps  -0x28(%ebp)
     eff:	83 ec 08             	sub    $0x8,%esp
     f02:	6a 05                	push   $0x5
     f04:	ff 75 08             	pushl  0x8(%ebp)
     f07:	e8 3e fc ff ff       	call   b4a <pow>
     f0c:	83 c4 10             	add    $0x10,%esp
     f0f:	d9 05 48 61 01 00    	flds   0x16148
     f15:	de f9                	fdivrp %st,%st(1)
     f17:	d8 45 d8             	fadds  -0x28(%ebp)
     f1a:	d9 5d d8             	fstps  -0x28(%ebp)
     f1d:	83 ec 08             	sub    $0x8,%esp
     f20:	6a 07                	push   $0x7
     f22:	ff 75 08             	pushl  0x8(%ebp)
     f25:	e8 20 fc ff ff       	call   b4a <pow>
     f2a:	83 c4 10             	add    $0x10,%esp
     f2d:	d9 05 4c 61 01 00    	flds   0x1614c
     f33:	de f9                	fdivrp %st,%st(1)
     f35:	d8 6d d8             	fsubrs -0x28(%ebp)
     f38:	d9 5d d8             	fstps  -0x28(%ebp)
     f3b:	83 ec 08             	sub    $0x8,%esp
     f3e:	6a 09                	push   $0x9
     f40:	ff 75 08             	pushl  0x8(%ebp)
     f43:	e8 02 fc ff ff       	call   b4a <pow>
     f48:	83 c4 10             	add    $0x10,%esp
     f4b:	d9 05 50 61 01 00    	flds   0x16150
     f51:	de f9                	fdivrp %st,%st(1)
     f53:	d8 45 d8             	fadds  -0x28(%ebp)
     f56:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     f59:	c9                   	leave  
     f5a:	c3                   	ret    

00000f5b <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     f5b:	55                   	push   %ebp
     f5c:	89 e5                	mov    %esp,%ebp
     f5e:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     f61:	83 ec 04             	sub    $0x4,%esp
     f64:	6a 0e                	push   $0xe
     f66:	ff 75 0c             	pushl  0xc(%ebp)
     f69:	ff 75 08             	pushl  0x8(%ebp)
     f6c:	e8 44 f6 ff ff       	call   5b5 <read>
     f71:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     f74:	83 ec 04             	sub    $0x4,%esp
     f77:	6a 28                	push   $0x28
     f79:	ff 75 10             	pushl  0x10(%ebp)
     f7c:	ff 75 08             	pushl  0x8(%ebp)
     f7f:	e8 31 f6 ff ff       	call   5b5 <read>
     f84:	83 c4 10             	add    $0x10,%esp
}
     f87:	90                   	nop
     f88:	c9                   	leave  
     f89:	c3                   	ret    

00000f8a <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     f8a:	55                   	push   %ebp
     f8b:	89 e5                	mov    %esp,%ebp
     f8d:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     f93:	83 ec 08             	sub    $0x8,%esp
     f96:	6a 00                	push   $0x0
     f98:	ff 75 08             	pushl  0x8(%ebp)
     f9b:	e8 3d f6 ff ff       	call   5dd <open>
     fa0:	83 c4 10             	add    $0x10,%esp
     fa3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     fa6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     faa:	79 0a                	jns    fb6 <readBitmapFile+0x2c>
        return -1;
     fac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     fb1:	e9 6e 01 00 00       	jmp    1124 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     fb6:	83 ec 04             	sub    $0x4,%esp
     fb9:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     fbc:	50                   	push   %eax
     fbd:	8d 45 ca             	lea    -0x36(%ebp),%eax
     fc0:	50                   	push   %eax
     fc1:	ff 75 ec             	pushl  -0x14(%ebp)
     fc4:	e8 92 ff ff ff       	call   f5b <readBitmapHeader>
     fc9:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     fcc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     fcf:	83 e8 36             	sub    $0x36,%eax
     fd2:	83 ec 04             	sub    $0x4,%esp
     fd5:	50                   	push   %eax
     fd6:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     fdc:	50                   	push   %eax
     fdd:	ff 75 ec             	pushl  -0x14(%ebp)
     fe0:	e8 d0 f5 ff ff       	call   5b5 <read>
     fe5:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     fe8:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     feb:	8b 45 14             	mov    0x14(%ebp),%eax
     fee:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     ff0:	8b 55 aa             	mov    -0x56(%ebp),%edx
     ff3:	8b 45 10             	mov    0x10(%ebp),%eax
     ff6:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     ff8:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     ffb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     ffe:	8b 45 aa             	mov    -0x56(%ebp),%eax
    1001:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    1004:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    1008:	0f b7 c0             	movzwl %ax,%eax
    100b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    100e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1011:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    1015:	8d 50 07             	lea    0x7(%eax),%edx
    1018:	85 c0                	test   %eax,%eax
    101a:	0f 48 c2             	cmovs  %edx,%eax
    101d:	c1 f8 03             	sar    $0x3,%eax
    1020:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1023:	8b 45 0c             	mov    0xc(%ebp),%eax
    1026:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    1029:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    102c:	83 e8 01             	sub    $0x1,%eax
    102f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1032:	e9 d0 00 00 00       	jmp    1107 <readBitmapFile+0x17d>
        if (bits == 32) {
    1037:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    103b:	75 22                	jne    105f <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    103d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1040:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    1044:	89 c2                	mov    %eax,%edx
    1046:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1049:	01 d0                	add    %edx,%eax
    104b:	83 ec 04             	sub    $0x4,%esp
    104e:	ff 75 dc             	pushl  -0x24(%ebp)
    1051:	50                   	push   %eax
    1052:	ff 75 ec             	pushl  -0x14(%ebp)
    1055:	e8 5b f5 ff ff       	call   5b5 <read>
    105a:	83 c4 10             	add    $0x10,%esp
    105d:	eb 65                	jmp    10c4 <readBitmapFile+0x13a>
        } else {
            int j = 0;
    105f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    1066:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    106d:	eb 4d                	jmp    10bc <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    106f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1072:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1076:	c1 e0 02             	shl    $0x2,%eax
    1079:	89 c2                	mov    %eax,%edx
    107b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    107e:	c1 e0 02             	shl    $0x2,%eax
    1081:	01 c2                	add    %eax,%edx
    1083:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1086:	01 d0                	add    %edx,%eax
    1088:	83 ec 04             	sub    $0x4,%esp
    108b:	6a 03                	push   $0x3
    108d:	50                   	push   %eax
    108e:	ff 75 ec             	pushl  -0x14(%ebp)
    1091:	e8 1f f5 ff ff       	call   5b5 <read>
    1096:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    1099:	8b 45 f4             	mov    -0xc(%ebp),%eax
    109c:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    10a0:	c1 e0 02             	shl    $0x2,%eax
    10a3:	89 c2                	mov    %eax,%edx
    10a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    10a8:	c1 e0 02             	shl    $0x2,%eax
    10ab:	01 d0                	add    %edx,%eax
    10ad:	8d 50 03             	lea    0x3(%eax),%edx
    10b0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    10b3:	01 d0                	add    %edx,%eax
    10b5:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    10b8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    10bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    10bf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    10c2:	7c ab                	jl     106f <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    10c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    10c7:	99                   	cltd   
    10c8:	c1 ea 1e             	shr    $0x1e,%edx
    10cb:	01 d0                	add    %edx,%eax
    10cd:	83 e0 03             	and    $0x3,%eax
    10d0:	29 d0                	sub    %edx,%eax
    10d2:	85 c0                	test   %eax,%eax
    10d4:	7e 2d                	jle    1103 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    10d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    10d9:	99                   	cltd   
    10da:	c1 ea 1e             	shr    $0x1e,%edx
    10dd:	01 d0                	add    %edx,%eax
    10df:	83 e0 03             	and    $0x3,%eax
    10e2:	29 d0                	sub    %edx,%eax
    10e4:	ba 04 00 00 00       	mov    $0x4,%edx
    10e9:	29 c2                	sub    %eax,%edx
    10eb:	89 d0                	mov    %edx,%eax
    10ed:	83 ec 04             	sub    $0x4,%esp
    10f0:	50                   	push   %eax
    10f1:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    10f7:	50                   	push   %eax
    10f8:	ff 75 ec             	pushl  -0x14(%ebp)
    10fb:	e8 b5 f4 ff ff       	call   5b5 <read>
    1100:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1103:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1107:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    110b:	0f 89 26 ff ff ff    	jns    1037 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1111:	83 ec 0c             	sub    $0xc,%esp
    1114:	ff 75 ec             	pushl  -0x14(%ebp)
    1117:	e8 a9 f4 ff ff       	call   5c5 <close>
    111c:	83 c4 10             	add    $0x10,%esp
    return 0;
    111f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1124:	c9                   	leave  
    1125:	c3                   	ret    

00001126 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    1126:	55                   	push   %ebp
    1127:	89 e5                	mov    %esp,%ebp
    1129:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    112f:	83 ec 08             	sub    $0x8,%esp
    1132:	6a 00                	push   $0x0
    1134:	ff 75 08             	pushl  0x8(%ebp)
    1137:	e8 a1 f4 ff ff       	call   5dd <open>
    113c:	83 c4 10             	add    $0x10,%esp
    113f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    1142:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1146:	79 0a                	jns    1152 <read24BitmapFile+0x2c>
        return -1;
    1148:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    114d:	e9 66 01 00 00       	jmp    12b8 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1152:	83 ec 04             	sub    $0x4,%esp
    1155:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1158:	50                   	push   %eax
    1159:	8d 45 ca             	lea    -0x36(%ebp),%eax
    115c:	50                   	push   %eax
    115d:	ff 75 ec             	pushl  -0x14(%ebp)
    1160:	e8 f6 fd ff ff       	call   f5b <readBitmapHeader>
    1165:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1168:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    116b:	83 e8 36             	sub    $0x36,%eax
    116e:	83 ec 04             	sub    $0x4,%esp
    1171:	50                   	push   %eax
    1172:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1178:	50                   	push   %eax
    1179:	ff 75 ec             	pushl  -0x14(%ebp)
    117c:	e8 34 f4 ff ff       	call   5b5 <read>
    1181:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    1184:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1187:	8b 45 14             	mov    0x14(%ebp),%eax
    118a:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    118c:	8b 55 aa             	mov    -0x56(%ebp),%edx
    118f:	8b 45 10             	mov    0x10(%ebp),%eax
    1192:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    1194:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    1197:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    119a:	8b 45 aa             	mov    -0x56(%ebp),%eax
    119d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    11a0:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    11a4:	0f b7 c0             	movzwl %ax,%eax
    11a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    11aa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    11ad:	89 d0                	mov    %edx,%eax
    11af:	01 c0                	add    %eax,%eax
    11b1:	01 d0                	add    %edx,%eax
    11b3:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    11b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    11b9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    11bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    11bf:	83 e8 01             	sub    $0x1,%eax
    11c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    11c5:	e9 d1 00 00 00       	jmp    129b <read24BitmapFile+0x175>
        if (bits == 24) {
    11ca:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    11ce:	75 22                	jne    11f2 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    11d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    11d3:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    11d7:	89 c2                	mov    %eax,%edx
    11d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    11dc:	01 d0                	add    %edx,%eax
    11de:	83 ec 04             	sub    $0x4,%esp
    11e1:	ff 75 dc             	pushl  -0x24(%ebp)
    11e4:	50                   	push   %eax
    11e5:	ff 75 ec             	pushl  -0x14(%ebp)
    11e8:	e8 c8 f3 ff ff       	call   5b5 <read>
    11ed:	83 c4 10             	add    $0x10,%esp
    11f0:	eb 66                	jmp    1258 <read24BitmapFile+0x132>
        } else {
            int j = 0;
    11f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    11f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1200:	eb 4e                	jmp    1250 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    1202:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1205:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1209:	89 c2                	mov    %eax,%edx
    120b:	89 d0                	mov    %edx,%eax
    120d:	01 c0                	add    %eax,%eax
    120f:	01 d0                	add    %edx,%eax
    1211:	89 c1                	mov    %eax,%ecx
    1213:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1216:	89 d0                	mov    %edx,%eax
    1218:	01 c0                	add    %eax,%eax
    121a:	01 d0                	add    %edx,%eax
    121c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    121f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1222:	01 d0                	add    %edx,%eax
    1224:	83 ec 04             	sub    $0x4,%esp
    1227:	6a 03                	push   $0x3
    1229:	50                   	push   %eax
    122a:	ff 75 ec             	pushl  -0x14(%ebp)
    122d:	e8 83 f3 ff ff       	call   5b5 <read>
    1232:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    1235:	83 ec 04             	sub    $0x4,%esp
    1238:	6a 01                	push   $0x1
    123a:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1240:	50                   	push   %eax
    1241:	ff 75 ec             	pushl  -0x14(%ebp)
    1244:	e8 6c f3 ff ff       	call   5b5 <read>
    1249:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    124c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1250:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1253:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1256:	7c aa                	jl     1202 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    1258:	8b 45 dc             	mov    -0x24(%ebp),%eax
    125b:	99                   	cltd   
    125c:	c1 ea 1e             	shr    $0x1e,%edx
    125f:	01 d0                	add    %edx,%eax
    1261:	83 e0 03             	and    $0x3,%eax
    1264:	29 d0                	sub    %edx,%eax
    1266:	85 c0                	test   %eax,%eax
    1268:	7e 2d                	jle    1297 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    126a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    126d:	99                   	cltd   
    126e:	c1 ea 1e             	shr    $0x1e,%edx
    1271:	01 d0                	add    %edx,%eax
    1273:	83 e0 03             	and    $0x3,%eax
    1276:	29 d0                	sub    %edx,%eax
    1278:	ba 04 00 00 00       	mov    $0x4,%edx
    127d:	29 c2                	sub    %eax,%edx
    127f:	89 d0                	mov    %edx,%eax
    1281:	83 ec 04             	sub    $0x4,%esp
    1284:	50                   	push   %eax
    1285:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    128b:	50                   	push   %eax
    128c:	ff 75 ec             	pushl  -0x14(%ebp)
    128f:	e8 21 f3 ff ff       	call   5b5 <read>
    1294:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1297:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    129b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    129f:	0f 89 25 ff ff ff    	jns    11ca <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    12a5:	83 ec 0c             	sub    $0xc,%esp
    12a8:	ff 75 ec             	pushl  -0x14(%ebp)
    12ab:	e8 15 f3 ff ff       	call   5c5 <close>
    12b0:	83 c4 10             	add    $0x10,%esp
    return 0;
    12b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12b8:	c9                   	leave  
    12b9:	c3                   	ret    

000012ba <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    12ba:	55                   	push   %ebp
    12bb:	89 e5                	mov    %esp,%ebp
    12bd:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    12c0:	8b 55 10             	mov    0x10(%ebp),%edx
    12c3:	89 d0                	mov    %edx,%eax
    12c5:	01 c0                	add    %eax,%eax
    12c7:	01 d0                	add    %edx,%eax
    12c9:	c1 e0 03             	shl    $0x3,%eax
    12cc:	83 c0 1f             	add    $0x1f,%eax
    12cf:	8d 50 1f             	lea    0x1f(%eax),%edx
    12d2:	85 c0                	test   %eax,%eax
    12d4:	0f 48 c2             	cmovs  %edx,%eax
    12d7:	c1 f8 05             	sar    $0x5,%eax
    12da:	c1 e0 02             	shl    $0x2,%eax
    12dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    12e0:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    12e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    12e9:	0f af 45 0c          	imul   0xc(%ebp),%eax
    12ed:	83 c0 36             	add    $0x36,%eax
    12f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    12f3:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    12f9:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    12ff:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    1306:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    130d:	8b 45 10             	mov    0x10(%ebp),%eax
    1310:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    1313:	8b 45 0c             	mov    0xc(%ebp),%eax
    1316:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1319:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    131f:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    1325:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    132c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    132f:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1333:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1336:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    133d:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    1344:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    134b:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1352:	83 ec 04             	sub    $0x4,%esp
    1355:	6a 0e                	push   $0xe
    1357:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    135a:	50                   	push   %eax
    135b:	ff 75 08             	pushl  0x8(%ebp)
    135e:	e8 5a f2 ff ff       	call   5bd <write>
    1363:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1366:	83 ec 04             	sub    $0x4,%esp
    1369:	6a 28                	push   $0x28
    136b:	8d 45 be             	lea    -0x42(%ebp),%eax
    136e:	50                   	push   %eax
    136f:	ff 75 08             	pushl  0x8(%ebp)
    1372:	e8 46 f2 ff ff       	call   5bd <write>
    1377:	83 c4 10             	add    $0x10,%esp
}
    137a:	90                   	nop
    137b:	c9                   	leave  
    137c:	c3                   	ret    

0000137d <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    137d:	55                   	push   %ebp
    137e:	89 e5                	mov    %esp,%ebp
    1380:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    1383:	83 ec 08             	sub    $0x8,%esp
    1386:	68 02 02 00 00       	push   $0x202
    138b:	ff 75 08             	pushl  0x8(%ebp)
    138e:	e8 4a f2 ff ff       	call   5dd <open>
    1393:	83 c4 10             	add    $0x10,%esp
    1396:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    1399:	8b 55 14             	mov    0x14(%ebp),%edx
    139c:	89 d0                	mov    %edx,%eax
    139e:	01 c0                	add    %eax,%eax
    13a0:	01 d0                	add    %edx,%eax
    13a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    13a5:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    13a9:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    13ad:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    13b1:	83 ec 04             	sub    $0x4,%esp
    13b4:	ff 75 14             	pushl  0x14(%ebp)
    13b7:	ff 75 10             	pushl  0x10(%ebp)
    13ba:	ff 75 f0             	pushl  -0x10(%ebp)
    13bd:	e8 f8 fe ff ff       	call   12ba <write24BitmapFileHeader>
    13c2:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    13c5:	8b 45 10             	mov    0x10(%ebp),%eax
    13c8:	83 e8 01             	sub    $0x1,%eax
    13cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    13ce:	eb 66                	jmp    1436 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    13d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    13d3:	0f af 45 14          	imul   0x14(%ebp),%eax
    13d7:	89 c2                	mov    %eax,%edx
    13d9:	89 d0                	mov    %edx,%eax
    13db:	01 c0                	add    %eax,%eax
    13dd:	01 c2                	add    %eax,%edx
    13df:	8b 45 0c             	mov    0xc(%ebp),%eax
    13e2:	01 d0                	add    %edx,%eax
    13e4:	83 ec 04             	sub    $0x4,%esp
    13e7:	ff 75 ec             	pushl  -0x14(%ebp)
    13ea:	50                   	push   %eax
    13eb:	ff 75 f0             	pushl  -0x10(%ebp)
    13ee:	e8 ca f1 ff ff       	call   5bd <write>
    13f3:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    13f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    13f9:	99                   	cltd   
    13fa:	c1 ea 1e             	shr    $0x1e,%edx
    13fd:	01 d0                	add    %edx,%eax
    13ff:	83 e0 03             	and    $0x3,%eax
    1402:	29 d0                	sub    %edx,%eax
    1404:	85 c0                	test   %eax,%eax
    1406:	7e 2a                	jle    1432 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1408:	8b 45 ec             	mov    -0x14(%ebp),%eax
    140b:	99                   	cltd   
    140c:	c1 ea 1e             	shr    $0x1e,%edx
    140f:	01 d0                	add    %edx,%eax
    1411:	83 e0 03             	and    $0x3,%eax
    1414:	29 d0                	sub    %edx,%eax
    1416:	ba 04 00 00 00       	mov    $0x4,%edx
    141b:	29 c2                	sub    %eax,%edx
    141d:	89 d0                	mov    %edx,%eax
    141f:	83 ec 04             	sub    $0x4,%esp
    1422:	50                   	push   %eax
    1423:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1426:	50                   	push   %eax
    1427:	ff 75 f0             	pushl  -0x10(%ebp)
    142a:	e8 8e f1 ff ff       	call   5bd <write>
    142f:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    1432:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1436:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    143a:	79 94                	jns    13d0 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    143c:	83 ec 0c             	sub    $0xc,%esp
    143f:	ff 75 f0             	pushl  -0x10(%ebp)
    1442:	e8 7e f1 ff ff       	call   5c5 <close>
    1447:	83 c4 10             	add    $0x10,%esp
    return 0;
    144a:	b8 00 00 00 00       	mov    $0x0,%eax
    144f:	c9                   	leave  
    1450:	c3                   	ret    

00001451 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    1451:	55                   	push   %ebp
    1452:	89 e5                	mov    %esp,%ebp
    1454:	57                   	push   %edi
    1455:	56                   	push   %esi
    1456:	53                   	push   %ebx
    1457:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    145a:	8b 45 08             	mov    0x8(%ebp),%eax
    145d:	8b 50 10             	mov    0x10(%eax),%edx
    1460:	8b 40 0c             	mov    0xc(%eax),%eax
    1463:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1466:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    146c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    146f:	83 c2 1e             	add    $0x1e,%edx
    1472:	0f af d0             	imul   %eax,%edx
    1475:	89 d0                	mov    %edx,%eax
    1477:	01 c0                	add    %eax,%eax
    1479:	01 d0                	add    %edx,%eax
    147b:	83 ec 0c             	sub    $0xc,%esp
    147e:	50                   	push   %eax
    147f:	e8 93 f5 ff ff       	call   a17 <malloc>
    1484:	83 c4 10             	add    $0x10,%esp
    1487:	89 c2                	mov    %eax,%edx
    1489:	8b 45 08             	mov    0x8(%ebp),%eax
    148c:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    148f:	8b 45 08             	mov    0x8(%ebp),%eax
    1492:	8b 40 1c             	mov    0x1c(%eax),%eax
    1495:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1498:	6b d2 5a             	imul   $0x5a,%edx,%edx
    149b:	01 c2                	add    %eax,%edx
    149d:	8b 45 08             	mov    0x8(%ebp),%eax
    14a0:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    14a3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    14a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    14a9:	0f af d0             	imul   %eax,%edx
    14ac:	89 d0                	mov    %edx,%eax
    14ae:	01 c0                	add    %eax,%eax
    14b0:	01 d0                	add    %edx,%eax
    14b2:	89 c2                	mov    %eax,%edx
    14b4:	8b 45 08             	mov    0x8(%ebp),%eax
    14b7:	8b 40 18             	mov    0x18(%eax),%eax
    14ba:	83 ec 04             	sub    $0x4,%esp
    14bd:	52                   	push   %edx
    14be:	68 ff 00 00 00       	push   $0xff
    14c3:	50                   	push   %eax
    14c4:	e8 39 ef ff ff       	call   402 <memset>
    14c9:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    14cc:	8b 45 08             	mov    0x8(%ebp),%eax
    14cf:	8b 78 1c             	mov    0x1c(%eax),%edi
    14d2:	8b 45 08             	mov    0x8(%ebp),%eax
    14d5:	8b 70 14             	mov    0x14(%eax),%esi
    14d8:	8b 45 08             	mov    0x8(%ebp),%eax
    14db:	8b 58 0c             	mov    0xc(%eax),%ebx
    14de:	8b 45 08             	mov    0x8(%ebp),%eax
    14e1:	8b 48 10             	mov    0x10(%eax),%ecx
    14e4:	8b 45 08             	mov    0x8(%ebp),%eax
    14e7:	8b 50 08             	mov    0x8(%eax),%edx
    14ea:	8b 45 08             	mov    0x8(%ebp),%eax
    14ed:	8b 40 04             	mov    0x4(%eax),%eax
    14f0:	83 ec 08             	sub    $0x8,%esp
    14f3:	57                   	push   %edi
    14f4:	56                   	push   %esi
    14f5:	53                   	push   %ebx
    14f6:	51                   	push   %ecx
    14f7:	52                   	push   %edx
    14f8:	50                   	push   %eax
    14f9:	e8 3f f1 ff ff       	call   63d <createwindow>
    14fe:	83 c4 20             	add    $0x20,%esp
    1501:	89 c2                	mov    %eax,%edx
    1503:	8b 45 08             	mov    0x8(%ebp),%eax
    1506:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    1508:	8b 45 08             	mov    0x8(%ebp),%eax
    150b:	8b 00                	mov    (%eax),%eax
}
    150d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1510:	5b                   	pop    %ebx
    1511:	5e                   	pop    %esi
    1512:	5f                   	pop    %edi
    1513:	5d                   	pop    %ebp
    1514:	c3                   	ret    

00001515 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    1515:	55                   	push   %ebp
    1516:	89 e5                	mov    %esp,%ebp
    1518:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    151b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1522:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1529:	8b 45 08             	mov    0x8(%ebp),%eax
    152c:	8b 40 18             	mov    0x18(%eax),%eax
    152f:	ff 75 1c             	pushl  0x1c(%ebp)
    1532:	ff 75 18             	pushl  0x18(%ebp)
    1535:	ff 75 1c             	pushl  0x1c(%ebp)
    1538:	ff 75 18             	pushl  0x18(%ebp)
    153b:	8b 55 08             	mov    0x8(%ebp),%edx
    153e:	ff 72 10             	pushl  0x10(%edx)
    1541:	ff 72 0c             	pushl  0xc(%edx)
    1544:	ff 75 f4             	pushl  -0xc(%ebp)
    1547:	ff 75 f0             	pushl  -0x10(%ebp)
    154a:	ff 75 14             	pushl  0x14(%ebp)
    154d:	ff 75 10             	pushl  0x10(%ebp)
    1550:	ff 75 0c             	pushl  0xc(%ebp)
    1553:	50                   	push   %eax
    1554:	e8 d5 07 00 00       	call   1d2e <drawBitmap>
    1559:	83 c4 30             	add    $0x30,%esp
    return 0;
    155c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1561:	c9                   	leave  
    1562:	c3                   	ret    

00001563 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1563:	55                   	push   %ebp
    1564:	89 e5                	mov    %esp,%ebp
    1566:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1569:	8b 45 08             	mov    0x8(%ebp),%eax
    156c:	8b 40 18             	mov    0x18(%eax),%eax
    156f:	ff 75 2c             	pushl  0x2c(%ebp)
    1572:	ff 75 28             	pushl  0x28(%ebp)
    1575:	ff 75 24             	pushl  0x24(%ebp)
    1578:	ff 75 20             	pushl  0x20(%ebp)
    157b:	8b 55 08             	mov    0x8(%ebp),%edx
    157e:	ff 72 10             	pushl  0x10(%edx)
    1581:	ff 72 0c             	pushl  0xc(%edx)
    1584:	ff 75 1c             	pushl  0x1c(%ebp)
    1587:	ff 75 18             	pushl  0x18(%ebp)
    158a:	ff 75 14             	pushl  0x14(%ebp)
    158d:	ff 75 10             	pushl  0x10(%ebp)
    1590:	ff 75 0c             	pushl  0xc(%ebp)
    1593:	50                   	push   %eax
    1594:	e8 95 07 00 00       	call   1d2e <drawBitmap>
    1599:	83 c4 30             	add    $0x30,%esp
    return 0;
    159c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15a1:	c9                   	leave  
    15a2:	c3                   	ret    

000015a3 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    15a3:	55                   	push   %ebp
    15a4:	89 e5                	mov    %esp,%ebp
    15a6:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    15a9:	8b 45 08             	mov    0x8(%ebp),%eax
    15ac:	8b 40 18             	mov    0x18(%eax),%eax
    15af:	ff 75 2c             	pushl  0x2c(%ebp)
    15b2:	ff 75 28             	pushl  0x28(%ebp)
    15b5:	ff 75 24             	pushl  0x24(%ebp)
    15b8:	ff 75 20             	pushl  0x20(%ebp)
    15bb:	8b 55 08             	mov    0x8(%ebp),%edx
    15be:	ff 72 10             	pushl  0x10(%edx)
    15c1:	ff 72 0c             	pushl  0xc(%edx)
    15c4:	ff 75 1c             	pushl  0x1c(%ebp)
    15c7:	ff 75 18             	pushl  0x18(%ebp)
    15ca:	ff 75 14             	pushl  0x14(%ebp)
    15cd:	ff 75 10             	pushl  0x10(%ebp)
    15d0:	ff 75 0c             	pushl  0xc(%ebp)
    15d3:	50                   	push   %eax
    15d4:	e8 75 08 00 00       	call   1e4e <drawTransparentBitmap>
    15d9:	83 c4 30             	add    $0x30,%esp
    return 0;
    15dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15e1:	c9                   	leave  
    15e2:	c3                   	ret    

000015e3 <api_repaint>:

int api_repaint(Window* wnd)
{
    15e3:	55                   	push   %ebp
    15e4:	89 e5                	mov    %esp,%ebp
    15e6:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    15e9:	8b 45 08             	mov    0x8(%ebp),%eax
    15ec:	8b 00                	mov    (%eax),%eax
    15ee:	83 ec 0c             	sub    $0xc,%esp
    15f1:	50                   	push   %eax
    15f2:	e8 4e f0 ff ff       	call   645 <repaintwindow>
    15f7:	83 c4 10             	add    $0x10,%esp
    return 0;
    15fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15ff:	c9                   	leave  
    1600:	c3                   	ret    

00001601 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    1601:	55                   	push   %ebp
    1602:	89 e5                	mov    %esp,%ebp
    1604:	56                   	push   %esi
    1605:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    1606:	8b 75 18             	mov    0x18(%ebp),%esi
    1609:	8b 5d 14             	mov    0x14(%ebp),%ebx
    160c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    160f:	8b 55 0c             	mov    0xc(%ebp),%edx
    1612:	8b 45 08             	mov    0x8(%ebp),%eax
    1615:	8b 00                	mov    (%eax),%eax
    1617:	83 ec 0c             	sub    $0xc,%esp
    161a:	56                   	push   %esi
    161b:	53                   	push   %ebx
    161c:	51                   	push   %ecx
    161d:	52                   	push   %edx
    161e:	50                   	push   %eax
    161f:	e8 39 f0 ff ff       	call   65d <updatewindow>
    1624:	83 c4 20             	add    $0x20,%esp
    return 0;
    1627:	b8 00 00 00 00       	mov    $0x0,%eax
}
    162c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    162f:	5b                   	pop    %ebx
    1630:	5e                   	pop    %esi
    1631:	5d                   	pop    %ebp
    1632:	c3                   	ret    

00001633 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    1633:	55                   	push   %ebp
    1634:	89 e5                	mov    %esp,%ebp
    1636:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1639:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    1640:	8b 45 08             	mov    0x8(%ebp),%eax
    1643:	8b 00                	mov    (%eax),%eax
    1645:	83 ec 08             	sub    $0x8,%esp
    1648:	8d 55 c8             	lea    -0x38(%ebp),%edx
    164b:	52                   	push   %edx
    164c:	50                   	push   %eax
    164d:	e8 fb ef ff ff       	call   64d <getmessage>
    1652:	83 c4 10             	add    $0x10,%esp
    1655:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1658:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    165c:	74 e2                	je     1640 <api_exec+0xd>
        {
            pf(&msg);
    165e:	83 ec 0c             	sub    $0xc,%esp
    1661:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1664:	50                   	push   %eax
    1665:	8b 45 0c             	mov    0xc(%ebp),%eax
    1668:	ff d0                	call   *%eax
    166a:	83 c4 10             	add    $0x10,%esp
        }
    }
    166d:	eb d1                	jmp    1640 <api_exec+0xd>

0000166f <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    166f:	55                   	push   %ebp
    1670:	89 e5                	mov    %esp,%ebp
    1672:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1675:	8b 45 08             	mov    0x8(%ebp),%eax
    1678:	8b 00                	mov    (%eax),%eax
    167a:	83 ec 08             	sub    $0x8,%esp
    167d:	ff 75 0c             	pushl  0xc(%ebp)
    1680:	50                   	push   %eax
    1681:	e8 cf ef ff ff       	call   655 <settimer>
    1686:	83 c4 10             	add    $0x10,%esp
    return 0;
    1689:	b8 00 00 00 00       	mov    $0x0,%eax
}
    168e:	c9                   	leave  
    168f:	c3                   	ret    

00001690 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    1690:	55                   	push   %ebp
    1691:	89 e5                	mov    %esp,%ebp
    1693:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    1696:	8b 45 08             	mov    0x8(%ebp),%eax
    1699:	8b 50 18             	mov    0x18(%eax),%edx
    169c:	ff 75 18             	pushl  0x18(%ebp)
    169f:	ff 75 14             	pushl  0x14(%ebp)
    16a2:	83 ec 04             	sub    $0x4,%esp
    16a5:	89 e0                	mov    %esp,%eax
    16a7:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    16ab:	66 89 08             	mov    %cx,(%eax)
    16ae:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    16b2:	88 48 02             	mov    %cl,0x2(%eax)
    16b5:	8b 45 08             	mov    0x8(%ebp),%eax
    16b8:	ff 70 10             	pushl  0x10(%eax)
    16bb:	ff 70 0c             	pushl  0xc(%eax)
    16be:	ff 75 10             	pushl  0x10(%ebp)
    16c1:	ff 75 0c             	pushl  0xc(%ebp)
    16c4:	52                   	push   %edx
    16c5:	e8 6f 04 00 00       	call   1b39 <drawRect>
    16ca:	83 c4 20             	add    $0x20,%esp
    return 0;
    16cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    16d2:	c9                   	leave  
    16d3:	c3                   	ret    

000016d4 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    16d4:	55                   	push   %ebp
    16d5:	89 e5                	mov    %esp,%ebp
    16d7:	83 ec 28             	sub    $0x28,%esp
    16da:	8b 45 14             	mov    0x14(%ebp),%eax
    16dd:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    16e0:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    16e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    16e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    16ea:	8b 45 10             	mov    0x10(%ebp),%eax
    16ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
    16f0:	8b 45 08             	mov    0x8(%ebp),%eax
    16f3:	8b 40 18             	mov    0x18(%eax),%eax
    16f6:	83 ec 04             	sub    $0x4,%esp
    16f9:	ff 75 18             	pushl  0x18(%ebp)
    16fc:	52                   	push   %edx
    16fd:	8b 55 08             	mov    0x8(%ebp),%edx
    1700:	ff 72 10             	pushl  0x10(%edx)
    1703:	ff 72 0c             	pushl  0xc(%edx)
    1706:	ff 75 f4             	pushl  -0xc(%ebp)
    1709:	ff 75 f0             	pushl  -0x10(%ebp)
    170c:	50                   	push   %eax
    170d:	e8 d4 02 00 00       	call   19e6 <drawCharacter>
    1712:	83 c4 20             	add    $0x20,%esp
    return 0;
    1715:	b8 00 00 00 00       	mov    $0x0,%eax
}
    171a:	c9                   	leave  
    171b:	c3                   	ret    

0000171c <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    171c:	55                   	push   %ebp
    171d:	89 e5                	mov    %esp,%ebp
    171f:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1722:	8b 45 0c             	mov    0xc(%ebp),%eax
    1725:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1728:	8b 45 10             	mov    0x10(%ebp),%eax
    172b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    172e:	8b 45 08             	mov    0x8(%ebp),%eax
    1731:	8b 40 18             	mov    0x18(%eax),%eax
    1734:	83 ec 04             	sub    $0x4,%esp
    1737:	ff 75 18             	pushl  0x18(%ebp)
    173a:	ff 75 14             	pushl  0x14(%ebp)
    173d:	8b 55 08             	mov    0x8(%ebp),%edx
    1740:	ff 72 10             	pushl  0x10(%edx)
    1743:	ff 72 0c             	pushl  0xc(%edx)
    1746:	ff 75 f4             	pushl  -0xc(%ebp)
    1749:	ff 75 f0             	pushl  -0x10(%ebp)
    174c:	50                   	push   %eax
    174d:	e8 8e 03 00 00       	call   1ae0 <drawString>
    1752:	83 c4 20             	add    $0x20,%esp
    return 0;
    1755:	b8 00 00 00 00       	mov    $0x0,%eax
}
    175a:	c9                   	leave  
    175b:	c3                   	ret    

0000175c <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    175c:	55                   	push   %ebp
    175d:	89 e5                	mov    %esp,%ebp
    175f:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    1762:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1766:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    176a:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    176e:	83 ec 08             	sub    $0x8,%esp
    1771:	83 ec 04             	sub    $0x4,%esp
    1774:	89 e0                	mov    %esp,%eax
    1776:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    177a:	66 89 10             	mov    %dx,(%eax)
    177d:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    1781:	88 50 02             	mov    %dl,0x2(%eax)
    1784:	ff 75 18             	pushl  0x18(%ebp)
    1787:	ff 75 14             	pushl  0x14(%ebp)
    178a:	ff 75 10             	pushl  0x10(%ebp)
    178d:	ff 75 0c             	pushl  0xc(%ebp)
    1790:	ff 75 08             	pushl  0x8(%ebp)
    1793:	e8 f8 fe ff ff       	call   1690 <api_drawRect>
    1798:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    179b:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    179f:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    17a3:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    17a7:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    17ab:	8b 45 10             	mov    0x10(%ebp),%eax
    17ae:	8d 50 0a             	lea    0xa(%eax),%edx
    17b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    17b4:	83 c0 0a             	add    $0xa,%eax
    17b7:	83 ec 0c             	sub    $0xc,%esp
    17ba:	ff 75 f4             	pushl  -0xc(%ebp)
    17bd:	ff 75 1c             	pushl  0x1c(%ebp)
    17c0:	52                   	push   %edx
    17c1:	50                   	push   %eax
    17c2:	ff 75 08             	pushl  0x8(%ebp)
    17c5:	e8 52 ff ff ff       	call   171c <api_drawString>
    17ca:	83 c4 20             	add    $0x20,%esp
    return 0;
    17cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    17d2:	c9                   	leave  
    17d3:	c3                   	ret    

000017d4 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    17d4:	55                   	push   %ebp
    17d5:	89 e5                	mov    %esp,%ebp
    17d7:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    17da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    17e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    17e8:	8b 45 08             	mov    0x8(%ebp),%eax
    17eb:	8b 40 18             	mov    0x18(%eax),%eax
    17ee:	ff 75 1c             	pushl  0x1c(%ebp)
    17f1:	ff 75 18             	pushl  0x18(%ebp)
    17f4:	ff 75 1c             	pushl  0x1c(%ebp)
    17f7:	ff 75 18             	pushl  0x18(%ebp)
    17fa:	8b 55 08             	mov    0x8(%ebp),%edx
    17fd:	ff 72 10             	pushl  0x10(%edx)
    1800:	ff 72 0c             	pushl  0xc(%edx)
    1803:	ff 75 f4             	pushl  -0xc(%ebp)
    1806:	ff 75 f0             	pushl  -0x10(%ebp)
    1809:	ff 75 14             	pushl  0x14(%ebp)
    180c:	ff 75 10             	pushl  0x10(%ebp)
    180f:	ff 75 0c             	pushl  0xc(%ebp)
    1812:	50                   	push   %eax
    1813:	e8 16 05 00 00       	call   1d2e <drawBitmap>
    1818:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    181b:	8b 45 08             	mov    0x8(%ebp),%eax
    181e:	8b 40 18             	mov    0x18(%eax),%eax
    1821:	ff 75 28             	pushl  0x28(%ebp)
    1824:	ff 75 1c             	pushl  0x1c(%ebp)
    1827:	ff 75 18             	pushl  0x18(%ebp)
    182a:	8b 55 08             	mov    0x8(%ebp),%edx
    182d:	ff 72 10             	pushl  0x10(%edx)
    1830:	ff 72 0c             	pushl  0xc(%edx)
    1833:	ff 75 14             	pushl  0x14(%ebp)
    1836:	ff 75 10             	pushl  0x10(%ebp)
    1839:	50                   	push   %eax
    183a:	e8 99 07 00 00       	call   1fd8 <colorShift>
    183f:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    1842:	8b 45 08             	mov    0x8(%ebp),%eax
    1845:	8b 50 18             	mov    0x18(%eax),%edx
    1848:	83 ec 0c             	sub    $0xc,%esp
    184b:	ff 75 20             	pushl  0x20(%ebp)
    184e:	ff 75 1c             	pushl  0x1c(%ebp)
    1851:	ff 75 18             	pushl  0x18(%ebp)
    1854:	83 ec 04             	sub    $0x4,%esp
    1857:	89 e0                	mov    %esp,%eax
    1859:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    185d:	66 89 08             	mov    %cx,(%eax)
    1860:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1864:	88 48 02             	mov    %cl,0x2(%eax)
    1867:	8b 45 08             	mov    0x8(%ebp),%eax
    186a:	ff 70 10             	pushl  0x10(%eax)
    186d:	ff 70 0c             	pushl  0xc(%eax)
    1870:	ff 75 14             	pushl  0x14(%ebp)
    1873:	ff 75 10             	pushl  0x10(%ebp)
    1876:	52                   	push   %edx
    1877:	e8 6d 03 00 00       	call   1be9 <drawBorder>
    187c:	83 c4 30             	add    $0x30,%esp
    return 0;
    187f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1884:	c9                   	leave  
    1885:	c3                   	ret    

00001886 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    1886:	55                   	push   %ebp
    1887:	89 e5                	mov    %esp,%ebp
    1889:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    188c:	8b 45 08             	mov    0x8(%ebp),%eax
    188f:	8b 00                	mov    (%eax),%eax
    1891:	83 ec 0c             	sub    $0xc,%esp
    1894:	50                   	push   %eax
    1895:	e8 cb ed ff ff       	call   665 <destroywindow>
    189a:	83 c4 10             	add    $0x10,%esp
    return 0;
    189d:	b8 00 00 00 00       	mov    $0x0,%eax
    18a2:	c9                   	leave  
    18a3:	c3                   	ret    

000018a4 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    18a4:	55                   	push   %ebp
    18a5:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    18a7:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    18ab:	8b 45 08             	mov    0x8(%ebp),%eax
    18ae:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    18b1:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    18b5:	8b 45 08             	mov    0x8(%ebp),%eax
    18b8:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    18bb:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    18bf:	8b 45 08             	mov    0x8(%ebp),%eax
    18c2:	88 10                	mov    %dl,(%eax)
}
    18c4:	90                   	nop
    18c5:	5d                   	pop    %ebp
    18c6:	c3                   	ret    

000018c7 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    18c7:	55                   	push   %ebp
    18c8:	89 e5                	mov    %esp,%ebp
    18ca:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    18cd:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    18d1:	3c ff                	cmp    $0xff,%al
    18d3:	75 22                	jne    18f7 <drawPointAlpha+0x30>
        color->R = origin.R;
    18d5:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    18d9:	8b 45 08             	mov    0x8(%ebp),%eax
    18dc:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    18df:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    18e3:	8b 45 08             	mov    0x8(%ebp),%eax
    18e6:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    18e9:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    18ed:	8b 45 08             	mov    0x8(%ebp),%eax
    18f0:	88 10                	mov    %dl,(%eax)
        return;
    18f2:	e9 ed 00 00 00       	jmp    19e4 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    18f7:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    18fb:	84 c0                	test   %al,%al
    18fd:	0f 84 e0 00 00 00    	je     19e3 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    1903:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1907:	0f b6 c0             	movzbl %al,%eax
    190a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    190e:	df 45 e4             	fild   -0x1c(%ebp)
    1911:	d9 05 a0 9f 01 00    	flds   0x19fa0
    1917:	de f9                	fdivrp %st,%st(1)
    1919:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    191c:	8b 45 08             	mov    0x8(%ebp),%eax
    191f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1923:	0f b6 c0             	movzbl %al,%eax
    1926:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1929:	db 45 e4             	fildl  -0x1c(%ebp)
    192c:	d9 e8                	fld1   
    192e:	d8 65 fc             	fsubs  -0x4(%ebp)
    1931:	de c9                	fmulp  %st,%st(1)
    1933:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1937:	0f b6 c0             	movzbl %al,%eax
    193a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    193d:	db 45 e4             	fildl  -0x1c(%ebp)
    1940:	d8 4d fc             	fmuls  -0x4(%ebp)
    1943:	de c1                	faddp  %st,%st(1)
    1945:	d9 7d ee             	fnstcw -0x12(%ebp)
    1948:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    194c:	b4 0c                	mov    $0xc,%ah
    194e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    1952:	d9 6d ec             	fldcw  -0x14(%ebp)
    1955:	df 5d ea             	fistp  -0x16(%ebp)
    1958:	d9 6d ee             	fldcw  -0x12(%ebp)
    195b:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    195f:	89 c2                	mov    %eax,%edx
    1961:	8b 45 08             	mov    0x8(%ebp),%eax
    1964:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1967:	8b 45 08             	mov    0x8(%ebp),%eax
    196a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    196e:	0f b6 c0             	movzbl %al,%eax
    1971:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1974:	db 45 e4             	fildl  -0x1c(%ebp)
    1977:	d9 e8                	fld1   
    1979:	d8 65 fc             	fsubs  -0x4(%ebp)
    197c:	de c9                	fmulp  %st,%st(1)
    197e:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    1982:	0f b6 c0             	movzbl %al,%eax
    1985:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1988:	db 45 e4             	fildl  -0x1c(%ebp)
    198b:	d8 4d fc             	fmuls  -0x4(%ebp)
    198e:	de c1                	faddp  %st,%st(1)
    1990:	d9 6d ec             	fldcw  -0x14(%ebp)
    1993:	df 5d ea             	fistp  -0x16(%ebp)
    1996:	d9 6d ee             	fldcw  -0x12(%ebp)
    1999:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    199d:	89 c2                	mov    %eax,%edx
    199f:	8b 45 08             	mov    0x8(%ebp),%eax
    19a2:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    19a5:	8b 45 08             	mov    0x8(%ebp),%eax
    19a8:	0f b6 00             	movzbl (%eax),%eax
    19ab:	0f b6 c0             	movzbl %al,%eax
    19ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    19b1:	db 45 e4             	fildl  -0x1c(%ebp)
    19b4:	d9 e8                	fld1   
    19b6:	d8 65 fc             	fsubs  -0x4(%ebp)
    19b9:	de c9                	fmulp  %st,%st(1)
    19bb:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    19bf:	0f b6 c0             	movzbl %al,%eax
    19c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    19c5:	db 45 e4             	fildl  -0x1c(%ebp)
    19c8:	d8 4d fc             	fmuls  -0x4(%ebp)
    19cb:	de c1                	faddp  %st,%st(1)
    19cd:	d9 6d ec             	fldcw  -0x14(%ebp)
    19d0:	df 5d ea             	fistp  -0x16(%ebp)
    19d3:	d9 6d ee             	fldcw  -0x12(%ebp)
    19d6:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    19da:	89 c2                	mov    %eax,%edx
    19dc:	8b 45 08             	mov    0x8(%ebp),%eax
    19df:	88 10                	mov    %dl,(%eax)
    19e1:	eb 01                	jmp    19e4 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    19e3:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    19e4:	c9                   	leave  
    19e5:	c3                   	ret    

000019e6 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    19e6:	55                   	push   %ebp
    19e7:	89 e5                	mov    %esp,%ebp
    19e9:	83 ec 14             	sub    $0x14,%esp
    19ec:	8b 45 1c             	mov    0x1c(%ebp),%eax
    19ef:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    19f2:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    19f6:	83 e8 20             	sub    $0x20,%eax
    19f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    19fc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1a00:	0f 88 d7 00 00 00    	js     1add <drawCharacter+0xf7>
    1a06:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1a0a:	0f 8f cd 00 00 00    	jg     1add <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1a10:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1a17:	e9 b5 00 00 00       	jmp    1ad1 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1a1c:	8b 55 10             	mov    0x10(%ebp),%edx
    1a1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1a22:	01 c2                	add    %eax,%edx
    1a24:	8b 45 14             	mov    0x14(%ebp),%eax
    1a27:	39 c2                	cmp    %eax,%edx
    1a29:	0f 8f af 00 00 00    	jg     1ade <drawCharacter+0xf8>
    1a2f:	8b 55 10             	mov    0x10(%ebp),%edx
    1a32:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1a35:	01 d0                	add    %edx,%eax
    1a37:	85 c0                	test   %eax,%eax
    1a39:	0f 88 9f 00 00 00    	js     1ade <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1a3f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1a46:	eb 7b                	jmp    1ac3 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1a48:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1a4b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1a4e:	89 d0                	mov    %edx,%eax
    1a50:	c1 e0 03             	shl    $0x3,%eax
    1a53:	01 d0                	add    %edx,%eax
    1a55:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1a5b:	01 c2                	add    %eax,%edx
    1a5d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1a60:	01 d0                	add    %edx,%eax
    1a62:	05 80 63 01 00       	add    $0x16380,%eax
    1a67:	0f b6 00             	movzbl (%eax),%eax
    1a6a:	3c 01                	cmp    $0x1,%al
    1a6c:	75 51                	jne    1abf <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    1a6e:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a71:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1a74:	01 c2                	add    %eax,%edx
    1a76:	8b 45 18             	mov    0x18(%ebp),%eax
    1a79:	39 c2                	cmp    %eax,%edx
    1a7b:	7f 50                	jg     1acd <drawCharacter+0xe7>
    1a7d:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a80:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1a83:	01 d0                	add    %edx,%eax
    1a85:	85 c0                	test   %eax,%eax
    1a87:	78 44                	js     1acd <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1a89:	8b 55 10             	mov    0x10(%ebp),%edx
    1a8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1a8f:	01 c2                	add    %eax,%edx
    1a91:	8b 45 18             	mov    0x18(%ebp),%eax
    1a94:	0f af c2             	imul   %edx,%eax
    1a97:	89 c2                	mov    %eax,%edx
    1a99:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a9c:	01 c2                	add    %eax,%edx
    1a9e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1aa1:	01 c2                	add    %eax,%edx
    1aa3:	89 d0                	mov    %edx,%eax
    1aa5:	01 c0                	add    %eax,%eax
    1aa7:	01 c2                	add    %eax,%edx
    1aa9:	8b 45 08             	mov    0x8(%ebp),%eax
    1aac:	01 d0                	add    %edx,%eax
    1aae:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    1ab1:	ff 75 20             	pushl  0x20(%ebp)
    1ab4:	ff 75 f0             	pushl  -0x10(%ebp)
    1ab7:	e8 0b fe ff ff       	call   18c7 <drawPointAlpha>
    1abc:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1abf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1ac3:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    1ac7:	0f 8e 7b ff ff ff    	jle    1a48 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1acd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1ad1:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1ad5:	0f 8e 41 ff ff ff    	jle    1a1c <drawCharacter+0x36>
    1adb:	eb 01                	jmp    1ade <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1add:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    1ade:	c9                   	leave  
    1adf:	c3                   	ret    

00001ae0 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    1ae0:	55                   	push   %ebp
    1ae1:	89 e5                	mov    %esp,%ebp
    1ae3:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1ae6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    1aed:	eb 3d                	jmp    1b2c <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    1aef:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1af2:	0f b6 00             	movzbl (%eax),%eax
    1af5:	0f be c0             	movsbl %al,%eax
    1af8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1afb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1afe:	01 ca                	add    %ecx,%edx
    1b00:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1b03:	8b 55 10             	mov    0x10(%ebp),%edx
    1b06:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1b09:	ff 75 20             	pushl  0x20(%ebp)
    1b0c:	50                   	push   %eax
    1b0d:	ff 75 18             	pushl  0x18(%ebp)
    1b10:	ff 75 14             	pushl  0x14(%ebp)
    1b13:	ff 75 f8             	pushl  -0x8(%ebp)
    1b16:	ff 75 f4             	pushl  -0xc(%ebp)
    1b19:	ff 75 08             	pushl  0x8(%ebp)
    1b1c:	e8 c5 fe ff ff       	call   19e6 <drawCharacter>
    1b21:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1b24:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1b28:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1b2c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b2f:	0f b6 00             	movzbl (%eax),%eax
    1b32:	84 c0                	test   %al,%al
    1b34:	75 b9                	jne    1aef <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1b36:	90                   	nop
    1b37:	c9                   	leave  
    1b38:	c3                   	ret    

00001b39 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1b39:	55                   	push   %ebp
    1b3a:	89 e5                	mov    %esp,%ebp
    1b3c:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1b3f:	8b 45 20             	mov    0x20(%ebp),%eax
    1b42:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1b45:	8b 45 24             	mov    0x24(%ebp),%eax
    1b48:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1b4b:	8b 55 14             	mov    0x14(%ebp),%edx
    1b4e:	8b 45 10             	mov    0x10(%ebp),%eax
    1b51:	29 c2                	sub    %eax,%edx
    1b53:	89 d0                	mov    %edx,%eax
    1b55:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1b58:	7d 0d                	jge    1b67 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1b5a:	8b 55 14             	mov    0x14(%ebp),%edx
    1b5d:	8b 45 10             	mov    0x10(%ebp),%eax
    1b60:	29 c2                	sub    %eax,%edx
    1b62:	89 d0                	mov    %edx,%eax
    1b64:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1b67:	8b 55 18             	mov    0x18(%ebp),%edx
    1b6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b6d:	29 c2                	sub    %eax,%edx
    1b6f:	89 d0                	mov    %edx,%eax
    1b71:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1b74:	7d 0d                	jge    1b83 <drawRect+0x4a>
        draw_w = s.w - p.x;
    1b76:	8b 55 18             	mov    0x18(%ebp),%edx
    1b79:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b7c:	29 c2                	sub    %eax,%edx
    1b7e:	89 d0                	mov    %edx,%eax
    1b80:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1b83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1b8a:	eb 52                	jmp    1bde <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1b8c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1b93:	eb 3d                	jmp    1bd2 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    1b95:	8b 55 10             	mov    0x10(%ebp),%edx
    1b98:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1b9b:	01 c2                	add    %eax,%edx
    1b9d:	8b 45 18             	mov    0x18(%ebp),%eax
    1ba0:	0f af c2             	imul   %edx,%eax
    1ba3:	89 c2                	mov    %eax,%edx
    1ba5:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ba8:	01 c2                	add    %eax,%edx
    1baa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1bad:	01 c2                	add    %eax,%edx
    1baf:	89 d0                	mov    %edx,%eax
    1bb1:	01 c0                	add    %eax,%eax
    1bb3:	01 c2                	add    %eax,%edx
    1bb5:	8b 45 08             	mov    0x8(%ebp),%eax
    1bb8:	01 d0                	add    %edx,%eax
    1bba:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    1bbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1bc0:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1bc4:	66 89 10             	mov    %dx,(%eax)
    1bc7:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1bcb:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1bce:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1bd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1bd5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1bd8:	7c bb                	jl     1b95 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1bda:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1bde:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1be1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1be4:	7c a6                	jl     1b8c <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1be6:	90                   	nop
    1be7:	c9                   	leave  
    1be8:	c3                   	ret    

00001be9 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1be9:	55                   	push   %ebp
    1bea:	89 e5                	mov    %esp,%ebp
    1bec:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    1bef:	8b 45 28             	mov    0x28(%ebp),%eax
    1bf2:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1bf5:	8b 45 24             	mov    0x24(%ebp),%eax
    1bf8:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1bfb:	ff 75 cc             	pushl  -0x34(%ebp)
    1bfe:	ff 75 c8             	pushl  -0x38(%ebp)
    1c01:	83 ec 04             	sub    $0x4,%esp
    1c04:	89 e0                	mov    %esp,%eax
    1c06:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1c0a:	66 89 10             	mov    %dx,(%eax)
    1c0d:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1c11:	88 50 02             	mov    %dl,0x2(%eax)
    1c14:	ff 75 18             	pushl  0x18(%ebp)
    1c17:	ff 75 14             	pushl  0x14(%ebp)
    1c1a:	ff 75 10             	pushl  0x10(%ebp)
    1c1d:	ff 75 0c             	pushl  0xc(%ebp)
    1c20:	ff 75 08             	pushl  0x8(%ebp)
    1c23:	e8 11 ff ff ff       	call   1b39 <drawRect>
    1c28:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1c2b:	8b 45 28             	mov    0x28(%ebp),%eax
    1c2e:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1c31:	8b 45 24             	mov    0x24(%ebp),%eax
    1c34:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1c37:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c3a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1c3d:	8b 55 10             	mov    0x10(%ebp),%edx
    1c40:	8b 45 20             	mov    0x20(%ebp),%eax
    1c43:	01 d0                	add    %edx,%eax
    1c45:	2b 45 28             	sub    0x28(%ebp),%eax
    1c48:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1c4b:	ff 75 d4             	pushl  -0x2c(%ebp)
    1c4e:	ff 75 d0             	pushl  -0x30(%ebp)
    1c51:	83 ec 04             	sub    $0x4,%esp
    1c54:	89 e0                	mov    %esp,%eax
    1c56:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1c5a:	66 89 10             	mov    %dx,(%eax)
    1c5d:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1c61:	88 50 02             	mov    %dl,0x2(%eax)
    1c64:	ff 75 18             	pushl  0x18(%ebp)
    1c67:	ff 75 14             	pushl  0x14(%ebp)
    1c6a:	ff 75 dc             	pushl  -0x24(%ebp)
    1c6d:	ff 75 d8             	pushl  -0x28(%ebp)
    1c70:	ff 75 08             	pushl  0x8(%ebp)
    1c73:	e8 c1 fe ff ff       	call   1b39 <drawRect>
    1c78:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1c7b:	8b 45 20             	mov    0x20(%ebp),%eax
    1c7e:	8b 55 28             	mov    0x28(%ebp),%edx
    1c81:	01 d2                	add    %edx,%edx
    1c83:	29 d0                	sub    %edx,%eax
    1c85:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1c88:	8b 45 28             	mov    0x28(%ebp),%eax
    1c8b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c91:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1c94:	8b 55 10             	mov    0x10(%ebp),%edx
    1c97:	8b 45 28             	mov    0x28(%ebp),%eax
    1c9a:	01 d0                	add    %edx,%eax
    1c9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1c9f:	ff 75 e4             	pushl  -0x1c(%ebp)
    1ca2:	ff 75 e0             	pushl  -0x20(%ebp)
    1ca5:	83 ec 04             	sub    $0x4,%esp
    1ca8:	89 e0                	mov    %esp,%eax
    1caa:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1cae:	66 89 10             	mov    %dx,(%eax)
    1cb1:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1cb5:	88 50 02             	mov    %dl,0x2(%eax)
    1cb8:	ff 75 18             	pushl  0x18(%ebp)
    1cbb:	ff 75 14             	pushl  0x14(%ebp)
    1cbe:	ff 75 ec             	pushl  -0x14(%ebp)
    1cc1:	ff 75 e8             	pushl  -0x18(%ebp)
    1cc4:	ff 75 08             	pushl  0x8(%ebp)
    1cc7:	e8 6d fe ff ff       	call   1b39 <drawRect>
    1ccc:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1ccf:	8b 45 20             	mov    0x20(%ebp),%eax
    1cd2:	8b 55 28             	mov    0x28(%ebp),%edx
    1cd5:	01 d2                	add    %edx,%edx
    1cd7:	29 d0                	sub    %edx,%eax
    1cd9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1cdc:	8b 45 28             	mov    0x28(%ebp),%eax
    1cdf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1ce2:	8b 55 0c             	mov    0xc(%ebp),%edx
    1ce5:	8b 45 24             	mov    0x24(%ebp),%eax
    1ce8:	01 d0                	add    %edx,%eax
    1cea:	2b 45 28             	sub    0x28(%ebp),%eax
    1ced:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1cf0:	8b 55 10             	mov    0x10(%ebp),%edx
    1cf3:	8b 45 28             	mov    0x28(%ebp),%eax
    1cf6:	01 d0                	add    %edx,%eax
    1cf8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1cfb:	ff 75 f4             	pushl  -0xc(%ebp)
    1cfe:	ff 75 f0             	pushl  -0x10(%ebp)
    1d01:	83 ec 04             	sub    $0x4,%esp
    1d04:	89 e0                	mov    %esp,%eax
    1d06:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1d0a:	66 89 10             	mov    %dx,(%eax)
    1d0d:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1d11:	88 50 02             	mov    %dl,0x2(%eax)
    1d14:	ff 75 18             	pushl  0x18(%ebp)
    1d17:	ff 75 14             	pushl  0x14(%ebp)
    1d1a:	ff 75 fc             	pushl  -0x4(%ebp)
    1d1d:	ff 75 f8             	pushl  -0x8(%ebp)
    1d20:	ff 75 08             	pushl  0x8(%ebp)
    1d23:	e8 11 fe ff ff       	call   1b39 <drawRect>
    1d28:	83 c4 20             	add    $0x20,%esp
}
    1d2b:	90                   	nop
    1d2c:	c9                   	leave  
    1d2d:	c3                   	ret    

00001d2e <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1d2e:	55                   	push   %ebp
    1d2f:	89 e5                	mov    %esp,%ebp
    1d31:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1d34:	8b 45 30             	mov    0x30(%ebp),%eax
    1d37:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1d3a:	8b 45 34             	mov    0x34(%ebp),%eax
    1d3d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1d40:	8b 55 20             	mov    0x20(%ebp),%edx
    1d43:	8b 45 14             	mov    0x14(%ebp),%eax
    1d46:	29 c2                	sub    %eax,%edx
    1d48:	89 d0                	mov    %edx,%eax
    1d4a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1d4d:	7d 0d                	jge    1d5c <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1d4f:	8b 55 20             	mov    0x20(%ebp),%edx
    1d52:	8b 45 14             	mov    0x14(%ebp),%eax
    1d55:	29 c2                	sub    %eax,%edx
    1d57:	89 d0                	mov    %edx,%eax
    1d59:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1d5c:	8b 55 28             	mov    0x28(%ebp),%edx
    1d5f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d62:	29 c2                	sub    %eax,%edx
    1d64:	89 d0                	mov    %edx,%eax
    1d66:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1d69:	7d 0d                	jge    1d78 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1d6b:	8b 55 28             	mov    0x28(%ebp),%edx
    1d6e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d71:	29 c2                	sub    %eax,%edx
    1d73:	89 d0                	mov    %edx,%eax
    1d75:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1d78:	8b 55 24             	mov    0x24(%ebp),%edx
    1d7b:	8b 45 10             	mov    0x10(%ebp),%eax
    1d7e:	29 c2                	sub    %eax,%edx
    1d80:	89 d0                	mov    %edx,%eax
    1d82:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1d85:	7d 0d                	jge    1d94 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1d87:	8b 55 24             	mov    0x24(%ebp),%edx
    1d8a:	8b 45 10             	mov    0x10(%ebp),%eax
    1d8d:	29 c2                	sub    %eax,%edx
    1d8f:	89 d0                	mov    %edx,%eax
    1d91:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1d94:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1d97:	8b 45 18             	mov    0x18(%ebp),%eax
    1d9a:	29 c2                	sub    %eax,%edx
    1d9c:	89 d0                	mov    %edx,%eax
    1d9e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1da1:	7d 0d                	jge    1db0 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1da3:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1da6:	8b 45 18             	mov    0x18(%ebp),%eax
    1da9:	29 c2                	sub    %eax,%edx
    1dab:	89 d0                	mov    %edx,%eax
    1dad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1db0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1db7:	e9 83 00 00 00       	jmp    1e3f <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1dbc:	8b 55 14             	mov    0x14(%ebp),%edx
    1dbf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dc2:	01 d0                	add    %edx,%eax
    1dc4:	85 c0                	test   %eax,%eax
    1dc6:	78 72                	js     1e3a <drawBitmap+0x10c>
    1dc8:	8b 55 14             	mov    0x14(%ebp),%edx
    1dcb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dce:	01 c2                	add    %eax,%edx
    1dd0:	8b 45 20             	mov    0x20(%ebp),%eax
    1dd3:	39 c2                	cmp    %eax,%edx
    1dd5:	7d 63                	jge    1e3a <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1dd7:	8b 55 14             	mov    0x14(%ebp),%edx
    1dda:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ddd:	01 c2                	add    %eax,%edx
    1ddf:	8b 45 24             	mov    0x24(%ebp),%eax
    1de2:	0f af c2             	imul   %edx,%eax
    1de5:	89 c2                	mov    %eax,%edx
    1de7:	8b 45 10             	mov    0x10(%ebp),%eax
    1dea:	01 c2                	add    %eax,%edx
    1dec:	89 d0                	mov    %edx,%eax
    1dee:	01 c0                	add    %eax,%eax
    1df0:	01 c2                	add    %eax,%edx
    1df2:	8b 45 08             	mov    0x8(%ebp),%eax
    1df5:	01 d0                	add    %edx,%eax
    1df7:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1dfa:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1dfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e00:	01 c2                	add    %eax,%edx
    1e02:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1e05:	0f af c2             	imul   %edx,%eax
    1e08:	89 c2                	mov    %eax,%edx
    1e0a:	8b 45 18             	mov    0x18(%ebp),%eax
    1e0d:	01 c2                	add    %eax,%edx
    1e0f:	89 d0                	mov    %edx,%eax
    1e11:	01 c0                	add    %eax,%eax
    1e13:	01 c2                	add    %eax,%edx
    1e15:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e18:	01 d0                	add    %edx,%eax
    1e1a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1e1d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1e20:	89 d0                	mov    %edx,%eax
    1e22:	01 c0                	add    %eax,%eax
    1e24:	01 d0                	add    %edx,%eax
    1e26:	83 ec 04             	sub    $0x4,%esp
    1e29:	50                   	push   %eax
    1e2a:	ff 75 e4             	pushl  -0x1c(%ebp)
    1e2d:	ff 75 e8             	pushl  -0x18(%ebp)
    1e30:	e8 23 e7 ff ff       	call   558 <memmove>
    1e35:	83 c4 10             	add    $0x10,%esp
    1e38:	eb 01                	jmp    1e3b <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1e3a:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1e3b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1e3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e42:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1e45:	0f 8c 71 ff ff ff    	jl     1dbc <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1e4b:	90                   	nop
    1e4c:	c9                   	leave  
    1e4d:	c3                   	ret    

00001e4e <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1e4e:	55                   	push   %ebp
    1e4f:	89 e5                	mov    %esp,%ebp
    1e51:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1e54:	8b 45 30             	mov    0x30(%ebp),%eax
    1e57:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1e5a:	8b 45 34             	mov    0x34(%ebp),%eax
    1e5d:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1e60:	8b 55 20             	mov    0x20(%ebp),%edx
    1e63:	8b 45 14             	mov    0x14(%ebp),%eax
    1e66:	29 c2                	sub    %eax,%edx
    1e68:	89 d0                	mov    %edx,%eax
    1e6a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e6d:	7d 0d                	jge    1e7c <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1e6f:	8b 55 20             	mov    0x20(%ebp),%edx
    1e72:	8b 45 14             	mov    0x14(%ebp),%eax
    1e75:	29 c2                	sub    %eax,%edx
    1e77:	89 d0                	mov    %edx,%eax
    1e79:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1e7c:	8b 55 28             	mov    0x28(%ebp),%edx
    1e7f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1e82:	29 c2                	sub    %eax,%edx
    1e84:	89 d0                	mov    %edx,%eax
    1e86:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e89:	7d 0d                	jge    1e98 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1e8b:	8b 55 28             	mov    0x28(%ebp),%edx
    1e8e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1e91:	29 c2                	sub    %eax,%edx
    1e93:	89 d0                	mov    %edx,%eax
    1e95:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1e98:	8b 55 24             	mov    0x24(%ebp),%edx
    1e9b:	8b 45 10             	mov    0x10(%ebp),%eax
    1e9e:	29 c2                	sub    %eax,%edx
    1ea0:	89 d0                	mov    %edx,%eax
    1ea2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1ea5:	7d 0d                	jge    1eb4 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1ea7:	8b 55 24             	mov    0x24(%ebp),%edx
    1eaa:	8b 45 10             	mov    0x10(%ebp),%eax
    1ead:	29 c2                	sub    %eax,%edx
    1eaf:	89 d0                	mov    %edx,%eax
    1eb1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1eb4:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1eb7:	8b 45 18             	mov    0x18(%ebp),%eax
    1eba:	29 c2                	sub    %eax,%edx
    1ebc:	89 d0                	mov    %edx,%eax
    1ebe:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1ec1:	7d 0d                	jge    1ed0 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1ec3:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ec6:	8b 45 18             	mov    0x18(%ebp),%eax
    1ec9:	29 c2                	sub    %eax,%edx
    1ecb:	89 d0                	mov    %edx,%eax
    1ecd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1ed0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1ed7:	e9 b8 00 00 00       	jmp    1f94 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1edc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1ee3:	e9 9c 00 00 00       	jmp    1f84 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1ee8:	8b 55 14             	mov    0x14(%ebp),%edx
    1eeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1eee:	01 c2                	add    %eax,%edx
    1ef0:	8b 45 24             	mov    0x24(%ebp),%eax
    1ef3:	0f af c2             	imul   %edx,%eax
    1ef6:	89 c2                	mov    %eax,%edx
    1ef8:	8b 45 10             	mov    0x10(%ebp),%eax
    1efb:	01 c2                	add    %eax,%edx
    1efd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f00:	01 c2                	add    %eax,%edx
    1f02:	89 d0                	mov    %edx,%eax
    1f04:	01 c0                	add    %eax,%eax
    1f06:	01 c2                	add    %eax,%edx
    1f08:	8b 45 08             	mov    0x8(%ebp),%eax
    1f0b:	01 d0                	add    %edx,%eax
    1f0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1f10:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1f13:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1f16:	01 c2                	add    %eax,%edx
    1f18:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1f1b:	0f af c2             	imul   %edx,%eax
    1f1e:	89 c2                	mov    %eax,%edx
    1f20:	8b 45 18             	mov    0x18(%ebp),%eax
    1f23:	01 c2                	add    %eax,%edx
    1f25:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f28:	01 c2                	add    %eax,%edx
    1f2a:	89 d0                	mov    %edx,%eax
    1f2c:	01 c0                	add    %eax,%eax
    1f2e:	01 c2                	add    %eax,%edx
    1f30:	8b 45 0c             	mov    0xc(%ebp),%eax
    1f33:	01 d0                	add    %edx,%eax
    1f35:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1f38:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f3b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1f3f:	3c ff                	cmp    $0xff,%al
    1f41:	75 15                	jne    1f58 <drawTransparentBitmap+0x10a>
    1f43:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f46:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1f4a:	3c ff                	cmp    $0xff,%al
    1f4c:	75 0a                	jne    1f58 <drawTransparentBitmap+0x10a>
    1f4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f51:	0f b6 00             	movzbl (%eax),%eax
    1f54:	3c ff                	cmp    $0xff,%al
    1f56:	74 27                	je     1f7f <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1f58:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f5b:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1f5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f62:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1f65:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f68:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1f6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f6f:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1f72:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f75:	0f b6 10             	movzbl (%eax),%edx
    1f78:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f7b:	88 10                	mov    %dl,(%eax)
    1f7d:	eb 01                	jmp    1f80 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1f7f:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1f80:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1f84:	8b 45 34             	mov    0x34(%ebp),%eax
    1f87:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1f8a:	0f 8f 58 ff ff ff    	jg     1ee8 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1f90:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1f94:	8b 45 30             	mov    0x30(%ebp),%eax
    1f97:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1f9a:	0f 8f 3c ff ff ff    	jg     1edc <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1fa0:	90                   	nop
    1fa1:	c9                   	leave  
    1fa2:	c3                   	ret    

00001fa3 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1fa3:	55                   	push   %ebp
    1fa4:	89 e5                	mov    %esp,%ebp
    1fa6:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1fa9:	ff 75 24             	pushl  0x24(%ebp)
    1fac:	ff 75 20             	pushl  0x20(%ebp)
    1faf:	ff 75 1c             	pushl  0x1c(%ebp)
    1fb2:	ff 75 18             	pushl  0x18(%ebp)
    1fb5:	ff 75 1c             	pushl  0x1c(%ebp)
    1fb8:	ff 75 18             	pushl  0x18(%ebp)
    1fbb:	ff 75 14             	pushl  0x14(%ebp)
    1fbe:	ff 75 10             	pushl  0x10(%ebp)
    1fc1:	ff 75 14             	pushl  0x14(%ebp)
    1fc4:	ff 75 10             	pushl  0x10(%ebp)
    1fc7:	ff 75 0c             	pushl  0xc(%ebp)
    1fca:	ff 75 08             	pushl  0x8(%ebp)
    1fcd:	e8 5c fd ff ff       	call   1d2e <drawBitmap>
    1fd2:	83 c4 30             	add    $0x30,%esp
}
    1fd5:	90                   	nop
    1fd6:	c9                   	leave  
    1fd7:	c3                   	ret    

00001fd8 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1fd8:	55                   	push   %ebp
    1fd9:	89 e5                	mov    %esp,%ebp
    1fdb:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1fde:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1fe1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1fe4:	8b 45 20             	mov    0x20(%ebp),%eax
    1fe7:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1fea:	8b 55 14             	mov    0x14(%ebp),%edx
    1fed:	8b 45 10             	mov    0x10(%ebp),%eax
    1ff0:	29 c2                	sub    %eax,%edx
    1ff2:	89 d0                	mov    %edx,%eax
    1ff4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1ff7:	7d 0d                	jge    2006 <colorShift+0x2e>
        draw_h = s.h - p.y;
    1ff9:	8b 55 14             	mov    0x14(%ebp),%edx
    1ffc:	8b 45 10             	mov    0x10(%ebp),%eax
    1fff:	29 c2                	sub    %eax,%edx
    2001:	89 d0                	mov    %edx,%eax
    2003:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    2006:	8b 55 18             	mov    0x18(%ebp),%edx
    2009:	8b 45 0c             	mov    0xc(%ebp),%eax
    200c:	29 c2                	sub    %eax,%edx
    200e:	89 d0                	mov    %edx,%eax
    2010:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2013:	7d 0d                	jge    2022 <colorShift+0x4a>
        draw_w = s.w - p.x;
    2015:	8b 55 18             	mov    0x18(%ebp),%edx
    2018:	8b 45 0c             	mov    0xc(%ebp),%eax
    201b:	29 c2                	sub    %eax,%edx
    201d:	89 d0                	mov    %edx,%eax
    201f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2022:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2029:	e9 fc 00 00 00       	jmp    212a <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    202e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2035:	e9 e0 00 00 00       	jmp    211a <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    203a:	8b 55 10             	mov    0x10(%ebp),%edx
    203d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2040:	01 c2                	add    %eax,%edx
    2042:	8b 45 18             	mov    0x18(%ebp),%eax
    2045:	0f af c2             	imul   %edx,%eax
    2048:	89 c2                	mov    %eax,%edx
    204a:	8b 45 0c             	mov    0xc(%ebp),%eax
    204d:	01 c2                	add    %eax,%edx
    204f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2052:	01 c2                	add    %eax,%edx
    2054:	89 d0                	mov    %edx,%eax
    2056:	01 c0                	add    %eax,%eax
    2058:	01 c2                	add    %eax,%edx
    205a:	8b 45 08             	mov    0x8(%ebp),%eax
    205d:	01 d0                	add    %edx,%eax
    205f:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    2062:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2065:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2069:	3c c8                	cmp    $0xc8,%al
    206b:	0f 86 a5 00 00 00    	jbe    2116 <colorShift+0x13e>
    2071:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2074:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2078:	3c c8                	cmp    $0xc8,%al
    207a:	0f 86 96 00 00 00    	jbe    2116 <colorShift+0x13e>
    2080:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2083:	0f b6 00             	movzbl (%eax),%eax
    2086:	3c c8                	cmp    $0xc8,%al
    2088:	0f 86 88 00 00 00    	jbe    2116 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    208e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2091:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2095:	0f b6 d0             	movzbl %al,%edx
    2098:	8b 45 24             	mov    0x24(%ebp),%eax
    209b:	01 d0                	add    %edx,%eax
    209d:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    20a3:	89 d0                	mov    %edx,%eax
    20a5:	c1 f8 1f             	sar    $0x1f,%eax
    20a8:	c1 e8 18             	shr    $0x18,%eax
    20ab:	01 c2                	add    %eax,%edx
    20ad:	0f b6 d2             	movzbl %dl,%edx
    20b0:	29 c2                	sub    %eax,%edx
    20b2:	89 d0                	mov    %edx,%eax
    20b4:	89 c2                	mov    %eax,%edx
    20b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20b9:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    20bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20bf:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    20c3:	0f b6 d0             	movzbl %al,%edx
    20c6:	8b 45 24             	mov    0x24(%ebp),%eax
    20c9:	01 d0                	add    %edx,%eax
    20cb:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    20d1:	89 d0                	mov    %edx,%eax
    20d3:	c1 f8 1f             	sar    $0x1f,%eax
    20d6:	c1 e8 18             	shr    $0x18,%eax
    20d9:	01 c2                	add    %eax,%edx
    20db:	0f b6 d2             	movzbl %dl,%edx
    20de:	29 c2                	sub    %eax,%edx
    20e0:	89 d0                	mov    %edx,%eax
    20e2:	89 c2                	mov    %eax,%edx
    20e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20e7:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    20ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20ed:	0f b6 00             	movzbl (%eax),%eax
    20f0:	0f b6 d0             	movzbl %al,%edx
    20f3:	8b 45 24             	mov    0x24(%ebp),%eax
    20f6:	01 d0                	add    %edx,%eax
    20f8:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    20fe:	89 d0                	mov    %edx,%eax
    2100:	c1 f8 1f             	sar    $0x1f,%eax
    2103:	c1 e8 18             	shr    $0x18,%eax
    2106:	01 c2                	add    %eax,%edx
    2108:	0f b6 d2             	movzbl %dl,%edx
    210b:	29 c2                	sub    %eax,%edx
    210d:	89 d0                	mov    %edx,%eax
    210f:	89 c2                	mov    %eax,%edx
    2111:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2114:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    2116:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    211a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    211d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2120:	0f 8c 14 ff ff ff    	jl     203a <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    2126:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    212a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    212d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2130:	0f 8c f8 fe ff ff    	jl     202e <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    2136:	90                   	nop
    2137:	c9                   	leave  
    2138:	c3                   	ret    

00002139 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    2139:	55                   	push   %ebp
    213a:	89 e5                	mov    %esp,%ebp
    213c:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    213f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2146:	e9 fb 00 00 00       	jmp    2246 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    214b:	8b 55 14             	mov    0x14(%ebp),%edx
    214e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2151:	01 c2                	add    %eax,%edx
    2153:	0f b7 05 96 e8 01 00 	movzwl 0x1e896,%eax
    215a:	0f b7 c0             	movzwl %ax,%eax
    215d:	39 c2                	cmp    %eax,%edx
    215f:	0f 8f eb 00 00 00    	jg     2250 <drawMouse+0x117>
    2165:	8b 55 14             	mov    0x14(%ebp),%edx
    2168:	8b 45 fc             	mov    -0x4(%ebp),%eax
    216b:	01 d0                	add    %edx,%eax
    216d:	85 c0                	test   %eax,%eax
    216f:	0f 88 db 00 00 00    	js     2250 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2175:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    217c:	e9 b7 00 00 00       	jmp    2238 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    2181:	8b 55 10             	mov    0x10(%ebp),%edx
    2184:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2187:	01 c2                	add    %eax,%edx
    2189:	0f b7 05 94 e8 01 00 	movzwl 0x1e894,%eax
    2190:	0f b7 c0             	movzwl %ax,%eax
    2193:	39 c2                	cmp    %eax,%edx
    2195:	0f 8f a7 00 00 00    	jg     2242 <drawMouse+0x109>
    219b:	8b 55 10             	mov    0x10(%ebp),%edx
    219e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    21a1:	01 d0                	add    %edx,%eax
    21a3:	85 c0                	test   %eax,%eax
    21a5:	0f 88 97 00 00 00    	js     2242 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    21ab:	8b 55 fc             	mov    -0x4(%ebp),%edx
    21ae:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    21b1:	89 d0                	mov    %edx,%eax
    21b3:	c1 e0 04             	shl    $0x4,%eax
    21b6:	29 d0                	sub    %edx,%eax
    21b8:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    21be:	01 c2                	add    %eax,%edx
    21c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    21c3:	01 d0                	add    %edx,%eax
    21c5:	05 60 61 01 00       	add    $0x16160,%eax
    21ca:	0f b6 00             	movzbl (%eax),%eax
    21cd:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    21d0:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    21d4:	74 5e                	je     2234 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    21d6:	8b 55 14             	mov    0x14(%ebp),%edx
    21d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    21dc:	01 c2                	add    %eax,%edx
    21de:	0f b7 05 94 e8 01 00 	movzwl 0x1e894,%eax
    21e5:	0f b7 c0             	movzwl %ax,%eax
    21e8:	0f af c2             	imul   %edx,%eax
    21eb:	89 c2                	mov    %eax,%edx
    21ed:	8b 45 10             	mov    0x10(%ebp),%eax
    21f0:	01 c2                	add    %eax,%edx
    21f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    21f5:	01 c2                	add    %eax,%edx
    21f7:	89 d0                	mov    %edx,%eax
    21f9:	01 c0                	add    %eax,%eax
    21fb:	01 c2                	add    %eax,%edx
    21fd:	8b 45 08             	mov    0x8(%ebp),%eax
    2200:	01 d0                	add    %edx,%eax
    2202:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    2205:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    2209:	8d 50 ff             	lea    -0x1(%eax),%edx
    220c:	89 d0                	mov    %edx,%eax
    220e:	01 c0                	add    %eax,%eax
    2210:	01 d0                	add    %edx,%eax
    2212:	05 9c e8 01 00       	add    $0x1e89c,%eax
    2217:	83 ec 04             	sub    $0x4,%esp
    221a:	89 e2                	mov    %esp,%edx
    221c:	0f b7 08             	movzwl (%eax),%ecx
    221f:	66 89 0a             	mov    %cx,(%edx)
    2222:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2226:	88 42 02             	mov    %al,0x2(%edx)
    2229:	ff 75 f0             	pushl  -0x10(%ebp)
    222c:	e8 73 f6 ff ff       	call   18a4 <drawPoint>
    2231:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2234:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2238:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    223c:	0f 8e 3f ff ff ff    	jle    2181 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    2242:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2246:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    224a:	0f 8e fb fe ff ff    	jle    214b <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    2250:	90                   	nop
    2251:	c9                   	leave  
    2252:	c3                   	ret    

00002253 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    2253:	55                   	push   %ebp
    2254:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    2256:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    225a:	78 1b                	js     2277 <getColor+0x24>
    225c:	8b 45 08             	mov    0x8(%ebp),%eax
    225f:	8b 40 04             	mov    0x4(%eax),%eax
    2262:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2265:	7c 10                	jl     2277 <getColor+0x24>
    2267:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    226b:	78 0a                	js     2277 <getColor+0x24>
    226d:	8b 45 08             	mov    0x8(%ebp),%eax
    2270:	8b 00                	mov    (%eax),%eax
    2272:	3b 45 10             	cmp    0x10(%ebp),%eax
    2275:	7d 10                	jge    2287 <getColor+0x34>
    {
        *isInPic = 1;
    2277:	8b 45 14             	mov    0x14(%ebp),%eax
    227a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    2280:	b8 31 e4 01 00       	mov    $0x1e431,%eax
    2285:	eb 44                	jmp    22cb <getColor+0x78>
    }

    if (y == pic->height)
    2287:	8b 45 08             	mov    0x8(%ebp),%eax
    228a:	8b 40 04             	mov    0x4(%eax),%eax
    228d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2290:	75 04                	jne    2296 <getColor+0x43>
        y--;
    2292:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    2296:	8b 45 08             	mov    0x8(%ebp),%eax
    2299:	8b 00                	mov    (%eax),%eax
    229b:	3b 45 10             	cmp    0x10(%ebp),%eax
    229e:	75 04                	jne    22a4 <getColor+0x51>
        x--;
    22a0:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    22a4:	8b 45 14             	mov    0x14(%ebp),%eax
    22a7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    22ad:	8b 45 08             	mov    0x8(%ebp),%eax
    22b0:	8b 48 08             	mov    0x8(%eax),%ecx
    22b3:	8b 45 08             	mov    0x8(%ebp),%eax
    22b6:	8b 00                	mov    (%eax),%eax
    22b8:	0f af 45 0c          	imul   0xc(%ebp),%eax
    22bc:	89 c2                	mov    %eax,%edx
    22be:	8b 45 10             	mov    0x10(%ebp),%eax
    22c1:	01 c2                	add    %eax,%edx
    22c3:	89 d0                	mov    %edx,%eax
    22c5:	01 c0                	add    %eax,%eax
    22c7:	01 d0                	add    %edx,%eax
    22c9:	01 c8                	add    %ecx,%eax
}
    22cb:	5d                   	pop    %ebp
    22cc:	c3                   	ret    

000022cd <setColor>:

int setColor(RGB *src, RGB *dst)
{
    22cd:	55                   	push   %ebp
    22ce:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    22d0:	8b 45 08             	mov    0x8(%ebp),%eax
    22d3:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    22d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    22da:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    22dd:	8b 45 08             	mov    0x8(%ebp),%eax
    22e0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    22e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    22e7:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    22ea:	8b 45 08             	mov    0x8(%ebp),%eax
    22ed:	0f b6 10             	movzbl (%eax),%edx
    22f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    22f3:	88 10                	mov    %dl,(%eax)

    return 1;
    22f5:	b8 01 00 00 00       	mov    $0x1,%eax
}
    22fa:	5d                   	pop    %ebp
    22fb:	c3                   	ret    

000022fc <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    22fc:	55                   	push   %ebp
    22fd:	89 e5                	mov    %esp,%ebp
    22ff:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    2302:	d9 45 10             	flds   0x10(%ebp)
    2305:	d9 7d be             	fnstcw -0x42(%ebp)
    2308:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    230c:	b4 0c                	mov    $0xc,%ah
    230e:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2312:	d9 6d bc             	fldcw  -0x44(%ebp)
    2315:	db 5d fc             	fistpl -0x4(%ebp)
    2318:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    231b:	d9 45 0c             	flds   0xc(%ebp)
    231e:	d9 6d bc             	fldcw  -0x44(%ebp)
    2321:	db 5d f8             	fistpl -0x8(%ebp)
    2324:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2327:	db 45 fc             	fildl  -0x4(%ebp)
    232a:	d9 45 10             	flds   0x10(%ebp)
    232d:	d9 c9                	fxch   %st(1)
    232f:	df e9                	fucomip %st(1),%st
    2331:	dd d8                	fstp   %st(0)
    2333:	76 04                	jbe    2339 <mixColor+0x3d>
        x--;
    2335:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2339:	db 45 f8             	fildl  -0x8(%ebp)
    233c:	d9 45 0c             	flds   0xc(%ebp)
    233f:	d9 c9                	fxch   %st(1)
    2341:	df e9                	fucomip %st(1),%st
    2343:	dd d8                	fstp   %st(0)
    2345:	76 04                	jbe    234b <mixColor+0x4f>
        y--;
    2347:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    234b:	8d 45 c0             	lea    -0x40(%ebp),%eax
    234e:	50                   	push   %eax
    234f:	ff 75 fc             	pushl  -0x4(%ebp)
    2352:	ff 75 f8             	pushl  -0x8(%ebp)
    2355:	ff 75 08             	pushl  0x8(%ebp)
    2358:	e8 f6 fe ff ff       	call   2253 <getColor>
    235d:	83 c4 10             	add    $0x10,%esp
    2360:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2363:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2366:	83 c0 01             	add    $0x1,%eax
    2369:	8d 55 c0             	lea    -0x40(%ebp),%edx
    236c:	83 c2 04             	add    $0x4,%edx
    236f:	52                   	push   %edx
    2370:	ff 75 fc             	pushl  -0x4(%ebp)
    2373:	50                   	push   %eax
    2374:	ff 75 08             	pushl  0x8(%ebp)
    2377:	e8 d7 fe ff ff       	call   2253 <getColor>
    237c:	83 c4 10             	add    $0x10,%esp
    237f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2382:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2385:	83 c0 01             	add    $0x1,%eax
    2388:	8d 55 c0             	lea    -0x40(%ebp),%edx
    238b:	83 c2 08             	add    $0x8,%edx
    238e:	52                   	push   %edx
    238f:	50                   	push   %eax
    2390:	ff 75 f8             	pushl  -0x8(%ebp)
    2393:	ff 75 08             	pushl  0x8(%ebp)
    2396:	e8 b8 fe ff ff       	call   2253 <getColor>
    239b:	83 c4 10             	add    $0x10,%esp
    239e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    23a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    23a4:	8d 50 01             	lea    0x1(%eax),%edx
    23a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    23aa:	83 c0 01             	add    $0x1,%eax
    23ad:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    23b0:	83 c1 0c             	add    $0xc,%ecx
    23b3:	51                   	push   %ecx
    23b4:	52                   	push   %edx
    23b5:	50                   	push   %eax
    23b6:	ff 75 08             	pushl  0x8(%ebp)
    23b9:	e8 95 fe ff ff       	call   2253 <getColor>
    23be:	83 c4 10             	add    $0x10,%esp
    23c1:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    23c4:	db 45 fc             	fildl  -0x4(%ebp)
    23c7:	d9 45 10             	flds   0x10(%ebp)
    23ca:	de e1                	fsubp  %st,%st(1)
    23cc:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    23cf:	db 45 f8             	fildl  -0x8(%ebp)
    23d2:	d9 45 0c             	flds   0xc(%ebp)
    23d5:	de e1                	fsubp  %st,%st(1)
    23d7:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    23da:	d9 45 e4             	flds   -0x1c(%ebp)
    23dd:	d8 4d e0             	fmuls  -0x20(%ebp)
    23e0:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    23e3:	d9 e8                	fld1   
    23e5:	d8 65 e0             	fsubs  -0x20(%ebp)
    23e8:	d8 4d e4             	fmuls  -0x1c(%ebp)
    23eb:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    23ee:	d9 e8                	fld1   
    23f0:	d8 65 e4             	fsubs  -0x1c(%ebp)
    23f3:	d8 4d e0             	fmuls  -0x20(%ebp)
    23f6:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    23f9:	d9 e8                	fld1   
    23fb:	d8 65 e4             	fsubs  -0x1c(%ebp)
    23fe:	d9 e8                	fld1   
    2400:	d8 65 e0             	fsubs  -0x20(%ebp)
    2403:	de c9                	fmulp  %st,%st(1)
    2405:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    2408:	8b 45 f4             	mov    -0xc(%ebp),%eax
    240b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    240f:	0f b6 c0             	movzbl %al,%eax
    2412:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2415:	db 45 b4             	fildl  -0x4c(%ebp)
    2418:	d8 4d d0             	fmuls  -0x30(%ebp)
    241b:	8b 45 c0             	mov    -0x40(%ebp),%eax
    241e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2421:	db 45 b4             	fildl  -0x4c(%ebp)
    2424:	de c9                	fmulp  %st,%st(1)
    2426:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2429:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    242d:	0f b6 c0             	movzbl %al,%eax
    2430:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2433:	db 45 b4             	fildl  -0x4c(%ebp)
    2436:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2439:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    243c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    243f:	db 45 b4             	fildl  -0x4c(%ebp)
    2442:	de c9                	fmulp  %st,%st(1)
    2444:	de c1                	faddp  %st,%st(1)
    2446:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2449:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    244d:	0f b6 c0             	movzbl %al,%eax
    2450:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2453:	db 45 b4             	fildl  -0x4c(%ebp)
    2456:	d8 4d d8             	fmuls  -0x28(%ebp)
    2459:	8b 45 c8             	mov    -0x38(%ebp),%eax
    245c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    245f:	db 45 b4             	fildl  -0x4c(%ebp)
    2462:	de c9                	fmulp  %st,%st(1)
    2464:	de c1                	faddp  %st,%st(1)
    2466:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2469:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    246d:	0f b6 c0             	movzbl %al,%eax
    2470:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2473:	db 45 b4             	fildl  -0x4c(%ebp)
    2476:	d8 4d dc             	fmuls  -0x24(%ebp)
    2479:	8b 45 cc             	mov    -0x34(%ebp),%eax
    247c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    247f:	db 45 b4             	fildl  -0x4c(%ebp)
    2482:	de c9                	fmulp  %st,%st(1)
    2484:	de c1                	faddp  %st,%st(1)
    2486:	d9 7d be             	fnstcw -0x42(%ebp)
    2489:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    248d:	b4 0c                	mov    $0xc,%ah
    248f:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2493:	d9 6d bc             	fldcw  -0x44(%ebp)
    2496:	db 5d b8             	fistpl -0x48(%ebp)
    2499:	d9 6d be             	fldcw  -0x42(%ebp)
    249c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    249f:	89 c2                	mov    %eax,%edx
    24a1:	8b 45 14             	mov    0x14(%ebp),%eax
    24a4:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    24a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    24aa:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24ae:	0f b6 c0             	movzbl %al,%eax
    24b1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24b4:	db 45 b4             	fildl  -0x4c(%ebp)
    24b7:	d8 4d d0             	fmuls  -0x30(%ebp)
    24ba:	8b 45 c0             	mov    -0x40(%ebp),%eax
    24bd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24c0:	db 45 b4             	fildl  -0x4c(%ebp)
    24c3:	de c9                	fmulp  %st,%st(1)
    24c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24c8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24cc:	0f b6 c0             	movzbl %al,%eax
    24cf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24d2:	db 45 b4             	fildl  -0x4c(%ebp)
    24d5:	d8 4d d4             	fmuls  -0x2c(%ebp)
    24d8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    24db:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24de:	db 45 b4             	fildl  -0x4c(%ebp)
    24e1:	de c9                	fmulp  %st,%st(1)
    24e3:	de c1                	faddp  %st,%st(1)
    24e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24e8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24ec:	0f b6 c0             	movzbl %al,%eax
    24ef:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24f2:	db 45 b4             	fildl  -0x4c(%ebp)
    24f5:	d8 4d d8             	fmuls  -0x28(%ebp)
    24f8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    24fb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24fe:	db 45 b4             	fildl  -0x4c(%ebp)
    2501:	de c9                	fmulp  %st,%st(1)
    2503:	de c1                	faddp  %st,%st(1)
    2505:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2508:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    250c:	0f b6 c0             	movzbl %al,%eax
    250f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2512:	db 45 b4             	fildl  -0x4c(%ebp)
    2515:	d8 4d dc             	fmuls  -0x24(%ebp)
    2518:	8b 45 cc             	mov    -0x34(%ebp),%eax
    251b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    251e:	db 45 b4             	fildl  -0x4c(%ebp)
    2521:	de c9                	fmulp  %st,%st(1)
    2523:	de c1                	faddp  %st,%st(1)
    2525:	d9 6d bc             	fldcw  -0x44(%ebp)
    2528:	db 5d b8             	fistpl -0x48(%ebp)
    252b:	d9 6d be             	fldcw  -0x42(%ebp)
    252e:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2531:	89 c2                	mov    %eax,%edx
    2533:	8b 45 14             	mov    0x14(%ebp),%eax
    2536:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2539:	8b 45 f4             	mov    -0xc(%ebp),%eax
    253c:	0f b6 00             	movzbl (%eax),%eax
    253f:	0f b6 c0             	movzbl %al,%eax
    2542:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2545:	db 45 b4             	fildl  -0x4c(%ebp)
    2548:	d8 4d d0             	fmuls  -0x30(%ebp)
    254b:	8b 45 c0             	mov    -0x40(%ebp),%eax
    254e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2551:	db 45 b4             	fildl  -0x4c(%ebp)
    2554:	de c9                	fmulp  %st,%st(1)
    2556:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2559:	0f b6 00             	movzbl (%eax),%eax
    255c:	0f b6 c0             	movzbl %al,%eax
    255f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2562:	db 45 b4             	fildl  -0x4c(%ebp)
    2565:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2568:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    256b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    256e:	db 45 b4             	fildl  -0x4c(%ebp)
    2571:	de c9                	fmulp  %st,%st(1)
    2573:	de c1                	faddp  %st,%st(1)
    2575:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2578:	0f b6 00             	movzbl (%eax),%eax
    257b:	0f b6 c0             	movzbl %al,%eax
    257e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2581:	db 45 b4             	fildl  -0x4c(%ebp)
    2584:	d8 4d d8             	fmuls  -0x28(%ebp)
    2587:	8b 45 c8             	mov    -0x38(%ebp),%eax
    258a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    258d:	db 45 b4             	fildl  -0x4c(%ebp)
    2590:	de c9                	fmulp  %st,%st(1)
    2592:	de c1                	faddp  %st,%st(1)
    2594:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2597:	0f b6 00             	movzbl (%eax),%eax
    259a:	0f b6 c0             	movzbl %al,%eax
    259d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25a0:	db 45 b4             	fildl  -0x4c(%ebp)
    25a3:	d8 4d dc             	fmuls  -0x24(%ebp)
    25a6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    25a9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    25ac:	db 45 b4             	fildl  -0x4c(%ebp)
    25af:	de c9                	fmulp  %st,%st(1)
    25b1:	de c1                	faddp  %st,%st(1)
    25b3:	d9 6d bc             	fldcw  -0x44(%ebp)
    25b6:	db 5d b8             	fistpl -0x48(%ebp)
    25b9:	d9 6d be             	fldcw  -0x42(%ebp)
    25bc:	8b 45 b8             	mov    -0x48(%ebp),%eax
    25bf:	89 c2                	mov    %eax,%edx
    25c1:	8b 45 14             	mov    0x14(%ebp),%eax
    25c4:	88 10                	mov    %dl,(%eax)

    return 1;
    25c6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    25cb:	c9                   	leave  
    25cc:	c3                   	ret    

000025cd <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    25cd:	55                   	push   %ebp
    25ce:	89 e5                	mov    %esp,%ebp
    25d0:	53                   	push   %ebx
    25d1:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    25d4:	8b 45 10             	mov    0x10(%ebp),%eax
    25d7:	c1 f8 10             	sar    $0x10,%eax
    25da:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    25dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    25e0:	c1 f8 10             	sar    $0x10,%eax
    25e3:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    25e6:	8d 45 bc             	lea    -0x44(%ebp),%eax
    25e9:	50                   	push   %eax
    25ea:	ff 75 f8             	pushl  -0x8(%ebp)
    25ed:	ff 75 f4             	pushl  -0xc(%ebp)
    25f0:	ff 75 08             	pushl  0x8(%ebp)
    25f3:	e8 5b fc ff ff       	call   2253 <getColor>
    25f8:	83 c4 10             	add    $0x10,%esp
    25fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    25fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2601:	83 c0 01             	add    $0x1,%eax
    2604:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2607:	83 c2 04             	add    $0x4,%edx
    260a:	52                   	push   %edx
    260b:	ff 75 f8             	pushl  -0x8(%ebp)
    260e:	50                   	push   %eax
    260f:	ff 75 08             	pushl  0x8(%ebp)
    2612:	e8 3c fc ff ff       	call   2253 <getColor>
    2617:	83 c4 10             	add    $0x10,%esp
    261a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    261d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2620:	83 c0 01             	add    $0x1,%eax
    2623:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2626:	83 c2 08             	add    $0x8,%edx
    2629:	52                   	push   %edx
    262a:	50                   	push   %eax
    262b:	ff 75 f4             	pushl  -0xc(%ebp)
    262e:	ff 75 08             	pushl  0x8(%ebp)
    2631:	e8 1d fc ff ff       	call   2253 <getColor>
    2636:	83 c4 10             	add    $0x10,%esp
    2639:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    263c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    263f:	8d 50 01             	lea    0x1(%eax),%edx
    2642:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2645:	83 c0 01             	add    $0x1,%eax
    2648:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    264b:	83 c1 0c             	add    $0xc,%ecx
    264e:	51                   	push   %ecx
    264f:	52                   	push   %edx
    2650:	50                   	push   %eax
    2651:	ff 75 08             	pushl  0x8(%ebp)
    2654:	e8 fa fb ff ff       	call   2253 <getColor>
    2659:	83 c4 10             	add    $0x10,%esp
    265c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    265f:	8b 45 10             	mov    0x10(%ebp),%eax
    2662:	0f b7 c0             	movzwl %ax,%eax
    2665:	c1 f8 08             	sar    $0x8,%eax
    2668:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    266b:	8b 45 0c             	mov    0xc(%ebp),%eax
    266e:	0f b7 c0             	movzwl %ax,%eax
    2671:	c1 f8 08             	sar    $0x8,%eax
    2674:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2677:	8b 45 e0             	mov    -0x20(%ebp),%eax
    267a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    267e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    2681:	b8 ff 00 00 00       	mov    $0xff,%eax
    2686:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2689:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    268d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    2690:	b8 ff 00 00 00       	mov    $0xff,%eax
    2695:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2698:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    269c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    269f:	b8 ff 00 00 00       	mov    $0xff,%eax
    26a4:	2b 45 e0             	sub    -0x20(%ebp),%eax
    26a7:	89 c2                	mov    %eax,%edx
    26a9:	b8 ff 00 00 00       	mov    $0xff,%eax
    26ae:	2b 45 dc             	sub    -0x24(%ebp),%eax
    26b1:	0f af c2             	imul   %edx,%eax
    26b4:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    26b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    26ba:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26be:	0f b6 c0             	movzbl %al,%eax
    26c1:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    26c5:	8b 55 bc             	mov    -0x44(%ebp),%edx
    26c8:	0f af d0             	imul   %eax,%edx
    26cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    26ce:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26d2:	0f b6 c0             	movzbl %al,%eax
    26d5:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    26d9:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    26dc:	0f af c1             	imul   %ecx,%eax
    26df:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    26e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    26e5:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26e9:	0f b6 c0             	movzbl %al,%eax
    26ec:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    26f0:	8b 55 c8             	mov    -0x38(%ebp),%edx
    26f3:	0f af d0             	imul   %eax,%edx
    26f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    26f9:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26fd:	0f b6 c0             	movzbl %al,%eax
    2700:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2704:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2707:	0f af c1             	imul   %ecx,%eax
    270a:	01 d0                	add    %edx,%eax
    270c:	01 d8                	add    %ebx,%eax
    270e:	c1 e8 10             	shr    $0x10,%eax
    2711:	89 c2                	mov    %eax,%edx
    2713:	8b 45 14             	mov    0x14(%ebp),%eax
    2716:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2719:	8b 45 f0             	mov    -0x10(%ebp),%eax
    271c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2720:	0f b6 c0             	movzbl %al,%eax
    2723:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2727:	8b 55 bc             	mov    -0x44(%ebp),%edx
    272a:	0f af d0             	imul   %eax,%edx
    272d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2730:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2734:	0f b6 c0             	movzbl %al,%eax
    2737:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    273b:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    273e:	0f af c1             	imul   %ecx,%eax
    2741:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2744:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2747:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    274b:	0f b6 c0             	movzbl %al,%eax
    274e:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2752:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2755:	0f af d0             	imul   %eax,%edx
    2758:	8b 45 e8             	mov    -0x18(%ebp),%eax
    275b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    275f:	0f b6 c0             	movzbl %al,%eax
    2762:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2766:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2769:	0f af c1             	imul   %ecx,%eax
    276c:	01 d0                	add    %edx,%eax
    276e:	01 d8                	add    %ebx,%eax
    2770:	c1 e8 10             	shr    $0x10,%eax
    2773:	89 c2                	mov    %eax,%edx
    2775:	8b 45 14             	mov    0x14(%ebp),%eax
    2778:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    277b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    277e:	0f b6 00             	movzbl (%eax),%eax
    2781:	0f b6 c0             	movzbl %al,%eax
    2784:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2788:	8b 55 bc             	mov    -0x44(%ebp),%edx
    278b:	0f af d0             	imul   %eax,%edx
    278e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2791:	0f b6 00             	movzbl (%eax),%eax
    2794:	0f b6 c0             	movzbl %al,%eax
    2797:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    279b:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    279e:	0f af c1             	imul   %ecx,%eax
    27a1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    27a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    27a7:	0f b6 00             	movzbl (%eax),%eax
    27aa:	0f b6 c0             	movzbl %al,%eax
    27ad:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    27b1:	8b 55 c8             	mov    -0x38(%ebp),%edx
    27b4:	0f af d0             	imul   %eax,%edx
    27b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    27ba:	0f b6 00             	movzbl (%eax),%eax
    27bd:	0f b6 c0             	movzbl %al,%eax
    27c0:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    27c4:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    27c7:	0f af c1             	imul   %ecx,%eax
    27ca:	01 d0                	add    %edx,%eax
    27cc:	01 d8                	add    %ebx,%eax
    27ce:	c1 e8 10             	shr    $0x10,%eax
    27d1:	89 c2                	mov    %eax,%edx
    27d3:	8b 45 14             	mov    0x14(%ebp),%eax
    27d6:	88 10                	mov    %dl,(%eax)
}
    27d8:	90                   	nop
    27d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    27dc:	c9                   	leave  
    27dd:	c3                   	ret    

000027de <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    27de:	55                   	push   %ebp
    27df:	89 e5                	mov    %esp,%ebp
    27e1:	53                   	push   %ebx
    27e2:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    27e5:	8b 45 08             	mov    0x8(%ebp),%eax
    27e8:	8b 00                	mov    (%eax),%eax
    27ea:	c1 e0 10             	shl    $0x10,%eax
    27ed:	89 c1                	mov    %eax,%ecx
    27ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    27f2:	8b 18                	mov    (%eax),%ebx
    27f4:	89 c8                	mov    %ecx,%eax
    27f6:	99                   	cltd   
    27f7:	f7 fb                	idiv   %ebx
    27f9:	83 c0 01             	add    $0x1,%eax
    27fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    27ff:	8b 45 08             	mov    0x8(%ebp),%eax
    2802:	8b 40 04             	mov    0x4(%eax),%eax
    2805:	c1 e0 10             	shl    $0x10,%eax
    2808:	89 c1                	mov    %eax,%ecx
    280a:	8b 45 0c             	mov    0xc(%ebp),%eax
    280d:	8b 58 04             	mov    0x4(%eax),%ebx
    2810:	89 c8                	mov    %ecx,%eax
    2812:	99                   	cltd   
    2813:	f7 fb                	idiv   %ebx
    2815:	83 c0 01             	add    $0x1,%eax
    2818:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    281b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    281e:	d1 f8                	sar    %eax
    2820:	2d 00 80 00 00       	sub    $0x8000,%eax
    2825:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2828:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    282b:	d1 f8                	sar    %eax
    282d:	2d 00 80 00 00       	sub    $0x8000,%eax
    2832:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2835:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2838:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    283b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2842:	eb 5d                	jmp    28a1 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2844:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2847:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    284a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2851:	eb 3a                	jmp    288d <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    2853:	8b 45 0c             	mov    0xc(%ebp),%eax
    2856:	8b 48 08             	mov    0x8(%eax),%ecx
    2859:	8b 45 0c             	mov    0xc(%ebp),%eax
    285c:	8b 00                	mov    (%eax),%eax
    285e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2862:	89 c2                	mov    %eax,%edx
    2864:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2867:	01 c2                	add    %eax,%edx
    2869:	89 d0                	mov    %edx,%eax
    286b:	01 c0                	add    %eax,%eax
    286d:	01 d0                	add    %edx,%eax
    286f:	01 c8                	add    %ecx,%eax
    2871:	50                   	push   %eax
    2872:	ff 75 f0             	pushl  -0x10(%ebp)
    2875:	ff 75 f8             	pushl  -0x8(%ebp)
    2878:	ff 75 08             	pushl  0x8(%ebp)
    287b:	e8 4d fd ff ff       	call   25cd <mixColorInt>
    2880:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    2883:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2886:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    2889:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    288d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2890:	8b 00                	mov    (%eax),%eax
    2892:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2895:	7f bc                	jg     2853 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    2897:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    289a:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    289d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    28a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    28a4:	8b 40 04             	mov    0x4(%eax),%eax
    28a7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    28aa:	7f 98                	jg     2844 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    28ac:	b8 01 00 00 00       	mov    $0x1,%eax
}
    28b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    28b4:	c9                   	leave  
    28b5:	c3                   	ret    

000028b6 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    28b6:	55                   	push   %ebp
    28b7:	89 e5                	mov    %esp,%ebp
    28b9:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    28bc:	8b 45 08             	mov    0x8(%ebp),%eax
    28bf:	8b 00                	mov    (%eax),%eax
    28c1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    28c4:	db 45 e4             	fildl  -0x1c(%ebp)
    28c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    28ca:	8b 00                	mov    (%eax),%eax
    28cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    28cf:	db 45 e4             	fildl  -0x1c(%ebp)
    28d2:	de f9                	fdivrp %st,%st(1)
    28d4:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    28d7:	8b 45 08             	mov    0x8(%ebp),%eax
    28da:	8b 40 04             	mov    0x4(%eax),%eax
    28dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    28e0:	db 45 e4             	fildl  -0x1c(%ebp)
    28e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    28e6:	8b 40 04             	mov    0x4(%eax),%eax
    28e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    28ec:	db 45 e4             	fildl  -0x1c(%ebp)
    28ef:	de f9                	fdivrp %st,%st(1)
    28f1:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    28f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    28fb:	eb 5e                	jmp    295b <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    28fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2904:	eb 47                	jmp    294d <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    2906:	db 45 f8             	fildl  -0x8(%ebp)
    2909:	d8 4d f4             	fmuls  -0xc(%ebp)
    290c:	d9 7d ee             	fnstcw -0x12(%ebp)
    290f:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2913:	b4 0c                	mov    $0xc,%ah
    2915:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2919:	d9 6d ec             	fldcw  -0x14(%ebp)
    291c:	db 5d e8             	fistpl -0x18(%ebp)
    291f:	d9 6d ee             	fldcw  -0x12(%ebp)
    2922:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2925:	db 45 fc             	fildl  -0x4(%ebp)
    2928:	d8 4d f0             	fmuls  -0x10(%ebp)
    292b:	d9 6d ec             	fldcw  -0x14(%ebp)
    292e:	db 5d e8             	fistpl -0x18(%ebp)
    2931:	d9 6d ee             	fldcw  -0x12(%ebp)
    2934:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2937:	6a 00                	push   $0x0
    2939:	52                   	push   %edx
    293a:	50                   	push   %eax
    293b:	ff 75 08             	pushl  0x8(%ebp)
    293e:	e8 10 f9 ff ff       	call   2253 <getColor>
    2943:	83 c4 10             	add    $0x10,%esp
    2946:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2949:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    294d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2950:	8b 00                	mov    (%eax),%eax
    2952:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2955:	7f af                	jg     2906 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2957:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    295b:	8b 45 0c             	mov    0xc(%ebp),%eax
    295e:	8b 40 04             	mov    0x4(%eax),%eax
    2961:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2964:	7f 97                	jg     28fd <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2966:	b8 01 00 00 00       	mov    $0x1,%eax
}
    296b:	c9                   	leave  
    296c:	c3                   	ret    

0000296d <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    296d:	55                   	push   %ebp
    296e:	89 e5                	mov    %esp,%ebp
    2970:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    2973:	8b 45 08             	mov    0x8(%ebp),%eax
    2976:	8b 00                	mov    (%eax),%eax
    2978:	89 45 e0             	mov    %eax,-0x20(%ebp)
    297b:	db 45 e0             	fildl  -0x20(%ebp)
    297e:	d9 5d e0             	fstps  -0x20(%ebp)
    2981:	83 ec 0c             	sub    $0xc,%esp
    2984:	ff 75 10             	pushl  0x10(%ebp)
    2987:	e8 6b e2 ff ff       	call   bf7 <cos>
    298c:	83 c4 10             	add    $0x10,%esp
    298f:	d9 5d dc             	fstps  -0x24(%ebp)
    2992:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2995:	83 ec 0c             	sub    $0xc,%esp
    2998:	50                   	push   %eax
    2999:	e8 90 e1 ff ff       	call   b2e <abs>
    299e:	83 c4 10             	add    $0x10,%esp
    29a1:	d8 4d e0             	fmuls  -0x20(%ebp)
    29a4:	d9 5d e0             	fstps  -0x20(%ebp)
    29a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    29aa:	8b 00                	mov    (%eax),%eax
    29ac:	89 45 dc             	mov    %eax,-0x24(%ebp)
    29af:	db 45 dc             	fildl  -0x24(%ebp)
    29b2:	d9 5d dc             	fstps  -0x24(%ebp)
    29b5:	83 ec 0c             	sub    $0xc,%esp
    29b8:	ff 75 10             	pushl  0x10(%ebp)
    29bb:	e8 da e3 ff ff       	call   d9a <sin>
    29c0:	83 c4 10             	add    $0x10,%esp
    29c3:	d9 5d d8             	fstps  -0x28(%ebp)
    29c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    29c9:	83 ec 0c             	sub    $0xc,%esp
    29cc:	50                   	push   %eax
    29cd:	e8 5c e1 ff ff       	call   b2e <abs>
    29d2:	83 c4 10             	add    $0x10,%esp
    29d5:	d8 4d dc             	fmuls  -0x24(%ebp)
    29d8:	d8 45 e0             	fadds  -0x20(%ebp)
    29db:	d9 7d e6             	fnstcw -0x1a(%ebp)
    29de:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    29e2:	b4 0c                	mov    $0xc,%ah
    29e4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    29e8:	d9 6d e4             	fldcw  -0x1c(%ebp)
    29eb:	db 5d f4             	fistpl -0xc(%ebp)
    29ee:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    29f1:	8b 45 08             	mov    0x8(%ebp),%eax
    29f4:	8b 00                	mov    (%eax),%eax
    29f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    29f9:	db 45 e0             	fildl  -0x20(%ebp)
    29fc:	d9 5d e0             	fstps  -0x20(%ebp)
    29ff:	83 ec 0c             	sub    $0xc,%esp
    2a02:	ff 75 10             	pushl  0x10(%ebp)
    2a05:	e8 90 e3 ff ff       	call   d9a <sin>
    2a0a:	83 c4 10             	add    $0x10,%esp
    2a0d:	d9 5d dc             	fstps  -0x24(%ebp)
    2a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2a13:	83 ec 0c             	sub    $0xc,%esp
    2a16:	50                   	push   %eax
    2a17:	e8 12 e1 ff ff       	call   b2e <abs>
    2a1c:	83 c4 10             	add    $0x10,%esp
    2a1f:	d8 4d e0             	fmuls  -0x20(%ebp)
    2a22:	d9 5d e0             	fstps  -0x20(%ebp)
    2a25:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a28:	8b 00                	mov    (%eax),%eax
    2a2a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2a2d:	db 45 dc             	fildl  -0x24(%ebp)
    2a30:	d9 5d dc             	fstps  -0x24(%ebp)
    2a33:	83 ec 0c             	sub    $0xc,%esp
    2a36:	ff 75 10             	pushl  0x10(%ebp)
    2a39:	e8 b9 e1 ff ff       	call   bf7 <cos>
    2a3e:	83 c4 10             	add    $0x10,%esp
    2a41:	d9 5d d8             	fstps  -0x28(%ebp)
    2a44:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2a47:	83 ec 0c             	sub    $0xc,%esp
    2a4a:	50                   	push   %eax
    2a4b:	e8 de e0 ff ff       	call   b2e <abs>
    2a50:	83 c4 10             	add    $0x10,%esp
    2a53:	d8 4d dc             	fmuls  -0x24(%ebp)
    2a56:	d8 45 e0             	fadds  -0x20(%ebp)
    2a59:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2a5c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2a60:	b4 0c                	mov    $0xc,%ah
    2a62:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2a66:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2a69:	db 5d f0             	fistpl -0x10(%ebp)
    2a6c:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    2a6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a72:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2a75:	89 10                	mov    %edx,(%eax)
    *width = w;
    2a77:	8b 45 08             	mov    0x8(%ebp),%eax
    2a7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2a7d:	89 10                	mov    %edx,(%eax)
    return 1;
    2a7f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a84:	c9                   	leave  
    2a85:	c3                   	ret    

00002a86 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    2a86:	55                   	push   %ebp
    2a87:	89 e5                	mov    %esp,%ebp
    2a89:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2a8c:	8b 45 08             	mov    0x8(%ebp),%eax
    2a8f:	8b 40 04             	mov    0x4(%eax),%eax
    2a92:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2a95:	db 45 c4             	fildl  -0x3c(%ebp)
    2a98:	d9 05 a4 9f 01 00    	flds   0x19fa4
    2a9e:	de f9                	fdivrp %st,%st(1)
    2aa0:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    2aa3:	8b 45 08             	mov    0x8(%ebp),%eax
    2aa6:	8b 00                	mov    (%eax),%eax
    2aa8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2aab:	db 45 c4             	fildl  -0x3c(%ebp)
    2aae:	d9 05 a4 9f 01 00    	flds   0x19fa4
    2ab4:	de f9                	fdivrp %st,%st(1)
    2ab6:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2ab9:	8b 45 0c             	mov    0xc(%ebp),%eax
    2abc:	8b 50 04             	mov    0x4(%eax),%edx
    2abf:	8b 45 08             	mov    0x8(%ebp),%eax
    2ac2:	8b 40 04             	mov    0x4(%eax),%eax
    2ac5:	29 c2                	sub    %eax,%edx
    2ac7:	89 d0                	mov    %edx,%eax
    2ac9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2acc:	db 45 c4             	fildl  -0x3c(%ebp)
    2acf:	d9 05 a4 9f 01 00    	flds   0x19fa4
    2ad5:	de f9                	fdivrp %st,%st(1)
    2ad7:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2ada:	8b 45 0c             	mov    0xc(%ebp),%eax
    2add:	8b 10                	mov    (%eax),%edx
    2adf:	8b 45 08             	mov    0x8(%ebp),%eax
    2ae2:	8b 00                	mov    (%eax),%eax
    2ae4:	29 c2                	sub    %eax,%edx
    2ae6:	89 d0                	mov    %edx,%eax
    2ae8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2aeb:	db 45 c4             	fildl  -0x3c(%ebp)
    2aee:	d9 05 a4 9f 01 00    	flds   0x19fa4
    2af4:	de f9                	fdivrp %st,%st(1)
    2af6:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2af9:	d9 45 10             	flds   0x10(%ebp)
    2afc:	d9 e0                	fchs   
    2afe:	83 ec 0c             	sub    $0xc,%esp
    2b01:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2b05:	d9 1c 24             	fstps  (%esp)
    2b08:	e8 ea e0 ff ff       	call   bf7 <cos>
    2b0d:	83 c4 10             	add    $0x10,%esp
    2b10:	d9 5d c4             	fstps  -0x3c(%ebp)
    2b13:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2b16:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2b19:	d9 45 10             	flds   0x10(%ebp)
    2b1c:	d9 e0                	fchs   
    2b1e:	83 ec 0c             	sub    $0xc,%esp
    2b21:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2b25:	d9 1c 24             	fstps  (%esp)
    2b28:	e8 6d e2 ff ff       	call   d9a <sin>
    2b2d:	83 c4 10             	add    $0x10,%esp
    2b30:	d9 5d c4             	fstps  -0x3c(%ebp)
    2b33:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2b36:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2b39:	d9 ee                	fldz   
    2b3b:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    2b3e:	d9 ee                	fldz   
    2b40:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    2b43:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2b4a:	e9 28 01 00 00       	jmp    2c77 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    2b4f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2b56:	e9 0a 01 00 00       	jmp    2c65 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2b5b:	db 45 f4             	fildl  -0xc(%ebp)
    2b5e:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2b61:	d8 65 ec             	fsubs  -0x14(%ebp)
    2b64:	d8 4d dc             	fmuls  -0x24(%ebp)
    2b67:	db 45 f0             	fildl  -0x10(%ebp)
    2b6a:	d8 65 e0             	fsubs  -0x20(%ebp)
    2b6d:	d8 65 e8             	fsubs  -0x18(%ebp)
    2b70:	d8 4d d8             	fmuls  -0x28(%ebp)
    2b73:	de c1                	faddp  %st,%st(1)
    2b75:	d8 45 ec             	fadds  -0x14(%ebp)
    2b78:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2b7b:	db 45 f0             	fildl  -0x10(%ebp)
    2b7e:	d8 65 e0             	fsubs  -0x20(%ebp)
    2b81:	d8 65 e8             	fsubs  -0x18(%ebp)
    2b84:	d8 4d dc             	fmuls  -0x24(%ebp)
    2b87:	db 45 f4             	fildl  -0xc(%ebp)
    2b8a:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2b8d:	d8 65 ec             	fsubs  -0x14(%ebp)
    2b90:	d8 4d d8             	fmuls  -0x28(%ebp)
    2b93:	de e9                	fsubrp %st,%st(1)
    2b95:	d8 45 e8             	fadds  -0x18(%ebp)
    2b98:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2b9b:	d9 45 d4             	flds   -0x2c(%ebp)
    2b9e:	d9 ee                	fldz   
    2ba0:	d9 c9                	fxch   %st(1)
    2ba2:	df e9                	fucomip %st(1),%st
    2ba4:	dd d8                	fstp   %st(0)
    2ba6:	0f 93 c0             	setae  %al
    2ba9:	83 f0 01             	xor    $0x1,%eax
    2bac:	84 c0                	test   %al,%al
    2bae:	75 52                	jne    2c02 <picTurn+0x17c>
    2bb0:	8b 45 08             	mov    0x8(%ebp),%eax
    2bb3:	8b 40 04             	mov    0x4(%eax),%eax
    2bb6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2bb9:	db 45 c4             	fildl  -0x3c(%ebp)
    2bbc:	d9 45 d4             	flds   -0x2c(%ebp)
    2bbf:	d9 c9                	fxch   %st(1)
    2bc1:	df e9                	fucomip %st(1),%st
    2bc3:	dd d8                	fstp   %st(0)
    2bc5:	0f 97 c0             	seta   %al
    2bc8:	83 f0 01             	xor    $0x1,%eax
    2bcb:	84 c0                	test   %al,%al
    2bcd:	75 33                	jne    2c02 <picTurn+0x17c>
    2bcf:	d9 45 d0             	flds   -0x30(%ebp)
    2bd2:	d9 ee                	fldz   
    2bd4:	d9 c9                	fxch   %st(1)
    2bd6:	df e9                	fucomip %st(1),%st
    2bd8:	dd d8                	fstp   %st(0)
    2bda:	0f 93 c0             	setae  %al
    2bdd:	83 f0 01             	xor    $0x1,%eax
    2be0:	84 c0                	test   %al,%al
    2be2:	75 1e                	jne    2c02 <picTurn+0x17c>
    2be4:	8b 45 08             	mov    0x8(%ebp),%eax
    2be7:	8b 00                	mov    (%eax),%eax
    2be9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2bec:	db 45 c4             	fildl  -0x3c(%ebp)
    2bef:	d9 45 d0             	flds   -0x30(%ebp)
    2bf2:	d9 c9                	fxch   %st(1)
    2bf4:	df e9                	fucomip %st(1),%st
    2bf6:	dd d8                	fstp   %st(0)
    2bf8:	0f 97 c0             	seta   %al
    2bfb:	83 f0 01             	xor    $0x1,%eax
    2bfe:	84 c0                	test   %al,%al
    2c00:	74 2f                	je     2c31 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    2c02:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c05:	8b 48 08             	mov    0x8(%eax),%ecx
    2c08:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c0b:	8b 00                	mov    (%eax),%eax
    2c0d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2c11:	89 c2                	mov    %eax,%edx
    2c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2c16:	01 c2                	add    %eax,%edx
    2c18:	89 d0                	mov    %edx,%eax
    2c1a:	01 c0                	add    %eax,%eax
    2c1c:	01 d0                	add    %edx,%eax
    2c1e:	01 c8                	add    %ecx,%eax
    2c20:	83 ec 08             	sub    $0x8,%esp
    2c23:	50                   	push   %eax
    2c24:	68 31 e4 01 00       	push   $0x1e431
    2c29:	e8 9f f6 ff ff       	call   22cd <setColor>
    2c2e:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    2c31:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c34:	8b 48 08             	mov    0x8(%eax),%ecx
    2c37:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c3a:	8b 00                	mov    (%eax),%eax
    2c3c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2c40:	89 c2                	mov    %eax,%edx
    2c42:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2c45:	01 c2                	add    %eax,%edx
    2c47:	89 d0                	mov    %edx,%eax
    2c49:	01 c0                	add    %eax,%eax
    2c4b:	01 d0                	add    %edx,%eax
    2c4d:	01 c8                	add    %ecx,%eax
    2c4f:	50                   	push   %eax
    2c50:	ff 75 d0             	pushl  -0x30(%ebp)
    2c53:	ff 75 d4             	pushl  -0x2c(%ebp)
    2c56:	ff 75 08             	pushl  0x8(%ebp)
    2c59:	e8 9e f6 ff ff       	call   22fc <mixColor>
    2c5e:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2c61:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2c65:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c68:	8b 00                	mov    (%eax),%eax
    2c6a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2c6d:	0f 8f e8 fe ff ff    	jg     2b5b <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2c73:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2c77:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c7a:	8b 40 04             	mov    0x4(%eax),%eax
    2c7d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2c80:	0f 8f c9 fe ff ff    	jg     2b4f <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    2c86:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2c8b:	c9                   	leave  
    2c8c:	c3                   	ret    

00002c8d <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2c8d:	55                   	push   %ebp
    2c8e:	89 e5                	mov    %esp,%ebp
    2c90:	53                   	push   %ebx
    2c91:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2c94:	8b 45 08             	mov    0x8(%ebp),%eax
    2c97:	8b 10                	mov    (%eax),%edx
    2c99:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c9c:	8b 00                	mov    (%eax),%eax
    2c9e:	39 c2                	cmp    %eax,%edx
    2ca0:	75 10                	jne    2cb2 <picRollingOver+0x25>
    2ca2:	8b 45 08             	mov    0x8(%ebp),%eax
    2ca5:	8b 50 04             	mov    0x4(%eax),%edx
    2ca8:	8b 45 0c             	mov    0xc(%ebp),%eax
    2cab:	8b 40 04             	mov    0x4(%eax),%eax
    2cae:	39 c2                	cmp    %eax,%edx
    2cb0:	74 0a                	je     2cbc <picRollingOver+0x2f>
        return 0;
    2cb2:	b8 00 00 00 00       	mov    $0x0,%eax
    2cb7:	e9 88 00 00 00       	jmp    2d44 <picRollingOver+0xb7>

    int h = src->height;
    2cbc:	8b 45 08             	mov    0x8(%ebp),%eax
    2cbf:	8b 40 04             	mov    0x4(%eax),%eax
    2cc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2cc5:	8b 45 08             	mov    0x8(%ebp),%eax
    2cc8:	8b 00                	mov    (%eax),%eax
    2cca:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2ccd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2cd4:	eb 61                	jmp    2d37 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2cd6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2cdd:	eb 4c                	jmp    2d2b <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2cdf:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ce2:	8b 48 08             	mov    0x8(%eax),%ecx
    2ce5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ce8:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2ceb:	83 e8 01             	sub    $0x1,%eax
    2cee:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2cf2:	89 c2                	mov    %eax,%edx
    2cf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2cf7:	01 c2                	add    %eax,%edx
    2cf9:	89 d0                	mov    %edx,%eax
    2cfb:	01 c0                	add    %eax,%eax
    2cfd:	01 d0                	add    %edx,%eax
    2cff:	01 c1                	add    %eax,%ecx
    2d01:	8b 45 08             	mov    0x8(%ebp),%eax
    2d04:	8b 58 08             	mov    0x8(%eax),%ebx
    2d07:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2d0a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2d0e:	89 c2                	mov    %eax,%edx
    2d10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d13:	01 c2                	add    %eax,%edx
    2d15:	89 d0                	mov    %edx,%eax
    2d17:	01 c0                	add    %eax,%eax
    2d19:	01 d0                	add    %edx,%eax
    2d1b:	01 d8                	add    %ebx,%eax
    2d1d:	51                   	push   %ecx
    2d1e:	50                   	push   %eax
    2d1f:	e8 a9 f5 ff ff       	call   22cd <setColor>
    2d24:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2d27:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2d2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d2e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2d31:	7c ac                	jl     2cdf <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2d33:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2d37:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2d3a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2d3d:	7c 97                	jl     2cd6 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2d3f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2d44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2d47:	c9                   	leave  
    2d48:	c3                   	ret    

00002d49 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2d49:	55                   	push   %ebp
    2d4a:	89 e5                	mov    %esp,%ebp
    2d4c:	53                   	push   %ebx
    2d4d:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2d50:	8b 45 08             	mov    0x8(%ebp),%eax
    2d53:	8b 10                	mov    (%eax),%edx
    2d55:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d58:	8b 00                	mov    (%eax),%eax
    2d5a:	39 c2                	cmp    %eax,%edx
    2d5c:	75 10                	jne    2d6e <picTurnAround+0x25>
    2d5e:	8b 45 08             	mov    0x8(%ebp),%eax
    2d61:	8b 50 04             	mov    0x4(%eax),%edx
    2d64:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d67:	8b 40 04             	mov    0x4(%eax),%eax
    2d6a:	39 c2                	cmp    %eax,%edx
    2d6c:	74 0a                	je     2d78 <picTurnAround+0x2f>
        return 0;
    2d6e:	b8 00 00 00 00       	mov    $0x0,%eax
    2d73:	e9 88 00 00 00       	jmp    2e00 <picTurnAround+0xb7>

    int h = src->height;
    2d78:	8b 45 08             	mov    0x8(%ebp),%eax
    2d7b:	8b 40 04             	mov    0x4(%eax),%eax
    2d7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2d81:	8b 45 08             	mov    0x8(%ebp),%eax
    2d84:	8b 00                	mov    (%eax),%eax
    2d86:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2d89:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2d90:	eb 61                	jmp    2df3 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2d92:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2d99:	eb 4c                	jmp    2de7 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2d9b:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d9e:	8b 48 08             	mov    0x8(%eax),%ecx
    2da1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2da4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2da8:	89 c2                	mov    %eax,%edx
    2daa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2dad:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2db0:	01 c2                	add    %eax,%edx
    2db2:	89 d0                	mov    %edx,%eax
    2db4:	01 c0                	add    %eax,%eax
    2db6:	01 d0                	add    %edx,%eax
    2db8:	83 e8 03             	sub    $0x3,%eax
    2dbb:	01 c1                	add    %eax,%ecx
    2dbd:	8b 45 08             	mov    0x8(%ebp),%eax
    2dc0:	8b 58 08             	mov    0x8(%eax),%ebx
    2dc3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2dc6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2dca:	89 c2                	mov    %eax,%edx
    2dcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dcf:	01 c2                	add    %eax,%edx
    2dd1:	89 d0                	mov    %edx,%eax
    2dd3:	01 c0                	add    %eax,%eax
    2dd5:	01 d0                	add    %edx,%eax
    2dd7:	01 d8                	add    %ebx,%eax
    2dd9:	51                   	push   %ecx
    2dda:	50                   	push   %eax
    2ddb:	e8 ed f4 ff ff       	call   22cd <setColor>
    2de0:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2de3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2de7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dea:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2ded:	7c ac                	jl     2d9b <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2def:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2df3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2df6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2df9:	7c 97                	jl     2d92 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2dfb:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2e00:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2e03:	c9                   	leave  
    2e04:	c3                   	ret    

00002e05 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2e05:	55                   	push   %ebp
    2e06:	89 e5                	mov    %esp,%ebp
    2e08:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2e0b:	83 ec 0c             	sub    $0xc,%esp
    2e0e:	ff 75 08             	pushl  0x8(%ebp)
    2e11:	e8 c5 d5 ff ff       	call   3db <strlen>
    2e16:	83 c4 10             	add    $0x10,%esp
    2e19:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2e1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e1f:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e22:	8b 45 08             	mov    0x8(%ebp),%eax
    2e25:	01 d0                	add    %edx,%eax
    2e27:	0f b6 00             	movzbl (%eax),%eax
    2e2a:	3c 67                	cmp    $0x67,%al
    2e2c:	75 2b                	jne    2e59 <type+0x54>
    2e2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e31:	8d 50 fe             	lea    -0x2(%eax),%edx
    2e34:	8b 45 08             	mov    0x8(%ebp),%eax
    2e37:	01 d0                	add    %edx,%eax
    2e39:	0f b6 00             	movzbl (%eax),%eax
    2e3c:	3c 70                	cmp    $0x70,%al
    2e3e:	75 19                	jne    2e59 <type+0x54>
    2e40:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e43:	8d 50 fd             	lea    -0x3(%eax),%edx
    2e46:	8b 45 08             	mov    0x8(%ebp),%eax
    2e49:	01 d0                	add    %edx,%eax
    2e4b:	0f b6 00             	movzbl (%eax),%eax
    2e4e:	3c 6a                	cmp    $0x6a,%al
    2e50:	75 07                	jne    2e59 <type+0x54>
    2e52:	b8 00 00 00 00       	mov    $0x0,%eax
    2e57:	eb 7f                	jmp    2ed8 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2e59:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e5c:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e5f:	8b 45 08             	mov    0x8(%ebp),%eax
    2e62:	01 d0                	add    %edx,%eax
    2e64:	0f b6 00             	movzbl (%eax),%eax
    2e67:	3c 70                	cmp    $0x70,%al
    2e69:	75 2b                	jne    2e96 <type+0x91>
    2e6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e6e:	8d 50 fe             	lea    -0x2(%eax),%edx
    2e71:	8b 45 08             	mov    0x8(%ebp),%eax
    2e74:	01 d0                	add    %edx,%eax
    2e76:	0f b6 00             	movzbl (%eax),%eax
    2e79:	3c 6d                	cmp    $0x6d,%al
    2e7b:	75 19                	jne    2e96 <type+0x91>
    2e7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e80:	8d 50 fd             	lea    -0x3(%eax),%edx
    2e83:	8b 45 08             	mov    0x8(%ebp),%eax
    2e86:	01 d0                	add    %edx,%eax
    2e88:	0f b6 00             	movzbl (%eax),%eax
    2e8b:	3c 62                	cmp    $0x62,%al
    2e8d:	75 07                	jne    2e96 <type+0x91>
    2e8f:	b8 01 00 00 00       	mov    $0x1,%eax
    2e94:	eb 42                	jmp    2ed8 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2e96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e99:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e9c:	8b 45 08             	mov    0x8(%ebp),%eax
    2e9f:	01 d0                	add    %edx,%eax
    2ea1:	0f b6 00             	movzbl (%eax),%eax
    2ea4:	3c 67                	cmp    $0x67,%al
    2ea6:	75 2b                	jne    2ed3 <type+0xce>
    2ea8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2eab:	8d 50 fe             	lea    -0x2(%eax),%edx
    2eae:	8b 45 08             	mov    0x8(%ebp),%eax
    2eb1:	01 d0                	add    %edx,%eax
    2eb3:	0f b6 00             	movzbl (%eax),%eax
    2eb6:	3c 6e                	cmp    $0x6e,%al
    2eb8:	75 19                	jne    2ed3 <type+0xce>
    2eba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ebd:	8d 50 fd             	lea    -0x3(%eax),%edx
    2ec0:	8b 45 08             	mov    0x8(%ebp),%eax
    2ec3:	01 d0                	add    %edx,%eax
    2ec5:	0f b6 00             	movzbl (%eax),%eax
    2ec8:	3c 70                	cmp    $0x70,%al
    2eca:	75 07                	jne    2ed3 <type+0xce>
    2ecc:	b8 02 00 00 00       	mov    $0x2,%eax
    2ed1:	eb 05                	jmp    2ed8 <type+0xd3>
    else return NONE;
    2ed3:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2ed8:	c9                   	leave  
    2ed9:	c3                   	ret    

00002eda <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2eda:	55                   	push   %ebp
    2edb:	89 e5                	mov    %esp,%ebp
    2edd:	56                   	push   %esi
    2ede:	53                   	push   %ebx
    2edf:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2ee2:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2ee9:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2ef0:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2ef7:	83 ec 08             	sub    $0x8,%esp
    2efa:	6a 00                	push   $0x0
    2efc:	ff 75 0c             	pushl  0xc(%ebp)
    2eff:	e8 d9 d6 ff ff       	call   5dd <open>
    2f04:	83 c4 10             	add    $0x10,%esp
    2f07:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2f0a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2f0e:	79 2c                	jns    2f3c <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2f10:	83 ec 08             	sub    $0x8,%esp
    2f13:	ff 75 0c             	pushl  0xc(%ebp)
    2f16:	68 a8 9f 01 00       	push   $0x19fa8
    2f1b:	e8 24 d8 ff ff       	call   744 <printf>
    2f20:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2f23:	8b 45 08             	mov    0x8(%ebp),%eax
    2f26:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2f29:	89 10                	mov    %edx,(%eax)
    2f2b:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2f2e:	89 50 04             	mov    %edx,0x4(%eax)
    2f31:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f34:	89 50 08             	mov    %edx,0x8(%eax)
    2f37:	e9 2d 02 00 00       	jmp    3169 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2f3c:	83 ec 04             	sub    $0x4,%esp
    2f3f:	6a 0e                	push   $0xe
    2f41:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2f44:	50                   	push   %eax
    2f45:	ff 75 ec             	pushl  -0x14(%ebp)
    2f48:	e8 68 d6 ff ff       	call   5b5 <read>
    2f4d:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2f50:	83 ec 04             	sub    $0x4,%esp
    2f53:	6a 28                	push   $0x28
    2f55:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2f58:	50                   	push   %eax
    2f59:	ff 75 ec             	pushl  -0x14(%ebp)
    2f5c:	e8 54 d6 ff ff       	call   5b5 <read>
    2f61:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2f64:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2f68:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2f6b:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2f6f:	0f b7 d8             	movzwl %ax,%ebx
    2f72:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2f75:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2f78:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2f7c:	0f b7 c0             	movzwl %ax,%eax
    2f7f:	83 ec 04             	sub    $0x4,%esp
    2f82:	6a 36                	push   $0x36
    2f84:	56                   	push   %esi
    2f85:	53                   	push   %ebx
    2f86:	51                   	push   %ecx
    2f87:	52                   	push   %edx
    2f88:	50                   	push   %eax
    2f89:	68 b8 9f 01 00       	push   $0x19fb8
    2f8e:	e8 b1 d7 ff ff       	call   744 <printf>
    2f93:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2f96:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2f99:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2f9c:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2f9f:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2fa2:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2fa5:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2fa8:	0f af c2             	imul   %edx,%eax
    2fab:	89 c2                	mov    %eax,%edx
    2fad:	89 d0                	mov    %edx,%eax
    2faf:	01 c0                	add    %eax,%eax
    2fb1:	01 d0                	add    %edx,%eax
    2fb3:	83 ec 0c             	sub    $0xc,%esp
    2fb6:	50                   	push   %eax
    2fb7:	e8 5b da ff ff       	call   a17 <malloc>
    2fbc:	83 c4 10             	add    $0x10,%esp
    2fbf:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2fc2:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2fc6:	0f b7 c0             	movzwl %ax,%eax
    2fc9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2fcc:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2fcf:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2fd3:	83 c0 1f             	add    $0x1f,%eax
    2fd6:	c1 f8 05             	sar    $0x5,%eax
    2fd9:	c1 e0 02             	shl    $0x2,%eax
    2fdc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2fdf:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2fe2:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2fe6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2fe9:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2fec:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2fef:	83 ec 08             	sub    $0x8,%esp
    2ff2:	52                   	push   %edx
    2ff3:	50                   	push   %eax
    2ff4:	ff 75 e8             	pushl  -0x18(%ebp)
    2ff7:	ff 75 e0             	pushl  -0x20(%ebp)
    2ffa:	ff 75 e4             	pushl  -0x1c(%ebp)
    2ffd:	68 e0 9f 01 00       	push   $0x19fe0
    3002:	e8 3d d7 ff ff       	call   744 <printf>
    3007:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    300a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    300d:	83 e8 36             	sub    $0x36,%eax
    3010:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    3013:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3016:	83 ec 0c             	sub    $0xc,%esp
    3019:	50                   	push   %eax
    301a:	e8 f8 d9 ff ff       	call   a17 <malloc>
    301f:	83 c4 10             	add    $0x10,%esp
    3022:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    3025:	83 ec 04             	sub    $0x4,%esp
    3028:	ff 75 dc             	pushl  -0x24(%ebp)
    302b:	ff 75 d8             	pushl  -0x28(%ebp)
    302e:	ff 75 ec             	pushl  -0x14(%ebp)
    3031:	e8 7f d5 ff ff       	call   5b5 <read>
    3036:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    3039:	8b 45 ac             	mov    -0x54(%ebp),%eax
    303c:	83 ec 0c             	sub    $0xc,%esp
    303f:	50                   	push   %eax
    3040:	e8 d2 d9 ff ff       	call   a17 <malloc>
    3045:	83 c4 10             	add    $0x10,%esp
    3048:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    304b:	8b 45 ac             	mov    -0x54(%ebp),%eax
    304e:	83 ec 04             	sub    $0x4,%esp
    3051:	50                   	push   %eax
    3052:	ff 75 d4             	pushl  -0x2c(%ebp)
    3055:	ff 75 ec             	pushl  -0x14(%ebp)
    3058:	e8 58 d5 ff ff       	call   5b5 <read>
    305d:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    3060:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    3064:	66 c1 e8 03          	shr    $0x3,%ax
    3068:	0f b7 c0             	movzwl %ax,%eax
    306b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    306e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3075:	e9 c1 00 00 00       	jmp    313b <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    307a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    307d:	2b 45 f4             	sub    -0xc(%ebp),%eax
    3080:	8d 50 ff             	lea    -0x1(%eax),%edx
    3083:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3086:	0f af c2             	imul   %edx,%eax
    3089:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    308c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    308f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    3093:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    3096:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    309d:	e9 89 00 00 00       	jmp    312b <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    30a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    30a5:	83 c0 01             	add    $0x1,%eax
    30a8:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    30ac:	89 c2                	mov    %eax,%edx
    30ae:	8b 45 c8             	mov    -0x38(%ebp),%eax
    30b1:	01 d0                	add    %edx,%eax
    30b3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    30b6:	8b 55 c0             	mov    -0x40(%ebp),%edx
    30b9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    30bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    30bf:	01 c8                	add    %ecx,%eax
    30c1:	89 c1                	mov    %eax,%ecx
    30c3:	89 c8                	mov    %ecx,%eax
    30c5:	01 c0                	add    %eax,%eax
    30c7:	01 c8                	add    %ecx,%eax
    30c9:	01 c2                	add    %eax,%edx
    30cb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    30ce:	8d 48 ff             	lea    -0x1(%eax),%ecx
    30d1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    30d4:	01 c8                	add    %ecx,%eax
    30d6:	0f b6 00             	movzbl (%eax),%eax
    30d9:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    30dc:	8b 55 c0             	mov    -0x40(%ebp),%edx
    30df:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    30e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    30e5:	01 c8                	add    %ecx,%eax
    30e7:	89 c1                	mov    %eax,%ecx
    30e9:	89 c8                	mov    %ecx,%eax
    30eb:	01 c0                	add    %eax,%eax
    30ed:	01 c8                	add    %ecx,%eax
    30ef:	01 c2                	add    %eax,%edx
    30f1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    30f4:	8d 48 fe             	lea    -0x2(%eax),%ecx
    30f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    30fa:	01 c8                	add    %ecx,%eax
    30fc:	0f b6 00             	movzbl (%eax),%eax
    30ff:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    3102:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3105:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    3108:	8b 45 f0             	mov    -0x10(%ebp),%eax
    310b:	01 c8                	add    %ecx,%eax
    310d:	89 c1                	mov    %eax,%ecx
    310f:	89 c8                	mov    %ecx,%eax
    3111:	01 c0                	add    %eax,%eax
    3113:	01 c8                	add    %ecx,%eax
    3115:	01 c2                	add    %eax,%edx
    3117:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    311a:	8d 48 fd             	lea    -0x3(%eax),%ecx
    311d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3120:	01 c8                	add    %ecx,%eax
    3122:	0f b6 00             	movzbl (%eax),%eax
    3125:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    3127:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    312b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    312e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3131:	0f 8f 6b ff ff ff    	jg     30a2 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    3137:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    313b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    313e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3141:	0f 8f 33 ff ff ff    	jg     307a <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    3147:	83 ec 0c             	sub    $0xc,%esp
    314a:	ff 75 ec             	pushl  -0x14(%ebp)
    314d:	e8 73 d4 ff ff       	call   5c5 <close>
    3152:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3155:	8b 45 08             	mov    0x8(%ebp),%eax
    3158:	8b 55 b8             	mov    -0x48(%ebp),%edx
    315b:	89 10                	mov    %edx,(%eax)
    315d:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3160:	89 50 04             	mov    %edx,0x4(%eax)
    3163:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3166:	89 50 08             	mov    %edx,0x8(%eax)
}
    3169:	8b 45 08             	mov    0x8(%ebp),%eax
    316c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    316f:	5b                   	pop    %ebx
    3170:	5e                   	pop    %esi
    3171:	5d                   	pop    %ebp
    3172:	c2 04 00             	ret    $0x4

00003175 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    3175:	55                   	push   %ebp
    3176:	89 e5                	mov    %esp,%ebp
    3178:	53                   	push   %ebx
    3179:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    317c:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    3180:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    3184:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    3188:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    318c:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    3190:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    3194:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    3198:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    319c:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    31a0:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    31a4:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    31a8:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    31ac:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    31b0:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    31b4:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    31b8:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    31bc:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    31c0:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    31c4:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    31c8:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    31cc:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    31d0:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    31d4:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    31d8:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    31dc:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    31e0:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    31e4:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    31e8:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    31ec:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    31f0:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    31f4:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    31f8:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    31fc:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    3200:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    3204:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    3208:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    320c:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    3210:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    3214:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    3218:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    321c:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    3220:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    3224:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    3228:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    322c:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    3230:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    3234:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    3238:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    323c:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    3240:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    3244:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    3248:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    324c:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    3250:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    3254:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    3258:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    325c:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    3260:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    3264:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    3268:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    326c:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    3270:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    3274:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    3278:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    327c:	83 ec 0c             	sub    $0xc,%esp
    327f:	68 c8 02 08 00       	push   $0x802c8
    3284:	e8 8e d7 ff ff       	call   a17 <malloc>
    3289:	83 c4 10             	add    $0x10,%esp
    328c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    328f:	83 ec 04             	sub    $0x4,%esp
    3292:	68 c8 02 08 00       	push   $0x802c8
    3297:	6a 00                	push   $0x0
    3299:	ff 75 f0             	pushl  -0x10(%ebp)
    329c:	e8 61 d1 ff ff       	call   402 <memset>
    32a1:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    32a4:	83 ec 08             	sub    $0x8,%esp
    32a7:	6a 00                	push   $0x0
    32a9:	ff 75 0c             	pushl  0xc(%ebp)
    32ac:	e8 2c d3 ff ff       	call   5dd <open>
    32b1:	83 c4 10             	add    $0x10,%esp
    32b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    32b7:	83 ec 0c             	sub    $0xc,%esp
    32ba:	68 40 42 0f 00       	push   $0xf4240
    32bf:	e8 53 d7 ff ff       	call   a17 <malloc>
    32c4:	83 c4 10             	add    $0x10,%esp
    32c7:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    32ca:	83 ec 04             	sub    $0x4,%esp
    32cd:	68 40 42 0f 00       	push   $0xf4240
    32d2:	ff 75 e8             	pushl  -0x18(%ebp)
    32d5:	ff 75 ec             	pushl  -0x14(%ebp)
    32d8:	e8 d8 d2 ff ff       	call   5b5 <read>
    32dd:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    32e0:	83 ec 0c             	sub    $0xc,%esp
    32e3:	ff 75 ec             	pushl  -0x14(%ebp)
    32e6:	e8 da d2 ff ff       	call   5c5 <close>
    32eb:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    32ee:	68 40 42 0f 00       	push   $0xf4240
    32f3:	ff 75 e8             	pushl  -0x18(%ebp)
    32f6:	8d 45 9c             	lea    -0x64(%ebp),%eax
    32f9:	50                   	push   %eax
    32fa:	ff 75 f0             	pushl  -0x10(%ebp)
    32fd:	e8 5e 0c 01 00       	call   13f60 <_DecodeJPEG>
    3302:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    3305:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    330c:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    3313:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    331a:	83 ec 0c             	sub    $0xc,%esp
    331d:	ff 75 f0             	pushl  -0x10(%ebp)
    3320:	e8 29 0b 01 00       	call   13e4e <GetImageSize>
    3325:	83 c4 10             	add    $0x10,%esp
    3328:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    332b:	83 ec 0c             	sub    $0xc,%esp
    332e:	ff 75 f0             	pushl  -0x10(%ebp)
    3331:	e8 e1 0a 01 00       	call   13e17 <GetImage>
    3336:	83 c4 10             	add    $0x10,%esp
    3339:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    333c:	83 ec 0c             	sub    $0xc,%esp
    333f:	ff 75 f0             	pushl  -0x10(%ebp)
    3342:	e8 f1 0a 01 00       	call   13e38 <GetWidth>
    3347:	83 c4 10             	add    $0x10,%esp
    334a:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    334d:	83 ec 0c             	sub    $0xc,%esp
    3350:	ff 75 f0             	pushl  -0x10(%ebp)
    3353:	e8 eb 0a 01 00       	call   13e43 <GetHeight>
    3358:	83 c4 10             	add    $0x10,%esp
    335b:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    335e:	8b 55 90             	mov    -0x70(%ebp),%edx
    3361:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3364:	0f af c2             	imul   %edx,%eax
    3367:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    336a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    336d:	89 d0                	mov    %edx,%eax
    336f:	01 c0                	add    %eax,%eax
    3371:	01 d0                	add    %edx,%eax
    3373:	83 ec 0c             	sub    $0xc,%esp
    3376:	50                   	push   %eax
    3377:	e8 9b d6 ff ff       	call   a17 <malloc>
    337c:	83 c4 10             	add    $0x10,%esp
    337f:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    3382:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3389:	e9 9c 00 00 00       	jmp    342a <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    338e:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3391:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3394:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3399:	89 c8                	mov    %ecx,%eax
    339b:	f7 ea                	imul   %edx
    339d:	89 c8                	mov    %ecx,%eax
    339f:	c1 f8 1f             	sar    $0x1f,%eax
    33a2:	29 c2                	sub    %eax,%edx
    33a4:	89 d0                	mov    %edx,%eax
    33a6:	89 c2                	mov    %eax,%edx
    33a8:	89 d0                	mov    %edx,%eax
    33aa:	01 c0                	add    %eax,%eax
    33ac:	01 d0                	add    %edx,%eax
    33ae:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    33b1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    33b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    33b7:	01 c8                	add    %ecx,%eax
    33b9:	0f b6 00             	movzbl (%eax),%eax
    33bc:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    33bf:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    33c2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    33c5:	ba 56 55 55 55       	mov    $0x55555556,%edx
    33ca:	89 c8                	mov    %ecx,%eax
    33cc:	f7 ea                	imul   %edx
    33ce:	89 c8                	mov    %ecx,%eax
    33d0:	c1 f8 1f             	sar    $0x1f,%eax
    33d3:	29 c2                	sub    %eax,%edx
    33d5:	89 d0                	mov    %edx,%eax
    33d7:	89 c2                	mov    %eax,%edx
    33d9:	89 d0                	mov    %edx,%eax
    33db:	01 c0                	add    %eax,%eax
    33dd:	01 d0                	add    %edx,%eax
    33df:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    33e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    33e5:	8d 48 01             	lea    0x1(%eax),%ecx
    33e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    33eb:	01 c8                	add    %ecx,%eax
    33ed:	0f b6 00             	movzbl (%eax),%eax
    33f0:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    33f3:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    33f6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    33f9:	ba 56 55 55 55       	mov    $0x55555556,%edx
    33fe:	89 c8                	mov    %ecx,%eax
    3400:	f7 ea                	imul   %edx
    3402:	89 c8                	mov    %ecx,%eax
    3404:	c1 f8 1f             	sar    $0x1f,%eax
    3407:	29 c2                	sub    %eax,%edx
    3409:	89 d0                	mov    %edx,%eax
    340b:	89 c2                	mov    %eax,%edx
    340d:	89 d0                	mov    %edx,%eax
    340f:	01 c0                	add    %eax,%eax
    3411:	01 d0                	add    %edx,%eax
    3413:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3416:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3419:	8d 48 02             	lea    0x2(%eax),%ecx
    341c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    341f:	01 c8                	add    %ecx,%eax
    3421:	0f b6 00             	movzbl (%eax),%eax
    3424:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3426:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    342a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    342d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    3430:	0f 8c 58 ff ff ff    	jl     338e <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3436:	8b 45 08             	mov    0x8(%ebp),%eax
    3439:	8b 55 90             	mov    -0x70(%ebp),%edx
    343c:	89 10                	mov    %edx,(%eax)
    343e:	8b 55 94             	mov    -0x6c(%ebp),%edx
    3441:	89 50 04             	mov    %edx,0x4(%eax)
    3444:	8b 55 98             	mov    -0x68(%ebp),%edx
    3447:	89 50 08             	mov    %edx,0x8(%eax)
}
    344a:	8b 45 08             	mov    0x8(%ebp),%eax
    344d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3450:	c9                   	leave  
    3451:	c2 04 00             	ret    $0x4

00003454 <LoadPng>:

PBitmap LoadPng(char* filename){
    3454:	55                   	push   %ebp
    3455:	89 e5                	mov    %esp,%ebp
    3457:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    345a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    3461:	ff 75 0c             	pushl  0xc(%ebp)
    3464:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3467:	50                   	push   %eax
    3468:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    346b:	50                   	push   %eax
    346c:	8d 45 e8             	lea    -0x18(%ebp),%eax
    346f:	50                   	push   %eax
    3470:	e8 d3 d3 00 00       	call   10848 <lodepng_decode24_file>
    3475:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3478:	8b 45 e0             	mov    -0x20(%ebp),%eax
    347b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    347e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3481:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    3484:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    348b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    348e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3491:	0f af c2             	imul   %edx,%eax
    3494:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    3497:	8b 55 f0             	mov    -0x10(%ebp),%edx
    349a:	89 d0                	mov    %edx,%eax
    349c:	01 c0                	add    %eax,%eax
    349e:	01 d0                	add    %edx,%eax
    34a0:	83 ec 0c             	sub    $0xc,%esp
    34a3:	50                   	push   %eax
    34a4:	e8 6e d5 ff ff       	call   a17 <malloc>
    34a9:	83 c4 10             	add    $0x10,%esp
    34ac:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    34af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    34b6:	e9 87 00 00 00       	jmp    3542 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    34bb:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    34be:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34c1:	89 d0                	mov    %edx,%eax
    34c3:	01 c0                	add    %eax,%eax
    34c5:	01 d0                	add    %edx,%eax
    34c7:	01 c8                	add    %ecx,%eax
    34c9:	0f b6 00             	movzbl (%eax),%eax
    34cc:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    34cf:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    34d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34d5:	89 d0                	mov    %edx,%eax
    34d7:	01 c0                	add    %eax,%eax
    34d9:	01 d0                	add    %edx,%eax
    34db:	83 c0 01             	add    $0x1,%eax
    34de:	01 c8                	add    %ecx,%eax
    34e0:	0f b6 00             	movzbl (%eax),%eax
    34e3:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    34e6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    34e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34ec:	89 d0                	mov    %edx,%eax
    34ee:	01 c0                	add    %eax,%eax
    34f0:	01 d0                	add    %edx,%eax
    34f2:	83 c0 02             	add    $0x2,%eax
    34f5:	01 c8                	add    %ecx,%eax
    34f7:	0f b6 00             	movzbl (%eax),%eax
    34fa:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    34fd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3500:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3503:	89 d0                	mov    %edx,%eax
    3505:	01 c0                	add    %eax,%eax
    3507:	01 d0                	add    %edx,%eax
    3509:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    350c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    3510:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    3513:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3516:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3519:	89 d0                	mov    %edx,%eax
    351b:	01 c0                	add    %eax,%eax
    351d:	01 d0                	add    %edx,%eax
    351f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3522:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3526:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    3529:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    352c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    352f:	89 d0                	mov    %edx,%eax
    3531:	01 c0                	add    %eax,%eax
    3533:	01 d0                	add    %edx,%eax
    3535:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3538:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    353c:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    353e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3542:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3545:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3548:	0f 8c 6d ff ff ff    	jl     34bb <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    354e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3551:	83 ec 0c             	sub    $0xc,%esp
    3554:	50                   	push   %eax
    3555:	e8 7b d3 ff ff       	call   8d5 <free>
    355a:	83 c4 10             	add    $0x10,%esp
    return bmp;
    355d:	8b 45 08             	mov    0x8(%ebp),%eax
    3560:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3563:	89 10                	mov    %edx,(%eax)
    3565:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3568:	89 50 04             	mov    %edx,0x4(%eax)
    356b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    356e:	89 50 08             	mov    %edx,0x8(%eax)

}
    3571:	8b 45 08             	mov    0x8(%ebp),%eax
    3574:	c9                   	leave  
    3575:	c2 04 00             	ret    $0x4

00003578 <LoadImg>:

PBitmap LoadImg(char* filename){
    3578:	55                   	push   %ebp
    3579:	89 e5                	mov    %esp,%ebp
    357b:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    357e:	83 ec 0c             	sub    $0xc,%esp
    3581:	ff 75 0c             	pushl  0xc(%ebp)
    3584:	e8 7c f8 ff ff       	call   2e05 <type>
    3589:	83 c4 10             	add    $0x10,%esp
    358c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    358f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3592:	83 f8 01             	cmp    $0x1,%eax
    3595:	74 1d                	je     35b4 <LoadImg+0x3c>
    3597:	83 f8 02             	cmp    $0x2,%eax
    359a:	74 2c                	je     35c8 <LoadImg+0x50>
    359c:	85 c0                	test   %eax,%eax
    359e:	75 3c                	jne    35dc <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    35a0:	8b 45 08             	mov    0x8(%ebp),%eax
    35a3:	83 ec 08             	sub    $0x8,%esp
    35a6:	ff 75 0c             	pushl  0xc(%ebp)
    35a9:	50                   	push   %eax
    35aa:	e8 c6 fb ff ff       	call   3175 <LoadJpeg>
    35af:	83 c4 0c             	add    $0xc,%esp
    35b2:	eb 3c                	jmp    35f0 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    35b4:	8b 45 08             	mov    0x8(%ebp),%eax
    35b7:	83 ec 08             	sub    $0x8,%esp
    35ba:	ff 75 0c             	pushl  0xc(%ebp)
    35bd:	50                   	push   %eax
    35be:	e8 17 f9 ff ff       	call   2eda <LoadBmp>
    35c3:	83 c4 0c             	add    $0xc,%esp
    35c6:	eb 28                	jmp    35f0 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    35c8:	8b 45 08             	mov    0x8(%ebp),%eax
    35cb:	83 ec 08             	sub    $0x8,%esp
    35ce:	ff 75 0c             	pushl  0xc(%ebp)
    35d1:	50                   	push   %eax
    35d2:	e8 7d fe ff ff       	call   3454 <LoadPng>
    35d7:	83 c4 0c             	add    $0xc,%esp
    35da:	eb 14                	jmp    35f0 <LoadImg+0x78>

        default: return bmp;
    35dc:	8b 45 08             	mov    0x8(%ebp),%eax
    35df:	8b 55 e8             	mov    -0x18(%ebp),%edx
    35e2:	89 10                	mov    %edx,(%eax)
    35e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    35e7:	89 50 04             	mov    %edx,0x4(%eax)
    35ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
    35ed:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    35f0:	8b 45 08             	mov    0x8(%ebp),%eax
    35f3:	c9                   	leave  
    35f4:	c2 04 00             	ret    $0x4

000035f7 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    35f7:	55                   	push   %ebp
    35f8:	89 e5                	mov    %esp,%ebp
    35fa:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    35fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3600:	83 ec 0c             	sub    $0xc,%esp
    3603:	50                   	push   %eax
    3604:	e8 0e d4 ff ff       	call   a17 <malloc>
    3609:	83 c4 10             	add    $0x10,%esp
}
    360c:	c9                   	leave  
    360d:	c3                   	ret    

0000360e <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    360e:	55                   	push   %ebp
    360f:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    3611:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3616:	5d                   	pop    %ebp
    3617:	c3                   	ret    

00003618 <lodepng_free>:

static void lodepng_free(void* ptr) {
    3618:	55                   	push   %ebp
    3619:	89 e5                	mov    %esp,%ebp
    361b:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    361e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3622:	74 0e                	je     3632 <lodepng_free+0x1a>
    free(ptr);
    3624:	83 ec 0c             	sub    $0xc,%esp
    3627:	ff 75 08             	pushl  0x8(%ebp)
    362a:	e8 a6 d2 ff ff       	call   8d5 <free>
    362f:	83 c4 10             	add    $0x10,%esp
}
    3632:	90                   	nop
    3633:	c9                   	leave  
    3634:	c3                   	ret    

00003635 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3635:	55                   	push   %ebp
    3636:	89 e5                	mov    %esp,%ebp
    3638:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    363b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3642:	eb 19                	jmp    365d <lodepng_memcpy+0x28>
    3644:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3647:	8b 45 08             	mov    0x8(%ebp),%eax
    364a:	01 c2                	add    %eax,%edx
    364c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    364f:	8b 45 0c             	mov    0xc(%ebp),%eax
    3652:	01 c8                	add    %ecx,%eax
    3654:	0f b6 00             	movzbl (%eax),%eax
    3657:	88 02                	mov    %al,(%edx)
    3659:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    365d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3660:	3b 45 10             	cmp    0x10(%ebp),%eax
    3663:	7c df                	jl     3644 <lodepng_memcpy+0xf>
}
    3665:	90                   	nop
    3666:	c9                   	leave  
    3667:	c3                   	ret    

00003668 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3668:	55                   	push   %ebp
    3669:	89 e5                	mov    %esp,%ebp
    366b:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    366e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3675:	eb 11                	jmp    3688 <lodepng_memset+0x20>
    3677:	8b 55 fc             	mov    -0x4(%ebp),%edx
    367a:	8b 45 08             	mov    0x8(%ebp),%eax
    367d:	01 d0                	add    %edx,%eax
    367f:	8b 55 0c             	mov    0xc(%ebp),%edx
    3682:	88 10                	mov    %dl,(%eax)
    3684:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3688:	8b 45 fc             	mov    -0x4(%ebp),%eax
    368b:	3b 45 10             	cmp    0x10(%ebp),%eax
    368e:	7c e7                	jl     3677 <lodepng_memset+0xf>
}
    3690:	90                   	nop
    3691:	c9                   	leave  
    3692:	c3                   	ret    

00003693 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    3693:	55                   	push   %ebp
    3694:	89 e5                	mov    %esp,%ebp
    3696:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    3699:	8b 45 08             	mov    0x8(%ebp),%eax
    369c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    369f:	eb 04                	jmp    36a5 <lodepng_strlen+0x12>
    36a1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    36a5:	8b 45 08             	mov    0x8(%ebp),%eax
    36a8:	0f b6 00             	movzbl (%eax),%eax
    36ab:	84 c0                	test   %al,%al
    36ad:	75 f2                	jne    36a1 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    36af:	8b 55 08             	mov    0x8(%ebp),%edx
    36b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    36b5:	29 c2                	sub    %eax,%edx
    36b7:	89 d0                	mov    %edx,%eax
}
    36b9:	c9                   	leave  
    36ba:	c3                   	ret    

000036bb <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    36bb:	55                   	push   %ebp
    36bc:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    36be:	8b 55 08             	mov    0x8(%ebp),%edx
    36c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    36c4:	01 c2                	add    %eax,%edx
    36c6:	8b 45 10             	mov    0x10(%ebp),%eax
    36c9:	89 10                	mov    %edx,(%eax)
  return *result < a;
    36cb:	8b 45 10             	mov    0x10(%ebp),%eax
    36ce:	8b 00                	mov    (%eax),%eax
    36d0:	3b 45 08             	cmp    0x8(%ebp),%eax
    36d3:	0f 9c c0             	setl   %al
    36d6:	0f b6 c0             	movzbl %al,%eax
}
    36d9:	5d                   	pop    %ebp
    36da:	c3                   	ret    

000036db <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    36db:	55                   	push   %ebp
    36dc:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    36de:	8b 45 08             	mov    0x8(%ebp),%eax
    36e1:	0f af 45 0c          	imul   0xc(%ebp),%eax
    36e5:	89 c2                	mov    %eax,%edx
    36e7:	8b 45 10             	mov    0x10(%ebp),%eax
    36ea:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    36ec:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    36f0:	74 15                	je     3707 <lodepng_mulofl+0x2c>
    36f2:	8b 45 10             	mov    0x10(%ebp),%eax
    36f5:	8b 00                	mov    (%eax),%eax
    36f7:	99                   	cltd   
    36f8:	f7 7d 08             	idivl  0x8(%ebp)
    36fb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    36fe:	74 07                	je     3707 <lodepng_mulofl+0x2c>
    3700:	b8 01 00 00 00       	mov    $0x1,%eax
    3705:	eb 05                	jmp    370c <lodepng_mulofl+0x31>
    3707:	b8 00 00 00 00       	mov    $0x0,%eax
}
    370c:	5d                   	pop    %ebp
    370d:	c3                   	ret    

0000370e <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    370e:	55                   	push   %ebp
    370f:	89 e5                	mov    %esp,%ebp
    3711:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    3714:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3717:	50                   	push   %eax
    3718:	ff 75 0c             	pushl  0xc(%ebp)
    371b:	ff 75 08             	pushl  0x8(%ebp)
    371e:	e8 98 ff ff ff       	call   36bb <lodepng_addofl>
    3723:	83 c4 0c             	add    $0xc,%esp
    3726:	85 c0                	test   %eax,%eax
    3728:	74 07                	je     3731 <lodepng_gtofl+0x23>
    372a:	b8 01 00 00 00       	mov    $0x1,%eax
    372f:	eb 0c                	jmp    373d <lodepng_gtofl+0x2f>
  return d > c;
    3731:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3734:	3b 45 10             	cmp    0x10(%ebp),%eax
    3737:	0f 9f c0             	setg   %al
    373a:	0f b6 c0             	movzbl %al,%eax
}
    373d:	c9                   	leave  
    373e:	c3                   	ret    

0000373f <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    373f:	55                   	push   %ebp
    3740:	89 e5                	mov    %esp,%ebp
    3742:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3745:	8b 45 08             	mov    0x8(%ebp),%eax
    3748:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    374f:	8b 45 08             	mov    0x8(%ebp),%eax
    3752:	8b 50 08             	mov    0x8(%eax),%edx
    3755:	8b 45 08             	mov    0x8(%ebp),%eax
    3758:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    375b:	8b 45 08             	mov    0x8(%ebp),%eax
    375e:	8b 00                	mov    (%eax),%eax
    3760:	83 ec 0c             	sub    $0xc,%esp
    3763:	50                   	push   %eax
    3764:	e8 af fe ff ff       	call   3618 <lodepng_free>
    3769:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    376c:	8b 45 08             	mov    0x8(%ebp),%eax
    376f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3775:	90                   	nop
    3776:	c9                   	leave  
    3777:	c3                   	ret    

00003778 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3778:	55                   	push   %ebp
    3779:	89 e5                	mov    %esp,%ebp
    377b:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    377e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3781:	c1 e0 02             	shl    $0x2,%eax
    3784:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    3787:	8b 45 08             	mov    0x8(%ebp),%eax
    378a:	8b 40 08             	mov    0x8(%eax),%eax
    378d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3790:	7d 46                	jge    37d8 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    3792:	8b 45 08             	mov    0x8(%ebp),%eax
    3795:	8b 40 08             	mov    0x8(%eax),%eax
    3798:	d1 f8                	sar    %eax
    379a:	89 c2                	mov    %eax,%edx
    379c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    379f:	01 d0                	add    %edx,%eax
    37a1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    37a4:	8b 45 08             	mov    0x8(%ebp),%eax
    37a7:	8b 00                	mov    (%eax),%eax
    37a9:	ff 75 f8             	pushl  -0x8(%ebp)
    37ac:	50                   	push   %eax
    37ad:	e8 5c fe ff ff       	call   360e <lodepng_realloc>
    37b2:	83 c4 08             	add    $0x8,%esp
    37b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    37b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37bc:	74 13                	je     37d1 <uivector_resize+0x59>
      p->allocsize = newsize;
    37be:	8b 45 08             	mov    0x8(%ebp),%eax
    37c1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    37c4:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    37c7:	8b 45 08             	mov    0x8(%ebp),%eax
    37ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    37cd:	89 10                	mov    %edx,(%eax)
    37cf:	eb 07                	jmp    37d8 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    37d1:	b8 00 00 00 00       	mov    $0x0,%eax
    37d6:	eb 0e                	jmp    37e6 <uivector_resize+0x6e>
  }
  p->size = size;
    37d8:	8b 45 08             	mov    0x8(%ebp),%eax
    37db:	8b 55 0c             	mov    0xc(%ebp),%edx
    37de:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    37e1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    37e6:	c9                   	leave  
    37e7:	c3                   	ret    

000037e8 <uivector_init>:

static void uivector_init(uivector* p) {
    37e8:	55                   	push   %ebp
    37e9:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    37eb:	8b 45 08             	mov    0x8(%ebp),%eax
    37ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    37f4:	8b 45 08             	mov    0x8(%ebp),%eax
    37f7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    37fe:	8b 45 08             	mov    0x8(%ebp),%eax
    3801:	8b 50 08             	mov    0x8(%eax),%edx
    3804:	8b 45 08             	mov    0x8(%ebp),%eax
    3807:	89 50 04             	mov    %edx,0x4(%eax)
}
    380a:	90                   	nop
    380b:	5d                   	pop    %ebp
    380c:	c3                   	ret    

0000380d <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    380d:	55                   	push   %ebp
    380e:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    3810:	8b 45 08             	mov    0x8(%ebp),%eax
    3813:	8b 40 04             	mov    0x4(%eax),%eax
    3816:	83 c0 01             	add    $0x1,%eax
    3819:	50                   	push   %eax
    381a:	ff 75 08             	pushl  0x8(%ebp)
    381d:	e8 56 ff ff ff       	call   3778 <uivector_resize>
    3822:	83 c4 08             	add    $0x8,%esp
    3825:	85 c0                	test   %eax,%eax
    3827:	75 07                	jne    3830 <uivector_push_back+0x23>
    3829:	b8 00 00 00 00       	mov    $0x0,%eax
    382e:	eb 1f                	jmp    384f <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    3830:	8b 45 08             	mov    0x8(%ebp),%eax
    3833:	8b 10                	mov    (%eax),%edx
    3835:	8b 45 08             	mov    0x8(%ebp),%eax
    3838:	8b 40 04             	mov    0x4(%eax),%eax
    383b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    3840:	c1 e0 02             	shl    $0x2,%eax
    3843:	01 c2                	add    %eax,%edx
    3845:	8b 45 0c             	mov    0xc(%ebp),%eax
    3848:	89 02                	mov    %eax,(%edx)
  return 1;
    384a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    384f:	c9                   	leave  
    3850:	c3                   	ret    

00003851 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    3851:	55                   	push   %ebp
    3852:	89 e5                	mov    %esp,%ebp
    3854:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3857:	8b 45 08             	mov    0x8(%ebp),%eax
    385a:	8b 40 08             	mov    0x8(%eax),%eax
    385d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3860:	7d 46                	jge    38a8 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    3862:	8b 45 08             	mov    0x8(%ebp),%eax
    3865:	8b 40 08             	mov    0x8(%eax),%eax
    3868:	d1 f8                	sar    %eax
    386a:	89 c2                	mov    %eax,%edx
    386c:	8b 45 0c             	mov    0xc(%ebp),%eax
    386f:	01 d0                	add    %edx,%eax
    3871:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3874:	8b 45 08             	mov    0x8(%ebp),%eax
    3877:	8b 00                	mov    (%eax),%eax
    3879:	ff 75 fc             	pushl  -0x4(%ebp)
    387c:	50                   	push   %eax
    387d:	e8 8c fd ff ff       	call   360e <lodepng_realloc>
    3882:	83 c4 08             	add    $0x8,%esp
    3885:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    3888:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    388c:	74 13                	je     38a1 <ucvector_resize+0x50>
      p->allocsize = newsize;
    388e:	8b 45 08             	mov    0x8(%ebp),%eax
    3891:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3894:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    3897:	8b 45 08             	mov    0x8(%ebp),%eax
    389a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    389d:	89 10                	mov    %edx,(%eax)
    389f:	eb 07                	jmp    38a8 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    38a1:	b8 00 00 00 00       	mov    $0x0,%eax
    38a6:	eb 0e                	jmp    38b6 <ucvector_resize+0x65>
  }
  p->size = size;
    38a8:	8b 45 08             	mov    0x8(%ebp),%eax
    38ab:	8b 55 0c             	mov    0xc(%ebp),%edx
    38ae:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    38b1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    38b6:	c9                   	leave  
    38b7:	c3                   	ret    

000038b8 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    38b8:	55                   	push   %ebp
    38b9:	89 e5                	mov    %esp,%ebp
    38bb:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    38be:	8b 45 0c             	mov    0xc(%ebp),%eax
    38c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    38c4:	8b 45 10             	mov    0x10(%ebp),%eax
    38c7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    38ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    38cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    38d0:	8b 45 08             	mov    0x8(%ebp),%eax
    38d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    38d6:	89 10                	mov    %edx,(%eax)
    38d8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    38db:	89 50 04             	mov    %edx,0x4(%eax)
    38de:	8b 55 fc             	mov    -0x4(%ebp),%edx
    38e1:	89 50 08             	mov    %edx,0x8(%eax)
}
    38e4:	8b 45 08             	mov    0x8(%ebp),%eax
    38e7:	c9                   	leave  
    38e8:	c2 04 00             	ret    $0x4

000038eb <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    38eb:	55                   	push   %ebp
    38ec:	89 e5                	mov    %esp,%ebp
    38ee:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    38f1:	8b 45 08             	mov    0x8(%ebp),%eax
    38f4:	8b 00                	mov    (%eax),%eax
    38f6:	83 ec 0c             	sub    $0xc,%esp
    38f9:	50                   	push   %eax
    38fa:	e8 19 fd ff ff       	call   3618 <lodepng_free>
    38ff:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    3902:	8b 45 08             	mov    0x8(%ebp),%eax
    3905:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    390b:	90                   	nop
    390c:	c9                   	leave  
    390d:	c3                   	ret    

0000390e <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    390e:	55                   	push   %ebp
    390f:	89 e5                	mov    %esp,%ebp
    3911:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    3914:	8b 45 0c             	mov    0xc(%ebp),%eax
    3917:	83 c0 01             	add    $0x1,%eax
    391a:	83 ec 0c             	sub    $0xc,%esp
    391d:	50                   	push   %eax
    391e:	e8 d4 fc ff ff       	call   35f7 <lodepng_malloc>
    3923:	83 c4 10             	add    $0x10,%esp
    3926:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3929:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    392d:	74 1f                	je     394e <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    392f:	83 ec 04             	sub    $0x4,%esp
    3932:	ff 75 0c             	pushl  0xc(%ebp)
    3935:	ff 75 08             	pushl  0x8(%ebp)
    3938:	ff 75 f4             	pushl  -0xc(%ebp)
    393b:	e8 f5 fc ff ff       	call   3635 <lodepng_memcpy>
    3940:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    3943:	8b 55 0c             	mov    0xc(%ebp),%edx
    3946:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3949:	01 d0                	add    %edx,%eax
    394b:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    394e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3951:	c9                   	leave  
    3952:	c3                   	ret    

00003953 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    3953:	55                   	push   %ebp
    3954:	89 e5                	mov    %esp,%ebp
    3956:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3959:	ff 75 08             	pushl  0x8(%ebp)
    395c:	e8 32 fd ff ff       	call   3693 <lodepng_strlen>
    3961:	83 c4 04             	add    $0x4,%esp
    3964:	83 ec 08             	sub    $0x8,%esp
    3967:	50                   	push   %eax
    3968:	ff 75 08             	pushl  0x8(%ebp)
    396b:	e8 9e ff ff ff       	call   390e <alloc_string_sized>
    3970:	83 c4 10             	add    $0x10,%esp
}
    3973:	c9                   	leave  
    3974:	c3                   	ret    

00003975 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    3975:	55                   	push   %ebp
    3976:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3978:	8b 45 08             	mov    0x8(%ebp),%eax
    397b:	0f b6 00             	movzbl (%eax),%eax
    397e:	0f b6 c0             	movzbl %al,%eax
    3981:	c1 e0 18             	shl    $0x18,%eax
    3984:	89 c2                	mov    %eax,%edx
    3986:	8b 45 08             	mov    0x8(%ebp),%eax
    3989:	83 c0 01             	add    $0x1,%eax
    398c:	0f b6 00             	movzbl (%eax),%eax
    398f:	0f b6 c0             	movzbl %al,%eax
    3992:	c1 e0 10             	shl    $0x10,%eax
    3995:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3997:	8b 45 08             	mov    0x8(%ebp),%eax
    399a:	83 c0 02             	add    $0x2,%eax
    399d:	0f b6 00             	movzbl (%eax),%eax
    39a0:	0f b6 c0             	movzbl %al,%eax
    39a3:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    39a6:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    39a8:	8b 45 08             	mov    0x8(%ebp),%eax
    39ab:	83 c0 03             	add    $0x3,%eax
    39ae:	0f b6 00             	movzbl (%eax),%eax
    39b1:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    39b4:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    39b6:	5d                   	pop    %ebp
    39b7:	c3                   	ret    

000039b8 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    39b8:	55                   	push   %ebp
    39b9:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    39bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    39be:	c1 e8 18             	shr    $0x18,%eax
    39c1:	89 c2                	mov    %eax,%edx
    39c3:	8b 45 08             	mov    0x8(%ebp),%eax
    39c6:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    39c8:	8b 45 08             	mov    0x8(%ebp),%eax
    39cb:	83 c0 01             	add    $0x1,%eax
    39ce:	8b 55 0c             	mov    0xc(%ebp),%edx
    39d1:	c1 ea 10             	shr    $0x10,%edx
    39d4:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    39d6:	8b 45 08             	mov    0x8(%ebp),%eax
    39d9:	83 c0 02             	add    $0x2,%eax
    39dc:	8b 55 0c             	mov    0xc(%ebp),%edx
    39df:	c1 ea 08             	shr    $0x8,%edx
    39e2:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    39e4:	8b 45 08             	mov    0x8(%ebp),%eax
    39e7:	83 c0 03             	add    $0x3,%eax
    39ea:	8b 55 0c             	mov    0xc(%ebp),%edx
    39ed:	88 10                	mov    %dl,(%eax)
}
    39ef:	90                   	nop
    39f0:	5d                   	pop    %ebp
    39f1:	c3                   	ret    

000039f2 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    39f2:	55                   	push   %ebp
    39f3:	89 e5                	mov    %esp,%ebp
    39f5:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    39f8:	83 ec 08             	sub    $0x8,%esp
    39fb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    39fe:	50                   	push   %eax
    39ff:	ff 75 08             	pushl  0x8(%ebp)
    3a02:	e8 b7 ca ff ff       	call   4be <stat>
    3a07:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3a0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3a0d:	c9                   	leave  
    3a0e:	c3                   	ret    

00003a0f <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    3a0f:	55                   	push   %ebp
    3a10:	89 e5                	mov    %esp,%ebp
    3a12:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3a15:	83 ec 08             	sub    $0x8,%esp
    3a18:	6a 00                	push   $0x0
    3a1a:	ff 75 10             	pushl  0x10(%ebp)
    3a1d:	e8 bb cb ff ff       	call   5dd <open>
    3a22:	83 c4 10             	add    $0x10,%esp
    3a25:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3a28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3a2c:	79 07                	jns    3a35 <lodepng_buffer_file+0x26>
  {
      return -1;
    3a2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3a33:	eb 19                	jmp    3a4e <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3a35:	83 ec 04             	sub    $0x4,%esp
    3a38:	ff 75 0c             	pushl  0xc(%ebp)
    3a3b:	ff 75 08             	pushl  0x8(%ebp)
    3a3e:	ff 75 f4             	pushl  -0xc(%ebp)
    3a41:	e8 6f cb ff ff       	call   5b5 <read>
    3a46:	83 c4 10             	add    $0x10,%esp
  return 0;
    3a49:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3a4e:	c9                   	leave  
    3a4f:	c3                   	ret    

00003a50 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    3a50:	55                   	push   %ebp
    3a51:	89 e5                	mov    %esp,%ebp
    3a53:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3a56:	83 ec 0c             	sub    $0xc,%esp
    3a59:	ff 75 10             	pushl  0x10(%ebp)
    3a5c:	e8 91 ff ff ff       	call   39f2 <lodepng_filesize>
    3a61:	83 c4 10             	add    $0x10,%esp
    3a64:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3a67:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3a6b:	79 07                	jns    3a74 <lodepng_load_file+0x24>
    3a6d:	b8 4e 00 00 00       	mov    $0x4e,%eax
    3a72:	eb 4a                	jmp    3abe <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    3a74:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a77:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3a7a:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3a7c:	83 ec 0c             	sub    $0xc,%esp
    3a7f:	ff 75 f4             	pushl  -0xc(%ebp)
    3a82:	e8 70 fb ff ff       	call   35f7 <lodepng_malloc>
    3a87:	83 c4 10             	add    $0x10,%esp
    3a8a:	89 c2                	mov    %eax,%edx
    3a8c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a8f:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    3a91:	8b 45 08             	mov    0x8(%ebp),%eax
    3a94:	8b 00                	mov    (%eax),%eax
    3a96:	85 c0                	test   %eax,%eax
    3a98:	75 0d                	jne    3aa7 <lodepng_load_file+0x57>
    3a9a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3a9e:	7e 07                	jle    3aa7 <lodepng_load_file+0x57>
    3aa0:	b8 53 00 00 00       	mov    $0x53,%eax
    3aa5:	eb 17                	jmp    3abe <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    3aa7:	8b 45 08             	mov    0x8(%ebp),%eax
    3aaa:	8b 00                	mov    (%eax),%eax
    3aac:	83 ec 04             	sub    $0x4,%esp
    3aaf:	ff 75 10             	pushl  0x10(%ebp)
    3ab2:	ff 75 f4             	pushl  -0xc(%ebp)
    3ab5:	50                   	push   %eax
    3ab6:	e8 54 ff ff ff       	call   3a0f <lodepng_buffer_file>
    3abb:	83 c4 10             	add    $0x10,%esp
}
    3abe:	c9                   	leave  
    3abf:	c3                   	ret    

00003ac0 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    3ac0:	55                   	push   %ebp
    3ac1:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    3ac3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3ac8:	5d                   	pop    %ebp
    3ac9:	c3                   	ret    

00003aca <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3aca:	55                   	push   %ebp
    3acb:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3acd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ad0:	8b 55 0c             	mov    0xc(%ebp),%edx
    3ad3:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    3ad5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ad8:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3adc:	90                   	nop
    3add:	5d                   	pop    %ebp
    3ade:	c3                   	ret    

00003adf <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3adf:	55                   	push   %ebp
    3ae0:	89 e5                	mov    %esp,%ebp
    3ae2:	56                   	push   %esi
    3ae3:	53                   	push   %ebx
    3ae4:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3ae7:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3aeb:	0f 85 aa 00 00 00    	jne    3b9b <writeBits+0xbc>
    WRITEBIT(writer, value);
    3af1:	8b 45 08             	mov    0x8(%ebp),%eax
    3af4:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3af8:	0f b6 c0             	movzbl %al,%eax
    3afb:	83 e0 07             	and    $0x7,%eax
    3afe:	85 c0                	test   %eax,%eax
    3b00:	75 39                	jne    3b3b <writeBits+0x5c>
    3b02:	8b 45 08             	mov    0x8(%ebp),%eax
    3b05:	8b 00                	mov    (%eax),%eax
    3b07:	8b 40 04             	mov    0x4(%eax),%eax
    3b0a:	8d 50 01             	lea    0x1(%eax),%edx
    3b0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b10:	8b 00                	mov    (%eax),%eax
    3b12:	52                   	push   %edx
    3b13:	50                   	push   %eax
    3b14:	e8 38 fd ff ff       	call   3851 <ucvector_resize>
    3b19:	83 c4 08             	add    $0x8,%esp
    3b1c:	85 c0                	test   %eax,%eax
    3b1e:	0f 84 44 01 00 00    	je     3c68 <writeBits+0x189>
    3b24:	8b 45 08             	mov    0x8(%ebp),%eax
    3b27:	8b 00                	mov    (%eax),%eax
    3b29:	8b 10                	mov    (%eax),%edx
    3b2b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b2e:	8b 00                	mov    (%eax),%eax
    3b30:	8b 40 04             	mov    0x4(%eax),%eax
    3b33:	83 e8 01             	sub    $0x1,%eax
    3b36:	01 d0                	add    %edx,%eax
    3b38:	c6 00 00             	movb   $0x0,(%eax)
    3b3b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b3e:	8b 00                	mov    (%eax),%eax
    3b40:	8b 10                	mov    (%eax),%edx
    3b42:	8b 45 08             	mov    0x8(%ebp),%eax
    3b45:	8b 00                	mov    (%eax),%eax
    3b47:	8b 40 04             	mov    0x4(%eax),%eax
    3b4a:	83 e8 01             	sub    $0x1,%eax
    3b4d:	01 c2                	add    %eax,%edx
    3b4f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b52:	8b 00                	mov    (%eax),%eax
    3b54:	8b 08                	mov    (%eax),%ecx
    3b56:	8b 45 08             	mov    0x8(%ebp),%eax
    3b59:	8b 00                	mov    (%eax),%eax
    3b5b:	8b 40 04             	mov    0x4(%eax),%eax
    3b5e:	83 e8 01             	sub    $0x1,%eax
    3b61:	01 c8                	add    %ecx,%eax
    3b63:	0f b6 00             	movzbl (%eax),%eax
    3b66:	88 45 e7             	mov    %al,-0x19(%ebp)
    3b69:	8b 45 08             	mov    0x8(%ebp),%eax
    3b6c:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b70:	0f b6 c0             	movzbl %al,%eax
    3b73:	83 e0 07             	and    $0x7,%eax
    3b76:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3b79:	89 de                	mov    %ebx,%esi
    3b7b:	89 c1                	mov    %eax,%ecx
    3b7d:	d3 e6                	shl    %cl,%esi
    3b7f:	89 f0                	mov    %esi,%eax
    3b81:	0a 45 e7             	or     -0x19(%ebp),%al
    3b84:	88 02                	mov    %al,(%edx)
    3b86:	8b 45 08             	mov    0x8(%ebp),%eax
    3b89:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b8d:	8d 50 01             	lea    0x1(%eax),%edx
    3b90:	8b 45 08             	mov    0x8(%ebp),%eax
    3b93:	88 50 04             	mov    %dl,0x4(%eax)
    3b96:	e9 d1 00 00 00       	jmp    3c6c <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3b9b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3ba2:	e9 b3 00 00 00       	jmp    3c5a <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3ba7:	8b 45 08             	mov    0x8(%ebp),%eax
    3baa:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3bae:	0f b6 c0             	movzbl %al,%eax
    3bb1:	83 e0 07             	and    $0x7,%eax
    3bb4:	85 c0                	test   %eax,%eax
    3bb6:	75 39                	jne    3bf1 <writeBits+0x112>
    3bb8:	8b 45 08             	mov    0x8(%ebp),%eax
    3bbb:	8b 00                	mov    (%eax),%eax
    3bbd:	8b 40 04             	mov    0x4(%eax),%eax
    3bc0:	8d 50 01             	lea    0x1(%eax),%edx
    3bc3:	8b 45 08             	mov    0x8(%ebp),%eax
    3bc6:	8b 00                	mov    (%eax),%eax
    3bc8:	52                   	push   %edx
    3bc9:	50                   	push   %eax
    3bca:	e8 82 fc ff ff       	call   3851 <ucvector_resize>
    3bcf:	83 c4 08             	add    $0x8,%esp
    3bd2:	85 c0                	test   %eax,%eax
    3bd4:	0f 84 91 00 00 00    	je     3c6b <writeBits+0x18c>
    3bda:	8b 45 08             	mov    0x8(%ebp),%eax
    3bdd:	8b 00                	mov    (%eax),%eax
    3bdf:	8b 10                	mov    (%eax),%edx
    3be1:	8b 45 08             	mov    0x8(%ebp),%eax
    3be4:	8b 00                	mov    (%eax),%eax
    3be6:	8b 40 04             	mov    0x4(%eax),%eax
    3be9:	83 e8 01             	sub    $0x1,%eax
    3bec:	01 d0                	add    %edx,%eax
    3bee:	c6 00 00             	movb   $0x0,(%eax)
    3bf1:	8b 45 08             	mov    0x8(%ebp),%eax
    3bf4:	8b 00                	mov    (%eax),%eax
    3bf6:	8b 10                	mov    (%eax),%edx
    3bf8:	8b 45 08             	mov    0x8(%ebp),%eax
    3bfb:	8b 00                	mov    (%eax),%eax
    3bfd:	8b 40 04             	mov    0x4(%eax),%eax
    3c00:	83 e8 01             	sub    $0x1,%eax
    3c03:	01 c2                	add    %eax,%edx
    3c05:	8b 45 08             	mov    0x8(%ebp),%eax
    3c08:	8b 00                	mov    (%eax),%eax
    3c0a:	8b 08                	mov    (%eax),%ecx
    3c0c:	8b 45 08             	mov    0x8(%ebp),%eax
    3c0f:	8b 00                	mov    (%eax),%eax
    3c11:	8b 40 04             	mov    0x4(%eax),%eax
    3c14:	83 e8 01             	sub    $0x1,%eax
    3c17:	01 c8                	add    %ecx,%eax
    3c19:	0f b6 00             	movzbl (%eax),%eax
    3c1c:	89 c6                	mov    %eax,%esi
    3c1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c21:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3c24:	89 c1                	mov    %eax,%ecx
    3c26:	d3 eb                	shr    %cl,%ebx
    3c28:	89 d8                	mov    %ebx,%eax
    3c2a:	83 e0 01             	and    $0x1,%eax
    3c2d:	89 c3                	mov    %eax,%ebx
    3c2f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c32:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c36:	0f b6 c0             	movzbl %al,%eax
    3c39:	83 e0 07             	and    $0x7,%eax
    3c3c:	89 c1                	mov    %eax,%ecx
    3c3e:	d3 e3                	shl    %cl,%ebx
    3c40:	89 d8                	mov    %ebx,%eax
    3c42:	09 f0                	or     %esi,%eax
    3c44:	88 02                	mov    %al,(%edx)
    3c46:	8b 45 08             	mov    0x8(%ebp),%eax
    3c49:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c4d:	8d 50 01             	lea    0x1(%eax),%edx
    3c50:	8b 45 08             	mov    0x8(%ebp),%eax
    3c53:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3c56:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3c5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c5d:	3b 45 10             	cmp    0x10(%ebp),%eax
    3c60:	0f 85 41 ff ff ff    	jne    3ba7 <writeBits+0xc8>
    3c66:	eb 04                	jmp    3c6c <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3c68:	90                   	nop
    3c69:	eb 01                	jmp    3c6c <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3c6b:	90                   	nop
    }
  }
}
    3c6c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3c6f:	5b                   	pop    %ebx
    3c70:	5e                   	pop    %esi
    3c71:	5d                   	pop    %ebp
    3c72:	c3                   	ret    

00003c73 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3c73:	55                   	push   %ebp
    3c74:	89 e5                	mov    %esp,%ebp
    3c76:	56                   	push   %esi
    3c77:	53                   	push   %ebx
    3c78:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3c7b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3c82:	e9 bd 00 00 00       	jmp    3d44 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3c87:	8b 45 08             	mov    0x8(%ebp),%eax
    3c8a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c8e:	0f b6 c0             	movzbl %al,%eax
    3c91:	83 e0 07             	and    $0x7,%eax
    3c94:	85 c0                	test   %eax,%eax
    3c96:	75 39                	jne    3cd1 <writeBitsReversed+0x5e>
    3c98:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9b:	8b 00                	mov    (%eax),%eax
    3c9d:	8b 40 04             	mov    0x4(%eax),%eax
    3ca0:	8d 50 01             	lea    0x1(%eax),%edx
    3ca3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca6:	8b 00                	mov    (%eax),%eax
    3ca8:	52                   	push   %edx
    3ca9:	50                   	push   %eax
    3caa:	e8 a2 fb ff ff       	call   3851 <ucvector_resize>
    3caf:	83 c4 08             	add    $0x8,%esp
    3cb2:	85 c0                	test   %eax,%eax
    3cb4:	0f 84 98 00 00 00    	je     3d52 <writeBitsReversed+0xdf>
    3cba:	8b 45 08             	mov    0x8(%ebp),%eax
    3cbd:	8b 00                	mov    (%eax),%eax
    3cbf:	8b 10                	mov    (%eax),%edx
    3cc1:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc4:	8b 00                	mov    (%eax),%eax
    3cc6:	8b 40 04             	mov    0x4(%eax),%eax
    3cc9:	83 e8 01             	sub    $0x1,%eax
    3ccc:	01 d0                	add    %edx,%eax
    3cce:	c6 00 00             	movb   $0x0,(%eax)
    3cd1:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd4:	8b 00                	mov    (%eax),%eax
    3cd6:	8b 10                	mov    (%eax),%edx
    3cd8:	8b 45 08             	mov    0x8(%ebp),%eax
    3cdb:	8b 00                	mov    (%eax),%eax
    3cdd:	8b 40 04             	mov    0x4(%eax),%eax
    3ce0:	83 e8 01             	sub    $0x1,%eax
    3ce3:	01 c2                	add    %eax,%edx
    3ce5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce8:	8b 00                	mov    (%eax),%eax
    3cea:	8b 08                	mov    (%eax),%ecx
    3cec:	8b 45 08             	mov    0x8(%ebp),%eax
    3cef:	8b 00                	mov    (%eax),%eax
    3cf1:	8b 40 04             	mov    0x4(%eax),%eax
    3cf4:	83 e8 01             	sub    $0x1,%eax
    3cf7:	01 c8                	add    %ecx,%eax
    3cf9:	0f b6 00             	movzbl (%eax),%eax
    3cfc:	89 c6                	mov    %eax,%esi
    3cfe:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3d01:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3d04:	29 c1                	sub    %eax,%ecx
    3d06:	89 c8                	mov    %ecx,%eax
    3d08:	83 e8 01             	sub    $0x1,%eax
    3d0b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3d0e:	89 c1                	mov    %eax,%ecx
    3d10:	d3 eb                	shr    %cl,%ebx
    3d12:	89 d8                	mov    %ebx,%eax
    3d14:	83 e0 01             	and    $0x1,%eax
    3d17:	89 c3                	mov    %eax,%ebx
    3d19:	8b 45 08             	mov    0x8(%ebp),%eax
    3d1c:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3d20:	0f b6 c0             	movzbl %al,%eax
    3d23:	83 e0 07             	and    $0x7,%eax
    3d26:	89 c1                	mov    %eax,%ecx
    3d28:	d3 e3                	shl    %cl,%ebx
    3d2a:	89 d8                	mov    %ebx,%eax
    3d2c:	09 f0                	or     %esi,%eax
    3d2e:	88 02                	mov    %al,(%edx)
    3d30:	8b 45 08             	mov    0x8(%ebp),%eax
    3d33:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3d37:	8d 50 01             	lea    0x1(%eax),%edx
    3d3a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d3d:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3d40:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3d44:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3d47:	3b 45 10             	cmp    0x10(%ebp),%eax
    3d4a:	0f 85 37 ff ff ff    	jne    3c87 <writeBitsReversed+0x14>
    3d50:	eb 01                	jmp    3d53 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3d52:	90                   	nop
  }
}
    3d53:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3d56:	5b                   	pop    %ebx
    3d57:	5e                   	pop    %esi
    3d58:	5d                   	pop    %ebp
    3d59:	c3                   	ret    

00003d5a <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3d5a:	55                   	push   %ebp
    3d5b:	89 e5                	mov    %esp,%ebp
    3d5d:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3d60:	8b 45 08             	mov    0x8(%ebp),%eax
    3d63:	8b 55 0c             	mov    0xc(%ebp),%edx
    3d66:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3d68:	8b 45 08             	mov    0x8(%ebp),%eax
    3d6b:	8b 55 10             	mov    0x10(%ebp),%edx
    3d6e:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3d71:	8b 45 08             	mov    0x8(%ebp),%eax
    3d74:	83 c0 08             	add    $0x8,%eax
    3d77:	50                   	push   %eax
    3d78:	6a 08                	push   $0x8
    3d7a:	ff 75 10             	pushl  0x10(%ebp)
    3d7d:	e8 59 f9 ff ff       	call   36db <lodepng_mulofl>
    3d82:	83 c4 0c             	add    $0xc,%esp
    3d85:	85 c0                	test   %eax,%eax
    3d87:	74 07                	je     3d90 <LodePNGBitReader_init+0x36>
    3d89:	b8 69 00 00 00       	mov    $0x69,%eax
    3d8e:	eb 39                	jmp    3dc9 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3d90:	8b 45 08             	mov    0x8(%ebp),%eax
    3d93:	8b 40 08             	mov    0x8(%eax),%eax
    3d96:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3d99:	52                   	push   %edx
    3d9a:	6a 40                	push   $0x40
    3d9c:	50                   	push   %eax
    3d9d:	e8 19 f9 ff ff       	call   36bb <lodepng_addofl>
    3da2:	83 c4 0c             	add    $0xc,%esp
    3da5:	85 c0                	test   %eax,%eax
    3da7:	74 07                	je     3db0 <LodePNGBitReader_init+0x56>
    3da9:	b8 69 00 00 00       	mov    $0x69,%eax
    3dae:	eb 19                	jmp    3dc9 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3db0:	8b 45 08             	mov    0x8(%ebp),%eax
    3db3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3dba:	8b 45 08             	mov    0x8(%ebp),%eax
    3dbd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3dc4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3dc9:	c9                   	leave  
    3dca:	c3                   	ret    

00003dcb <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3dcb:	55                   	push   %ebp
    3dcc:	89 e5                	mov    %esp,%ebp
    3dce:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3dd1:	8b 45 08             	mov    0x8(%ebp),%eax
    3dd4:	8b 40 0c             	mov    0xc(%eax),%eax
    3dd7:	c1 f8 03             	sar    $0x3,%eax
    3dda:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3ddd:	8b 45 08             	mov    0x8(%ebp),%eax
    3de0:	8b 40 04             	mov    0x4(%eax),%eax
    3de3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3de6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3de9:	8d 50 01             	lea    0x1(%eax),%edx
    3dec:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3def:	39 c2                	cmp    %eax,%edx
    3df1:	73 4e                	jae    3e41 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3df3:	8b 45 08             	mov    0x8(%ebp),%eax
    3df6:	8b 10                	mov    (%eax),%edx
    3df8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dfb:	01 d0                	add    %edx,%eax
    3dfd:	0f b6 00             	movzbl (%eax),%eax
    3e00:	0f b6 d0             	movzbl %al,%edx
    3e03:	8b 45 08             	mov    0x8(%ebp),%eax
    3e06:	8b 00                	mov    (%eax),%eax
    3e08:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e0b:	83 c1 01             	add    $0x1,%ecx
    3e0e:	01 c8                	add    %ecx,%eax
    3e10:	0f b6 00             	movzbl (%eax),%eax
    3e13:	0f b6 c0             	movzbl %al,%eax
    3e16:	c1 e0 08             	shl    $0x8,%eax
    3e19:	09 c2                	or     %eax,%edx
    3e1b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1e:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e21:	8b 45 08             	mov    0x8(%ebp),%eax
    3e24:	8b 50 10             	mov    0x10(%eax),%edx
    3e27:	8b 45 08             	mov    0x8(%ebp),%eax
    3e2a:	8b 40 0c             	mov    0xc(%eax),%eax
    3e2d:	83 e0 07             	and    $0x7,%eax
    3e30:	89 c1                	mov    %eax,%ecx
    3e32:	d3 ea                	shr    %cl,%edx
    3e34:	8b 45 08             	mov    0x8(%ebp),%eax
    3e37:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3e3a:	b8 01 00 00 00       	mov    $0x1,%eax
    3e3f:	eb 64                	jmp    3ea5 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3e41:	8b 45 08             	mov    0x8(%ebp),%eax
    3e44:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3e4b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e51:	39 c2                	cmp    %eax,%edx
    3e53:	73 1e                	jae    3e73 <ensureBits9+0xa8>
    3e55:	8b 45 08             	mov    0x8(%ebp),%eax
    3e58:	8b 50 10             	mov    0x10(%eax),%edx
    3e5b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e5e:	8b 08                	mov    (%eax),%ecx
    3e60:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e63:	01 c8                	add    %ecx,%eax
    3e65:	0f b6 00             	movzbl (%eax),%eax
    3e68:	0f b6 c0             	movzbl %al,%eax
    3e6b:	09 c2                	or     %eax,%edx
    3e6d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e70:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e73:	8b 45 08             	mov    0x8(%ebp),%eax
    3e76:	8b 50 10             	mov    0x10(%eax),%edx
    3e79:	8b 45 08             	mov    0x8(%ebp),%eax
    3e7c:	8b 40 0c             	mov    0xc(%eax),%eax
    3e7f:	83 e0 07             	and    $0x7,%eax
    3e82:	89 c1                	mov    %eax,%ecx
    3e84:	d3 ea                	shr    %cl,%edx
    3e86:	8b 45 08             	mov    0x8(%ebp),%eax
    3e89:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3e8c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e8f:	8b 50 0c             	mov    0xc(%eax),%edx
    3e92:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e95:	01 c2                	add    %eax,%edx
    3e97:	8b 45 08             	mov    0x8(%ebp),%eax
    3e9a:	8b 40 08             	mov    0x8(%eax),%eax
    3e9d:	39 c2                	cmp    %eax,%edx
    3e9f:	0f 9e c0             	setle  %al
    3ea2:	0f b6 c0             	movzbl %al,%eax
  }
}
    3ea5:	c9                   	leave  
    3ea6:	c3                   	ret    

00003ea7 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3ea7:	55                   	push   %ebp
    3ea8:	89 e5                	mov    %esp,%ebp
    3eaa:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3ead:	8b 45 08             	mov    0x8(%ebp),%eax
    3eb0:	8b 40 0c             	mov    0xc(%eax),%eax
    3eb3:	c1 f8 03             	sar    $0x3,%eax
    3eb6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3eb9:	8b 45 08             	mov    0x8(%ebp),%eax
    3ebc:	8b 40 04             	mov    0x4(%eax),%eax
    3ebf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3ec2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ec5:	8d 50 02             	lea    0x2(%eax),%edx
    3ec8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ecb:	39 c2                	cmp    %eax,%edx
    3ecd:	73 6d                	jae    3f3c <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ecf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed2:	8b 10                	mov    (%eax),%edx
    3ed4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ed7:	01 d0                	add    %edx,%eax
    3ed9:	0f b6 00             	movzbl (%eax),%eax
    3edc:	0f b6 d0             	movzbl %al,%edx
    3edf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ee2:	8b 00                	mov    (%eax),%eax
    3ee4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3ee7:	83 c1 01             	add    $0x1,%ecx
    3eea:	01 c8                	add    %ecx,%eax
    3eec:	0f b6 00             	movzbl (%eax),%eax
    3eef:	0f b6 c0             	movzbl %al,%eax
    3ef2:	c1 e0 08             	shl    $0x8,%eax
    3ef5:	89 d1                	mov    %edx,%ecx
    3ef7:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3ef9:	8b 45 08             	mov    0x8(%ebp),%eax
    3efc:	8b 00                	mov    (%eax),%eax
    3efe:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3f01:	83 c2 02             	add    $0x2,%edx
    3f04:	01 d0                	add    %edx,%eax
    3f06:	0f b6 00             	movzbl (%eax),%eax
    3f09:	0f b6 c0             	movzbl %al,%eax
    3f0c:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f0f:	09 c1                	or     %eax,%ecx
    3f11:	89 ca                	mov    %ecx,%edx
    3f13:	8b 45 08             	mov    0x8(%ebp),%eax
    3f16:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3f19:	8b 45 08             	mov    0x8(%ebp),%eax
    3f1c:	8b 50 10             	mov    0x10(%eax),%edx
    3f1f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f22:	8b 40 0c             	mov    0xc(%eax),%eax
    3f25:	83 e0 07             	and    $0x7,%eax
    3f28:	89 c1                	mov    %eax,%ecx
    3f2a:	d3 ea                	shr    %cl,%edx
    3f2c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f2f:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3f32:	b8 01 00 00 00       	mov    $0x1,%eax
    3f37:	e9 95 00 00 00       	jmp    3fd1 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3f3c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f3f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f46:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3f49:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f4c:	39 c2                	cmp    %eax,%edx
    3f4e:	73 1e                	jae    3f6e <ensureBits17+0xc7>
    3f50:	8b 45 08             	mov    0x8(%ebp),%eax
    3f53:	8b 50 10             	mov    0x10(%eax),%edx
    3f56:	8b 45 08             	mov    0x8(%ebp),%eax
    3f59:	8b 08                	mov    (%eax),%ecx
    3f5b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f5e:	01 c8                	add    %ecx,%eax
    3f60:	0f b6 00             	movzbl (%eax),%eax
    3f63:	0f b6 c0             	movzbl %al,%eax
    3f66:	09 c2                	or     %eax,%edx
    3f68:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6b:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3f6e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f71:	8d 50 01             	lea    0x1(%eax),%edx
    3f74:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f77:	39 c2                	cmp    %eax,%edx
    3f79:	73 24                	jae    3f9f <ensureBits17+0xf8>
    3f7b:	8b 45 08             	mov    0x8(%ebp),%eax
    3f7e:	8b 50 10             	mov    0x10(%eax),%edx
    3f81:	8b 45 08             	mov    0x8(%ebp),%eax
    3f84:	8b 00                	mov    (%eax),%eax
    3f86:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3f89:	83 c1 01             	add    $0x1,%ecx
    3f8c:	01 c8                	add    %ecx,%eax
    3f8e:	0f b6 00             	movzbl (%eax),%eax
    3f91:	0f b6 c0             	movzbl %al,%eax
    3f94:	c1 e0 08             	shl    $0x8,%eax
    3f97:	09 c2                	or     %eax,%edx
    3f99:	8b 45 08             	mov    0x8(%ebp),%eax
    3f9c:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3f9f:	8b 45 08             	mov    0x8(%ebp),%eax
    3fa2:	8b 50 10             	mov    0x10(%eax),%edx
    3fa5:	8b 45 08             	mov    0x8(%ebp),%eax
    3fa8:	8b 40 0c             	mov    0xc(%eax),%eax
    3fab:	83 e0 07             	and    $0x7,%eax
    3fae:	89 c1                	mov    %eax,%ecx
    3fb0:	d3 ea                	shr    %cl,%edx
    3fb2:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb5:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3fb8:	8b 45 08             	mov    0x8(%ebp),%eax
    3fbb:	8b 50 0c             	mov    0xc(%eax),%edx
    3fbe:	8b 45 0c             	mov    0xc(%ebp),%eax
    3fc1:	01 c2                	add    %eax,%edx
    3fc3:	8b 45 08             	mov    0x8(%ebp),%eax
    3fc6:	8b 40 08             	mov    0x8(%eax),%eax
    3fc9:	39 c2                	cmp    %eax,%edx
    3fcb:	0f 9e c0             	setle  %al
    3fce:	0f b6 c0             	movzbl %al,%eax
  }
}
    3fd1:	c9                   	leave  
    3fd2:	c3                   	ret    

00003fd3 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3fd3:	55                   	push   %ebp
    3fd4:	89 e5                	mov    %esp,%ebp
    3fd6:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3fd9:	8b 45 08             	mov    0x8(%ebp),%eax
    3fdc:	8b 40 0c             	mov    0xc(%eax),%eax
    3fdf:	c1 f8 03             	sar    $0x3,%eax
    3fe2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3fe5:	8b 45 08             	mov    0x8(%ebp),%eax
    3fe8:	8b 40 04             	mov    0x4(%eax),%eax
    3feb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3fee:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ff1:	8d 50 03             	lea    0x3(%eax),%edx
    3ff4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ff7:	39 c2                	cmp    %eax,%edx
    3ff9:	0f 83 85 00 00 00    	jae    4084 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3fff:	8b 45 08             	mov    0x8(%ebp),%eax
    4002:	8b 10                	mov    (%eax),%edx
    4004:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4007:	01 d0                	add    %edx,%eax
    4009:	0f b6 00             	movzbl (%eax),%eax
    400c:	0f b6 d0             	movzbl %al,%edx
    400f:	8b 45 08             	mov    0x8(%ebp),%eax
    4012:	8b 00                	mov    (%eax),%eax
    4014:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4017:	83 c1 01             	add    $0x1,%ecx
    401a:	01 c8                	add    %ecx,%eax
    401c:	0f b6 00             	movzbl (%eax),%eax
    401f:	0f b6 c0             	movzbl %al,%eax
    4022:	c1 e0 08             	shl    $0x8,%eax
    4025:	89 d1                	mov    %edx,%ecx
    4027:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4029:	8b 45 08             	mov    0x8(%ebp),%eax
    402c:	8b 00                	mov    (%eax),%eax
    402e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4031:	83 c2 02             	add    $0x2,%edx
    4034:	01 d0                	add    %edx,%eax
    4036:	0f b6 00             	movzbl (%eax),%eax
    4039:	0f b6 c0             	movzbl %al,%eax
    403c:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    403f:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4041:	8b 45 08             	mov    0x8(%ebp),%eax
    4044:	8b 00                	mov    (%eax),%eax
    4046:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4049:	83 c2 03             	add    $0x3,%edx
    404c:	01 d0                	add    %edx,%eax
    404e:	0f b6 00             	movzbl (%eax),%eax
    4051:	0f b6 c0             	movzbl %al,%eax
    4054:	c1 e0 18             	shl    $0x18,%eax
    4057:	09 c1                	or     %eax,%ecx
    4059:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    405b:	8b 45 08             	mov    0x8(%ebp),%eax
    405e:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4061:	8b 45 08             	mov    0x8(%ebp),%eax
    4064:	8b 50 10             	mov    0x10(%eax),%edx
    4067:	8b 45 08             	mov    0x8(%ebp),%eax
    406a:	8b 40 0c             	mov    0xc(%eax),%eax
    406d:	83 e0 07             	and    $0x7,%eax
    4070:	89 c1                	mov    %eax,%ecx
    4072:	d3 ea                	shr    %cl,%edx
    4074:	8b 45 08             	mov    0x8(%ebp),%eax
    4077:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    407a:	b8 01 00 00 00       	mov    $0x1,%eax
    407f:	e9 c6 00 00 00       	jmp    414a <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    4084:	8b 45 08             	mov    0x8(%ebp),%eax
    4087:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    408e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4091:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4094:	39 c2                	cmp    %eax,%edx
    4096:	73 1e                	jae    40b6 <ensureBits25+0xe3>
    4098:	8b 45 08             	mov    0x8(%ebp),%eax
    409b:	8b 50 10             	mov    0x10(%eax),%edx
    409e:	8b 45 08             	mov    0x8(%ebp),%eax
    40a1:	8b 08                	mov    (%eax),%ecx
    40a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    40a6:	01 c8                	add    %ecx,%eax
    40a8:	0f b6 00             	movzbl (%eax),%eax
    40ab:	0f b6 c0             	movzbl %al,%eax
    40ae:	09 c2                	or     %eax,%edx
    40b0:	8b 45 08             	mov    0x8(%ebp),%eax
    40b3:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    40b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    40b9:	8d 50 01             	lea    0x1(%eax),%edx
    40bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40bf:	39 c2                	cmp    %eax,%edx
    40c1:	73 24                	jae    40e7 <ensureBits25+0x114>
    40c3:	8b 45 08             	mov    0x8(%ebp),%eax
    40c6:	8b 50 10             	mov    0x10(%eax),%edx
    40c9:	8b 45 08             	mov    0x8(%ebp),%eax
    40cc:	8b 00                	mov    (%eax),%eax
    40ce:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    40d1:	83 c1 01             	add    $0x1,%ecx
    40d4:	01 c8                	add    %ecx,%eax
    40d6:	0f b6 00             	movzbl (%eax),%eax
    40d9:	0f b6 c0             	movzbl %al,%eax
    40dc:	c1 e0 08             	shl    $0x8,%eax
    40df:	09 c2                	or     %eax,%edx
    40e1:	8b 45 08             	mov    0x8(%ebp),%eax
    40e4:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    40e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    40ea:	8d 50 02             	lea    0x2(%eax),%edx
    40ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40f0:	39 c2                	cmp    %eax,%edx
    40f2:	73 24                	jae    4118 <ensureBits25+0x145>
    40f4:	8b 45 08             	mov    0x8(%ebp),%eax
    40f7:	8b 50 10             	mov    0x10(%eax),%edx
    40fa:	8b 45 08             	mov    0x8(%ebp),%eax
    40fd:	8b 00                	mov    (%eax),%eax
    40ff:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4102:	83 c1 02             	add    $0x2,%ecx
    4105:	01 c8                	add    %ecx,%eax
    4107:	0f b6 00             	movzbl (%eax),%eax
    410a:	0f b6 c0             	movzbl %al,%eax
    410d:	c1 e0 10             	shl    $0x10,%eax
    4110:	09 c2                	or     %eax,%edx
    4112:	8b 45 08             	mov    0x8(%ebp),%eax
    4115:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4118:	8b 45 08             	mov    0x8(%ebp),%eax
    411b:	8b 50 10             	mov    0x10(%eax),%edx
    411e:	8b 45 08             	mov    0x8(%ebp),%eax
    4121:	8b 40 0c             	mov    0xc(%eax),%eax
    4124:	83 e0 07             	and    $0x7,%eax
    4127:	89 c1                	mov    %eax,%ecx
    4129:	d3 ea                	shr    %cl,%edx
    412b:	8b 45 08             	mov    0x8(%ebp),%eax
    412e:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4131:	8b 45 08             	mov    0x8(%ebp),%eax
    4134:	8b 50 0c             	mov    0xc(%eax),%edx
    4137:	8b 45 0c             	mov    0xc(%ebp),%eax
    413a:	01 c2                	add    %eax,%edx
    413c:	8b 45 08             	mov    0x8(%ebp),%eax
    413f:	8b 40 08             	mov    0x8(%eax),%eax
    4142:	39 c2                	cmp    %eax,%edx
    4144:	0f 9e c0             	setle  %al
    4147:	0f b6 c0             	movzbl %al,%eax
  }
}
    414a:	c9                   	leave  
    414b:	c3                   	ret    

0000414c <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    414c:	55                   	push   %ebp
    414d:	89 e5                	mov    %esp,%ebp
    414f:	53                   	push   %ebx
    4150:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4153:	8b 45 08             	mov    0x8(%ebp),%eax
    4156:	8b 40 0c             	mov    0xc(%eax),%eax
    4159:	c1 f8 03             	sar    $0x3,%eax
    415c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    415f:	8b 45 08             	mov    0x8(%ebp),%eax
    4162:	8b 40 04             	mov    0x4(%eax),%eax
    4165:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    4168:	8b 45 f8             	mov    -0x8(%ebp),%eax
    416b:	8d 50 04             	lea    0x4(%eax),%edx
    416e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4171:	39 c2                	cmp    %eax,%edx
    4173:	0f 83 c3 00 00 00    	jae    423c <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4179:	8b 45 08             	mov    0x8(%ebp),%eax
    417c:	8b 10                	mov    (%eax),%edx
    417e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4181:	01 d0                	add    %edx,%eax
    4183:	0f b6 00             	movzbl (%eax),%eax
    4186:	0f b6 d0             	movzbl %al,%edx
    4189:	8b 45 08             	mov    0x8(%ebp),%eax
    418c:	8b 00                	mov    (%eax),%eax
    418e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4191:	83 c1 01             	add    $0x1,%ecx
    4194:	01 c8                	add    %ecx,%eax
    4196:	0f b6 00             	movzbl (%eax),%eax
    4199:	0f b6 c0             	movzbl %al,%eax
    419c:	c1 e0 08             	shl    $0x8,%eax
    419f:	89 d1                	mov    %edx,%ecx
    41a1:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    41a3:	8b 45 08             	mov    0x8(%ebp),%eax
    41a6:	8b 00                	mov    (%eax),%eax
    41a8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    41ab:	83 c2 02             	add    $0x2,%edx
    41ae:	01 d0                	add    %edx,%eax
    41b0:	0f b6 00             	movzbl (%eax),%eax
    41b3:	0f b6 c0             	movzbl %al,%eax
    41b6:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    41b9:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    41bb:	8b 45 08             	mov    0x8(%ebp),%eax
    41be:	8b 00                	mov    (%eax),%eax
    41c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    41c3:	83 c2 03             	add    $0x3,%edx
    41c6:	01 d0                	add    %edx,%eax
    41c8:	0f b6 00             	movzbl (%eax),%eax
    41cb:	0f b6 c0             	movzbl %al,%eax
    41ce:	c1 e0 18             	shl    $0x18,%eax
    41d1:	09 c1                	or     %eax,%ecx
    41d3:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    41d5:	8b 45 08             	mov    0x8(%ebp),%eax
    41d8:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    41db:	8b 45 08             	mov    0x8(%ebp),%eax
    41de:	8b 50 10             	mov    0x10(%eax),%edx
    41e1:	8b 45 08             	mov    0x8(%ebp),%eax
    41e4:	8b 40 0c             	mov    0xc(%eax),%eax
    41e7:	83 e0 07             	and    $0x7,%eax
    41ea:	89 c1                	mov    %eax,%ecx
    41ec:	d3 ea                	shr    %cl,%edx
    41ee:	8b 45 08             	mov    0x8(%ebp),%eax
    41f1:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    41f4:	8b 45 08             	mov    0x8(%ebp),%eax
    41f7:	8b 50 10             	mov    0x10(%eax),%edx
    41fa:	8b 45 08             	mov    0x8(%ebp),%eax
    41fd:	8b 00                	mov    (%eax),%eax
    41ff:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4202:	83 c1 04             	add    $0x4,%ecx
    4205:	01 c8                	add    %ecx,%eax
    4207:	0f b6 00             	movzbl (%eax),%eax
    420a:	0f b6 c0             	movzbl %al,%eax
    420d:	c1 e0 18             	shl    $0x18,%eax
    4210:	89 c3                	mov    %eax,%ebx
    4212:	8b 45 08             	mov    0x8(%ebp),%eax
    4215:	8b 40 0c             	mov    0xc(%eax),%eax
    4218:	83 e0 07             	and    $0x7,%eax
    421b:	b9 08 00 00 00       	mov    $0x8,%ecx
    4220:	29 c1                	sub    %eax,%ecx
    4222:	89 c8                	mov    %ecx,%eax
    4224:	89 c1                	mov    %eax,%ecx
    4226:	d3 e3                	shl    %cl,%ebx
    4228:	89 d8                	mov    %ebx,%eax
    422a:	09 c2                	or     %eax,%edx
    422c:	8b 45 08             	mov    0x8(%ebp),%eax
    422f:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4232:	b8 01 00 00 00       	mov    $0x1,%eax
    4237:	e9 f7 00 00 00       	jmp    4333 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    423c:	8b 45 08             	mov    0x8(%ebp),%eax
    423f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4246:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4249:	8b 45 f4             	mov    -0xc(%ebp),%eax
    424c:	39 c2                	cmp    %eax,%edx
    424e:	73 1e                	jae    426e <ensureBits32+0x122>
    4250:	8b 45 08             	mov    0x8(%ebp),%eax
    4253:	8b 50 10             	mov    0x10(%eax),%edx
    4256:	8b 45 08             	mov    0x8(%ebp),%eax
    4259:	8b 08                	mov    (%eax),%ecx
    425b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    425e:	01 c8                	add    %ecx,%eax
    4260:	0f b6 00             	movzbl (%eax),%eax
    4263:	0f b6 c0             	movzbl %al,%eax
    4266:	09 c2                	or     %eax,%edx
    4268:	8b 45 08             	mov    0x8(%ebp),%eax
    426b:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    426e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4271:	8d 50 01             	lea    0x1(%eax),%edx
    4274:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4277:	39 c2                	cmp    %eax,%edx
    4279:	73 24                	jae    429f <ensureBits32+0x153>
    427b:	8b 45 08             	mov    0x8(%ebp),%eax
    427e:	8b 50 10             	mov    0x10(%eax),%edx
    4281:	8b 45 08             	mov    0x8(%ebp),%eax
    4284:	8b 00                	mov    (%eax),%eax
    4286:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4289:	83 c1 01             	add    $0x1,%ecx
    428c:	01 c8                	add    %ecx,%eax
    428e:	0f b6 00             	movzbl (%eax),%eax
    4291:	0f b6 c0             	movzbl %al,%eax
    4294:	c1 e0 08             	shl    $0x8,%eax
    4297:	09 c2                	or     %eax,%edx
    4299:	8b 45 08             	mov    0x8(%ebp),%eax
    429c:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    429f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    42a2:	8d 50 02             	lea    0x2(%eax),%edx
    42a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    42a8:	39 c2                	cmp    %eax,%edx
    42aa:	73 24                	jae    42d0 <ensureBits32+0x184>
    42ac:	8b 45 08             	mov    0x8(%ebp),%eax
    42af:	8b 50 10             	mov    0x10(%eax),%edx
    42b2:	8b 45 08             	mov    0x8(%ebp),%eax
    42b5:	8b 00                	mov    (%eax),%eax
    42b7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    42ba:	83 c1 02             	add    $0x2,%ecx
    42bd:	01 c8                	add    %ecx,%eax
    42bf:	0f b6 00             	movzbl (%eax),%eax
    42c2:	0f b6 c0             	movzbl %al,%eax
    42c5:	c1 e0 10             	shl    $0x10,%eax
    42c8:	09 c2                	or     %eax,%edx
    42ca:	8b 45 08             	mov    0x8(%ebp),%eax
    42cd:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    42d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    42d3:	8d 50 03             	lea    0x3(%eax),%edx
    42d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    42d9:	39 c2                	cmp    %eax,%edx
    42db:	73 24                	jae    4301 <ensureBits32+0x1b5>
    42dd:	8b 45 08             	mov    0x8(%ebp),%eax
    42e0:	8b 50 10             	mov    0x10(%eax),%edx
    42e3:	8b 45 08             	mov    0x8(%ebp),%eax
    42e6:	8b 00                	mov    (%eax),%eax
    42e8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    42eb:	83 c1 03             	add    $0x3,%ecx
    42ee:	01 c8                	add    %ecx,%eax
    42f0:	0f b6 00             	movzbl (%eax),%eax
    42f3:	0f b6 c0             	movzbl %al,%eax
    42f6:	c1 e0 18             	shl    $0x18,%eax
    42f9:	09 c2                	or     %eax,%edx
    42fb:	8b 45 08             	mov    0x8(%ebp),%eax
    42fe:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4301:	8b 45 08             	mov    0x8(%ebp),%eax
    4304:	8b 50 10             	mov    0x10(%eax),%edx
    4307:	8b 45 08             	mov    0x8(%ebp),%eax
    430a:	8b 40 0c             	mov    0xc(%eax),%eax
    430d:	83 e0 07             	and    $0x7,%eax
    4310:	89 c1                	mov    %eax,%ecx
    4312:	d3 ea                	shr    %cl,%edx
    4314:	8b 45 08             	mov    0x8(%ebp),%eax
    4317:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    431a:	8b 45 08             	mov    0x8(%ebp),%eax
    431d:	8b 50 0c             	mov    0xc(%eax),%edx
    4320:	8b 45 0c             	mov    0xc(%ebp),%eax
    4323:	01 c2                	add    %eax,%edx
    4325:	8b 45 08             	mov    0x8(%ebp),%eax
    4328:	8b 40 08             	mov    0x8(%eax),%eax
    432b:	39 c2                	cmp    %eax,%edx
    432d:	0f 9e c0             	setle  %al
    4330:	0f b6 c0             	movzbl %al,%eax
  }
}
    4333:	83 c4 10             	add    $0x10,%esp
    4336:	5b                   	pop    %ebx
    4337:	5d                   	pop    %ebp
    4338:	c3                   	ret    

00004339 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4339:	55                   	push   %ebp
    433a:	89 e5                	mov    %esp,%ebp
    433c:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    433d:	8b 45 08             	mov    0x8(%ebp),%eax
    4340:	8b 50 10             	mov    0x10(%eax),%edx
    4343:	8b 45 0c             	mov    0xc(%ebp),%eax
    4346:	bb 01 00 00 00       	mov    $0x1,%ebx
    434b:	89 c1                	mov    %eax,%ecx
    434d:	d3 e3                	shl    %cl,%ebx
    434f:	89 d8                	mov    %ebx,%eax
    4351:	83 e8 01             	sub    $0x1,%eax
    4354:	21 d0                	and    %edx,%eax
}
    4356:	5b                   	pop    %ebx
    4357:	5d                   	pop    %ebp
    4358:	c3                   	ret    

00004359 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4359:	55                   	push   %ebp
    435a:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    435c:	8b 45 08             	mov    0x8(%ebp),%eax
    435f:	8b 50 10             	mov    0x10(%eax),%edx
    4362:	8b 45 0c             	mov    0xc(%ebp),%eax
    4365:	89 c1                	mov    %eax,%ecx
    4367:	d3 ea                	shr    %cl,%edx
    4369:	8b 45 08             	mov    0x8(%ebp),%eax
    436c:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    436f:	8b 45 08             	mov    0x8(%ebp),%eax
    4372:	8b 50 0c             	mov    0xc(%eax),%edx
    4375:	8b 45 0c             	mov    0xc(%ebp),%eax
    4378:	01 c2                	add    %eax,%edx
    437a:	8b 45 08             	mov    0x8(%ebp),%eax
    437d:	89 50 0c             	mov    %edx,0xc(%eax)
}
    4380:	90                   	nop
    4381:	5d                   	pop    %ebp
    4382:	c3                   	ret    

00004383 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    4383:	55                   	push   %ebp
    4384:	89 e5                	mov    %esp,%ebp
    4386:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    4389:	ff 75 0c             	pushl  0xc(%ebp)
    438c:	ff 75 08             	pushl  0x8(%ebp)
    438f:	e8 a5 ff ff ff       	call   4339 <peekBits>
    4394:	83 c4 08             	add    $0x8,%esp
    4397:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    439a:	ff 75 0c             	pushl  0xc(%ebp)
    439d:	ff 75 08             	pushl  0x8(%ebp)
    43a0:	e8 b4 ff ff ff       	call   4359 <advanceBits>
    43a5:	83 c4 08             	add    $0x8,%esp
  return result;
    43a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    43ab:	c9                   	leave  
    43ac:	c3                   	ret    

000043ad <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    43ad:	55                   	push   %ebp
    43ae:	89 e5                	mov    %esp,%ebp
    43b0:	53                   	push   %ebx
    43b1:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    43b4:	ff 75 0c             	pushl  0xc(%ebp)
    43b7:	ff 75 08             	pushl  0x8(%ebp)
    43ba:	8d 45 d8             	lea    -0x28(%ebp),%eax
    43bd:	50                   	push   %eax
    43be:	e8 97 f9 ff ff       	call   3d5a <LodePNGBitReader_init>
    43c3:	83 c4 0c             	add    $0xc,%esp
    43c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    43c9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    43cd:	74 0a                	je     43d9 <lode_png_test_bitreader+0x2c>
    43cf:	b8 00 00 00 00       	mov    $0x0,%eax
    43d4:	e9 c3 00 00 00       	jmp    449c <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    43d9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    43e0:	e9 a6 00 00 00       	jmp    448b <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    43e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    43e8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    43ef:	8b 45 14             	mov    0x14(%ebp),%eax
    43f2:	01 d0                	add    %edx,%eax
    43f4:	8b 00                	mov    (%eax),%eax
    43f6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    43f9:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    43fd:	7e 14                	jle    4413 <lode_png_test_bitreader+0x66>
    43ff:	ff 75 ec             	pushl  -0x14(%ebp)
    4402:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4405:	50                   	push   %eax
    4406:	e8 41 fd ff ff       	call   414c <ensureBits32>
    440b:	83 c4 08             	add    $0x8,%esp
    440e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4411:	eb 46                	jmp    4459 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    4413:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    4417:	7e 14                	jle    442d <lode_png_test_bitreader+0x80>
    4419:	ff 75 ec             	pushl  -0x14(%ebp)
    441c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    441f:	50                   	push   %eax
    4420:	e8 ae fb ff ff       	call   3fd3 <ensureBits25>
    4425:	83 c4 08             	add    $0x8,%esp
    4428:	89 45 f4             	mov    %eax,-0xc(%ebp)
    442b:	eb 2c                	jmp    4459 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    442d:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    4431:	7e 14                	jle    4447 <lode_png_test_bitreader+0x9a>
    4433:	ff 75 ec             	pushl  -0x14(%ebp)
    4436:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4439:	50                   	push   %eax
    443a:	e8 68 fa ff ff       	call   3ea7 <ensureBits17>
    443f:	83 c4 08             	add    $0x8,%esp
    4442:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4445:	eb 12                	jmp    4459 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4447:	ff 75 ec             	pushl  -0x14(%ebp)
    444a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    444d:	50                   	push   %eax
    444e:	e8 78 f9 ff ff       	call   3dcb <ensureBits9>
    4453:	83 c4 08             	add    $0x8,%esp
    4456:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4459:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    445d:	75 07                	jne    4466 <lode_png_test_bitreader+0xb9>
    445f:	b8 00 00 00 00       	mov    $0x0,%eax
    4464:	eb 36                	jmp    449c <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4466:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4469:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4470:	8b 45 18             	mov    0x18(%ebp),%eax
    4473:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4476:	ff 75 ec             	pushl  -0x14(%ebp)
    4479:	8d 45 d8             	lea    -0x28(%ebp),%eax
    447c:	50                   	push   %eax
    447d:	e8 01 ff ff ff       	call   4383 <readBits>
    4482:	83 c4 08             	add    $0x8,%esp
    4485:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    4487:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    448b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    448e:	3b 45 10             	cmp    0x10(%ebp),%eax
    4491:	0f 8c 4e ff ff ff    	jl     43e5 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    4497:	b8 01 00 00 00       	mov    $0x1,%eax
}
    449c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    449f:	c9                   	leave  
    44a0:	c3                   	ret    

000044a1 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    44a1:	55                   	push   %ebp
    44a2:	89 e5                	mov    %esp,%ebp
    44a4:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    44a7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    44ae:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    44b5:	eb 27                	jmp    44de <reverseBits+0x3d>
    44b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    44ba:	2b 45 fc             	sub    -0x4(%ebp),%eax
    44bd:	83 e8 01             	sub    $0x1,%eax
    44c0:	8b 55 08             	mov    0x8(%ebp),%edx
    44c3:	89 c1                	mov    %eax,%ecx
    44c5:	d3 ea                	shr    %cl,%edx
    44c7:	89 d0                	mov    %edx,%eax
    44c9:	83 e0 01             	and    $0x1,%eax
    44cc:	89 c2                	mov    %eax,%edx
    44ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
    44d1:	89 c1                	mov    %eax,%ecx
    44d3:	d3 e2                	shl    %cl,%edx
    44d5:	89 d0                	mov    %edx,%eax
    44d7:	09 45 f8             	or     %eax,-0x8(%ebp)
    44da:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    44de:	8b 45 fc             	mov    -0x4(%ebp),%eax
    44e1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    44e4:	72 d1                	jb     44b7 <reverseBits+0x16>
  return result;
    44e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    44e9:	c9                   	leave  
    44ea:	c3                   	ret    

000044eb <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    44eb:	55                   	push   %ebp
    44ec:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    44ee:	8b 45 08             	mov    0x8(%ebp),%eax
    44f1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    44f7:	8b 45 08             	mov    0x8(%ebp),%eax
    44fa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    4501:	8b 45 08             	mov    0x8(%ebp),%eax
    4504:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    450b:	8b 45 08             	mov    0x8(%ebp),%eax
    450e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    4515:	90                   	nop
    4516:	5d                   	pop    %ebp
    4517:	c3                   	ret    

00004518 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    4518:	55                   	push   %ebp
    4519:	89 e5                	mov    %esp,%ebp
    451b:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    451e:	8b 45 08             	mov    0x8(%ebp),%eax
    4521:	8b 00                	mov    (%eax),%eax
    4523:	83 ec 0c             	sub    $0xc,%esp
    4526:	50                   	push   %eax
    4527:	e8 ec f0 ff ff       	call   3618 <lodepng_free>
    452c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    452f:	8b 45 08             	mov    0x8(%ebp),%eax
    4532:	8b 40 04             	mov    0x4(%eax),%eax
    4535:	83 ec 0c             	sub    $0xc,%esp
    4538:	50                   	push   %eax
    4539:	e8 da f0 ff ff       	call   3618 <lodepng_free>
    453e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    4541:	8b 45 08             	mov    0x8(%ebp),%eax
    4544:	8b 40 10             	mov    0x10(%eax),%eax
    4547:	83 ec 0c             	sub    $0xc,%esp
    454a:	50                   	push   %eax
    454b:	e8 c8 f0 ff ff       	call   3618 <lodepng_free>
    4550:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4553:	8b 45 08             	mov    0x8(%ebp),%eax
    4556:	8b 40 14             	mov    0x14(%eax),%eax
    4559:	83 ec 0c             	sub    $0xc,%esp
    455c:	50                   	push   %eax
    455d:	e8 b6 f0 ff ff       	call   3618 <lodepng_free>
    4562:	83 c4 10             	add    $0x10,%esp
}
    4565:	90                   	nop
    4566:	c9                   	leave  
    4567:	c3                   	ret    

00004568 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4568:	55                   	push   %ebp
    4569:	89 e5                	mov    %esp,%ebp
    456b:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    456e:	a1 c8 b8 01 00       	mov    0x1b8c8,%eax
    4573:	c1 e0 02             	shl    $0x2,%eax
    4576:	83 ec 0c             	sub    $0xc,%esp
    4579:	50                   	push   %eax
    457a:	e8 78 f0 ff ff       	call   35f7 <lodepng_malloc>
    457f:	83 c4 10             	add    $0x10,%esp
    4582:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    4585:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4589:	75 0a                	jne    4595 <HuffmanTree_makeTable+0x2d>
    458b:	b8 53 00 00 00       	mov    $0x53,%eax
    4590:	e9 61 04 00 00       	jmp    49f6 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    4595:	a1 c8 b8 01 00       	mov    0x1b8c8,%eax
    459a:	c1 e0 02             	shl    $0x2,%eax
    459d:	83 ec 04             	sub    $0x4,%esp
    45a0:	50                   	push   %eax
    45a1:	6a 00                	push   $0x0
    45a3:	ff 75 dc             	pushl  -0x24(%ebp)
    45a6:	e8 bd f0 ff ff       	call   3668 <lodepng_memset>
    45ab:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    45ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    45b5:	eb 7d                	jmp    4634 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    45b7:	8b 45 08             	mov    0x8(%ebp),%eax
    45ba:	8b 00                	mov    (%eax),%eax
    45bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45bf:	c1 e2 02             	shl    $0x2,%edx
    45c2:	01 d0                	add    %edx,%eax
    45c4:	8b 00                	mov    (%eax),%eax
    45c6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    45c9:	8b 45 08             	mov    0x8(%ebp),%eax
    45cc:	8b 40 04             	mov    0x4(%eax),%eax
    45cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45d2:	c1 e2 02             	shl    $0x2,%edx
    45d5:	01 d0                	add    %edx,%eax
    45d7:	8b 00                	mov    (%eax),%eax
    45d9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    45dc:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    45e0:	76 4d                	jbe    462f <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    45e2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    45e5:	83 e8 09             	sub    $0x9,%eax
    45e8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    45eb:	89 c1                	mov    %eax,%ecx
    45ed:	d3 ea                	shr    %cl,%edx
    45ef:	89 d0                	mov    %edx,%eax
    45f1:	83 ec 08             	sub    $0x8,%esp
    45f4:	6a 09                	push   $0x9
    45f6:	50                   	push   %eax
    45f7:	e8 a5 fe ff ff       	call   44a1 <reverseBits>
    45fc:	83 c4 10             	add    $0x10,%esp
    45ff:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    4602:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4605:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    460c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    460f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    4612:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4615:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    461c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    461f:	01 d0                	add    %edx,%eax
    4621:	8b 10                	mov    (%eax),%edx
    4623:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4626:	39 c2                	cmp    %eax,%edx
    4628:	0f 43 c2             	cmovae %edx,%eax
    462b:	89 01                	mov    %eax,(%ecx)
    462d:	eb 01                	jmp    4630 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    462f:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    4630:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4634:	8b 45 08             	mov    0x8(%ebp),%eax
    4637:	8b 50 0c             	mov    0xc(%eax),%edx
    463a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    463d:	39 c2                	cmp    %eax,%edx
    463f:	0f 87 72 ff ff ff    	ja     45b7 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4645:	a1 c8 b8 01 00       	mov    0x1b8c8,%eax
    464a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    464d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4654:	eb 35                	jmp    468b <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4656:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4659:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4660:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4663:	01 d0                	add    %edx,%eax
    4665:	8b 00                	mov    (%eax),%eax
    4667:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    466a:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    466e:	76 17                	jbe    4687 <HuffmanTree_makeTable+0x11f>
    4670:	8b 45 cc             	mov    -0x34(%ebp),%eax
    4673:	83 e8 09             	sub    $0x9,%eax
    4676:	ba 01 00 00 00       	mov    $0x1,%edx
    467b:	89 c1                	mov    %eax,%ecx
    467d:	d3 e2                	shl    %cl,%edx
    467f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4682:	01 d0                	add    %edx,%eax
    4684:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4687:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    468b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    468e:	a1 c8 b8 01 00       	mov    0x1b8c8,%eax
    4693:	39 c2                	cmp    %eax,%edx
    4695:	72 bf                	jb     4656 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    4697:	83 ec 0c             	sub    $0xc,%esp
    469a:	ff 75 e8             	pushl  -0x18(%ebp)
    469d:	e8 55 ef ff ff       	call   35f7 <lodepng_malloc>
    46a2:	83 c4 10             	add    $0x10,%esp
    46a5:	89 c2                	mov    %eax,%edx
    46a7:	8b 45 08             	mov    0x8(%ebp),%eax
    46aa:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    46ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    46b0:	01 c0                	add    %eax,%eax
    46b2:	83 ec 0c             	sub    $0xc,%esp
    46b5:	50                   	push   %eax
    46b6:	e8 3c ef ff ff       	call   35f7 <lodepng_malloc>
    46bb:	83 c4 10             	add    $0x10,%esp
    46be:	89 c2                	mov    %eax,%edx
    46c0:	8b 45 08             	mov    0x8(%ebp),%eax
    46c3:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    46c6:	8b 45 08             	mov    0x8(%ebp),%eax
    46c9:	8b 40 10             	mov    0x10(%eax),%eax
    46cc:	85 c0                	test   %eax,%eax
    46ce:	74 0a                	je     46da <HuffmanTree_makeTable+0x172>
    46d0:	8b 45 08             	mov    0x8(%ebp),%eax
    46d3:	8b 40 14             	mov    0x14(%eax),%eax
    46d6:	85 c0                	test   %eax,%eax
    46d8:	75 18                	jne    46f2 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    46da:	83 ec 0c             	sub    $0xc,%esp
    46dd:	ff 75 dc             	pushl  -0x24(%ebp)
    46e0:	e8 33 ef ff ff       	call   3618 <lodepng_free>
    46e5:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    46e8:	b8 53 00 00 00       	mov    $0x53,%eax
    46ed:	e9 04 03 00 00       	jmp    49f6 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    46f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    46f9:	eb 12                	jmp    470d <HuffmanTree_makeTable+0x1a5>
    46fb:	8b 45 08             	mov    0x8(%ebp),%eax
    46fe:	8b 50 10             	mov    0x10(%eax),%edx
    4701:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4704:	01 d0                	add    %edx,%eax
    4706:	c6 00 10             	movb   $0x10,(%eax)
    4709:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    470d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4710:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4713:	7c e6                	jl     46fb <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    4715:	a1 c8 b8 01 00       	mov    0x1b8c8,%eax
    471a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    471d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4724:	eb 5b                	jmp    4781 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4726:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4729:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4730:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4733:	01 d0                	add    %edx,%eax
    4735:	8b 00                	mov    (%eax),%eax
    4737:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    473a:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    473e:	76 3c                	jbe    477c <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    4740:	8b 45 08             	mov    0x8(%ebp),%eax
    4743:	8b 50 10             	mov    0x10(%eax),%edx
    4746:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4749:	01 d0                	add    %edx,%eax
    474b:	8b 55 c8             	mov    -0x38(%ebp),%edx
    474e:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    4750:	8b 45 08             	mov    0x8(%ebp),%eax
    4753:	8b 40 14             	mov    0x14(%eax),%eax
    4756:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4759:	01 d2                	add    %edx,%edx
    475b:	01 d0                	add    %edx,%eax
    475d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4760:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    4763:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4766:	83 e8 09             	sub    $0x9,%eax
    4769:	ba 01 00 00 00       	mov    $0x1,%edx
    476e:	89 c1                	mov    %eax,%ecx
    4770:	d3 e2                	shl    %cl,%edx
    4772:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4775:	01 d0                	add    %edx,%eax
    4777:	89 45 ec             	mov    %eax,-0x14(%ebp)
    477a:	eb 01                	jmp    477d <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    477c:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    477d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4781:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4784:	a1 c8 b8 01 00       	mov    0x1b8c8,%eax
    4789:	39 c2                	cmp    %eax,%edx
    478b:	72 99                	jb     4726 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    478d:	83 ec 0c             	sub    $0xc,%esp
    4790:	ff 75 dc             	pushl  -0x24(%ebp)
    4793:	e8 80 ee ff ff       	call   3618 <lodepng_free>
    4798:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    479b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    47a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    47a9:	e9 9d 01 00 00       	jmp    494b <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    47ae:	8b 45 08             	mov    0x8(%ebp),%eax
    47b1:	8b 40 04             	mov    0x4(%eax),%eax
    47b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    47b7:	c1 e2 02             	shl    $0x2,%edx
    47ba:	01 d0                	add    %edx,%eax
    47bc:	8b 00                	mov    (%eax),%eax
    47be:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    47c1:	8b 45 08             	mov    0x8(%ebp),%eax
    47c4:	8b 00                	mov    (%eax),%eax
    47c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    47c9:	c1 e2 02             	shl    $0x2,%edx
    47cc:	01 d0                	add    %edx,%eax
    47ce:	8b 00                	mov    (%eax),%eax
    47d0:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    47d3:	83 ec 08             	sub    $0x8,%esp
    47d6:	ff 75 c4             	pushl  -0x3c(%ebp)
    47d9:	ff 75 c0             	pushl  -0x40(%ebp)
    47dc:	e8 c0 fc ff ff       	call   44a1 <reverseBits>
    47e1:	83 c4 10             	add    $0x10,%esp
    47e4:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    47e7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    47eb:	0f 84 55 01 00 00    	je     4946 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    47f1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    47f5:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    47f9:	0f 87 81 00 00 00    	ja     4880 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    47ff:	b8 09 00 00 00       	mov    $0x9,%eax
    4804:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4807:	ba 01 00 00 00       	mov    $0x1,%edx
    480c:	89 c1                	mov    %eax,%ecx
    480e:	d3 e2                	shl    %cl,%edx
    4810:	89 d0                	mov    %edx,%eax
    4812:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    4815:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    481c:	eb 55                	jmp    4873 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    481e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4821:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4824:	89 c1                	mov    %eax,%ecx
    4826:	d3 e2                	shl    %cl,%edx
    4828:	89 d0                	mov    %edx,%eax
    482a:	0b 45 bc             	or     -0x44(%ebp),%eax
    482d:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4830:	8b 45 08             	mov    0x8(%ebp),%eax
    4833:	8b 50 10             	mov    0x10(%eax),%edx
    4836:	8b 45 98             	mov    -0x68(%ebp),%eax
    4839:	01 d0                	add    %edx,%eax
    483b:	0f b6 00             	movzbl (%eax),%eax
    483e:	3c 10                	cmp    $0x10,%al
    4840:	74 0a                	je     484c <HuffmanTree_makeTable+0x2e4>
    4842:	b8 37 00 00 00       	mov    $0x37,%eax
    4847:	e9 aa 01 00 00       	jmp    49f6 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    484c:	8b 45 08             	mov    0x8(%ebp),%eax
    484f:	8b 50 10             	mov    0x10(%eax),%edx
    4852:	8b 45 98             	mov    -0x68(%ebp),%eax
    4855:	01 d0                	add    %edx,%eax
    4857:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    485a:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    485c:	8b 45 08             	mov    0x8(%ebp),%eax
    485f:	8b 40 14             	mov    0x14(%eax),%eax
    4862:	8b 55 98             	mov    -0x68(%ebp),%edx
    4865:	01 d2                	add    %edx,%edx
    4867:	01 d0                	add    %edx,%eax
    4869:	8b 55 f4             	mov    -0xc(%ebp),%edx
    486c:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    486f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    4873:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4876:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    4879:	72 a3                	jb     481e <HuffmanTree_makeTable+0x2b6>
    487b:	e9 c7 00 00 00       	jmp    4947 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    4880:	a1 cc b8 01 00       	mov    0x1b8cc,%eax
    4885:	23 45 bc             	and    -0x44(%ebp),%eax
    4888:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    488b:	8b 45 08             	mov    0x8(%ebp),%eax
    488e:	8b 50 10             	mov    0x10(%eax),%edx
    4891:	8b 45 b8             	mov    -0x48(%ebp),%eax
    4894:	01 d0                	add    %edx,%eax
    4896:	0f b6 00             	movzbl (%eax),%eax
    4899:	0f b6 c0             	movzbl %al,%eax
    489c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    489f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    48a2:	83 e8 09             	sub    $0x9,%eax
    48a5:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    48a8:	8b 45 08             	mov    0x8(%ebp),%eax
    48ab:	8b 40 14             	mov    0x14(%eax),%eax
    48ae:	8b 55 b8             	mov    -0x48(%ebp),%edx
    48b1:	01 d2                	add    %edx,%edx
    48b3:	01 d0                	add    %edx,%eax
    48b5:	0f b7 00             	movzwl (%eax),%eax
    48b8:	0f b7 c0             	movzwl %ax,%eax
    48bb:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    48be:	8b 45 b0             	mov    -0x50(%ebp),%eax
    48c1:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    48c4:	83 c0 09             	add    $0x9,%eax
    48c7:	ba 01 00 00 00       	mov    $0x1,%edx
    48cc:	89 c1                	mov    %eax,%ecx
    48ce:	d3 e2                	shl    %cl,%edx
    48d0:	89 d0                	mov    %edx,%eax
    48d2:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    48d5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    48d8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    48db:	73 0a                	jae    48e7 <HuffmanTree_makeTable+0x37f>
    48dd:	b8 37 00 00 00       	mov    $0x37,%eax
    48e2:	e9 0f 01 00 00       	jmp    49f6 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    48e7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    48ee:	eb 4c                	jmp    493c <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    48f0:	8b 45 bc             	mov    -0x44(%ebp),%eax
    48f3:	c1 e8 09             	shr    $0x9,%eax
    48f6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    48f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    48fc:	83 e8 09             	sub    $0x9,%eax
    48ff:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4902:	89 c1                	mov    %eax,%ecx
    4904:	d3 e2                	shl    %cl,%edx
    4906:	89 d0                	mov    %edx,%eax
    4908:	0b 45 a4             	or     -0x5c(%ebp),%eax
    490b:	89 c2                	mov    %eax,%edx
    490d:	8b 45 ac             	mov    -0x54(%ebp),%eax
    4910:	01 d0                	add    %edx,%eax
    4912:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    4915:	8b 45 08             	mov    0x8(%ebp),%eax
    4918:	8b 50 10             	mov    0x10(%eax),%edx
    491b:	8b 45 a0             	mov    -0x60(%ebp),%eax
    491e:	01 d0                	add    %edx,%eax
    4920:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4923:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4925:	8b 45 08             	mov    0x8(%ebp),%eax
    4928:	8b 40 14             	mov    0x14(%eax),%eax
    492b:	8b 55 a0             	mov    -0x60(%ebp),%edx
    492e:	01 d2                	add    %edx,%edx
    4930:	01 d0                	add    %edx,%eax
    4932:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4935:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4938:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    493c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    493f:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    4942:	72 ac                	jb     48f0 <HuffmanTree_makeTable+0x388>
    4944:	eb 01                	jmp    4947 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4946:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4947:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    494b:	8b 45 08             	mov    0x8(%ebp),%eax
    494e:	8b 50 0c             	mov    0xc(%eax),%edx
    4951:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4954:	39 c2                	cmp    %eax,%edx
    4956:	0f 87 52 fe ff ff    	ja     47ae <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    495c:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    4960:	7f 61                	jg     49c3 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4962:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4969:	eb 4e                	jmp    49b9 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    496b:	8b 45 08             	mov    0x8(%ebp),%eax
    496e:	8b 50 10             	mov    0x10(%eax),%edx
    4971:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4974:	01 d0                	add    %edx,%eax
    4976:	0f b6 00             	movzbl (%eax),%eax
    4979:	3c 10                	cmp    $0x10,%al
    497b:	75 38                	jne    49b5 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    497d:	8b 45 08             	mov    0x8(%ebp),%eax
    4980:	8b 50 10             	mov    0x10(%eax),%edx
    4983:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4986:	01 d0                	add    %edx,%eax
    4988:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    498b:	8b 15 c8 b8 01 00    	mov    0x1b8c8,%edx
    4991:	39 d1                	cmp    %edx,%ecx
    4993:	73 07                	jae    499c <HuffmanTree_makeTable+0x434>
    4995:	ba 01 00 00 00       	mov    $0x1,%edx
    499a:	eb 05                	jmp    49a1 <HuffmanTree_makeTable+0x439>
    499c:	ba 0a 00 00 00       	mov    $0xa,%edx
    49a1:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    49a3:	8b 45 08             	mov    0x8(%ebp),%eax
    49a6:	8b 40 14             	mov    0x14(%eax),%eax
    49a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    49ac:	01 d2                	add    %edx,%edx
    49ae:	01 d0                	add    %edx,%eax
    49b0:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    49b5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49bc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    49bf:	7c aa                	jl     496b <HuffmanTree_makeTable+0x403>
    49c1:	eb 2e                	jmp    49f1 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    49c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    49ca:	eb 1d                	jmp    49e9 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    49cc:	8b 45 08             	mov    0x8(%ebp),%eax
    49cf:	8b 50 10             	mov    0x10(%eax),%edx
    49d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49d5:	01 d0                	add    %edx,%eax
    49d7:	0f b6 00             	movzbl (%eax),%eax
    49da:	3c 10                	cmp    $0x10,%al
    49dc:	75 07                	jne    49e5 <HuffmanTree_makeTable+0x47d>
    49de:	b8 37 00 00 00       	mov    $0x37,%eax
    49e3:	eb 11                	jmp    49f6 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    49e5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49ec:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    49ef:	7c db                	jl     49cc <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    49f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    49f6:	c9                   	leave  
    49f7:	c3                   	ret    

000049f8 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    49f8:	55                   	push   %ebp
    49f9:	89 e5                	mov    %esp,%ebp
    49fb:	56                   	push   %esi
    49fc:	53                   	push   %ebx
    49fd:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    4a00:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4a07:	8b 45 08             	mov    0x8(%ebp),%eax
    4a0a:	8b 40 0c             	mov    0xc(%eax),%eax
    4a0d:	c1 e0 02             	shl    $0x2,%eax
    4a10:	83 ec 0c             	sub    $0xc,%esp
    4a13:	50                   	push   %eax
    4a14:	e8 de eb ff ff       	call   35f7 <lodepng_malloc>
    4a19:	83 c4 10             	add    $0x10,%esp
    4a1c:	89 c2                	mov    %eax,%edx
    4a1e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a21:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4a23:	8b 45 08             	mov    0x8(%ebp),%eax
    4a26:	8b 40 08             	mov    0x8(%eax),%eax
    4a29:	83 c0 01             	add    $0x1,%eax
    4a2c:	c1 e0 02             	shl    $0x2,%eax
    4a2f:	83 ec 0c             	sub    $0xc,%esp
    4a32:	50                   	push   %eax
    4a33:	e8 bf eb ff ff       	call   35f7 <lodepng_malloc>
    4a38:	83 c4 10             	add    $0x10,%esp
    4a3b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4a3e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a41:	8b 40 08             	mov    0x8(%eax),%eax
    4a44:	83 c0 01             	add    $0x1,%eax
    4a47:	c1 e0 02             	shl    $0x2,%eax
    4a4a:	83 ec 0c             	sub    $0xc,%esp
    4a4d:	50                   	push   %eax
    4a4e:	e8 a4 eb ff ff       	call   35f7 <lodepng_malloc>
    4a53:	83 c4 10             	add    $0x10,%esp
    4a56:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4a59:	8b 45 08             	mov    0x8(%ebp),%eax
    4a5c:	8b 00                	mov    (%eax),%eax
    4a5e:	85 c0                	test   %eax,%eax
    4a60:	74 0c                	je     4a6e <HuffmanTree_makeFromLengths2+0x76>
    4a62:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4a66:	74 06                	je     4a6e <HuffmanTree_makeFromLengths2+0x76>
    4a68:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4a6c:	75 07                	jne    4a75 <HuffmanTree_makeFromLengths2+0x7d>
    4a6e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    4a75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a79:	0f 85 7d 01 00 00    	jne    4bfc <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    4a7f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4a86:	eb 2c                	jmp    4ab4 <HuffmanTree_makeFromLengths2+0xbc>
    4a88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4a8b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4a92:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4a95:	01 c2                	add    %eax,%edx
    4a97:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4a9a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4aa1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4aa4:	01 c8                	add    %ecx,%eax
    4aa6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4aac:	8b 00                	mov    (%eax),%eax
    4aae:	89 02                	mov    %eax,(%edx)
    4ab0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4ab4:	8b 45 08             	mov    0x8(%ebp),%eax
    4ab7:	8b 40 08             	mov    0x8(%eax),%eax
    4aba:	83 c0 01             	add    $0x1,%eax
    4abd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4ac0:	75 c6                	jne    4a88 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    4ac2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4ac9:	eb 27                	jmp    4af2 <HuffmanTree_makeFromLengths2+0xfa>
    4acb:	8b 45 08             	mov    0x8(%ebp),%eax
    4ace:	8b 40 04             	mov    0x4(%eax),%eax
    4ad1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4ad4:	c1 e2 02             	shl    $0x2,%edx
    4ad7:	01 d0                	add    %edx,%eax
    4ad9:	8b 00                	mov    (%eax),%eax
    4adb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4ae2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4ae5:	01 d0                	add    %edx,%eax
    4ae7:	8b 10                	mov    (%eax),%edx
    4ae9:	83 c2 01             	add    $0x1,%edx
    4aec:	89 10                	mov    %edx,(%eax)
    4aee:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4af2:	8b 45 08             	mov    0x8(%ebp),%eax
    4af5:	8b 40 0c             	mov    0xc(%eax),%eax
    4af8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4afb:	75 ce                	jne    4acb <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4afd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4b04:	eb 47                	jmp    4b4d <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4b06:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b09:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4b10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4b13:	01 d0                	add    %edx,%eax
    4b15:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4b18:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4b1e:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4b25:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4b28:	01 ca                	add    %ecx,%edx
    4b2a:	8b 0a                	mov    (%edx),%ecx
    4b2c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4b2f:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4b35:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4b3c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4b3f:	01 da                	add    %ebx,%edx
    4b41:	8b 12                	mov    (%edx),%edx
    4b43:	01 ca                	add    %ecx,%edx
    4b45:	01 d2                	add    %edx,%edx
    4b47:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4b49:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b50:	8b 40 08             	mov    0x8(%eax),%eax
    4b53:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4b56:	73 ae                	jae    4b06 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4b58:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4b5f:	e9 89 00 00 00       	jmp    4bed <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4b64:	8b 45 08             	mov    0x8(%ebp),%eax
    4b67:	8b 40 04             	mov    0x4(%eax),%eax
    4b6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b6d:	c1 e2 02             	shl    $0x2,%edx
    4b70:	01 d0                	add    %edx,%eax
    4b72:	8b 00                	mov    (%eax),%eax
    4b74:	85 c0                	test   %eax,%eax
    4b76:	74 71                	je     4be9 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4b78:	8b 45 08             	mov    0x8(%ebp),%eax
    4b7b:	8b 00                	mov    (%eax),%eax
    4b7d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b80:	c1 e2 02             	shl    $0x2,%edx
    4b83:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4b86:	8b 45 08             	mov    0x8(%ebp),%eax
    4b89:	8b 40 04             	mov    0x4(%eax),%eax
    4b8c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b8f:	c1 e2 02             	shl    $0x2,%edx
    4b92:	01 d0                	add    %edx,%eax
    4b94:	8b 00                	mov    (%eax),%eax
    4b96:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4b9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ba0:	01 c2                	add    %eax,%edx
    4ba2:	8b 02                	mov    (%edx),%eax
    4ba4:	8d 48 01             	lea    0x1(%eax),%ecx
    4ba7:	89 0a                	mov    %ecx,(%edx)
    4ba9:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4bab:	8b 45 08             	mov    0x8(%ebp),%eax
    4bae:	8b 00                	mov    (%eax),%eax
    4bb0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4bb3:	c1 e2 02             	shl    $0x2,%edx
    4bb6:	01 c2                	add    %eax,%edx
    4bb8:	8b 45 08             	mov    0x8(%ebp),%eax
    4bbb:	8b 00                	mov    (%eax),%eax
    4bbd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4bc0:	c1 e1 02             	shl    $0x2,%ecx
    4bc3:	01 c8                	add    %ecx,%eax
    4bc5:	8b 18                	mov    (%eax),%ebx
    4bc7:	8b 45 08             	mov    0x8(%ebp),%eax
    4bca:	8b 40 04             	mov    0x4(%eax),%eax
    4bcd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4bd0:	c1 e1 02             	shl    $0x2,%ecx
    4bd3:	01 c8                	add    %ecx,%eax
    4bd5:	8b 00                	mov    (%eax),%eax
    4bd7:	be 01 00 00 00       	mov    $0x1,%esi
    4bdc:	89 c1                	mov    %eax,%ecx
    4bde:	d3 e6                	shl    %cl,%esi
    4be0:	89 f0                	mov    %esi,%eax
    4be2:	83 e8 01             	sub    $0x1,%eax
    4be5:	21 d8                	and    %ebx,%eax
    4be7:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4be9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4bed:	8b 45 08             	mov    0x8(%ebp),%eax
    4bf0:	8b 40 0c             	mov    0xc(%eax),%eax
    4bf3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4bf6:	0f 85 68 ff ff ff    	jne    4b64 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    4bfc:	83 ec 0c             	sub    $0xc,%esp
    4bff:	ff 75 e8             	pushl  -0x18(%ebp)
    4c02:	e8 11 ea ff ff       	call   3618 <lodepng_free>
    4c07:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4c0a:	83 ec 0c             	sub    $0xc,%esp
    4c0d:	ff 75 e4             	pushl  -0x1c(%ebp)
    4c10:	e8 03 ea ff ff       	call   3618 <lodepng_free>
    4c15:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4c18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4c1c:	75 11                	jne    4c2f <HuffmanTree_makeFromLengths2+0x237>
    4c1e:	83 ec 0c             	sub    $0xc,%esp
    4c21:	ff 75 08             	pushl  0x8(%ebp)
    4c24:	e8 3f f9 ff ff       	call   4568 <HuffmanTree_makeTable>
    4c29:	83 c4 10             	add    $0x10,%esp
    4c2c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    4c2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4c32:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4c35:	5b                   	pop    %ebx
    4c36:	5e                   	pop    %esi
    4c37:	5d                   	pop    %ebp
    4c38:	c3                   	ret    

00004c39 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4c39:	55                   	push   %ebp
    4c3a:	89 e5                	mov    %esp,%ebp
    4c3c:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4c3f:	8b 45 10             	mov    0x10(%ebp),%eax
    4c42:	c1 e0 02             	shl    $0x2,%eax
    4c45:	83 ec 0c             	sub    $0xc,%esp
    4c48:	50                   	push   %eax
    4c49:	e8 a9 e9 ff ff       	call   35f7 <lodepng_malloc>
    4c4e:	83 c4 10             	add    $0x10,%esp
    4c51:	89 c2                	mov    %eax,%edx
    4c53:	8b 45 08             	mov    0x8(%ebp),%eax
    4c56:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4c59:	8b 45 08             	mov    0x8(%ebp),%eax
    4c5c:	8b 40 04             	mov    0x4(%eax),%eax
    4c5f:	85 c0                	test   %eax,%eax
    4c61:	75 07                	jne    4c6a <HuffmanTree_makeFromLengths+0x31>
    4c63:	b8 53 00 00 00       	mov    $0x53,%eax
    4c68:	eb 56                	jmp    4cc0 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4c6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4c71:	eb 25                	jmp    4c98 <HuffmanTree_makeFromLengths+0x5f>
    4c73:	8b 45 08             	mov    0x8(%ebp),%eax
    4c76:	8b 40 04             	mov    0x4(%eax),%eax
    4c79:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4c7c:	c1 e2 02             	shl    $0x2,%edx
    4c7f:	01 c2                	add    %eax,%edx
    4c81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c84:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4c8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c8e:	01 c8                	add    %ecx,%eax
    4c90:	8b 00                	mov    (%eax),%eax
    4c92:	89 02                	mov    %eax,(%edx)
    4c94:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4c98:	8b 45 10             	mov    0x10(%ebp),%eax
    4c9b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4c9e:	75 d3                	jne    4c73 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4ca0:	8b 55 10             	mov    0x10(%ebp),%edx
    4ca3:	8b 45 08             	mov    0x8(%ebp),%eax
    4ca6:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    4ca9:	8b 45 08             	mov    0x8(%ebp),%eax
    4cac:	8b 55 14             	mov    0x14(%ebp),%edx
    4caf:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4cb2:	83 ec 0c             	sub    $0xc,%esp
    4cb5:	ff 75 08             	pushl  0x8(%ebp)
    4cb8:	e8 3b fd ff ff       	call   49f8 <HuffmanTree_makeFromLengths2>
    4cbd:	83 c4 10             	add    $0x10,%esp
}
    4cc0:	c9                   	leave  
    4cc1:	c3                   	ret    

00004cc2 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4cc2:	55                   	push   %ebp
    4cc3:	89 e5                	mov    %esp,%ebp
    4cc5:	53                   	push   %ebx
    4cc6:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4cc9:	8b 45 08             	mov    0x8(%ebp),%eax
    4ccc:	8b 50 0c             	mov    0xc(%eax),%edx
    4ccf:	8b 45 08             	mov    0x8(%ebp),%eax
    4cd2:	8b 40 08             	mov    0x8(%eax),%eax
    4cd5:	39 c2                	cmp    %eax,%edx
    4cd7:	0f 82 0b 01 00 00    	jb     4de8 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4cdd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4ce4:	eb 19                	jmp    4cff <bpmnode_create+0x3d>
    4ce6:	8b 45 08             	mov    0x8(%ebp),%eax
    4ce9:	8b 40 04             	mov    0x4(%eax),%eax
    4cec:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4cef:	c1 e2 04             	shl    $0x4,%edx
    4cf2:	01 d0                	add    %edx,%eax
    4cf4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4cfb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4cff:	8b 45 08             	mov    0x8(%ebp),%eax
    4d02:	8b 00                	mov    (%eax),%eax
    4d04:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4d07:	75 dd                	jne    4ce6 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4d09:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4d10:	eb 60                	jmp    4d72 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4d12:	8b 45 08             	mov    0x8(%ebp),%eax
    4d15:	8b 40 18             	mov    0x18(%eax),%eax
    4d18:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4d1b:	c1 e2 02             	shl    $0x2,%edx
    4d1e:	01 d0                	add    %edx,%eax
    4d20:	8b 00                	mov    (%eax),%eax
    4d22:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d25:	eb 13                	jmp    4d3a <bpmnode_create+0x78>
    4d27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d2a:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d34:	8b 40 08             	mov    0x8(%eax),%eax
    4d37:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d3a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4d3e:	75 e7                	jne    4d27 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4d40:	8b 45 08             	mov    0x8(%ebp),%eax
    4d43:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d46:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4d49:	c1 e2 02             	shl    $0x2,%edx
    4d4c:	01 d0                	add    %edx,%eax
    4d4e:	8b 00                	mov    (%eax),%eax
    4d50:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d53:	eb 13                	jmp    4d68 <bpmnode_create+0xa6>
    4d55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d58:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4d5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d62:	8b 40 08             	mov    0x8(%eax),%eax
    4d65:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4d6c:	75 e7                	jne    4d55 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4d6e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4d72:	8b 45 08             	mov    0x8(%ebp),%eax
    4d75:	8b 40 14             	mov    0x14(%eax),%eax
    4d78:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4d7b:	75 95                	jne    4d12 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4d7d:	8b 45 08             	mov    0x8(%ebp),%eax
    4d80:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4d87:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4d8e:	eb 44                	jmp    4dd4 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4d90:	8b 45 08             	mov    0x8(%ebp),%eax
    4d93:	8b 40 04             	mov    0x4(%eax),%eax
    4d96:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4d99:	c1 e2 04             	shl    $0x4,%edx
    4d9c:	01 d0                	add    %edx,%eax
    4d9e:	8b 40 0c             	mov    0xc(%eax),%eax
    4da1:	85 c0                	test   %eax,%eax
    4da3:	75 2b                	jne    4dd0 <bpmnode_create+0x10e>
    4da5:	8b 45 08             	mov    0x8(%ebp),%eax
    4da8:	8b 58 10             	mov    0x10(%eax),%ebx
    4dab:	8b 45 08             	mov    0x8(%ebp),%eax
    4dae:	8b 40 08             	mov    0x8(%eax),%eax
    4db1:	8d 48 01             	lea    0x1(%eax),%ecx
    4db4:	8b 55 08             	mov    0x8(%ebp),%edx
    4db7:	89 4a 08             	mov    %ecx,0x8(%edx)
    4dba:	c1 e0 02             	shl    $0x2,%eax
    4dbd:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4dc0:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc3:	8b 40 04             	mov    0x4(%eax),%eax
    4dc6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4dc9:	c1 e1 04             	shl    $0x4,%ecx
    4dcc:	01 c8                	add    %ecx,%eax
    4dce:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4dd0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4dd4:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd7:	8b 00                	mov    (%eax),%eax
    4dd9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4ddc:	75 b2                	jne    4d90 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4dde:	8b 45 08             	mov    0x8(%ebp),%eax
    4de1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4de8:	8b 45 08             	mov    0x8(%ebp),%eax
    4deb:	8b 58 10             	mov    0x10(%eax),%ebx
    4dee:	8b 45 08             	mov    0x8(%ebp),%eax
    4df1:	8b 40 0c             	mov    0xc(%eax),%eax
    4df4:	8d 48 01             	lea    0x1(%eax),%ecx
    4df7:	8b 55 08             	mov    0x8(%ebp),%edx
    4dfa:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4dfd:	c1 e0 02             	shl    $0x2,%eax
    4e00:	01 d8                	add    %ebx,%eax
    4e02:	8b 00                	mov    (%eax),%eax
    4e04:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4e07:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e0a:	8b 55 0c             	mov    0xc(%ebp),%edx
    4e0d:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4e0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e12:	8b 55 10             	mov    0x10(%ebp),%edx
    4e15:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e1b:	8b 55 14             	mov    0x14(%ebp),%edx
    4e1e:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4e21:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4e24:	83 c4 10             	add    $0x10,%esp
    4e27:	5b                   	pop    %ebx
    4e28:	5d                   	pop    %ebp
    4e29:	c3                   	ret    

00004e2a <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4e2a:	55                   	push   %ebp
    4e2b:	89 e5                	mov    %esp,%ebp
    4e2d:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4e30:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e33:	c1 e0 04             	shl    $0x4,%eax
    4e36:	83 ec 0c             	sub    $0xc,%esp
    4e39:	50                   	push   %eax
    4e3a:	e8 b8 e7 ff ff       	call   35f7 <lodepng_malloc>
    4e3f:	83 c4 10             	add    $0x10,%esp
    4e42:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4e45:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4e4c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4e53:	e9 41 01 00 00       	jmp    4f99 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4e58:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e5b:	83 e0 01             	and    $0x1,%eax
    4e5e:	85 c0                	test   %eax,%eax
    4e60:	74 05                	je     4e67 <bpmnode_sort+0x3d>
    4e62:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4e65:	eb 03                	jmp    4e6a <bpmnode_sort+0x40>
    4e67:	8b 45 08             	mov    0x8(%ebp),%eax
    4e6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4e6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e70:	83 e0 01             	and    $0x1,%eax
    4e73:	85 c0                	test   %eax,%eax
    4e75:	74 05                	je     4e7c <bpmnode_sort+0x52>
    4e77:	8b 45 08             	mov    0x8(%ebp),%eax
    4e7a:	eb 03                	jmp    4e7f <bpmnode_sort+0x55>
    4e7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4e7f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4e82:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4e89:	e9 f8 00 00 00       	jmp    4f86 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4e8e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4e91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e94:	01 c2                	add    %eax,%edx
    4e96:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e99:	39 c2                	cmp    %eax,%edx
    4e9b:	0f 4e c2             	cmovle %edx,%eax
    4e9e:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4ea1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ea4:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4ea7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4eaa:	01 c2                	add    %eax,%edx
    4eac:	8b 45 0c             	mov    0xc(%ebp),%eax
    4eaf:	39 c2                	cmp    %eax,%edx
    4eb1:	0f 4e c2             	cmovle %edx,%eax
    4eb4:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4eb7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4eba:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4ebd:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4ec0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4ec3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4ec6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4ec9:	e9 a4 00 00 00       	jmp    4f72 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4ece:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4ed1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4ed4:	7d 62                	jge    4f38 <bpmnode_sort+0x10e>
    4ed6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ed9:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4edc:	7d 22                	jge    4f00 <bpmnode_sort+0xd6>
    4ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4ee1:	c1 e0 04             	shl    $0x4,%eax
    4ee4:	89 c2                	mov    %eax,%edx
    4ee6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4ee9:	01 d0                	add    %edx,%eax
    4eeb:	8b 10                	mov    (%eax),%edx
    4eed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ef0:	c1 e0 04             	shl    $0x4,%eax
    4ef3:	89 c1                	mov    %eax,%ecx
    4ef5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4ef8:	01 c8                	add    %ecx,%eax
    4efa:	8b 00                	mov    (%eax),%eax
    4efc:	39 c2                	cmp    %eax,%edx
    4efe:	7f 38                	jg     4f38 <bpmnode_sort+0x10e>
    4f00:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4f03:	c1 e0 04             	shl    $0x4,%eax
    4f06:	89 c2                	mov    %eax,%edx
    4f08:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4f0b:	01 d0                	add    %edx,%eax
    4f0d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4f10:	8d 4a 01             	lea    0x1(%edx),%ecx
    4f13:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4f16:	89 d1                	mov    %edx,%ecx
    4f18:	c1 e1 04             	shl    $0x4,%ecx
    4f1b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4f1e:	01 ca                	add    %ecx,%edx
    4f20:	8b 0a                	mov    (%edx),%ecx
    4f22:	89 08                	mov    %ecx,(%eax)
    4f24:	8b 4a 04             	mov    0x4(%edx),%ecx
    4f27:	89 48 04             	mov    %ecx,0x4(%eax)
    4f2a:	8b 4a 08             	mov    0x8(%edx),%ecx
    4f2d:	89 48 08             	mov    %ecx,0x8(%eax)
    4f30:	8b 52 0c             	mov    0xc(%edx),%edx
    4f33:	89 50 0c             	mov    %edx,0xc(%eax)
    4f36:	eb 36                	jmp    4f6e <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4f38:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4f3b:	c1 e0 04             	shl    $0x4,%eax
    4f3e:	89 c2                	mov    %eax,%edx
    4f40:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4f43:	01 d0                	add    %edx,%eax
    4f45:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4f48:	8d 4a 01             	lea    0x1(%edx),%ecx
    4f4b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4f4e:	89 d1                	mov    %edx,%ecx
    4f50:	c1 e1 04             	shl    $0x4,%ecx
    4f53:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4f56:	01 ca                	add    %ecx,%edx
    4f58:	8b 0a                	mov    (%edx),%ecx
    4f5a:	89 08                	mov    %ecx,(%eax)
    4f5c:	8b 4a 04             	mov    0x4(%edx),%ecx
    4f5f:	89 48 04             	mov    %ecx,0x4(%eax)
    4f62:	8b 4a 08             	mov    0x8(%edx),%ecx
    4f65:	89 48 08             	mov    %ecx,0x8(%eax)
    4f68:	8b 52 0c             	mov    0xc(%edx),%edx
    4f6b:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4f6e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4f72:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4f75:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4f78:	0f 8c 50 ff ff ff    	jl     4ece <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4f7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f81:	01 c0                	add    %eax,%eax
    4f83:	01 45 ec             	add    %eax,-0x14(%ebp)
    4f86:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f89:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4f8c:	0f 8c fc fe ff ff    	jl     4e8e <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4f92:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4f96:	d1 65 f4             	shll   -0xc(%ebp)
    4f99:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f9c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4f9f:	0f 8c b3 fe ff ff    	jl     4e58 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4fa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4fa8:	83 e0 01             	and    $0x1,%eax
    4fab:	85 c0                	test   %eax,%eax
    4fad:	74 18                	je     4fc7 <bpmnode_sort+0x19d>
    4faf:	8b 45 0c             	mov    0xc(%ebp),%eax
    4fb2:	c1 e0 04             	shl    $0x4,%eax
    4fb5:	83 ec 04             	sub    $0x4,%esp
    4fb8:	50                   	push   %eax
    4fb9:	ff 75 dc             	pushl  -0x24(%ebp)
    4fbc:	ff 75 08             	pushl  0x8(%ebp)
    4fbf:	e8 71 e6 ff ff       	call   3635 <lodepng_memcpy>
    4fc4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4fc7:	83 ec 0c             	sub    $0xc,%esp
    4fca:	ff 75 dc             	pushl  -0x24(%ebp)
    4fcd:	e8 46 e6 ff ff       	call   3618 <lodepng_free>
    4fd2:	83 c4 10             	add    $0x10,%esp
}
    4fd5:	90                   	nop
    4fd6:	c9                   	leave  
    4fd7:	c3                   	ret    

00004fd8 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4fd8:	55                   	push   %ebp
    4fd9:	89 e5                	mov    %esp,%ebp
    4fdb:	56                   	push   %esi
    4fdc:	53                   	push   %ebx
    4fdd:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4fe0:	8b 45 08             	mov    0x8(%ebp),%eax
    4fe3:	8b 40 1c             	mov    0x1c(%eax),%eax
    4fe6:	8b 55 14             	mov    0x14(%ebp),%edx
    4fe9:	c1 e2 02             	shl    $0x2,%edx
    4fec:	01 d0                	add    %edx,%eax
    4fee:	8b 00                	mov    (%eax),%eax
    4ff0:	8b 40 04             	mov    0x4(%eax),%eax
    4ff3:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4ff6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4ffa:	75 66                	jne    5062 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4ffc:	8b 45 10             	mov    0x10(%ebp),%eax
    4fff:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    5002:	0f 83 a0 01 00 00    	jae    51a8 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    5008:	8b 45 08             	mov    0x8(%ebp),%eax
    500b:	8b 40 18             	mov    0x18(%eax),%eax
    500e:	8b 55 14             	mov    0x14(%ebp),%edx
    5011:	c1 e2 02             	shl    $0x2,%edx
    5014:	01 c2                	add    %eax,%edx
    5016:	8b 45 08             	mov    0x8(%ebp),%eax
    5019:	8b 40 1c             	mov    0x1c(%eax),%eax
    501c:	8b 4d 14             	mov    0x14(%ebp),%ecx
    501f:	c1 e1 02             	shl    $0x2,%ecx
    5022:	01 c8                	add    %ecx,%eax
    5024:	8b 00                	mov    (%eax),%eax
    5026:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    5028:	8b 45 08             	mov    0x8(%ebp),%eax
    502b:	8b 40 1c             	mov    0x1c(%eax),%eax
    502e:	8b 55 14             	mov    0x14(%ebp),%edx
    5031:	c1 e2 02             	shl    $0x2,%edx
    5034:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5037:	8b 45 f4             	mov    -0xc(%ebp),%eax
    503a:	8d 50 01             	lea    0x1(%eax),%edx
    503d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5040:	c1 e0 04             	shl    $0x4,%eax
    5043:	89 c1                	mov    %eax,%ecx
    5045:	8b 45 0c             	mov    0xc(%ebp),%eax
    5048:	01 c8                	add    %ecx,%eax
    504a:	8b 00                	mov    (%eax),%eax
    504c:	6a 00                	push   $0x0
    504e:	52                   	push   %edx
    504f:	50                   	push   %eax
    5050:	ff 75 08             	pushl  0x8(%ebp)
    5053:	e8 6a fc ff ff       	call   4cc2 <bpmnode_create>
    5058:	83 c4 10             	add    $0x10,%esp
    505b:	89 03                	mov    %eax,(%ebx)
    505d:	e9 47 01 00 00       	jmp    51a9 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    5062:	8b 45 08             	mov    0x8(%ebp),%eax
    5065:	8b 40 18             	mov    0x18(%eax),%eax
    5068:	8b 55 14             	mov    0x14(%ebp),%edx
    506b:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5071:	c1 e2 02             	shl    $0x2,%edx
    5074:	01 d0                	add    %edx,%eax
    5076:	8b 00                	mov    (%eax),%eax
    5078:	8b 10                	mov    (%eax),%edx
    507a:	8b 45 08             	mov    0x8(%ebp),%eax
    507d:	8b 40 1c             	mov    0x1c(%eax),%eax
    5080:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5083:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    5089:	c1 e1 02             	shl    $0x2,%ecx
    508c:	01 c8                	add    %ecx,%eax
    508e:	8b 00                	mov    (%eax),%eax
    5090:	8b 00                	mov    (%eax),%eax
    5092:	01 d0                	add    %edx,%eax
    5094:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    5097:	8b 45 08             	mov    0x8(%ebp),%eax
    509a:	8b 40 18             	mov    0x18(%eax),%eax
    509d:	8b 55 14             	mov    0x14(%ebp),%edx
    50a0:	c1 e2 02             	shl    $0x2,%edx
    50a3:	01 c2                	add    %eax,%edx
    50a5:	8b 45 08             	mov    0x8(%ebp),%eax
    50a8:	8b 40 1c             	mov    0x1c(%eax),%eax
    50ab:	8b 4d 14             	mov    0x14(%ebp),%ecx
    50ae:	c1 e1 02             	shl    $0x2,%ecx
    50b1:	01 c8                	add    %ecx,%eax
    50b3:	8b 00                	mov    (%eax),%eax
    50b5:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    50b7:	8b 45 10             	mov    0x10(%ebp),%eax
    50ba:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    50bd:	73 60                	jae    511f <boundaryPM+0x147>
    50bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50c2:	c1 e0 04             	shl    $0x4,%eax
    50c5:	89 c2                	mov    %eax,%edx
    50c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    50ca:	01 d0                	add    %edx,%eax
    50cc:	8b 00                	mov    (%eax),%eax
    50ce:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    50d1:	7d 4c                	jge    511f <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    50d3:	8b 45 08             	mov    0x8(%ebp),%eax
    50d6:	8b 40 1c             	mov    0x1c(%eax),%eax
    50d9:	8b 55 14             	mov    0x14(%ebp),%edx
    50dc:	c1 e2 02             	shl    $0x2,%edx
    50df:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    50e2:	8b 45 08             	mov    0x8(%ebp),%eax
    50e5:	8b 40 1c             	mov    0x1c(%eax),%eax
    50e8:	8b 55 14             	mov    0x14(%ebp),%edx
    50eb:	c1 e2 02             	shl    $0x2,%edx
    50ee:	01 d0                	add    %edx,%eax
    50f0:	8b 00                	mov    (%eax),%eax
    50f2:	8b 50 08             	mov    0x8(%eax),%edx
    50f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50f8:	8d 48 01             	lea    0x1(%eax),%ecx
    50fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50fe:	c1 e0 04             	shl    $0x4,%eax
    5101:	89 c6                	mov    %eax,%esi
    5103:	8b 45 0c             	mov    0xc(%ebp),%eax
    5106:	01 f0                	add    %esi,%eax
    5108:	8b 00                	mov    (%eax),%eax
    510a:	52                   	push   %edx
    510b:	51                   	push   %ecx
    510c:	50                   	push   %eax
    510d:	ff 75 08             	pushl  0x8(%ebp)
    5110:	e8 ad fb ff ff       	call   4cc2 <bpmnode_create>
    5115:	83 c4 10             	add    $0x10,%esp
    5118:	89 03                	mov    %eax,(%ebx)
      return;
    511a:	e9 8a 00 00 00       	jmp    51a9 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    511f:	8b 45 08             	mov    0x8(%ebp),%eax
    5122:	8b 40 1c             	mov    0x1c(%eax),%eax
    5125:	8b 55 14             	mov    0x14(%ebp),%edx
    5128:	c1 e2 02             	shl    $0x2,%edx
    512b:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    512e:	8b 45 08             	mov    0x8(%ebp),%eax
    5131:	8b 40 1c             	mov    0x1c(%eax),%eax
    5134:	8b 55 14             	mov    0x14(%ebp),%edx
    5137:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    513d:	c1 e2 02             	shl    $0x2,%edx
    5140:	01 d0                	add    %edx,%eax
    5142:	8b 00                	mov    (%eax),%eax
    5144:	50                   	push   %eax
    5145:	ff 75 f4             	pushl  -0xc(%ebp)
    5148:	ff 75 f0             	pushl  -0x10(%ebp)
    514b:	ff 75 08             	pushl  0x8(%ebp)
    514e:	e8 6f fb ff ff       	call   4cc2 <bpmnode_create>
    5153:	83 c4 10             	add    $0x10,%esp
    5156:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    5158:	8b 45 18             	mov    0x18(%ebp),%eax
    515b:	8d 50 01             	lea    0x1(%eax),%edx
    515e:	8b 45 10             	mov    0x10(%ebp),%eax
    5161:	83 e8 01             	sub    $0x1,%eax
    5164:	01 c0                	add    %eax,%eax
    5166:	39 c2                	cmp    %eax,%edx
    5168:	7d 3f                	jge    51a9 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    516a:	8b 45 14             	mov    0x14(%ebp),%eax
    516d:	83 e8 01             	sub    $0x1,%eax
    5170:	83 ec 0c             	sub    $0xc,%esp
    5173:	ff 75 18             	pushl  0x18(%ebp)
    5176:	50                   	push   %eax
    5177:	ff 75 10             	pushl  0x10(%ebp)
    517a:	ff 75 0c             	pushl  0xc(%ebp)
    517d:	ff 75 08             	pushl  0x8(%ebp)
    5180:	e8 53 fe ff ff       	call   4fd8 <boundaryPM>
    5185:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5188:	8b 45 14             	mov    0x14(%ebp),%eax
    518b:	83 e8 01             	sub    $0x1,%eax
    518e:	83 ec 0c             	sub    $0xc,%esp
    5191:	ff 75 18             	pushl  0x18(%ebp)
    5194:	50                   	push   %eax
    5195:	ff 75 10             	pushl  0x10(%ebp)
    5198:	ff 75 0c             	pushl  0xc(%ebp)
    519b:	ff 75 08             	pushl  0x8(%ebp)
    519e:	e8 35 fe ff ff       	call   4fd8 <boundaryPM>
    51a3:	83 c4 20             	add    $0x20,%esp
    51a6:	eb 01                	jmp    51a9 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    51a8:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    51a9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    51ac:	5b                   	pop    %ebx
    51ad:	5e                   	pop    %esi
    51ae:	5d                   	pop    %ebp
    51af:	c3                   	ret    

000051b0 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    51b0:	55                   	push   %ebp
    51b1:	89 e5                	mov    %esp,%ebp
    51b3:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    51b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    51bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    51c4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    51c8:	75 0a                	jne    51d4 <lodepng_huffman_code_lengths+0x24>
    51ca:	b8 50 00 00 00       	mov    $0x50,%eax
    51cf:	e9 4d 03 00 00       	jmp    5521 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    51d4:	8b 45 14             	mov    0x14(%ebp),%eax
    51d7:	ba 01 00 00 00       	mov    $0x1,%edx
    51dc:	89 c1                	mov    %eax,%ecx
    51de:	d3 e2                	shl    %cl,%edx
    51e0:	8b 45 10             	mov    0x10(%ebp),%eax
    51e3:	39 c2                	cmp    %eax,%edx
    51e5:	73 0a                	jae    51f1 <lodepng_huffman_code_lengths+0x41>
    51e7:	b8 50 00 00 00       	mov    $0x50,%eax
    51ec:	e9 30 03 00 00       	jmp    5521 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    51f1:	8b 45 10             	mov    0x10(%ebp),%eax
    51f4:	c1 e0 04             	shl    $0x4,%eax
    51f7:	83 ec 0c             	sub    $0xc,%esp
    51fa:	50                   	push   %eax
    51fb:	e8 f7 e3 ff ff       	call   35f7 <lodepng_malloc>
    5200:	83 c4 10             	add    $0x10,%esp
    5203:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    5206:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    520a:	75 0a                	jne    5216 <lodepng_huffman_code_lengths+0x66>
    520c:	b8 53 00 00 00       	mov    $0x53,%eax
    5211:	e9 0b 03 00 00       	jmp    5521 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    5216:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    521d:	eb 50                	jmp    526f <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    521f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5222:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5229:	8b 45 0c             	mov    0xc(%ebp),%eax
    522c:	01 d0                	add    %edx,%eax
    522e:	8b 00                	mov    (%eax),%eax
    5230:	85 c0                	test   %eax,%eax
    5232:	74 37                	je     526b <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    5234:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5237:	c1 e0 04             	shl    $0x4,%eax
    523a:	89 c2                	mov    %eax,%edx
    523c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    523f:	01 d0                	add    %edx,%eax
    5241:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5244:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    524b:	8b 55 0c             	mov    0xc(%ebp),%edx
    524e:	01 ca                	add    %ecx,%edx
    5250:	8b 12                	mov    (%edx),%edx
    5252:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    5254:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5257:	c1 e0 04             	shl    $0x4,%eax
    525a:	89 c2                	mov    %eax,%edx
    525c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    525f:	01 c2                	add    %eax,%edx
    5261:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5264:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    5267:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    526b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    526f:	8b 45 10             	mov    0x10(%ebp),%eax
    5272:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5275:	75 a8                	jne    521f <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    5277:	8b 45 10             	mov    0x10(%ebp),%eax
    527a:	c1 e0 02             	shl    $0x2,%eax
    527d:	83 ec 04             	sub    $0x4,%esp
    5280:	50                   	push   %eax
    5281:	6a 00                	push   $0x0
    5283:	ff 75 08             	pushl  0x8(%ebp)
    5286:	e8 dd e3 ff ff       	call   3668 <lodepng_memset>
    528b:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    528e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5292:	75 18                	jne    52ac <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    5294:	8b 45 08             	mov    0x8(%ebp),%eax
    5297:	83 c0 04             	add    $0x4,%eax
    529a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    52a0:	8b 10                	mov    (%eax),%edx
    52a2:	8b 45 08             	mov    0x8(%ebp),%eax
    52a5:	89 10                	mov    %edx,(%eax)
    52a7:	e9 64 02 00 00       	jmp    5510 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    52ac:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    52b0:	75 3e                	jne    52f0 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    52b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    52b5:	8b 40 04             	mov    0x4(%eax),%eax
    52b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    52bf:	8b 45 08             	mov    0x8(%ebp),%eax
    52c2:	01 d0                	add    %edx,%eax
    52c4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    52ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    52cd:	8b 40 04             	mov    0x4(%eax),%eax
    52d0:	85 c0                	test   %eax,%eax
    52d2:	75 07                	jne    52db <lodepng_huffman_code_lengths+0x12b>
    52d4:	ba 04 00 00 00       	mov    $0x4,%edx
    52d9:	eb 05                	jmp    52e0 <lodepng_huffman_code_lengths+0x130>
    52db:	ba 00 00 00 00       	mov    $0x0,%edx
    52e0:	8b 45 08             	mov    0x8(%ebp),%eax
    52e3:	01 d0                	add    %edx,%eax
    52e5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    52eb:	e9 20 02 00 00       	jmp    5510 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    52f0:	83 ec 08             	sub    $0x8,%esp
    52f3:	ff 75 ec             	pushl  -0x14(%ebp)
    52f6:	ff 75 e4             	pushl  -0x1c(%ebp)
    52f9:	e8 2c fb ff ff       	call   4e2a <bpmnode_sort>
    52fe:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    5301:	8b 45 14             	mov    0x14(%ebp),%eax
    5304:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    5307:	8b 45 14             	mov    0x14(%ebp),%eax
    530a:	83 c0 01             	add    $0x1,%eax
    530d:	0f af 45 14          	imul   0x14(%ebp),%eax
    5311:	01 c0                	add    %eax,%eax
    5313:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    5316:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    531d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5320:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    5323:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5326:	c1 e0 04             	shl    $0x4,%eax
    5329:	83 ec 0c             	sub    $0xc,%esp
    532c:	50                   	push   %eax
    532d:	e8 c5 e2 ff ff       	call   35f7 <lodepng_malloc>
    5332:	83 c4 10             	add    $0x10,%esp
    5335:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5338:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    533b:	c1 e0 02             	shl    $0x2,%eax
    533e:	83 ec 0c             	sub    $0xc,%esp
    5341:	50                   	push   %eax
    5342:	e8 b0 e2 ff ff       	call   35f7 <lodepng_malloc>
    5347:	83 c4 10             	add    $0x10,%esp
    534a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    534d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5350:	c1 e0 02             	shl    $0x2,%eax
    5353:	83 ec 0c             	sub    $0xc,%esp
    5356:	50                   	push   %eax
    5357:	e8 9b e2 ff ff       	call   35f7 <lodepng_malloc>
    535c:	83 c4 10             	add    $0x10,%esp
    535f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5362:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5365:	c1 e0 02             	shl    $0x2,%eax
    5368:	83 ec 0c             	sub    $0xc,%esp
    536b:	50                   	push   %eax
    536c:	e8 86 e2 ff ff       	call   35f7 <lodepng_malloc>
    5371:	83 c4 10             	add    $0x10,%esp
    5374:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5377:	8b 45 c8             	mov    -0x38(%ebp),%eax
    537a:	85 c0                	test   %eax,%eax
    537c:	74 15                	je     5393 <lodepng_huffman_code_lengths+0x1e3>
    537e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5381:	85 c0                	test   %eax,%eax
    5383:	74 0e                	je     5393 <lodepng_huffman_code_lengths+0x1e3>
    5385:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5388:	85 c0                	test   %eax,%eax
    538a:	74 07                	je     5393 <lodepng_huffman_code_lengths+0x1e3>
    538c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    538f:	85 c0                	test   %eax,%eax
    5391:	75 07                	jne    539a <lodepng_huffman_code_lengths+0x1ea>
    5393:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    539a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    539e:	0f 85 30 01 00 00    	jne    54d4 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    53a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    53ab:	eb 1c                	jmp    53c9 <lodepng_huffman_code_lengths+0x219>
    53ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    53b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    53b3:	c1 e2 02             	shl    $0x2,%edx
    53b6:	01 d0                	add    %edx,%eax
    53b8:	8b 55 c8             	mov    -0x38(%ebp),%edx
    53bb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    53be:	c1 e1 04             	shl    $0x4,%ecx
    53c1:	01 ca                	add    %ecx,%edx
    53c3:	89 10                	mov    %edx,(%eax)
    53c5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    53c9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    53cc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    53cf:	75 dc                	jne    53ad <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    53d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    53d4:	8b 00                	mov    (%eax),%eax
    53d6:	6a 00                	push   $0x0
    53d8:	6a 01                	push   $0x1
    53da:	50                   	push   %eax
    53db:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    53de:	50                   	push   %eax
    53df:	e8 de f8 ff ff       	call   4cc2 <bpmnode_create>
    53e4:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    53e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    53ea:	83 c0 10             	add    $0x10,%eax
    53ed:	8b 00                	mov    (%eax),%eax
    53ef:	6a 00                	push   $0x0
    53f1:	6a 02                	push   $0x2
    53f3:	50                   	push   %eax
    53f4:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    53f7:	50                   	push   %eax
    53f8:	e8 c5 f8 ff ff       	call   4cc2 <bpmnode_create>
    53fd:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    5400:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5407:	eb 27                	jmp    5430 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    5409:	8b 45 dc             	mov    -0x24(%ebp),%eax
    540c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    540f:	c1 e2 02             	shl    $0x2,%edx
    5412:	01 c2                	add    %eax,%edx
    5414:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5417:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5419:	8b 45 e0             	mov    -0x20(%ebp),%eax
    541c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    541f:	c1 e2 02             	shl    $0x2,%edx
    5422:	01 d0                	add    %edx,%eax
    5424:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5427:	83 c2 10             	add    $0x10,%edx
    542a:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    542c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5430:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5433:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5436:	75 d1                	jne    5409 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5438:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    543f:	eb 24                	jmp    5465 <lodepng_huffman_code_lengths+0x2b5>
    5441:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5444:	8b 55 14             	mov    0x14(%ebp),%edx
    5447:	83 ea 01             	sub    $0x1,%edx
    544a:	83 ec 0c             	sub    $0xc,%esp
    544d:	50                   	push   %eax
    544e:	52                   	push   %edx
    544f:	ff 75 ec             	pushl  -0x14(%ebp)
    5452:	ff 75 e4             	pushl  -0x1c(%ebp)
    5455:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5458:	50                   	push   %eax
    5459:	e8 7a fb ff ff       	call   4fd8 <boundaryPM>
    545e:	83 c4 20             	add    $0x20,%esp
    5461:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5465:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5468:	83 e8 01             	sub    $0x1,%eax
    546b:	01 c0                	add    %eax,%eax
    546d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5470:	75 cf                	jne    5441 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5472:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5475:	8b 55 14             	mov    0x14(%ebp),%edx
    5478:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    547e:	c1 e2 02             	shl    $0x2,%edx
    5481:	01 d0                	add    %edx,%eax
    5483:	8b 00                	mov    (%eax),%eax
    5485:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5488:	eb 44                	jmp    54ce <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    548a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5491:	eb 27                	jmp    54ba <lodepng_huffman_code_lengths+0x30a>
    5493:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5496:	c1 e0 04             	shl    $0x4,%eax
    5499:	89 c2                	mov    %eax,%edx
    549b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    549e:	01 d0                	add    %edx,%eax
    54a0:	8b 40 04             	mov    0x4(%eax),%eax
    54a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    54aa:	8b 45 08             	mov    0x8(%ebp),%eax
    54ad:	01 d0                	add    %edx,%eax
    54af:	8b 10                	mov    (%eax),%edx
    54b1:	83 c2 01             	add    $0x1,%edx
    54b4:	89 10                	mov    %edx,(%eax)
    54b6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    54ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
    54bd:	8b 40 04             	mov    0x4(%eax),%eax
    54c0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    54c3:	75 ce                	jne    5493 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    54c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    54c8:	8b 40 08             	mov    0x8(%eax),%eax
    54cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    54ce:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    54d2:	75 b6                	jne    548a <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    54d4:	8b 45 c8             	mov    -0x38(%ebp),%eax
    54d7:	83 ec 0c             	sub    $0xc,%esp
    54da:	50                   	push   %eax
    54db:	e8 38 e1 ff ff       	call   3618 <lodepng_free>
    54e0:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    54e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    54e6:	83 ec 0c             	sub    $0xc,%esp
    54e9:	50                   	push   %eax
    54ea:	e8 29 e1 ff ff       	call   3618 <lodepng_free>
    54ef:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    54f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    54f5:	83 ec 0c             	sub    $0xc,%esp
    54f8:	50                   	push   %eax
    54f9:	e8 1a e1 ff ff       	call   3618 <lodepng_free>
    54fe:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    5501:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5504:	83 ec 0c             	sub    $0xc,%esp
    5507:	50                   	push   %eax
    5508:	e8 0b e1 ff ff       	call   3618 <lodepng_free>
    550d:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    5510:	83 ec 0c             	sub    $0xc,%esp
    5513:	ff 75 e4             	pushl  -0x1c(%ebp)
    5516:	e8 fd e0 ff ff       	call   3618 <lodepng_free>
    551b:	83 c4 10             	add    $0x10,%esp
  return error;
    551e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5521:	c9                   	leave  
    5522:	c3                   	ret    

00005523 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    5523:	55                   	push   %ebp
    5524:	89 e5                	mov    %esp,%ebp
    5526:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    5529:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    5530:	eb 04                	jmp    5536 <HuffmanTree_makeFromFrequencies+0x13>
    5532:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5536:	8b 45 14             	mov    0x14(%ebp),%eax
    5539:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    553e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5545:	8b 45 0c             	mov    0xc(%ebp),%eax
    5548:	01 d0                	add    %edx,%eax
    554a:	8b 00                	mov    (%eax),%eax
    554c:	85 c0                	test   %eax,%eax
    554e:	75 08                	jne    5558 <HuffmanTree_makeFromFrequencies+0x35>
    5550:	8b 45 14             	mov    0x14(%ebp),%eax
    5553:	3b 45 10             	cmp    0x10(%ebp),%eax
    5556:	7f da                	jg     5532 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5558:	8b 45 14             	mov    0x14(%ebp),%eax
    555b:	c1 e0 02             	shl    $0x2,%eax
    555e:	83 ec 0c             	sub    $0xc,%esp
    5561:	50                   	push   %eax
    5562:	e8 90 e0 ff ff       	call   35f7 <lodepng_malloc>
    5567:	83 c4 10             	add    $0x10,%esp
    556a:	89 c2                	mov    %eax,%edx
    556c:	8b 45 08             	mov    0x8(%ebp),%eax
    556f:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    5572:	8b 45 08             	mov    0x8(%ebp),%eax
    5575:	8b 40 04             	mov    0x4(%eax),%eax
    5578:	85 c0                	test   %eax,%eax
    557a:	75 07                	jne    5583 <HuffmanTree_makeFromFrequencies+0x60>
    557c:	b8 53 00 00 00       	mov    $0x53,%eax
    5581:	eb 47                	jmp    55ca <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    5583:	8b 45 08             	mov    0x8(%ebp),%eax
    5586:	8b 55 18             	mov    0x18(%ebp),%edx
    5589:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    558c:	8b 55 14             	mov    0x14(%ebp),%edx
    558f:	8b 45 08             	mov    0x8(%ebp),%eax
    5592:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    5595:	8b 45 08             	mov    0x8(%ebp),%eax
    5598:	8b 40 04             	mov    0x4(%eax),%eax
    559b:	ff 75 18             	pushl  0x18(%ebp)
    559e:	ff 75 14             	pushl  0x14(%ebp)
    55a1:	ff 75 0c             	pushl  0xc(%ebp)
    55a4:	50                   	push   %eax
    55a5:	e8 06 fc ff ff       	call   51b0 <lodepng_huffman_code_lengths>
    55aa:	83 c4 10             	add    $0x10,%esp
    55ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    55b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    55b4:	75 11                	jne    55c7 <HuffmanTree_makeFromFrequencies+0xa4>
    55b6:	83 ec 0c             	sub    $0xc,%esp
    55b9:	ff 75 08             	pushl  0x8(%ebp)
    55bc:	e8 37 f4 ff ff       	call   49f8 <HuffmanTree_makeFromLengths2>
    55c1:	83 c4 10             	add    $0x10,%esp
    55c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    55c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    55ca:	c9                   	leave  
    55cb:	c3                   	ret    

000055cc <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    55cc:	55                   	push   %ebp
    55cd:	89 e5                	mov    %esp,%ebp
    55cf:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    55d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    55d9:	83 ec 0c             	sub    $0xc,%esp
    55dc:	68 80 04 00 00       	push   $0x480
    55e1:	e8 11 e0 ff ff       	call   35f7 <lodepng_malloc>
    55e6:	83 c4 10             	add    $0x10,%esp
    55e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    55ec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    55f0:	75 0a                	jne    55fc <generateFixedLitLenTree+0x30>
    55f2:	b8 53 00 00 00       	mov    $0x53,%eax
    55f7:	e9 d5 00 00 00       	jmp    56d1 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    55fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5603:	eb 19                	jmp    561e <generateFixedLitLenTree+0x52>
    5605:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5608:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    560f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5612:	01 d0                	add    %edx,%eax
    5614:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    561a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    561e:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5625:	76 de                	jbe    5605 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5627:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    562e:	eb 19                	jmp    5649 <generateFixedLitLenTree+0x7d>
    5630:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5633:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    563a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    563d:	01 d0                	add    %edx,%eax
    563f:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5645:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5649:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    5650:	76 de                	jbe    5630 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    5652:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5659:	eb 19                	jmp    5674 <generateFixedLitLenTree+0xa8>
    565b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    565e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5665:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5668:	01 d0                	add    %edx,%eax
    566a:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    5670:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5674:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    567b:	76 de                	jbe    565b <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    567d:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    5684:	eb 19                	jmp    569f <generateFixedLitLenTree+0xd3>
    5686:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5689:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5690:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5693:	01 d0                	add    %edx,%eax
    5695:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    569b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    569f:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    56a6:	76 de                	jbe    5686 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    56a8:	6a 0f                	push   $0xf
    56aa:	68 20 01 00 00       	push   $0x120
    56af:	ff 75 ec             	pushl  -0x14(%ebp)
    56b2:	ff 75 08             	pushl  0x8(%ebp)
    56b5:	e8 7f f5 ff ff       	call   4c39 <HuffmanTree_makeFromLengths>
    56ba:	83 c4 10             	add    $0x10,%esp
    56bd:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    56c0:	83 ec 0c             	sub    $0xc,%esp
    56c3:	ff 75 ec             	pushl  -0x14(%ebp)
    56c6:	e8 4d df ff ff       	call   3618 <lodepng_free>
    56cb:	83 c4 10             	add    $0x10,%esp
  return error;
    56ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    56d1:	c9                   	leave  
    56d2:	c3                   	ret    

000056d3 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    56d3:	55                   	push   %ebp
    56d4:	89 e5                	mov    %esp,%ebp
    56d6:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    56d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    56e0:	83 ec 0c             	sub    $0xc,%esp
    56e3:	68 80 00 00 00       	push   $0x80
    56e8:	e8 0a df ff ff       	call   35f7 <lodepng_malloc>
    56ed:	83 c4 10             	add    $0x10,%esp
    56f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    56f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    56f7:	75 07                	jne    5700 <generateFixedDistanceTree+0x2d>
    56f9:	b8 53 00 00 00       	mov    $0x53,%eax
    56fe:	eb 4e                	jmp    574e <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    5700:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5707:	eb 19                	jmp    5722 <generateFixedDistanceTree+0x4f>
    5709:	8b 45 f4             	mov    -0xc(%ebp),%eax
    570c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5713:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5716:	01 d0                	add    %edx,%eax
    5718:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    571e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5722:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5726:	75 e1                	jne    5709 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5728:	6a 0f                	push   $0xf
    572a:	6a 20                	push   $0x20
    572c:	ff 75 ec             	pushl  -0x14(%ebp)
    572f:	ff 75 08             	pushl  0x8(%ebp)
    5732:	e8 02 f5 ff ff       	call   4c39 <HuffmanTree_makeFromLengths>
    5737:	83 c4 10             	add    $0x10,%esp
    573a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    573d:	83 ec 0c             	sub    $0xc,%esp
    5740:	ff 75 ec             	pushl  -0x14(%ebp)
    5743:	e8 d0 de ff ff       	call   3618 <lodepng_free>
    5748:	83 c4 10             	add    $0x10,%esp
  return error;
    574b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    574e:	c9                   	leave  
    574f:	c3                   	ret    

00005750 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    5750:	55                   	push   %ebp
    5751:	89 e5                	mov    %esp,%ebp
    5753:	53                   	push   %ebx
    5754:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5757:	6a 09                	push   $0x9
    5759:	ff 75 08             	pushl  0x8(%ebp)
    575c:	e8 d8 eb ff ff       	call   4339 <peekBits>
    5761:	83 c4 08             	add    $0x8,%esp
    5764:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5768:	8b 45 0c             	mov    0xc(%ebp),%eax
    576b:	8b 50 10             	mov    0x10(%eax),%edx
    576e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    5772:	01 d0                	add    %edx,%eax
    5774:	0f b6 00             	movzbl (%eax),%eax
    5777:	0f b6 c0             	movzbl %al,%eax
    577a:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    577e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5781:	8b 40 14             	mov    0x14(%eax),%eax
    5784:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    5788:	01 d2                	add    %edx,%edx
    578a:	01 d0                	add    %edx,%eax
    578c:	0f b7 00             	movzwl (%eax),%eax
    578f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    5793:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    5798:	77 16                	ja     57b0 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    579a:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    579e:	50                   	push   %eax
    579f:	ff 75 08             	pushl  0x8(%ebp)
    57a2:	e8 b2 eb ff ff       	call   4359 <advanceBits>
    57a7:	83 c4 08             	add    $0x8,%esp
    return value;
    57aa:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    57ae:	eb 5c                	jmp    580c <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    57b0:	6a 09                	push   $0x9
    57b2:	ff 75 08             	pushl  0x8(%ebp)
    57b5:	e8 9f eb ff ff       	call   4359 <advanceBits>
    57ba:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    57bd:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    57c1:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    57c5:	83 e8 09             	sub    $0x9,%eax
    57c8:	50                   	push   %eax
    57c9:	ff 75 08             	pushl  0x8(%ebp)
    57cc:	e8 68 eb ff ff       	call   4339 <peekBits>
    57d1:	83 c4 08             	add    $0x8,%esp
    57d4:	01 d8                	add    %ebx,%eax
    57d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    57d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    57dc:	8b 50 10             	mov    0x10(%eax),%edx
    57df:	8b 45 f0             	mov    -0x10(%ebp),%eax
    57e2:	01 d0                	add    %edx,%eax
    57e4:	0f b6 00             	movzbl (%eax),%eax
    57e7:	0f b6 c0             	movzbl %al,%eax
    57ea:	83 e8 09             	sub    $0x9,%eax
    57ed:	50                   	push   %eax
    57ee:	ff 75 08             	pushl  0x8(%ebp)
    57f1:	e8 63 eb ff ff       	call   4359 <advanceBits>
    57f6:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    57f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    57fc:	8b 40 14             	mov    0x14(%eax),%eax
    57ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5802:	01 d2                	add    %edx,%edx
    5804:	01 d0                	add    %edx,%eax
    5806:	0f b7 00             	movzwl (%eax),%eax
    5809:	0f b7 c0             	movzwl %ax,%eax
  }
}
    580c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    580f:	c9                   	leave  
    5810:	c3                   	ret    

00005811 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    5811:	55                   	push   %ebp
    5812:	89 e5                	mov    %esp,%ebp
    5814:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5817:	83 ec 0c             	sub    $0xc,%esp
    581a:	ff 75 08             	pushl  0x8(%ebp)
    581d:	e8 aa fd ff ff       	call   55cc <generateFixedLitLenTree>
    5822:	83 c4 10             	add    $0x10,%esp
    5825:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5828:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    582c:	74 05                	je     5833 <getTreeInflateFixed+0x22>
    582e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5831:	eb 0e                	jmp    5841 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    5833:	83 ec 0c             	sub    $0xc,%esp
    5836:	ff 75 0c             	pushl  0xc(%ebp)
    5839:	e8 95 fe ff ff       	call   56d3 <generateFixedDistanceTree>
    583e:	83 c4 10             	add    $0x10,%esp
}
    5841:	c9                   	leave  
    5842:	c3                   	ret    

00005843 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    5843:	55                   	push   %ebp
    5844:	89 e5                	mov    %esp,%ebp
    5846:	53                   	push   %ebx
    5847:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    584a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    5851:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5858:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    585f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5866:	6a 0e                	push   $0xe
    5868:	ff 75 10             	pushl  0x10(%ebp)
    586b:	e8 37 e6 ff ff       	call   3ea7 <ensureBits17>
    5870:	83 c4 08             	add    $0x8,%esp
    5873:	85 c0                	test   %eax,%eax
    5875:	75 0a                	jne    5881 <getTreeInflateDynamic+0x3e>
    5877:	b8 31 00 00 00       	mov    $0x31,%eax
    587c:	e9 ec 04 00 00       	jmp    5d6d <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    5881:	6a 05                	push   $0x5
    5883:	ff 75 10             	pushl  0x10(%ebp)
    5886:	e8 f8 ea ff ff       	call   4383 <readBits>
    588b:	83 c4 08             	add    $0x8,%esp
    588e:	05 01 01 00 00       	add    $0x101,%eax
    5893:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    5896:	6a 05                	push   $0x5
    5898:	ff 75 10             	pushl  0x10(%ebp)
    589b:	e8 e3 ea ff ff       	call   4383 <readBits>
    58a0:	83 c4 08             	add    $0x8,%esp
    58a3:	83 c0 01             	add    $0x1,%eax
    58a6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    58a9:	6a 04                	push   $0x4
    58ab:	ff 75 10             	pushl  0x10(%ebp)
    58ae:	e8 d0 ea ff ff       	call   4383 <readBits>
    58b3:	83 c4 08             	add    $0x8,%esp
    58b6:	83 c0 04             	add    $0x4,%eax
    58b9:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    58bc:	83 ec 0c             	sub    $0xc,%esp
    58bf:	6a 4c                	push   $0x4c
    58c1:	e8 31 dd ff ff       	call   35f7 <lodepng_malloc>
    58c6:	83 c4 10             	add    $0x10,%esp
    58c9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    58cc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    58d0:	75 0a                	jne    58dc <getTreeInflateDynamic+0x99>
    58d2:	b8 53 00 00 00       	mov    $0x53,%eax
    58d7:	e9 91 04 00 00       	jmp    5d6d <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    58dc:	83 ec 0c             	sub    $0xc,%esp
    58df:	8d 45 a8             	lea    -0x58(%ebp),%eax
    58e2:	50                   	push   %eax
    58e3:	e8 03 ec ff ff       	call   44eb <HuffmanTree_init>
    58e8:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    58eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    58ef:	0f 85 3c 04 00 00    	jne    5d31 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    58f5:	8b 45 10             	mov    0x10(%ebp),%eax
    58f8:	8b 48 08             	mov    0x8(%eax),%ecx
    58fb:	8b 55 d0             	mov    -0x30(%ebp),%edx
    58fe:	89 d0                	mov    %edx,%eax
    5900:	01 c0                	add    %eax,%eax
    5902:	01 d0                	add    %edx,%eax
    5904:	89 c2                	mov    %eax,%edx
    5906:	8b 45 10             	mov    0x10(%ebp),%eax
    5909:	8b 40 0c             	mov    0xc(%eax),%eax
    590c:	83 ec 04             	sub    $0x4,%esp
    590f:	51                   	push   %ecx
    5910:	52                   	push   %edx
    5911:	50                   	push   %eax
    5912:	e8 f7 dd ff ff       	call   370e <lodepng_gtofl>
    5917:	83 c4 10             	add    $0x10,%esp
    591a:	85 c0                	test   %eax,%eax
    591c:	74 0c                	je     592a <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    591e:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5925:	e9 07 04 00 00       	jmp    5d31 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    592a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5931:	eb 3d                	jmp    5970 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    5933:	83 ec 08             	sub    $0x8,%esp
    5936:	6a 03                	push   $0x3
    5938:	ff 75 10             	pushl  0x10(%ebp)
    593b:	e8 8b e4 ff ff       	call   3dcb <ensureBits9>
    5940:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    5943:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5946:	8b 04 85 40 a2 01 00 	mov    0x1a240(,%eax,4),%eax
    594d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5954:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5957:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    595a:	83 ec 08             	sub    $0x8,%esp
    595d:	6a 03                	push   $0x3
    595f:	ff 75 10             	pushl  0x10(%ebp)
    5962:	e8 1c ea ff ff       	call   4383 <readBits>
    5967:	83 c4 10             	add    $0x10,%esp
    596a:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    596c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5970:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5973:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5976:	75 bb                	jne    5933 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5978:	8b 45 d0             	mov    -0x30(%ebp),%eax
    597b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    597e:	eb 20                	jmp    59a0 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    5980:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5983:	8b 04 85 40 a2 01 00 	mov    0x1a240(,%eax,4),%eax
    598a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5991:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5994:	01 d0                	add    %edx,%eax
    5996:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    599c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    59a0:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    59a4:	75 da                	jne    5980 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    59a6:	6a 07                	push   $0x7
    59a8:	6a 13                	push   $0x13
    59aa:	ff 75 dc             	pushl  -0x24(%ebp)
    59ad:	8d 45 a8             	lea    -0x58(%ebp),%eax
    59b0:	50                   	push   %eax
    59b1:	e8 83 f2 ff ff       	call   4c39 <HuffmanTree_makeFromLengths>
    59b6:	83 c4 10             	add    $0x10,%esp
    59b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    59bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    59c0:	0f 85 64 03 00 00    	jne    5d2a <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    59c6:	83 ec 0c             	sub    $0xc,%esp
    59c9:	68 80 04 00 00       	push   $0x480
    59ce:	e8 24 dc ff ff       	call   35f7 <lodepng_malloc>
    59d3:	83 c4 10             	add    $0x10,%esp
    59d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    59d9:	83 ec 0c             	sub    $0xc,%esp
    59dc:	68 80 00 00 00       	push   $0x80
    59e1:	e8 11 dc ff ff       	call   35f7 <lodepng_malloc>
    59e6:	83 c4 10             	add    $0x10,%esp
    59e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    59ec:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    59f0:	74 06                	je     59f8 <getTreeInflateDynamic+0x1b5>
    59f2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    59f6:	75 0c                	jne    5a04 <getTreeInflateDynamic+0x1c1>
    59f8:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    59ff:	e9 2d 03 00 00       	jmp    5d31 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    5a04:	83 ec 04             	sub    $0x4,%esp
    5a07:	68 80 04 00 00       	push   $0x480
    5a0c:	6a 00                	push   $0x0
    5a0e:	ff 75 e8             	pushl  -0x18(%ebp)
    5a11:	e8 52 dc ff ff       	call   3668 <lodepng_memset>
    5a16:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5a19:	83 ec 04             	sub    $0x4,%esp
    5a1c:	68 80 00 00 00       	push   $0x80
    5a21:	6a 00                	push   $0x0
    5a23:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a26:	e8 3d dc ff ff       	call   3668 <lodepng_memset>
    5a2b:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    5a2e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5a35:	e9 8d 02 00 00       	jmp    5cc7 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5a3a:	83 ec 08             	sub    $0x8,%esp
    5a3d:	6a 16                	push   $0x16
    5a3f:	ff 75 10             	pushl  0x10(%ebp)
    5a42:	e8 8c e5 ff ff       	call   3fd3 <ensureBits25>
    5a47:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5a4a:	83 ec 08             	sub    $0x8,%esp
    5a4d:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5a50:	50                   	push   %eax
    5a51:	ff 75 10             	pushl  0x10(%ebp)
    5a54:	e8 f7 fc ff ff       	call   5750 <huffmanDecodeSymbol>
    5a59:	83 c4 10             	add    $0x10,%esp
    5a5c:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    5a5f:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    5a63:	77 3e                	ja     5aa3 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5a65:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a68:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5a6b:	73 16                	jae    5a83 <getTreeInflateDynamic+0x240>
    5a6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a70:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a77:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a7a:	01 c2                	add    %eax,%edx
    5a7c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5a7f:	89 02                	mov    %eax,(%edx)
    5a81:	eb 17                	jmp    5a9a <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    5a83:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a86:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5a89:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a90:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5a93:	01 c2                	add    %eax,%edx
    5a95:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5a98:	89 02                	mov    %eax,(%edx)
        ++i;
    5a9a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5a9e:	e9 0b 02 00 00       	jmp    5cae <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    5aa3:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    5aa7:	0f 85 da 00 00 00    	jne    5b87 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5aad:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    5ab4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5ab8:	75 0c                	jne    5ac6 <getTreeInflateDynamic+0x283>
    5aba:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    5ac1:	e9 12 02 00 00       	jmp    5cd8 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    5ac6:	83 ec 08             	sub    $0x8,%esp
    5ac9:	6a 02                	push   $0x2
    5acb:	ff 75 10             	pushl  0x10(%ebp)
    5ace:	e8 b0 e8 ff ff       	call   4383 <readBits>
    5ad3:	83 c4 10             	add    $0x10,%esp
    5ad6:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5ad9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5adc:	83 c0 01             	add    $0x1,%eax
    5adf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5ae2:	76 1b                	jbe    5aff <getTreeInflateDynamic+0x2bc>
    5ae4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ae7:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5aec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5af3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5af6:	01 d0                	add    %edx,%eax
    5af8:	8b 00                	mov    (%eax),%eax
    5afa:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5afd:	eb 1c                	jmp    5b1b <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    5aff:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b02:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5b05:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5b0a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b11:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b14:	01 d0                	add    %edx,%eax
    5b16:	8b 00                	mov    (%eax),%eax
    5b18:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5b1b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5b22:	eb 56                	jmp    5b7a <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5b24:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5b27:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5b2a:	01 d0                	add    %edx,%eax
    5b2c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5b2f:	77 0c                	ja     5b3d <getTreeInflateDynamic+0x2fa>
    5b31:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5b38:	e9 71 01 00 00       	jmp    5cae <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5b3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b40:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5b43:	73 16                	jae    5b5b <getTreeInflateDynamic+0x318>
    5b45:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b48:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5b52:	01 c2                	add    %eax,%edx
    5b54:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5b57:	89 02                	mov    %eax,(%edx)
    5b59:	eb 17                	jmp    5b72 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5b5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b5e:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5b61:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b6b:	01 c2                	add    %eax,%edx
    5b6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5b70:	89 02                	mov    %eax,(%edx)
          ++i;
    5b72:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5b76:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5b7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5b7d:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    5b80:	72 a2                	jb     5b24 <getTreeInflateDynamic+0x2e1>
    5b82:	e9 27 01 00 00       	jmp    5cae <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    5b87:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5b8b:	0f 85 88 00 00 00    	jne    5c19 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    5b91:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    5b98:	83 ec 08             	sub    $0x8,%esp
    5b9b:	6a 03                	push   $0x3
    5b9d:	ff 75 10             	pushl  0x10(%ebp)
    5ba0:	e8 de e7 ff ff       	call   4383 <readBits>
    5ba5:	83 c4 10             	add    $0x10,%esp
    5ba8:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5bab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5bb2:	eb 58                	jmp    5c0c <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    5bb4:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5bb7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5bba:	01 d0                	add    %edx,%eax
    5bbc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5bbf:	77 0c                	ja     5bcd <getTreeInflateDynamic+0x38a>
    5bc1:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    5bc8:	e9 e1 00 00 00       	jmp    5cae <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5bcd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5bd0:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5bd3:	73 17                	jae    5bec <getTreeInflateDynamic+0x3a9>
    5bd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5bd8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5bdf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5be2:	01 d0                	add    %edx,%eax
    5be4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5bea:	eb 18                	jmp    5c04 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    5bec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5bef:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5bf2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5bf9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5bfc:	01 d0                	add    %edx,%eax
    5bfe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5c04:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5c08:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5c0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c0f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    5c12:	72 a0                	jb     5bb4 <getTreeInflateDynamic+0x371>
    5c14:	e9 95 00 00 00       	jmp    5cae <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5c19:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5c1d:	0f 85 82 00 00 00    	jne    5ca5 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5c23:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5c2a:	83 ec 08             	sub    $0x8,%esp
    5c2d:	6a 07                	push   $0x7
    5c2f:	ff 75 10             	pushl  0x10(%ebp)
    5c32:	e8 4c e7 ff ff       	call   4383 <readBits>
    5c37:	83 c4 10             	add    $0x10,%esp
    5c3a:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5c3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5c44:	eb 55                	jmp    5c9b <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5c46:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5c49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c4c:	01 d0                	add    %edx,%eax
    5c4e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5c51:	77 09                	ja     5c5c <getTreeInflateDynamic+0x419>
    5c53:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5c5a:	eb 52                	jmp    5cae <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5c5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c5f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5c62:	73 17                	jae    5c7b <getTreeInflateDynamic+0x438>
    5c64:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c67:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5c71:	01 d0                	add    %edx,%eax
    5c73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5c79:	eb 18                	jmp    5c93 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5c7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c7e:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5c81:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c8b:	01 d0                	add    %edx,%eax
    5c8d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5c93:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5c97:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5c9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c9e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5ca1:	72 a3                	jb     5c46 <getTreeInflateDynamic+0x403>
    5ca3:	eb 09                	jmp    5cae <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5ca5:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5cac:	eb 2a                	jmp    5cd8 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5cae:	8b 45 10             	mov    0x10(%ebp),%eax
    5cb1:	8b 50 0c             	mov    0xc(%eax),%edx
    5cb4:	8b 45 10             	mov    0x10(%ebp),%eax
    5cb7:	8b 40 08             	mov    0x8(%eax),%eax
    5cba:	39 c2                	cmp    %eax,%edx
    5cbc:	7e 09                	jle    5cc7 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5cbe:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5cc5:	eb 11                	jmp    5cd8 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5cc7:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5cca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5ccd:	01 d0                	add    %edx,%eax
    5ccf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5cd2:	0f 87 62 fd ff ff    	ja     5a3a <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5cd8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5cdc:	75 4f                	jne    5d2d <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5cde:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5ce1:	05 00 04 00 00       	add    $0x400,%eax
    5ce6:	8b 00                	mov    (%eax),%eax
    5ce8:	85 c0                	test   %eax,%eax
    5cea:	75 09                	jne    5cf5 <getTreeInflateDynamic+0x4b2>
    5cec:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5cf3:	eb 3c                	jmp    5d31 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5cf5:	6a 0f                	push   $0xf
    5cf7:	68 20 01 00 00       	push   $0x120
    5cfc:	ff 75 e8             	pushl  -0x18(%ebp)
    5cff:	ff 75 08             	pushl  0x8(%ebp)
    5d02:	e8 32 ef ff ff       	call   4c39 <HuffmanTree_makeFromLengths>
    5d07:	83 c4 10             	add    $0x10,%esp
    5d0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5d0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5d11:	75 1d                	jne    5d30 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5d13:	6a 0f                	push   $0xf
    5d15:	6a 20                	push   $0x20
    5d17:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d1a:	ff 75 0c             	pushl  0xc(%ebp)
    5d1d:	e8 17 ef ff ff       	call   4c39 <HuffmanTree_makeFromLengths>
    5d22:	83 c4 10             	add    $0x10,%esp
    5d25:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5d28:	eb 07                	jmp    5d31 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5d2a:	90                   	nop
    5d2b:	eb 04                	jmp    5d31 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5d2d:	90                   	nop
    5d2e:	eb 01                	jmp    5d31 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5d30:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5d31:	83 ec 0c             	sub    $0xc,%esp
    5d34:	ff 75 dc             	pushl  -0x24(%ebp)
    5d37:	e8 dc d8 ff ff       	call   3618 <lodepng_free>
    5d3c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5d3f:	83 ec 0c             	sub    $0xc,%esp
    5d42:	ff 75 e8             	pushl  -0x18(%ebp)
    5d45:	e8 ce d8 ff ff       	call   3618 <lodepng_free>
    5d4a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5d4d:	83 ec 0c             	sub    $0xc,%esp
    5d50:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d53:	e8 c0 d8 ff ff       	call   3618 <lodepng_free>
    5d58:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5d5b:	83 ec 0c             	sub    $0xc,%esp
    5d5e:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5d61:	50                   	push   %eax
    5d62:	e8 b1 e7 ff ff       	call   4518 <HuffmanTree_cleanup>
    5d67:	83 c4 10             	add    $0x10,%esp

  return error;
    5d6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5d6d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5d70:	c9                   	leave  
    5d71:	c3                   	ret    

00005d72 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5d72:	55                   	push   %ebp
    5d73:	89 e5                	mov    %esp,%ebp
    5d75:	53                   	push   %ebx
    5d76:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5d79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5d80:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5d83:	50                   	push   %eax
    5d84:	e8 62 e7 ff ff       	call   44eb <HuffmanTree_init>
    5d89:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5d8c:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5d8f:	50                   	push   %eax
    5d90:	e8 56 e7 ff ff       	call   44eb <HuffmanTree_init>
    5d95:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5d98:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5d9c:	75 1b                	jne    5db9 <inflateHuffmanBlock+0x47>
    5d9e:	83 ec 08             	sub    $0x8,%esp
    5da1:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5da4:	50                   	push   %eax
    5da5:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5da8:	50                   	push   %eax
    5da9:	e8 63 fa ff ff       	call   5811 <getTreeInflateFixed>
    5dae:	83 c4 10             	add    $0x10,%esp
    5db1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5db4:	e9 9a 02 00 00       	jmp    6053 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5db9:	83 ec 04             	sub    $0x4,%esp
    5dbc:	ff 75 0c             	pushl  0xc(%ebp)
    5dbf:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5dc2:	50                   	push   %eax
    5dc3:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5dc6:	50                   	push   %eax
    5dc7:	e8 77 fa ff ff       	call   5843 <getTreeInflateDynamic>
    5dcc:	83 c4 10             	add    $0x10,%esp
    5dcf:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5dd2:	e9 7c 02 00 00       	jmp    6053 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5dd7:	83 ec 08             	sub    $0x8,%esp
    5dda:	6a 14                	push   $0x14
    5ddc:	ff 75 0c             	pushl  0xc(%ebp)
    5ddf:	e8 ef e1 ff ff       	call   3fd3 <ensureBits25>
    5de4:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5de7:	83 ec 08             	sub    $0x8,%esp
    5dea:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ded:	50                   	push   %eax
    5dee:	ff 75 0c             	pushl  0xc(%ebp)
    5df1:	e8 5a f9 ff ff       	call   5750 <huffmanDecodeSymbol>
    5df6:	83 c4 10             	add    $0x10,%esp
    5df9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5dfc:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5e03:	77 42                	ja     5e47 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5e05:	8b 45 08             	mov    0x8(%ebp),%eax
    5e08:	8b 40 04             	mov    0x4(%eax),%eax
    5e0b:	83 c0 01             	add    $0x1,%eax
    5e0e:	83 ec 08             	sub    $0x8,%esp
    5e11:	50                   	push   %eax
    5e12:	ff 75 08             	pushl  0x8(%ebp)
    5e15:	e8 37 da ff ff       	call   3851 <ucvector_resize>
    5e1a:	83 c4 10             	add    $0x10,%esp
    5e1d:	85 c0                	test   %eax,%eax
    5e1f:	75 0c                	jne    5e2d <inflateHuffmanBlock+0xbb>
    5e21:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5e28:	e9 33 02 00 00       	jmp    6060 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5e2d:	8b 45 08             	mov    0x8(%ebp),%eax
    5e30:	8b 10                	mov    (%eax),%edx
    5e32:	8b 45 08             	mov    0x8(%ebp),%eax
    5e35:	8b 40 04             	mov    0x4(%eax),%eax
    5e38:	83 e8 01             	sub    $0x1,%eax
    5e3b:	01 d0                	add    %edx,%eax
    5e3d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5e40:	88 10                	mov    %dl,(%eax)
    5e42:	e9 d9 01 00 00       	jmp    6020 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5e47:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5e4e:	0f 86 ba 01 00 00    	jbe    600e <inflateHuffmanBlock+0x29c>
    5e54:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5e5b:	0f 87 ad 01 00 00    	ja     600e <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5e61:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5e64:	2d 01 01 00 00       	sub    $0x101,%eax
    5e69:	8b 04 85 40 a0 01 00 	mov    0x1a040(,%eax,4),%eax
    5e70:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5e73:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5e76:	2d 01 01 00 00       	sub    $0x101,%eax
    5e7b:	8b 04 85 c0 a0 01 00 	mov    0x1a0c0(,%eax,4),%eax
    5e82:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5e85:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5e89:	74 1c                	je     5ea7 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5e8b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5e8e:	83 ec 08             	sub    $0x8,%esp
    5e91:	50                   	push   %eax
    5e92:	ff 75 0c             	pushl  0xc(%ebp)
    5e95:	e8 e9 e4 ff ff       	call   4383 <readBits>
    5e9a:	83 c4 10             	add    $0x10,%esp
    5e9d:	89 c2                	mov    %eax,%edx
    5e9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5ea2:	01 d0                	add    %edx,%eax
    5ea4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5ea7:	83 ec 08             	sub    $0x8,%esp
    5eaa:	6a 1c                	push   $0x1c
    5eac:	ff 75 0c             	pushl  0xc(%ebp)
    5eaf:	e8 98 e2 ff ff       	call   414c <ensureBits32>
    5eb4:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5eb7:	83 ec 08             	sub    $0x8,%esp
    5eba:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ebd:	50                   	push   %eax
    5ebe:	ff 75 0c             	pushl  0xc(%ebp)
    5ec1:	e8 8a f8 ff ff       	call   5750 <huffmanDecodeSymbol>
    5ec6:	83 c4 10             	add    $0x10,%esp
    5ec9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5ecc:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5ed0:	76 1e                	jbe    5ef0 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5ed2:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5ed6:	77 0c                	ja     5ee4 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5ed8:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5edf:	e9 7c 01 00 00       	jmp    6060 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5ee4:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5eeb:	e9 70 01 00 00       	jmp    6060 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5ef0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5ef3:	8b 04 85 40 a1 01 00 	mov    0x1a140(,%eax,4),%eax
    5efa:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5efd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5f00:	8b 04 85 c0 a1 01 00 	mov    0x1a1c0(,%eax,4),%eax
    5f07:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5f0a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5f0e:	74 15                	je     5f25 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5f10:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5f13:	83 ec 08             	sub    $0x8,%esp
    5f16:	50                   	push   %eax
    5f17:	ff 75 0c             	pushl  0xc(%ebp)
    5f1a:	e8 64 e4 ff ff       	call   4383 <readBits>
    5f1f:	83 c4 10             	add    $0x10,%esp
    5f22:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5f25:	8b 45 08             	mov    0x8(%ebp),%eax
    5f28:	8b 40 04             	mov    0x4(%eax),%eax
    5f2b:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5f2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f31:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5f34:	76 0c                	jbe    5f42 <inflateHuffmanBlock+0x1d0>
    5f36:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5f3d:	e9 1e 01 00 00       	jmp    6060 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5f42:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f45:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5f48:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5f4b:	8b 45 08             	mov    0x8(%ebp),%eax
    5f4e:	8b 50 04             	mov    0x4(%eax),%edx
    5f51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f54:	01 d0                	add    %edx,%eax
    5f56:	83 ec 08             	sub    $0x8,%esp
    5f59:	50                   	push   %eax
    5f5a:	ff 75 08             	pushl  0x8(%ebp)
    5f5d:	e8 ef d8 ff ff       	call   3851 <ucvector_resize>
    5f62:	83 c4 10             	add    $0x10,%esp
    5f65:	85 c0                	test   %eax,%eax
    5f67:	75 0c                	jne    5f75 <inflateHuffmanBlock+0x203>
    5f69:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5f70:	e9 eb 00 00 00       	jmp    6060 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5f75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f78:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5f7b:	73 6b                	jae    5fe8 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5f7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f80:	8b 55 08             	mov    0x8(%ebp),%edx
    5f83:	8b 0a                	mov    (%edx),%ecx
    5f85:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5f88:	01 d1                	add    %edx,%ecx
    5f8a:	8b 55 08             	mov    0x8(%ebp),%edx
    5f8d:	8b 1a                	mov    (%edx),%ebx
    5f8f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5f92:	01 da                	add    %ebx,%edx
    5f94:	83 ec 04             	sub    $0x4,%esp
    5f97:	50                   	push   %eax
    5f98:	51                   	push   %ecx
    5f99:	52                   	push   %edx
    5f9a:	e8 96 d6 ff ff       	call   3635 <lodepng_memcpy>
    5f9f:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5fa2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5fa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5fa8:	01 d0                	add    %edx,%eax
    5faa:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5fad:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5fb0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5fb3:	eb 29                	jmp    5fde <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5fb5:	8b 45 08             	mov    0x8(%ebp),%eax
    5fb8:	8b 08                	mov    (%eax),%ecx
    5fba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5fbd:	8d 50 01             	lea    0x1(%eax),%edx
    5fc0:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5fc3:	01 c1                	add    %eax,%ecx
    5fc5:	8b 45 08             	mov    0x8(%ebp),%eax
    5fc8:	8b 18                	mov    (%eax),%ebx
    5fca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5fcd:	8d 50 01             	lea    0x1(%eax),%edx
    5fd0:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5fd3:	01 d8                	add    %ebx,%eax
    5fd5:	0f b6 00             	movzbl (%eax),%eax
    5fd8:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5fda:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5fde:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5fe1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5fe4:	7c cf                	jl     5fb5 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5fe6:	eb 38                	jmp    6020 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5fe8:	8b 45 08             	mov    0x8(%ebp),%eax
    5feb:	8b 10                	mov    (%eax),%edx
    5fed:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5ff0:	01 c2                	add    %eax,%edx
    5ff2:	8b 45 08             	mov    0x8(%ebp),%eax
    5ff5:	8b 08                	mov    (%eax),%ecx
    5ff7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ffa:	01 c8                	add    %ecx,%eax
    5ffc:	83 ec 04             	sub    $0x4,%esp
    5fff:	ff 75 e4             	pushl  -0x1c(%ebp)
    6002:	52                   	push   %edx
    6003:	50                   	push   %eax
    6004:	e8 2c d6 ff ff       	call   3635 <lodepng_memcpy>
    6009:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    600c:	eb 12                	jmp    6020 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    600e:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    6015:	74 48                	je     605f <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    6017:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    601e:	eb 40                	jmp    6060 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    6020:	8b 45 0c             	mov    0xc(%ebp),%eax
    6023:	8b 50 0c             	mov    0xc(%eax),%edx
    6026:	8b 45 0c             	mov    0xc(%ebp),%eax
    6029:	8b 40 08             	mov    0x8(%eax),%eax
    602c:	39 c2                	cmp    %eax,%edx
    602e:	7e 09                	jle    6039 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    6030:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    6037:	eb 27                	jmp    6060 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    6039:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    603d:	74 14                	je     6053 <inflateHuffmanBlock+0x2e1>
    603f:	8b 45 08             	mov    0x8(%ebp),%eax
    6042:	8b 40 04             	mov    0x4(%eax),%eax
    6045:	3b 45 14             	cmp    0x14(%ebp),%eax
    6048:	7e 09                	jle    6053 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    604a:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    6051:	eb 0d                	jmp    6060 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6053:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6057:	0f 84 7a fd ff ff    	je     5dd7 <inflateHuffmanBlock+0x65>
    605d:	eb 01                	jmp    6060 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    605f:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    6060:	83 ec 0c             	sub    $0xc,%esp
    6063:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6066:	50                   	push   %eax
    6067:	e8 ac e4 ff ff       	call   4518 <HuffmanTree_cleanup>
    606c:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    606f:	83 ec 0c             	sub    $0xc,%esp
    6072:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6075:	50                   	push   %eax
    6076:	e8 9d e4 ff ff       	call   4518 <HuffmanTree_cleanup>
    607b:	83 c4 10             	add    $0x10,%esp

  return error;
    607e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6081:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6084:	c9                   	leave  
    6085:	c3                   	ret    

00006086 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    6086:	55                   	push   %ebp
    6087:	89 e5                	mov    %esp,%ebp
    6089:	53                   	push   %ebx
    608a:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    608d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6090:	8b 40 04             	mov    0x4(%eax),%eax
    6093:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    6096:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    609d:	8b 45 0c             	mov    0xc(%ebp),%eax
    60a0:	8b 40 0c             	mov    0xc(%eax),%eax
    60a3:	83 c0 07             	add    $0x7,%eax
    60a6:	c1 e8 03             	shr    $0x3,%eax
    60a9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    60ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    60af:	83 c0 04             	add    $0x4,%eax
    60b2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    60b5:	7c 0a                	jl     60c1 <inflateNoCompression+0x3b>
    60b7:	b8 34 00 00 00       	mov    $0x34,%eax
    60bc:	e9 01 01 00 00       	jmp    61c2 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    60c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    60c4:	8b 10                	mov    (%eax),%edx
    60c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    60c9:	01 d0                	add    %edx,%eax
    60cb:	0f b6 00             	movzbl (%eax),%eax
    60ce:	0f b6 d0             	movzbl %al,%edx
    60d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    60d4:	8b 00                	mov    (%eax),%eax
    60d6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    60d9:	83 c1 01             	add    $0x1,%ecx
    60dc:	01 c8                	add    %ecx,%eax
    60de:	0f b6 00             	movzbl (%eax),%eax
    60e1:	0f b6 c0             	movzbl %al,%eax
    60e4:	c1 e0 08             	shl    $0x8,%eax
    60e7:	01 d0                	add    %edx,%eax
    60e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    60ec:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    60f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    60f3:	8b 10                	mov    (%eax),%edx
    60f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    60f8:	01 d0                	add    %edx,%eax
    60fa:	0f b6 00             	movzbl (%eax),%eax
    60fd:	0f b6 d0             	movzbl %al,%edx
    6100:	8b 45 0c             	mov    0xc(%ebp),%eax
    6103:	8b 00                	mov    (%eax),%eax
    6105:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    6108:	83 c1 01             	add    $0x1,%ecx
    610b:	01 c8                	add    %ecx,%eax
    610d:	0f b6 00             	movzbl (%eax),%eax
    6110:	0f b6 c0             	movzbl %al,%eax
    6113:	c1 e0 08             	shl    $0x8,%eax
    6116:	01 d0                	add    %edx,%eax
    6118:	89 45 e8             	mov    %eax,-0x18(%ebp)
    611b:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    611f:	8b 45 10             	mov    0x10(%ebp),%eax
    6122:	8b 40 04             	mov    0x4(%eax),%eax
    6125:	85 c0                	test   %eax,%eax
    6127:	75 19                	jne    6142 <inflateNoCompression+0xbc>
    6129:	8b 55 ec             	mov    -0x14(%ebp),%edx
    612c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    612f:	01 d0                	add    %edx,%eax
    6131:	3d ff ff 00 00       	cmp    $0xffff,%eax
    6136:	74 0a                	je     6142 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    6138:	b8 15 00 00 00       	mov    $0x15,%eax
    613d:	e9 80 00 00 00       	jmp    61c2 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    6142:	8b 45 08             	mov    0x8(%ebp),%eax
    6145:	8b 40 04             	mov    0x4(%eax),%eax
    6148:	89 c2                	mov    %eax,%edx
    614a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    614d:	01 d0                	add    %edx,%eax
    614f:	50                   	push   %eax
    6150:	ff 75 08             	pushl  0x8(%ebp)
    6153:	e8 f9 d6 ff ff       	call   3851 <ucvector_resize>
    6158:	83 c4 08             	add    $0x8,%esp
    615b:	85 c0                	test   %eax,%eax
    615d:	75 07                	jne    6166 <inflateNoCompression+0xe0>
    615f:	b8 53 00 00 00       	mov    $0x53,%eax
    6164:	eb 5c                	jmp    61c2 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    6166:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6169:	8b 45 ec             	mov    -0x14(%ebp),%eax
    616c:	01 c2                	add    %eax,%edx
    616e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6171:	39 c2                	cmp    %eax,%edx
    6173:	76 07                	jbe    617c <inflateNoCompression+0xf6>
    6175:	b8 17 00 00 00       	mov    $0x17,%eax
    617a:	eb 46                	jmp    61c2 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    617c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    617f:	8b 55 0c             	mov    0xc(%ebp),%edx
    6182:	8b 0a                	mov    (%edx),%ecx
    6184:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6187:	01 d1                	add    %edx,%ecx
    6189:	8b 55 08             	mov    0x8(%ebp),%edx
    618c:	8b 1a                	mov    (%edx),%ebx
    618e:	8b 55 08             	mov    0x8(%ebp),%edx
    6191:	8b 52 04             	mov    0x4(%edx),%edx
    6194:	2b 55 ec             	sub    -0x14(%ebp),%edx
    6197:	01 da                	add    %ebx,%edx
    6199:	50                   	push   %eax
    619a:	51                   	push   %ecx
    619b:	52                   	push   %edx
    619c:	e8 94 d4 ff ff       	call   3635 <lodepng_memcpy>
    61a1:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    61a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    61a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    61aa:	01 d0                	add    %edx,%eax
    61ac:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    61af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    61b2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    61b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    61bc:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    61bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    61c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    61c5:	c9                   	leave  
    61c6:	c3                   	ret    

000061c7 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    61c7:	55                   	push   %ebp
    61c8:	89 e5                	mov    %esp,%ebp
    61ca:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    61cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    61d4:	ff 75 10             	pushl  0x10(%ebp)
    61d7:	ff 75 0c             	pushl  0xc(%ebp)
    61da:	8d 45 d8             	lea    -0x28(%ebp),%eax
    61dd:	50                   	push   %eax
    61de:	e8 77 db ff ff       	call   3d5a <LodePNGBitReader_init>
    61e3:	83 c4 0c             	add    $0xc,%esp
    61e6:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    61e9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    61ed:	0f 84 b9 00 00 00    	je     62ac <lodepng_inflatev+0xe5>
    61f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    61f6:	e9 c1 00 00 00       	jmp    62bc <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    61fb:	6a 03                	push   $0x3
    61fd:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6200:	50                   	push   %eax
    6201:	e8 c5 db ff ff       	call   3dcb <ensureBits9>
    6206:	83 c4 08             	add    $0x8,%esp
    6209:	85 c0                	test   %eax,%eax
    620b:	75 0a                	jne    6217 <lodepng_inflatev+0x50>
    620d:	b8 34 00 00 00       	mov    $0x34,%eax
    6212:	e9 a5 00 00 00       	jmp    62bc <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    6217:	6a 01                	push   $0x1
    6219:	8d 45 d8             	lea    -0x28(%ebp),%eax
    621c:	50                   	push   %eax
    621d:	e8 61 e1 ff ff       	call   4383 <readBits>
    6222:	83 c4 08             	add    $0x8,%esp
    6225:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    6228:	6a 02                	push   $0x2
    622a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    622d:	50                   	push   %eax
    622e:	e8 50 e1 ff ff       	call   4383 <readBits>
    6233:	83 c4 08             	add    $0x8,%esp
    6236:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    6239:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    623d:	75 07                	jne    6246 <lodepng_inflatev+0x7f>
    623f:	b8 14 00 00 00       	mov    $0x14,%eax
    6244:	eb 76                	jmp    62bc <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    6246:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    624a:	75 17                	jne    6263 <lodepng_inflatev+0x9c>
    624c:	ff 75 14             	pushl  0x14(%ebp)
    624f:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6252:	50                   	push   %eax
    6253:	ff 75 08             	pushl  0x8(%ebp)
    6256:	e8 2b fe ff ff       	call   6086 <inflateNoCompression>
    625b:	83 c4 0c             	add    $0xc,%esp
    625e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6261:	eb 1c                	jmp    627f <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    6263:	8b 45 14             	mov    0x14(%ebp),%eax
    6266:	8b 40 08             	mov    0x8(%eax),%eax
    6269:	50                   	push   %eax
    626a:	ff 75 ec             	pushl  -0x14(%ebp)
    626d:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6270:	50                   	push   %eax
    6271:	ff 75 08             	pushl  0x8(%ebp)
    6274:	e8 f9 fa ff ff       	call   5d72 <inflateHuffmanBlock>
    6279:	83 c4 10             	add    $0x10,%esp
    627c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    627f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6283:	75 21                	jne    62a6 <lodepng_inflatev+0xdf>
    6285:	8b 45 14             	mov    0x14(%ebp),%eax
    6288:	8b 40 08             	mov    0x8(%eax),%eax
    628b:	85 c0                	test   %eax,%eax
    628d:	74 17                	je     62a6 <lodepng_inflatev+0xdf>
    628f:	8b 45 08             	mov    0x8(%ebp),%eax
    6292:	8b 50 04             	mov    0x4(%eax),%edx
    6295:	8b 45 14             	mov    0x14(%ebp),%eax
    6298:	8b 40 08             	mov    0x8(%eax),%eax
    629b:	39 c2                	cmp    %eax,%edx
    629d:	7e 07                	jle    62a6 <lodepng_inflatev+0xdf>
    629f:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    62a6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    62aa:	75 0c                	jne    62b8 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    62ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    62b0:	0f 84 45 ff ff ff    	je     61fb <lodepng_inflatev+0x34>
    62b6:	eb 01                	jmp    62b9 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    62b8:	90                   	nop
  }

  return error;
    62b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    62bc:	c9                   	leave  
    62bd:	c3                   	ret    

000062be <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    62be:	55                   	push   %ebp
    62bf:	89 e5                	mov    %esp,%ebp
    62c1:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    62c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    62c7:	8b 08                	mov    (%eax),%ecx
    62c9:	8b 45 08             	mov    0x8(%ebp),%eax
    62cc:	8b 10                	mov    (%eax),%edx
    62ce:	8d 45 e8             	lea    -0x18(%ebp),%eax
    62d1:	51                   	push   %ecx
    62d2:	52                   	push   %edx
    62d3:	50                   	push   %eax
    62d4:	e8 df d5 ff ff       	call   38b8 <ucvector_init>
    62d9:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    62dc:	ff 75 18             	pushl  0x18(%ebp)
    62df:	ff 75 14             	pushl  0x14(%ebp)
    62e2:	ff 75 10             	pushl  0x10(%ebp)
    62e5:	8d 45 e8             	lea    -0x18(%ebp),%eax
    62e8:	50                   	push   %eax
    62e9:	e8 d9 fe ff ff       	call   61c7 <lodepng_inflatev>
    62ee:	83 c4 10             	add    $0x10,%esp
    62f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    62f4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    62f7:	8b 45 08             	mov    0x8(%ebp),%eax
    62fa:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    62fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    62ff:	8b 45 0c             	mov    0xc(%ebp),%eax
    6302:	89 10                	mov    %edx,(%eax)
  return error;
    6304:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6307:	c9                   	leave  
    6308:	c3                   	ret    

00006309 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    6309:	55                   	push   %ebp
    630a:	89 e5                	mov    %esp,%ebp
    630c:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    630f:	8b 45 14             	mov    0x14(%ebp),%eax
    6312:	8b 40 10             	mov    0x10(%eax),%eax
    6315:	85 c0                	test   %eax,%eax
    6317:	74 64                	je     637d <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6319:	8b 45 14             	mov    0x14(%ebp),%eax
    631c:	8b 40 10             	mov    0x10(%eax),%eax
    631f:	8b 55 08             	mov    0x8(%ebp),%edx
    6322:	8d 4a 04             	lea    0x4(%edx),%ecx
    6325:	8b 55 08             	mov    0x8(%ebp),%edx
    6328:	83 ec 0c             	sub    $0xc,%esp
    632b:	ff 75 14             	pushl  0x14(%ebp)
    632e:	ff 75 10             	pushl  0x10(%ebp)
    6331:	ff 75 0c             	pushl  0xc(%ebp)
    6334:	51                   	push   %ecx
    6335:	52                   	push   %edx
    6336:	ff d0                	call   *%eax
    6338:	83 c4 20             	add    $0x20,%esp
    633b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    633e:	8b 45 08             	mov    0x8(%ebp),%eax
    6341:	8b 50 04             	mov    0x4(%eax),%edx
    6344:	8b 45 08             	mov    0x8(%ebp),%eax
    6347:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    634a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    634e:	74 28                	je     6378 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    6350:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6357:	8b 45 14             	mov    0x14(%ebp),%eax
    635a:	8b 40 08             	mov    0x8(%eax),%eax
    635d:	85 c0                	test   %eax,%eax
    635f:	74 17                	je     6378 <inflatev+0x6f>
    6361:	8b 45 08             	mov    0x8(%ebp),%eax
    6364:	8b 50 04             	mov    0x4(%eax),%edx
    6367:	8b 45 14             	mov    0x14(%ebp),%eax
    636a:	8b 40 08             	mov    0x8(%eax),%eax
    636d:	39 c2                	cmp    %eax,%edx
    636f:	7e 07                	jle    6378 <inflatev+0x6f>
    6371:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6378:	8b 45 f4             	mov    -0xc(%ebp),%eax
    637b:	eb 14                	jmp    6391 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    637d:	ff 75 14             	pushl  0x14(%ebp)
    6380:	ff 75 10             	pushl  0x10(%ebp)
    6383:	ff 75 0c             	pushl  0xc(%ebp)
    6386:	ff 75 08             	pushl  0x8(%ebp)
    6389:	e8 39 fe ff ff       	call   61c7 <lodepng_inflatev>
    638e:	83 c4 10             	add    $0x10,%esp
  }
}
    6391:	c9                   	leave  
    6392:	c3                   	ret    

00006393 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    6393:	55                   	push   %ebp
    6394:	89 e5                	mov    %esp,%ebp
    6396:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    6399:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    63a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    63a3:	83 e8 01             	sub    $0x1,%eax
    63a6:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    63a9:	eb 39                	jmp    63e4 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    63ab:	8b 55 fc             	mov    -0x4(%ebp),%edx
    63ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    63b1:	01 d0                	add    %edx,%eax
    63b3:	d1 f8                	sar    %eax
    63b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    63b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63bb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    63c2:	8b 45 08             	mov    0x8(%ebp),%eax
    63c5:	01 d0                	add    %edx,%eax
    63c7:	8b 10                	mov    (%eax),%edx
    63c9:	8b 45 10             	mov    0x10(%ebp),%eax
    63cc:	39 c2                	cmp    %eax,%edx
    63ce:	72 0b                	jb     63db <searchCodeIndex+0x48>
    63d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63d3:	83 e8 01             	sub    $0x1,%eax
    63d6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    63d9:	eb 09                	jmp    63e4 <searchCodeIndex+0x51>
    else left = mid + 1;
    63db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63de:	83 c0 01             	add    $0x1,%eax
    63e1:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    63e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    63e7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    63ea:	7e bf                	jle    63ab <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    63ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
    63ef:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63f2:	7d 18                	jge    640c <searchCodeIndex+0x79>
    63f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    63f7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    63fe:	8b 45 08             	mov    0x8(%ebp),%eax
    6401:	01 d0                	add    %edx,%eax
    6403:	8b 10                	mov    (%eax),%edx
    6405:	8b 45 10             	mov    0x10(%ebp),%eax
    6408:	39 c2                	cmp    %eax,%edx
    640a:	76 04                	jbe    6410 <searchCodeIndex+0x7d>
    640c:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    6410:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6413:	c9                   	leave  
    6414:	c3                   	ret    

00006415 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    6415:	55                   	push   %ebp
    6416:	89 e5                	mov    %esp,%ebp
    6418:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    641b:	ff 75 0c             	pushl  0xc(%ebp)
    641e:	6a 1d                	push   $0x1d
    6420:	68 40 a0 01 00       	push   $0x1a040
    6425:	e8 69 ff ff ff       	call   6393 <searchCodeIndex>
    642a:	83 c4 0c             	add    $0xc,%esp
    642d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    6430:	8b 55 0c             	mov    0xc(%ebp),%edx
    6433:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6436:	8b 04 85 40 a0 01 00 	mov    0x1a040(,%eax,4),%eax
    643d:	29 c2                	sub    %eax,%edx
    643f:	89 d0                	mov    %edx,%eax
    6441:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    6444:	ff 75 10             	pushl  0x10(%ebp)
    6447:	6a 1e                	push   $0x1e
    6449:	68 40 a1 01 00       	push   $0x1a140
    644e:	e8 40 ff ff ff       	call   6393 <searchCodeIndex>
    6453:	83 c4 0c             	add    $0xc,%esp
    6456:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6459:	8b 55 10             	mov    0x10(%ebp),%edx
    645c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    645f:	8b 04 85 40 a1 01 00 	mov    0x1a140(,%eax,4),%eax
    6466:	29 c2                	sub    %eax,%edx
    6468:	89 d0                	mov    %edx,%eax
    646a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    646d:	8b 45 08             	mov    0x8(%ebp),%eax
    6470:	8b 40 04             	mov    0x4(%eax),%eax
    6473:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    6476:	8b 45 08             	mov    0x8(%ebp),%eax
    6479:	8b 40 04             	mov    0x4(%eax),%eax
    647c:	83 c0 04             	add    $0x4,%eax
    647f:	50                   	push   %eax
    6480:	ff 75 08             	pushl  0x8(%ebp)
    6483:	e8 f0 d2 ff ff       	call   3778 <uivector_resize>
    6488:	83 c4 08             	add    $0x8,%esp
    648b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    648e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    6492:	74 57                	je     64eb <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    6494:	8b 45 08             	mov    0x8(%ebp),%eax
    6497:	8b 00                	mov    (%eax),%eax
    6499:	8b 55 ec             	mov    -0x14(%ebp),%edx
    649c:	c1 e2 02             	shl    $0x2,%edx
    649f:	01 d0                	add    %edx,%eax
    64a1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    64a4:	81 c2 01 01 00 00    	add    $0x101,%edx
    64aa:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    64ac:	8b 45 08             	mov    0x8(%ebp),%eax
    64af:	8b 00                	mov    (%eax),%eax
    64b1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    64b4:	83 c2 01             	add    $0x1,%edx
    64b7:	c1 e2 02             	shl    $0x2,%edx
    64ba:	01 c2                	add    %eax,%edx
    64bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64bf:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    64c1:	8b 45 08             	mov    0x8(%ebp),%eax
    64c4:	8b 00                	mov    (%eax),%eax
    64c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    64c9:	83 c2 02             	add    $0x2,%edx
    64cc:	c1 e2 02             	shl    $0x2,%edx
    64cf:	01 c2                	add    %eax,%edx
    64d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    64d4:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    64d6:	8b 45 08             	mov    0x8(%ebp),%eax
    64d9:	8b 00                	mov    (%eax),%eax
    64db:	8b 55 ec             	mov    -0x14(%ebp),%edx
    64de:	83 c2 03             	add    $0x3,%edx
    64e1:	c1 e2 02             	shl    $0x2,%edx
    64e4:	01 c2                	add    %eax,%edx
    64e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    64e9:	89 02                	mov    %eax,(%edx)
  }
}
    64eb:	90                   	nop
    64ec:	c9                   	leave  
    64ed:	c3                   	ret    

000064ee <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    64ee:	55                   	push   %ebp
    64ef:	89 e5                	mov    %esp,%ebp
    64f1:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    64f4:	b8 00 00 01 00       	mov    $0x10000,%eax
    64f9:	c1 e0 02             	shl    $0x2,%eax
    64fc:	83 ec 0c             	sub    $0xc,%esp
    64ff:	50                   	push   %eax
    6500:	e8 f2 d0 ff ff       	call   35f7 <lodepng_malloc>
    6505:	83 c4 10             	add    $0x10,%esp
    6508:	89 c2                	mov    %eax,%edx
    650a:	8b 45 08             	mov    0x8(%ebp),%eax
    650d:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    650f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6512:	c1 e0 02             	shl    $0x2,%eax
    6515:	83 ec 0c             	sub    $0xc,%esp
    6518:	50                   	push   %eax
    6519:	e8 d9 d0 ff ff       	call   35f7 <lodepng_malloc>
    651e:	83 c4 10             	add    $0x10,%esp
    6521:	89 c2                	mov    %eax,%edx
    6523:	8b 45 08             	mov    0x8(%ebp),%eax
    6526:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6529:	8b 45 0c             	mov    0xc(%ebp),%eax
    652c:	01 c0                	add    %eax,%eax
    652e:	83 ec 0c             	sub    $0xc,%esp
    6531:	50                   	push   %eax
    6532:	e8 c0 d0 ff ff       	call   35f7 <lodepng_malloc>
    6537:	83 c4 10             	add    $0x10,%esp
    653a:	89 c2                	mov    %eax,%edx
    653c:	8b 45 08             	mov    0x8(%ebp),%eax
    653f:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6542:	8b 45 0c             	mov    0xc(%ebp),%eax
    6545:	01 c0                	add    %eax,%eax
    6547:	83 ec 0c             	sub    $0xc,%esp
    654a:	50                   	push   %eax
    654b:	e8 a7 d0 ff ff       	call   35f7 <lodepng_malloc>
    6550:	83 c4 10             	add    $0x10,%esp
    6553:	89 c2                	mov    %eax,%edx
    6555:	8b 45 08             	mov    0x8(%ebp),%eax
    6558:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    655b:	b8 02 01 00 00       	mov    $0x102,%eax
    6560:	83 c0 01             	add    $0x1,%eax
    6563:	c1 e0 02             	shl    $0x2,%eax
    6566:	83 ec 0c             	sub    $0xc,%esp
    6569:	50                   	push   %eax
    656a:	e8 88 d0 ff ff       	call   35f7 <lodepng_malloc>
    656f:	83 c4 10             	add    $0x10,%esp
    6572:	89 c2                	mov    %eax,%edx
    6574:	8b 45 08             	mov    0x8(%ebp),%eax
    6577:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    657a:	8b 45 0c             	mov    0xc(%ebp),%eax
    657d:	01 c0                	add    %eax,%eax
    657f:	83 ec 0c             	sub    $0xc,%esp
    6582:	50                   	push   %eax
    6583:	e8 6f d0 ff ff       	call   35f7 <lodepng_malloc>
    6588:	83 c4 10             	add    $0x10,%esp
    658b:	89 c2                	mov    %eax,%edx
    658d:	8b 45 08             	mov    0x8(%ebp),%eax
    6590:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    6593:	8b 45 08             	mov    0x8(%ebp),%eax
    6596:	8b 00                	mov    (%eax),%eax
    6598:	85 c0                	test   %eax,%eax
    659a:	74 32                	je     65ce <hash_init+0xe0>
    659c:	8b 45 08             	mov    0x8(%ebp),%eax
    659f:	8b 40 04             	mov    0x4(%eax),%eax
    65a2:	85 c0                	test   %eax,%eax
    65a4:	74 28                	je     65ce <hash_init+0xe0>
    65a6:	8b 45 08             	mov    0x8(%ebp),%eax
    65a9:	8b 40 08             	mov    0x8(%eax),%eax
    65ac:	85 c0                	test   %eax,%eax
    65ae:	74 1e                	je     65ce <hash_init+0xe0>
    65b0:	8b 45 08             	mov    0x8(%ebp),%eax
    65b3:	8b 40 0c             	mov    0xc(%eax),%eax
    65b6:	85 c0                	test   %eax,%eax
    65b8:	74 14                	je     65ce <hash_init+0xe0>
    65ba:	8b 45 08             	mov    0x8(%ebp),%eax
    65bd:	8b 40 10             	mov    0x10(%eax),%eax
    65c0:	85 c0                	test   %eax,%eax
    65c2:	74 0a                	je     65ce <hash_init+0xe0>
    65c4:	8b 45 08             	mov    0x8(%ebp),%eax
    65c7:	8b 40 14             	mov    0x14(%eax),%eax
    65ca:	85 c0                	test   %eax,%eax
    65cc:	75 0a                	jne    65d8 <hash_init+0xea>
    return 83; /*alloc fail*/
    65ce:	b8 53 00 00 00       	mov    $0x53,%eax
    65d3:	e9 d3 00 00 00       	jmp    66ab <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    65d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    65df:	eb 17                	jmp    65f8 <hash_init+0x10a>
    65e1:	8b 45 08             	mov    0x8(%ebp),%eax
    65e4:	8b 00                	mov    (%eax),%eax
    65e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    65e9:	c1 e2 02             	shl    $0x2,%edx
    65ec:	01 d0                	add    %edx,%eax
    65ee:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    65f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    65f8:	b8 00 00 01 00       	mov    $0x10000,%eax
    65fd:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6600:	75 df                	jne    65e1 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    6602:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6609:	eb 18                	jmp    6623 <hash_init+0x135>
    660b:	8b 45 08             	mov    0x8(%ebp),%eax
    660e:	8b 40 08             	mov    0x8(%eax),%eax
    6611:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6614:	c1 e2 02             	shl    $0x2,%edx
    6617:	01 d0                	add    %edx,%eax
    6619:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    661f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6623:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6626:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6629:	75 e0                	jne    660b <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    662b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6632:	eb 17                	jmp    664b <hash_init+0x15d>
    6634:	8b 45 08             	mov    0x8(%ebp),%eax
    6637:	8b 40 04             	mov    0x4(%eax),%eax
    663a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    663d:	01 d2                	add    %edx,%edx
    663f:	01 d0                	add    %edx,%eax
    6641:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6644:	66 89 10             	mov    %dx,(%eax)
    6647:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    664b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    664e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6651:	75 e1                	jne    6634 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6653:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    665a:	eb 18                	jmp    6674 <hash_init+0x186>
    665c:	8b 45 08             	mov    0x8(%ebp),%eax
    665f:	8b 40 0c             	mov    0xc(%eax),%eax
    6662:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6665:	c1 e2 02             	shl    $0x2,%edx
    6668:	01 d0                	add    %edx,%eax
    666a:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6670:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6674:	b8 02 01 00 00       	mov    $0x102,%eax
    6679:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    667c:	76 de                	jbe    665c <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    667e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6685:	eb 17                	jmp    669e <hash_init+0x1b0>
    6687:	8b 45 08             	mov    0x8(%ebp),%eax
    668a:	8b 40 10             	mov    0x10(%eax),%eax
    668d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6690:	01 d2                	add    %edx,%edx
    6692:	01 d0                	add    %edx,%eax
    6694:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6697:	66 89 10             	mov    %dx,(%eax)
    669a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    669e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    66a1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    66a4:	75 e1                	jne    6687 <hash_init+0x199>

  return 0;
    66a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    66ab:	c9                   	leave  
    66ac:	c3                   	ret    

000066ad <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    66ad:	55                   	push   %ebp
    66ae:	89 e5                	mov    %esp,%ebp
    66b0:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    66b3:	8b 45 08             	mov    0x8(%ebp),%eax
    66b6:	8b 00                	mov    (%eax),%eax
    66b8:	83 ec 0c             	sub    $0xc,%esp
    66bb:	50                   	push   %eax
    66bc:	e8 57 cf ff ff       	call   3618 <lodepng_free>
    66c1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    66c4:	8b 45 08             	mov    0x8(%ebp),%eax
    66c7:	8b 40 08             	mov    0x8(%eax),%eax
    66ca:	83 ec 0c             	sub    $0xc,%esp
    66cd:	50                   	push   %eax
    66ce:	e8 45 cf ff ff       	call   3618 <lodepng_free>
    66d3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    66d6:	8b 45 08             	mov    0x8(%ebp),%eax
    66d9:	8b 40 04             	mov    0x4(%eax),%eax
    66dc:	83 ec 0c             	sub    $0xc,%esp
    66df:	50                   	push   %eax
    66e0:	e8 33 cf ff ff       	call   3618 <lodepng_free>
    66e5:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    66e8:	8b 45 08             	mov    0x8(%ebp),%eax
    66eb:	8b 40 14             	mov    0x14(%eax),%eax
    66ee:	83 ec 0c             	sub    $0xc,%esp
    66f1:	50                   	push   %eax
    66f2:	e8 21 cf ff ff       	call   3618 <lodepng_free>
    66f7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    66fa:	8b 45 08             	mov    0x8(%ebp),%eax
    66fd:	8b 40 0c             	mov    0xc(%eax),%eax
    6700:	83 ec 0c             	sub    $0xc,%esp
    6703:	50                   	push   %eax
    6704:	e8 0f cf ff ff       	call   3618 <lodepng_free>
    6709:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    670c:	8b 45 08             	mov    0x8(%ebp),%eax
    670f:	8b 40 10             	mov    0x10(%eax),%eax
    6712:	83 ec 0c             	sub    $0xc,%esp
    6715:	50                   	push   %eax
    6716:	e8 fd ce ff ff       	call   3618 <lodepng_free>
    671b:	83 c4 10             	add    $0x10,%esp
}
    671e:	90                   	nop
    671f:	c9                   	leave  
    6720:	c3                   	ret    

00006721 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    6721:	55                   	push   %ebp
    6722:	89 e5                	mov    %esp,%ebp
    6724:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6727:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    672e:	8b 45 10             	mov    0x10(%ebp),%eax
    6731:	83 c0 02             	add    $0x2,%eax
    6734:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6737:	7d 41                	jge    677a <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6739:	8b 55 10             	mov    0x10(%ebp),%edx
    673c:	8b 45 08             	mov    0x8(%ebp),%eax
    673f:	01 d0                	add    %edx,%eax
    6741:	0f b6 00             	movzbl (%eax),%eax
    6744:	0f b6 c0             	movzbl %al,%eax
    6747:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    674a:	8b 45 10             	mov    0x10(%ebp),%eax
    674d:	8d 50 01             	lea    0x1(%eax),%edx
    6750:	8b 45 08             	mov    0x8(%ebp),%eax
    6753:	01 d0                	add    %edx,%eax
    6755:	0f b6 00             	movzbl (%eax),%eax
    6758:	0f b6 c0             	movzbl %al,%eax
    675b:	c1 e0 04             	shl    $0x4,%eax
    675e:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    6761:	8b 45 10             	mov    0x10(%ebp),%eax
    6764:	8d 50 02             	lea    0x2(%eax),%edx
    6767:	8b 45 08             	mov    0x8(%ebp),%eax
    676a:	01 d0                	add    %edx,%eax
    676c:	0f b6 00             	movzbl (%eax),%eax
    676f:	0f b6 c0             	movzbl %al,%eax
    6772:	c1 e0 08             	shl    $0x8,%eax
    6775:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6778:	eb 51                	jmp    67cb <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    677a:	8b 45 10             	mov    0x10(%ebp),%eax
    677d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6780:	7c 07                	jl     6789 <getHash+0x68>
    6782:	b8 00 00 00 00       	mov    $0x0,%eax
    6787:	eb 4a                	jmp    67d3 <getHash+0xb2>
    amount = size - pos;
    6789:	8b 45 0c             	mov    0xc(%ebp),%eax
    678c:	2b 45 10             	sub    0x10(%ebp),%eax
    678f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    6792:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6799:	eb 28                	jmp    67c3 <getHash+0xa2>
    679b:	8b 55 10             	mov    0x10(%ebp),%edx
    679e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    67a1:	01 d0                	add    %edx,%eax
    67a3:	89 c2                	mov    %eax,%edx
    67a5:	8b 45 08             	mov    0x8(%ebp),%eax
    67a8:	01 d0                	add    %edx,%eax
    67aa:	0f b6 00             	movzbl (%eax),%eax
    67ad:	0f b6 d0             	movzbl %al,%edx
    67b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    67b3:	c1 e0 03             	shl    $0x3,%eax
    67b6:	89 c1                	mov    %eax,%ecx
    67b8:	d3 e2                	shl    %cl,%edx
    67ba:	89 d0                	mov    %edx,%eax
    67bc:	31 45 fc             	xor    %eax,-0x4(%ebp)
    67bf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    67c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    67c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    67c9:	75 d0                	jne    679b <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    67cb:	b8 ff ff 00 00       	mov    $0xffff,%eax
    67d0:	23 45 fc             	and    -0x4(%ebp),%eax
}
    67d3:	c9                   	leave  
    67d4:	c3                   	ret    

000067d5 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    67d5:	55                   	push   %ebp
    67d6:	89 e5                	mov    %esp,%ebp
    67d8:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    67db:	8b 55 10             	mov    0x10(%ebp),%edx
    67de:	8b 45 08             	mov    0x8(%ebp),%eax
    67e1:	01 d0                	add    %edx,%eax
    67e3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    67e6:	b8 02 01 00 00       	mov    $0x102,%eax
    67eb:	89 c2                	mov    %eax,%edx
    67ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    67f0:	01 d0                	add    %edx,%eax
    67f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    67f5:	8b 55 0c             	mov    0xc(%ebp),%edx
    67f8:	8b 45 08             	mov    0x8(%ebp),%eax
    67fb:	01 d0                	add    %edx,%eax
    67fd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6800:	73 0b                	jae    680d <countZeros+0x38>
    6802:	8b 55 0c             	mov    0xc(%ebp),%edx
    6805:	8b 45 08             	mov    0x8(%ebp),%eax
    6808:	01 d0                	add    %edx,%eax
    680a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    680d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6810:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    6813:	eb 04                	jmp    6819 <countZeros+0x44>
    6815:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6819:	8b 45 08             	mov    0x8(%ebp),%eax
    681c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    681f:	74 0a                	je     682b <countZeros+0x56>
    6821:	8b 45 08             	mov    0x8(%ebp),%eax
    6824:	0f b6 00             	movzbl (%eax),%eax
    6827:	84 c0                	test   %al,%al
    6829:	74 ea                	je     6815 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    682b:	8b 55 08             	mov    0x8(%ebp),%edx
    682e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6831:	29 c2                	sub    %eax,%edx
    6833:	89 d0                	mov    %edx,%eax
}
    6835:	c9                   	leave  
    6836:	c3                   	ret    

00006837 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6837:	55                   	push   %ebp
    6838:	89 e5                	mov    %esp,%ebp
    683a:	83 ec 04             	sub    $0x4,%esp
    683d:	8b 45 14             	mov    0x14(%ebp),%eax
    6840:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6844:	8b 45 08             	mov    0x8(%ebp),%eax
    6847:	8b 40 08             	mov    0x8(%eax),%eax
    684a:	8b 55 0c             	mov    0xc(%ebp),%edx
    684d:	c1 e2 02             	shl    $0x2,%edx
    6850:	01 c2                	add    %eax,%edx
    6852:	8b 45 10             	mov    0x10(%ebp),%eax
    6855:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6857:	8b 45 08             	mov    0x8(%ebp),%eax
    685a:	8b 00                	mov    (%eax),%eax
    685c:	8b 55 10             	mov    0x10(%ebp),%edx
    685f:	c1 e2 02             	shl    $0x2,%edx
    6862:	01 d0                	add    %edx,%eax
    6864:	8b 00                	mov    (%eax),%eax
    6866:	83 f8 ff             	cmp    $0xffffffff,%eax
    6869:	74 1f                	je     688a <updateHashChain+0x53>
    686b:	8b 45 08             	mov    0x8(%ebp),%eax
    686e:	8b 40 04             	mov    0x4(%eax),%eax
    6871:	8b 55 0c             	mov    0xc(%ebp),%edx
    6874:	01 d2                	add    %edx,%edx
    6876:	01 c2                	add    %eax,%edx
    6878:	8b 45 08             	mov    0x8(%ebp),%eax
    687b:	8b 00                	mov    (%eax),%eax
    687d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6880:	c1 e1 02             	shl    $0x2,%ecx
    6883:	01 c8                	add    %ecx,%eax
    6885:	8b 00                	mov    (%eax),%eax
    6887:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    688a:	8b 45 08             	mov    0x8(%ebp),%eax
    688d:	8b 00                	mov    (%eax),%eax
    688f:	8b 55 10             	mov    0x10(%ebp),%edx
    6892:	c1 e2 02             	shl    $0x2,%edx
    6895:	01 c2                	add    %eax,%edx
    6897:	8b 45 0c             	mov    0xc(%ebp),%eax
    689a:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    689c:	8b 45 08             	mov    0x8(%ebp),%eax
    689f:	8b 40 14             	mov    0x14(%eax),%eax
    68a2:	8b 55 0c             	mov    0xc(%ebp),%edx
    68a5:	01 d2                	add    %edx,%edx
    68a7:	01 c2                	add    %eax,%edx
    68a9:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    68ad:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    68b0:	8b 45 08             	mov    0x8(%ebp),%eax
    68b3:	8b 40 0c             	mov    0xc(%eax),%eax
    68b6:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    68ba:	c1 e2 02             	shl    $0x2,%edx
    68bd:	01 d0                	add    %edx,%eax
    68bf:	8b 00                	mov    (%eax),%eax
    68c1:	83 f8 ff             	cmp    $0xffffffff,%eax
    68c4:	74 21                	je     68e7 <updateHashChain+0xb0>
    68c6:	8b 45 08             	mov    0x8(%ebp),%eax
    68c9:	8b 40 10             	mov    0x10(%eax),%eax
    68cc:	8b 55 0c             	mov    0xc(%ebp),%edx
    68cf:	01 d2                	add    %edx,%edx
    68d1:	01 c2                	add    %eax,%edx
    68d3:	8b 45 08             	mov    0x8(%ebp),%eax
    68d6:	8b 40 0c             	mov    0xc(%eax),%eax
    68d9:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    68dd:	c1 e1 02             	shl    $0x2,%ecx
    68e0:	01 c8                	add    %ecx,%eax
    68e2:	8b 00                	mov    (%eax),%eax
    68e4:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    68e7:	8b 45 08             	mov    0x8(%ebp),%eax
    68ea:	8b 40 0c             	mov    0xc(%eax),%eax
    68ed:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    68f1:	c1 e2 02             	shl    $0x2,%edx
    68f4:	01 c2                	add    %eax,%edx
    68f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    68f9:	89 02                	mov    %eax,(%edx)
}
    68fb:	90                   	nop
    68fc:	c9                   	leave  
    68fd:	c3                   	ret    

000068fe <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    68fe:	55                   	push   %ebp
    68ff:	89 e5                	mov    %esp,%ebp
    6901:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    6904:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    690b:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6912:	77 08                	ja     691c <encodeLZ77+0x1e>
    6914:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6917:	c1 e8 03             	shr    $0x3,%eax
    691a:	eb 03                	jmp    691f <encodeLZ77+0x21>
    691c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    691f:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6922:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6929:	76 07                	jbe    6932 <encodeLZ77+0x34>
    692b:	b8 02 01 00 00       	mov    $0x102,%eax
    6930:	eb 05                	jmp    6937 <encodeLZ77+0x39>
    6932:	b8 40 00 00 00       	mov    $0x40,%eax
    6937:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    693a:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    6941:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6948:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    694f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6956:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    695d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    6961:	74 09                	je     696c <encodeLZ77+0x6e>
    6963:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    696a:	76 0a                	jbe    6976 <encodeLZ77+0x78>
    696c:	b8 3c 00 00 00       	mov    $0x3c,%eax
    6971:	e9 e3 04 00 00       	jmp    6e59 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    6976:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6979:	83 e8 01             	sub    $0x1,%eax
    697c:	23 45 1c             	and    0x1c(%ebp),%eax
    697f:	85 c0                	test   %eax,%eax
    6981:	74 0a                	je     698d <encodeLZ77+0x8f>
    6983:	b8 5a 00 00 00       	mov    $0x5a,%eax
    6988:	e9 cc 04 00 00       	jmp    6e59 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    698d:	b8 02 01 00 00       	mov    $0x102,%eax
    6992:	39 45 24             	cmp    %eax,0x24(%ebp)
    6995:	76 08                	jbe    699f <encodeLZ77+0xa1>
    6997:	b8 02 01 00 00       	mov    $0x102,%eax
    699c:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    699f:	8b 45 14             	mov    0x14(%ebp),%eax
    69a2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    69a5:	e9 a0 04 00 00       	jmp    6e4a <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    69aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    69ad:	8d 50 ff             	lea    -0x1(%eax),%edx
    69b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    69b3:	21 d0                	and    %edx,%eax
    69b5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    69b8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    69bf:	ff 75 fc             	pushl  -0x4(%ebp)
    69c2:	ff 75 18             	pushl  0x18(%ebp)
    69c5:	ff 75 10             	pushl  0x10(%ebp)
    69c8:	e8 54 fd ff ff       	call   6721 <getHash>
    69cd:	83 c4 0c             	add    $0xc,%esp
    69d0:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    69d3:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    69d7:	74 4e                	je     6a27 <encodeLZ77+0x129>
    69d9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    69dd:	75 48                	jne    6a27 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    69df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    69e3:	75 16                	jne    69fb <encodeLZ77+0xfd>
    69e5:	ff 75 fc             	pushl  -0x4(%ebp)
    69e8:	ff 75 18             	pushl  0x18(%ebp)
    69eb:	ff 75 10             	pushl  0x10(%ebp)
    69ee:	e8 e2 fd ff ff       	call   67d5 <countZeros>
    69f3:	83 c4 0c             	add    $0xc,%esp
    69f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    69f9:	eb 35                	jmp    6a30 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    69fb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    69fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a01:	01 c2                	add    %eax,%edx
    6a03:	8b 45 18             	mov    0x18(%ebp),%eax
    6a06:	39 c2                	cmp    %eax,%edx
    6a08:	77 17                	ja     6a21 <encodeLZ77+0x123>
    6a0a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a10:	01 d0                	add    %edx,%eax
    6a12:	8d 50 ff             	lea    -0x1(%eax),%edx
    6a15:	8b 45 10             	mov    0x10(%ebp),%eax
    6a18:	01 d0                	add    %edx,%eax
    6a1a:	0f b6 00             	movzbl (%eax),%eax
    6a1d:	84 c0                	test   %al,%al
    6a1f:	74 0f                	je     6a30 <encodeLZ77+0x132>
    6a21:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6a25:	eb 09                	jmp    6a30 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6a27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6a2e:	eb 01                	jmp    6a31 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6a30:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    6a31:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a34:	0f b7 c0             	movzwl %ax,%eax
    6a37:	50                   	push   %eax
    6a38:	ff 75 b0             	pushl  -0x50(%ebp)
    6a3b:	ff 75 b4             	pushl  -0x4c(%ebp)
    6a3e:	ff 75 0c             	pushl  0xc(%ebp)
    6a41:	e8 f1 fd ff ff       	call   6837 <updateHashChain>
    6a46:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6a49:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    6a50:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6a57:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a5a:	8b 40 04             	mov    0x4(%eax),%eax
    6a5d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    6a60:	01 d2                	add    %edx,%edx
    6a62:	01 d0                	add    %edx,%eax
    6a64:	0f b7 00             	movzwl (%eax),%eax
    6a67:	0f b7 c0             	movzwl %ax,%eax
    6a6a:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6a6d:	ba 02 01 00 00       	mov    $0x102,%edx
    6a72:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6a75:	01 c2                	add    %eax,%edx
    6a77:	8b 45 18             	mov    0x18(%ebp),%eax
    6a7a:	39 c2                	cmp    %eax,%edx
    6a7c:	0f 4e c2             	cmovle %edx,%eax
    6a7f:	89 c2                	mov    %eax,%edx
    6a81:	8b 45 10             	mov    0x10(%ebp),%eax
    6a84:	01 d0                	add    %edx,%eax
    6a86:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6a89:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6a90:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6a93:	8d 50 01             	lea    0x1(%eax),%edx
    6a96:	89 55 c8             	mov    %edx,-0x38(%ebp)
    6a99:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6a9c:	0f 83 67 01 00 00    	jae    6c09 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    6aa2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6aa5:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    6aa8:	77 08                	ja     6ab2 <encodeLZ77+0x1b4>
    6aaa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6aad:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6ab0:	eb 0d                	jmp    6abf <encodeLZ77+0x1c1>
    6ab2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6ab5:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6ab8:	89 c2                	mov    %eax,%edx
    6aba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6abd:	01 d0                	add    %edx,%eax
    6abf:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6ac2:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6ac5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6ac8:	0f 82 3e 01 00 00    	jb     6c0c <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6ace:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6ad1:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    6ad4:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6ad8:	0f 84 a3 00 00 00    	je     6b81 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    6ade:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ae1:	8b 45 10             	mov    0x10(%ebp),%eax
    6ae4:	01 d0                	add    %edx,%eax
    6ae6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6ae9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6aec:	2b 45 a8             	sub    -0x58(%ebp),%eax
    6aef:	89 c2                	mov    %eax,%edx
    6af1:	8b 45 10             	mov    0x10(%ebp),%eax
    6af4:	01 d0                	add    %edx,%eax
    6af6:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6af9:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6afd:	76 3a                	jbe    6b39 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    6aff:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b02:	8b 40 14             	mov    0x14(%eax),%eax
    6b05:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6b08:	01 d2                	add    %edx,%edx
    6b0a:	01 d0                	add    %edx,%eax
    6b0c:	0f b7 00             	movzwl (%eax),%eax
    6b0f:	0f b7 c0             	movzwl %ax,%eax
    6b12:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6b15:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6b18:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6b1b:	76 06                	jbe    6b23 <encodeLZ77+0x225>
    6b1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b20:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    6b23:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6b26:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6b29:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6b2c:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6b2f:	eb 08                	jmp    6b39 <encodeLZ77+0x23b>
          ++backptr;
    6b31:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6b35:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6b39:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6b3c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    6b3f:	74 10                	je     6b51 <encodeLZ77+0x253>
    6b41:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6b44:	0f b6 10             	movzbl (%eax),%edx
    6b47:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6b4a:	0f b6 00             	movzbl (%eax),%eax
    6b4d:	38 c2                	cmp    %al,%dl
    6b4f:	74 e0                	je     6b31 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    6b51:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6b54:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6b57:	8b 55 10             	mov    0x10(%ebp),%edx
    6b5a:	01 ca                	add    %ecx,%edx
    6b5c:	29 d0                	sub    %edx,%eax
    6b5e:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    6b61:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6b64:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6b67:	76 18                	jbe    6b81 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6b69:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6b6c:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    6b6f:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6b72:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6b75:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6b78:	3b 45 24             	cmp    0x24(%ebp),%eax
    6b7b:	0f 83 8e 00 00 00    	jae    6c0f <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6b81:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b84:	8b 40 04             	mov    0x4(%eax),%eax
    6b87:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6b8a:	01 d2                	add    %edx,%edx
    6b8c:	01 d0                	add    %edx,%eax
    6b8e:	0f b7 00             	movzwl (%eax),%eax
    6b91:	0f b7 c0             	movzwl %ax,%eax
    6b94:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6b97:	74 79                	je     6c12 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    6b99:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6b9d:	76 38                	jbe    6bd7 <encodeLZ77+0x2d9>
    6b9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6ba2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6ba5:	76 30                	jbe    6bd7 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    6ba7:	8b 45 0c             	mov    0xc(%ebp),%eax
    6baa:	8b 40 10             	mov    0x10(%eax),%eax
    6bad:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6bb0:	01 d2                	add    %edx,%edx
    6bb2:	01 d0                	add    %edx,%eax
    6bb4:	0f b7 00             	movzwl (%eax),%eax
    6bb7:	0f b7 c0             	movzwl %ax,%eax
    6bba:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    6bbd:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bc0:	8b 40 14             	mov    0x14(%eax),%eax
    6bc3:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6bc6:	01 d2                	add    %edx,%edx
    6bc8:	01 d0                	add    %edx,%eax
    6bca:	0f b7 00             	movzwl (%eax),%eax
    6bcd:	0f b7 c0             	movzwl %ax,%eax
    6bd0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6bd3:	74 2f                	je     6c04 <encodeLZ77+0x306>
    6bd5:	eb 3f                	jmp    6c16 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6bd7:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bda:	8b 40 04             	mov    0x4(%eax),%eax
    6bdd:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6be0:	01 d2                	add    %edx,%edx
    6be2:	01 d0                	add    %edx,%eax
    6be4:	0f b7 00             	movzwl (%eax),%eax
    6be7:	0f b7 c0             	movzwl %ax,%eax
    6bea:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6bed:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bf0:	8b 40 08             	mov    0x8(%eax),%eax
    6bf3:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6bf6:	c1 e2 02             	shl    $0x2,%edx
    6bf9:	01 d0                	add    %edx,%eax
    6bfb:	8b 10                	mov    (%eax),%edx
    6bfd:	8b 45 b0             	mov    -0x50(%ebp),%eax
    6c00:	39 c2                	cmp    %eax,%edx
    6c02:	75 11                	jne    6c15 <encodeLZ77+0x317>
      }
    }
    6c04:	e9 87 fe ff ff       	jmp    6a90 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6c09:	90                   	nop
    6c0a:	eb 0a                	jmp    6c16 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6c0c:	90                   	nop
    6c0d:	eb 07                	jmp    6c16 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6c0f:	90                   	nop
    6c10:	eb 04                	jmp    6c16 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6c12:	90                   	nop
    6c13:	eb 01                	jmp    6c16 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6c15:	90                   	nop
      }
    }

    if(lazymatching) {
    6c16:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6c1a:	0f 84 c8 00 00 00    	je     6ce8 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    6c20:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6c24:	75 30                	jne    6c56 <encodeLZ77+0x358>
    6c26:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6c2a:	76 2a                	jbe    6c56 <encodeLZ77+0x358>
    6c2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c2f:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6c32:	77 22                	ja     6c56 <encodeLZ77+0x358>
    6c34:	b8 02 01 00 00       	mov    $0x102,%eax
    6c39:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6c3c:	73 18                	jae    6c56 <encodeLZ77+0x358>
        lazy = 1;
    6c3e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6c45:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c48:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6c4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6c4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6c51:	e9 f0 01 00 00       	jmp    6e46 <encodeLZ77+0x548>
      }
      if(lazy) {
    6c56:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6c5a:	0f 84 88 00 00 00    	je     6ce8 <encodeLZ77+0x3ea>
        lazy = 0;
    6c60:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6c67:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6c6b:	75 0c                	jne    6c79 <encodeLZ77+0x37b>
    6c6d:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6c74:	e9 dd 01 00 00       	jmp    6e56 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6c79:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c7c:	83 c0 01             	add    $0x1,%eax
    6c7f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6c82:	73 2d                	jae    6cb1 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    6c84:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c87:	8d 50 ff             	lea    -0x1(%eax),%edx
    6c8a:	8b 45 10             	mov    0x10(%ebp),%eax
    6c8d:	01 d0                	add    %edx,%eax
    6c8f:	0f b6 00             	movzbl (%eax),%eax
    6c92:	0f b6 c0             	movzbl %al,%eax
    6c95:	50                   	push   %eax
    6c96:	ff 75 08             	pushl  0x8(%ebp)
    6c99:	e8 6f cb ff ff       	call   380d <uivector_push_back>
    6c9e:	83 c4 08             	add    $0x8,%esp
    6ca1:	85 c0                	test   %eax,%eax
    6ca3:	75 43                	jne    6ce8 <encodeLZ77+0x3ea>
    6ca5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6cac:	e9 a5 01 00 00       	jmp    6e56 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6cb1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6cb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6cb7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6cba:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6cbd:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cc0:	8b 00                	mov    (%eax),%eax
    6cc2:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6cc5:	c1 e2 02             	shl    $0x2,%edx
    6cc8:	01 d0                	add    %edx,%eax
    6cca:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6cd0:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cd3:	8b 40 0c             	mov    0xc(%eax),%eax
    6cd6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6cd9:	c1 e2 02             	shl    $0x2,%edx
    6cdc:	01 d0                	add    %edx,%eax
    6cde:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6ce4:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6ce8:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6cec:	76 14                	jbe    6d02 <encodeLZ77+0x404>
    6cee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6cf1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6cf4:	76 0c                	jbe    6d02 <encodeLZ77+0x404>
    6cf6:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6cfd:	e9 54 01 00 00       	jmp    6e56 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6d02:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6d06:	77 2e                	ja     6d36 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6d08:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d0b:	8b 45 10             	mov    0x10(%ebp),%eax
    6d0e:	01 d0                	add    %edx,%eax
    6d10:	0f b6 00             	movzbl (%eax),%eax
    6d13:	0f b6 c0             	movzbl %al,%eax
    6d16:	50                   	push   %eax
    6d17:	ff 75 08             	pushl  0x8(%ebp)
    6d1a:	e8 ee ca ff ff       	call   380d <uivector_push_back>
    6d1f:	83 c4 08             	add    $0x8,%esp
    6d22:	85 c0                	test   %eax,%eax
    6d24:	0f 85 1c 01 00 00    	jne    6e46 <encodeLZ77+0x548>
    6d2a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6d31:	e9 20 01 00 00       	jmp    6e56 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6d36:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d39:	3b 45 20             	cmp    0x20(%ebp),%eax
    6d3c:	72 0f                	jb     6d4d <encodeLZ77+0x44f>
    6d3e:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6d42:	75 37                	jne    6d7b <encodeLZ77+0x47d>
    6d44:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6d4b:	76 2e                	jbe    6d7b <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6d4d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d50:	8b 45 10             	mov    0x10(%ebp),%eax
    6d53:	01 d0                	add    %edx,%eax
    6d55:	0f b6 00             	movzbl (%eax),%eax
    6d58:	0f b6 c0             	movzbl %al,%eax
    6d5b:	50                   	push   %eax
    6d5c:	ff 75 08             	pushl  0x8(%ebp)
    6d5f:	e8 a9 ca ff ff       	call   380d <uivector_push_back>
    6d64:	83 c4 08             	add    $0x8,%esp
    6d67:	85 c0                	test   %eax,%eax
    6d69:	0f 85 d7 00 00 00    	jne    6e46 <encodeLZ77+0x548>
    6d6f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6d76:	e9 db 00 00 00       	jmp    6e56 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6d7b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6d7e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d81:	52                   	push   %edx
    6d82:	50                   	push   %eax
    6d83:	ff 75 08             	pushl  0x8(%ebp)
    6d86:	e8 8a f6 ff ff       	call   6415 <addLengthDistance>
    6d8b:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6d8e:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6d95:	e9 a0 00 00 00       	jmp    6e3a <encodeLZ77+0x53c>
        ++pos;
    6d9a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6d9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6da1:	8d 50 ff             	lea    -0x1(%eax),%edx
    6da4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6da7:	21 d0                	and    %edx,%eax
    6da9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6dac:	ff 75 fc             	pushl  -0x4(%ebp)
    6daf:	ff 75 18             	pushl  0x18(%ebp)
    6db2:	ff 75 10             	pushl  0x10(%ebp)
    6db5:	e8 67 f9 ff ff       	call   6721 <getHash>
    6dba:	83 c4 0c             	add    $0xc,%esp
    6dbd:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6dc0:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6dc4:	74 4e                	je     6e14 <encodeLZ77+0x516>
    6dc6:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6dca:	75 48                	jne    6e14 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6dcc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6dd0:	75 16                	jne    6de8 <encodeLZ77+0x4ea>
    6dd2:	ff 75 fc             	pushl  -0x4(%ebp)
    6dd5:	ff 75 18             	pushl  0x18(%ebp)
    6dd8:	ff 75 10             	pushl  0x10(%ebp)
    6ddb:	e8 f5 f9 ff ff       	call   67d5 <countZeros>
    6de0:	83 c4 0c             	add    $0xc,%esp
    6de3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6de6:	eb 35                	jmp    6e1d <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6de8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6deb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dee:	01 c2                	add    %eax,%edx
    6df0:	8b 45 18             	mov    0x18(%ebp),%eax
    6df3:	39 c2                	cmp    %eax,%edx
    6df5:	77 17                	ja     6e0e <encodeLZ77+0x510>
    6df7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6dfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dfd:	01 d0                	add    %edx,%eax
    6dff:	8d 50 ff             	lea    -0x1(%eax),%edx
    6e02:	8b 45 10             	mov    0x10(%ebp),%eax
    6e05:	01 d0                	add    %edx,%eax
    6e07:	0f b6 00             	movzbl (%eax),%eax
    6e0a:	84 c0                	test   %al,%al
    6e0c:	74 0f                	je     6e1d <encodeLZ77+0x51f>
    6e0e:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6e12:	eb 09                	jmp    6e1d <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6e14:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6e1b:	eb 01                	jmp    6e1e <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6e1d:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6e1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e21:	0f b7 c0             	movzwl %ax,%eax
    6e24:	50                   	push   %eax
    6e25:	ff 75 b0             	pushl  -0x50(%ebp)
    6e28:	ff 75 b4             	pushl  -0x4c(%ebp)
    6e2b:	ff 75 0c             	pushl  0xc(%ebp)
    6e2e:	e8 04 fa ff ff       	call   6837 <updateHashChain>
    6e33:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6e36:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6e3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6e3d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6e40:	0f 82 54 ff ff ff    	jb     6d9a <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6e46:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6e4d:	3b 45 18             	cmp    0x18(%ebp),%eax
    6e50:	0f 8c 54 fb ff ff    	jl     69aa <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6e59:	c9                   	leave  
    6e5a:	c3                   	ret    

00006e5b <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6e5b:	55                   	push   %ebp
    6e5c:	89 e5                	mov    %esp,%ebp
    6e5e:	53                   	push   %ebx
    6e5f:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6e62:	8b 45 10             	mov    0x10(%ebp),%eax
    6e65:	05 fe ff 00 00       	add    $0xfffe,%eax
    6e6a:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6e6f:	f7 e2                	mul    %edx
    6e71:	89 d0                	mov    %edx,%eax
    6e73:	c1 e8 0f             	shr    $0xf,%eax
    6e76:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6e79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6e80:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6e87:	e9 1b 01 00 00       	jmp    6fa7 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6e8c:	8b 45 08             	mov    0x8(%ebp),%eax
    6e8f:	8b 40 04             	mov    0x4(%eax),%eax
    6e92:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6e95:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6e98:	83 e8 01             	sub    $0x1,%eax
    6e9b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6e9e:	0f 94 c0             	sete   %al
    6ea1:	0f b6 c0             	movzbl %al,%eax
    6ea4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6ea7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6eae:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6eb5:	8b 45 10             	mov    0x10(%ebp),%eax
    6eb8:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6ebb:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6ec0:	77 09                	ja     6ecb <deflateNoCompression+0x70>
    6ec2:	8b 45 10             	mov    0x10(%ebp),%eax
    6ec5:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6ec8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6ecb:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6ed0:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6ed3:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6ed6:	8b 45 08             	mov    0x8(%ebp),%eax
    6ed9:	8b 40 04             	mov    0x4(%eax),%eax
    6edc:	89 c2                	mov    %eax,%edx
    6ede:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ee1:	01 d0                	add    %edx,%eax
    6ee3:	83 c0 05             	add    $0x5,%eax
    6ee6:	50                   	push   %eax
    6ee7:	ff 75 08             	pushl  0x8(%ebp)
    6eea:	e8 62 c9 ff ff       	call   3851 <ucvector_resize>
    6eef:	83 c4 08             	add    $0x8,%esp
    6ef2:	85 c0                	test   %eax,%eax
    6ef4:	75 0a                	jne    6f00 <deflateNoCompression+0xa5>
    6ef6:	b8 53 00 00 00       	mov    $0x53,%eax
    6efb:	e9 b8 00 00 00       	jmp    6fb8 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6f00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6f03:	89 c2                	mov    %eax,%edx
    6f05:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6f08:	83 e0 01             	and    $0x1,%eax
    6f0b:	01 c0                	add    %eax,%eax
    6f0d:	01 c2                	add    %eax,%edx
    6f0f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6f12:	83 e0 02             	and    $0x2,%eax
    6f15:	01 c0                	add    %eax,%eax
    6f17:	01 d0                	add    %edx,%eax
    6f19:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    6f1f:	8b 10                	mov    (%eax),%edx
    6f21:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6f24:	01 c2                	add    %eax,%edx
    6f26:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6f2a:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6f2c:	8b 45 08             	mov    0x8(%ebp),%eax
    6f2f:	8b 00                	mov    (%eax),%eax
    6f31:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f34:	83 c2 01             	add    $0x1,%edx
    6f37:	01 d0                	add    %edx,%eax
    6f39:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6f3c:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6f3e:	8b 45 08             	mov    0x8(%ebp),%eax
    6f41:	8b 00                	mov    (%eax),%eax
    6f43:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f46:	83 c2 02             	add    $0x2,%edx
    6f49:	01 d0                	add    %edx,%eax
    6f4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6f4e:	c1 ea 08             	shr    $0x8,%edx
    6f51:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6f53:	8b 45 08             	mov    0x8(%ebp),%eax
    6f56:	8b 00                	mov    (%eax),%eax
    6f58:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f5b:	83 c2 03             	add    $0x3,%edx
    6f5e:	01 d0                	add    %edx,%eax
    6f60:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6f63:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6f65:	8b 45 08             	mov    0x8(%ebp),%eax
    6f68:	8b 00                	mov    (%eax),%eax
    6f6a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f6d:	83 c2 04             	add    $0x4,%edx
    6f70:	01 d0                	add    %edx,%eax
    6f72:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6f75:	c1 ea 08             	shr    $0x8,%edx
    6f78:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6f7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f7d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6f80:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6f83:	01 d1                	add    %edx,%ecx
    6f85:	8b 55 08             	mov    0x8(%ebp),%edx
    6f88:	8b 12                	mov    (%edx),%edx
    6f8a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6f8d:	83 c3 05             	add    $0x5,%ebx
    6f90:	01 da                	add    %ebx,%edx
    6f92:	50                   	push   %eax
    6f93:	51                   	push   %ecx
    6f94:	52                   	push   %edx
    6f95:	e8 9b c6 ff ff       	call   3635 <lodepng_memcpy>
    6f9a:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6f9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6fa0:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6fa3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6fa7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6faa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6fad:	0f 85 d9 fe ff ff    	jne    6e8c <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6fb3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6fb8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6fbb:	c9                   	leave  
    6fbc:	c3                   	ret    

00006fbd <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6fbd:	55                   	push   %ebp
    6fbe:	89 e5                	mov    %esp,%ebp
    6fc0:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6fc3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6fca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6fd1:	e9 10 01 00 00       	jmp    70e6 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6fd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    6fd9:	8b 00                	mov    (%eax),%eax
    6fdb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6fde:	c1 e2 02             	shl    $0x2,%edx
    6fe1:	01 d0                	add    %edx,%eax
    6fe3:	8b 00                	mov    (%eax),%eax
    6fe5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6fe8:	8b 45 10             	mov    0x10(%ebp),%eax
    6feb:	8b 40 04             	mov    0x4(%eax),%eax
    6fee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6ff1:	c1 e2 02             	shl    $0x2,%edx
    6ff4:	01 d0                	add    %edx,%eax
    6ff6:	8b 00                	mov    (%eax),%eax
    6ff8:	89 c1                	mov    %eax,%ecx
    6ffa:	8b 45 10             	mov    0x10(%ebp),%eax
    6ffd:	8b 00                	mov    (%eax),%eax
    6fff:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7002:	c1 e2 02             	shl    $0x2,%edx
    7005:	01 d0                	add    %edx,%eax
    7007:	8b 00                	mov    (%eax),%eax
    7009:	51                   	push   %ecx
    700a:	50                   	push   %eax
    700b:	ff 75 08             	pushl  0x8(%ebp)
    700e:	e8 60 cc ff ff       	call   3c73 <writeBitsReversed>
    7013:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    7016:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    701d:	0f 86 bf 00 00 00    	jbe    70e2 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    7023:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7026:	2d 01 01 00 00       	sub    $0x101,%eax
    702b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    702e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7031:	8b 04 85 c0 a0 01 00 	mov    0x1a0c0(,%eax,4),%eax
    7038:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    703b:	8b 45 0c             	mov    0xc(%ebp),%eax
    703e:	8b 00                	mov    (%eax),%eax
    7040:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7044:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7047:	c1 e2 02             	shl    $0x2,%edx
    704a:	01 d0                	add    %edx,%eax
    704c:	8b 00                	mov    (%eax),%eax
    704e:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    7051:	8b 45 0c             	mov    0xc(%ebp),%eax
    7054:	8b 00                	mov    (%eax),%eax
    7056:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    705a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    705d:	c1 e2 02             	shl    $0x2,%edx
    7060:	01 d0                	add    %edx,%eax
    7062:	8b 00                	mov    (%eax),%eax
    7064:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    7067:	8b 45 e8             	mov    -0x18(%ebp),%eax
    706a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    706d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7070:	8b 04 85 c0 a1 01 00 	mov    0x1a1c0(,%eax,4),%eax
    7077:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    707a:	8b 45 0c             	mov    0xc(%ebp),%eax
    707d:	8b 00                	mov    (%eax),%eax
    707f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7083:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7086:	c1 e2 02             	shl    $0x2,%edx
    7089:	01 d0                	add    %edx,%eax
    708b:	8b 00                	mov    (%eax),%eax
    708d:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    7090:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7093:	50                   	push   %eax
    7094:	ff 75 ec             	pushl  -0x14(%ebp)
    7097:	ff 75 08             	pushl  0x8(%ebp)
    709a:	e8 40 ca ff ff       	call   3adf <writeBits>
    709f:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    70a2:	8b 45 14             	mov    0x14(%ebp),%eax
    70a5:	8b 40 04             	mov    0x4(%eax),%eax
    70a8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    70ab:	c1 e2 02             	shl    $0x2,%edx
    70ae:	01 d0                	add    %edx,%eax
    70b0:	8b 00                	mov    (%eax),%eax
    70b2:	89 c1                	mov    %eax,%ecx
    70b4:	8b 45 14             	mov    0x14(%ebp),%eax
    70b7:	8b 00                	mov    (%eax),%eax
    70b9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    70bc:	c1 e2 02             	shl    $0x2,%edx
    70bf:	01 d0                	add    %edx,%eax
    70c1:	8b 00                	mov    (%eax),%eax
    70c3:	51                   	push   %ecx
    70c4:	50                   	push   %eax
    70c5:	ff 75 08             	pushl  0x8(%ebp)
    70c8:	e8 a6 cb ff ff       	call   3c73 <writeBitsReversed>
    70cd:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    70d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    70d3:	50                   	push   %eax
    70d4:	ff 75 dc             	pushl  -0x24(%ebp)
    70d7:	ff 75 08             	pushl  0x8(%ebp)
    70da:	e8 00 ca ff ff       	call   3adf <writeBits>
    70df:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    70e2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    70e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    70e9:	8b 40 04             	mov    0x4(%eax),%eax
    70ec:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    70ef:	0f 85 e1 fe ff ff    	jne    6fd6 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    70f5:	90                   	nop
    70f6:	c9                   	leave  
    70f7:	c3                   	ret    

000070f8 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    70f8:	55                   	push   %ebp
    70f9:	89 e5                	mov    %esp,%ebp
    70fb:	53                   	push   %ebx
    70fc:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    7102:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    7109:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    7110:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    7117:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    711e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    7125:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    712c:	8b 45 18             	mov    0x18(%ebp),%eax
    712f:	2b 45 14             	sub    0x14(%ebp),%eax
    7132:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    7135:	8b 45 20             	mov    0x20(%ebp),%eax
    7138:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    713b:	8d 45 90             	lea    -0x70(%ebp),%eax
    713e:	50                   	push   %eax
    713f:	e8 a4 c6 ff ff       	call   37e8 <uivector_init>
    7144:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    7147:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    714d:	50                   	push   %eax
    714e:	e8 98 d3 ff ff       	call   44eb <HuffmanTree_init>
    7153:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7156:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    715c:	50                   	push   %eax
    715d:	e8 89 d3 ff ff       	call   44eb <HuffmanTree_init>
    7162:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    7165:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    716b:	50                   	push   %eax
    716c:	e8 7a d3 ff ff       	call   44eb <HuffmanTree_init>
    7171:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    7174:	83 ec 0c             	sub    $0xc,%esp
    7177:	68 78 04 00 00       	push   $0x478
    717c:	e8 76 c4 ff ff       	call   35f7 <lodepng_malloc>
    7181:	83 c4 10             	add    $0x10,%esp
    7184:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    7187:	83 ec 0c             	sub    $0xc,%esp
    718a:	6a 78                	push   $0x78
    718c:	e8 66 c4 ff ff       	call   35f7 <lodepng_malloc>
    7191:	83 c4 10             	add    $0x10,%esp
    7194:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7197:	83 ec 0c             	sub    $0xc,%esp
    719a:	6a 4c                	push   $0x4c
    719c:	e8 56 c4 ff ff       	call   35f7 <lodepng_malloc>
    71a1:	83 c4 10             	add    $0x10,%esp
    71a4:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    71a7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    71ab:	74 0c                	je     71b9 <deflateDynamic+0xc1>
    71ad:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    71b1:	74 06                	je     71b9 <deflateDynamic+0xc1>
    71b3:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    71b7:	75 07                	jne    71c0 <deflateDynamic+0xc8>
    71b9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    71c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    71c4:	0f 85 f6 07 00 00    	jne    79c0 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    71ca:	83 ec 04             	sub    $0x4,%esp
    71cd:	68 78 04 00 00       	push   $0x478
    71d2:	6a 00                	push   $0x0
    71d4:	ff 75 d4             	pushl  -0x2c(%ebp)
    71d7:	e8 8c c4 ff ff       	call   3668 <lodepng_memset>
    71dc:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    71df:	83 ec 04             	sub    $0x4,%esp
    71e2:	6a 78                	push   $0x78
    71e4:	6a 00                	push   $0x0
    71e6:	ff 75 d0             	pushl  -0x30(%ebp)
    71e9:	e8 7a c4 ff ff       	call   3668 <lodepng_memset>
    71ee:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    71f1:	83 ec 04             	sub    $0x4,%esp
    71f4:	6a 4c                	push   $0x4c
    71f6:	6a 00                	push   $0x0
    71f8:	ff 75 cc             	pushl  -0x34(%ebp)
    71fb:	e8 68 c4 ff ff       	call   3668 <lodepng_memset>
    7200:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    7203:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7206:	8b 40 04             	mov    0x4(%eax),%eax
    7209:	85 c0                	test   %eax,%eax
    720b:	74 45                	je     7252 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    720d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7210:	8b 58 14             	mov    0x14(%eax),%ebx
    7213:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7216:	8b 48 10             	mov    0x10(%eax),%ecx
    7219:	8b 45 1c             	mov    0x1c(%ebp),%eax
    721c:	8b 50 0c             	mov    0xc(%eax),%edx
    721f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7222:	8b 40 08             	mov    0x8(%eax),%eax
    7225:	83 ec 0c             	sub    $0xc,%esp
    7228:	53                   	push   %ebx
    7229:	51                   	push   %ecx
    722a:	52                   	push   %edx
    722b:	50                   	push   %eax
    722c:	ff 75 18             	pushl  0x18(%ebp)
    722f:	ff 75 14             	pushl  0x14(%ebp)
    7232:	ff 75 10             	pushl  0x10(%ebp)
    7235:	ff 75 0c             	pushl  0xc(%ebp)
    7238:	8d 45 90             	lea    -0x70(%ebp),%eax
    723b:	50                   	push   %eax
    723c:	e8 bd f6 ff ff       	call   68fe <encodeLZ77>
    7241:	83 c4 30             	add    $0x30,%esp
    7244:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    7247:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    724b:	74 59                	je     72a6 <deflateDynamic+0x1ae>
    724d:	e9 6e 07 00 00       	jmp    79c0 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    7252:	83 ec 08             	sub    $0x8,%esp
    7255:	ff 75 c8             	pushl  -0x38(%ebp)
    7258:	8d 45 90             	lea    -0x70(%ebp),%eax
    725b:	50                   	push   %eax
    725c:	e8 17 c5 ff ff       	call   3778 <uivector_resize>
    7261:	83 c4 10             	add    $0x10,%esp
    7264:	85 c0                	test   %eax,%eax
    7266:	75 0c                	jne    7274 <deflateDynamic+0x17c>
    7268:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    726f:	e9 4c 07 00 00       	jmp    79c0 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    7274:	8b 45 14             	mov    0x14(%ebp),%eax
    7277:	89 45 e8             	mov    %eax,-0x18(%ebp)
    727a:	eb 22                	jmp    729e <deflateDynamic+0x1a6>
    727c:	8b 55 90             	mov    -0x70(%ebp),%edx
    727f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7282:	2b 45 14             	sub    0x14(%ebp),%eax
    7285:	c1 e0 02             	shl    $0x2,%eax
    7288:	01 c2                	add    %eax,%edx
    728a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    728d:	8b 45 10             	mov    0x10(%ebp),%eax
    7290:	01 c8                	add    %ecx,%eax
    7292:	0f b6 00             	movzbl (%eax),%eax
    7295:	0f b6 c0             	movzbl %al,%eax
    7298:	89 02                	mov    %eax,(%edx)
    729a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    729e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    72a1:	3b 45 18             	cmp    0x18(%ebp),%eax
    72a4:	7c d6                	jl     727c <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    72a6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    72ad:	eb 60                	jmp    730f <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    72af:	8b 45 90             	mov    -0x70(%ebp),%eax
    72b2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    72b5:	c1 e2 02             	shl    $0x2,%edx
    72b8:	01 d0                	add    %edx,%eax
    72ba:	8b 00                	mov    (%eax),%eax
    72bc:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    72bf:	8b 45 c0             	mov    -0x40(%ebp),%eax
    72c2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72c9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    72cc:	01 d0                	add    %edx,%eax
    72ce:	8b 10                	mov    (%eax),%edx
    72d0:	83 c2 01             	add    $0x1,%edx
    72d3:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    72d5:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    72dc:	76 2d                	jbe    730b <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    72de:	8b 45 90             	mov    -0x70(%ebp),%eax
    72e1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    72e4:	83 c2 02             	add    $0x2,%edx
    72e7:	c1 e2 02             	shl    $0x2,%edx
    72ea:	01 d0                	add    %edx,%eax
    72ec:	8b 00                	mov    (%eax),%eax
    72ee:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    72f1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    72f4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72fb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    72fe:	01 d0                	add    %edx,%eax
    7300:	8b 10                	mov    (%eax),%edx
    7302:	83 c2 01             	add    $0x1,%edx
    7305:	89 10                	mov    %edx,(%eax)
        i += 3;
    7307:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    730b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    730f:	8b 45 94             	mov    -0x6c(%ebp),%eax
    7312:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7315:	75 98                	jne    72af <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    7317:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    731a:	05 00 04 00 00       	add    $0x400,%eax
    731f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    7325:	83 ec 0c             	sub    $0xc,%esp
    7328:	6a 0f                	push   $0xf
    732a:	68 1e 01 00 00       	push   $0x11e
    732f:	68 01 01 00 00       	push   $0x101
    7334:	ff 75 d4             	pushl  -0x2c(%ebp)
    7337:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    733d:	50                   	push   %eax
    733e:	e8 e0 e1 ff ff       	call   5523 <HuffmanTree_makeFromFrequencies>
    7343:	83 c4 20             	add    $0x20,%esp
    7346:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7349:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    734d:	0f 85 66 06 00 00    	jne    79b9 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7353:	83 ec 0c             	sub    $0xc,%esp
    7356:	6a 0f                	push   $0xf
    7358:	6a 1e                	push   $0x1e
    735a:	6a 02                	push   $0x2
    735c:	ff 75 d0             	pushl  -0x30(%ebp)
    735f:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7365:	50                   	push   %eax
    7366:	e8 b8 e1 ff ff       	call   5523 <HuffmanTree_makeFromFrequencies>
    736b:	83 c4 20             	add    $0x20,%esp
    736e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7371:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7375:	0f 85 41 06 00 00    	jne    79bc <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    737b:	8b 45 84             	mov    -0x7c(%ebp),%eax
    737e:	ba 1e 01 00 00       	mov    $0x11e,%edx
    7383:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    7388:	0f 47 c2             	cmova  %edx,%eax
    738b:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    738e:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    7394:	ba 1e 00 00 00       	mov    $0x1e,%edx
    7399:	83 f8 1e             	cmp    $0x1e,%eax
    739c:	0f 47 c2             	cmova  %edx,%eax
    739f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    73a2:	8b 55 b8             	mov    -0x48(%ebp),%edx
    73a5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    73a8:	01 d0                	add    %edx,%eax
    73aa:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    73ad:	8b 45 b0             	mov    -0x50(%ebp),%eax
    73b0:	c1 e0 02             	shl    $0x2,%eax
    73b3:	83 ec 0c             	sub    $0xc,%esp
    73b6:	50                   	push   %eax
    73b7:	e8 3b c2 ff ff       	call   35f7 <lodepng_malloc>
    73bc:	83 c4 10             	add    $0x10,%esp
    73bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    73c2:	8b 45 b0             	mov    -0x50(%ebp),%eax
    73c5:	c1 e0 02             	shl    $0x2,%eax
    73c8:	83 ec 0c             	sub    $0xc,%esp
    73cb:	50                   	push   %eax
    73cc:	e8 26 c2 ff ff       	call   35f7 <lodepng_malloc>
    73d1:	83 c4 10             	add    $0x10,%esp
    73d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    73d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    73db:	74 06                	je     73e3 <deflateDynamic+0x2eb>
    73dd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    73e1:	75 0c                	jne    73ef <deflateDynamic+0x2f7>
    73e3:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    73ea:	e9 d1 05 00 00       	jmp    79c0 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    73ef:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    73f6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    73fd:	eb 25                	jmp    7424 <deflateDynamic+0x32c>
    73ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7402:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7409:	8b 45 f0             	mov    -0x10(%ebp),%eax
    740c:	01 c2                	add    %eax,%edx
    740e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7414:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7417:	c1 e1 02             	shl    $0x2,%ecx
    741a:	01 c8                	add    %ecx,%eax
    741c:	8b 00                	mov    (%eax),%eax
    741e:	89 02                	mov    %eax,(%edx)
    7420:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7424:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7427:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    742a:	75 d3                	jne    73ff <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    742c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7433:	eb 2a                	jmp    745f <deflateDynamic+0x367>
    7435:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7438:	8b 45 e8             	mov    -0x18(%ebp),%eax
    743b:	01 d0                	add    %edx,%eax
    743d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7444:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7447:	01 c2                	add    %eax,%edx
    7449:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    744f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7452:	c1 e1 02             	shl    $0x2,%ecx
    7455:	01 c8                	add    %ecx,%eax
    7457:	8b 00                	mov    (%eax),%eax
    7459:	89 02                	mov    %eax,(%edx)
    745b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    745f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7462:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7465:	75 ce                	jne    7435 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7467:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    746e:	e9 3b 02 00 00       	jmp    76ae <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    7473:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    747a:	eb 04                	jmp    7480 <deflateDynamic+0x388>
    747c:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    7480:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7483:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7486:	01 d0                	add    %edx,%eax
    7488:	8d 50 01             	lea    0x1(%eax),%edx
    748b:	8b 45 b0             	mov    -0x50(%ebp),%eax
    748e:	39 c2                	cmp    %eax,%edx
    7490:	73 2e                	jae    74c0 <deflateDynamic+0x3c8>
    7492:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7495:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7498:	01 d0                	add    %edx,%eax
    749a:	83 c0 01             	add    $0x1,%eax
    749d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74a7:	01 d0                	add    %edx,%eax
    74a9:	8b 10                	mov    (%eax),%edx
    74ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74ae:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    74b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74b8:	01 c8                	add    %ecx,%eax
    74ba:	8b 00                	mov    (%eax),%eax
    74bc:	39 c2                	cmp    %eax,%edx
    74be:	74 bc                	je     747c <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    74c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74c3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74cd:	01 d0                	add    %edx,%eax
    74cf:	8b 00                	mov    (%eax),%eax
    74d1:	85 c0                	test   %eax,%eax
    74d3:	0f 85 a9 00 00 00    	jne    7582 <deflateDynamic+0x48a>
    74d9:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    74dd:	0f 86 9f 00 00 00    	jbe    7582 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    74e3:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    74e7:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    74eb:	77 3a                	ja     7527 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    74ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74f0:	8d 50 01             	lea    0x1(%eax),%edx
    74f3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    74f6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7500:	01 d0                	add    %edx,%eax
    7502:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    7508:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    750b:	8d 50 01             	lea    0x1(%eax),%edx
    750e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7511:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7518:	8b 45 ec             	mov    -0x14(%ebp),%eax
    751b:	01 d0                	add    %edx,%eax
    751d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7520:	83 ea 03             	sub    $0x3,%edx
    7523:	89 10                	mov    %edx,(%eax)
    7525:	eb 48                	jmp    756f <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7527:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    752e:	76 07                	jbe    7537 <deflateDynamic+0x43f>
    7530:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7537:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    753a:	8d 50 01             	lea    0x1(%eax),%edx
    753d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7540:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7547:	8b 45 ec             	mov    -0x14(%ebp),%eax
    754a:	01 d0                	add    %edx,%eax
    754c:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    7552:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7555:	8d 50 01             	lea    0x1(%eax),%edx
    7558:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    755b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7562:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7565:	01 d0                	add    %edx,%eax
    7567:	8b 55 dc             	mov    -0x24(%ebp),%edx
    756a:	83 ea 0b             	sub    $0xb,%edx
    756d:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    756f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7572:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7575:	01 d0                	add    %edx,%eax
    7577:	83 e8 01             	sub    $0x1,%eax
    757a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    757d:	e9 28 01 00 00       	jmp    76aa <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    7582:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    7586:	0f 86 f6 00 00 00    	jbe    7682 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    758c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    758f:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7594:	f7 e2                	mul    %edx
    7596:	89 d0                	mov    %edx,%eax
    7598:	c1 e8 02             	shr    $0x2,%eax
    759b:	89 45 ac             	mov    %eax,-0x54(%ebp)
    759e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    75a1:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    75a6:	89 c8                	mov    %ecx,%eax
    75a8:	f7 e2                	mul    %edx
    75aa:	c1 ea 02             	shr    $0x2,%edx
    75ad:	89 d0                	mov    %edx,%eax
    75af:	01 c0                	add    %eax,%eax
    75b1:	01 d0                	add    %edx,%eax
    75b3:	01 c0                	add    %eax,%eax
    75b5:	29 c1                	sub    %eax,%ecx
    75b7:	89 c8                	mov    %ecx,%eax
    75b9:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    75bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    75bf:	8d 50 01             	lea    0x1(%eax),%edx
    75c2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    75c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75cf:	01 c2                	add    %eax,%edx
    75d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75d4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    75db:	8b 45 f0             	mov    -0x10(%ebp),%eax
    75de:	01 c8                	add    %ecx,%eax
    75e0:	8b 00                	mov    (%eax),%eax
    75e2:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    75e4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    75eb:	eb 3a                	jmp    7627 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    75ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    75f0:	8d 50 01             	lea    0x1(%eax),%edx
    75f3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    75f6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7600:	01 d0                	add    %edx,%eax
    7602:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    7608:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    760b:	8d 50 01             	lea    0x1(%eax),%edx
    760e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7611:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7618:	8b 45 ec             	mov    -0x14(%ebp),%eax
    761b:	01 d0                	add    %edx,%eax
    761d:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    7623:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7627:	8b 45 d8             	mov    -0x28(%ebp),%eax
    762a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    762d:	72 be                	jb     75ed <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    762f:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    7633:	76 3a                	jbe    766f <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7635:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7638:	8d 50 01             	lea    0x1(%eax),%edx
    763b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    763e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7645:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7648:	01 d0                	add    %edx,%eax
    764a:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    7650:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7653:	8d 50 01             	lea    0x1(%eax),%edx
    7656:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7659:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7660:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7663:	01 d0                	add    %edx,%eax
    7665:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7668:	83 ea 03             	sub    $0x3,%edx
    766b:	89 10                	mov    %edx,(%eax)
    766d:	eb 06                	jmp    7675 <deflateDynamic+0x57d>
        }
        else j -= rest;
    766f:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7672:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7675:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7678:	8b 45 dc             	mov    -0x24(%ebp),%eax
    767b:	01 d0                	add    %edx,%eax
    767d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7680:	eb 28                	jmp    76aa <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7682:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7685:	8d 50 01             	lea    0x1(%eax),%edx
    7688:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    768b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7692:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7695:	01 c2                	add    %eax,%edx
    7697:	8b 45 e8             	mov    -0x18(%ebp),%eax
    769a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    76a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    76a4:	01 c8                	add    %ecx,%eax
    76a6:	8b 00                	mov    (%eax),%eax
    76a8:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    76aa:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76b1:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    76b4:	0f 85 b9 fd ff ff    	jne    7473 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    76ba:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    76c1:	eb 42                	jmp    7705 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    76c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76c6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76d0:	01 d0                	add    %edx,%eax
    76d2:	8b 00                	mov    (%eax),%eax
    76d4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76db:	8b 45 cc             	mov    -0x34(%ebp),%eax
    76de:	01 d0                	add    %edx,%eax
    76e0:	8b 10                	mov    (%eax),%edx
    76e2:	83 c2 01             	add    $0x1,%edx
    76e5:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    76e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76f4:	01 d0                	add    %edx,%eax
    76f6:	8b 00                	mov    (%eax),%eax
    76f8:	83 f8 0f             	cmp    $0xf,%eax
    76fb:	76 04                	jbe    7701 <deflateDynamic+0x609>
    76fd:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7701:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7705:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7708:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    770b:	75 b6                	jne    76c3 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    770d:	83 ec 0c             	sub    $0xc,%esp
    7710:	6a 07                	push   $0x7
    7712:	6a 13                	push   $0x13
    7714:	6a 13                	push   $0x13
    7716:	ff 75 cc             	pushl  -0x34(%ebp)
    7719:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    771f:	50                   	push   %eax
    7720:	e8 fe dd ff ff       	call   5523 <HuffmanTree_makeFromFrequencies>
    7725:	83 c4 20             	add    $0x20,%esp
    7728:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    772b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    772f:	0f 85 8a 02 00 00    	jne    79bf <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7735:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    773c:	eb 04                	jmp    7742 <deflateDynamic+0x64a>
      numcodes_cl--;
    773e:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7742:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7745:	83 f8 04             	cmp    $0x4,%eax
    7748:	76 1e                	jbe    7768 <deflateDynamic+0x670>
    774a:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7750:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7753:	83 ea 01             	sub    $0x1,%edx
    7756:	8b 14 95 40 a2 01 00 	mov    0x1a240(,%edx,4),%edx
    775d:	c1 e2 02             	shl    $0x2,%edx
    7760:	01 d0                	add    %edx,%eax
    7762:	8b 00                	mov    (%eax),%eax
    7764:	85 c0                	test   %eax,%eax
    7766:	74 d6                	je     773e <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7768:	83 ec 04             	sub    $0x4,%esp
    776b:	6a 01                	push   $0x1
    776d:	ff 75 c4             	pushl  -0x3c(%ebp)
    7770:	ff 75 08             	pushl  0x8(%ebp)
    7773:	e8 67 c3 ff ff       	call   3adf <writeBits>
    7778:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    777b:	83 ec 04             	sub    $0x4,%esp
    777e:	6a 01                	push   $0x1
    7780:	6a 00                	push   $0x0
    7782:	ff 75 08             	pushl  0x8(%ebp)
    7785:	e8 55 c3 ff ff       	call   3adf <writeBits>
    778a:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    778d:	83 ec 04             	sub    $0x4,%esp
    7790:	6a 01                	push   $0x1
    7792:	6a 01                	push   $0x1
    7794:	ff 75 08             	pushl  0x8(%ebp)
    7797:	e8 43 c3 ff ff       	call   3adf <writeBits>
    779c:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    779f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    77a2:	2d 01 01 00 00       	sub    $0x101,%eax
    77a7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    77aa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    77ad:	83 e8 01             	sub    $0x1,%eax
    77b0:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    77b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    77b6:	83 e8 04             	sub    $0x4,%eax
    77b9:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    77bc:	83 ec 04             	sub    $0x4,%esp
    77bf:	6a 05                	push   $0x5
    77c1:	ff 75 a4             	pushl  -0x5c(%ebp)
    77c4:	ff 75 08             	pushl  0x8(%ebp)
    77c7:	e8 13 c3 ff ff       	call   3adf <writeBits>
    77cc:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    77cf:	83 ec 04             	sub    $0x4,%esp
    77d2:	6a 05                	push   $0x5
    77d4:	ff 75 a0             	pushl  -0x60(%ebp)
    77d7:	ff 75 08             	pushl  0x8(%ebp)
    77da:	e8 00 c3 ff ff       	call   3adf <writeBits>
    77df:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    77e2:	83 ec 04             	sub    $0x4,%esp
    77e5:	6a 04                	push   $0x4
    77e7:	ff 75 9c             	pushl  -0x64(%ebp)
    77ea:	ff 75 08             	pushl  0x8(%ebp)
    77ed:	e8 ed c2 ff ff       	call   3adf <writeBits>
    77f2:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    77f5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    77fc:	eb 2c                	jmp    782a <deflateDynamic+0x732>
    77fe:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    7804:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7807:	8b 04 85 40 a2 01 00 	mov    0x1a240(,%eax,4),%eax
    780e:	c1 e0 02             	shl    $0x2,%eax
    7811:	01 d0                	add    %edx,%eax
    7813:	8b 00                	mov    (%eax),%eax
    7815:	83 ec 04             	sub    $0x4,%esp
    7818:	6a 03                	push   $0x3
    781a:	50                   	push   %eax
    781b:	ff 75 08             	pushl  0x8(%ebp)
    781e:	e8 bc c2 ff ff       	call   3adf <writeBits>
    7823:	83 c4 10             	add    $0x10,%esp
    7826:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    782a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    782d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    7830:	75 cc                	jne    77fe <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7832:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7839:	e9 0a 01 00 00       	jmp    7948 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    783e:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7844:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7847:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    784e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7851:	01 ca                	add    %ecx,%edx
    7853:	8b 12                	mov    (%edx),%edx
    7855:	c1 e2 02             	shl    $0x2,%edx
    7858:	01 d0                	add    %edx,%eax
    785a:	8b 00                	mov    (%eax),%eax
    785c:	89 c3                	mov    %eax,%ebx
    785e:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7864:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7867:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    786e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7871:	01 ca                	add    %ecx,%edx
    7873:	8b 12                	mov    (%edx),%edx
    7875:	c1 e2 02             	shl    $0x2,%edx
    7878:	01 d0                	add    %edx,%eax
    787a:	8b 00                	mov    (%eax),%eax
    787c:	83 ec 04             	sub    $0x4,%esp
    787f:	53                   	push   %ebx
    7880:	50                   	push   %eax
    7881:	ff 75 08             	pushl  0x8(%ebp)
    7884:	e8 ea c3 ff ff       	call   3c73 <writeBitsReversed>
    7889:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    788c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    788f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7896:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7899:	01 d0                	add    %edx,%eax
    789b:	8b 00                	mov    (%eax),%eax
    789d:	83 f8 10             	cmp    $0x10,%eax
    78a0:	75 28                	jne    78ca <deflateDynamic+0x7d2>
    78a2:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    78a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78b3:	01 d0                	add    %edx,%eax
    78b5:	8b 00                	mov    (%eax),%eax
    78b7:	83 ec 04             	sub    $0x4,%esp
    78ba:	6a 02                	push   $0x2
    78bc:	50                   	push   %eax
    78bd:	ff 75 08             	pushl  0x8(%ebp)
    78c0:	e8 1a c2 ff ff       	call   3adf <writeBits>
    78c5:	83 c4 10             	add    $0x10,%esp
    78c8:	eb 7a                	jmp    7944 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    78ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78cd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78d7:	01 d0                	add    %edx,%eax
    78d9:	8b 00                	mov    (%eax),%eax
    78db:	83 f8 11             	cmp    $0x11,%eax
    78de:	75 28                	jne    7908 <deflateDynamic+0x810>
    78e0:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    78e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78f1:	01 d0                	add    %edx,%eax
    78f3:	8b 00                	mov    (%eax),%eax
    78f5:	83 ec 04             	sub    $0x4,%esp
    78f8:	6a 03                	push   $0x3
    78fa:	50                   	push   %eax
    78fb:	ff 75 08             	pushl  0x8(%ebp)
    78fe:	e8 dc c1 ff ff       	call   3adf <writeBits>
    7903:	83 c4 10             	add    $0x10,%esp
    7906:	eb 3c                	jmp    7944 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    7908:	8b 45 e8             	mov    -0x18(%ebp),%eax
    790b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7912:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7915:	01 d0                	add    %edx,%eax
    7917:	8b 00                	mov    (%eax),%eax
    7919:	83 f8 12             	cmp    $0x12,%eax
    791c:	75 26                	jne    7944 <deflateDynamic+0x84c>
    791e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7922:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7925:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    792c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    792f:	01 d0                	add    %edx,%eax
    7931:	8b 00                	mov    (%eax),%eax
    7933:	83 ec 04             	sub    $0x4,%esp
    7936:	6a 07                	push   $0x7
    7938:	50                   	push   %eax
    7939:	ff 75 08             	pushl  0x8(%ebp)
    793c:	e8 9e c1 ff ff       	call   3adf <writeBits>
    7941:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7944:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7948:	8b 45 e8             	mov    -0x18(%ebp),%eax
    794b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    794e:	0f 85 ea fe ff ff    	jne    783e <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7954:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    795a:	50                   	push   %eax
    795b:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7961:	50                   	push   %eax
    7962:	8d 45 90             	lea    -0x70(%ebp),%eax
    7965:	50                   	push   %eax
    7966:	ff 75 08             	pushl  0x8(%ebp)
    7969:	e8 4f f6 ff ff       	call   6fbd <writeLZ77data>
    796e:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    7971:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7977:	05 00 04 00 00       	add    $0x400,%eax
    797c:	8b 00                	mov    (%eax),%eax
    797e:	85 c0                	test   %eax,%eax
    7980:	75 09                	jne    798b <deflateDynamic+0x893>
    7982:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7989:	eb 35                	jmp    79c0 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    798b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7991:	05 00 04 00 00       	add    $0x400,%eax
    7996:	8b 00                	mov    (%eax),%eax
    7998:	89 c2                	mov    %eax,%edx
    799a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    79a0:	05 00 04 00 00       	add    $0x400,%eax
    79a5:	8b 00                	mov    (%eax),%eax
    79a7:	83 ec 04             	sub    $0x4,%esp
    79aa:	52                   	push   %edx
    79ab:	50                   	push   %eax
    79ac:	ff 75 08             	pushl  0x8(%ebp)
    79af:	e8 bf c2 ff ff       	call   3c73 <writeBitsReversed>
    79b4:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    79b7:	eb 07                	jmp    79c0 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    79b9:	90                   	nop
    79ba:	eb 04                	jmp    79c0 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    79bc:	90                   	nop
    79bd:	eb 01                	jmp    79c0 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    79bf:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    79c0:	83 ec 0c             	sub    $0xc,%esp
    79c3:	8d 45 90             	lea    -0x70(%ebp),%eax
    79c6:	50                   	push   %eax
    79c7:	e8 73 bd ff ff       	call   373f <uivector_cleanup>
    79cc:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    79cf:	83 ec 0c             	sub    $0xc,%esp
    79d2:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    79d8:	50                   	push   %eax
    79d9:	e8 3a cb ff ff       	call   4518 <HuffmanTree_cleanup>
    79de:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    79e1:	83 ec 0c             	sub    $0xc,%esp
    79e4:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    79ea:	50                   	push   %eax
    79eb:	e8 28 cb ff ff       	call   4518 <HuffmanTree_cleanup>
    79f0:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    79f3:	83 ec 0c             	sub    $0xc,%esp
    79f6:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    79fc:	50                   	push   %eax
    79fd:	e8 16 cb ff ff       	call   4518 <HuffmanTree_cleanup>
    7a02:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    7a05:	83 ec 0c             	sub    $0xc,%esp
    7a08:	ff 75 d4             	pushl  -0x2c(%ebp)
    7a0b:	e8 08 bc ff ff       	call   3618 <lodepng_free>
    7a10:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    7a13:	83 ec 0c             	sub    $0xc,%esp
    7a16:	ff 75 d0             	pushl  -0x30(%ebp)
    7a19:	e8 fa bb ff ff       	call   3618 <lodepng_free>
    7a1e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    7a21:	83 ec 0c             	sub    $0xc,%esp
    7a24:	ff 75 cc             	pushl  -0x34(%ebp)
    7a27:	e8 ec bb ff ff       	call   3618 <lodepng_free>
    7a2c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    7a2f:	83 ec 0c             	sub    $0xc,%esp
    7a32:	ff 75 f0             	pushl  -0x10(%ebp)
    7a35:	e8 de bb ff ff       	call   3618 <lodepng_free>
    7a3a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7a3d:	83 ec 0c             	sub    $0xc,%esp
    7a40:	ff 75 ec             	pushl  -0x14(%ebp)
    7a43:	e8 d0 bb ff ff       	call   3618 <lodepng_free>
    7a48:	83 c4 10             	add    $0x10,%esp

  return error;
    7a4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7a4e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7a51:	c9                   	leave  
    7a52:	c3                   	ret    

00007a53 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    7a53:	55                   	push   %ebp
    7a54:	89 e5                	mov    %esp,%ebp
    7a56:	53                   	push   %ebx
    7a57:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7a5a:	8b 45 20             	mov    0x20(%ebp),%eax
    7a5d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    7a60:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7a67:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7a6a:	50                   	push   %eax
    7a6b:	e8 7b ca ff ff       	call   44eb <HuffmanTree_init>
    7a70:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7a73:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a76:	50                   	push   %eax
    7a77:	e8 6f ca ff ff       	call   44eb <HuffmanTree_init>
    7a7c:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    7a7f:	83 ec 0c             	sub    $0xc,%esp
    7a82:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7a85:	50                   	push   %eax
    7a86:	e8 41 db ff ff       	call   55cc <generateFixedLitLenTree>
    7a8b:	83 c4 10             	add    $0x10,%esp
    7a8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    7a91:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a95:	75 12                	jne    7aa9 <deflateFixed+0x56>
    7a97:	83 ec 0c             	sub    $0xc,%esp
    7a9a:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a9d:	50                   	push   %eax
    7a9e:	e8 30 dc ff ff       	call   56d3 <generateFixedDistanceTree>
    7aa3:	83 c4 10             	add    $0x10,%esp
    7aa6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7aa9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7aad:	0f 85 3a 01 00 00    	jne    7bed <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    7ab3:	83 ec 04             	sub    $0x4,%esp
    7ab6:	6a 01                	push   $0x1
    7ab8:	ff 75 ec             	pushl  -0x14(%ebp)
    7abb:	ff 75 08             	pushl  0x8(%ebp)
    7abe:	e8 1c c0 ff ff       	call   3adf <writeBits>
    7ac3:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    7ac6:	83 ec 04             	sub    $0x4,%esp
    7ac9:	6a 01                	push   $0x1
    7acb:	6a 01                	push   $0x1
    7acd:	ff 75 08             	pushl  0x8(%ebp)
    7ad0:	e8 0a c0 ff ff       	call   3adf <writeBits>
    7ad5:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7ad8:	83 ec 04             	sub    $0x4,%esp
    7adb:	6a 01                	push   $0x1
    7add:	6a 00                	push   $0x0
    7adf:	ff 75 08             	pushl  0x8(%ebp)
    7ae2:	e8 f8 bf ff ff       	call   3adf <writeBits>
    7ae7:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7aea:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7aed:	8b 40 04             	mov    0x4(%eax),%eax
    7af0:	85 c0                	test   %eax,%eax
    7af2:	74 77                	je     7b6b <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7af4:	83 ec 0c             	sub    $0xc,%esp
    7af7:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7afa:	50                   	push   %eax
    7afb:	e8 e8 bc ff ff       	call   37e8 <uivector_init>
    7b00:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7b03:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7b06:	8b 58 14             	mov    0x14(%eax),%ebx
    7b09:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7b0c:	8b 48 10             	mov    0x10(%eax),%ecx
    7b0f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7b12:	8b 50 0c             	mov    0xc(%eax),%edx
    7b15:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7b18:	8b 40 08             	mov    0x8(%eax),%eax
    7b1b:	83 ec 0c             	sub    $0xc,%esp
    7b1e:	53                   	push   %ebx
    7b1f:	51                   	push   %ecx
    7b20:	52                   	push   %edx
    7b21:	50                   	push   %eax
    7b22:	ff 75 18             	pushl  0x18(%ebp)
    7b25:	ff 75 14             	pushl  0x14(%ebp)
    7b28:	ff 75 10             	pushl  0x10(%ebp)
    7b2b:	ff 75 0c             	pushl  0xc(%ebp)
    7b2e:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7b31:	50                   	push   %eax
    7b32:	e8 c7 ed ff ff       	call   68fe <encodeLZ77>
    7b37:	83 c4 30             	add    $0x30,%esp
    7b3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7b3d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b41:	75 17                	jne    7b5a <deflateFixed+0x107>
    7b43:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b46:	50                   	push   %eax
    7b47:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7b4a:	50                   	push   %eax
    7b4b:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7b4e:	50                   	push   %eax
    7b4f:	ff 75 08             	pushl  0x8(%ebp)
    7b52:	e8 66 f4 ff ff       	call   6fbd <writeLZ77data>
    7b57:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7b5a:	83 ec 0c             	sub    $0xc,%esp
    7b5d:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7b60:	50                   	push   %eax
    7b61:	e8 d9 bb ff ff       	call   373f <uivector_cleanup>
    7b66:	83 c4 10             	add    $0x10,%esp
    7b69:	eb 56                	jmp    7bc1 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7b6b:	8b 45 14             	mov    0x14(%ebp),%eax
    7b6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7b71:	eb 46                	jmp    7bb9 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    7b73:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7b76:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7b79:	8b 55 10             	mov    0x10(%ebp),%edx
    7b7c:	01 ca                	add    %ecx,%edx
    7b7e:	0f b6 12             	movzbl (%edx),%edx
    7b81:	0f b6 d2             	movzbl %dl,%edx
    7b84:	c1 e2 02             	shl    $0x2,%edx
    7b87:	01 d0                	add    %edx,%eax
    7b89:	8b 00                	mov    (%eax),%eax
    7b8b:	89 c3                	mov    %eax,%ebx
    7b8d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7b90:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7b93:	8b 55 10             	mov    0x10(%ebp),%edx
    7b96:	01 ca                	add    %ecx,%edx
    7b98:	0f b6 12             	movzbl (%edx),%edx
    7b9b:	0f b6 d2             	movzbl %dl,%edx
    7b9e:	c1 e2 02             	shl    $0x2,%edx
    7ba1:	01 d0                	add    %edx,%eax
    7ba3:	8b 00                	mov    (%eax),%eax
    7ba5:	83 ec 04             	sub    $0x4,%esp
    7ba8:	53                   	push   %ebx
    7ba9:	50                   	push   %eax
    7baa:	ff 75 08             	pushl  0x8(%ebp)
    7bad:	e8 c1 c0 ff ff       	call   3c73 <writeBitsReversed>
    7bb2:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7bb5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7bb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7bbc:	3b 45 18             	cmp    0x18(%ebp),%eax
    7bbf:	7c b2                	jl     7b73 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    7bc1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7bc5:	75 26                	jne    7bed <deflateFixed+0x19a>
    7bc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7bca:	05 00 04 00 00       	add    $0x400,%eax
    7bcf:	8b 00                	mov    (%eax),%eax
    7bd1:	89 c2                	mov    %eax,%edx
    7bd3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7bd6:	05 00 04 00 00       	add    $0x400,%eax
    7bdb:	8b 00                	mov    (%eax),%eax
    7bdd:	83 ec 04             	sub    $0x4,%esp
    7be0:	52                   	push   %edx
    7be1:	50                   	push   %eax
    7be2:	ff 75 08             	pushl  0x8(%ebp)
    7be5:	e8 89 c0 ff ff       	call   3c73 <writeBitsReversed>
    7bea:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    7bed:	83 ec 0c             	sub    $0xc,%esp
    7bf0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7bf3:	50                   	push   %eax
    7bf4:	e8 1f c9 ff ff       	call   4518 <HuffmanTree_cleanup>
    7bf9:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7bfc:	83 ec 0c             	sub    $0xc,%esp
    7bff:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7c02:	50                   	push   %eax
    7c03:	e8 10 c9 ff ff       	call   4518 <HuffmanTree_cleanup>
    7c08:	83 c4 10             	add    $0x10,%esp

  return error;
    7c0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7c0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7c11:	c9                   	leave  
    7c12:	c3                   	ret    

00007c13 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    7c13:	55                   	push   %ebp
    7c14:	89 e5                	mov    %esp,%ebp
    7c16:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7c19:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    7c20:	ff 75 08             	pushl  0x8(%ebp)
    7c23:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7c26:	50                   	push   %eax
    7c27:	e8 9e be ff ff       	call   3aca <LodePNGBitWriter_init>
    7c2c:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    7c2f:	8b 45 14             	mov    0x14(%ebp),%eax
    7c32:	8b 00                	mov    (%eax),%eax
    7c34:	83 f8 02             	cmp    $0x2,%eax
    7c37:	76 0a                	jbe    7c43 <lodepng_deflatev+0x30>
    7c39:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7c3e:	e9 68 01 00 00       	jmp    7dab <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7c43:	8b 45 14             	mov    0x14(%ebp),%eax
    7c46:	8b 00                	mov    (%eax),%eax
    7c48:	85 c0                	test   %eax,%eax
    7c4a:	75 16                	jne    7c62 <lodepng_deflatev+0x4f>
    7c4c:	ff 75 10             	pushl  0x10(%ebp)
    7c4f:	ff 75 0c             	pushl  0xc(%ebp)
    7c52:	ff 75 08             	pushl  0x8(%ebp)
    7c55:	e8 01 f2 ff ff       	call   6e5b <deflateNoCompression>
    7c5a:	83 c4 0c             	add    $0xc,%esp
    7c5d:	e9 49 01 00 00       	jmp    7dab <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7c62:	8b 45 14             	mov    0x14(%ebp),%eax
    7c65:	8b 00                	mov    (%eax),%eax
    7c67:	83 f8 01             	cmp    $0x1,%eax
    7c6a:	75 08                	jne    7c74 <lodepng_deflatev+0x61>
    7c6c:	8b 45 10             	mov    0x10(%ebp),%eax
    7c6f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7c72:	eb 2c                	jmp    7ca0 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7c74:	8b 45 10             	mov    0x10(%ebp),%eax
    7c77:	c1 e8 03             	shr    $0x3,%eax
    7c7a:	83 c0 08             	add    $0x8,%eax
    7c7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7c80:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    7c87:	7f 07                	jg     7c90 <lodepng_deflatev+0x7d>
    7c89:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7c90:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    7c97:	7e 07                	jle    7ca0 <lodepng_deflatev+0x8d>
    7c99:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7ca0:	8b 55 10             	mov    0x10(%ebp),%edx
    7ca3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7ca6:	01 d0                	add    %edx,%eax
    7ca8:	83 e8 01             	sub    $0x1,%eax
    7cab:	99                   	cltd   
    7cac:	f7 7d ec             	idivl  -0x14(%ebp)
    7caf:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7cb2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7cb6:	75 07                	jne    7cbf <lodepng_deflatev+0xac>
    7cb8:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7cbf:	8b 45 14             	mov    0x14(%ebp),%eax
    7cc2:	8b 40 08             	mov    0x8(%eax),%eax
    7cc5:	83 ec 08             	sub    $0x8,%esp
    7cc8:	50                   	push   %eax
    7cc9:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7ccc:	50                   	push   %eax
    7ccd:	e8 1c e8 ff ff       	call   64ee <hash_init>
    7cd2:	83 c4 10             	add    $0x10,%esp
    7cd5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7cd8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7cdc:	0f 85 b7 00 00 00    	jne    7d99 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7ce2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7ce9:	e9 99 00 00 00       	jmp    7d87 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7cee:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7cf1:	83 e8 01             	sub    $0x1,%eax
    7cf4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7cf7:	0f 94 c0             	sete   %al
    7cfa:	0f b6 c0             	movzbl %al,%eax
    7cfd:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7d00:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7d03:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7d07:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7d0a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7d0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7d10:	01 d0                	add    %edx,%eax
    7d12:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7d15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7d18:	3b 45 10             	cmp    0x10(%ebp),%eax
    7d1b:	7e 06                	jle    7d23 <lodepng_deflatev+0x110>
    7d1d:	8b 45 10             	mov    0x10(%ebp),%eax
    7d20:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7d23:	8b 45 14             	mov    0x14(%ebp),%eax
    7d26:	8b 00                	mov    (%eax),%eax
    7d28:	83 f8 01             	cmp    $0x1,%eax
    7d2b:	75 27                	jne    7d54 <lodepng_deflatev+0x141>
    7d2d:	83 ec 04             	sub    $0x4,%esp
    7d30:	ff 75 e0             	pushl  -0x20(%ebp)
    7d33:	ff 75 14             	pushl  0x14(%ebp)
    7d36:	ff 75 e4             	pushl  -0x1c(%ebp)
    7d39:	ff 75 dc             	pushl  -0x24(%ebp)
    7d3c:	ff 75 0c             	pushl  0xc(%ebp)
    7d3f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7d42:	50                   	push   %eax
    7d43:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7d46:	50                   	push   %eax
    7d47:	e8 07 fd ff ff       	call   7a53 <deflateFixed>
    7d4c:	83 c4 20             	add    $0x20,%esp
    7d4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7d52:	eb 2f                	jmp    7d83 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7d54:	8b 45 14             	mov    0x14(%ebp),%eax
    7d57:	8b 00                	mov    (%eax),%eax
    7d59:	83 f8 02             	cmp    $0x2,%eax
    7d5c:	75 25                	jne    7d83 <lodepng_deflatev+0x170>
    7d5e:	83 ec 04             	sub    $0x4,%esp
    7d61:	ff 75 e0             	pushl  -0x20(%ebp)
    7d64:	ff 75 14             	pushl  0x14(%ebp)
    7d67:	ff 75 e4             	pushl  -0x1c(%ebp)
    7d6a:	ff 75 dc             	pushl  -0x24(%ebp)
    7d6d:	ff 75 0c             	pushl  0xc(%ebp)
    7d70:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7d73:	50                   	push   %eax
    7d74:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7d77:	50                   	push   %eax
    7d78:	e8 7b f3 ff ff       	call   70f8 <deflateDynamic>
    7d7d:	83 c4 20             	add    $0x20,%esp
    7d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7d83:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7d87:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7d8a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7d8d:	74 0a                	je     7d99 <lodepng_deflatev+0x186>
    7d8f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d93:	0f 84 55 ff ff ff    	je     7cee <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7d99:	83 ec 0c             	sub    $0xc,%esp
    7d9c:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7d9f:	50                   	push   %eax
    7da0:	e8 08 e9 ff ff       	call   66ad <hash_cleanup>
    7da5:	83 c4 10             	add    $0x10,%esp

  return error;
    7da8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7dab:	c9                   	leave  
    7dac:	c3                   	ret    

00007dad <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7dad:	55                   	push   %ebp
    7dae:	89 e5                	mov    %esp,%ebp
    7db0:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7db3:	8b 45 0c             	mov    0xc(%ebp),%eax
    7db6:	8b 08                	mov    (%eax),%ecx
    7db8:	8b 45 08             	mov    0x8(%ebp),%eax
    7dbb:	8b 10                	mov    (%eax),%edx
    7dbd:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7dc0:	51                   	push   %ecx
    7dc1:	52                   	push   %edx
    7dc2:	50                   	push   %eax
    7dc3:	e8 f0 ba ff ff       	call   38b8 <ucvector_init>
    7dc8:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7dcb:	ff 75 18             	pushl  0x18(%ebp)
    7dce:	ff 75 14             	pushl  0x14(%ebp)
    7dd1:	ff 75 10             	pushl  0x10(%ebp)
    7dd4:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7dd7:	50                   	push   %eax
    7dd8:	e8 36 fe ff ff       	call   7c13 <lodepng_deflatev>
    7ddd:	83 c4 10             	add    $0x10,%esp
    7de0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7de3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7de6:	8b 45 08             	mov    0x8(%ebp),%eax
    7de9:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7deb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7dee:	8b 45 0c             	mov    0xc(%ebp),%eax
    7df1:	89 10                	mov    %edx,(%eax)
  return error;
    7df3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7df6:	c9                   	leave  
    7df7:	c3                   	ret    

00007df8 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7df8:	55                   	push   %ebp
    7df9:	89 e5                	mov    %esp,%ebp
    7dfb:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7dfe:	8b 45 18             	mov    0x18(%ebp),%eax
    7e01:	8b 40 1c             	mov    0x1c(%eax),%eax
    7e04:	85 c0                	test   %eax,%eax
    7e06:	74 34                	je     7e3c <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7e08:	8b 45 18             	mov    0x18(%ebp),%eax
    7e0b:	8b 40 1c             	mov    0x1c(%eax),%eax
    7e0e:	83 ec 0c             	sub    $0xc,%esp
    7e11:	ff 75 18             	pushl  0x18(%ebp)
    7e14:	ff 75 14             	pushl  0x14(%ebp)
    7e17:	ff 75 10             	pushl  0x10(%ebp)
    7e1a:	ff 75 0c             	pushl  0xc(%ebp)
    7e1d:	ff 75 08             	pushl  0x8(%ebp)
    7e20:	ff d0                	call   *%eax
    7e22:	83 c4 20             	add    $0x20,%esp
    7e25:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7e28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e2c:	74 07                	je     7e35 <deflate+0x3d>
    7e2e:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7e33:	eb 21                	jmp    7e56 <deflate+0x5e>
    7e35:	b8 00 00 00 00       	mov    $0x0,%eax
    7e3a:	eb 1a                	jmp    7e56 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7e3c:	83 ec 0c             	sub    $0xc,%esp
    7e3f:	ff 75 18             	pushl  0x18(%ebp)
    7e42:	ff 75 14             	pushl  0x14(%ebp)
    7e45:	ff 75 10             	pushl  0x10(%ebp)
    7e48:	ff 75 0c             	pushl  0xc(%ebp)
    7e4b:	ff 75 08             	pushl  0x8(%ebp)
    7e4e:	e8 5a ff ff ff       	call   7dad <lodepng_deflate>
    7e53:	83 c4 20             	add    $0x20,%esp
  }
}
    7e56:	c9                   	leave  
    7e57:	c3                   	ret    

00007e58 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7e58:	55                   	push   %ebp
    7e59:	89 e5                	mov    %esp,%ebp
    7e5b:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7e5e:	8b 45 08             	mov    0x8(%ebp),%eax
    7e61:	0f b7 c0             	movzwl %ax,%eax
    7e64:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7e67:	8b 45 08             	mov    0x8(%ebp),%eax
    7e6a:	c1 e8 10             	shr    $0x10,%eax
    7e6d:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7e70:	e9 82 00 00 00       	jmp    7ef7 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7e75:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7e7a:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7e81:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7e85:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7e88:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7e8b:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7e8e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7e95:	eb 1c                	jmp    7eb3 <update_adler32+0x5b>
      s1 += (*data++);
    7e97:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e9a:	8d 50 01             	lea    0x1(%eax),%edx
    7e9d:	89 55 0c             	mov    %edx,0xc(%ebp)
    7ea0:	0f b6 00             	movzbl (%eax),%eax
    7ea3:	0f b6 c0             	movzbl %al,%eax
    7ea6:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7ea9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7eac:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7eaf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7eb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7eb6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7eb9:	75 dc                	jne    7e97 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7ebb:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7ebe:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7ec3:	89 c8                	mov    %ecx,%eax
    7ec5:	f7 e2                	mul    %edx
    7ec7:	89 d0                	mov    %edx,%eax
    7ec9:	c1 e8 0f             	shr    $0xf,%eax
    7ecc:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7ed2:	29 c1                	sub    %eax,%ecx
    7ed4:	89 c8                	mov    %ecx,%eax
    7ed6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7ed9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7edc:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7ee1:	89 c8                	mov    %ecx,%eax
    7ee3:	f7 e2                	mul    %edx
    7ee5:	89 d0                	mov    %edx,%eax
    7ee7:	c1 e8 0f             	shr    $0xf,%eax
    7eea:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7ef0:	29 c1                	sub    %eax,%ecx
    7ef2:	89 c8                	mov    %ecx,%eax
    7ef4:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7ef7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7efb:	0f 85 74 ff ff ff    	jne    7e75 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7f01:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7f04:	c1 e0 10             	shl    $0x10,%eax
    7f07:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7f0a:	c9                   	leave  
    7f0b:	c3                   	ret    

00007f0c <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7f0c:	55                   	push   %ebp
    7f0d:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7f0f:	ff 75 0c             	pushl  0xc(%ebp)
    7f12:	ff 75 08             	pushl  0x8(%ebp)
    7f15:	6a 01                	push   $0x1
    7f17:	e8 3c ff ff ff       	call   7e58 <update_adler32>
    7f1c:	83 c4 0c             	add    $0xc,%esp
}
    7f1f:	c9                   	leave  
    7f20:	c3                   	ret    

00007f21 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7f21:	55                   	push   %ebp
    7f22:	89 e5                	mov    %esp,%ebp
    7f24:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7f27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7f2e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7f32:	7f 0a                	jg     7f3e <lodepng_zlib_decompressv+0x1d>
    7f34:	b8 35 00 00 00       	mov    $0x35,%eax
    7f39:	e9 27 01 00 00       	jmp    8065 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7f3e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f41:	0f b6 00             	movzbl (%eax),%eax
    7f44:	0f b6 c0             	movzbl %al,%eax
    7f47:	c1 e0 08             	shl    $0x8,%eax
    7f4a:	89 c2                	mov    %eax,%edx
    7f4c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f4f:	83 c0 01             	add    $0x1,%eax
    7f52:	0f b6 00             	movzbl (%eax),%eax
    7f55:	0f b6 c0             	movzbl %al,%eax
    7f58:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7f5b:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7f60:	89 c8                	mov    %ecx,%eax
    7f62:	f7 ea                	imul   %edx
    7f64:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7f67:	c1 f8 04             	sar    $0x4,%eax
    7f6a:	89 c2                	mov    %eax,%edx
    7f6c:	89 c8                	mov    %ecx,%eax
    7f6e:	c1 f8 1f             	sar    $0x1f,%eax
    7f71:	29 c2                	sub    %eax,%edx
    7f73:	89 d0                	mov    %edx,%eax
    7f75:	89 c2                	mov    %eax,%edx
    7f77:	c1 e2 05             	shl    $0x5,%edx
    7f7a:	29 c2                	sub    %eax,%edx
    7f7c:	89 c8                	mov    %ecx,%eax
    7f7e:	29 d0                	sub    %edx,%eax
    7f80:	85 c0                	test   %eax,%eax
    7f82:	74 0a                	je     7f8e <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7f84:	b8 18 00 00 00       	mov    $0x18,%eax
    7f89:	e9 d7 00 00 00       	jmp    8065 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7f8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f91:	0f b6 00             	movzbl (%eax),%eax
    7f94:	0f b6 c0             	movzbl %al,%eax
    7f97:	83 e0 0f             	and    $0xf,%eax
    7f9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7f9d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fa0:	0f b6 00             	movzbl (%eax),%eax
    7fa3:	c0 e8 04             	shr    $0x4,%al
    7fa6:	0f b6 c0             	movzbl %al,%eax
    7fa9:	83 e0 0f             	and    $0xf,%eax
    7fac:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7faf:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fb2:	83 c0 01             	add    $0x1,%eax
    7fb5:	0f b6 00             	movzbl (%eax),%eax
    7fb8:	c0 e8 05             	shr    $0x5,%al
    7fbb:	0f b6 c0             	movzbl %al,%eax
    7fbe:	83 e0 01             	and    $0x1,%eax
    7fc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7fc4:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7fc8:	75 06                	jne    7fd0 <lodepng_zlib_decompressv+0xaf>
    7fca:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7fce:	76 0a                	jbe    7fda <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7fd0:	b8 19 00 00 00       	mov    $0x19,%eax
    7fd5:	e9 8b 00 00 00       	jmp    8065 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7fda:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7fde:	74 07                	je     7fe7 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7fe0:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7fe5:	eb 7e                	jmp    8065 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7fe7:	8b 45 10             	mov    0x10(%ebp),%eax
    7fea:	8d 50 fe             	lea    -0x2(%eax),%edx
    7fed:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ff0:	83 c0 02             	add    $0x2,%eax
    7ff3:	ff 75 14             	pushl  0x14(%ebp)
    7ff6:	52                   	push   %edx
    7ff7:	50                   	push   %eax
    7ff8:	ff 75 08             	pushl  0x8(%ebp)
    7ffb:	e8 09 e3 ff ff       	call   6309 <inflatev>
    8000:	83 c4 10             	add    $0x10,%esp
    8003:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    8006:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    800a:	74 05                	je     8011 <lodepng_zlib_decompressv+0xf0>
    800c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    800f:	eb 54                	jmp    8065 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    8011:	8b 45 14             	mov    0x14(%ebp),%eax
    8014:	8b 00                	mov    (%eax),%eax
    8016:	85 c0                	test   %eax,%eax
    8018:	75 46                	jne    8060 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    801a:	8b 45 10             	mov    0x10(%ebp),%eax
    801d:	8d 50 fc             	lea    -0x4(%eax),%edx
    8020:	8b 45 0c             	mov    0xc(%ebp),%eax
    8023:	01 d0                	add    %edx,%eax
    8025:	83 ec 0c             	sub    $0xc,%esp
    8028:	50                   	push   %eax
    8029:	e8 47 b9 ff ff       	call   3975 <lodepng_read32bitInt>
    802e:	83 c4 10             	add    $0x10,%esp
    8031:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    8034:	8b 45 08             	mov    0x8(%ebp),%eax
    8037:	8b 40 04             	mov    0x4(%eax),%eax
    803a:	89 c2                	mov    %eax,%edx
    803c:	8b 45 08             	mov    0x8(%ebp),%eax
    803f:	8b 00                	mov    (%eax),%eax
    8041:	83 ec 08             	sub    $0x8,%esp
    8044:	52                   	push   %edx
    8045:	50                   	push   %eax
    8046:	e8 c1 fe ff ff       	call   7f0c <adler32>
    804b:	83 c4 10             	add    $0x10,%esp
    804e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    8051:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8054:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8057:	74 07                	je     8060 <lodepng_zlib_decompressv+0x13f>
    8059:	b8 3a 00 00 00       	mov    $0x3a,%eax
    805e:	eb 05                	jmp    8065 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    8060:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8065:	c9                   	leave  
    8066:	c3                   	ret    

00008067 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    8067:	55                   	push   %ebp
    8068:	89 e5                	mov    %esp,%ebp
    806a:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    806d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8070:	8b 08                	mov    (%eax),%ecx
    8072:	8b 45 08             	mov    0x8(%ebp),%eax
    8075:	8b 10                	mov    (%eax),%edx
    8077:	8d 45 e8             	lea    -0x18(%ebp),%eax
    807a:	51                   	push   %ecx
    807b:	52                   	push   %edx
    807c:	50                   	push   %eax
    807d:	e8 36 b8 ff ff       	call   38b8 <ucvector_init>
    8082:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8085:	ff 75 18             	pushl  0x18(%ebp)
    8088:	ff 75 14             	pushl  0x14(%ebp)
    808b:	ff 75 10             	pushl  0x10(%ebp)
    808e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8091:	50                   	push   %eax
    8092:	e8 8a fe ff ff       	call   7f21 <lodepng_zlib_decompressv>
    8097:	83 c4 10             	add    $0x10,%esp
    809a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    809d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    80a0:	8b 45 08             	mov    0x8(%ebp),%eax
    80a3:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    80a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    80a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    80ab:	89 10                	mov    %edx,(%eax)
  return error;
    80ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    80b0:	c9                   	leave  
    80b1:	c3                   	ret    

000080b2 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    80b2:	55                   	push   %ebp
    80b3:	89 e5                	mov    %esp,%ebp
    80b5:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    80b8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    80bb:	8b 40 0c             	mov    0xc(%eax),%eax
    80be:	85 c0                	test   %eax,%eax
    80c0:	74 57                	je     8119 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    80c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    80c5:	8b 40 0c             	mov    0xc(%eax),%eax
    80c8:	83 ec 0c             	sub    $0xc,%esp
    80cb:	ff 75 1c             	pushl  0x1c(%ebp)
    80ce:	ff 75 18             	pushl  0x18(%ebp)
    80d1:	ff 75 14             	pushl  0x14(%ebp)
    80d4:	ff 75 0c             	pushl  0xc(%ebp)
    80d7:	ff 75 08             	pushl  0x8(%ebp)
    80da:	ff d0                	call   *%eax
    80dc:	83 c4 20             	add    $0x20,%esp
    80df:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    80e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    80e6:	0f 84 98 00 00 00    	je     8184 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    80ec:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    80f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    80f6:	8b 40 08             	mov    0x8(%eax),%eax
    80f9:	85 c0                	test   %eax,%eax
    80fb:	0f 84 83 00 00 00    	je     8184 <zlib_decompress+0xd2>
    8101:	8b 45 0c             	mov    0xc(%ebp),%eax
    8104:	8b 10                	mov    (%eax),%edx
    8106:	8b 45 1c             	mov    0x1c(%ebp),%eax
    8109:	8b 40 08             	mov    0x8(%eax),%eax
    810c:	39 c2                	cmp    %eax,%edx
    810e:	7e 74                	jle    8184 <zlib_decompress+0xd2>
    8110:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    8117:	eb 6b                	jmp    8184 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    8119:	8b 45 0c             	mov    0xc(%ebp),%eax
    811c:	8b 08                	mov    (%eax),%ecx
    811e:	8b 45 08             	mov    0x8(%ebp),%eax
    8121:	8b 10                	mov    (%eax),%edx
    8123:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8126:	83 ec 04             	sub    $0x4,%esp
    8129:	51                   	push   %ecx
    812a:	52                   	push   %edx
    812b:	50                   	push   %eax
    812c:	e8 87 b7 ff ff       	call   38b8 <ucvector_init>
    8131:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    8134:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8138:	74 22                	je     815c <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    813a:	8b 45 0c             	mov    0xc(%ebp),%eax
    813d:	8b 10                	mov    (%eax),%edx
    813f:	8b 45 10             	mov    0x10(%ebp),%eax
    8142:	01 d0                	add    %edx,%eax
    8144:	83 ec 08             	sub    $0x8,%esp
    8147:	50                   	push   %eax
    8148:	8d 45 e8             	lea    -0x18(%ebp),%eax
    814b:	50                   	push   %eax
    814c:	e8 00 b7 ff ff       	call   3851 <ucvector_resize>
    8151:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    8154:	8b 45 0c             	mov    0xc(%ebp),%eax
    8157:	8b 00                	mov    (%eax),%eax
    8159:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    815c:	ff 75 1c             	pushl  0x1c(%ebp)
    815f:	ff 75 18             	pushl  0x18(%ebp)
    8162:	ff 75 14             	pushl  0x14(%ebp)
    8165:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8168:	50                   	push   %eax
    8169:	e8 b3 fd ff ff       	call   7f21 <lodepng_zlib_decompressv>
    816e:	83 c4 10             	add    $0x10,%esp
    8171:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    8174:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8177:	8b 45 08             	mov    0x8(%ebp),%eax
    817a:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    817c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    817f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8182:	89 10                	mov    %edx,(%eax)
  }
  return error;
    8184:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8187:	c9                   	leave  
    8188:	c3                   	ret    

00008189 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    8189:	55                   	push   %ebp
    818a:	89 e5                	mov    %esp,%ebp
    818c:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    818f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    8196:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    819d:	83 ec 0c             	sub    $0xc,%esp
    81a0:	ff 75 18             	pushl  0x18(%ebp)
    81a3:	ff 75 14             	pushl  0x14(%ebp)
    81a6:	ff 75 10             	pushl  0x10(%ebp)
    81a9:	8d 45 d0             	lea    -0x30(%ebp),%eax
    81ac:	50                   	push   %eax
    81ad:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    81b0:	50                   	push   %eax
    81b1:	e8 42 fc ff ff       	call   7df8 <deflate>
    81b6:	83 c4 20             	add    $0x20,%esp
    81b9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    81bc:	8b 45 08             	mov    0x8(%ebp),%eax
    81bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    81c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    81c8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    81ce:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    81d2:	75 33                	jne    8207 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    81d4:	8b 45 d0             	mov    -0x30(%ebp),%eax
    81d7:	8d 50 06             	lea    0x6(%eax),%edx
    81da:	8b 45 0c             	mov    0xc(%ebp),%eax
    81dd:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    81df:	8b 45 0c             	mov    0xc(%ebp),%eax
    81e2:	8b 00                	mov    (%eax),%eax
    81e4:	83 ec 0c             	sub    $0xc,%esp
    81e7:	50                   	push   %eax
    81e8:	e8 0a b4 ff ff       	call   35f7 <lodepng_malloc>
    81ed:	83 c4 10             	add    $0x10,%esp
    81f0:	89 c2                	mov    %eax,%edx
    81f2:	8b 45 08             	mov    0x8(%ebp),%eax
    81f5:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    81f7:	8b 45 08             	mov    0x8(%ebp),%eax
    81fa:	8b 00                	mov    (%eax),%eax
    81fc:	85 c0                	test   %eax,%eax
    81fe:	75 07                	jne    8207 <lodepng_zlib_compress+0x7e>
    8200:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    8207:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    820b:	0f 85 e2 00 00 00    	jne    82f3 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    8211:	8b 45 14             	mov    0x14(%ebp),%eax
    8214:	83 ec 08             	sub    $0x8,%esp
    8217:	50                   	push   %eax
    8218:	ff 75 10             	pushl  0x10(%ebp)
    821b:	e8 ec fc ff ff       	call   7f0c <adler32>
    8220:	83 c4 10             	add    $0x10,%esp
    8223:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    8226:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    822d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    8234:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    823b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    823e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8245:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8248:	01 d0                	add    %edx,%eax
    824a:	8d 14 00             	lea    (%eax,%eax,1),%edx
    824d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8250:	01 d0                	add    %edx,%eax
    8252:	c1 e0 05             	shl    $0x5,%eax
    8255:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    8258:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    825b:	ba 85 10 42 08       	mov    $0x8421085,%edx
    8260:	89 c8                	mov    %ecx,%eax
    8262:	f7 e2                	mul    %edx
    8264:	89 c8                	mov    %ecx,%eax
    8266:	29 d0                	sub    %edx,%eax
    8268:	d1 e8                	shr    %eax
    826a:	01 d0                	add    %edx,%eax
    826c:	c1 e8 04             	shr    $0x4,%eax
    826f:	89 c2                	mov    %eax,%edx
    8271:	c1 e2 05             	shl    $0x5,%edx
    8274:	29 c2                	sub    %eax,%edx
    8276:	89 c8                	mov    %ecx,%eax
    8278:	29 d0                	sub    %edx,%eax
    827a:	ba 1f 00 00 00       	mov    $0x1f,%edx
    827f:	29 c2                	sub    %eax,%edx
    8281:	89 d0                	mov    %edx,%eax
    8283:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    8286:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8289:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    828c:	8b 45 08             	mov    0x8(%ebp),%eax
    828f:	8b 00                	mov    (%eax),%eax
    8291:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8294:	c1 ea 08             	shr    $0x8,%edx
    8297:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    8299:	8b 45 08             	mov    0x8(%ebp),%eax
    829c:	8b 00                	mov    (%eax),%eax
    829e:	83 c0 01             	add    $0x1,%eax
    82a1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    82a4:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    82a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    82ad:	eb 1e                	jmp    82cd <lodepng_zlib_compress+0x144>
    82af:	8b 45 08             	mov    0x8(%ebp),%eax
    82b2:	8b 00                	mov    (%eax),%eax
    82b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    82b7:	83 c2 02             	add    $0x2,%edx
    82ba:	01 c2                	add    %eax,%edx
    82bc:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    82bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    82c2:	01 c8                	add    %ecx,%eax
    82c4:	0f b6 00             	movzbl (%eax),%eax
    82c7:	88 02                	mov    %al,(%edx)
    82c9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    82cd:	8b 45 d0             	mov    -0x30(%ebp),%eax
    82d0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    82d3:	75 da                	jne    82af <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    82d5:	8b 45 08             	mov    0x8(%ebp),%eax
    82d8:	8b 10                	mov    (%eax),%edx
    82da:	8b 45 0c             	mov    0xc(%ebp),%eax
    82dd:	8b 00                	mov    (%eax),%eax
    82df:	83 e8 04             	sub    $0x4,%eax
    82e2:	01 d0                	add    %edx,%eax
    82e4:	83 ec 08             	sub    $0x8,%esp
    82e7:	ff 75 ec             	pushl  -0x14(%ebp)
    82ea:	50                   	push   %eax
    82eb:	e8 c8 b6 ff ff       	call   39b8 <lodepng_set32bitInt>
    82f0:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    82f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    82f6:	83 ec 0c             	sub    $0xc,%esp
    82f9:	50                   	push   %eax
    82fa:	e8 19 b3 ff ff       	call   3618 <lodepng_free>
    82ff:	83 c4 10             	add    $0x10,%esp
  return error;
    8302:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    8305:	c9                   	leave  
    8306:	c3                   	ret    

00008307 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    8307:	55                   	push   %ebp
    8308:	89 e5                	mov    %esp,%ebp
    830a:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    830d:	8b 45 18             	mov    0x18(%ebp),%eax
    8310:	8b 40 18             	mov    0x18(%eax),%eax
    8313:	85 c0                	test   %eax,%eax
    8315:	74 34                	je     834b <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    8317:	8b 45 18             	mov    0x18(%ebp),%eax
    831a:	8b 40 18             	mov    0x18(%eax),%eax
    831d:	83 ec 0c             	sub    $0xc,%esp
    8320:	ff 75 18             	pushl  0x18(%ebp)
    8323:	ff 75 14             	pushl  0x14(%ebp)
    8326:	ff 75 10             	pushl  0x10(%ebp)
    8329:	ff 75 0c             	pushl  0xc(%ebp)
    832c:	ff 75 08             	pushl  0x8(%ebp)
    832f:	ff d0                	call   *%eax
    8331:	83 c4 20             	add    $0x20,%esp
    8334:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8337:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    833b:	74 07                	je     8344 <zlib_compress+0x3d>
    833d:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8342:	eb 21                	jmp    8365 <zlib_compress+0x5e>
    8344:	b8 00 00 00 00       	mov    $0x0,%eax
    8349:	eb 1a                	jmp    8365 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    834b:	83 ec 0c             	sub    $0xc,%esp
    834e:	ff 75 18             	pushl  0x18(%ebp)
    8351:	ff 75 14             	pushl  0x14(%ebp)
    8354:	ff 75 10             	pushl  0x10(%ebp)
    8357:	ff 75 0c             	pushl  0xc(%ebp)
    835a:	ff 75 08             	pushl  0x8(%ebp)
    835d:	e8 27 fe ff ff       	call   8189 <lodepng_zlib_compress>
    8362:	83 c4 20             	add    $0x20,%esp
  }
}
    8365:	c9                   	leave  
    8366:	c3                   	ret    

00008367 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8367:	55                   	push   %ebp
    8368:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    836a:	8b 45 08             	mov    0x8(%ebp),%eax
    836d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    8373:	8b 45 08             	mov    0x8(%ebp),%eax
    8376:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    837d:	8b 45 08             	mov    0x8(%ebp),%eax
    8380:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    8387:	8b 45 08             	mov    0x8(%ebp),%eax
    838a:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    8391:	8b 45 08             	mov    0x8(%ebp),%eax
    8394:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    839b:	8b 45 08             	mov    0x8(%ebp),%eax
    839e:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    83a5:	8b 45 08             	mov    0x8(%ebp),%eax
    83a8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    83af:	8b 45 08             	mov    0x8(%ebp),%eax
    83b2:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    83b9:	8b 45 08             	mov    0x8(%ebp),%eax
    83bc:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    83c3:	90                   	nop
    83c4:	5d                   	pop    %ebp
    83c5:	c3                   	ret    

000083c6 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    83c6:	55                   	push   %ebp
    83c7:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    83c9:	8b 45 08             	mov    0x8(%ebp),%eax
    83cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    83d2:	8b 45 08             	mov    0x8(%ebp),%eax
    83d5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    83dc:	8b 45 08             	mov    0x8(%ebp),%eax
    83df:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    83e6:	8b 45 08             	mov    0x8(%ebp),%eax
    83e9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    83f0:	8b 45 08             	mov    0x8(%ebp),%eax
    83f3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    83fa:	8b 45 08             	mov    0x8(%ebp),%eax
    83fd:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    8404:	90                   	nop
    8405:	5d                   	pop    %ebp
    8406:	c3                   	ret    

00008407 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    8407:	55                   	push   %ebp
    8408:	89 e5                	mov    %esp,%ebp
    840a:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    840d:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    8414:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    841b:	eb 2a                	jmp    8447 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    841d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8420:	8b 45 08             	mov    0x8(%ebp),%eax
    8423:	01 d0                	add    %edx,%eax
    8425:	0f b6 00             	movzbl (%eax),%eax
    8428:	0f b6 c0             	movzbl %al,%eax
    842b:	33 45 fc             	xor    -0x4(%ebp),%eax
    842e:	0f b6 c0             	movzbl %al,%eax
    8431:	8b 04 85 60 e4 01 00 	mov    0x1e460(,%eax,4),%eax
    8438:	8b 55 fc             	mov    -0x4(%ebp),%edx
    843b:	c1 ea 08             	shr    $0x8,%edx
    843e:	31 d0                	xor    %edx,%eax
    8440:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    8443:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8447:	8b 45 f8             	mov    -0x8(%ebp),%eax
    844a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    844d:	7c ce                	jl     841d <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    844f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8452:	f7 d0                	not    %eax
}
    8454:	c9                   	leave  
    8455:	c3                   	ret    

00008456 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8456:	55                   	push   %ebp
    8457:	89 e5                	mov    %esp,%ebp
    8459:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    845c:	8b 45 08             	mov    0x8(%ebp),%eax
    845f:	8b 00                	mov    (%eax),%eax
    8461:	c1 f8 03             	sar    $0x3,%eax
    8464:	89 c2                	mov    %eax,%edx
    8466:	8b 45 0c             	mov    0xc(%ebp),%eax
    8469:	01 d0                	add    %edx,%eax
    846b:	0f b6 00             	movzbl (%eax),%eax
    846e:	0f b6 d0             	movzbl %al,%edx
    8471:	8b 45 08             	mov    0x8(%ebp),%eax
    8474:	8b 00                	mov    (%eax),%eax
    8476:	f7 d0                	not    %eax
    8478:	83 e0 07             	and    $0x7,%eax
    847b:	89 c1                	mov    %eax,%ecx
    847d:	d3 fa                	sar    %cl,%edx
    847f:	89 d0                	mov    %edx,%eax
    8481:	83 e0 01             	and    $0x1,%eax
    8484:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    8487:	8b 45 08             	mov    0x8(%ebp),%eax
    848a:	8b 00                	mov    (%eax),%eax
    848c:	8d 50 01             	lea    0x1(%eax),%edx
    848f:	8b 45 08             	mov    0x8(%ebp),%eax
    8492:	89 10                	mov    %edx,(%eax)
  return result;
    8494:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    8498:	c9                   	leave  
    8499:	c3                   	ret    

0000849a <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    849a:	55                   	push   %ebp
    849b:	89 e5                	mov    %esp,%ebp
    849d:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    84a0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    84a7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    84ae:	eb 1b                	jmp    84cb <readBitsFromReversedStream+0x31>
    result <<= 1u;
    84b0:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    84b3:	ff 75 0c             	pushl  0xc(%ebp)
    84b6:	ff 75 08             	pushl  0x8(%ebp)
    84b9:	e8 98 ff ff ff       	call   8456 <readBitFromReversedStream>
    84be:	83 c4 08             	add    $0x8,%esp
    84c1:	0f b6 c0             	movzbl %al,%eax
    84c4:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    84c7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    84cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    84ce:	3b 45 10             	cmp    0x10(%ebp),%eax
    84d1:	7c dd                	jl     84b0 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    84d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    84d6:	c9                   	leave  
    84d7:	c3                   	ret    

000084d8 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    84d8:	55                   	push   %ebp
    84d9:	89 e5                	mov    %esp,%ebp
    84db:	56                   	push   %esi
    84dc:	53                   	push   %ebx
    84dd:	83 ec 04             	sub    $0x4,%esp
    84e0:	8b 45 10             	mov    0x10(%ebp),%eax
    84e3:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    84e6:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    84ea:	75 3e                	jne    852a <setBitOfReversedStream+0x52>
    84ec:	8b 45 08             	mov    0x8(%ebp),%eax
    84ef:	8b 00                	mov    (%eax),%eax
    84f1:	c1 f8 03             	sar    $0x3,%eax
    84f4:	89 c2                	mov    %eax,%edx
    84f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    84f9:	01 c2                	add    %eax,%edx
    84fb:	8b 45 08             	mov    0x8(%ebp),%eax
    84fe:	8b 00                	mov    (%eax),%eax
    8500:	c1 f8 03             	sar    $0x3,%eax
    8503:	89 c1                	mov    %eax,%ecx
    8505:	8b 45 0c             	mov    0xc(%ebp),%eax
    8508:	01 c8                	add    %ecx,%eax
    850a:	0f b6 18             	movzbl (%eax),%ebx
    850d:	8b 45 08             	mov    0x8(%ebp),%eax
    8510:	8b 00                	mov    (%eax),%eax
    8512:	f7 d0                	not    %eax
    8514:	83 e0 07             	and    $0x7,%eax
    8517:	be 01 00 00 00       	mov    $0x1,%esi
    851c:	89 c1                	mov    %eax,%ecx
    851e:	d3 e6                	shl    %cl,%esi
    8520:	89 f0                	mov    %esi,%eax
    8522:	f7 d0                	not    %eax
    8524:	21 d8                	and    %ebx,%eax
    8526:	88 02                	mov    %al,(%edx)
    8528:	eb 3a                	jmp    8564 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    852a:	8b 45 08             	mov    0x8(%ebp),%eax
    852d:	8b 00                	mov    (%eax),%eax
    852f:	c1 f8 03             	sar    $0x3,%eax
    8532:	89 c2                	mov    %eax,%edx
    8534:	8b 45 0c             	mov    0xc(%ebp),%eax
    8537:	01 c2                	add    %eax,%edx
    8539:	8b 45 08             	mov    0x8(%ebp),%eax
    853c:	8b 00                	mov    (%eax),%eax
    853e:	c1 f8 03             	sar    $0x3,%eax
    8541:	89 c1                	mov    %eax,%ecx
    8543:	8b 45 0c             	mov    0xc(%ebp),%eax
    8546:	01 c8                	add    %ecx,%eax
    8548:	0f b6 18             	movzbl (%eax),%ebx
    854b:	8b 45 08             	mov    0x8(%ebp),%eax
    854e:	8b 00                	mov    (%eax),%eax
    8550:	f7 d0                	not    %eax
    8552:	83 e0 07             	and    $0x7,%eax
    8555:	be 01 00 00 00       	mov    $0x1,%esi
    855a:	89 c1                	mov    %eax,%ecx
    855c:	d3 e6                	shl    %cl,%esi
    855e:	89 f0                	mov    %esi,%eax
    8560:	09 d8                	or     %ebx,%eax
    8562:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8564:	8b 45 08             	mov    0x8(%ebp),%eax
    8567:	8b 00                	mov    (%eax),%eax
    8569:	8d 50 01             	lea    0x1(%eax),%edx
    856c:	8b 45 08             	mov    0x8(%ebp),%eax
    856f:	89 10                	mov    %edx,(%eax)
}
    8571:	90                   	nop
    8572:	83 c4 04             	add    $0x4,%esp
    8575:	5b                   	pop    %ebx
    8576:	5e                   	pop    %esi
    8577:	5d                   	pop    %ebp
    8578:	c3                   	ret    

00008579 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    8579:	55                   	push   %ebp
    857a:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    857c:	ff 75 08             	pushl  0x8(%ebp)
    857f:	e8 f1 b3 ff ff       	call   3975 <lodepng_read32bitInt>
    8584:	83 c4 04             	add    $0x4,%esp
}
    8587:	c9                   	leave  
    8588:	c3                   	ret    

00008589 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    8589:	55                   	push   %ebp
    858a:	89 e5                	mov    %esp,%ebp
    858c:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    858f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8596:	eb 1c                	jmp    85b4 <lodepng_chunk_type+0x2b>
    8598:	8b 55 08             	mov    0x8(%ebp),%edx
    859b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    859e:	01 d0                	add    %edx,%eax
    85a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    85a3:	8d 4a 04             	lea    0x4(%edx),%ecx
    85a6:	8b 55 0c             	mov    0xc(%ebp),%edx
    85a9:	01 ca                	add    %ecx,%edx
    85ab:	0f b6 12             	movzbl (%edx),%edx
    85ae:	88 10                	mov    %dl,(%eax)
    85b0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    85b4:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    85b8:	75 de                	jne    8598 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    85ba:	8b 45 08             	mov    0x8(%ebp),%eax
    85bd:	83 c0 04             	add    $0x4,%eax
    85c0:	c6 00 00             	movb   $0x0,(%eax)
}
    85c3:	90                   	nop
    85c4:	c9                   	leave  
    85c5:	c3                   	ret    

000085c6 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    85c6:	55                   	push   %ebp
    85c7:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    85c9:	ff 75 0c             	pushl  0xc(%ebp)
    85cc:	e8 c2 b0 ff ff       	call   3693 <lodepng_strlen>
    85d1:	83 c4 04             	add    $0x4,%esp
    85d4:	83 f8 04             	cmp    $0x4,%eax
    85d7:	74 07                	je     85e0 <lodepng_chunk_type_equals+0x1a>
    85d9:	b8 00 00 00 00       	mov    $0x0,%eax
    85de:	eb 79                	jmp    8659 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    85e0:	8b 45 08             	mov    0x8(%ebp),%eax
    85e3:	83 c0 04             	add    $0x4,%eax
    85e6:	0f b6 00             	movzbl (%eax),%eax
    85e9:	0f b6 d0             	movzbl %al,%edx
    85ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    85ef:	0f b6 00             	movzbl (%eax),%eax
    85f2:	0f be c0             	movsbl %al,%eax
    85f5:	39 c2                	cmp    %eax,%edx
    85f7:	75 5b                	jne    8654 <lodepng_chunk_type_equals+0x8e>
    85f9:	8b 45 08             	mov    0x8(%ebp),%eax
    85fc:	83 c0 05             	add    $0x5,%eax
    85ff:	0f b6 00             	movzbl (%eax),%eax
    8602:	0f b6 d0             	movzbl %al,%edx
    8605:	8b 45 0c             	mov    0xc(%ebp),%eax
    8608:	83 c0 01             	add    $0x1,%eax
    860b:	0f b6 00             	movzbl (%eax),%eax
    860e:	0f be c0             	movsbl %al,%eax
    8611:	39 c2                	cmp    %eax,%edx
    8613:	75 3f                	jne    8654 <lodepng_chunk_type_equals+0x8e>
    8615:	8b 45 08             	mov    0x8(%ebp),%eax
    8618:	83 c0 06             	add    $0x6,%eax
    861b:	0f b6 00             	movzbl (%eax),%eax
    861e:	0f b6 d0             	movzbl %al,%edx
    8621:	8b 45 0c             	mov    0xc(%ebp),%eax
    8624:	83 c0 02             	add    $0x2,%eax
    8627:	0f b6 00             	movzbl (%eax),%eax
    862a:	0f be c0             	movsbl %al,%eax
    862d:	39 c2                	cmp    %eax,%edx
    862f:	75 23                	jne    8654 <lodepng_chunk_type_equals+0x8e>
    8631:	8b 45 08             	mov    0x8(%ebp),%eax
    8634:	83 c0 07             	add    $0x7,%eax
    8637:	0f b6 00             	movzbl (%eax),%eax
    863a:	0f b6 d0             	movzbl %al,%edx
    863d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8640:	83 c0 03             	add    $0x3,%eax
    8643:	0f b6 00             	movzbl (%eax),%eax
    8646:	0f be c0             	movsbl %al,%eax
    8649:	39 c2                	cmp    %eax,%edx
    864b:	75 07                	jne    8654 <lodepng_chunk_type_equals+0x8e>
    864d:	b8 01 00 00 00       	mov    $0x1,%eax
    8652:	eb 05                	jmp    8659 <lodepng_chunk_type_equals+0x93>
    8654:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8659:	c9                   	leave  
    865a:	c3                   	ret    

0000865b <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    865b:	55                   	push   %ebp
    865c:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    865e:	8b 45 08             	mov    0x8(%ebp),%eax
    8661:	83 c0 04             	add    $0x4,%eax
    8664:	0f b6 00             	movzbl (%eax),%eax
    8667:	0f b6 c0             	movzbl %al,%eax
    866a:	83 e0 20             	and    $0x20,%eax
    866d:	85 c0                	test   %eax,%eax
    866f:	0f 95 c0             	setne  %al
}
    8672:	5d                   	pop    %ebp
    8673:	c3                   	ret    

00008674 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    8674:	55                   	push   %ebp
    8675:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8677:	8b 45 08             	mov    0x8(%ebp),%eax
    867a:	83 c0 06             	add    $0x6,%eax
    867d:	0f b6 00             	movzbl (%eax),%eax
    8680:	0f b6 c0             	movzbl %al,%eax
    8683:	83 e0 20             	and    $0x20,%eax
    8686:	85 c0                	test   %eax,%eax
    8688:	0f 95 c0             	setne  %al
}
    868b:	5d                   	pop    %ebp
    868c:	c3                   	ret    

0000868d <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    868d:	55                   	push   %ebp
    868e:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    8690:	8b 45 08             	mov    0x8(%ebp),%eax
    8693:	83 c0 07             	add    $0x7,%eax
    8696:	0f b6 00             	movzbl (%eax),%eax
    8699:	0f b6 c0             	movzbl %al,%eax
    869c:	83 e0 20             	and    $0x20,%eax
    869f:	85 c0                	test   %eax,%eax
    86a1:	0f 95 c0             	setne  %al
}
    86a4:	5d                   	pop    %ebp
    86a5:	c3                   	ret    

000086a6 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    86a6:	55                   	push   %ebp
    86a7:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    86a9:	8b 45 08             	mov    0x8(%ebp),%eax
    86ac:	83 c0 08             	add    $0x8,%eax
}
    86af:	5d                   	pop    %ebp
    86b0:	c3                   	ret    

000086b1 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    86b1:	55                   	push   %ebp
    86b2:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    86b4:	8b 45 08             	mov    0x8(%ebp),%eax
    86b7:	83 c0 08             	add    $0x8,%eax
}
    86ba:	5d                   	pop    %ebp
    86bb:	c3                   	ret    

000086bc <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    86bc:	55                   	push   %ebp
    86bd:	89 e5                	mov    %esp,%ebp
    86bf:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    86c2:	ff 75 08             	pushl  0x8(%ebp)
    86c5:	e8 af fe ff ff       	call   8579 <lodepng_chunk_length>
    86ca:	83 c4 04             	add    $0x4,%esp
    86cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    86d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    86d3:	8d 50 08             	lea    0x8(%eax),%edx
    86d6:	8b 45 08             	mov    0x8(%ebp),%eax
    86d9:	01 d0                	add    %edx,%eax
    86db:	50                   	push   %eax
    86dc:	e8 94 b2 ff ff       	call   3975 <lodepng_read32bitInt>
    86e1:	83 c4 04             	add    $0x4,%esp
    86e4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    86e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    86ea:	83 c0 04             	add    $0x4,%eax
    86ed:	89 c2                	mov    %eax,%edx
    86ef:	8b 45 08             	mov    0x8(%ebp),%eax
    86f2:	83 c0 04             	add    $0x4,%eax
    86f5:	52                   	push   %edx
    86f6:	50                   	push   %eax
    86f7:	e8 0b fd ff ff       	call   8407 <lodepng_crc32>
    86fc:	83 c4 08             	add    $0x8,%esp
    86ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    8702:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8705:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8708:	74 07                	je     8711 <lodepng_chunk_check_crc+0x55>
    870a:	b8 01 00 00 00       	mov    $0x1,%eax
    870f:	eb 05                	jmp    8716 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    8711:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8716:	c9                   	leave  
    8717:	c3                   	ret    

00008718 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8718:	55                   	push   %ebp
    8719:	89 e5                	mov    %esp,%ebp
    871b:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    871e:	ff 75 08             	pushl  0x8(%ebp)
    8721:	e8 53 fe ff ff       	call   8579 <lodepng_chunk_length>
    8726:	83 c4 04             	add    $0x4,%esp
    8729:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    872c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    872f:	83 c0 04             	add    $0x4,%eax
    8732:	89 c2                	mov    %eax,%edx
    8734:	8b 45 08             	mov    0x8(%ebp),%eax
    8737:	83 c0 04             	add    $0x4,%eax
    873a:	52                   	push   %edx
    873b:	50                   	push   %eax
    873c:	e8 c6 fc ff ff       	call   8407 <lodepng_crc32>
    8741:	83 c4 08             	add    $0x8,%esp
    8744:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8747:	8b 45 fc             	mov    -0x4(%ebp),%eax
    874a:	8d 50 08             	lea    0x8(%eax),%edx
    874d:	8b 45 08             	mov    0x8(%ebp),%eax
    8750:	01 d0                	add    %edx,%eax
    8752:	ff 75 f8             	pushl  -0x8(%ebp)
    8755:	50                   	push   %eax
    8756:	e8 5d b2 ff ff       	call   39b8 <lodepng_set32bitInt>
    875b:	83 c4 08             	add    $0x8,%esp
}
    875e:	90                   	nop
    875f:	c9                   	leave  
    8760:	c3                   	ret    

00008761 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    8761:	55                   	push   %ebp
    8762:	89 e5                	mov    %esp,%ebp
    8764:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8767:	8b 45 08             	mov    0x8(%ebp),%eax
    876a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    876d:	73 0f                	jae    877e <lodepng_chunk_next+0x1d>
    876f:	8b 55 0c             	mov    0xc(%ebp),%edx
    8772:	8b 45 08             	mov    0x8(%ebp),%eax
    8775:	29 c2                	sub    %eax,%edx
    8777:	89 d0                	mov    %edx,%eax
    8779:	83 f8 0b             	cmp    $0xb,%eax
    877c:	7f 08                	jg     8786 <lodepng_chunk_next+0x25>
    877e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8781:	e9 af 00 00 00       	jmp    8835 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8786:	8b 45 08             	mov    0x8(%ebp),%eax
    8789:	0f b6 00             	movzbl (%eax),%eax
    878c:	3c 89                	cmp    $0x89,%al
    878e:	75 63                	jne    87f3 <lodepng_chunk_next+0x92>
    8790:	8b 45 08             	mov    0x8(%ebp),%eax
    8793:	83 c0 01             	add    $0x1,%eax
    8796:	0f b6 00             	movzbl (%eax),%eax
    8799:	3c 50                	cmp    $0x50,%al
    879b:	75 56                	jne    87f3 <lodepng_chunk_next+0x92>
    879d:	8b 45 08             	mov    0x8(%ebp),%eax
    87a0:	83 c0 02             	add    $0x2,%eax
    87a3:	0f b6 00             	movzbl (%eax),%eax
    87a6:	3c 4e                	cmp    $0x4e,%al
    87a8:	75 49                	jne    87f3 <lodepng_chunk_next+0x92>
    87aa:	8b 45 08             	mov    0x8(%ebp),%eax
    87ad:	83 c0 03             	add    $0x3,%eax
    87b0:	0f b6 00             	movzbl (%eax),%eax
    87b3:	3c 47                	cmp    $0x47,%al
    87b5:	75 3c                	jne    87f3 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    87b7:	8b 45 08             	mov    0x8(%ebp),%eax
    87ba:	83 c0 04             	add    $0x4,%eax
    87bd:	0f b6 00             	movzbl (%eax),%eax
    87c0:	3c 0d                	cmp    $0xd,%al
    87c2:	75 2f                	jne    87f3 <lodepng_chunk_next+0x92>
    87c4:	8b 45 08             	mov    0x8(%ebp),%eax
    87c7:	83 c0 05             	add    $0x5,%eax
    87ca:	0f b6 00             	movzbl (%eax),%eax
    87cd:	3c 0a                	cmp    $0xa,%al
    87cf:	75 22                	jne    87f3 <lodepng_chunk_next+0x92>
    87d1:	8b 45 08             	mov    0x8(%ebp),%eax
    87d4:	83 c0 06             	add    $0x6,%eax
    87d7:	0f b6 00             	movzbl (%eax),%eax
    87da:	3c 1a                	cmp    $0x1a,%al
    87dc:	75 15                	jne    87f3 <lodepng_chunk_next+0x92>
    87de:	8b 45 08             	mov    0x8(%ebp),%eax
    87e1:	83 c0 07             	add    $0x7,%eax
    87e4:	0f b6 00             	movzbl (%eax),%eax
    87e7:	3c 0a                	cmp    $0xa,%al
    87e9:	75 08                	jne    87f3 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    87eb:	8b 45 08             	mov    0x8(%ebp),%eax
    87ee:	83 c0 08             	add    $0x8,%eax
    87f1:	eb 42                	jmp    8835 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    87f3:	ff 75 08             	pushl  0x8(%ebp)
    87f6:	e8 7e fd ff ff       	call   8579 <lodepng_chunk_length>
    87fb:	83 c4 04             	add    $0x4,%esp
    87fe:	89 c2                	mov    %eax,%edx
    8800:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8803:	50                   	push   %eax
    8804:	6a 0c                	push   $0xc
    8806:	52                   	push   %edx
    8807:	e8 af ae ff ff       	call   36bb <lodepng_addofl>
    880c:	83 c4 0c             	add    $0xc,%esp
    880f:	85 c0                	test   %eax,%eax
    8811:	74 05                	je     8818 <lodepng_chunk_next+0xb7>
    8813:	8b 45 0c             	mov    0xc(%ebp),%eax
    8816:	eb 1d                	jmp    8835 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8818:	8b 45 f8             	mov    -0x8(%ebp),%eax
    881b:	89 c2                	mov    %eax,%edx
    881d:	8b 45 08             	mov    0x8(%ebp),%eax
    8820:	01 d0                	add    %edx,%eax
    8822:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8825:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8828:	3b 45 08             	cmp    0x8(%ebp),%eax
    882b:	73 05                	jae    8832 <lodepng_chunk_next+0xd1>
    882d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8830:	eb 03                	jmp    8835 <lodepng_chunk_next+0xd4>
    return result;
    8832:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8835:	c9                   	leave  
    8836:	c3                   	ret    

00008837 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8837:	55                   	push   %ebp
    8838:	89 e5                	mov    %esp,%ebp
    883a:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    883d:	8b 45 08             	mov    0x8(%ebp),%eax
    8840:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8843:	73 0f                	jae    8854 <lodepng_chunk_next_const+0x1d>
    8845:	8b 55 0c             	mov    0xc(%ebp),%edx
    8848:	8b 45 08             	mov    0x8(%ebp),%eax
    884b:	29 c2                	sub    %eax,%edx
    884d:	89 d0                	mov    %edx,%eax
    884f:	83 f8 0b             	cmp    $0xb,%eax
    8852:	7f 08                	jg     885c <lodepng_chunk_next_const+0x25>
    8854:	8b 45 0c             	mov    0xc(%ebp),%eax
    8857:	e9 af 00 00 00       	jmp    890b <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    885c:	8b 45 08             	mov    0x8(%ebp),%eax
    885f:	0f b6 00             	movzbl (%eax),%eax
    8862:	3c 89                	cmp    $0x89,%al
    8864:	75 63                	jne    88c9 <lodepng_chunk_next_const+0x92>
    8866:	8b 45 08             	mov    0x8(%ebp),%eax
    8869:	83 c0 01             	add    $0x1,%eax
    886c:	0f b6 00             	movzbl (%eax),%eax
    886f:	3c 50                	cmp    $0x50,%al
    8871:	75 56                	jne    88c9 <lodepng_chunk_next_const+0x92>
    8873:	8b 45 08             	mov    0x8(%ebp),%eax
    8876:	83 c0 02             	add    $0x2,%eax
    8879:	0f b6 00             	movzbl (%eax),%eax
    887c:	3c 4e                	cmp    $0x4e,%al
    887e:	75 49                	jne    88c9 <lodepng_chunk_next_const+0x92>
    8880:	8b 45 08             	mov    0x8(%ebp),%eax
    8883:	83 c0 03             	add    $0x3,%eax
    8886:	0f b6 00             	movzbl (%eax),%eax
    8889:	3c 47                	cmp    $0x47,%al
    888b:	75 3c                	jne    88c9 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    888d:	8b 45 08             	mov    0x8(%ebp),%eax
    8890:	83 c0 04             	add    $0x4,%eax
    8893:	0f b6 00             	movzbl (%eax),%eax
    8896:	3c 0d                	cmp    $0xd,%al
    8898:	75 2f                	jne    88c9 <lodepng_chunk_next_const+0x92>
    889a:	8b 45 08             	mov    0x8(%ebp),%eax
    889d:	83 c0 05             	add    $0x5,%eax
    88a0:	0f b6 00             	movzbl (%eax),%eax
    88a3:	3c 0a                	cmp    $0xa,%al
    88a5:	75 22                	jne    88c9 <lodepng_chunk_next_const+0x92>
    88a7:	8b 45 08             	mov    0x8(%ebp),%eax
    88aa:	83 c0 06             	add    $0x6,%eax
    88ad:	0f b6 00             	movzbl (%eax),%eax
    88b0:	3c 1a                	cmp    $0x1a,%al
    88b2:	75 15                	jne    88c9 <lodepng_chunk_next_const+0x92>
    88b4:	8b 45 08             	mov    0x8(%ebp),%eax
    88b7:	83 c0 07             	add    $0x7,%eax
    88ba:	0f b6 00             	movzbl (%eax),%eax
    88bd:	3c 0a                	cmp    $0xa,%al
    88bf:	75 08                	jne    88c9 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    88c1:	8b 45 08             	mov    0x8(%ebp),%eax
    88c4:	83 c0 08             	add    $0x8,%eax
    88c7:	eb 42                	jmp    890b <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    88c9:	ff 75 08             	pushl  0x8(%ebp)
    88cc:	e8 a8 fc ff ff       	call   8579 <lodepng_chunk_length>
    88d1:	83 c4 04             	add    $0x4,%esp
    88d4:	89 c2                	mov    %eax,%edx
    88d6:	8d 45 f8             	lea    -0x8(%ebp),%eax
    88d9:	50                   	push   %eax
    88da:	6a 0c                	push   $0xc
    88dc:	52                   	push   %edx
    88dd:	e8 d9 ad ff ff       	call   36bb <lodepng_addofl>
    88e2:	83 c4 0c             	add    $0xc,%esp
    88e5:	85 c0                	test   %eax,%eax
    88e7:	74 05                	je     88ee <lodepng_chunk_next_const+0xb7>
    88e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    88ec:	eb 1d                	jmp    890b <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    88ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    88f1:	89 c2                	mov    %eax,%edx
    88f3:	8b 45 08             	mov    0x8(%ebp),%eax
    88f6:	01 d0                	add    %edx,%eax
    88f8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    88fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    88fe:	3b 45 08             	cmp    0x8(%ebp),%eax
    8901:	73 05                	jae    8908 <lodepng_chunk_next_const+0xd1>
    8903:	8b 45 0c             	mov    0xc(%ebp),%eax
    8906:	eb 03                	jmp    890b <lodepng_chunk_next_const+0xd4>
    return result;
    8908:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    890b:	c9                   	leave  
    890c:	c3                   	ret    

0000890d <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    890d:	55                   	push   %ebp
    890e:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8910:	8b 45 08             	mov    0x8(%ebp),%eax
    8913:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8916:	73 0f                	jae    8927 <lodepng_chunk_find+0x1a>
    8918:	8b 55 0c             	mov    0xc(%ebp),%edx
    891b:	8b 45 08             	mov    0x8(%ebp),%eax
    891e:	29 c2                	sub    %eax,%edx
    8920:	89 d0                	mov    %edx,%eax
    8922:	83 f8 0b             	cmp    $0xb,%eax
    8925:	7f 07                	jg     892e <lodepng_chunk_find+0x21>
    8927:	b8 00 00 00 00       	mov    $0x0,%eax
    892c:	eb 2a                	jmp    8958 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    892e:	ff 75 10             	pushl  0x10(%ebp)
    8931:	ff 75 08             	pushl  0x8(%ebp)
    8934:	e8 8d fc ff ff       	call   85c6 <lodepng_chunk_type_equals>
    8939:	83 c4 08             	add    $0x8,%esp
    893c:	84 c0                	test   %al,%al
    893e:	74 05                	je     8945 <lodepng_chunk_find+0x38>
    8940:	8b 45 08             	mov    0x8(%ebp),%eax
    8943:	eb 13                	jmp    8958 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8945:	ff 75 0c             	pushl  0xc(%ebp)
    8948:	ff 75 08             	pushl  0x8(%ebp)
    894b:	e8 11 fe ff ff       	call   8761 <lodepng_chunk_next>
    8950:	83 c4 08             	add    $0x8,%esp
    8953:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8956:	eb b8                	jmp    8910 <lodepng_chunk_find+0x3>
}
    8958:	c9                   	leave  
    8959:	c3                   	ret    

0000895a <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    895a:	55                   	push   %ebp
    895b:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    895d:	8b 45 08             	mov    0x8(%ebp),%eax
    8960:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8963:	73 0f                	jae    8974 <lodepng_chunk_find_const+0x1a>
    8965:	8b 55 0c             	mov    0xc(%ebp),%edx
    8968:	8b 45 08             	mov    0x8(%ebp),%eax
    896b:	29 c2                	sub    %eax,%edx
    896d:	89 d0                	mov    %edx,%eax
    896f:	83 f8 0b             	cmp    $0xb,%eax
    8972:	7f 07                	jg     897b <lodepng_chunk_find_const+0x21>
    8974:	b8 00 00 00 00       	mov    $0x0,%eax
    8979:	eb 2a                	jmp    89a5 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    897b:	ff 75 10             	pushl  0x10(%ebp)
    897e:	ff 75 08             	pushl  0x8(%ebp)
    8981:	e8 40 fc ff ff       	call   85c6 <lodepng_chunk_type_equals>
    8986:	83 c4 08             	add    $0x8,%esp
    8989:	84 c0                	test   %al,%al
    898b:	74 05                	je     8992 <lodepng_chunk_find_const+0x38>
    898d:	8b 45 08             	mov    0x8(%ebp),%eax
    8990:	eb 13                	jmp    89a5 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    8992:	ff 75 0c             	pushl  0xc(%ebp)
    8995:	ff 75 08             	pushl  0x8(%ebp)
    8998:	e8 9a fe ff ff       	call   8837 <lodepng_chunk_next_const>
    899d:	83 c4 08             	add    $0x8,%esp
    89a0:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    89a3:	eb b8                	jmp    895d <lodepng_chunk_find_const+0x3>
}
    89a5:	c9                   	leave  
    89a6:	c3                   	ret    

000089a7 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    89a7:	55                   	push   %ebp
    89a8:	89 e5                	mov    %esp,%ebp
    89aa:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    89ad:	ff 75 10             	pushl  0x10(%ebp)
    89b0:	e8 c4 fb ff ff       	call   8579 <lodepng_chunk_length>
    89b5:	83 c4 04             	add    $0x4,%esp
    89b8:	89 c2                	mov    %eax,%edx
    89ba:	8d 45 f0             	lea    -0x10(%ebp),%eax
    89bd:	50                   	push   %eax
    89be:	6a 0c                	push   $0xc
    89c0:	52                   	push   %edx
    89c1:	e8 f5 ac ff ff       	call   36bb <lodepng_addofl>
    89c6:	83 c4 0c             	add    $0xc,%esp
    89c9:	85 c0                	test   %eax,%eax
    89cb:	74 0a                	je     89d7 <lodepng_chunk_append+0x30>
    89cd:	b8 4d 00 00 00       	mov    $0x4d,%eax
    89d2:	e9 96 00 00 00       	jmp    8a6d <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    89d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    89da:	8b 45 0c             	mov    0xc(%ebp),%eax
    89dd:	8b 00                	mov    (%eax),%eax
    89df:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    89e2:	51                   	push   %ecx
    89e3:	52                   	push   %edx
    89e4:	50                   	push   %eax
    89e5:	e8 d1 ac ff ff       	call   36bb <lodepng_addofl>
    89ea:	83 c4 0c             	add    $0xc,%esp
    89ed:	85 c0                	test   %eax,%eax
    89ef:	74 07                	je     89f8 <lodepng_chunk_append+0x51>
    89f1:	b8 4d 00 00 00       	mov    $0x4d,%eax
    89f6:	eb 75                	jmp    8a6d <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    89f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    89fb:	8b 45 08             	mov    0x8(%ebp),%eax
    89fe:	8b 00                	mov    (%eax),%eax
    8a00:	52                   	push   %edx
    8a01:	50                   	push   %eax
    8a02:	e8 07 ac ff ff       	call   360e <lodepng_realloc>
    8a07:	83 c4 08             	add    $0x8,%esp
    8a0a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    8a0d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    8a11:	75 07                	jne    8a1a <lodepng_chunk_append+0x73>
    8a13:	b8 53 00 00 00       	mov    $0x53,%eax
    8a18:	eb 53                	jmp    8a6d <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8a1a:	8b 45 08             	mov    0x8(%ebp),%eax
    8a1d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8a20:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8a22:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8a25:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a28:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8a2a:	8b 45 08             	mov    0x8(%ebp),%eax
    8a2d:	8b 00                	mov    (%eax),%eax
    8a2f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8a32:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8a35:	29 d1                	sub    %edx,%ecx
    8a37:	89 ca                	mov    %ecx,%edx
    8a39:	01 d0                	add    %edx,%eax
    8a3b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    8a3e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8a45:	eb 19                	jmp    8a60 <lodepng_chunk_append+0xb9>
    8a47:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8a4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a4d:	01 c2                	add    %eax,%edx
    8a4f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8a52:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a55:	01 c8                	add    %ecx,%eax
    8a57:	0f b6 00             	movzbl (%eax),%eax
    8a5a:	88 02                	mov    %al,(%edx)
    8a5c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8a60:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8a63:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8a66:	75 df                	jne    8a47 <lodepng_chunk_append+0xa0>

  return 0;
    8a68:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8a6d:	c9                   	leave  
    8a6e:	c3                   	ret    

00008a6f <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    8a6f:	55                   	push   %ebp
    8a70:	89 e5                	mov    %esp,%ebp
    8a72:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    8a75:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a78:	8b 40 04             	mov    0x4(%eax),%eax
    8a7b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    8a7e:	8b 55 10             	mov    0x10(%ebp),%edx
    8a81:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a84:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    8a87:	51                   	push   %ecx
    8a88:	52                   	push   %edx
    8a89:	50                   	push   %eax
    8a8a:	e8 2c ac ff ff       	call   36bb <lodepng_addofl>
    8a8f:	83 c4 0c             	add    $0xc,%esp
    8a92:	85 c0                	test   %eax,%eax
    8a94:	74 07                	je     8a9d <lodepng_chunk_init+0x2e>
    8a96:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8a9b:	eb 78                	jmp    8b15 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8a9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8aa0:	8d 55 fc             	lea    -0x4(%ebp),%edx
    8aa3:	52                   	push   %edx
    8aa4:	6a 0c                	push   $0xc
    8aa6:	50                   	push   %eax
    8aa7:	e8 0f ac ff ff       	call   36bb <lodepng_addofl>
    8aac:	83 c4 0c             	add    $0xc,%esp
    8aaf:	85 c0                	test   %eax,%eax
    8ab1:	74 07                	je     8aba <lodepng_chunk_init+0x4b>
    8ab3:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8ab8:	eb 5b                	jmp    8b15 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8aba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8abd:	50                   	push   %eax
    8abe:	ff 75 0c             	pushl  0xc(%ebp)
    8ac1:	e8 8b ad ff ff       	call   3851 <ucvector_resize>
    8ac6:	83 c4 08             	add    $0x8,%esp
    8ac9:	85 c0                	test   %eax,%eax
    8acb:	75 07                	jne    8ad4 <lodepng_chunk_init+0x65>
    8acd:	b8 53 00 00 00       	mov    $0x53,%eax
    8ad2:	eb 41                	jmp    8b15 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    8ad4:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ad7:	8b 00                	mov    (%eax),%eax
    8ad9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8adc:	2b 55 10             	sub    0x10(%ebp),%edx
    8adf:	83 ea 0c             	sub    $0xc,%edx
    8ae2:	01 c2                	add    %eax,%edx
    8ae4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ae7:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8ae9:	8b 45 08             	mov    0x8(%ebp),%eax
    8aec:	8b 00                	mov    (%eax),%eax
    8aee:	ff 75 10             	pushl  0x10(%ebp)
    8af1:	50                   	push   %eax
    8af2:	e8 c1 ae ff ff       	call   39b8 <lodepng_set32bitInt>
    8af7:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8afa:	8b 45 08             	mov    0x8(%ebp),%eax
    8afd:	8b 00                	mov    (%eax),%eax
    8aff:	83 c0 04             	add    $0x4,%eax
    8b02:	6a 04                	push   $0x4
    8b04:	ff 75 14             	pushl  0x14(%ebp)
    8b07:	50                   	push   %eax
    8b08:	e8 28 ab ff ff       	call   3635 <lodepng_memcpy>
    8b0d:	83 c4 0c             	add    $0xc,%esp

  return 0;
    8b10:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b15:	c9                   	leave  
    8b16:	c3                   	ret    

00008b17 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8b17:	55                   	push   %ebp
    8b18:	89 e5                	mov    %esp,%ebp
    8b1a:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8b1d:	ff 75 10             	pushl  0x10(%ebp)
    8b20:	ff 75 0c             	pushl  0xc(%ebp)
    8b23:	ff 75 08             	pushl  0x8(%ebp)
    8b26:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8b29:	50                   	push   %eax
    8b2a:	e8 40 ff ff ff       	call   8a6f <lodepng_chunk_init>
    8b2f:	83 c4 10             	add    $0x10,%esp
    8b32:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8b35:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8b39:	74 05                	je     8b40 <lodepng_chunk_createv+0x29>
    8b3b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b3e:	eb 27                	jmp    8b67 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    8b40:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b43:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8b46:	83 c2 08             	add    $0x8,%edx
    8b49:	50                   	push   %eax
    8b4a:	ff 75 14             	pushl  0x14(%ebp)
    8b4d:	52                   	push   %edx
    8b4e:	e8 e2 aa ff ff       	call   3635 <lodepng_memcpy>
    8b53:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8b56:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8b59:	50                   	push   %eax
    8b5a:	e8 b9 fb ff ff       	call   8718 <lodepng_chunk_generate_crc>
    8b5f:	83 c4 04             	add    $0x4,%esp

  return 0;
    8b62:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b67:	c9                   	leave  
    8b68:	c3                   	ret    

00008b69 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8b69:	55                   	push   %ebp
    8b6a:	89 e5                	mov    %esp,%ebp
    8b6c:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8b6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b72:	8b 08                	mov    (%eax),%ecx
    8b74:	8b 45 08             	mov    0x8(%ebp),%eax
    8b77:	8b 10                	mov    (%eax),%edx
    8b79:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8b7c:	51                   	push   %ecx
    8b7d:	52                   	push   %edx
    8b7e:	50                   	push   %eax
    8b7f:	e8 34 ad ff ff       	call   38b8 <ucvector_init>
    8b84:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    8b87:	ff 75 18             	pushl  0x18(%ebp)
    8b8a:	ff 75 14             	pushl  0x14(%ebp)
    8b8d:	ff 75 10             	pushl  0x10(%ebp)
    8b90:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8b93:	50                   	push   %eax
    8b94:	e8 7e ff ff ff       	call   8b17 <lodepng_chunk_createv>
    8b99:	83 c4 10             	add    $0x10,%esp
    8b9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    8b9f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8ba2:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba5:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8ba7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8baa:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bad:	89 10                	mov    %edx,(%eax)
  return error;
    8baf:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8bb2:	c9                   	leave  
    8bb3:	c3                   	ret    

00008bb4 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    8bb4:	55                   	push   %ebp
    8bb5:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8bb7:	8b 45 08             	mov    0x8(%ebp),%eax
    8bba:	83 f8 03             	cmp    $0x3,%eax
    8bbd:	74 6d                	je     8c2c <checkColorValidity+0x78>
    8bbf:	83 f8 03             	cmp    $0x3,%eax
    8bc2:	77 0e                	ja     8bd2 <checkColorValidity+0x1e>
    8bc4:	85 c0                	test   %eax,%eax
    8bc6:	74 28                	je     8bf0 <checkColorValidity+0x3c>
    8bc8:	83 f8 02             	cmp    $0x2,%eax
    8bcb:	74 4c                	je     8c19 <checkColorValidity+0x65>
    8bcd:	e9 a6 00 00 00       	jmp    8c78 <checkColorValidity+0xc4>
    8bd2:	83 f8 06             	cmp    $0x6,%eax
    8bd5:	0f 84 83 00 00 00    	je     8c5e <checkColorValidity+0xaa>
    8bdb:	3d ff 00 00 00       	cmp    $0xff,%eax
    8be0:	0f 84 8b 00 00 00    	je     8c71 <checkColorValidity+0xbd>
    8be6:	83 f8 04             	cmp    $0x4,%eax
    8be9:	74 60                	je     8c4b <checkColorValidity+0x97>
    8beb:	e9 88 00 00 00       	jmp    8c78 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8bf0:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8bf4:	0f 84 85 00 00 00    	je     8c7f <checkColorValidity+0xcb>
    8bfa:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8bfe:	74 7f                	je     8c7f <checkColorValidity+0xcb>
    8c00:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8c04:	74 79                	je     8c7f <checkColorValidity+0xcb>
    8c06:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c0a:	74 73                	je     8c7f <checkColorValidity+0xcb>
    8c0c:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8c10:	74 6d                	je     8c7f <checkColorValidity+0xcb>
    8c12:	b8 25 00 00 00       	mov    $0x25,%eax
    8c17:	eb 78                	jmp    8c91 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c19:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c1d:	74 63                	je     8c82 <checkColorValidity+0xce>
    8c1f:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8c23:	74 5d                	je     8c82 <checkColorValidity+0xce>
    8c25:	b8 25 00 00 00       	mov    $0x25,%eax
    8c2a:	eb 65                	jmp    8c91 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8c2c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8c30:	74 53                	je     8c85 <checkColorValidity+0xd1>
    8c32:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8c36:	74 4d                	je     8c85 <checkColorValidity+0xd1>
    8c38:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8c3c:	74 47                	je     8c85 <checkColorValidity+0xd1>
    8c3e:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c42:	74 41                	je     8c85 <checkColorValidity+0xd1>
    8c44:	b8 25 00 00 00       	mov    $0x25,%eax
    8c49:	eb 46                	jmp    8c91 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c4b:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c4f:	74 37                	je     8c88 <checkColorValidity+0xd4>
    8c51:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8c55:	74 31                	je     8c88 <checkColorValidity+0xd4>
    8c57:	b8 25 00 00 00       	mov    $0x25,%eax
    8c5c:	eb 33                	jmp    8c91 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c5e:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c62:	74 27                	je     8c8b <checkColorValidity+0xd7>
    8c64:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8c68:	74 21                	je     8c8b <checkColorValidity+0xd7>
    8c6a:	b8 25 00 00 00       	mov    $0x25,%eax
    8c6f:	eb 20                	jmp    8c91 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8c71:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8c76:	eb 19                	jmp    8c91 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8c78:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8c7d:	eb 12                	jmp    8c91 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8c7f:	90                   	nop
    8c80:	eb 0a                	jmp    8c8c <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c82:	90                   	nop
    8c83:	eb 07                	jmp    8c8c <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8c85:	90                   	nop
    8c86:	eb 04                	jmp    8c8c <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c88:	90                   	nop
    8c89:	eb 01                	jmp    8c8c <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c8b:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8c8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8c91:	5d                   	pop    %ebp
    8c92:	c3                   	ret    

00008c93 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8c93:	55                   	push   %ebp
    8c94:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8c96:	8b 45 08             	mov    0x8(%ebp),%eax
    8c99:	83 f8 03             	cmp    $0x3,%eax
    8c9c:	74 31                	je     8ccf <getNumColorChannels+0x3c>
    8c9e:	83 f8 03             	cmp    $0x3,%eax
    8ca1:	77 0b                	ja     8cae <getNumColorChannels+0x1b>
    8ca3:	85 c0                	test   %eax,%eax
    8ca5:	74 1a                	je     8cc1 <getNumColorChannels+0x2e>
    8ca7:	83 f8 02             	cmp    $0x2,%eax
    8caa:	74 1c                	je     8cc8 <getNumColorChannels+0x35>
    8cac:	eb 3d                	jmp    8ceb <getNumColorChannels+0x58>
    8cae:	83 f8 06             	cmp    $0x6,%eax
    8cb1:	74 2a                	je     8cdd <getNumColorChannels+0x4a>
    8cb3:	3d ff 00 00 00       	cmp    $0xff,%eax
    8cb8:	74 2a                	je     8ce4 <getNumColorChannels+0x51>
    8cba:	83 f8 04             	cmp    $0x4,%eax
    8cbd:	74 17                	je     8cd6 <getNumColorChannels+0x43>
    8cbf:	eb 2a                	jmp    8ceb <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8cc1:	b8 01 00 00 00       	mov    $0x1,%eax
    8cc6:	eb 28                	jmp    8cf0 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8cc8:	b8 03 00 00 00       	mov    $0x3,%eax
    8ccd:	eb 21                	jmp    8cf0 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8ccf:	b8 01 00 00 00       	mov    $0x1,%eax
    8cd4:	eb 1a                	jmp    8cf0 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8cd6:	b8 02 00 00 00       	mov    $0x2,%eax
    8cdb:	eb 13                	jmp    8cf0 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8cdd:	b8 04 00 00 00       	mov    $0x4,%eax
    8ce2:	eb 0c                	jmp    8cf0 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8ce4:	b8 00 00 00 00       	mov    $0x0,%eax
    8ce9:	eb 05                	jmp    8cf0 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8ceb:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8cf0:	5d                   	pop    %ebp
    8cf1:	c3                   	ret    

00008cf2 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8cf2:	55                   	push   %ebp
    8cf3:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8cf5:	ff 75 08             	pushl  0x8(%ebp)
    8cf8:	e8 96 ff ff ff       	call   8c93 <getNumColorChannels>
    8cfd:	83 c4 04             	add    $0x4,%esp
    8d00:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8d04:	c9                   	leave  
    8d05:	c3                   	ret    

00008d06 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8d06:	55                   	push   %ebp
    8d07:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8d09:	8b 45 08             	mov    0x8(%ebp),%eax
    8d0c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8d13:	8b 45 08             	mov    0x8(%ebp),%eax
    8d16:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8d1d:	8b 45 08             	mov    0x8(%ebp),%eax
    8d20:	8b 50 1c             	mov    0x1c(%eax),%edx
    8d23:	8b 45 08             	mov    0x8(%ebp),%eax
    8d26:	89 50 18             	mov    %edx,0x18(%eax)
    8d29:	8b 45 08             	mov    0x8(%ebp),%eax
    8d2c:	8b 50 18             	mov    0x18(%eax),%edx
    8d2f:	8b 45 08             	mov    0x8(%ebp),%eax
    8d32:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8d35:	8b 45 08             	mov    0x8(%ebp),%eax
    8d38:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8d3e:	8b 45 08             	mov    0x8(%ebp),%eax
    8d41:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8d48:	8b 45 08             	mov    0x8(%ebp),%eax
    8d4b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8d52:	8b 45 08             	mov    0x8(%ebp),%eax
    8d55:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8d5c:	90                   	nop
    8d5d:	5d                   	pop    %ebp
    8d5e:	c3                   	ret    

00008d5f <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8d5f:	55                   	push   %ebp
    8d60:	89 e5                	mov    %esp,%ebp
    8d62:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8d65:	8b 45 08             	mov    0x8(%ebp),%eax
    8d68:	8b 40 08             	mov    0x8(%eax),%eax
    8d6b:	85 c0                	test   %eax,%eax
    8d6d:	75 18                	jne    8d87 <lodepng_color_mode_alloc_palette+0x28>
    8d6f:	83 ec 0c             	sub    $0xc,%esp
    8d72:	68 00 04 00 00       	push   $0x400
    8d77:	e8 7b a8 ff ff       	call   35f7 <lodepng_malloc>
    8d7c:	83 c4 10             	add    $0x10,%esp
    8d7f:	89 c2                	mov    %eax,%edx
    8d81:	8b 45 08             	mov    0x8(%ebp),%eax
    8d84:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8d87:	8b 45 08             	mov    0x8(%ebp),%eax
    8d8a:	8b 40 08             	mov    0x8(%eax),%eax
    8d8d:	85 c0                	test   %eax,%eax
    8d8f:	74 65                	je     8df6 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8d91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8d98:	eb 51                	jmp    8deb <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8d9a:	8b 45 08             	mov    0x8(%ebp),%eax
    8d9d:	8b 40 08             	mov    0x8(%eax),%eax
    8da0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8da3:	c1 e2 02             	shl    $0x2,%edx
    8da6:	01 d0                	add    %edx,%eax
    8da8:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8dab:	8b 45 08             	mov    0x8(%ebp),%eax
    8dae:	8b 40 08             	mov    0x8(%eax),%eax
    8db1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8db4:	c1 e2 02             	shl    $0x2,%edx
    8db7:	83 c2 01             	add    $0x1,%edx
    8dba:	01 d0                	add    %edx,%eax
    8dbc:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8dbf:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc2:	8b 40 08             	mov    0x8(%eax),%eax
    8dc5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8dc8:	c1 e2 02             	shl    $0x2,%edx
    8dcb:	83 c2 02             	add    $0x2,%edx
    8dce:	01 d0                	add    %edx,%eax
    8dd0:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8dd3:	8b 45 08             	mov    0x8(%ebp),%eax
    8dd6:	8b 40 08             	mov    0x8(%eax),%eax
    8dd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ddc:	c1 e2 02             	shl    $0x2,%edx
    8ddf:	83 c2 03             	add    $0x3,%edx
    8de2:	01 d0                	add    %edx,%eax
    8de4:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8de7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8deb:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8df2:	75 a6                	jne    8d9a <lodepng_color_mode_alloc_palette+0x3b>
    8df4:	eb 01                	jmp    8df7 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8df6:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8df7:	c9                   	leave  
    8df8:	c3                   	ret    

00008df9 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8df9:	55                   	push   %ebp
    8dfa:	89 e5                	mov    %esp,%ebp
    8dfc:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8dff:	83 ec 0c             	sub    $0xc,%esp
    8e02:	ff 75 08             	pushl  0x8(%ebp)
    8e05:	e8 f3 01 00 00       	call   8ffd <lodepng_palette_clear>
    8e0a:	83 c4 10             	add    $0x10,%esp
}
    8e0d:	90                   	nop
    8e0e:	c9                   	leave  
    8e0f:	c3                   	ret    

00008e10 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8e10:	55                   	push   %ebp
    8e11:	89 e5                	mov    %esp,%ebp
    8e13:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8e16:	83 ec 0c             	sub    $0xc,%esp
    8e19:	ff 75 08             	pushl  0x8(%ebp)
    8e1c:	e8 d8 ff ff ff       	call   8df9 <lodepng_color_mode_cleanup>
    8e21:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8e24:	83 ec 04             	sub    $0x4,%esp
    8e27:	6a 20                	push   $0x20
    8e29:	ff 75 0c             	pushl  0xc(%ebp)
    8e2c:	ff 75 08             	pushl  0x8(%ebp)
    8e2f:	e8 01 a8 ff ff       	call   3635 <lodepng_memcpy>
    8e34:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8e37:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e3a:	8b 40 08             	mov    0x8(%eax),%eax
    8e3d:	85 c0                	test   %eax,%eax
    8e3f:	74 5a                	je     8e9b <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8e41:	83 ec 0c             	sub    $0xc,%esp
    8e44:	68 00 04 00 00       	push   $0x400
    8e49:	e8 a9 a7 ff ff       	call   35f7 <lodepng_malloc>
    8e4e:	83 c4 10             	add    $0x10,%esp
    8e51:	89 c2                	mov    %eax,%edx
    8e53:	8b 45 08             	mov    0x8(%ebp),%eax
    8e56:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8e59:	8b 45 08             	mov    0x8(%ebp),%eax
    8e5c:	8b 40 08             	mov    0x8(%eax),%eax
    8e5f:	85 c0                	test   %eax,%eax
    8e61:	75 11                	jne    8e74 <lodepng_color_mode_copy+0x64>
    8e63:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e66:	8b 40 0c             	mov    0xc(%eax),%eax
    8e69:	85 c0                	test   %eax,%eax
    8e6b:	74 07                	je     8e74 <lodepng_color_mode_copy+0x64>
    8e6d:	b8 53 00 00 00       	mov    $0x53,%eax
    8e72:	eb 2c                	jmp    8ea0 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8e74:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e77:	8b 40 0c             	mov    0xc(%eax),%eax
    8e7a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8e81:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e84:	8b 50 08             	mov    0x8(%eax),%edx
    8e87:	8b 45 08             	mov    0x8(%ebp),%eax
    8e8a:	8b 40 08             	mov    0x8(%eax),%eax
    8e8d:	83 ec 04             	sub    $0x4,%esp
    8e90:	51                   	push   %ecx
    8e91:	52                   	push   %edx
    8e92:	50                   	push   %eax
    8e93:	e8 9d a7 ff ff       	call   3635 <lodepng_memcpy>
    8e98:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8e9b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8ea0:	c9                   	leave  
    8ea1:	c3                   	ret    

00008ea2 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8ea2:	55                   	push   %ebp
    8ea3:	89 e5                	mov    %esp,%ebp
    8ea5:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8ea8:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8eab:	50                   	push   %eax
    8eac:	e8 55 fe ff ff       	call   8d06 <lodepng_color_mode_init>
    8eb1:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8eb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    8eb7:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8eba:	8b 45 10             	mov    0x10(%ebp),%eax
    8ebd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8ec0:	8b 45 08             	mov    0x8(%ebp),%eax
    8ec3:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8ec6:	89 10                	mov    %edx,(%eax)
    8ec8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8ecb:	89 50 04             	mov    %edx,0x4(%eax)
    8ece:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8ed1:	89 50 08             	mov    %edx,0x8(%eax)
    8ed4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8ed7:	89 50 0c             	mov    %edx,0xc(%eax)
    8eda:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8edd:	89 50 10             	mov    %edx,0x10(%eax)
    8ee0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ee3:	89 50 14             	mov    %edx,0x14(%eax)
    8ee6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8ee9:	89 50 18             	mov    %edx,0x18(%eax)
    8eec:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8eef:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8ef2:	8b 45 08             	mov    0x8(%ebp),%eax
    8ef5:	c9                   	leave  
    8ef6:	c2 04 00             	ret    $0x4

00008ef9 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8ef9:	55                   	push   %ebp
    8efa:	89 e5                	mov    %esp,%ebp
    8efc:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8eff:	8b 45 08             	mov    0x8(%ebp),%eax
    8f02:	8b 10                	mov    (%eax),%edx
    8f04:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f07:	8b 00                	mov    (%eax),%eax
    8f09:	39 c2                	cmp    %eax,%edx
    8f0b:	74 0a                	je     8f17 <lodepng_color_mode_equal+0x1e>
    8f0d:	b8 00 00 00 00       	mov    $0x0,%eax
    8f12:	e9 e4 00 00 00       	jmp    8ffb <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8f17:	8b 45 08             	mov    0x8(%ebp),%eax
    8f1a:	8b 50 04             	mov    0x4(%eax),%edx
    8f1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f20:	8b 40 04             	mov    0x4(%eax),%eax
    8f23:	39 c2                	cmp    %eax,%edx
    8f25:	74 0a                	je     8f31 <lodepng_color_mode_equal+0x38>
    8f27:	b8 00 00 00 00       	mov    $0x0,%eax
    8f2c:	e9 ca 00 00 00       	jmp    8ffb <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8f31:	8b 45 08             	mov    0x8(%ebp),%eax
    8f34:	8b 50 10             	mov    0x10(%eax),%edx
    8f37:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f3a:	8b 40 10             	mov    0x10(%eax),%eax
    8f3d:	39 c2                	cmp    %eax,%edx
    8f3f:	74 0a                	je     8f4b <lodepng_color_mode_equal+0x52>
    8f41:	b8 00 00 00 00       	mov    $0x0,%eax
    8f46:	e9 b0 00 00 00       	jmp    8ffb <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8f4b:	8b 45 08             	mov    0x8(%ebp),%eax
    8f4e:	8b 40 10             	mov    0x10(%eax),%eax
    8f51:	85 c0                	test   %eax,%eax
    8f53:	74 48                	je     8f9d <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8f55:	8b 45 08             	mov    0x8(%ebp),%eax
    8f58:	8b 50 14             	mov    0x14(%eax),%edx
    8f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f5e:	8b 40 14             	mov    0x14(%eax),%eax
    8f61:	39 c2                	cmp    %eax,%edx
    8f63:	74 0a                	je     8f6f <lodepng_color_mode_equal+0x76>
    8f65:	b8 00 00 00 00       	mov    $0x0,%eax
    8f6a:	e9 8c 00 00 00       	jmp    8ffb <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8f6f:	8b 45 08             	mov    0x8(%ebp),%eax
    8f72:	8b 50 18             	mov    0x18(%eax),%edx
    8f75:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f78:	8b 40 18             	mov    0x18(%eax),%eax
    8f7b:	39 c2                	cmp    %eax,%edx
    8f7d:	74 07                	je     8f86 <lodepng_color_mode_equal+0x8d>
    8f7f:	b8 00 00 00 00       	mov    $0x0,%eax
    8f84:	eb 75                	jmp    8ffb <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8f86:	8b 45 08             	mov    0x8(%ebp),%eax
    8f89:	8b 50 1c             	mov    0x1c(%eax),%edx
    8f8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f8f:	8b 40 1c             	mov    0x1c(%eax),%eax
    8f92:	39 c2                	cmp    %eax,%edx
    8f94:	74 07                	je     8f9d <lodepng_color_mode_equal+0xa4>
    8f96:	b8 00 00 00 00       	mov    $0x0,%eax
    8f9b:	eb 5e                	jmp    8ffb <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8f9d:	8b 45 08             	mov    0x8(%ebp),%eax
    8fa0:	8b 50 0c             	mov    0xc(%eax),%edx
    8fa3:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fa6:	8b 40 0c             	mov    0xc(%eax),%eax
    8fa9:	39 c2                	cmp    %eax,%edx
    8fab:	74 07                	je     8fb4 <lodepng_color_mode_equal+0xbb>
    8fad:	b8 00 00 00 00       	mov    $0x0,%eax
    8fb2:	eb 47                	jmp    8ffb <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8fb4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8fbb:	eb 2b                	jmp    8fe8 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8fbd:	8b 45 08             	mov    0x8(%ebp),%eax
    8fc0:	8b 50 08             	mov    0x8(%eax),%edx
    8fc3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8fc6:	01 d0                	add    %edx,%eax
    8fc8:	0f b6 10             	movzbl (%eax),%edx
    8fcb:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fce:	8b 48 08             	mov    0x8(%eax),%ecx
    8fd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8fd4:	01 c8                	add    %ecx,%eax
    8fd6:	0f b6 00             	movzbl (%eax),%eax
    8fd9:	38 c2                	cmp    %al,%dl
    8fdb:	74 07                	je     8fe4 <lodepng_color_mode_equal+0xeb>
    8fdd:	b8 00 00 00 00       	mov    $0x0,%eax
    8fe2:	eb 17                	jmp    8ffb <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8fe4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8fe8:	8b 45 08             	mov    0x8(%ebp),%eax
    8feb:	8b 40 0c             	mov    0xc(%eax),%eax
    8fee:	c1 e0 02             	shl    $0x2,%eax
    8ff1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8ff4:	75 c7                	jne    8fbd <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8ff6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8ffb:	c9                   	leave  
    8ffc:	c3                   	ret    

00008ffd <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8ffd:	55                   	push   %ebp
    8ffe:	89 e5                	mov    %esp,%ebp
    9000:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    9003:	8b 45 08             	mov    0x8(%ebp),%eax
    9006:	8b 40 08             	mov    0x8(%eax),%eax
    9009:	85 c0                	test   %eax,%eax
    900b:	74 12                	je     901f <lodepng_palette_clear+0x22>
    900d:	8b 45 08             	mov    0x8(%ebp),%eax
    9010:	8b 40 08             	mov    0x8(%eax),%eax
    9013:	83 ec 0c             	sub    $0xc,%esp
    9016:	50                   	push   %eax
    9017:	e8 fc a5 ff ff       	call   3618 <lodepng_free>
    901c:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    901f:	8b 45 08             	mov    0x8(%ebp),%eax
    9022:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    9029:	8b 45 08             	mov    0x8(%ebp),%eax
    902c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    9033:	90                   	nop
    9034:	c9                   	leave  
    9035:	c3                   	ret    

00009036 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9036:	55                   	push   %ebp
    9037:	89 e5                	mov    %esp,%ebp
    9039:	53                   	push   %ebx
    903a:	83 ec 14             	sub    $0x14,%esp
    903d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9040:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9043:	8b 55 14             	mov    0x14(%ebp),%edx
    9046:	8b 45 18             	mov    0x18(%ebp),%eax
    9049:	88 5d f4             	mov    %bl,-0xc(%ebp)
    904c:	88 4d f0             	mov    %cl,-0x10(%ebp)
    904f:	88 55 ec             	mov    %dl,-0x14(%ebp)
    9052:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    9055:	8b 45 08             	mov    0x8(%ebp),%eax
    9058:	8b 40 08             	mov    0x8(%eax),%eax
    905b:	85 c0                	test   %eax,%eax
    905d:	75 22                	jne    9081 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    905f:	83 ec 0c             	sub    $0xc,%esp
    9062:	ff 75 08             	pushl  0x8(%ebp)
    9065:	e8 f5 fc ff ff       	call   8d5f <lodepng_color_mode_alloc_palette>
    906a:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    906d:	8b 45 08             	mov    0x8(%ebp),%eax
    9070:	8b 40 08             	mov    0x8(%eax),%eax
    9073:	85 c0                	test   %eax,%eax
    9075:	75 0a                	jne    9081 <lodepng_palette_add+0x4b>
    9077:	b8 53 00 00 00       	mov    $0x53,%eax
    907c:	e9 8d 00 00 00       	jmp    910e <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    9081:	8b 45 08             	mov    0x8(%ebp),%eax
    9084:	8b 40 0c             	mov    0xc(%eax),%eax
    9087:	3d ff 00 00 00       	cmp    $0xff,%eax
    908c:	7e 07                	jle    9095 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    908e:	b8 6c 00 00 00       	mov    $0x6c,%eax
    9093:	eb 79                	jmp    910e <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    9095:	8b 45 08             	mov    0x8(%ebp),%eax
    9098:	8b 50 08             	mov    0x8(%eax),%edx
    909b:	8b 45 08             	mov    0x8(%ebp),%eax
    909e:	8b 40 0c             	mov    0xc(%eax),%eax
    90a1:	c1 e0 02             	shl    $0x2,%eax
    90a4:	01 c2                	add    %eax,%edx
    90a6:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    90aa:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    90ac:	8b 45 08             	mov    0x8(%ebp),%eax
    90af:	8b 50 08             	mov    0x8(%eax),%edx
    90b2:	8b 45 08             	mov    0x8(%ebp),%eax
    90b5:	8b 40 0c             	mov    0xc(%eax),%eax
    90b8:	c1 e0 02             	shl    $0x2,%eax
    90bb:	83 c0 01             	add    $0x1,%eax
    90be:	01 c2                	add    %eax,%edx
    90c0:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    90c4:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    90c6:	8b 45 08             	mov    0x8(%ebp),%eax
    90c9:	8b 50 08             	mov    0x8(%eax),%edx
    90cc:	8b 45 08             	mov    0x8(%ebp),%eax
    90cf:	8b 40 0c             	mov    0xc(%eax),%eax
    90d2:	c1 e0 02             	shl    $0x2,%eax
    90d5:	83 c0 02             	add    $0x2,%eax
    90d8:	01 c2                	add    %eax,%edx
    90da:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    90de:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    90e0:	8b 45 08             	mov    0x8(%ebp),%eax
    90e3:	8b 50 08             	mov    0x8(%eax),%edx
    90e6:	8b 45 08             	mov    0x8(%ebp),%eax
    90e9:	8b 40 0c             	mov    0xc(%eax),%eax
    90ec:	c1 e0 02             	shl    $0x2,%eax
    90ef:	83 c0 03             	add    $0x3,%eax
    90f2:	01 c2                	add    %eax,%edx
    90f4:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    90f8:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    90fa:	8b 45 08             	mov    0x8(%ebp),%eax
    90fd:	8b 40 0c             	mov    0xc(%eax),%eax
    9100:	8d 50 01             	lea    0x1(%eax),%edx
    9103:	8b 45 08             	mov    0x8(%ebp),%eax
    9106:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    9109:	b8 00 00 00 00       	mov    $0x0,%eax
}
    910e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9111:	c9                   	leave  
    9112:	c3                   	ret    

00009113 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    9113:	55                   	push   %ebp
    9114:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    9116:	8b 45 08             	mov    0x8(%ebp),%eax
    9119:	8b 50 04             	mov    0x4(%eax),%edx
    911c:	8b 45 08             	mov    0x8(%ebp),%eax
    911f:	8b 00                	mov    (%eax),%eax
    9121:	52                   	push   %edx
    9122:	50                   	push   %eax
    9123:	e8 ca fb ff ff       	call   8cf2 <lodepng_get_bpp_lct>
    9128:	83 c4 08             	add    $0x8,%esp
}
    912b:	c9                   	leave  
    912c:	c3                   	ret    

0000912d <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    912d:	55                   	push   %ebp
    912e:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    9130:	8b 45 08             	mov    0x8(%ebp),%eax
    9133:	8b 00                	mov    (%eax),%eax
    9135:	50                   	push   %eax
    9136:	e8 58 fb ff ff       	call   8c93 <getNumColorChannels>
    913b:	83 c4 04             	add    $0x4,%esp
}
    913e:	c9                   	leave  
    913f:	c3                   	ret    

00009140 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    9140:	55                   	push   %ebp
    9141:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    9143:	8b 45 08             	mov    0x8(%ebp),%eax
    9146:	8b 00                	mov    (%eax),%eax
    9148:	85 c0                	test   %eax,%eax
    914a:	74 0a                	je     9156 <lodepng_is_greyscale_type+0x16>
    914c:	8b 45 08             	mov    0x8(%ebp),%eax
    914f:	8b 00                	mov    (%eax),%eax
    9151:	83 f8 04             	cmp    $0x4,%eax
    9154:	75 07                	jne    915d <lodepng_is_greyscale_type+0x1d>
    9156:	b8 01 00 00 00       	mov    $0x1,%eax
    915b:	eb 05                	jmp    9162 <lodepng_is_greyscale_type+0x22>
    915d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9162:	5d                   	pop    %ebp
    9163:	c3                   	ret    

00009164 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    9164:	55                   	push   %ebp
    9165:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    9167:	8b 45 08             	mov    0x8(%ebp),%eax
    916a:	8b 00                	mov    (%eax),%eax
    916c:	83 e0 04             	and    $0x4,%eax
    916f:	85 c0                	test   %eax,%eax
    9171:	0f 95 c0             	setne  %al
    9174:	0f b6 c0             	movzbl %al,%eax
}
    9177:	5d                   	pop    %ebp
    9178:	c3                   	ret    

00009179 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    9179:	55                   	push   %ebp
    917a:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    917c:	8b 45 08             	mov    0x8(%ebp),%eax
    917f:	8b 00                	mov    (%eax),%eax
    9181:	83 f8 03             	cmp    $0x3,%eax
    9184:	0f 94 c0             	sete   %al
    9187:	0f b6 c0             	movzbl %al,%eax
}
    918a:	5d                   	pop    %ebp
    918b:	c3                   	ret    

0000918c <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    918c:	55                   	push   %ebp
    918d:	89 e5                	mov    %esp,%ebp
    918f:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9192:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9199:	eb 23                	jmp    91be <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    919b:	8b 45 08             	mov    0x8(%ebp),%eax
    919e:	8b 40 08             	mov    0x8(%eax),%eax
    91a1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    91a4:	c1 e2 02             	shl    $0x2,%edx
    91a7:	83 c2 03             	add    $0x3,%edx
    91aa:	01 d0                	add    %edx,%eax
    91ac:	0f b6 00             	movzbl (%eax),%eax
    91af:	3c ff                	cmp    $0xff,%al
    91b1:	74 07                	je     91ba <lodepng_has_palette_alpha+0x2e>
    91b3:	b8 01 00 00 00       	mov    $0x1,%eax
    91b8:	eb 14                	jmp    91ce <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    91ba:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    91be:	8b 45 08             	mov    0x8(%ebp),%eax
    91c1:	8b 40 0c             	mov    0xc(%eax),%eax
    91c4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    91c7:	75 d2                	jne    919b <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    91c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    91ce:	c9                   	leave  
    91cf:	c3                   	ret    

000091d0 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    91d0:	55                   	push   %ebp
    91d1:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    91d3:	8b 45 08             	mov    0x8(%ebp),%eax
    91d6:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    91d9:	85 c0                	test   %eax,%eax
    91db:	75 1e                	jne    91fb <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    91dd:	ff 75 08             	pushl  0x8(%ebp)
    91e0:	e8 7f ff ff ff       	call   9164 <lodepng_is_alpha_type>
    91e5:	83 c4 04             	add    $0x4,%esp
    91e8:	85 c0                	test   %eax,%eax
    91ea:	75 0f                	jne    91fb <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    91ec:	ff 75 08             	pushl  0x8(%ebp)
    91ef:	e8 98 ff ff ff       	call   918c <lodepng_has_palette_alpha>
    91f4:	83 c4 04             	add    $0x4,%esp
    91f7:	85 c0                	test   %eax,%eax
    91f9:	74 07                	je     9202 <lodepng_can_have_alpha+0x32>
    91fb:	b8 01 00 00 00       	mov    $0x1,%eax
    9200:	eb 05                	jmp    9207 <lodepng_can_have_alpha+0x37>
    9202:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9207:	c9                   	leave  
    9208:	c3                   	ret    

00009209 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    9209:	55                   	push   %ebp
    920a:	89 e5                	mov    %esp,%ebp
    920c:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    920f:	ff 75 14             	pushl  0x14(%ebp)
    9212:	ff 75 10             	pushl  0x10(%ebp)
    9215:	e8 d8 fa ff ff       	call   8cf2 <lodepng_get_bpp_lct>
    921a:	83 c4 08             	add    $0x8,%esp
    921d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    9220:	8b 55 08             	mov    0x8(%ebp),%edx
    9223:	8b 45 0c             	mov    0xc(%ebp),%eax
    9226:	0f af c2             	imul   %edx,%eax
    9229:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    922c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    922f:	c1 e8 03             	shr    $0x3,%eax
    9232:	89 c2                	mov    %eax,%edx
    9234:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9237:	0f af c2             	imul   %edx,%eax
    923a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    923d:	89 d1                	mov    %edx,%ecx
    923f:	83 e1 07             	and    $0x7,%ecx
    9242:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9245:	0f af d1             	imul   %ecx,%edx
    9248:	83 c2 07             	add    $0x7,%edx
    924b:	c1 ea 03             	shr    $0x3,%edx
    924e:	01 d0                	add    %edx,%eax
}
    9250:	c9                   	leave  
    9251:	c3                   	ret    

00009252 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    9252:	55                   	push   %ebp
    9253:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    9255:	8b 45 10             	mov    0x10(%ebp),%eax
    9258:	8b 50 04             	mov    0x4(%eax),%edx
    925b:	8b 45 10             	mov    0x10(%ebp),%eax
    925e:	8b 00                	mov    (%eax),%eax
    9260:	52                   	push   %edx
    9261:	50                   	push   %eax
    9262:	ff 75 0c             	pushl  0xc(%ebp)
    9265:	ff 75 08             	pushl  0x8(%ebp)
    9268:	e8 9c ff ff ff       	call   9209 <lodepng_get_raw_size_lct>
    926d:	83 c4 10             	add    $0x10,%esp
}
    9270:	c9                   	leave  
    9271:	c3                   	ret    

00009272 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    9272:	55                   	push   %ebp
    9273:	89 e5                	mov    %esp,%ebp
    9275:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    9278:	8b 45 08             	mov    0x8(%ebp),%eax
    927b:	c1 e8 03             	shr    $0x3,%eax
    927e:	0f af 45 10          	imul   0x10(%ebp),%eax
    9282:	8b 55 08             	mov    0x8(%ebp),%edx
    9285:	83 e2 07             	and    $0x7,%edx
    9288:	0f af 55 10          	imul   0x10(%ebp),%edx
    928c:	83 c2 07             	add    $0x7,%edx
    928f:	c1 ea 03             	shr    $0x3,%edx
    9292:	01 d0                	add    %edx,%eax
    9294:	83 c0 01             	add    $0x1,%eax
    9297:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    929a:	8b 45 0c             	mov    0xc(%ebp),%eax
    929d:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    92a1:	c9                   	leave  
    92a2:	c3                   	ret    

000092a3 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    92a3:	55                   	push   %ebp
    92a4:	89 e5                	mov    %esp,%ebp
    92a6:	53                   	push   %ebx
    92a7:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    92aa:	ff 75 10             	pushl  0x10(%ebp)
    92ad:	e8 61 fe ff ff       	call   9113 <lodepng_get_bpp>
    92b2:	83 c4 04             	add    $0x4,%esp
    92b5:	89 c3                	mov    %eax,%ebx
    92b7:	ff 75 14             	pushl  0x14(%ebp)
    92ba:	e8 54 fe ff ff       	call   9113 <lodepng_get_bpp>
    92bf:	83 c4 04             	add    $0x4,%esp
    92c2:	39 c3                	cmp    %eax,%ebx
    92c4:	76 0d                	jbe    92d3 <lodepng_pixel_overflow+0x30>
    92c6:	ff 75 10             	pushl  0x10(%ebp)
    92c9:	e8 45 fe ff ff       	call   9113 <lodepng_get_bpp>
    92ce:	83 c4 04             	add    $0x4,%esp
    92d1:	eb 0b                	jmp    92de <lodepng_pixel_overflow+0x3b>
    92d3:	ff 75 14             	pushl  0x14(%ebp)
    92d6:	e8 38 fe ff ff       	call   9113 <lodepng_get_bpp>
    92db:	83 c4 04             	add    $0x4,%esp
    92de:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    92e1:	8b 55 0c             	mov    0xc(%ebp),%edx
    92e4:	8b 45 08             	mov    0x8(%ebp),%eax
    92e7:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    92ea:	51                   	push   %ecx
    92eb:	52                   	push   %edx
    92ec:	50                   	push   %eax
    92ed:	e8 e9 a3 ff ff       	call   36db <lodepng_mulofl>
    92f2:	83 c4 0c             	add    $0xc,%esp
    92f5:	85 c0                	test   %eax,%eax
    92f7:	74 0a                	je     9303 <lodepng_pixel_overflow+0x60>
    92f9:	b8 01 00 00 00       	mov    $0x1,%eax
    92fe:	e9 b6 00 00 00       	jmp    93b9 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    9303:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9306:	8d 55 f0             	lea    -0x10(%ebp),%edx
    9309:	52                   	push   %edx
    930a:	6a 08                	push   $0x8
    930c:	50                   	push   %eax
    930d:	e8 c9 a3 ff ff       	call   36db <lodepng_mulofl>
    9312:	83 c4 0c             	add    $0xc,%esp
    9315:	85 c0                	test   %eax,%eax
    9317:	74 0a                	je     9323 <lodepng_pixel_overflow+0x80>
    9319:	b8 01 00 00 00       	mov    $0x1,%eax
    931e:	e9 96 00 00 00       	jmp    93b9 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    9323:	8b 45 08             	mov    0x8(%ebp),%eax
    9326:	c1 e8 03             	shr    $0x3,%eax
    9329:	89 c2                	mov    %eax,%edx
    932b:	8d 45 ec             	lea    -0x14(%ebp),%eax
    932e:	50                   	push   %eax
    932f:	ff 75 f8             	pushl  -0x8(%ebp)
    9332:	52                   	push   %edx
    9333:	e8 a3 a3 ff ff       	call   36db <lodepng_mulofl>
    9338:	83 c4 0c             	add    $0xc,%esp
    933b:	85 c0                	test   %eax,%eax
    933d:	74 07                	je     9346 <lodepng_pixel_overflow+0xa3>
    933f:	b8 01 00 00 00       	mov    $0x1,%eax
    9344:	eb 73                	jmp    93b9 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9346:	8b 45 08             	mov    0x8(%ebp),%eax
    9349:	83 e0 07             	and    $0x7,%eax
    934c:	89 c2                	mov    %eax,%edx
    934e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9351:	0f af c2             	imul   %edx,%eax
    9354:	83 c0 07             	add    $0x7,%eax
    9357:	c1 e8 03             	shr    $0x3,%eax
    935a:	89 c1                	mov    %eax,%ecx
    935c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    935f:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9362:	52                   	push   %edx
    9363:	51                   	push   %ecx
    9364:	50                   	push   %eax
    9365:	e8 51 a3 ff ff       	call   36bb <lodepng_addofl>
    936a:	83 c4 0c             	add    $0xc,%esp
    936d:	85 c0                	test   %eax,%eax
    936f:	74 07                	je     9378 <lodepng_pixel_overflow+0xd5>
    9371:	b8 01 00 00 00       	mov    $0x1,%eax
    9376:	eb 41                	jmp    93b9 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9378:	8b 45 ec             	mov    -0x14(%ebp),%eax
    937b:	8d 55 ec             	lea    -0x14(%ebp),%edx
    937e:	52                   	push   %edx
    937f:	6a 05                	push   $0x5
    9381:	50                   	push   %eax
    9382:	e8 34 a3 ff ff       	call   36bb <lodepng_addofl>
    9387:	83 c4 0c             	add    $0xc,%esp
    938a:	85 c0                	test   %eax,%eax
    938c:	74 07                	je     9395 <lodepng_pixel_overflow+0xf2>
    938e:	b8 01 00 00 00       	mov    $0x1,%eax
    9393:	eb 24                	jmp    93b9 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    9395:	8b 55 0c             	mov    0xc(%ebp),%edx
    9398:	8b 45 ec             	mov    -0x14(%ebp),%eax
    939b:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    939e:	51                   	push   %ecx
    939f:	52                   	push   %edx
    93a0:	50                   	push   %eax
    93a1:	e8 35 a3 ff ff       	call   36db <lodepng_mulofl>
    93a6:	83 c4 0c             	add    $0xc,%esp
    93a9:	85 c0                	test   %eax,%eax
    93ab:	74 07                	je     93b4 <lodepng_pixel_overflow+0x111>
    93ad:	b8 01 00 00 00       	mov    $0x1,%eax
    93b2:	eb 05                	jmp    93b9 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    93b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    93b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    93bc:	c9                   	leave  
    93bd:	c3                   	ret    

000093be <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    93be:	55                   	push   %ebp
    93bf:	89 e5                	mov    %esp,%ebp
    93c1:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    93c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    93cb:	eb 15                	jmp    93e2 <LodePNGUnknownChunks_init+0x24>
    93cd:	8b 45 08             	mov    0x8(%ebp),%eax
    93d0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    93d3:	83 c2 30             	add    $0x30,%edx
    93d6:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    93dd:	00 
    93de:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    93e2:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    93e6:	75 e5                	jne    93cd <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    93e8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    93ef:	eb 15                	jmp    9406 <LodePNGUnknownChunks_init+0x48>
    93f1:	8b 45 08             	mov    0x8(%ebp),%eax
    93f4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    93f7:	83 c2 34             	add    $0x34,%edx
    93fa:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    9401:	00 
    9402:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9406:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    940a:	75 e5                	jne    93f1 <LodePNGUnknownChunks_init+0x33>
}
    940c:	90                   	nop
    940d:	c9                   	leave  
    940e:	c3                   	ret    

0000940f <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    940f:	55                   	push   %ebp
    9410:	89 e5                	mov    %esp,%ebp
    9412:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    9415:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    941c:	eb 1d                	jmp    943b <LodePNGUnknownChunks_cleanup+0x2c>
    941e:	8b 45 08             	mov    0x8(%ebp),%eax
    9421:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9424:	83 c2 30             	add    $0x30,%edx
    9427:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    942b:	83 ec 0c             	sub    $0xc,%esp
    942e:	50                   	push   %eax
    942f:	e8 e4 a1 ff ff       	call   3618 <lodepng_free>
    9434:	83 c4 10             	add    $0x10,%esp
    9437:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    943b:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    943f:	75 dd                	jne    941e <LodePNGUnknownChunks_cleanup+0xf>
}
    9441:	90                   	nop
    9442:	c9                   	leave  
    9443:	c3                   	ret    

00009444 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    9444:	55                   	push   %ebp
    9445:	89 e5                	mov    %esp,%ebp
    9447:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    944a:	83 ec 0c             	sub    $0xc,%esp
    944d:	ff 75 08             	pushl  0x8(%ebp)
    9450:	e8 ba ff ff ff       	call   940f <LodePNGUnknownChunks_cleanup>
    9455:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9458:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    945f:	e9 b7 00 00 00       	jmp    951b <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9464:	8b 45 0c             	mov    0xc(%ebp),%eax
    9467:	8b 55 f4             	mov    -0xc(%ebp),%edx
    946a:	83 c2 34             	add    $0x34,%edx
    946d:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    9471:	8b 45 08             	mov    0x8(%ebp),%eax
    9474:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9477:	83 c1 34             	add    $0x34,%ecx
    947a:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    947e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9481:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9484:	83 c2 34             	add    $0x34,%edx
    9487:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    948b:	83 ec 0c             	sub    $0xc,%esp
    948e:	50                   	push   %eax
    948f:	e8 63 a1 ff ff       	call   35f7 <lodepng_malloc>
    9494:	83 c4 10             	add    $0x10,%esp
    9497:	89 c1                	mov    %eax,%ecx
    9499:	8b 45 08             	mov    0x8(%ebp),%eax
    949c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    949f:	83 c2 30             	add    $0x30,%edx
    94a2:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    94a6:	8b 45 08             	mov    0x8(%ebp),%eax
    94a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    94ac:	83 c2 30             	add    $0x30,%edx
    94af:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    94b3:	85 c0                	test   %eax,%eax
    94b5:	75 18                	jne    94cf <LodePNGUnknownChunks_copy+0x8b>
    94b7:	8b 45 08             	mov    0x8(%ebp),%eax
    94ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
    94bd:	83 c2 34             	add    $0x34,%edx
    94c0:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    94c4:	85 c0                	test   %eax,%eax
    94c6:	74 07                	je     94cf <LodePNGUnknownChunks_copy+0x8b>
    94c8:	b8 53 00 00 00       	mov    $0x53,%eax
    94cd:	eb 5b                	jmp    952a <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    94cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    94d6:	eb 2d                	jmp    9505 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    94d8:	8b 45 08             	mov    0x8(%ebp),%eax
    94db:	8b 55 f4             	mov    -0xc(%ebp),%edx
    94de:	83 c2 30             	add    $0x30,%edx
    94e1:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    94e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    94e8:	01 c2                	add    %eax,%edx
    94ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    94ed:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    94f0:	83 c1 30             	add    $0x30,%ecx
    94f3:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    94f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    94fa:	01 c8                	add    %ecx,%eax
    94fc:	0f b6 00             	movzbl (%eax),%eax
    94ff:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9501:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9505:	8b 45 0c             	mov    0xc(%ebp),%eax
    9508:	8b 55 f4             	mov    -0xc(%ebp),%edx
    950b:	83 c2 34             	add    $0x34,%edx
    950e:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9512:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9515:	7f c1                	jg     94d8 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    9517:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    951b:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    951f:	0f 85 3f ff ff ff    	jne    9464 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    9525:	b8 00 00 00 00       	mov    $0x0,%eax
}
    952a:	c9                   	leave  
    952b:	c3                   	ret    

0000952c <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    952c:	55                   	push   %ebp
    952d:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    952f:	8b 45 08             	mov    0x8(%ebp),%eax
    9532:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9539:	8b 45 08             	mov    0x8(%ebp),%eax
    953c:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    9543:	8b 45 08             	mov    0x8(%ebp),%eax
    9546:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    954d:	90                   	nop
    954e:	5d                   	pop    %ebp
    954f:	c3                   	ret    

00009550 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    9550:	55                   	push   %ebp
    9551:	89 e5                	mov    %esp,%ebp
    9553:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9556:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    955d:	eb 38                	jmp    9597 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    955f:	8b 45 08             	mov    0x8(%ebp),%eax
    9562:	8b 40 40             	mov    0x40(%eax),%eax
    9565:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9568:	c1 e2 02             	shl    $0x2,%edx
    956b:	01 d0                	add    %edx,%eax
    956d:	83 ec 0c             	sub    $0xc,%esp
    9570:	50                   	push   %eax
    9571:	e8 75 a3 ff ff       	call   38eb <string_cleanup>
    9576:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    9579:	8b 45 08             	mov    0x8(%ebp),%eax
    957c:	8b 40 44             	mov    0x44(%eax),%eax
    957f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9582:	c1 e2 02             	shl    $0x2,%edx
    9585:	01 d0                	add    %edx,%eax
    9587:	83 ec 0c             	sub    $0xc,%esp
    958a:	50                   	push   %eax
    958b:	e8 5b a3 ff ff       	call   38eb <string_cleanup>
    9590:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9593:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9597:	8b 45 08             	mov    0x8(%ebp),%eax
    959a:	8b 40 3c             	mov    0x3c(%eax),%eax
    959d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    95a0:	75 bd                	jne    955f <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    95a2:	8b 45 08             	mov    0x8(%ebp),%eax
    95a5:	8b 40 40             	mov    0x40(%eax),%eax
    95a8:	83 ec 0c             	sub    $0xc,%esp
    95ab:	50                   	push   %eax
    95ac:	e8 67 a0 ff ff       	call   3618 <lodepng_free>
    95b1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    95b4:	8b 45 08             	mov    0x8(%ebp),%eax
    95b7:	8b 40 44             	mov    0x44(%eax),%eax
    95ba:	83 ec 0c             	sub    $0xc,%esp
    95bd:	50                   	push   %eax
    95be:	e8 55 a0 ff ff       	call   3618 <lodepng_free>
    95c3:	83 c4 10             	add    $0x10,%esp
}
    95c6:	90                   	nop
    95c7:	c9                   	leave  
    95c8:	c3                   	ret    

000095c9 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    95c9:	55                   	push   %ebp
    95ca:	89 e5                	mov    %esp,%ebp
    95cc:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    95cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    95d6:	8b 45 08             	mov    0x8(%ebp),%eax
    95d9:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    95e0:	8b 45 08             	mov    0x8(%ebp),%eax
    95e3:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    95ea:	8b 45 08             	mov    0x8(%ebp),%eax
    95ed:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    95f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    95fb:	eb 42                	jmp    963f <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    95fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    9600:	8b 40 44             	mov    0x44(%eax),%eax
    9603:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9606:	c1 e2 02             	shl    $0x2,%edx
    9609:	01 d0                	add    %edx,%eax
    960b:	8b 10                	mov    (%eax),%edx
    960d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9610:	8b 40 40             	mov    0x40(%eax),%eax
    9613:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9616:	c1 e1 02             	shl    $0x2,%ecx
    9619:	01 c8                	add    %ecx,%eax
    961b:	8b 00                	mov    (%eax),%eax
    961d:	83 ec 04             	sub    $0x4,%esp
    9620:	52                   	push   %edx
    9621:	50                   	push   %eax
    9622:	ff 75 08             	pushl  0x8(%ebp)
    9625:	e8 4d 01 00 00       	call   9777 <lodepng_add_text>
    962a:	83 c4 10             	add    $0x10,%esp
    962d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9630:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9634:	74 05                	je     963b <LodePNGText_copy+0x72>
    9636:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9639:	eb 14                	jmp    964f <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    963b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    963f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9642:	8b 40 3c             	mov    0x3c(%eax),%eax
    9645:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9648:	75 b3                	jne    95fd <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    964a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    964f:	c9                   	leave  
    9650:	c3                   	ret    

00009651 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    9651:	55                   	push   %ebp
    9652:	89 e5                	mov    %esp,%ebp
    9654:	53                   	push   %ebx
    9655:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9658:	8b 45 08             	mov    0x8(%ebp),%eax
    965b:	8b 40 3c             	mov    0x3c(%eax),%eax
    965e:	83 c0 01             	add    $0x1,%eax
    9661:	c1 e0 02             	shl    $0x2,%eax
    9664:	89 c2                	mov    %eax,%edx
    9666:	8b 45 08             	mov    0x8(%ebp),%eax
    9669:	8b 40 40             	mov    0x40(%eax),%eax
    966c:	52                   	push   %edx
    966d:	50                   	push   %eax
    966e:	e8 9b 9f ff ff       	call   360e <lodepng_realloc>
    9673:	83 c4 08             	add    $0x8,%esp
    9676:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9679:	8b 45 08             	mov    0x8(%ebp),%eax
    967c:	8b 40 3c             	mov    0x3c(%eax),%eax
    967f:	83 c0 01             	add    $0x1,%eax
    9682:	c1 e0 02             	shl    $0x2,%eax
    9685:	89 c2                	mov    %eax,%edx
    9687:	8b 45 08             	mov    0x8(%ebp),%eax
    968a:	8b 40 44             	mov    0x44(%eax),%eax
    968d:	52                   	push   %edx
    968e:	50                   	push   %eax
    968f:	e8 7a 9f ff ff       	call   360e <lodepng_realloc>
    9694:	83 c4 08             	add    $0x8,%esp
    9697:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    969a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    969e:	74 09                	je     96a9 <lodepng_add_text_sized+0x58>
    96a0:	8b 45 08             	mov    0x8(%ebp),%eax
    96a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96a6:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    96a9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    96ad:	74 09                	je     96b8 <lodepng_add_text_sized+0x67>
    96af:	8b 45 08             	mov    0x8(%ebp),%eax
    96b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    96b5:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    96b8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    96bc:	74 06                	je     96c4 <lodepng_add_text_sized+0x73>
    96be:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    96c2:	75 0a                	jne    96ce <lodepng_add_text_sized+0x7d>
    96c4:	b8 53 00 00 00       	mov    $0x53,%eax
    96c9:	e9 a4 00 00 00       	jmp    9772 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    96ce:	8b 45 08             	mov    0x8(%ebp),%eax
    96d1:	8b 40 3c             	mov    0x3c(%eax),%eax
    96d4:	8d 50 01             	lea    0x1(%eax),%edx
    96d7:	8b 45 08             	mov    0x8(%ebp),%eax
    96da:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    96dd:	8b 45 08             	mov    0x8(%ebp),%eax
    96e0:	8b 50 40             	mov    0x40(%eax),%edx
    96e3:	8b 45 08             	mov    0x8(%ebp),%eax
    96e6:	8b 40 3c             	mov    0x3c(%eax),%eax
    96e9:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    96ee:	c1 e0 02             	shl    $0x2,%eax
    96f1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    96f4:	83 ec 0c             	sub    $0xc,%esp
    96f7:	ff 75 0c             	pushl  0xc(%ebp)
    96fa:	e8 54 a2 ff ff       	call   3953 <alloc_string>
    96ff:	83 c4 10             	add    $0x10,%esp
    9702:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    9704:	8b 45 08             	mov    0x8(%ebp),%eax
    9707:	8b 50 44             	mov    0x44(%eax),%edx
    970a:	8b 45 08             	mov    0x8(%ebp),%eax
    970d:	8b 40 3c             	mov    0x3c(%eax),%eax
    9710:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9715:	c1 e0 02             	shl    $0x2,%eax
    9718:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    971b:	83 ec 08             	sub    $0x8,%esp
    971e:	ff 75 14             	pushl  0x14(%ebp)
    9721:	ff 75 10             	pushl  0x10(%ebp)
    9724:	e8 e5 a1 ff ff       	call   390e <alloc_string_sized>
    9729:	83 c4 10             	add    $0x10,%esp
    972c:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    972e:	8b 45 08             	mov    0x8(%ebp),%eax
    9731:	8b 50 40             	mov    0x40(%eax),%edx
    9734:	8b 45 08             	mov    0x8(%ebp),%eax
    9737:	8b 40 3c             	mov    0x3c(%eax),%eax
    973a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    973f:	c1 e0 02             	shl    $0x2,%eax
    9742:	01 d0                	add    %edx,%eax
    9744:	8b 00                	mov    (%eax),%eax
    9746:	85 c0                	test   %eax,%eax
    9748:	74 1c                	je     9766 <lodepng_add_text_sized+0x115>
    974a:	8b 45 08             	mov    0x8(%ebp),%eax
    974d:	8b 50 44             	mov    0x44(%eax),%edx
    9750:	8b 45 08             	mov    0x8(%ebp),%eax
    9753:	8b 40 3c             	mov    0x3c(%eax),%eax
    9756:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    975b:	c1 e0 02             	shl    $0x2,%eax
    975e:	01 d0                	add    %edx,%eax
    9760:	8b 00                	mov    (%eax),%eax
    9762:	85 c0                	test   %eax,%eax
    9764:	75 07                	jne    976d <lodepng_add_text_sized+0x11c>
    9766:	b8 53 00 00 00       	mov    $0x53,%eax
    976b:	eb 05                	jmp    9772 <lodepng_add_text_sized+0x121>

  return 0;
    976d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9772:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9775:	c9                   	leave  
    9776:	c3                   	ret    

00009777 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9777:	55                   	push   %ebp
    9778:	89 e5                	mov    %esp,%ebp
    977a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    977d:	ff 75 10             	pushl  0x10(%ebp)
    9780:	e8 0e 9f ff ff       	call   3693 <lodepng_strlen>
    9785:	83 c4 04             	add    $0x4,%esp
    9788:	50                   	push   %eax
    9789:	ff 75 10             	pushl  0x10(%ebp)
    978c:	ff 75 0c             	pushl  0xc(%ebp)
    978f:	ff 75 08             	pushl  0x8(%ebp)
    9792:	e8 ba fe ff ff       	call   9651 <lodepng_add_text_sized>
    9797:	83 c4 10             	add    $0x10,%esp
}
    979a:	c9                   	leave  
    979b:	c3                   	ret    

0000979c <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    979c:	55                   	push   %ebp
    979d:	89 e5                	mov    %esp,%ebp
    979f:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    97a2:	83 ec 0c             	sub    $0xc,%esp
    97a5:	ff 75 08             	pushl  0x8(%ebp)
    97a8:	e8 a3 fd ff ff       	call   9550 <LodePNGText_cleanup>
    97ad:	83 c4 10             	add    $0x10,%esp
}
    97b0:	90                   	nop
    97b1:	c9                   	leave  
    97b2:	c3                   	ret    

000097b3 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    97b3:	55                   	push   %ebp
    97b4:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    97b6:	8b 45 08             	mov    0x8(%ebp),%eax
    97b9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    97c0:	8b 45 08             	mov    0x8(%ebp),%eax
    97c3:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    97ca:	8b 45 08             	mov    0x8(%ebp),%eax
    97cd:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    97d4:	8b 45 08             	mov    0x8(%ebp),%eax
    97d7:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    97de:	8b 45 08             	mov    0x8(%ebp),%eax
    97e1:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    97e8:	90                   	nop
    97e9:	5d                   	pop    %ebp
    97ea:	c3                   	ret    

000097eb <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    97eb:	55                   	push   %ebp
    97ec:	89 e5                	mov    %esp,%ebp
    97ee:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    97f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    97f8:	eb 6c                	jmp    9866 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    97fa:	8b 45 08             	mov    0x8(%ebp),%eax
    97fd:	8b 40 4c             	mov    0x4c(%eax),%eax
    9800:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9803:	c1 e2 02             	shl    $0x2,%edx
    9806:	01 d0                	add    %edx,%eax
    9808:	83 ec 0c             	sub    $0xc,%esp
    980b:	50                   	push   %eax
    980c:	e8 da a0 ff ff       	call   38eb <string_cleanup>
    9811:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    9814:	8b 45 08             	mov    0x8(%ebp),%eax
    9817:	8b 40 50             	mov    0x50(%eax),%eax
    981a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    981d:	c1 e2 02             	shl    $0x2,%edx
    9820:	01 d0                	add    %edx,%eax
    9822:	83 ec 0c             	sub    $0xc,%esp
    9825:	50                   	push   %eax
    9826:	e8 c0 a0 ff ff       	call   38eb <string_cleanup>
    982b:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    982e:	8b 45 08             	mov    0x8(%ebp),%eax
    9831:	8b 40 54             	mov    0x54(%eax),%eax
    9834:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9837:	c1 e2 02             	shl    $0x2,%edx
    983a:	01 d0                	add    %edx,%eax
    983c:	83 ec 0c             	sub    $0xc,%esp
    983f:	50                   	push   %eax
    9840:	e8 a6 a0 ff ff       	call   38eb <string_cleanup>
    9845:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9848:	8b 45 08             	mov    0x8(%ebp),%eax
    984b:	8b 40 58             	mov    0x58(%eax),%eax
    984e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9851:	c1 e2 02             	shl    $0x2,%edx
    9854:	01 d0                	add    %edx,%eax
    9856:	83 ec 0c             	sub    $0xc,%esp
    9859:	50                   	push   %eax
    985a:	e8 8c a0 ff ff       	call   38eb <string_cleanup>
    985f:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9862:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9866:	8b 45 08             	mov    0x8(%ebp),%eax
    9869:	8b 40 48             	mov    0x48(%eax),%eax
    986c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    986f:	75 89                	jne    97fa <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    9871:	8b 45 08             	mov    0x8(%ebp),%eax
    9874:	8b 40 4c             	mov    0x4c(%eax),%eax
    9877:	83 ec 0c             	sub    $0xc,%esp
    987a:	50                   	push   %eax
    987b:	e8 98 9d ff ff       	call   3618 <lodepng_free>
    9880:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    9883:	8b 45 08             	mov    0x8(%ebp),%eax
    9886:	8b 40 50             	mov    0x50(%eax),%eax
    9889:	83 ec 0c             	sub    $0xc,%esp
    988c:	50                   	push   %eax
    988d:	e8 86 9d ff ff       	call   3618 <lodepng_free>
    9892:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    9895:	8b 45 08             	mov    0x8(%ebp),%eax
    9898:	8b 40 54             	mov    0x54(%eax),%eax
    989b:	83 ec 0c             	sub    $0xc,%esp
    989e:	50                   	push   %eax
    989f:	e8 74 9d ff ff       	call   3618 <lodepng_free>
    98a4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    98a7:	8b 45 08             	mov    0x8(%ebp),%eax
    98aa:	8b 40 58             	mov    0x58(%eax),%eax
    98ad:	83 ec 0c             	sub    $0xc,%esp
    98b0:	50                   	push   %eax
    98b1:	e8 62 9d ff ff       	call   3618 <lodepng_free>
    98b6:	83 c4 10             	add    $0x10,%esp
}
    98b9:	90                   	nop
    98ba:	c9                   	leave  
    98bb:	c3                   	ret    

000098bc <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    98bc:	55                   	push   %ebp
    98bd:	89 e5                	mov    %esp,%ebp
    98bf:	56                   	push   %esi
    98c0:	53                   	push   %ebx
    98c1:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    98c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    98cb:	8b 45 08             	mov    0x8(%ebp),%eax
    98ce:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    98d5:	8b 45 08             	mov    0x8(%ebp),%eax
    98d8:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    98df:	8b 45 08             	mov    0x8(%ebp),%eax
    98e2:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    98e9:	8b 45 08             	mov    0x8(%ebp),%eax
    98ec:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    98f3:	8b 45 08             	mov    0x8(%ebp),%eax
    98f6:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    98fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9904:	eb 64                	jmp    996a <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    9906:	8b 45 0c             	mov    0xc(%ebp),%eax
    9909:	8b 40 58             	mov    0x58(%eax),%eax
    990c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    990f:	c1 e2 02             	shl    $0x2,%edx
    9912:	01 d0                	add    %edx,%eax
    9914:	8b 18                	mov    (%eax),%ebx
    9916:	8b 45 0c             	mov    0xc(%ebp),%eax
    9919:	8b 40 54             	mov    0x54(%eax),%eax
    991c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    991f:	c1 e2 02             	shl    $0x2,%edx
    9922:	01 d0                	add    %edx,%eax
    9924:	8b 08                	mov    (%eax),%ecx
    9926:	8b 45 0c             	mov    0xc(%ebp),%eax
    9929:	8b 40 50             	mov    0x50(%eax),%eax
    992c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    992f:	c1 e2 02             	shl    $0x2,%edx
    9932:	01 d0                	add    %edx,%eax
    9934:	8b 10                	mov    (%eax),%edx
    9936:	8b 45 0c             	mov    0xc(%ebp),%eax
    9939:	8b 40 4c             	mov    0x4c(%eax),%eax
    993c:	8b 75 f4             	mov    -0xc(%ebp),%esi
    993f:	c1 e6 02             	shl    $0x2,%esi
    9942:	01 f0                	add    %esi,%eax
    9944:	8b 00                	mov    (%eax),%eax
    9946:	83 ec 0c             	sub    $0xc,%esp
    9949:	53                   	push   %ebx
    994a:	51                   	push   %ecx
    994b:	52                   	push   %edx
    994c:	50                   	push   %eax
    994d:	ff 75 08             	pushl  0x8(%ebp)
    9950:	e8 e4 01 00 00       	call   9b39 <lodepng_add_itext>
    9955:	83 c4 20             	add    $0x20,%esp
    9958:	89 45 f0             	mov    %eax,-0x10(%ebp)
    995b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    995f:	74 05                	je     9966 <LodePNGIText_copy+0xaa>
    9961:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9964:	eb 14                	jmp    997a <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9966:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    996a:	8b 45 0c             	mov    0xc(%ebp),%eax
    996d:	8b 40 48             	mov    0x48(%eax),%eax
    9970:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9973:	75 91                	jne    9906 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    9975:	b8 00 00 00 00       	mov    $0x0,%eax
}
    997a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    997d:	5b                   	pop    %ebx
    997e:	5e                   	pop    %esi
    997f:	5d                   	pop    %ebp
    9980:	c3                   	ret    

00009981 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    9981:	55                   	push   %ebp
    9982:	89 e5                	mov    %esp,%ebp
    9984:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    9987:	83 ec 0c             	sub    $0xc,%esp
    998a:	ff 75 08             	pushl  0x8(%ebp)
    998d:	e8 59 fe ff ff       	call   97eb <LodePNGIText_cleanup>
    9992:	83 c4 10             	add    $0x10,%esp
}
    9995:	90                   	nop
    9996:	c9                   	leave  
    9997:	c3                   	ret    

00009998 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    9998:	55                   	push   %ebp
    9999:	89 e5                	mov    %esp,%ebp
    999b:	53                   	push   %ebx
    999c:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    999f:	8b 45 08             	mov    0x8(%ebp),%eax
    99a2:	8b 40 48             	mov    0x48(%eax),%eax
    99a5:	83 c0 01             	add    $0x1,%eax
    99a8:	c1 e0 02             	shl    $0x2,%eax
    99ab:	89 c2                	mov    %eax,%edx
    99ad:	8b 45 08             	mov    0x8(%ebp),%eax
    99b0:	8b 40 4c             	mov    0x4c(%eax),%eax
    99b3:	52                   	push   %edx
    99b4:	50                   	push   %eax
    99b5:	e8 54 9c ff ff       	call   360e <lodepng_realloc>
    99ba:	83 c4 08             	add    $0x8,%esp
    99bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    99c0:	8b 45 08             	mov    0x8(%ebp),%eax
    99c3:	8b 40 48             	mov    0x48(%eax),%eax
    99c6:	83 c0 01             	add    $0x1,%eax
    99c9:	c1 e0 02             	shl    $0x2,%eax
    99cc:	89 c2                	mov    %eax,%edx
    99ce:	8b 45 08             	mov    0x8(%ebp),%eax
    99d1:	8b 40 50             	mov    0x50(%eax),%eax
    99d4:	52                   	push   %edx
    99d5:	50                   	push   %eax
    99d6:	e8 33 9c ff ff       	call   360e <lodepng_realloc>
    99db:	83 c4 08             	add    $0x8,%esp
    99de:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    99e1:	8b 45 08             	mov    0x8(%ebp),%eax
    99e4:	8b 40 48             	mov    0x48(%eax),%eax
    99e7:	83 c0 01             	add    $0x1,%eax
    99ea:	c1 e0 02             	shl    $0x2,%eax
    99ed:	89 c2                	mov    %eax,%edx
    99ef:	8b 45 08             	mov    0x8(%ebp),%eax
    99f2:	8b 40 54             	mov    0x54(%eax),%eax
    99f5:	52                   	push   %edx
    99f6:	50                   	push   %eax
    99f7:	e8 12 9c ff ff       	call   360e <lodepng_realloc>
    99fc:	83 c4 08             	add    $0x8,%esp
    99ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    9a02:	8b 45 08             	mov    0x8(%ebp),%eax
    9a05:	8b 40 48             	mov    0x48(%eax),%eax
    9a08:	83 c0 01             	add    $0x1,%eax
    9a0b:	c1 e0 02             	shl    $0x2,%eax
    9a0e:	89 c2                	mov    %eax,%edx
    9a10:	8b 45 08             	mov    0x8(%ebp),%eax
    9a13:	8b 40 58             	mov    0x58(%eax),%eax
    9a16:	52                   	push   %edx
    9a17:	50                   	push   %eax
    9a18:	e8 f1 9b ff ff       	call   360e <lodepng_realloc>
    9a1d:	83 c4 08             	add    $0x8,%esp
    9a20:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    9a23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9a27:	74 09                	je     9a32 <lodepng_add_itext_sized+0x9a>
    9a29:	8b 45 08             	mov    0x8(%ebp),%eax
    9a2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9a2f:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    9a32:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9a36:	74 09                	je     9a41 <lodepng_add_itext_sized+0xa9>
    9a38:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9a3e:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    9a41:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9a45:	74 09                	je     9a50 <lodepng_add_itext_sized+0xb8>
    9a47:	8b 45 08             	mov    0x8(%ebp),%eax
    9a4a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9a4d:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    9a50:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9a54:	74 09                	je     9a5f <lodepng_add_itext_sized+0xc7>
    9a56:	8b 45 08             	mov    0x8(%ebp),%eax
    9a59:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9a5c:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    9a5f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9a63:	74 12                	je     9a77 <lodepng_add_itext_sized+0xdf>
    9a65:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9a69:	74 0c                	je     9a77 <lodepng_add_itext_sized+0xdf>
    9a6b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9a6f:	74 06                	je     9a77 <lodepng_add_itext_sized+0xdf>
    9a71:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9a75:	75 0a                	jne    9a81 <lodepng_add_itext_sized+0xe9>
    9a77:	b8 53 00 00 00       	mov    $0x53,%eax
    9a7c:	e9 b3 00 00 00       	jmp    9b34 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    9a81:	8b 45 08             	mov    0x8(%ebp),%eax
    9a84:	8b 40 48             	mov    0x48(%eax),%eax
    9a87:	8d 50 01             	lea    0x1(%eax),%edx
    9a8a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a8d:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    9a90:	8b 45 08             	mov    0x8(%ebp),%eax
    9a93:	8b 50 4c             	mov    0x4c(%eax),%edx
    9a96:	8b 45 08             	mov    0x8(%ebp),%eax
    9a99:	8b 40 48             	mov    0x48(%eax),%eax
    9a9c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9aa1:	c1 e0 02             	shl    $0x2,%eax
    9aa4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9aa7:	83 ec 0c             	sub    $0xc,%esp
    9aaa:	ff 75 0c             	pushl  0xc(%ebp)
    9aad:	e8 a1 9e ff ff       	call   3953 <alloc_string>
    9ab2:	83 c4 10             	add    $0x10,%esp
    9ab5:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    9ab7:	8b 45 08             	mov    0x8(%ebp),%eax
    9aba:	8b 50 50             	mov    0x50(%eax),%edx
    9abd:	8b 45 08             	mov    0x8(%ebp),%eax
    9ac0:	8b 40 48             	mov    0x48(%eax),%eax
    9ac3:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9ac8:	c1 e0 02             	shl    $0x2,%eax
    9acb:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9ace:	83 ec 0c             	sub    $0xc,%esp
    9ad1:	ff 75 10             	pushl  0x10(%ebp)
    9ad4:	e8 7a 9e ff ff       	call   3953 <alloc_string>
    9ad9:	83 c4 10             	add    $0x10,%esp
    9adc:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    9ade:	8b 45 08             	mov    0x8(%ebp),%eax
    9ae1:	8b 50 54             	mov    0x54(%eax),%edx
    9ae4:	8b 45 08             	mov    0x8(%ebp),%eax
    9ae7:	8b 40 48             	mov    0x48(%eax),%eax
    9aea:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9aef:	c1 e0 02             	shl    $0x2,%eax
    9af2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9af5:	83 ec 0c             	sub    $0xc,%esp
    9af8:	ff 75 14             	pushl  0x14(%ebp)
    9afb:	e8 53 9e ff ff       	call   3953 <alloc_string>
    9b00:	83 c4 10             	add    $0x10,%esp
    9b03:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9b05:	8b 45 08             	mov    0x8(%ebp),%eax
    9b08:	8b 50 58             	mov    0x58(%eax),%edx
    9b0b:	8b 45 08             	mov    0x8(%ebp),%eax
    9b0e:	8b 40 48             	mov    0x48(%eax),%eax
    9b11:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9b16:	c1 e0 02             	shl    $0x2,%eax
    9b19:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9b1c:	83 ec 08             	sub    $0x8,%esp
    9b1f:	ff 75 1c             	pushl  0x1c(%ebp)
    9b22:	ff 75 18             	pushl  0x18(%ebp)
    9b25:	e8 e4 9d ff ff       	call   390e <alloc_string_sized>
    9b2a:	83 c4 10             	add    $0x10,%esp
    9b2d:	89 03                	mov    %eax,(%ebx)

  return 0;
    9b2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9b34:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9b37:	c9                   	leave  
    9b38:	c3                   	ret    

00009b39 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9b39:	55                   	push   %ebp
    9b3a:	89 e5                	mov    %esp,%ebp
    9b3c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    9b3f:	ff 75 18             	pushl  0x18(%ebp)
    9b42:	e8 4c 9b ff ff       	call   3693 <lodepng_strlen>
    9b47:	83 c4 04             	add    $0x4,%esp
    9b4a:	83 ec 08             	sub    $0x8,%esp
    9b4d:	50                   	push   %eax
    9b4e:	ff 75 18             	pushl  0x18(%ebp)
    9b51:	ff 75 14             	pushl  0x14(%ebp)
    9b54:	ff 75 10             	pushl  0x10(%ebp)
    9b57:	ff 75 0c             	pushl  0xc(%ebp)
    9b5a:	ff 75 08             	pushl  0x8(%ebp)
    9b5d:	e8 36 fe ff ff       	call   9998 <lodepng_add_itext_sized>
    9b62:	83 c4 20             	add    $0x20,%esp
}
    9b65:	c9                   	leave  
    9b66:	c3                   	ret    

00009b67 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9b67:	55                   	push   %ebp
    9b68:	89 e5                	mov    %esp,%ebp
    9b6a:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9b6d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    9b71:	75 0a                	jne    9b7d <lodepng_assign_icc+0x16>
    9b73:	b8 64 00 00 00       	mov    $0x64,%eax
    9b78:	e9 81 00 00 00       	jmp    9bfe <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9b7d:	83 ec 0c             	sub    $0xc,%esp
    9b80:	ff 75 0c             	pushl  0xc(%ebp)
    9b83:	e8 cb 9d ff ff       	call   3953 <alloc_string>
    9b88:	83 c4 10             	add    $0x10,%esp
    9b8b:	89 c2                	mov    %eax,%edx
    9b8d:	8b 45 08             	mov    0x8(%ebp),%eax
    9b90:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    9b96:	8b 45 14             	mov    0x14(%ebp),%eax
    9b99:	83 ec 0c             	sub    $0xc,%esp
    9b9c:	50                   	push   %eax
    9b9d:	e8 55 9a ff ff       	call   35f7 <lodepng_malloc>
    9ba2:	83 c4 10             	add    $0x10,%esp
    9ba5:	89 c2                	mov    %eax,%edx
    9ba7:	8b 45 08             	mov    0x8(%ebp),%eax
    9baa:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    9bb0:	8b 45 08             	mov    0x8(%ebp),%eax
    9bb3:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9bb9:	85 c0                	test   %eax,%eax
    9bbb:	74 0d                	je     9bca <lodepng_assign_icc+0x63>
    9bbd:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc0:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9bc6:	85 c0                	test   %eax,%eax
    9bc8:	75 07                	jne    9bd1 <lodepng_assign_icc+0x6a>
    9bca:	b8 53 00 00 00       	mov    $0x53,%eax
    9bcf:	eb 2d                	jmp    9bfe <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    9bd1:	8b 55 14             	mov    0x14(%ebp),%edx
    9bd4:	8b 45 08             	mov    0x8(%ebp),%eax
    9bd7:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9bdd:	83 ec 04             	sub    $0x4,%esp
    9be0:	52                   	push   %edx
    9be1:	ff 75 10             	pushl  0x10(%ebp)
    9be4:	50                   	push   %eax
    9be5:	e8 4b 9a ff ff       	call   3635 <lodepng_memcpy>
    9bea:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    9bed:	8b 45 08             	mov    0x8(%ebp),%eax
    9bf0:	8b 55 14             	mov    0x14(%ebp),%edx
    9bf3:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9bf9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9bfe:	c9                   	leave  
    9bff:	c3                   	ret    

00009c00 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9c00:	55                   	push   %ebp
    9c01:	89 e5                	mov    %esp,%ebp
    9c03:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9c06:	8b 45 08             	mov    0x8(%ebp),%eax
    9c09:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9c0f:	85 c0                	test   %eax,%eax
    9c11:	74 0e                	je     9c21 <lodepng_set_icc+0x21>
    9c13:	83 ec 0c             	sub    $0xc,%esp
    9c16:	ff 75 08             	pushl  0x8(%ebp)
    9c19:	e8 26 00 00 00       	call   9c44 <lodepng_clear_icc>
    9c1e:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    9c21:	8b 45 08             	mov    0x8(%ebp),%eax
    9c24:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9c2b:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    9c2e:	ff 75 14             	pushl  0x14(%ebp)
    9c31:	ff 75 10             	pushl  0x10(%ebp)
    9c34:	ff 75 0c             	pushl  0xc(%ebp)
    9c37:	ff 75 08             	pushl  0x8(%ebp)
    9c3a:	e8 28 ff ff ff       	call   9b67 <lodepng_assign_icc>
    9c3f:	83 c4 10             	add    $0x10,%esp
}
    9c42:	c9                   	leave  
    9c43:	c3                   	ret    

00009c44 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9c44:	55                   	push   %ebp
    9c45:	89 e5                	mov    %esp,%ebp
    9c47:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9c4a:	8b 45 08             	mov    0x8(%ebp),%eax
    9c4d:	05 c0 00 00 00       	add    $0xc0,%eax
    9c52:	83 ec 0c             	sub    $0xc,%esp
    9c55:	50                   	push   %eax
    9c56:	e8 90 9c ff ff       	call   38eb <string_cleanup>
    9c5b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9c5e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c61:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9c67:	83 ec 0c             	sub    $0xc,%esp
    9c6a:	50                   	push   %eax
    9c6b:	e8 a8 99 ff ff       	call   3618 <lodepng_free>
    9c70:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9c73:	8b 45 08             	mov    0x8(%ebp),%eax
    9c76:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9c7d:	00 00 00 
  info->iccp_profile_size = 0;
    9c80:	8b 45 08             	mov    0x8(%ebp),%eax
    9c83:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9c8a:	00 00 00 
  info->iccp_defined = 0;
    9c8d:	8b 45 08             	mov    0x8(%ebp),%eax
    9c90:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9c97:	00 00 00 
}
    9c9a:	90                   	nop
    9c9b:	c9                   	leave  
    9c9c:	c3                   	ret    

00009c9d <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9c9d:	55                   	push   %ebp
    9c9e:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9ca0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca3:	83 c0 0c             	add    $0xc,%eax
    9ca6:	50                   	push   %eax
    9ca7:	e8 5a f0 ff ff       	call   8d06 <lodepng_color_mode_init>
    9cac:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9caf:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9cb9:	8b 45 08             	mov    0x8(%ebp),%eax
    9cbc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9cc2:	8b 45 08             	mov    0x8(%ebp),%eax
    9cc5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9ccc:	8b 45 08             	mov    0x8(%ebp),%eax
    9ccf:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9cd6:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd9:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9ce0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce3:	8b 50 38             	mov    0x38(%eax),%edx
    9ce6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce9:	89 50 34             	mov    %edx,0x34(%eax)
    9cec:	8b 45 08             	mov    0x8(%ebp),%eax
    9cef:	8b 50 34             	mov    0x34(%eax),%edx
    9cf2:	8b 45 08             	mov    0x8(%ebp),%eax
    9cf5:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9cf8:	ff 75 08             	pushl  0x8(%ebp)
    9cfb:	e8 2c f8 ff ff       	call   952c <LodePNGText_init>
    9d00:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9d03:	ff 75 08             	pushl  0x8(%ebp)
    9d06:	e8 a8 fa ff ff       	call   97b3 <LodePNGIText_init>
    9d0b:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9d0e:	8b 45 08             	mov    0x8(%ebp),%eax
    9d11:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9d18:	8b 45 08             	mov    0x8(%ebp),%eax
    9d1b:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9d22:	8b 45 08             	mov    0x8(%ebp),%eax
    9d25:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9d2c:	00 00 00 
  info->chrm_defined = 0;
    9d2f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d32:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9d39:	00 00 00 
  info->srgb_defined = 0;
    9d3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9d3f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9d46:	00 00 00 
  info->iccp_defined = 0;
    9d49:	8b 45 08             	mov    0x8(%ebp),%eax
    9d4c:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9d53:	00 00 00 
  info->iccp_name = NULL;
    9d56:	8b 45 08             	mov    0x8(%ebp),%eax
    9d59:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9d60:	00 00 00 
  info->iccp_profile = NULL;
    9d63:	8b 45 08             	mov    0x8(%ebp),%eax
    9d66:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9d6d:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9d70:	ff 75 08             	pushl  0x8(%ebp)
    9d73:	e8 46 f6 ff ff       	call   93be <LodePNGUnknownChunks_init>
    9d78:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9d7b:	90                   	nop
    9d7c:	c9                   	leave  
    9d7d:	c3                   	ret    

00009d7e <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9d7e:	55                   	push   %ebp
    9d7f:	89 e5                	mov    %esp,%ebp
    9d81:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9d84:	8b 45 08             	mov    0x8(%ebp),%eax
    9d87:	83 c0 0c             	add    $0xc,%eax
    9d8a:	83 ec 0c             	sub    $0xc,%esp
    9d8d:	50                   	push   %eax
    9d8e:	e8 66 f0 ff ff       	call   8df9 <lodepng_color_mode_cleanup>
    9d93:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9d96:	83 ec 0c             	sub    $0xc,%esp
    9d99:	ff 75 08             	pushl  0x8(%ebp)
    9d9c:	e8 af f7 ff ff       	call   9550 <LodePNGText_cleanup>
    9da1:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9da4:	83 ec 0c             	sub    $0xc,%esp
    9da7:	ff 75 08             	pushl  0x8(%ebp)
    9daa:	e8 3c fa ff ff       	call   97eb <LodePNGIText_cleanup>
    9daf:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9db2:	83 ec 0c             	sub    $0xc,%esp
    9db5:	ff 75 08             	pushl  0x8(%ebp)
    9db8:	e8 87 fe ff ff       	call   9c44 <lodepng_clear_icc>
    9dbd:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9dc0:	83 ec 0c             	sub    $0xc,%esp
    9dc3:	ff 75 08             	pushl  0x8(%ebp)
    9dc6:	e8 44 f6 ff ff       	call   940f <LodePNGUnknownChunks_cleanup>
    9dcb:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9dce:	90                   	nop
    9dcf:	c9                   	leave  
    9dd0:	c3                   	ret    

00009dd1 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9dd1:	55                   	push   %ebp
    9dd2:	89 e5                	mov    %esp,%ebp
    9dd4:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9dd7:	83 ec 0c             	sub    $0xc,%esp
    9dda:	ff 75 08             	pushl  0x8(%ebp)
    9ddd:	e8 9c ff ff ff       	call   9d7e <lodepng_info_cleanup>
    9de2:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9de5:	83 ec 04             	sub    $0x4,%esp
    9de8:	68 e4 00 00 00       	push   $0xe4
    9ded:	ff 75 0c             	pushl  0xc(%ebp)
    9df0:	ff 75 08             	pushl  0x8(%ebp)
    9df3:	e8 3d 98 ff ff       	call   3635 <lodepng_memcpy>
    9df8:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9dfb:	8b 45 08             	mov    0x8(%ebp),%eax
    9dfe:	83 c0 0c             	add    $0xc,%eax
    9e01:	83 ec 0c             	sub    $0xc,%esp
    9e04:	50                   	push   %eax
    9e05:	e8 fc ee ff ff       	call   8d06 <lodepng_color_mode_init>
    9e0a:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9e0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e10:	8d 50 0c             	lea    0xc(%eax),%edx
    9e13:	8b 45 08             	mov    0x8(%ebp),%eax
    9e16:	83 c0 0c             	add    $0xc,%eax
    9e19:	83 ec 08             	sub    $0x8,%esp
    9e1c:	52                   	push   %edx
    9e1d:	50                   	push   %eax
    9e1e:	e8 ed ef ff ff       	call   8e10 <lodepng_color_mode_copy>
    9e23:	83 c4 10             	add    $0x10,%esp
    9e26:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9e29:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9e2d:	74 08                	je     9e37 <lodepng_info_copy+0x66>
    9e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e32:	e9 b7 00 00 00       	jmp    9eee <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9e37:	83 ec 08             	sub    $0x8,%esp
    9e3a:	ff 75 0c             	pushl  0xc(%ebp)
    9e3d:	ff 75 08             	pushl  0x8(%ebp)
    9e40:	e8 84 f7 ff ff       	call   95c9 <LodePNGText_copy>
    9e45:	83 c4 10             	add    $0x10,%esp
    9e48:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9e4b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9e4f:	74 08                	je     9e59 <lodepng_info_copy+0x88>
    9e51:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9e54:	e9 95 00 00 00       	jmp    9eee <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9e59:	83 ec 08             	sub    $0x8,%esp
    9e5c:	ff 75 0c             	pushl  0xc(%ebp)
    9e5f:	ff 75 08             	pushl  0x8(%ebp)
    9e62:	e8 55 fa ff ff       	call   98bc <LodePNGIText_copy>
    9e67:	83 c4 10             	add    $0x10,%esp
    9e6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9e6d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9e71:	74 05                	je     9e78 <lodepng_info_copy+0xa7>
    9e73:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9e76:	eb 76                	jmp    9eee <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9e78:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e7b:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9e81:	85 c0                	test   %eax,%eax
    9e83:	74 37                	je     9ebc <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9e85:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e88:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9e8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e91:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9e97:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e9a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9ea0:	51                   	push   %ecx
    9ea1:	52                   	push   %edx
    9ea2:	50                   	push   %eax
    9ea3:	ff 75 08             	pushl  0x8(%ebp)
    9ea6:	e8 bc fc ff ff       	call   9b67 <lodepng_assign_icc>
    9eab:	83 c4 10             	add    $0x10,%esp
    9eae:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9eb1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9eb5:	74 05                	je     9ebc <lodepng_info_copy+0xeb>
    9eb7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9eba:	eb 32                	jmp    9eee <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9ebc:	83 ec 0c             	sub    $0xc,%esp
    9ebf:	ff 75 08             	pushl  0x8(%ebp)
    9ec2:	e8 f7 f4 ff ff       	call   93be <LodePNGUnknownChunks_init>
    9ec7:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9eca:	83 ec 08             	sub    $0x8,%esp
    9ecd:	ff 75 0c             	pushl  0xc(%ebp)
    9ed0:	ff 75 08             	pushl  0x8(%ebp)
    9ed3:	e8 6c f5 ff ff       	call   9444 <LodePNGUnknownChunks_copy>
    9ed8:	83 c4 10             	add    $0x10,%esp
    9edb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9ede:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9ee2:	74 05                	je     9ee9 <lodepng_info_copy+0x118>
    9ee4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9ee7:	eb 05                	jmp    9eee <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9ee9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9eee:	c9                   	leave  
    9eef:	c3                   	ret    

00009ef0 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9ef0:	55                   	push   %ebp
    9ef1:	89 e5                	mov    %esp,%ebp
    9ef3:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9ef6:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9efa:	74 14                	je     9f10 <addColorBits+0x20>
    9efc:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9f00:	75 07                	jne    9f09 <addColorBits+0x19>
    9f02:	b8 03 00 00 00       	mov    $0x3,%eax
    9f07:	eb 0c                	jmp    9f15 <addColorBits+0x25>
    9f09:	b8 01 00 00 00       	mov    $0x1,%eax
    9f0e:	eb 05                	jmp    9f15 <addColorBits+0x25>
    9f10:	b8 07 00 00 00       	mov    $0x7,%eax
    9f15:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9f18:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f1b:	23 45 fc             	and    -0x4(%ebp),%eax
    9f1e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9f21:	8b 45 10             	mov    0x10(%ebp),%eax
    9f24:	ba 01 00 00 00       	mov    $0x1,%edx
    9f29:	89 c1                	mov    %eax,%ecx
    9f2b:	d3 e2                	shl    %cl,%edx
    9f2d:	89 d0                	mov    %edx,%eax
    9f2f:	83 e8 01             	sub    $0x1,%eax
    9f32:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9f35:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9f38:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9f3b:	0f af 45 10          	imul   0x10(%ebp),%eax
    9f3f:	89 c1                	mov    %eax,%ecx
    9f41:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9f44:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9f48:	75 18                	jne    9f62 <addColorBits+0x72>
    9f4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f4d:	0f af 45 10          	imul   0x10(%ebp),%eax
    9f51:	c1 e8 03             	shr    $0x3,%eax
    9f54:	89 c2                	mov    %eax,%edx
    9f56:	8b 45 08             	mov    0x8(%ebp),%eax
    9f59:	01 d0                	add    %edx,%eax
    9f5b:	8b 55 14             	mov    0x14(%ebp),%edx
    9f5e:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9f60:	eb 1e                	jmp    9f80 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9f62:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f65:	0f af 45 10          	imul   0x10(%ebp),%eax
    9f69:	c1 e8 03             	shr    $0x3,%eax
    9f6c:	8b 55 08             	mov    0x8(%ebp),%edx
    9f6f:	01 c2                	add    %eax,%edx
    9f71:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9f74:	01 c8                	add    %ecx,%eax
    9f76:	0f b6 08             	movzbl (%eax),%ecx
    9f79:	8b 45 14             	mov    0x14(%ebp),%eax
    9f7c:	09 c8                	or     %ecx,%eax
    9f7e:	88 02                	mov    %al,(%edx)
}
    9f80:	90                   	nop
    9f81:	c9                   	leave  
    9f82:	c3                   	ret    

00009f83 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9f83:	55                   	push   %ebp
    9f84:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9f86:	8b 45 08             	mov    0x8(%ebp),%eax
    9f89:	6a 40                	push   $0x40
    9f8b:	6a 00                	push   $0x0
    9f8d:	50                   	push   %eax
    9f8e:	e8 d5 96 ff ff       	call   3668 <lodepng_memset>
    9f93:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9f96:	8b 45 08             	mov    0x8(%ebp),%eax
    9f99:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9fa0:	90                   	nop
    9fa1:	c9                   	leave  
    9fa2:	c3                   	ret    

00009fa3 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9fa3:	55                   	push   %ebp
    9fa4:	89 e5                	mov    %esp,%ebp
    9fa6:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9fa9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9fb0:	eb 3b                	jmp    9fed <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9fb2:	8b 45 08             	mov    0x8(%ebp),%eax
    9fb5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fb8:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fbb:	85 c0                	test   %eax,%eax
    9fbd:	74 2a                	je     9fe9 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9fbf:	8b 45 08             	mov    0x8(%ebp),%eax
    9fc2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fc5:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fc8:	83 ec 0c             	sub    $0xc,%esp
    9fcb:	50                   	push   %eax
    9fcc:	e8 d2 ff ff ff       	call   9fa3 <color_tree_cleanup>
    9fd1:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9fd4:	8b 45 08             	mov    0x8(%ebp),%eax
    9fd7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fda:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fdd:	83 ec 0c             	sub    $0xc,%esp
    9fe0:	50                   	push   %eax
    9fe1:	e8 32 96 ff ff       	call   3618 <lodepng_free>
    9fe6:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9fe9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9fed:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9ff1:	75 bf                	jne    9fb2 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9ff3:	90                   	nop
    9ff4:	c9                   	leave  
    9ff5:	c3                   	ret    

00009ff6 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9ff6:	55                   	push   %ebp
    9ff7:	89 e5                	mov    %esp,%ebp
    9ff9:	53                   	push   %ebx
    9ffa:	83 ec 20             	sub    $0x20,%esp
    9ffd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a000:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a003:	8b 55 14             	mov    0x14(%ebp),%edx
    a006:	8b 45 18             	mov    0x18(%ebp),%eax
    a009:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a00c:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a00f:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a012:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    a015:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    a01c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    a023:	eb 76                	jmp    a09b <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a025:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a029:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a02c:	89 c1                	mov    %eax,%ecx
    a02e:	d3 fa                	sar    %cl,%edx
    a030:	89 d0                	mov    %edx,%eax
    a032:	83 e0 01             	and    $0x1,%eax
    a035:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a038:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a03c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a03f:	89 c1                	mov    %eax,%ecx
    a041:	d3 fa                	sar    %cl,%edx
    a043:	89 d0                	mov    %edx,%eax
    a045:	83 e0 01             	and    $0x1,%eax
    a048:	01 d8                	add    %ebx,%eax
    a04a:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a04d:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a051:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a054:	89 c1                	mov    %eax,%ecx
    a056:	d3 fa                	sar    %cl,%edx
    a058:	89 d0                	mov    %edx,%eax
    a05a:	83 e0 01             	and    $0x1,%eax
    a05d:	01 d8                	add    %ebx,%eax
    a05f:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a062:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a066:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a069:	89 c1                	mov    %eax,%ecx
    a06b:	d3 fa                	sar    %cl,%edx
    a06d:	89 d0                	mov    %edx,%eax
    a06f:	83 e0 01             	and    $0x1,%eax
    a072:	01 d8                	add    %ebx,%eax
    a074:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    a077:	8b 45 08             	mov    0x8(%ebp),%eax
    a07a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a07d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a080:	85 c0                	test   %eax,%eax
    a082:	75 07                	jne    a08b <color_tree_get+0x95>
    a084:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a089:	eb 2a                	jmp    a0b5 <color_tree_get+0xbf>
    else tree = tree->children[i];
    a08b:	8b 45 08             	mov    0x8(%ebp),%eax
    a08e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a091:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a094:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    a097:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a09b:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    a09f:	7e 84                	jle    a025 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    a0a1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    a0a5:	74 08                	je     a0af <color_tree_get+0xb9>
    a0a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a0aa:	8b 40 40             	mov    0x40(%eax),%eax
    a0ad:	eb 05                	jmp    a0b4 <color_tree_get+0xbe>
    a0af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a0b4:	90                   	nop
}
    a0b5:	83 c4 20             	add    $0x20,%esp
    a0b8:	5b                   	pop    %ebx
    a0b9:	5d                   	pop    %ebp
    a0ba:	c3                   	ret    

0000a0bb <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a0bb:	55                   	push   %ebp
    a0bc:	89 e5                	mov    %esp,%ebp
    a0be:	53                   	push   %ebx
    a0bf:	83 ec 10             	sub    $0x10,%esp
    a0c2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a0c5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a0c8:	8b 55 14             	mov    0x14(%ebp),%edx
    a0cb:	8b 45 18             	mov    0x18(%ebp),%eax
    a0ce:	88 5d f8             	mov    %bl,-0x8(%ebp)
    a0d1:	88 4d f4             	mov    %cl,-0xc(%ebp)
    a0d4:	88 55 f0             	mov    %dl,-0x10(%ebp)
    a0d7:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    a0da:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    a0de:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    a0e2:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    a0e6:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    a0ea:	53                   	push   %ebx
    a0eb:	51                   	push   %ecx
    a0ec:	52                   	push   %edx
    a0ed:	50                   	push   %eax
    a0ee:	ff 75 08             	pushl  0x8(%ebp)
    a0f1:	e8 00 ff ff ff       	call   9ff6 <color_tree_get>
    a0f6:	83 c4 14             	add    $0x14,%esp
    a0f9:	f7 d0                	not    %eax
    a0fb:	c1 e8 1f             	shr    $0x1f,%eax
    a0fe:	0f b6 c0             	movzbl %al,%eax
}
    a101:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a104:	c9                   	leave  
    a105:	c3                   	ret    

0000a106 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    a106:	55                   	push   %ebp
    a107:	89 e5                	mov    %esp,%ebp
    a109:	53                   	push   %ebx
    a10a:	83 ec 24             	sub    $0x24,%esp
    a10d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a110:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a113:	8b 55 14             	mov    0x14(%ebp),%edx
    a116:	8b 45 18             	mov    0x18(%ebp),%eax
    a119:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    a11c:	88 4d e0             	mov    %cl,-0x20(%ebp)
    a11f:	88 55 dc             	mov    %dl,-0x24(%ebp)
    a122:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a125:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a12c:	e9 b0 00 00 00       	jmp    a1e1 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a131:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a135:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a138:	89 c1                	mov    %eax,%ecx
    a13a:	d3 fa                	sar    %cl,%edx
    a13c:	89 d0                	mov    %edx,%eax
    a13e:	83 e0 01             	and    $0x1,%eax
    a141:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a144:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a148:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a14b:	89 c1                	mov    %eax,%ecx
    a14d:	d3 fa                	sar    %cl,%edx
    a14f:	89 d0                	mov    %edx,%eax
    a151:	83 e0 01             	and    $0x1,%eax
    a154:	01 d8                	add    %ebx,%eax
    a156:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a159:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a15d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a160:	89 c1                	mov    %eax,%ecx
    a162:	d3 fa                	sar    %cl,%edx
    a164:	89 d0                	mov    %edx,%eax
    a166:	83 e0 01             	and    $0x1,%eax
    a169:	01 d8                	add    %ebx,%eax
    a16b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a16e:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    a172:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a175:	89 c1                	mov    %eax,%ecx
    a177:	d3 fa                	sar    %cl,%edx
    a179:	89 d0                	mov    %edx,%eax
    a17b:	83 e0 01             	and    $0x1,%eax
    a17e:	01 d8                	add    %ebx,%eax
    a180:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    a183:	8b 45 08             	mov    0x8(%ebp),%eax
    a186:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a189:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a18c:	85 c0                	test   %eax,%eax
    a18e:	75 41                	jne    a1d1 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    a190:	83 ec 0c             	sub    $0xc,%esp
    a193:	6a 44                	push   $0x44
    a195:	e8 5d 94 ff ff       	call   35f7 <lodepng_malloc>
    a19a:	83 c4 10             	add    $0x10,%esp
    a19d:	89 c1                	mov    %eax,%ecx
    a19f:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a1a5:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    a1a8:	8b 45 08             	mov    0x8(%ebp),%eax
    a1ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a1ae:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a1b1:	85 c0                	test   %eax,%eax
    a1b3:	75 07                	jne    a1bc <color_tree_add+0xb6>
    a1b5:	b8 53 00 00 00       	mov    $0x53,%eax
    a1ba:	eb 3d                	jmp    a1f9 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    a1bc:	8b 45 08             	mov    0x8(%ebp),%eax
    a1bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a1c2:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a1c5:	83 ec 0c             	sub    $0xc,%esp
    a1c8:	50                   	push   %eax
    a1c9:	e8 b5 fd ff ff       	call   9f83 <color_tree_init>
    a1ce:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    a1d1:	8b 45 08             	mov    0x8(%ebp),%eax
    a1d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a1d7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a1da:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a1dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a1e1:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    a1e5:	0f 8e 46 ff ff ff    	jle    a131 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    a1eb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a1ee:	8b 45 08             	mov    0x8(%ebp),%eax
    a1f1:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    a1f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a1f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a1fc:	c9                   	leave  
    a1fd:	c3                   	ret    

0000a1fe <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a1fe:	55                   	push   %ebp
    a1ff:	89 e5                	mov    %esp,%ebp
    a201:	53                   	push   %ebx
    a202:	83 ec 20             	sub    $0x20,%esp
    a205:	8b 5d 18             	mov    0x18(%ebp),%ebx
    a208:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    a20b:	8b 55 20             	mov    0x20(%ebp),%edx
    a20e:	8b 45 24             	mov    0x24(%ebp),%eax
    a211:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a214:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a217:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a21a:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a21d:	8b 45 10             	mov    0x10(%ebp),%eax
    a220:	8b 00                	mov    (%eax),%eax
    a222:	85 c0                	test   %eax,%eax
    a224:	0f 85 ad 00 00 00    	jne    a2d7 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a22a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a22e:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    a231:	8b 45 10             	mov    0x10(%ebp),%eax
    a234:	8b 40 04             	mov    0x4(%eax),%eax
    a237:	83 f8 08             	cmp    $0x8,%eax
    a23a:	75 13                	jne    a24f <rgba8ToPixel+0x51>
    a23c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a23f:	8b 45 08             	mov    0x8(%ebp),%eax
    a242:	01 c2                	add    %eax,%edx
    a244:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a248:	88 02                	mov    %al,(%edx)
    a24a:	e9 b4 03 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a24f:	8b 45 10             	mov    0x10(%ebp),%eax
    a252:	8b 40 04             	mov    0x4(%eax),%eax
    a255:	83 f8 10             	cmp    $0x10,%eax
    a258:	75 2a                	jne    a284 <rgba8ToPixel+0x86>
    a25a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a25d:	01 c0                	add    %eax,%eax
    a25f:	89 c2                	mov    %eax,%edx
    a261:	8b 45 08             	mov    0x8(%ebp),%eax
    a264:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a267:	8b 45 0c             	mov    0xc(%ebp),%eax
    a26a:	01 c0                	add    %eax,%eax
    a26c:	8d 50 01             	lea    0x1(%eax),%edx
    a26f:	8b 45 08             	mov    0x8(%ebp),%eax
    a272:	01 d0                	add    %edx,%eax
    a274:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a278:	88 10                	mov    %dl,(%eax)
    a27a:	0f b6 00             	movzbl (%eax),%eax
    a27d:	88 01                	mov    %al,(%ecx)
    a27f:	e9 7f 03 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a284:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a288:	8b 45 10             	mov    0x10(%ebp),%eax
    a28b:	8b 40 04             	mov    0x4(%eax),%eax
    a28e:	b9 08 00 00 00       	mov    $0x8,%ecx
    a293:	29 c1                	sub    %eax,%ecx
    a295:	89 c8                	mov    %ecx,%eax
    a297:	89 c1                	mov    %eax,%ecx
    a299:	d3 ea                	shr    %cl,%edx
    a29b:	89 d0                	mov    %edx,%eax
    a29d:	89 c2                	mov    %eax,%edx
    a29f:	8b 45 10             	mov    0x10(%ebp),%eax
    a2a2:	8b 40 04             	mov    0x4(%eax),%eax
    a2a5:	bb 01 00 00 00       	mov    $0x1,%ebx
    a2aa:	89 c1                	mov    %eax,%ecx
    a2ac:	d3 e3                	shl    %cl,%ebx
    a2ae:	89 d8                	mov    %ebx,%eax
    a2b0:	83 e8 01             	sub    $0x1,%eax
    a2b3:	21 d0                	and    %edx,%eax
    a2b5:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a2b8:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a2bc:	8b 45 10             	mov    0x10(%ebp),%eax
    a2bf:	8b 40 04             	mov    0x4(%eax),%eax
    a2c2:	52                   	push   %edx
    a2c3:	50                   	push   %eax
    a2c4:	ff 75 0c             	pushl  0xc(%ebp)
    a2c7:	ff 75 08             	pushl  0x8(%ebp)
    a2ca:	e8 21 fc ff ff       	call   9ef0 <addColorBits>
    a2cf:	83 c4 10             	add    $0x10,%esp
    a2d2:	e9 2c 03 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a2d7:	8b 45 10             	mov    0x10(%ebp),%eax
    a2da:	8b 00                	mov    (%eax),%eax
    a2dc:	83 f8 02             	cmp    $0x2,%eax
    a2df:	0f 85 ee 00 00 00    	jne    a3d3 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a2e5:	8b 45 10             	mov    0x10(%ebp),%eax
    a2e8:	8b 40 04             	mov    0x4(%eax),%eax
    a2eb:	83 f8 08             	cmp    $0x8,%eax
    a2ee:	75 49                	jne    a339 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a2f0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a2f3:	89 d0                	mov    %edx,%eax
    a2f5:	01 c0                	add    %eax,%eax
    a2f7:	01 d0                	add    %edx,%eax
    a2f9:	89 c2                	mov    %eax,%edx
    a2fb:	8b 45 08             	mov    0x8(%ebp),%eax
    a2fe:	01 c2                	add    %eax,%edx
    a300:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a304:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a306:	8b 55 0c             	mov    0xc(%ebp),%edx
    a309:	89 d0                	mov    %edx,%eax
    a30b:	01 c0                	add    %eax,%eax
    a30d:	01 d0                	add    %edx,%eax
    a30f:	8d 50 01             	lea    0x1(%eax),%edx
    a312:	8b 45 08             	mov    0x8(%ebp),%eax
    a315:	01 c2                	add    %eax,%edx
    a317:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a31b:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a31d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a320:	89 d0                	mov    %edx,%eax
    a322:	01 c0                	add    %eax,%eax
    a324:	01 d0                	add    %edx,%eax
    a326:	8d 50 02             	lea    0x2(%eax),%edx
    a329:	8b 45 08             	mov    0x8(%ebp),%eax
    a32c:	01 c2                	add    %eax,%edx
    a32e:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a332:	88 02                	mov    %al,(%edx)
    a334:	e9 ca 02 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a339:	8b 55 0c             	mov    0xc(%ebp),%edx
    a33c:	89 d0                	mov    %edx,%eax
    a33e:	01 c0                	add    %eax,%eax
    a340:	01 d0                	add    %edx,%eax
    a342:	01 c0                	add    %eax,%eax
    a344:	89 c2                	mov    %eax,%edx
    a346:	8b 45 08             	mov    0x8(%ebp),%eax
    a349:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a34c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a34f:	89 d0                	mov    %edx,%eax
    a351:	01 c0                	add    %eax,%eax
    a353:	01 d0                	add    %edx,%eax
    a355:	01 c0                	add    %eax,%eax
    a357:	8d 50 01             	lea    0x1(%eax),%edx
    a35a:	8b 45 08             	mov    0x8(%ebp),%eax
    a35d:	01 d0                	add    %edx,%eax
    a35f:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a363:	88 10                	mov    %dl,(%eax)
    a365:	0f b6 00             	movzbl (%eax),%eax
    a368:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a36a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a36d:	89 d0                	mov    %edx,%eax
    a36f:	01 c0                	add    %eax,%eax
    a371:	01 d0                	add    %edx,%eax
    a373:	01 c0                	add    %eax,%eax
    a375:	8d 50 02             	lea    0x2(%eax),%edx
    a378:	8b 45 08             	mov    0x8(%ebp),%eax
    a37b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a37e:	8b 55 0c             	mov    0xc(%ebp),%edx
    a381:	89 d0                	mov    %edx,%eax
    a383:	01 c0                	add    %eax,%eax
    a385:	01 d0                	add    %edx,%eax
    a387:	01 c0                	add    %eax,%eax
    a389:	8d 50 03             	lea    0x3(%eax),%edx
    a38c:	8b 45 08             	mov    0x8(%ebp),%eax
    a38f:	01 d0                	add    %edx,%eax
    a391:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a395:	88 10                	mov    %dl,(%eax)
    a397:	0f b6 00             	movzbl (%eax),%eax
    a39a:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a39c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a39f:	89 d0                	mov    %edx,%eax
    a3a1:	01 c0                	add    %eax,%eax
    a3a3:	01 d0                	add    %edx,%eax
    a3a5:	01 c0                	add    %eax,%eax
    a3a7:	8d 50 04             	lea    0x4(%eax),%edx
    a3aa:	8b 45 08             	mov    0x8(%ebp),%eax
    a3ad:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a3b0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3b3:	89 d0                	mov    %edx,%eax
    a3b5:	01 c0                	add    %eax,%eax
    a3b7:	01 d0                	add    %edx,%eax
    a3b9:	01 c0                	add    %eax,%eax
    a3bb:	8d 50 05             	lea    0x5(%eax),%edx
    a3be:	8b 45 08             	mov    0x8(%ebp),%eax
    a3c1:	01 d0                	add    %edx,%eax
    a3c3:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a3c7:	88 10                	mov    %dl,(%eax)
    a3c9:	0f b6 00             	movzbl (%eax),%eax
    a3cc:	88 01                	mov    %al,(%ecx)
    a3ce:	e9 30 02 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a3d3:	8b 45 10             	mov    0x10(%ebp),%eax
    a3d6:	8b 00                	mov    (%eax),%eax
    a3d8:	83 f8 03             	cmp    $0x3,%eax
    a3db:	75 6d                	jne    a44a <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a3dd:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a3e1:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a3e5:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a3e9:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a3ed:	53                   	push   %ebx
    a3ee:	51                   	push   %ecx
    a3ef:	52                   	push   %edx
    a3f0:	50                   	push   %eax
    a3f1:	ff 75 14             	pushl  0x14(%ebp)
    a3f4:	e8 fd fb ff ff       	call   9ff6 <color_tree_get>
    a3f9:	83 c4 14             	add    $0x14,%esp
    a3fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a3ff:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a403:	79 0a                	jns    a40f <rgba8ToPixel+0x211>
    a405:	b8 52 00 00 00       	mov    $0x52,%eax
    a40a:	e9 f9 01 00 00       	jmp    a608 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a40f:	8b 45 10             	mov    0x10(%ebp),%eax
    a412:	8b 40 04             	mov    0x4(%eax),%eax
    a415:	83 f8 08             	cmp    $0x8,%eax
    a418:	75 12                	jne    a42c <rgba8ToPixel+0x22e>
    a41a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a41d:	8b 45 08             	mov    0x8(%ebp),%eax
    a420:	01 d0                	add    %edx,%eax
    a422:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a425:	88 10                	mov    %dl,(%eax)
    a427:	e9 d7 01 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a42c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a42f:	8b 45 10             	mov    0x10(%ebp),%eax
    a432:	8b 40 04             	mov    0x4(%eax),%eax
    a435:	52                   	push   %edx
    a436:	50                   	push   %eax
    a437:	ff 75 0c             	pushl  0xc(%ebp)
    a43a:	ff 75 08             	pushl  0x8(%ebp)
    a43d:	e8 ae fa ff ff       	call   9ef0 <addColorBits>
    a442:	83 c4 10             	add    $0x10,%esp
    a445:	e9 b9 01 00 00       	jmp    a603 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a44a:	8b 45 10             	mov    0x10(%ebp),%eax
    a44d:	8b 00                	mov    (%eax),%eax
    a44f:	83 f8 04             	cmp    $0x4,%eax
    a452:	0f 85 9f 00 00 00    	jne    a4f7 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a458:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a45c:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a45f:	8b 45 10             	mov    0x10(%ebp),%eax
    a462:	8b 40 04             	mov    0x4(%eax),%eax
    a465:	83 f8 08             	cmp    $0x8,%eax
    a468:	75 2a                	jne    a494 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a46a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a46d:	01 c0                	add    %eax,%eax
    a46f:	89 c2                	mov    %eax,%edx
    a471:	8b 45 08             	mov    0x8(%ebp),%eax
    a474:	01 c2                	add    %eax,%edx
    a476:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a47a:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a47c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a47f:	01 c0                	add    %eax,%eax
    a481:	8d 50 01             	lea    0x1(%eax),%edx
    a484:	8b 45 08             	mov    0x8(%ebp),%eax
    a487:	01 c2                	add    %eax,%edx
    a489:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a48d:	88 02                	mov    %al,(%edx)
    a48f:	e9 6f 01 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a494:	8b 45 10             	mov    0x10(%ebp),%eax
    a497:	8b 40 04             	mov    0x4(%eax),%eax
    a49a:	83 f8 10             	cmp    $0x10,%eax
    a49d:	0f 85 60 01 00 00    	jne    a603 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a4a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4a6:	c1 e0 02             	shl    $0x2,%eax
    a4a9:	89 c2                	mov    %eax,%edx
    a4ab:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ae:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a4b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4b4:	c1 e0 02             	shl    $0x2,%eax
    a4b7:	8d 50 01             	lea    0x1(%eax),%edx
    a4ba:	8b 45 08             	mov    0x8(%ebp),%eax
    a4bd:	01 d0                	add    %edx,%eax
    a4bf:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a4c3:	88 10                	mov    %dl,(%eax)
    a4c5:	0f b6 00             	movzbl (%eax),%eax
    a4c8:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a4ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4cd:	c1 e0 02             	shl    $0x2,%eax
    a4d0:	8d 50 02             	lea    0x2(%eax),%edx
    a4d3:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a4d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4dc:	c1 e0 02             	shl    $0x2,%eax
    a4df:	8d 50 03             	lea    0x3(%eax),%edx
    a4e2:	8b 45 08             	mov    0x8(%ebp),%eax
    a4e5:	01 d0                	add    %edx,%eax
    a4e7:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a4eb:	88 10                	mov    %dl,(%eax)
    a4ed:	0f b6 00             	movzbl (%eax),%eax
    a4f0:	88 01                	mov    %al,(%ecx)
    a4f2:	e9 0c 01 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a4f7:	8b 45 10             	mov    0x10(%ebp),%eax
    a4fa:	8b 00                	mov    (%eax),%eax
    a4fc:	83 f8 06             	cmp    $0x6,%eax
    a4ff:	0f 85 fe 00 00 00    	jne    a603 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a505:	8b 45 10             	mov    0x10(%ebp),%eax
    a508:	8b 40 04             	mov    0x4(%eax),%eax
    a50b:	83 f8 08             	cmp    $0x8,%eax
    a50e:	75 54                	jne    a564 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a510:	8b 45 0c             	mov    0xc(%ebp),%eax
    a513:	c1 e0 02             	shl    $0x2,%eax
    a516:	89 c2                	mov    %eax,%edx
    a518:	8b 45 08             	mov    0x8(%ebp),%eax
    a51b:	01 c2                	add    %eax,%edx
    a51d:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a521:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a523:	8b 45 0c             	mov    0xc(%ebp),%eax
    a526:	c1 e0 02             	shl    $0x2,%eax
    a529:	8d 50 01             	lea    0x1(%eax),%edx
    a52c:	8b 45 08             	mov    0x8(%ebp),%eax
    a52f:	01 c2                	add    %eax,%edx
    a531:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a535:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a537:	8b 45 0c             	mov    0xc(%ebp),%eax
    a53a:	c1 e0 02             	shl    $0x2,%eax
    a53d:	8d 50 02             	lea    0x2(%eax),%edx
    a540:	8b 45 08             	mov    0x8(%ebp),%eax
    a543:	01 c2                	add    %eax,%edx
    a545:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a549:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a54b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a54e:	c1 e0 02             	shl    $0x2,%eax
    a551:	8d 50 03             	lea    0x3(%eax),%edx
    a554:	8b 45 08             	mov    0x8(%ebp),%eax
    a557:	01 c2                	add    %eax,%edx
    a559:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a55d:	88 02                	mov    %al,(%edx)
    a55f:	e9 9f 00 00 00       	jmp    a603 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a564:	8b 45 0c             	mov    0xc(%ebp),%eax
    a567:	c1 e0 03             	shl    $0x3,%eax
    a56a:	89 c2                	mov    %eax,%edx
    a56c:	8b 45 08             	mov    0x8(%ebp),%eax
    a56f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a572:	8b 45 0c             	mov    0xc(%ebp),%eax
    a575:	c1 e0 03             	shl    $0x3,%eax
    a578:	8d 50 01             	lea    0x1(%eax),%edx
    a57b:	8b 45 08             	mov    0x8(%ebp),%eax
    a57e:	01 d0                	add    %edx,%eax
    a580:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a584:	88 10                	mov    %dl,(%eax)
    a586:	0f b6 00             	movzbl (%eax),%eax
    a589:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a58b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a58e:	c1 e0 03             	shl    $0x3,%eax
    a591:	8d 50 02             	lea    0x2(%eax),%edx
    a594:	8b 45 08             	mov    0x8(%ebp),%eax
    a597:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a59a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a59d:	c1 e0 03             	shl    $0x3,%eax
    a5a0:	8d 50 03             	lea    0x3(%eax),%edx
    a5a3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5a6:	01 d0                	add    %edx,%eax
    a5a8:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a5ac:	88 10                	mov    %dl,(%eax)
    a5ae:	0f b6 00             	movzbl (%eax),%eax
    a5b1:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a5b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5b6:	c1 e0 03             	shl    $0x3,%eax
    a5b9:	8d 50 04             	lea    0x4(%eax),%edx
    a5bc:	8b 45 08             	mov    0x8(%ebp),%eax
    a5bf:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a5c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5c5:	c1 e0 03             	shl    $0x3,%eax
    a5c8:	8d 50 05             	lea    0x5(%eax),%edx
    a5cb:	8b 45 08             	mov    0x8(%ebp),%eax
    a5ce:	01 d0                	add    %edx,%eax
    a5d0:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a5d4:	88 10                	mov    %dl,(%eax)
    a5d6:	0f b6 00             	movzbl (%eax),%eax
    a5d9:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a5db:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5de:	c1 e0 03             	shl    $0x3,%eax
    a5e1:	8d 50 06             	lea    0x6(%eax),%edx
    a5e4:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a5ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5ed:	c1 e0 03             	shl    $0x3,%eax
    a5f0:	8d 50 07             	lea    0x7(%eax),%edx
    a5f3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5f6:	01 d0                	add    %edx,%eax
    a5f8:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a5fc:	88 10                	mov    %dl,(%eax)
    a5fe:	0f b6 00             	movzbl (%eax),%eax
    a601:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a603:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a608:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a60b:	c9                   	leave  
    a60c:	c3                   	ret    

0000a60d <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a60d:	55                   	push   %ebp
    a60e:	89 e5                	mov    %esp,%ebp
    a610:	53                   	push   %ebx
    a611:	83 ec 20             	sub    $0x20,%esp
    a614:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a617:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a61a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a61d:	8b 45 20             	mov    0x20(%ebp),%eax
    a620:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a624:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a628:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a62c:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a630:	8b 45 10             	mov    0x10(%ebp),%eax
    a633:	8b 00                	mov    (%eax),%eax
    a635:	85 c0                	test   %eax,%eax
    a637:	75 36                	jne    a66f <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a639:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a63d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a641:	8b 45 0c             	mov    0xc(%ebp),%eax
    a644:	01 c0                	add    %eax,%eax
    a646:	89 c2                	mov    %eax,%edx
    a648:	8b 45 08             	mov    0x8(%ebp),%eax
    a64b:	01 d0                	add    %edx,%eax
    a64d:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a651:	66 c1 ea 08          	shr    $0x8,%dx
    a655:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a657:	8b 45 0c             	mov    0xc(%ebp),%eax
    a65a:	01 c0                	add    %eax,%eax
    a65c:	8d 50 01             	lea    0x1(%eax),%edx
    a65f:	8b 45 08             	mov    0x8(%ebp),%eax
    a662:	01 d0                	add    %edx,%eax
    a664:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a668:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a66a:	e9 df 01 00 00       	jmp    a84e <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a66f:	8b 45 10             	mov    0x10(%ebp),%eax
    a672:	8b 00                	mov    (%eax),%eax
    a674:	83 f8 02             	cmp    $0x2,%eax
    a677:	0f 85 a6 00 00 00    	jne    a723 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a67d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a680:	89 d0                	mov    %edx,%eax
    a682:	01 c0                	add    %eax,%eax
    a684:	01 d0                	add    %edx,%eax
    a686:	01 c0                	add    %eax,%eax
    a688:	89 c2                	mov    %eax,%edx
    a68a:	8b 45 08             	mov    0x8(%ebp),%eax
    a68d:	01 d0                	add    %edx,%eax
    a68f:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a693:	66 c1 ea 08          	shr    $0x8,%dx
    a697:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a699:	8b 55 0c             	mov    0xc(%ebp),%edx
    a69c:	89 d0                	mov    %edx,%eax
    a69e:	01 c0                	add    %eax,%eax
    a6a0:	01 d0                	add    %edx,%eax
    a6a2:	01 c0                	add    %eax,%eax
    a6a4:	8d 50 01             	lea    0x1(%eax),%edx
    a6a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a6aa:	01 d0                	add    %edx,%eax
    a6ac:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a6b0:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a6b2:	8b 55 0c             	mov    0xc(%ebp),%edx
    a6b5:	89 d0                	mov    %edx,%eax
    a6b7:	01 c0                	add    %eax,%eax
    a6b9:	01 d0                	add    %edx,%eax
    a6bb:	01 c0                	add    %eax,%eax
    a6bd:	8d 50 02             	lea    0x2(%eax),%edx
    a6c0:	8b 45 08             	mov    0x8(%ebp),%eax
    a6c3:	01 d0                	add    %edx,%eax
    a6c5:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a6c9:	66 c1 ea 08          	shr    $0x8,%dx
    a6cd:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a6cf:	8b 55 0c             	mov    0xc(%ebp),%edx
    a6d2:	89 d0                	mov    %edx,%eax
    a6d4:	01 c0                	add    %eax,%eax
    a6d6:	01 d0                	add    %edx,%eax
    a6d8:	01 c0                	add    %eax,%eax
    a6da:	8d 50 03             	lea    0x3(%eax),%edx
    a6dd:	8b 45 08             	mov    0x8(%ebp),%eax
    a6e0:	01 d0                	add    %edx,%eax
    a6e2:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a6e6:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a6e8:	8b 55 0c             	mov    0xc(%ebp),%edx
    a6eb:	89 d0                	mov    %edx,%eax
    a6ed:	01 c0                	add    %eax,%eax
    a6ef:	01 d0                	add    %edx,%eax
    a6f1:	01 c0                	add    %eax,%eax
    a6f3:	8d 50 04             	lea    0x4(%eax),%edx
    a6f6:	8b 45 08             	mov    0x8(%ebp),%eax
    a6f9:	01 d0                	add    %edx,%eax
    a6fb:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a6ff:	66 c1 ea 08          	shr    $0x8,%dx
    a703:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a705:	8b 55 0c             	mov    0xc(%ebp),%edx
    a708:	89 d0                	mov    %edx,%eax
    a70a:	01 c0                	add    %eax,%eax
    a70c:	01 d0                	add    %edx,%eax
    a70e:	01 c0                	add    %eax,%eax
    a710:	8d 50 05             	lea    0x5(%eax),%edx
    a713:	8b 45 08             	mov    0x8(%ebp),%eax
    a716:	01 d0                	add    %edx,%eax
    a718:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a71c:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a71e:	e9 2b 01 00 00       	jmp    a84e <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a723:	8b 45 10             	mov    0x10(%ebp),%eax
    a726:	8b 00                	mov    (%eax),%eax
    a728:	83 f8 04             	cmp    $0x4,%eax
    a72b:	75 64                	jne    a791 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a72d:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a731:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a735:	8b 45 0c             	mov    0xc(%ebp),%eax
    a738:	c1 e0 02             	shl    $0x2,%eax
    a73b:	89 c2                	mov    %eax,%edx
    a73d:	8b 45 08             	mov    0x8(%ebp),%eax
    a740:	01 d0                	add    %edx,%eax
    a742:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a746:	66 c1 ea 08          	shr    $0x8,%dx
    a74a:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a74c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a74f:	c1 e0 02             	shl    $0x2,%eax
    a752:	8d 50 01             	lea    0x1(%eax),%edx
    a755:	8b 45 08             	mov    0x8(%ebp),%eax
    a758:	01 d0                	add    %edx,%eax
    a75a:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a75e:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a760:	8b 45 0c             	mov    0xc(%ebp),%eax
    a763:	c1 e0 02             	shl    $0x2,%eax
    a766:	8d 50 02             	lea    0x2(%eax),%edx
    a769:	8b 45 08             	mov    0x8(%ebp),%eax
    a76c:	01 d0                	add    %edx,%eax
    a76e:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a772:	66 c1 ea 08          	shr    $0x8,%dx
    a776:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a778:	8b 45 0c             	mov    0xc(%ebp),%eax
    a77b:	c1 e0 02             	shl    $0x2,%eax
    a77e:	8d 50 03             	lea    0x3(%eax),%edx
    a781:	8b 45 08             	mov    0x8(%ebp),%eax
    a784:	01 d0                	add    %edx,%eax
    a786:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a78a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a78c:	e9 bd 00 00 00       	jmp    a84e <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a791:	8b 45 10             	mov    0x10(%ebp),%eax
    a794:	8b 00                	mov    (%eax),%eax
    a796:	83 f8 06             	cmp    $0x6,%eax
    a799:	0f 85 af 00 00 00    	jne    a84e <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a79f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7a2:	c1 e0 03             	shl    $0x3,%eax
    a7a5:	89 c2                	mov    %eax,%edx
    a7a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a7aa:	01 d0                	add    %edx,%eax
    a7ac:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a7b0:	66 c1 ea 08          	shr    $0x8,%dx
    a7b4:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a7b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7b9:	c1 e0 03             	shl    $0x3,%eax
    a7bc:	8d 50 01             	lea    0x1(%eax),%edx
    a7bf:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c2:	01 d0                	add    %edx,%eax
    a7c4:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a7c8:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a7ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7cd:	c1 e0 03             	shl    $0x3,%eax
    a7d0:	8d 50 02             	lea    0x2(%eax),%edx
    a7d3:	8b 45 08             	mov    0x8(%ebp),%eax
    a7d6:	01 d0                	add    %edx,%eax
    a7d8:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a7dc:	66 c1 ea 08          	shr    $0x8,%dx
    a7e0:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a7e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7e5:	c1 e0 03             	shl    $0x3,%eax
    a7e8:	8d 50 03             	lea    0x3(%eax),%edx
    a7eb:	8b 45 08             	mov    0x8(%ebp),%eax
    a7ee:	01 d0                	add    %edx,%eax
    a7f0:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a7f4:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a7f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7f9:	c1 e0 03             	shl    $0x3,%eax
    a7fc:	8d 50 04             	lea    0x4(%eax),%edx
    a7ff:	8b 45 08             	mov    0x8(%ebp),%eax
    a802:	01 d0                	add    %edx,%eax
    a804:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a808:	66 c1 ea 08          	shr    $0x8,%dx
    a80c:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a80e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a811:	c1 e0 03             	shl    $0x3,%eax
    a814:	8d 50 05             	lea    0x5(%eax),%edx
    a817:	8b 45 08             	mov    0x8(%ebp),%eax
    a81a:	01 d0                	add    %edx,%eax
    a81c:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a820:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a822:	8b 45 0c             	mov    0xc(%ebp),%eax
    a825:	c1 e0 03             	shl    $0x3,%eax
    a828:	8d 50 06             	lea    0x6(%eax),%edx
    a82b:	8b 45 08             	mov    0x8(%ebp),%eax
    a82e:	01 d0                	add    %edx,%eax
    a830:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a834:	66 c1 ea 08          	shr    $0x8,%dx
    a838:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a83a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a83d:	c1 e0 03             	shl    $0x3,%eax
    a840:	8d 50 07             	lea    0x7(%eax),%edx
    a843:	8b 45 08             	mov    0x8(%ebp),%eax
    a846:	01 d0                	add    %edx,%eax
    a848:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a84c:	88 10                	mov    %dl,(%eax)
  }
}
    a84e:	90                   	nop
    a84f:	83 c4 20             	add    $0x20,%esp
    a852:	5b                   	pop    %ebx
    a853:	5d                   	pop    %ebp
    a854:	c3                   	ret    

0000a855 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a855:	55                   	push   %ebp
    a856:	89 e5                	mov    %esp,%ebp
    a858:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a85b:	8b 45 20             	mov    0x20(%ebp),%eax
    a85e:	8b 00                	mov    (%eax),%eax
    a860:	85 c0                	test   %eax,%eax
    a862:	0f 85 8c 01 00 00    	jne    a9f4 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a868:	8b 45 20             	mov    0x20(%ebp),%eax
    a86b:	8b 40 04             	mov    0x4(%eax),%eax
    a86e:	83 f8 08             	cmp    $0x8,%eax
    a871:	75 59                	jne    a8cc <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a873:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a876:	8b 45 18             	mov    0x18(%ebp),%eax
    a879:	01 d0                	add    %edx,%eax
    a87b:	0f b6 10             	movzbl (%eax),%edx
    a87e:	8b 45 10             	mov    0x10(%ebp),%eax
    a881:	88 10                	mov    %dl,(%eax)
    a883:	8b 45 10             	mov    0x10(%ebp),%eax
    a886:	0f b6 10             	movzbl (%eax),%edx
    a889:	8b 45 0c             	mov    0xc(%ebp),%eax
    a88c:	88 10                	mov    %dl,(%eax)
    a88e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a891:	0f b6 10             	movzbl (%eax),%edx
    a894:	8b 45 08             	mov    0x8(%ebp),%eax
    a897:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a899:	8b 45 20             	mov    0x20(%ebp),%eax
    a89c:	8b 40 10             	mov    0x10(%eax),%eax
    a89f:	85 c0                	test   %eax,%eax
    a8a1:	74 1e                	je     a8c1 <getPixelColorRGBA8+0x6c>
    a8a3:	8b 45 08             	mov    0x8(%ebp),%eax
    a8a6:	0f b6 00             	movzbl (%eax),%eax
    a8a9:	0f b6 d0             	movzbl %al,%edx
    a8ac:	8b 45 20             	mov    0x20(%ebp),%eax
    a8af:	8b 40 14             	mov    0x14(%eax),%eax
    a8b2:	39 c2                	cmp    %eax,%edx
    a8b4:	75 0b                	jne    a8c1 <getPixelColorRGBA8+0x6c>
    a8b6:	8b 45 14             	mov    0x14(%ebp),%eax
    a8b9:	c6 00 00             	movb   $0x0,(%eax)
    a8bc:	e9 5e 05 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a8c1:	8b 45 14             	mov    0x14(%ebp),%eax
    a8c4:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a8c7:	e9 53 05 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a8cc:	8b 45 20             	mov    0x20(%ebp),%eax
    a8cf:	8b 40 04             	mov    0x4(%eax),%eax
    a8d2:	83 f8 10             	cmp    $0x10,%eax
    a8d5:	0f 85 80 00 00 00    	jne    a95b <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a8db:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a8de:	01 c0                	add    %eax,%eax
    a8e0:	89 c2                	mov    %eax,%edx
    a8e2:	8b 45 18             	mov    0x18(%ebp),%eax
    a8e5:	01 d0                	add    %edx,%eax
    a8e7:	0f b6 10             	movzbl (%eax),%edx
    a8ea:	8b 45 10             	mov    0x10(%ebp),%eax
    a8ed:	88 10                	mov    %dl,(%eax)
    a8ef:	8b 45 10             	mov    0x10(%ebp),%eax
    a8f2:	0f b6 10             	movzbl (%eax),%edx
    a8f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8f8:	88 10                	mov    %dl,(%eax)
    a8fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8fd:	0f b6 10             	movzbl (%eax),%edx
    a900:	8b 45 08             	mov    0x8(%ebp),%eax
    a903:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a905:	8b 45 20             	mov    0x20(%ebp),%eax
    a908:	8b 40 10             	mov    0x10(%eax),%eax
    a90b:	85 c0                	test   %eax,%eax
    a90d:	74 41                	je     a950 <getPixelColorRGBA8+0xfb>
    a90f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a912:	01 c0                	add    %eax,%eax
    a914:	89 c2                	mov    %eax,%edx
    a916:	8b 45 18             	mov    0x18(%ebp),%eax
    a919:	01 d0                	add    %edx,%eax
    a91b:	0f b6 00             	movzbl (%eax),%eax
    a91e:	0f b6 c0             	movzbl %al,%eax
    a921:	c1 e0 08             	shl    $0x8,%eax
    a924:	89 c2                	mov    %eax,%edx
    a926:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a929:	01 c0                	add    %eax,%eax
    a92b:	8d 48 01             	lea    0x1(%eax),%ecx
    a92e:	8b 45 18             	mov    0x18(%ebp),%eax
    a931:	01 c8                	add    %ecx,%eax
    a933:	0f b6 00             	movzbl (%eax),%eax
    a936:	0f b6 c0             	movzbl %al,%eax
    a939:	01 c2                	add    %eax,%edx
    a93b:	8b 45 20             	mov    0x20(%ebp),%eax
    a93e:	8b 40 14             	mov    0x14(%eax),%eax
    a941:	39 c2                	cmp    %eax,%edx
    a943:	75 0b                	jne    a950 <getPixelColorRGBA8+0xfb>
    a945:	8b 45 14             	mov    0x14(%ebp),%eax
    a948:	c6 00 00             	movb   $0x0,(%eax)
    a94b:	e9 cf 04 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a950:	8b 45 14             	mov    0x14(%ebp),%eax
    a953:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a956:	e9 c4 04 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a95b:	8b 45 20             	mov    0x20(%ebp),%eax
    a95e:	8b 40 04             	mov    0x4(%eax),%eax
    a961:	ba 01 00 00 00       	mov    $0x1,%edx
    a966:	89 c1                	mov    %eax,%ecx
    a968:	d3 e2                	shl    %cl,%edx
    a96a:	89 d0                	mov    %edx,%eax
    a96c:	83 e8 01             	sub    $0x1,%eax
    a96f:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a972:	8b 45 20             	mov    0x20(%ebp),%eax
    a975:	8b 50 04             	mov    0x4(%eax),%edx
    a978:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a97b:	0f af c2             	imul   %edx,%eax
    a97e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a981:	8b 45 20             	mov    0x20(%ebp),%eax
    a984:	8b 40 04             	mov    0x4(%eax),%eax
    a987:	50                   	push   %eax
    a988:	ff 75 18             	pushl  0x18(%ebp)
    a98b:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a98e:	50                   	push   %eax
    a98f:	e8 06 db ff ff       	call   849a <readBitsFromReversedStream>
    a994:	83 c4 0c             	add    $0xc,%esp
    a997:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a99a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a99d:	89 d0                	mov    %edx,%eax
    a99f:	c1 e0 08             	shl    $0x8,%eax
    a9a2:	29 d0                	sub    %edx,%eax
    a9a4:	ba 00 00 00 00       	mov    $0x0,%edx
    a9a9:	f7 75 f8             	divl   -0x8(%ebp)
    a9ac:	89 c2                	mov    %eax,%edx
    a9ae:	8b 45 10             	mov    0x10(%ebp),%eax
    a9b1:	88 10                	mov    %dl,(%eax)
    a9b3:	8b 45 10             	mov    0x10(%ebp),%eax
    a9b6:	0f b6 10             	movzbl (%eax),%edx
    a9b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9bc:	88 10                	mov    %dl,(%eax)
    a9be:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9c1:	0f b6 10             	movzbl (%eax),%edx
    a9c4:	8b 45 08             	mov    0x8(%ebp),%eax
    a9c7:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a9c9:	8b 45 20             	mov    0x20(%ebp),%eax
    a9cc:	8b 40 10             	mov    0x10(%eax),%eax
    a9cf:	85 c0                	test   %eax,%eax
    a9d1:	74 16                	je     a9e9 <getPixelColorRGBA8+0x194>
    a9d3:	8b 45 20             	mov    0x20(%ebp),%eax
    a9d6:	8b 40 14             	mov    0x14(%eax),%eax
    a9d9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a9dc:	75 0b                	jne    a9e9 <getPixelColorRGBA8+0x194>
    a9de:	8b 45 14             	mov    0x14(%ebp),%eax
    a9e1:	c6 00 00             	movb   $0x0,(%eax)
    a9e4:	e9 36 04 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a9e9:	8b 45 14             	mov    0x14(%ebp),%eax
    a9ec:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9ef:	e9 2b 04 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a9f4:	8b 45 20             	mov    0x20(%ebp),%eax
    a9f7:	8b 00                	mov    (%eax),%eax
    a9f9:	83 f8 02             	cmp    $0x2,%eax
    a9fc:	0f 85 f5 01 00 00    	jne    abf7 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    aa02:	8b 45 20             	mov    0x20(%ebp),%eax
    aa05:	8b 40 04             	mov    0x4(%eax),%eax
    aa08:	83 f8 08             	cmp    $0x8,%eax
    aa0b:	0f 85 a3 00 00 00    	jne    aab4 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    aa11:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa14:	89 d0                	mov    %edx,%eax
    aa16:	01 c0                	add    %eax,%eax
    aa18:	01 d0                	add    %edx,%eax
    aa1a:	89 c2                	mov    %eax,%edx
    aa1c:	8b 45 18             	mov    0x18(%ebp),%eax
    aa1f:	01 d0                	add    %edx,%eax
    aa21:	0f b6 10             	movzbl (%eax),%edx
    aa24:	8b 45 08             	mov    0x8(%ebp),%eax
    aa27:	88 10                	mov    %dl,(%eax)
    aa29:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa2c:	89 d0                	mov    %edx,%eax
    aa2e:	01 c0                	add    %eax,%eax
    aa30:	01 d0                	add    %edx,%eax
    aa32:	8d 50 01             	lea    0x1(%eax),%edx
    aa35:	8b 45 18             	mov    0x18(%ebp),%eax
    aa38:	01 d0                	add    %edx,%eax
    aa3a:	0f b6 10             	movzbl (%eax),%edx
    aa3d:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa40:	88 10                	mov    %dl,(%eax)
    aa42:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa45:	89 d0                	mov    %edx,%eax
    aa47:	01 c0                	add    %eax,%eax
    aa49:	01 d0                	add    %edx,%eax
    aa4b:	8d 50 02             	lea    0x2(%eax),%edx
    aa4e:	8b 45 18             	mov    0x18(%ebp),%eax
    aa51:	01 d0                	add    %edx,%eax
    aa53:	0f b6 10             	movzbl (%eax),%edx
    aa56:	8b 45 10             	mov    0x10(%ebp),%eax
    aa59:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    aa5b:	8b 45 20             	mov    0x20(%ebp),%eax
    aa5e:	8b 40 10             	mov    0x10(%eax),%eax
    aa61:	85 c0                	test   %eax,%eax
    aa63:	74 44                	je     aaa9 <getPixelColorRGBA8+0x254>
    aa65:	8b 45 08             	mov    0x8(%ebp),%eax
    aa68:	0f b6 00             	movzbl (%eax),%eax
    aa6b:	0f b6 d0             	movzbl %al,%edx
    aa6e:	8b 45 20             	mov    0x20(%ebp),%eax
    aa71:	8b 40 14             	mov    0x14(%eax),%eax
    aa74:	39 c2                	cmp    %eax,%edx
    aa76:	75 31                	jne    aaa9 <getPixelColorRGBA8+0x254>
    aa78:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa7b:	0f b6 00             	movzbl (%eax),%eax
    aa7e:	0f b6 d0             	movzbl %al,%edx
    aa81:	8b 45 20             	mov    0x20(%ebp),%eax
    aa84:	8b 40 18             	mov    0x18(%eax),%eax
    aa87:	39 c2                	cmp    %eax,%edx
    aa89:	75 1e                	jne    aaa9 <getPixelColorRGBA8+0x254>
    aa8b:	8b 45 10             	mov    0x10(%ebp),%eax
    aa8e:	0f b6 00             	movzbl (%eax),%eax
    aa91:	0f b6 d0             	movzbl %al,%edx
    aa94:	8b 45 20             	mov    0x20(%ebp),%eax
    aa97:	8b 40 1c             	mov    0x1c(%eax),%eax
    aa9a:	39 c2                	cmp    %eax,%edx
    aa9c:	75 0b                	jne    aaa9 <getPixelColorRGBA8+0x254>
    aa9e:	8b 45 14             	mov    0x14(%ebp),%eax
    aaa1:	c6 00 00             	movb   $0x0,(%eax)
    aaa4:	e9 76 03 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    aaa9:	8b 45 14             	mov    0x14(%ebp),%eax
    aaac:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aaaf:	e9 6b 03 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    aab4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aab7:	89 d0                	mov    %edx,%eax
    aab9:	01 c0                	add    %eax,%eax
    aabb:	01 d0                	add    %edx,%eax
    aabd:	01 c0                	add    %eax,%eax
    aabf:	89 c2                	mov    %eax,%edx
    aac1:	8b 45 18             	mov    0x18(%ebp),%eax
    aac4:	01 d0                	add    %edx,%eax
    aac6:	0f b6 10             	movzbl (%eax),%edx
    aac9:	8b 45 08             	mov    0x8(%ebp),%eax
    aacc:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    aace:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aad1:	89 d0                	mov    %edx,%eax
    aad3:	01 c0                	add    %eax,%eax
    aad5:	01 d0                	add    %edx,%eax
    aad7:	01 c0                	add    %eax,%eax
    aad9:	8d 50 02             	lea    0x2(%eax),%edx
    aadc:	8b 45 18             	mov    0x18(%ebp),%eax
    aadf:	01 d0                	add    %edx,%eax
    aae1:	0f b6 10             	movzbl (%eax),%edx
    aae4:	8b 45 0c             	mov    0xc(%ebp),%eax
    aae7:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    aae9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aaec:	89 d0                	mov    %edx,%eax
    aaee:	01 c0                	add    %eax,%eax
    aaf0:	01 d0                	add    %edx,%eax
    aaf2:	01 c0                	add    %eax,%eax
    aaf4:	8d 50 04             	lea    0x4(%eax),%edx
    aaf7:	8b 45 18             	mov    0x18(%ebp),%eax
    aafa:	01 d0                	add    %edx,%eax
    aafc:	0f b6 10             	movzbl (%eax),%edx
    aaff:	8b 45 10             	mov    0x10(%ebp),%eax
    ab02:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    ab04:	8b 45 20             	mov    0x20(%ebp),%eax
    ab07:	8b 40 10             	mov    0x10(%eax),%eax
    ab0a:	85 c0                	test   %eax,%eax
    ab0c:	0f 84 da 00 00 00    	je     abec <getPixelColorRGBA8+0x397>
    ab12:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab15:	89 d0                	mov    %edx,%eax
    ab17:	01 c0                	add    %eax,%eax
    ab19:	01 d0                	add    %edx,%eax
    ab1b:	01 c0                	add    %eax,%eax
    ab1d:	89 c2                	mov    %eax,%edx
    ab1f:	8b 45 18             	mov    0x18(%ebp),%eax
    ab22:	01 d0                	add    %edx,%eax
    ab24:	0f b6 00             	movzbl (%eax),%eax
    ab27:	0f b6 c0             	movzbl %al,%eax
    ab2a:	c1 e0 08             	shl    $0x8,%eax
    ab2d:	89 c1                	mov    %eax,%ecx
    ab2f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab32:	89 d0                	mov    %edx,%eax
    ab34:	01 c0                	add    %eax,%eax
    ab36:	01 d0                	add    %edx,%eax
    ab38:	01 c0                	add    %eax,%eax
    ab3a:	8d 50 01             	lea    0x1(%eax),%edx
    ab3d:	8b 45 18             	mov    0x18(%ebp),%eax
    ab40:	01 d0                	add    %edx,%eax
    ab42:	0f b6 00             	movzbl (%eax),%eax
    ab45:	0f b6 c0             	movzbl %al,%eax
    ab48:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ab4b:	8b 45 20             	mov    0x20(%ebp),%eax
    ab4e:	8b 40 14             	mov    0x14(%eax),%eax
    ab51:	39 c2                	cmp    %eax,%edx
    ab53:	0f 85 93 00 00 00    	jne    abec <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    ab59:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab5c:	89 d0                	mov    %edx,%eax
    ab5e:	01 c0                	add    %eax,%eax
    ab60:	01 d0                	add    %edx,%eax
    ab62:	01 c0                	add    %eax,%eax
    ab64:	8d 50 02             	lea    0x2(%eax),%edx
    ab67:	8b 45 18             	mov    0x18(%ebp),%eax
    ab6a:	01 d0                	add    %edx,%eax
    ab6c:	0f b6 00             	movzbl (%eax),%eax
    ab6f:	0f b6 c0             	movzbl %al,%eax
    ab72:	c1 e0 08             	shl    $0x8,%eax
    ab75:	89 c1                	mov    %eax,%ecx
    ab77:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab7a:	89 d0                	mov    %edx,%eax
    ab7c:	01 c0                	add    %eax,%eax
    ab7e:	01 d0                	add    %edx,%eax
    ab80:	01 c0                	add    %eax,%eax
    ab82:	8d 50 03             	lea    0x3(%eax),%edx
    ab85:	8b 45 18             	mov    0x18(%ebp),%eax
    ab88:	01 d0                	add    %edx,%eax
    ab8a:	0f b6 00             	movzbl (%eax),%eax
    ab8d:	0f b6 c0             	movzbl %al,%eax
    ab90:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ab93:	8b 45 20             	mov    0x20(%ebp),%eax
    ab96:	8b 40 18             	mov    0x18(%eax),%eax
    ab99:	39 c2                	cmp    %eax,%edx
    ab9b:	75 4f                	jne    abec <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    ab9d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aba0:	89 d0                	mov    %edx,%eax
    aba2:	01 c0                	add    %eax,%eax
    aba4:	01 d0                	add    %edx,%eax
    aba6:	01 c0                	add    %eax,%eax
    aba8:	8d 50 04             	lea    0x4(%eax),%edx
    abab:	8b 45 18             	mov    0x18(%ebp),%eax
    abae:	01 d0                	add    %edx,%eax
    abb0:	0f b6 00             	movzbl (%eax),%eax
    abb3:	0f b6 c0             	movzbl %al,%eax
    abb6:	c1 e0 08             	shl    $0x8,%eax
    abb9:	89 c1                	mov    %eax,%ecx
    abbb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    abbe:	89 d0                	mov    %edx,%eax
    abc0:	01 c0                	add    %eax,%eax
    abc2:	01 d0                	add    %edx,%eax
    abc4:	01 c0                	add    %eax,%eax
    abc6:	8d 50 05             	lea    0x5(%eax),%edx
    abc9:	8b 45 18             	mov    0x18(%ebp),%eax
    abcc:	01 d0                	add    %edx,%eax
    abce:	0f b6 00             	movzbl (%eax),%eax
    abd1:	0f b6 c0             	movzbl %al,%eax
    abd4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    abd7:	8b 45 20             	mov    0x20(%ebp),%eax
    abda:	8b 40 1c             	mov    0x1c(%eax),%eax
    abdd:	39 c2                	cmp    %eax,%edx
    abdf:	75 0b                	jne    abec <getPixelColorRGBA8+0x397>
    abe1:	8b 45 14             	mov    0x14(%ebp),%eax
    abe4:	c6 00 00             	movb   $0x0,(%eax)
    abe7:	e9 33 02 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    abec:	8b 45 14             	mov    0x14(%ebp),%eax
    abef:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    abf2:	e9 28 02 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    abf7:	8b 45 20             	mov    0x20(%ebp),%eax
    abfa:	8b 00                	mov    (%eax),%eax
    abfc:	83 f8 03             	cmp    $0x3,%eax
    abff:	0f 85 ac 00 00 00    	jne    acb1 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    ac05:	8b 45 20             	mov    0x20(%ebp),%eax
    ac08:	8b 40 04             	mov    0x4(%eax),%eax
    ac0b:	83 f8 08             	cmp    $0x8,%eax
    ac0e:	75 13                	jne    ac23 <getPixelColorRGBA8+0x3ce>
    ac10:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ac13:	8b 45 18             	mov    0x18(%ebp),%eax
    ac16:	01 d0                	add    %edx,%eax
    ac18:	0f b6 00             	movzbl (%eax),%eax
    ac1b:	0f b6 c0             	movzbl %al,%eax
    ac1e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    ac21:	eb 28                	jmp    ac4b <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    ac23:	8b 45 20             	mov    0x20(%ebp),%eax
    ac26:	8b 50 04             	mov    0x4(%eax),%edx
    ac29:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac2c:	0f af c2             	imul   %edx,%eax
    ac2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ac32:	8b 45 20             	mov    0x20(%ebp),%eax
    ac35:	8b 40 04             	mov    0x4(%eax),%eax
    ac38:	50                   	push   %eax
    ac39:	ff 75 18             	pushl  0x18(%ebp)
    ac3c:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ac3f:	50                   	push   %eax
    ac40:	e8 55 d8 ff ff       	call   849a <readBitsFromReversedStream>
    ac45:	83 c4 0c             	add    $0xc,%esp
    ac48:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    ac4b:	8b 45 20             	mov    0x20(%ebp),%eax
    ac4e:	8b 40 08             	mov    0x8(%eax),%eax
    ac51:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ac54:	c1 e2 02             	shl    $0x2,%edx
    ac57:	01 d0                	add    %edx,%eax
    ac59:	0f b6 10             	movzbl (%eax),%edx
    ac5c:	8b 45 08             	mov    0x8(%ebp),%eax
    ac5f:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    ac61:	8b 45 20             	mov    0x20(%ebp),%eax
    ac64:	8b 40 08             	mov    0x8(%eax),%eax
    ac67:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ac6a:	c1 e2 02             	shl    $0x2,%edx
    ac6d:	83 c2 01             	add    $0x1,%edx
    ac70:	01 d0                	add    %edx,%eax
    ac72:	0f b6 10             	movzbl (%eax),%edx
    ac75:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac78:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    ac7a:	8b 45 20             	mov    0x20(%ebp),%eax
    ac7d:	8b 40 08             	mov    0x8(%eax),%eax
    ac80:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ac83:	c1 e2 02             	shl    $0x2,%edx
    ac86:	83 c2 02             	add    $0x2,%edx
    ac89:	01 d0                	add    %edx,%eax
    ac8b:	0f b6 10             	movzbl (%eax),%edx
    ac8e:	8b 45 10             	mov    0x10(%ebp),%eax
    ac91:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    ac93:	8b 45 20             	mov    0x20(%ebp),%eax
    ac96:	8b 40 08             	mov    0x8(%eax),%eax
    ac99:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ac9c:	c1 e2 02             	shl    $0x2,%edx
    ac9f:	83 c2 03             	add    $0x3,%edx
    aca2:	01 d0                	add    %edx,%eax
    aca4:	0f b6 10             	movzbl (%eax),%edx
    aca7:	8b 45 14             	mov    0x14(%ebp),%eax
    acaa:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    acac:	e9 6e 01 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    acb1:	8b 45 20             	mov    0x20(%ebp),%eax
    acb4:	8b 00                	mov    (%eax),%eax
    acb6:	83 f8 04             	cmp    $0x4,%eax
    acb9:	0f 85 95 00 00 00    	jne    ad54 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    acbf:	8b 45 20             	mov    0x20(%ebp),%eax
    acc2:	8b 40 04             	mov    0x4(%eax),%eax
    acc5:	83 f8 08             	cmp    $0x8,%eax
    acc8:	75 44                	jne    ad0e <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    acca:	8b 45 1c             	mov    0x1c(%ebp),%eax
    accd:	01 c0                	add    %eax,%eax
    accf:	89 c2                	mov    %eax,%edx
    acd1:	8b 45 18             	mov    0x18(%ebp),%eax
    acd4:	01 d0                	add    %edx,%eax
    acd6:	0f b6 10             	movzbl (%eax),%edx
    acd9:	8b 45 10             	mov    0x10(%ebp),%eax
    acdc:	88 10                	mov    %dl,(%eax)
    acde:	8b 45 10             	mov    0x10(%ebp),%eax
    ace1:	0f b6 10             	movzbl (%eax),%edx
    ace4:	8b 45 0c             	mov    0xc(%ebp),%eax
    ace7:	88 10                	mov    %dl,(%eax)
    ace9:	8b 45 0c             	mov    0xc(%ebp),%eax
    acec:	0f b6 10             	movzbl (%eax),%edx
    acef:	8b 45 08             	mov    0x8(%ebp),%eax
    acf2:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    acf4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    acf7:	01 c0                	add    %eax,%eax
    acf9:	8d 50 01             	lea    0x1(%eax),%edx
    acfc:	8b 45 18             	mov    0x18(%ebp),%eax
    acff:	01 d0                	add    %edx,%eax
    ad01:	0f b6 10             	movzbl (%eax),%edx
    ad04:	8b 45 14             	mov    0x14(%ebp),%eax
    ad07:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ad09:	e9 11 01 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    ad0e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad11:	c1 e0 02             	shl    $0x2,%eax
    ad14:	89 c2                	mov    %eax,%edx
    ad16:	8b 45 18             	mov    0x18(%ebp),%eax
    ad19:	01 d0                	add    %edx,%eax
    ad1b:	0f b6 10             	movzbl (%eax),%edx
    ad1e:	8b 45 10             	mov    0x10(%ebp),%eax
    ad21:	88 10                	mov    %dl,(%eax)
    ad23:	8b 45 10             	mov    0x10(%ebp),%eax
    ad26:	0f b6 10             	movzbl (%eax),%edx
    ad29:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad2c:	88 10                	mov    %dl,(%eax)
    ad2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad31:	0f b6 10             	movzbl (%eax),%edx
    ad34:	8b 45 08             	mov    0x8(%ebp),%eax
    ad37:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    ad39:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad3c:	c1 e0 02             	shl    $0x2,%eax
    ad3f:	8d 50 02             	lea    0x2(%eax),%edx
    ad42:	8b 45 18             	mov    0x18(%ebp),%eax
    ad45:	01 d0                	add    %edx,%eax
    ad47:	0f b6 10             	movzbl (%eax),%edx
    ad4a:	8b 45 14             	mov    0x14(%ebp),%eax
    ad4d:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ad4f:	e9 cb 00 00 00       	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    ad54:	8b 45 20             	mov    0x20(%ebp),%eax
    ad57:	8b 00                	mov    (%eax),%eax
    ad59:	83 f8 06             	cmp    $0x6,%eax
    ad5c:	0f 85 bd 00 00 00    	jne    ae1f <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    ad62:	8b 45 20             	mov    0x20(%ebp),%eax
    ad65:	8b 40 04             	mov    0x4(%eax),%eax
    ad68:	83 f8 08             	cmp    $0x8,%eax
    ad6b:	75 59                	jne    adc6 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    ad6d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad70:	c1 e0 02             	shl    $0x2,%eax
    ad73:	89 c2                	mov    %eax,%edx
    ad75:	8b 45 18             	mov    0x18(%ebp),%eax
    ad78:	01 d0                	add    %edx,%eax
    ad7a:	0f b6 10             	movzbl (%eax),%edx
    ad7d:	8b 45 08             	mov    0x8(%ebp),%eax
    ad80:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    ad82:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad85:	c1 e0 02             	shl    $0x2,%eax
    ad88:	8d 50 01             	lea    0x1(%eax),%edx
    ad8b:	8b 45 18             	mov    0x18(%ebp),%eax
    ad8e:	01 d0                	add    %edx,%eax
    ad90:	0f b6 10             	movzbl (%eax),%edx
    ad93:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad96:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    ad98:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad9b:	c1 e0 02             	shl    $0x2,%eax
    ad9e:	8d 50 02             	lea    0x2(%eax),%edx
    ada1:	8b 45 18             	mov    0x18(%ebp),%eax
    ada4:	01 d0                	add    %edx,%eax
    ada6:	0f b6 10             	movzbl (%eax),%edx
    ada9:	8b 45 10             	mov    0x10(%ebp),%eax
    adac:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    adae:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adb1:	c1 e0 02             	shl    $0x2,%eax
    adb4:	8d 50 03             	lea    0x3(%eax),%edx
    adb7:	8b 45 18             	mov    0x18(%ebp),%eax
    adba:	01 d0                	add    %edx,%eax
    adbc:	0f b6 10             	movzbl (%eax),%edx
    adbf:	8b 45 14             	mov    0x14(%ebp),%eax
    adc2:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    adc4:	eb 59                	jmp    ae1f <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    adc6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adc9:	c1 e0 03             	shl    $0x3,%eax
    adcc:	89 c2                	mov    %eax,%edx
    adce:	8b 45 18             	mov    0x18(%ebp),%eax
    add1:	01 d0                	add    %edx,%eax
    add3:	0f b6 10             	movzbl (%eax),%edx
    add6:	8b 45 08             	mov    0x8(%ebp),%eax
    add9:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    addb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adde:	c1 e0 03             	shl    $0x3,%eax
    ade1:	8d 50 02             	lea    0x2(%eax),%edx
    ade4:	8b 45 18             	mov    0x18(%ebp),%eax
    ade7:	01 d0                	add    %edx,%eax
    ade9:	0f b6 10             	movzbl (%eax),%edx
    adec:	8b 45 0c             	mov    0xc(%ebp),%eax
    adef:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    adf1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adf4:	c1 e0 03             	shl    $0x3,%eax
    adf7:	8d 50 04             	lea    0x4(%eax),%edx
    adfa:	8b 45 18             	mov    0x18(%ebp),%eax
    adfd:	01 d0                	add    %edx,%eax
    adff:	0f b6 10             	movzbl (%eax),%edx
    ae02:	8b 45 10             	mov    0x10(%ebp),%eax
    ae05:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    ae07:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ae0a:	c1 e0 03             	shl    $0x3,%eax
    ae0d:	8d 50 06             	lea    0x6(%eax),%edx
    ae10:	8b 45 18             	mov    0x18(%ebp),%eax
    ae13:	01 d0                	add    %edx,%eax
    ae15:	0f b6 10             	movzbl (%eax),%edx
    ae18:	8b 45 14             	mov    0x14(%ebp),%eax
    ae1b:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ae1d:	eb 00                	jmp    ae1f <getPixelColorRGBA8+0x5ca>
    ae1f:	90                   	nop
    ae20:	c9                   	leave  
    ae21:	c3                   	ret    

0000ae22 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ae22:	55                   	push   %ebp
    ae23:	89 e5                	mov    %esp,%ebp
    ae25:	53                   	push   %ebx
    ae26:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    ae29:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ae30:	8b 45 14             	mov    0x14(%ebp),%eax
    ae33:	8b 00                	mov    (%eax),%eax
    ae35:	85 c0                	test   %eax,%eax
    ae37:	0f 85 14 02 00 00    	jne    b051 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ae3d:	8b 45 14             	mov    0x14(%ebp),%eax
    ae40:	8b 40 04             	mov    0x4(%eax),%eax
    ae43:	83 f8 08             	cmp    $0x8,%eax
    ae46:	0f 85 a0 00 00 00    	jne    aeec <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae4c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae53:	eb 39                	jmp    ae8e <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ae55:	8b 45 08             	mov    0x8(%ebp),%eax
    ae58:	83 c0 01             	add    $0x1,%eax
    ae5b:	8b 55 08             	mov    0x8(%ebp),%edx
    ae5e:	83 c2 02             	add    $0x2,%edx
    ae61:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ae64:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ae67:	01 d9                	add    %ebx,%ecx
    ae69:	0f b6 09             	movzbl (%ecx),%ecx
    ae6c:	88 0a                	mov    %cl,(%edx)
    ae6e:	0f b6 12             	movzbl (%edx),%edx
    ae71:	88 10                	mov    %dl,(%eax)
    ae73:	0f b6 10             	movzbl (%eax),%edx
    ae76:	8b 45 08             	mov    0x8(%ebp),%eax
    ae79:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    ae7b:	8b 45 08             	mov    0x8(%ebp),%eax
    ae7e:	83 c0 03             	add    $0x3,%eax
    ae81:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae84:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae8b:	01 45 08             	add    %eax,0x8(%ebp)
    ae8e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae91:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae94:	75 bf                	jne    ae55 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ae96:	8b 45 14             	mov    0x14(%ebp),%eax
    ae99:	8b 40 10             	mov    0x10(%eax),%eax
    ae9c:	85 c0                	test   %eax,%eax
    ae9e:	0f 84 48 06 00 00    	je     b4ec <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    aea4:	8b 45 0c             	mov    0xc(%ebp),%eax
    aea7:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    aeab:	f7 d8                	neg    %eax
    aead:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aeb0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    aeb7:	eb 26                	jmp    aedf <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    aeb9:	8b 45 08             	mov    0x8(%ebp),%eax
    aebc:	0f b6 00             	movzbl (%eax),%eax
    aebf:	0f b6 d0             	movzbl %al,%edx
    aec2:	8b 45 14             	mov    0x14(%ebp),%eax
    aec5:	8b 40 14             	mov    0x14(%eax),%eax
    aec8:	39 c2                	cmp    %eax,%edx
    aeca:	75 09                	jne    aed5 <getPixelColorsRGBA8+0xb3>
    aecc:	8b 45 08             	mov    0x8(%ebp),%eax
    aecf:	83 c0 03             	add    $0x3,%eax
    aed2:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aed5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aed9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aedc:	01 45 08             	add    %eax,0x8(%ebp)
    aedf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    aee2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    aee5:	75 d2                	jne    aeb9 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    aee7:	e9 00 06 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    aeec:	8b 45 14             	mov    0x14(%ebp),%eax
    aeef:	8b 40 04             	mov    0x4(%eax),%eax
    aef2:	83 f8 10             	cmp    $0x10,%eax
    aef5:	0f 85 a5 00 00 00    	jne    afa0 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aefb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    af02:	e9 88 00 00 00       	jmp    af8f <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    af07:	8b 45 08             	mov    0x8(%ebp),%eax
    af0a:	83 c0 01             	add    $0x1,%eax
    af0d:	8b 55 08             	mov    0x8(%ebp),%edx
    af10:	83 c2 02             	add    $0x2,%edx
    af13:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    af16:	01 c9                	add    %ecx,%ecx
    af18:	89 cb                	mov    %ecx,%ebx
    af1a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    af1d:	01 d9                	add    %ebx,%ecx
    af1f:	0f b6 09             	movzbl (%ecx),%ecx
    af22:	88 0a                	mov    %cl,(%edx)
    af24:	0f b6 12             	movzbl (%edx),%edx
    af27:	88 10                	mov    %dl,(%eax)
    af29:	0f b6 10             	movzbl (%eax),%edx
    af2c:	8b 45 08             	mov    0x8(%ebp),%eax
    af2f:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    af31:	8b 45 08             	mov    0x8(%ebp),%eax
    af34:	8d 50 03             	lea    0x3(%eax),%edx
    af37:	8b 45 14             	mov    0x14(%ebp),%eax
    af3a:	8b 40 10             	mov    0x10(%eax),%eax
    af3d:	85 c0                	test   %eax,%eax
    af3f:	74 3d                	je     af7e <getPixelColorsRGBA8+0x15c>
    af41:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af44:	01 c0                	add    %eax,%eax
    af46:	89 c1                	mov    %eax,%ecx
    af48:	8b 45 10             	mov    0x10(%ebp),%eax
    af4b:	01 c8                	add    %ecx,%eax
    af4d:	0f b6 00             	movzbl (%eax),%eax
    af50:	0f b6 c0             	movzbl %al,%eax
    af53:	c1 e0 08             	shl    $0x8,%eax
    af56:	89 c1                	mov    %eax,%ecx
    af58:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af5b:	01 c0                	add    %eax,%eax
    af5d:	8d 58 01             	lea    0x1(%eax),%ebx
    af60:	8b 45 10             	mov    0x10(%ebp),%eax
    af63:	01 d8                	add    %ebx,%eax
    af65:	0f b6 00             	movzbl (%eax),%eax
    af68:	0f b6 c0             	movzbl %al,%eax
    af6b:	01 c1                	add    %eax,%ecx
    af6d:	8b 45 14             	mov    0x14(%ebp),%eax
    af70:	8b 40 14             	mov    0x14(%eax),%eax
    af73:	39 c1                	cmp    %eax,%ecx
    af75:	75 07                	jne    af7e <getPixelColorsRGBA8+0x15c>
    af77:	b8 00 00 00 00       	mov    $0x0,%eax
    af7c:	eb 05                	jmp    af83 <getPixelColorsRGBA8+0x161>
    af7e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    af83:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af85:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    af89:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af8c:	01 45 08             	add    %eax,0x8(%ebp)
    af8f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af92:	3b 45 0c             	cmp    0xc(%ebp),%eax
    af95:	0f 85 6c ff ff ff    	jne    af07 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    af9b:	e9 4c 05 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    afa0:	8b 45 14             	mov    0x14(%ebp),%eax
    afa3:	8b 40 04             	mov    0x4(%eax),%eax
    afa6:	ba 01 00 00 00       	mov    $0x1,%edx
    afab:	89 c1                	mov    %eax,%ecx
    afad:	d3 e2                	shl    %cl,%edx
    afaf:	89 d0                	mov    %edx,%eax
    afb1:	83 e8 01             	sub    $0x1,%eax
    afb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    afb7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afbe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    afc5:	eb 79                	jmp    b040 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    afc7:	8b 45 14             	mov    0x14(%ebp),%eax
    afca:	8b 40 04             	mov    0x4(%eax),%eax
    afcd:	50                   	push   %eax
    afce:	ff 75 10             	pushl  0x10(%ebp)
    afd1:	8d 45 e0             	lea    -0x20(%ebp),%eax
    afd4:	50                   	push   %eax
    afd5:	e8 c0 d4 ff ff       	call   849a <readBitsFromReversedStream>
    afda:	83 c4 0c             	add    $0xc,%esp
    afdd:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    afe0:	8b 45 08             	mov    0x8(%ebp),%eax
    afe3:	8d 48 01             	lea    0x1(%eax),%ecx
    afe6:	8b 45 08             	mov    0x8(%ebp),%eax
    afe9:	8d 58 02             	lea    0x2(%eax),%ebx
    afec:	8b 55 ec             	mov    -0x14(%ebp),%edx
    afef:	89 d0                	mov    %edx,%eax
    aff1:	c1 e0 08             	shl    $0x8,%eax
    aff4:	29 d0                	sub    %edx,%eax
    aff6:	ba 00 00 00 00       	mov    $0x0,%edx
    affb:	f7 75 f0             	divl   -0x10(%ebp)
    affe:	88 03                	mov    %al,(%ebx)
    b000:	0f b6 03             	movzbl (%ebx),%eax
    b003:	88 01                	mov    %al,(%ecx)
    b005:	0f b6 11             	movzbl (%ecx),%edx
    b008:	8b 45 08             	mov    0x8(%ebp),%eax
    b00b:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    b00d:	8b 45 08             	mov    0x8(%ebp),%eax
    b010:	8d 50 03             	lea    0x3(%eax),%edx
    b013:	8b 45 14             	mov    0x14(%ebp),%eax
    b016:	8b 40 10             	mov    0x10(%eax),%eax
    b019:	85 c0                	test   %eax,%eax
    b01b:	74 12                	je     b02f <getPixelColorsRGBA8+0x20d>
    b01d:	8b 45 14             	mov    0x14(%ebp),%eax
    b020:	8b 40 14             	mov    0x14(%eax),%eax
    b023:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    b026:	75 07                	jne    b02f <getPixelColorsRGBA8+0x20d>
    b028:	b8 00 00 00 00       	mov    $0x0,%eax
    b02d:	eb 05                	jmp    b034 <getPixelColorsRGBA8+0x212>
    b02f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b034:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b036:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b03a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b03d:	01 45 08             	add    %eax,0x8(%ebp)
    b040:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b043:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b046:	0f 85 7b ff ff ff    	jne    afc7 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b04c:	e9 9b 04 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b051:	8b 45 14             	mov    0x14(%ebp),%eax
    b054:	8b 00                	mov    (%eax),%eax
    b056:	83 f8 02             	cmp    $0x2,%eax
    b059:	0f 85 41 02 00 00    	jne    b2a0 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    b05f:	8b 45 14             	mov    0x14(%ebp),%eax
    b062:	8b 40 04             	mov    0x4(%eax),%eax
    b065:	83 f8 08             	cmp    $0x8,%eax
    b068:	0f 85 c4 00 00 00    	jne    b132 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b06e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b075:	eb 31                	jmp    b0a8 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    b077:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b07a:	89 d0                	mov    %edx,%eax
    b07c:	01 c0                	add    %eax,%eax
    b07e:	01 d0                	add    %edx,%eax
    b080:	89 c2                	mov    %eax,%edx
    b082:	8b 45 10             	mov    0x10(%ebp),%eax
    b085:	01 d0                	add    %edx,%eax
    b087:	6a 03                	push   $0x3
    b089:	50                   	push   %eax
    b08a:	ff 75 08             	pushl  0x8(%ebp)
    b08d:	e8 a3 85 ff ff       	call   3635 <lodepng_memcpy>
    b092:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    b095:	8b 45 08             	mov    0x8(%ebp),%eax
    b098:	83 c0 03             	add    $0x3,%eax
    b09b:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b09e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b0a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b0a5:	01 45 08             	add    %eax,0x8(%ebp)
    b0a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0ab:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b0ae:	75 c7                	jne    b077 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b0b0:	8b 45 14             	mov    0x14(%ebp),%eax
    b0b3:	8b 40 10             	mov    0x10(%eax),%eax
    b0b6:	85 c0                	test   %eax,%eax
    b0b8:	0f 84 2e 04 00 00    	je     b4ec <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b0be:	8b 45 0c             	mov    0xc(%ebp),%eax
    b0c1:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b0c5:	f7 d8                	neg    %eax
    b0c7:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0ca:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0d1:	eb 52                	jmp    b125 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    b0d3:	8b 45 08             	mov    0x8(%ebp),%eax
    b0d6:	0f b6 00             	movzbl (%eax),%eax
    b0d9:	0f b6 d0             	movzbl %al,%edx
    b0dc:	8b 45 14             	mov    0x14(%ebp),%eax
    b0df:	8b 40 14             	mov    0x14(%eax),%eax
    b0e2:	39 c2                	cmp    %eax,%edx
    b0e4:	75 35                	jne    b11b <getPixelColorsRGBA8+0x2f9>
    b0e6:	8b 45 08             	mov    0x8(%ebp),%eax
    b0e9:	83 c0 01             	add    $0x1,%eax
    b0ec:	0f b6 00             	movzbl (%eax),%eax
    b0ef:	0f b6 d0             	movzbl %al,%edx
    b0f2:	8b 45 14             	mov    0x14(%ebp),%eax
    b0f5:	8b 40 18             	mov    0x18(%eax),%eax
    b0f8:	39 c2                	cmp    %eax,%edx
    b0fa:	75 1f                	jne    b11b <getPixelColorsRGBA8+0x2f9>
    b0fc:	8b 45 08             	mov    0x8(%ebp),%eax
    b0ff:	83 c0 02             	add    $0x2,%eax
    b102:	0f b6 00             	movzbl (%eax),%eax
    b105:	0f b6 d0             	movzbl %al,%edx
    b108:	8b 45 14             	mov    0x14(%ebp),%eax
    b10b:	8b 40 1c             	mov    0x1c(%eax),%eax
    b10e:	39 c2                	cmp    %eax,%edx
    b110:	75 09                	jne    b11b <getPixelColorsRGBA8+0x2f9>
    b112:	8b 45 08             	mov    0x8(%ebp),%eax
    b115:	83 c0 03             	add    $0x3,%eax
    b118:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b11b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b11f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b122:	01 45 08             	add    %eax,0x8(%ebp)
    b125:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b128:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b12b:	75 a6                	jne    b0d3 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b12d:	e9 ba 03 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b132:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b139:	e9 51 01 00 00       	jmp    b28f <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    b13e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b141:	89 d0                	mov    %edx,%eax
    b143:	01 c0                	add    %eax,%eax
    b145:	01 d0                	add    %edx,%eax
    b147:	01 c0                	add    %eax,%eax
    b149:	89 c2                	mov    %eax,%edx
    b14b:	8b 45 10             	mov    0x10(%ebp),%eax
    b14e:	01 d0                	add    %edx,%eax
    b150:	0f b6 10             	movzbl (%eax),%edx
    b153:	8b 45 08             	mov    0x8(%ebp),%eax
    b156:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b158:	8b 45 08             	mov    0x8(%ebp),%eax
    b15b:	8d 48 01             	lea    0x1(%eax),%ecx
    b15e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b161:	89 d0                	mov    %edx,%eax
    b163:	01 c0                	add    %eax,%eax
    b165:	01 d0                	add    %edx,%eax
    b167:	01 c0                	add    %eax,%eax
    b169:	8d 50 02             	lea    0x2(%eax),%edx
    b16c:	8b 45 10             	mov    0x10(%ebp),%eax
    b16f:	01 d0                	add    %edx,%eax
    b171:	0f b6 00             	movzbl (%eax),%eax
    b174:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b176:	8b 45 08             	mov    0x8(%ebp),%eax
    b179:	8d 48 02             	lea    0x2(%eax),%ecx
    b17c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b17f:	89 d0                	mov    %edx,%eax
    b181:	01 c0                	add    %eax,%eax
    b183:	01 d0                	add    %edx,%eax
    b185:	01 c0                	add    %eax,%eax
    b187:	8d 50 04             	lea    0x4(%eax),%edx
    b18a:	8b 45 10             	mov    0x10(%ebp),%eax
    b18d:	01 d0                	add    %edx,%eax
    b18f:	0f b6 00             	movzbl (%eax),%eax
    b192:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    b194:	8b 45 08             	mov    0x8(%ebp),%eax
    b197:	8d 48 03             	lea    0x3(%eax),%ecx
    b19a:	8b 45 14             	mov    0x14(%ebp),%eax
    b19d:	8b 40 10             	mov    0x10(%eax),%eax
    b1a0:	85 c0                	test   %eax,%eax
    b1a2:	0f 84 d6 00 00 00    	je     b27e <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b1a8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b1ab:	89 d0                	mov    %edx,%eax
    b1ad:	01 c0                	add    %eax,%eax
    b1af:	01 d0                	add    %edx,%eax
    b1b1:	01 c0                	add    %eax,%eax
    b1b3:	89 c2                	mov    %eax,%edx
    b1b5:	8b 45 10             	mov    0x10(%ebp),%eax
    b1b8:	01 d0                	add    %edx,%eax
    b1ba:	0f b6 00             	movzbl (%eax),%eax
    b1bd:	0f b6 c0             	movzbl %al,%eax
    b1c0:	c1 e0 08             	shl    $0x8,%eax
    b1c3:	89 c3                	mov    %eax,%ebx
    b1c5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b1c8:	89 d0                	mov    %edx,%eax
    b1ca:	01 c0                	add    %eax,%eax
    b1cc:	01 d0                	add    %edx,%eax
    b1ce:	01 c0                	add    %eax,%eax
    b1d0:	8d 50 01             	lea    0x1(%eax),%edx
    b1d3:	8b 45 10             	mov    0x10(%ebp),%eax
    b1d6:	01 d0                	add    %edx,%eax
    b1d8:	0f b6 00             	movzbl (%eax),%eax
    b1db:	0f b6 c0             	movzbl %al,%eax
    b1de:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b1e1:	8b 45 14             	mov    0x14(%ebp),%eax
    b1e4:	8b 40 14             	mov    0x14(%eax),%eax
    b1e7:	39 c2                	cmp    %eax,%edx
    b1e9:	0f 85 8f 00 00 00    	jne    b27e <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b1ef:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b1f2:	89 d0                	mov    %edx,%eax
    b1f4:	01 c0                	add    %eax,%eax
    b1f6:	01 d0                	add    %edx,%eax
    b1f8:	01 c0                	add    %eax,%eax
    b1fa:	8d 50 02             	lea    0x2(%eax),%edx
    b1fd:	8b 45 10             	mov    0x10(%ebp),%eax
    b200:	01 d0                	add    %edx,%eax
    b202:	0f b6 00             	movzbl (%eax),%eax
    b205:	0f b6 c0             	movzbl %al,%eax
    b208:	c1 e0 08             	shl    $0x8,%eax
    b20b:	89 c3                	mov    %eax,%ebx
    b20d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b210:	89 d0                	mov    %edx,%eax
    b212:	01 c0                	add    %eax,%eax
    b214:	01 d0                	add    %edx,%eax
    b216:	01 c0                	add    %eax,%eax
    b218:	8d 50 03             	lea    0x3(%eax),%edx
    b21b:	8b 45 10             	mov    0x10(%ebp),%eax
    b21e:	01 d0                	add    %edx,%eax
    b220:	0f b6 00             	movzbl (%eax),%eax
    b223:	0f b6 c0             	movzbl %al,%eax
    b226:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b229:	8b 45 14             	mov    0x14(%ebp),%eax
    b22c:	8b 40 18             	mov    0x18(%eax),%eax
    b22f:	39 c2                	cmp    %eax,%edx
    b231:	75 4b                	jne    b27e <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    b233:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b236:	89 d0                	mov    %edx,%eax
    b238:	01 c0                	add    %eax,%eax
    b23a:	01 d0                	add    %edx,%eax
    b23c:	01 c0                	add    %eax,%eax
    b23e:	8d 50 04             	lea    0x4(%eax),%edx
    b241:	8b 45 10             	mov    0x10(%ebp),%eax
    b244:	01 d0                	add    %edx,%eax
    b246:	0f b6 00             	movzbl (%eax),%eax
    b249:	0f b6 c0             	movzbl %al,%eax
    b24c:	c1 e0 08             	shl    $0x8,%eax
    b24f:	89 c3                	mov    %eax,%ebx
    b251:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b254:	89 d0                	mov    %edx,%eax
    b256:	01 c0                	add    %eax,%eax
    b258:	01 d0                	add    %edx,%eax
    b25a:	01 c0                	add    %eax,%eax
    b25c:	8d 50 05             	lea    0x5(%eax),%edx
    b25f:	8b 45 10             	mov    0x10(%ebp),%eax
    b262:	01 d0                	add    %edx,%eax
    b264:	0f b6 00             	movzbl (%eax),%eax
    b267:	0f b6 c0             	movzbl %al,%eax
    b26a:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b26d:	8b 45 14             	mov    0x14(%ebp),%eax
    b270:	8b 40 1c             	mov    0x1c(%eax),%eax
    b273:	39 c2                	cmp    %eax,%edx
    b275:	75 07                	jne    b27e <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b277:	b8 00 00 00 00       	mov    $0x0,%eax
    b27c:	eb 05                	jmp    b283 <getPixelColorsRGBA8+0x461>
    b27e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b283:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b285:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b289:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b28c:	01 45 08             	add    %eax,0x8(%ebp)
    b28f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b292:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b295:	0f 85 a3 fe ff ff    	jne    b13e <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b29b:	e9 4c 02 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b2a0:	8b 45 14             	mov    0x14(%ebp),%eax
    b2a3:	8b 00                	mov    (%eax),%eax
    b2a5:	83 f8 03             	cmp    $0x3,%eax
    b2a8:	0f 85 b4 00 00 00    	jne    b362 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b2ae:	8b 45 14             	mov    0x14(%ebp),%eax
    b2b1:	8b 40 04             	mov    0x4(%eax),%eax
    b2b4:	83 f8 08             	cmp    $0x8,%eax
    b2b7:	75 4d                	jne    b306 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2b9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2c0:	eb 37                	jmp    b2f9 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b2c2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b2c5:	8b 45 10             	mov    0x10(%ebp),%eax
    b2c8:	01 d0                	add    %edx,%eax
    b2ca:	0f b6 00             	movzbl (%eax),%eax
    b2cd:	0f b6 c0             	movzbl %al,%eax
    b2d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b2d3:	8b 45 14             	mov    0x14(%ebp),%eax
    b2d6:	8b 40 08             	mov    0x8(%eax),%eax
    b2d9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b2dc:	c1 e2 02             	shl    $0x2,%edx
    b2df:	01 d0                	add    %edx,%eax
    b2e1:	6a 04                	push   $0x4
    b2e3:	50                   	push   %eax
    b2e4:	ff 75 08             	pushl  0x8(%ebp)
    b2e7:	e8 49 83 ff ff       	call   3635 <lodepng_memcpy>
    b2ec:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2ef:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2f6:	01 45 08             	add    %eax,0x8(%ebp)
    b2f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2fc:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2ff:	75 c1                	jne    b2c2 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b301:	e9 e6 01 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b306:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b30d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b314:	eb 3f                	jmp    b355 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b316:	8b 45 14             	mov    0x14(%ebp),%eax
    b319:	8b 40 04             	mov    0x4(%eax),%eax
    b31c:	50                   	push   %eax
    b31d:	ff 75 10             	pushl  0x10(%ebp)
    b320:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b323:	50                   	push   %eax
    b324:	e8 71 d1 ff ff       	call   849a <readBitsFromReversedStream>
    b329:	83 c4 0c             	add    $0xc,%esp
    b32c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b32f:	8b 45 14             	mov    0x14(%ebp),%eax
    b332:	8b 40 08             	mov    0x8(%eax),%eax
    b335:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b338:	c1 e2 02             	shl    $0x2,%edx
    b33b:	01 d0                	add    %edx,%eax
    b33d:	6a 04                	push   $0x4
    b33f:	50                   	push   %eax
    b340:	ff 75 08             	pushl  0x8(%ebp)
    b343:	e8 ed 82 ff ff       	call   3635 <lodepng_memcpy>
    b348:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b34b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b34f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b352:	01 45 08             	add    %eax,0x8(%ebp)
    b355:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b358:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b35b:	75 b9                	jne    b316 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b35d:	e9 8a 01 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b362:	8b 45 14             	mov    0x14(%ebp),%eax
    b365:	8b 00                	mov    (%eax),%eax
    b367:	83 f8 04             	cmp    $0x4,%eax
    b36a:	0f 85 d1 00 00 00    	jne    b441 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b370:	8b 45 14             	mov    0x14(%ebp),%eax
    b373:	8b 40 04             	mov    0x4(%eax),%eax
    b376:	83 f8 08             	cmp    $0x8,%eax
    b379:	75 62                	jne    b3dd <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b37b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b382:	eb 4c                	jmp    b3d0 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b384:	8b 45 08             	mov    0x8(%ebp),%eax
    b387:	83 c0 01             	add    $0x1,%eax
    b38a:	8b 55 08             	mov    0x8(%ebp),%edx
    b38d:	83 c2 02             	add    $0x2,%edx
    b390:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b393:	01 c9                	add    %ecx,%ecx
    b395:	89 cb                	mov    %ecx,%ebx
    b397:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b39a:	01 d9                	add    %ebx,%ecx
    b39c:	0f b6 09             	movzbl (%ecx),%ecx
    b39f:	88 0a                	mov    %cl,(%edx)
    b3a1:	0f b6 12             	movzbl (%edx),%edx
    b3a4:	88 10                	mov    %dl,(%eax)
    b3a6:	0f b6 10             	movzbl (%eax),%edx
    b3a9:	8b 45 08             	mov    0x8(%ebp),%eax
    b3ac:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b3ae:	8b 45 08             	mov    0x8(%ebp),%eax
    b3b1:	8d 50 03             	lea    0x3(%eax),%edx
    b3b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3b7:	01 c0                	add    %eax,%eax
    b3b9:	8d 48 01             	lea    0x1(%eax),%ecx
    b3bc:	8b 45 10             	mov    0x10(%ebp),%eax
    b3bf:	01 c8                	add    %ecx,%eax
    b3c1:	0f b6 00             	movzbl (%eax),%eax
    b3c4:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3c6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3cd:	01 45 08             	add    %eax,0x8(%ebp)
    b3d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3d3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3d6:	75 ac                	jne    b384 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b3d8:	e9 0f 01 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3e4:	eb 4e                	jmp    b434 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b3e6:	8b 45 08             	mov    0x8(%ebp),%eax
    b3e9:	83 c0 01             	add    $0x1,%eax
    b3ec:	8b 55 08             	mov    0x8(%ebp),%edx
    b3ef:	83 c2 02             	add    $0x2,%edx
    b3f2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b3f5:	c1 e1 02             	shl    $0x2,%ecx
    b3f8:	89 cb                	mov    %ecx,%ebx
    b3fa:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b3fd:	01 d9                	add    %ebx,%ecx
    b3ff:	0f b6 09             	movzbl (%ecx),%ecx
    b402:	88 0a                	mov    %cl,(%edx)
    b404:	0f b6 12             	movzbl (%edx),%edx
    b407:	88 10                	mov    %dl,(%eax)
    b409:	0f b6 10             	movzbl (%eax),%edx
    b40c:	8b 45 08             	mov    0x8(%ebp),%eax
    b40f:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b411:	8b 45 08             	mov    0x8(%ebp),%eax
    b414:	8d 50 03             	lea    0x3(%eax),%edx
    b417:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b41a:	c1 e0 02             	shl    $0x2,%eax
    b41d:	8d 48 02             	lea    0x2(%eax),%ecx
    b420:	8b 45 10             	mov    0x10(%ebp),%eax
    b423:	01 c8                	add    %ecx,%eax
    b425:	0f b6 00             	movzbl (%eax),%eax
    b428:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b42a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b42e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b431:	01 45 08             	add    %eax,0x8(%ebp)
    b434:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b437:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b43a:	75 aa                	jne    b3e6 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b43c:	e9 ab 00 00 00       	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b441:	8b 45 14             	mov    0x14(%ebp),%eax
    b444:	8b 00                	mov    (%eax),%eax
    b446:	83 f8 06             	cmp    $0x6,%eax
    b449:	0f 85 9d 00 00 00    	jne    b4ec <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b44f:	8b 45 14             	mov    0x14(%ebp),%eax
    b452:	8b 40 04             	mov    0x4(%eax),%eax
    b455:	83 f8 08             	cmp    $0x8,%eax
    b458:	75 17                	jne    b471 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b45a:	8b 45 0c             	mov    0xc(%ebp),%eax
    b45d:	c1 e0 02             	shl    $0x2,%eax
    b460:	50                   	push   %eax
    b461:	ff 75 10             	pushl  0x10(%ebp)
    b464:	ff 75 08             	pushl  0x8(%ebp)
    b467:	e8 c9 81 ff ff       	call   3635 <lodepng_memcpy>
    b46c:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b46f:	eb 7b                	jmp    b4ec <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b471:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b478:	eb 6a                	jmp    b4e4 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b47a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b47d:	c1 e0 03             	shl    $0x3,%eax
    b480:	89 c2                	mov    %eax,%edx
    b482:	8b 45 10             	mov    0x10(%ebp),%eax
    b485:	01 d0                	add    %edx,%eax
    b487:	0f b6 10             	movzbl (%eax),%edx
    b48a:	8b 45 08             	mov    0x8(%ebp),%eax
    b48d:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b48f:	8b 45 08             	mov    0x8(%ebp),%eax
    b492:	8d 50 01             	lea    0x1(%eax),%edx
    b495:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b498:	c1 e0 03             	shl    $0x3,%eax
    b49b:	8d 48 02             	lea    0x2(%eax),%ecx
    b49e:	8b 45 10             	mov    0x10(%ebp),%eax
    b4a1:	01 c8                	add    %ecx,%eax
    b4a3:	0f b6 00             	movzbl (%eax),%eax
    b4a6:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b4a8:	8b 45 08             	mov    0x8(%ebp),%eax
    b4ab:	8d 50 02             	lea    0x2(%eax),%edx
    b4ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4b1:	c1 e0 03             	shl    $0x3,%eax
    b4b4:	8d 48 04             	lea    0x4(%eax),%ecx
    b4b7:	8b 45 10             	mov    0x10(%ebp),%eax
    b4ba:	01 c8                	add    %ecx,%eax
    b4bc:	0f b6 00             	movzbl (%eax),%eax
    b4bf:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b4c1:	8b 45 08             	mov    0x8(%ebp),%eax
    b4c4:	8d 50 03             	lea    0x3(%eax),%edx
    b4c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4ca:	c1 e0 03             	shl    $0x3,%eax
    b4cd:	8d 48 06             	lea    0x6(%eax),%ecx
    b4d0:	8b 45 10             	mov    0x10(%ebp),%eax
    b4d3:	01 c8                	add    %ecx,%eax
    b4d5:	0f b6 00             	movzbl (%eax),%eax
    b4d8:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4da:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4de:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4e1:	01 45 08             	add    %eax,0x8(%ebp)
    b4e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4e7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4ea:	75 8e                	jne    b47a <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b4ec:	90                   	nop
    b4ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b4f0:	c9                   	leave  
    b4f1:	c3                   	ret    

0000b4f2 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b4f2:	55                   	push   %ebp
    b4f3:	89 e5                	mov    %esp,%ebp
    b4f5:	53                   	push   %ebx
    b4f6:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b4f9:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b500:	8b 45 14             	mov    0x14(%ebp),%eax
    b503:	8b 00                	mov    (%eax),%eax
    b505:	85 c0                	test   %eax,%eax
    b507:	0f 85 2a 01 00 00    	jne    b637 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b50d:	8b 45 14             	mov    0x14(%ebp),%eax
    b510:	8b 40 04             	mov    0x4(%eax),%eax
    b513:	83 f8 08             	cmp    $0x8,%eax
    b516:	75 46                	jne    b55e <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b518:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b51f:	eb 30                	jmp    b551 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b521:	8b 45 08             	mov    0x8(%ebp),%eax
    b524:	83 c0 01             	add    $0x1,%eax
    b527:	8b 55 08             	mov    0x8(%ebp),%edx
    b52a:	83 c2 02             	add    $0x2,%edx
    b52d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b530:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b533:	01 d9                	add    %ebx,%ecx
    b535:	0f b6 09             	movzbl (%ecx),%ecx
    b538:	88 0a                	mov    %cl,(%edx)
    b53a:	0f b6 12             	movzbl (%edx),%edx
    b53d:	88 10                	mov    %dl,(%eax)
    b53f:	0f b6 10             	movzbl (%eax),%edx
    b542:	8b 45 08             	mov    0x8(%ebp),%eax
    b545:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b547:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b54b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b54e:	01 45 08             	add    %eax,0x8(%ebp)
    b551:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b554:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b557:	75 c8                	jne    b521 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b559:	e9 a8 03 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b55e:	8b 45 14             	mov    0x14(%ebp),%eax
    b561:	8b 40 04             	mov    0x4(%eax),%eax
    b564:	83 f8 10             	cmp    $0x10,%eax
    b567:	75 4a                	jne    b5b3 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b569:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b570:	eb 34                	jmp    b5a6 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b572:	8b 45 08             	mov    0x8(%ebp),%eax
    b575:	83 c0 01             	add    $0x1,%eax
    b578:	8b 55 08             	mov    0x8(%ebp),%edx
    b57b:	83 c2 02             	add    $0x2,%edx
    b57e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b581:	01 c9                	add    %ecx,%ecx
    b583:	89 cb                	mov    %ecx,%ebx
    b585:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b588:	01 d9                	add    %ebx,%ecx
    b58a:	0f b6 09             	movzbl (%ecx),%ecx
    b58d:	88 0a                	mov    %cl,(%edx)
    b58f:	0f b6 12             	movzbl (%edx),%edx
    b592:	88 10                	mov    %dl,(%eax)
    b594:	0f b6 10             	movzbl (%eax),%edx
    b597:	8b 45 08             	mov    0x8(%ebp),%eax
    b59a:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b59c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5a3:	01 45 08             	add    %eax,0x8(%ebp)
    b5a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5a9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5ac:	75 c4                	jne    b572 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5ae:	e9 53 03 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b5b3:	8b 45 14             	mov    0x14(%ebp),%eax
    b5b6:	8b 40 04             	mov    0x4(%eax),%eax
    b5b9:	ba 01 00 00 00       	mov    $0x1,%edx
    b5be:	89 c1                	mov    %eax,%ecx
    b5c0:	d3 e2                	shl    %cl,%edx
    b5c2:	89 d0                	mov    %edx,%eax
    b5c4:	83 e8 01             	sub    $0x1,%eax
    b5c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b5ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5d1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5d8:	eb 50                	jmp    b62a <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b5da:	8b 45 14             	mov    0x14(%ebp),%eax
    b5dd:	8b 40 04             	mov    0x4(%eax),%eax
    b5e0:	50                   	push   %eax
    b5e1:	ff 75 10             	pushl  0x10(%ebp)
    b5e4:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b5e7:	50                   	push   %eax
    b5e8:	e8 ad ce ff ff       	call   849a <readBitsFromReversedStream>
    b5ed:	83 c4 0c             	add    $0xc,%esp
    b5f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b5f3:	8b 45 08             	mov    0x8(%ebp),%eax
    b5f6:	8d 48 01             	lea    0x1(%eax),%ecx
    b5f9:	8b 45 08             	mov    0x8(%ebp),%eax
    b5fc:	8d 58 02             	lea    0x2(%eax),%ebx
    b5ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b602:	89 d0                	mov    %edx,%eax
    b604:	c1 e0 08             	shl    $0x8,%eax
    b607:	29 d0                	sub    %edx,%eax
    b609:	ba 00 00 00 00       	mov    $0x0,%edx
    b60e:	f7 75 f0             	divl   -0x10(%ebp)
    b611:	88 03                	mov    %al,(%ebx)
    b613:	0f b6 03             	movzbl (%ebx),%eax
    b616:	88 01                	mov    %al,(%ecx)
    b618:	0f b6 11             	movzbl (%ecx),%edx
    b61b:	8b 45 08             	mov    0x8(%ebp),%eax
    b61e:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b620:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b624:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b627:	01 45 08             	add    %eax,0x8(%ebp)
    b62a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b62d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b630:	75 a8                	jne    b5da <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b632:	e9 cf 02 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b637:	8b 45 14             	mov    0x14(%ebp),%eax
    b63a:	8b 00                	mov    (%eax),%eax
    b63c:	83 f8 02             	cmp    $0x2,%eax
    b63f:	0f 85 9e 00 00 00    	jne    b6e3 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b645:	8b 45 14             	mov    0x14(%ebp),%eax
    b648:	8b 40 04             	mov    0x4(%eax),%eax
    b64b:	83 f8 08             	cmp    $0x8,%eax
    b64e:	75 1d                	jne    b66d <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b650:	8b 55 0c             	mov    0xc(%ebp),%edx
    b653:	89 d0                	mov    %edx,%eax
    b655:	01 c0                	add    %eax,%eax
    b657:	01 d0                	add    %edx,%eax
    b659:	50                   	push   %eax
    b65a:	ff 75 10             	pushl  0x10(%ebp)
    b65d:	ff 75 08             	pushl  0x8(%ebp)
    b660:	e8 d0 7f ff ff       	call   3635 <lodepng_memcpy>
    b665:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b668:	e9 99 02 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b66d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b674:	eb 60                	jmp    b6d6 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b676:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b679:	89 d0                	mov    %edx,%eax
    b67b:	01 c0                	add    %eax,%eax
    b67d:	01 d0                	add    %edx,%eax
    b67f:	01 c0                	add    %eax,%eax
    b681:	89 c2                	mov    %eax,%edx
    b683:	8b 45 10             	mov    0x10(%ebp),%eax
    b686:	01 d0                	add    %edx,%eax
    b688:	0f b6 10             	movzbl (%eax),%edx
    b68b:	8b 45 08             	mov    0x8(%ebp),%eax
    b68e:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b690:	8b 45 08             	mov    0x8(%ebp),%eax
    b693:	8d 48 01             	lea    0x1(%eax),%ecx
    b696:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b699:	89 d0                	mov    %edx,%eax
    b69b:	01 c0                	add    %eax,%eax
    b69d:	01 d0                	add    %edx,%eax
    b69f:	01 c0                	add    %eax,%eax
    b6a1:	8d 50 02             	lea    0x2(%eax),%edx
    b6a4:	8b 45 10             	mov    0x10(%ebp),%eax
    b6a7:	01 d0                	add    %edx,%eax
    b6a9:	0f b6 00             	movzbl (%eax),%eax
    b6ac:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b6ae:	8b 45 08             	mov    0x8(%ebp),%eax
    b6b1:	8d 48 02             	lea    0x2(%eax),%ecx
    b6b4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b6b7:	89 d0                	mov    %edx,%eax
    b6b9:	01 c0                	add    %eax,%eax
    b6bb:	01 d0                	add    %edx,%eax
    b6bd:	01 c0                	add    %eax,%eax
    b6bf:	8d 50 04             	lea    0x4(%eax),%edx
    b6c2:	8b 45 10             	mov    0x10(%ebp),%eax
    b6c5:	01 d0                	add    %edx,%eax
    b6c7:	0f b6 00             	movzbl (%eax),%eax
    b6ca:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6cc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b6d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6d3:	01 45 08             	add    %eax,0x8(%ebp)
    b6d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6d9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b6dc:	75 98                	jne    b676 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b6de:	e9 23 02 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b6e3:	8b 45 14             	mov    0x14(%ebp),%eax
    b6e6:	8b 00                	mov    (%eax),%eax
    b6e8:	83 f8 03             	cmp    $0x3,%eax
    b6eb:	0f 85 b4 00 00 00    	jne    b7a5 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b6f1:	8b 45 14             	mov    0x14(%ebp),%eax
    b6f4:	8b 40 04             	mov    0x4(%eax),%eax
    b6f7:	83 f8 08             	cmp    $0x8,%eax
    b6fa:	75 4d                	jne    b749 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b703:	eb 37                	jmp    b73c <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b705:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b708:	8b 45 10             	mov    0x10(%ebp),%eax
    b70b:	01 d0                	add    %edx,%eax
    b70d:	0f b6 00             	movzbl (%eax),%eax
    b710:	0f b6 c0             	movzbl %al,%eax
    b713:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b716:	8b 45 14             	mov    0x14(%ebp),%eax
    b719:	8b 40 08             	mov    0x8(%eax),%eax
    b71c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b71f:	c1 e2 02             	shl    $0x2,%edx
    b722:	01 d0                	add    %edx,%eax
    b724:	6a 03                	push   $0x3
    b726:	50                   	push   %eax
    b727:	ff 75 08             	pushl  0x8(%ebp)
    b72a:	e8 06 7f ff ff       	call   3635 <lodepng_memcpy>
    b72f:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b732:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b736:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b739:	01 45 08             	add    %eax,0x8(%ebp)
    b73c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b73f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b742:	75 c1                	jne    b705 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b744:	e9 bd 01 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b749:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b750:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b757:	eb 3f                	jmp    b798 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b759:	8b 45 14             	mov    0x14(%ebp),%eax
    b75c:	8b 40 04             	mov    0x4(%eax),%eax
    b75f:	50                   	push   %eax
    b760:	ff 75 10             	pushl  0x10(%ebp)
    b763:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b766:	50                   	push   %eax
    b767:	e8 2e cd ff ff       	call   849a <readBitsFromReversedStream>
    b76c:	83 c4 0c             	add    $0xc,%esp
    b76f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b772:	8b 45 14             	mov    0x14(%ebp),%eax
    b775:	8b 40 08             	mov    0x8(%eax),%eax
    b778:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b77b:	c1 e2 02             	shl    $0x2,%edx
    b77e:	01 d0                	add    %edx,%eax
    b780:	6a 03                	push   $0x3
    b782:	50                   	push   %eax
    b783:	ff 75 08             	pushl  0x8(%ebp)
    b786:	e8 aa 7e ff ff       	call   3635 <lodepng_memcpy>
    b78b:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b78e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b792:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b795:	01 45 08             	add    %eax,0x8(%ebp)
    b798:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b79b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b79e:	75 b9                	jne    b759 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b7a0:	e9 61 01 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b7a5:	8b 45 14             	mov    0x14(%ebp),%eax
    b7a8:	8b 00                	mov    (%eax),%eax
    b7aa:	83 f8 04             	cmp    $0x4,%eax
    b7ad:	0f 85 a0 00 00 00    	jne    b853 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b7b3:	8b 45 14             	mov    0x14(%ebp),%eax
    b7b6:	8b 40 04             	mov    0x4(%eax),%eax
    b7b9:	83 f8 08             	cmp    $0x8,%eax
    b7bc:	75 4a                	jne    b808 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b7c5:	eb 34                	jmp    b7fb <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b7c7:	8b 45 08             	mov    0x8(%ebp),%eax
    b7ca:	83 c0 01             	add    $0x1,%eax
    b7cd:	8b 55 08             	mov    0x8(%ebp),%edx
    b7d0:	83 c2 02             	add    $0x2,%edx
    b7d3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b7d6:	01 c9                	add    %ecx,%ecx
    b7d8:	89 cb                	mov    %ecx,%ebx
    b7da:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b7dd:	01 d9                	add    %ebx,%ecx
    b7df:	0f b6 09             	movzbl (%ecx),%ecx
    b7e2:	88 0a                	mov    %cl,(%edx)
    b7e4:	0f b6 12             	movzbl (%edx),%edx
    b7e7:	88 10                	mov    %dl,(%eax)
    b7e9:	0f b6 10             	movzbl (%eax),%edx
    b7ec:	8b 45 08             	mov    0x8(%ebp),%eax
    b7ef:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7f1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b7f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b7f8:	01 45 08             	add    %eax,0x8(%ebp)
    b7fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b7fe:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b801:	75 c4                	jne    b7c7 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b803:	e9 fe 00 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b808:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b80f:	eb 35                	jmp    b846 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b811:	8b 45 08             	mov    0x8(%ebp),%eax
    b814:	83 c0 01             	add    $0x1,%eax
    b817:	8b 55 08             	mov    0x8(%ebp),%edx
    b81a:	83 c2 02             	add    $0x2,%edx
    b81d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b820:	c1 e1 02             	shl    $0x2,%ecx
    b823:	89 cb                	mov    %ecx,%ebx
    b825:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b828:	01 d9                	add    %ebx,%ecx
    b82a:	0f b6 09             	movzbl (%ecx),%ecx
    b82d:	88 0a                	mov    %cl,(%edx)
    b82f:	0f b6 12             	movzbl (%edx),%edx
    b832:	88 10                	mov    %dl,(%eax)
    b834:	0f b6 10             	movzbl (%eax),%edx
    b837:	8b 45 08             	mov    0x8(%ebp),%eax
    b83a:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b83c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b840:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b843:	01 45 08             	add    %eax,0x8(%ebp)
    b846:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b849:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b84c:	75 c3                	jne    b811 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b84e:	e9 b3 00 00 00       	jmp    b906 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b853:	8b 45 14             	mov    0x14(%ebp),%eax
    b856:	8b 00                	mov    (%eax),%eax
    b858:	83 f8 06             	cmp    $0x6,%eax
    b85b:	0f 85 a5 00 00 00    	jne    b906 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b861:	8b 45 14             	mov    0x14(%ebp),%eax
    b864:	8b 40 04             	mov    0x4(%eax),%eax
    b867:	83 f8 08             	cmp    $0x8,%eax
    b86a:	75 38                	jne    b8a4 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b86c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b873:	eb 25                	jmp    b89a <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b875:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b878:	c1 e0 02             	shl    $0x2,%eax
    b87b:	89 c2                	mov    %eax,%edx
    b87d:	8b 45 10             	mov    0x10(%ebp),%eax
    b880:	01 d0                	add    %edx,%eax
    b882:	6a 03                	push   $0x3
    b884:	50                   	push   %eax
    b885:	ff 75 08             	pushl  0x8(%ebp)
    b888:	e8 a8 7d ff ff       	call   3635 <lodepng_memcpy>
    b88d:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b890:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b894:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b897:	01 45 08             	add    %eax,0x8(%ebp)
    b89a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b89d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b8a0:	75 d3                	jne    b875 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b8a2:	eb 62                	jmp    b906 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b8a4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b8ab:	eb 51                	jmp    b8fe <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b8ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8b0:	c1 e0 03             	shl    $0x3,%eax
    b8b3:	89 c2                	mov    %eax,%edx
    b8b5:	8b 45 10             	mov    0x10(%ebp),%eax
    b8b8:	01 d0                	add    %edx,%eax
    b8ba:	0f b6 10             	movzbl (%eax),%edx
    b8bd:	8b 45 08             	mov    0x8(%ebp),%eax
    b8c0:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b8c2:	8b 45 08             	mov    0x8(%ebp),%eax
    b8c5:	8d 50 01             	lea    0x1(%eax),%edx
    b8c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8cb:	c1 e0 03             	shl    $0x3,%eax
    b8ce:	8d 48 02             	lea    0x2(%eax),%ecx
    b8d1:	8b 45 10             	mov    0x10(%ebp),%eax
    b8d4:	01 c8                	add    %ecx,%eax
    b8d6:	0f b6 00             	movzbl (%eax),%eax
    b8d9:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b8db:	8b 45 08             	mov    0x8(%ebp),%eax
    b8de:	8d 50 02             	lea    0x2(%eax),%edx
    b8e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8e4:	c1 e0 03             	shl    $0x3,%eax
    b8e7:	8d 48 04             	lea    0x4(%eax),%ecx
    b8ea:	8b 45 10             	mov    0x10(%ebp),%eax
    b8ed:	01 c8                	add    %ecx,%eax
    b8ef:	0f b6 00             	movzbl (%eax),%eax
    b8f2:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b8f4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b8f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b8fb:	01 45 08             	add    %eax,0x8(%ebp)
    b8fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b901:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b904:	75 a7                	jne    b8ad <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b906:	90                   	nop
    b907:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b90a:	c9                   	leave  
    b90b:	c3                   	ret    

0000b90c <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b90c:	55                   	push   %ebp
    b90d:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b90f:	8b 45 20             	mov    0x20(%ebp),%eax
    b912:	8b 00                	mov    (%eax),%eax
    b914:	85 c0                	test   %eax,%eax
    b916:	0f 85 a4 00 00 00    	jne    b9c0 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b91c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b91f:	01 c0                	add    %eax,%eax
    b921:	89 c2                	mov    %eax,%edx
    b923:	8b 45 18             	mov    0x18(%ebp),%eax
    b926:	01 d0                	add    %edx,%eax
    b928:	0f b6 00             	movzbl (%eax),%eax
    b92b:	0f b6 c0             	movzbl %al,%eax
    b92e:	c1 e0 08             	shl    $0x8,%eax
    b931:	89 c2                	mov    %eax,%edx
    b933:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b936:	01 c0                	add    %eax,%eax
    b938:	8d 48 01             	lea    0x1(%eax),%ecx
    b93b:	8b 45 18             	mov    0x18(%ebp),%eax
    b93e:	01 c8                	add    %ecx,%eax
    b940:	0f b6 00             	movzbl (%eax),%eax
    b943:	0f b6 c0             	movzbl %al,%eax
    b946:	01 c2                	add    %eax,%edx
    b948:	8b 45 10             	mov    0x10(%ebp),%eax
    b94b:	66 89 10             	mov    %dx,(%eax)
    b94e:	8b 45 10             	mov    0x10(%ebp),%eax
    b951:	0f b7 10             	movzwl (%eax),%edx
    b954:	8b 45 0c             	mov    0xc(%ebp),%eax
    b957:	66 89 10             	mov    %dx,(%eax)
    b95a:	8b 45 0c             	mov    0xc(%ebp),%eax
    b95d:	0f b7 10             	movzwl (%eax),%edx
    b960:	8b 45 08             	mov    0x8(%ebp),%eax
    b963:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b966:	8b 45 20             	mov    0x20(%ebp),%eax
    b969:	8b 40 10             	mov    0x10(%eax),%eax
    b96c:	85 c0                	test   %eax,%eax
    b96e:	74 43                	je     b9b3 <getPixelColorRGBA16+0xa7>
    b970:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b973:	01 c0                	add    %eax,%eax
    b975:	89 c2                	mov    %eax,%edx
    b977:	8b 45 18             	mov    0x18(%ebp),%eax
    b97a:	01 d0                	add    %edx,%eax
    b97c:	0f b6 00             	movzbl (%eax),%eax
    b97f:	0f b6 c0             	movzbl %al,%eax
    b982:	c1 e0 08             	shl    $0x8,%eax
    b985:	89 c2                	mov    %eax,%edx
    b987:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b98a:	01 c0                	add    %eax,%eax
    b98c:	8d 48 01             	lea    0x1(%eax),%ecx
    b98f:	8b 45 18             	mov    0x18(%ebp),%eax
    b992:	01 c8                	add    %ecx,%eax
    b994:	0f b6 00             	movzbl (%eax),%eax
    b997:	0f b6 c0             	movzbl %al,%eax
    b99a:	01 c2                	add    %eax,%edx
    b99c:	8b 45 20             	mov    0x20(%ebp),%eax
    b99f:	8b 40 14             	mov    0x14(%eax),%eax
    b9a2:	39 c2                	cmp    %eax,%edx
    b9a4:	75 0d                	jne    b9b3 <getPixelColorRGBA16+0xa7>
    b9a6:	8b 45 14             	mov    0x14(%ebp),%eax
    b9a9:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b9ae:	e9 48 03 00 00       	jmp    bcfb <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b9b3:	8b 45 14             	mov    0x14(%ebp),%eax
    b9b6:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b9bb:	e9 3b 03 00 00       	jmp    bcfb <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b9c0:	8b 45 20             	mov    0x20(%ebp),%eax
    b9c3:	8b 00                	mov    (%eax),%eax
    b9c5:	83 f8 02             	cmp    $0x2,%eax
    b9c8:	0f 85 b6 01 00 00    	jne    bb84 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b9ce:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b9d1:	89 d0                	mov    %edx,%eax
    b9d3:	01 c0                	add    %eax,%eax
    b9d5:	01 d0                	add    %edx,%eax
    b9d7:	01 c0                	add    %eax,%eax
    b9d9:	89 c2                	mov    %eax,%edx
    b9db:	8b 45 18             	mov    0x18(%ebp),%eax
    b9de:	01 d0                	add    %edx,%eax
    b9e0:	0f b6 00             	movzbl (%eax),%eax
    b9e3:	0f b6 c0             	movzbl %al,%eax
    b9e6:	c1 e0 08             	shl    $0x8,%eax
    b9e9:	89 c1                	mov    %eax,%ecx
    b9eb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b9ee:	89 d0                	mov    %edx,%eax
    b9f0:	01 c0                	add    %eax,%eax
    b9f2:	01 d0                	add    %edx,%eax
    b9f4:	01 c0                	add    %eax,%eax
    b9f6:	8d 50 01             	lea    0x1(%eax),%edx
    b9f9:	8b 45 18             	mov    0x18(%ebp),%eax
    b9fc:	01 d0                	add    %edx,%eax
    b9fe:	0f b6 00             	movzbl (%eax),%eax
    ba01:	0f b6 c0             	movzbl %al,%eax
    ba04:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ba07:	8b 45 08             	mov    0x8(%ebp),%eax
    ba0a:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    ba0d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba10:	89 d0                	mov    %edx,%eax
    ba12:	01 c0                	add    %eax,%eax
    ba14:	01 d0                	add    %edx,%eax
    ba16:	01 c0                	add    %eax,%eax
    ba18:	8d 50 02             	lea    0x2(%eax),%edx
    ba1b:	8b 45 18             	mov    0x18(%ebp),%eax
    ba1e:	01 d0                	add    %edx,%eax
    ba20:	0f b6 00             	movzbl (%eax),%eax
    ba23:	0f b6 c0             	movzbl %al,%eax
    ba26:	c1 e0 08             	shl    $0x8,%eax
    ba29:	89 c1                	mov    %eax,%ecx
    ba2b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba2e:	89 d0                	mov    %edx,%eax
    ba30:	01 c0                	add    %eax,%eax
    ba32:	01 d0                	add    %edx,%eax
    ba34:	01 c0                	add    %eax,%eax
    ba36:	8d 50 03             	lea    0x3(%eax),%edx
    ba39:	8b 45 18             	mov    0x18(%ebp),%eax
    ba3c:	01 d0                	add    %edx,%eax
    ba3e:	0f b6 00             	movzbl (%eax),%eax
    ba41:	0f b6 c0             	movzbl %al,%eax
    ba44:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ba47:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba4a:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    ba4d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba50:	89 d0                	mov    %edx,%eax
    ba52:	01 c0                	add    %eax,%eax
    ba54:	01 d0                	add    %edx,%eax
    ba56:	01 c0                	add    %eax,%eax
    ba58:	8d 50 04             	lea    0x4(%eax),%edx
    ba5b:	8b 45 18             	mov    0x18(%ebp),%eax
    ba5e:	01 d0                	add    %edx,%eax
    ba60:	0f b6 00             	movzbl (%eax),%eax
    ba63:	0f b6 c0             	movzbl %al,%eax
    ba66:	c1 e0 08             	shl    $0x8,%eax
    ba69:	89 c1                	mov    %eax,%ecx
    ba6b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba6e:	89 d0                	mov    %edx,%eax
    ba70:	01 c0                	add    %eax,%eax
    ba72:	01 d0                	add    %edx,%eax
    ba74:	01 c0                	add    %eax,%eax
    ba76:	8d 50 05             	lea    0x5(%eax),%edx
    ba79:	8b 45 18             	mov    0x18(%ebp),%eax
    ba7c:	01 d0                	add    %edx,%eax
    ba7e:	0f b6 00             	movzbl (%eax),%eax
    ba81:	0f b6 c0             	movzbl %al,%eax
    ba84:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ba87:	8b 45 10             	mov    0x10(%ebp),%eax
    ba8a:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    ba8d:	8b 45 20             	mov    0x20(%ebp),%eax
    ba90:	8b 40 10             	mov    0x10(%eax),%eax
    ba93:	85 c0                	test   %eax,%eax
    ba95:	0f 84 dc 00 00 00    	je     bb77 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    ba9b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba9e:	89 d0                	mov    %edx,%eax
    baa0:	01 c0                	add    %eax,%eax
    baa2:	01 d0                	add    %edx,%eax
    baa4:	01 c0                	add    %eax,%eax
    baa6:	89 c2                	mov    %eax,%edx
    baa8:	8b 45 18             	mov    0x18(%ebp),%eax
    baab:	01 d0                	add    %edx,%eax
    baad:	0f b6 00             	movzbl (%eax),%eax
    bab0:	0f b6 c0             	movzbl %al,%eax
    bab3:	c1 e0 08             	shl    $0x8,%eax
    bab6:	89 c1                	mov    %eax,%ecx
    bab8:	8b 55 1c             	mov    0x1c(%ebp),%edx
    babb:	89 d0                	mov    %edx,%eax
    babd:	01 c0                	add    %eax,%eax
    babf:	01 d0                	add    %edx,%eax
    bac1:	01 c0                	add    %eax,%eax
    bac3:	8d 50 01             	lea    0x1(%eax),%edx
    bac6:	8b 45 18             	mov    0x18(%ebp),%eax
    bac9:	01 d0                	add    %edx,%eax
    bacb:	0f b6 00             	movzbl (%eax),%eax
    bace:	0f b6 c0             	movzbl %al,%eax
    bad1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bad4:	8b 45 20             	mov    0x20(%ebp),%eax
    bad7:	8b 40 14             	mov    0x14(%eax),%eax
    bada:	39 c2                	cmp    %eax,%edx
    badc:	0f 85 95 00 00 00    	jne    bb77 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    bae2:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bae5:	89 d0                	mov    %edx,%eax
    bae7:	01 c0                	add    %eax,%eax
    bae9:	01 d0                	add    %edx,%eax
    baeb:	01 c0                	add    %eax,%eax
    baed:	8d 50 02             	lea    0x2(%eax),%edx
    baf0:	8b 45 18             	mov    0x18(%ebp),%eax
    baf3:	01 d0                	add    %edx,%eax
    baf5:	0f b6 00             	movzbl (%eax),%eax
    baf8:	0f b6 c0             	movzbl %al,%eax
    bafb:	c1 e0 08             	shl    $0x8,%eax
    bafe:	89 c1                	mov    %eax,%ecx
    bb00:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb03:	89 d0                	mov    %edx,%eax
    bb05:	01 c0                	add    %eax,%eax
    bb07:	01 d0                	add    %edx,%eax
    bb09:	01 c0                	add    %eax,%eax
    bb0b:	8d 50 03             	lea    0x3(%eax),%edx
    bb0e:	8b 45 18             	mov    0x18(%ebp),%eax
    bb11:	01 d0                	add    %edx,%eax
    bb13:	0f b6 00             	movzbl (%eax),%eax
    bb16:	0f b6 c0             	movzbl %al,%eax
    bb19:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bb1c:	8b 45 20             	mov    0x20(%ebp),%eax
    bb1f:	8b 40 18             	mov    0x18(%eax),%eax
    bb22:	39 c2                	cmp    %eax,%edx
    bb24:	75 51                	jne    bb77 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    bb26:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb29:	89 d0                	mov    %edx,%eax
    bb2b:	01 c0                	add    %eax,%eax
    bb2d:	01 d0                	add    %edx,%eax
    bb2f:	01 c0                	add    %eax,%eax
    bb31:	8d 50 04             	lea    0x4(%eax),%edx
    bb34:	8b 45 18             	mov    0x18(%ebp),%eax
    bb37:	01 d0                	add    %edx,%eax
    bb39:	0f b6 00             	movzbl (%eax),%eax
    bb3c:	0f b6 c0             	movzbl %al,%eax
    bb3f:	c1 e0 08             	shl    $0x8,%eax
    bb42:	89 c1                	mov    %eax,%ecx
    bb44:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb47:	89 d0                	mov    %edx,%eax
    bb49:	01 c0                	add    %eax,%eax
    bb4b:	01 d0                	add    %edx,%eax
    bb4d:	01 c0                	add    %eax,%eax
    bb4f:	8d 50 05             	lea    0x5(%eax),%edx
    bb52:	8b 45 18             	mov    0x18(%ebp),%eax
    bb55:	01 d0                	add    %edx,%eax
    bb57:	0f b6 00             	movzbl (%eax),%eax
    bb5a:	0f b6 c0             	movzbl %al,%eax
    bb5d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bb60:	8b 45 20             	mov    0x20(%ebp),%eax
    bb63:	8b 40 1c             	mov    0x1c(%eax),%eax
    bb66:	39 c2                	cmp    %eax,%edx
    bb68:	75 0d                	jne    bb77 <getPixelColorRGBA16+0x26b>
    bb6a:	8b 45 14             	mov    0x14(%ebp),%eax
    bb6d:	66 c7 00 00 00       	movw   $0x0,(%eax)
    bb72:	e9 84 01 00 00       	jmp    bcfb <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    bb77:	8b 45 14             	mov    0x14(%ebp),%eax
    bb7a:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bb7f:	e9 77 01 00 00       	jmp    bcfb <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    bb84:	8b 45 20             	mov    0x20(%ebp),%eax
    bb87:	8b 00                	mov    (%eax),%eax
    bb89:	83 f8 04             	cmp    $0x4,%eax
    bb8c:	0f 85 86 00 00 00    	jne    bc18 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    bb92:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb95:	c1 e0 02             	shl    $0x2,%eax
    bb98:	89 c2                	mov    %eax,%edx
    bb9a:	8b 45 18             	mov    0x18(%ebp),%eax
    bb9d:	01 d0                	add    %edx,%eax
    bb9f:	0f b6 00             	movzbl (%eax),%eax
    bba2:	0f b6 c0             	movzbl %al,%eax
    bba5:	c1 e0 08             	shl    $0x8,%eax
    bba8:	89 c2                	mov    %eax,%edx
    bbaa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbad:	c1 e0 02             	shl    $0x2,%eax
    bbb0:	8d 48 01             	lea    0x1(%eax),%ecx
    bbb3:	8b 45 18             	mov    0x18(%ebp),%eax
    bbb6:	01 c8                	add    %ecx,%eax
    bbb8:	0f b6 00             	movzbl (%eax),%eax
    bbbb:	0f b6 c0             	movzbl %al,%eax
    bbbe:	01 c2                	add    %eax,%edx
    bbc0:	8b 45 10             	mov    0x10(%ebp),%eax
    bbc3:	66 89 10             	mov    %dx,(%eax)
    bbc6:	8b 45 10             	mov    0x10(%ebp),%eax
    bbc9:	0f b7 10             	movzwl (%eax),%edx
    bbcc:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbcf:	66 89 10             	mov    %dx,(%eax)
    bbd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbd5:	0f b7 10             	movzwl (%eax),%edx
    bbd8:	8b 45 08             	mov    0x8(%ebp),%eax
    bbdb:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    bbde:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbe1:	c1 e0 02             	shl    $0x2,%eax
    bbe4:	8d 50 02             	lea    0x2(%eax),%edx
    bbe7:	8b 45 18             	mov    0x18(%ebp),%eax
    bbea:	01 d0                	add    %edx,%eax
    bbec:	0f b6 00             	movzbl (%eax),%eax
    bbef:	0f b6 c0             	movzbl %al,%eax
    bbf2:	c1 e0 08             	shl    $0x8,%eax
    bbf5:	89 c2                	mov    %eax,%edx
    bbf7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbfa:	c1 e0 02             	shl    $0x2,%eax
    bbfd:	8d 48 03             	lea    0x3(%eax),%ecx
    bc00:	8b 45 18             	mov    0x18(%ebp),%eax
    bc03:	01 c8                	add    %ecx,%eax
    bc05:	0f b6 00             	movzbl (%eax),%eax
    bc08:	0f b6 c0             	movzbl %al,%eax
    bc0b:	01 c2                	add    %eax,%edx
    bc0d:	8b 45 14             	mov    0x14(%ebp),%eax
    bc10:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bc13:	e9 e3 00 00 00       	jmp    bcfb <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    bc18:	8b 45 20             	mov    0x20(%ebp),%eax
    bc1b:	8b 00                	mov    (%eax),%eax
    bc1d:	83 f8 06             	cmp    $0x6,%eax
    bc20:	0f 85 d5 00 00 00    	jne    bcfb <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    bc26:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc29:	c1 e0 03             	shl    $0x3,%eax
    bc2c:	89 c2                	mov    %eax,%edx
    bc2e:	8b 45 18             	mov    0x18(%ebp),%eax
    bc31:	01 d0                	add    %edx,%eax
    bc33:	0f b6 00             	movzbl (%eax),%eax
    bc36:	0f b6 c0             	movzbl %al,%eax
    bc39:	c1 e0 08             	shl    $0x8,%eax
    bc3c:	89 c2                	mov    %eax,%edx
    bc3e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc41:	c1 e0 03             	shl    $0x3,%eax
    bc44:	8d 48 01             	lea    0x1(%eax),%ecx
    bc47:	8b 45 18             	mov    0x18(%ebp),%eax
    bc4a:	01 c8                	add    %ecx,%eax
    bc4c:	0f b6 00             	movzbl (%eax),%eax
    bc4f:	0f b6 c0             	movzbl %al,%eax
    bc52:	01 c2                	add    %eax,%edx
    bc54:	8b 45 08             	mov    0x8(%ebp),%eax
    bc57:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    bc5a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc5d:	c1 e0 03             	shl    $0x3,%eax
    bc60:	8d 50 02             	lea    0x2(%eax),%edx
    bc63:	8b 45 18             	mov    0x18(%ebp),%eax
    bc66:	01 d0                	add    %edx,%eax
    bc68:	0f b6 00             	movzbl (%eax),%eax
    bc6b:	0f b6 c0             	movzbl %al,%eax
    bc6e:	c1 e0 08             	shl    $0x8,%eax
    bc71:	89 c2                	mov    %eax,%edx
    bc73:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc76:	c1 e0 03             	shl    $0x3,%eax
    bc79:	8d 48 03             	lea    0x3(%eax),%ecx
    bc7c:	8b 45 18             	mov    0x18(%ebp),%eax
    bc7f:	01 c8                	add    %ecx,%eax
    bc81:	0f b6 00             	movzbl (%eax),%eax
    bc84:	0f b6 c0             	movzbl %al,%eax
    bc87:	01 c2                	add    %eax,%edx
    bc89:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc8c:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    bc8f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc92:	c1 e0 03             	shl    $0x3,%eax
    bc95:	8d 50 04             	lea    0x4(%eax),%edx
    bc98:	8b 45 18             	mov    0x18(%ebp),%eax
    bc9b:	01 d0                	add    %edx,%eax
    bc9d:	0f b6 00             	movzbl (%eax),%eax
    bca0:	0f b6 c0             	movzbl %al,%eax
    bca3:	c1 e0 08             	shl    $0x8,%eax
    bca6:	89 c2                	mov    %eax,%edx
    bca8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bcab:	c1 e0 03             	shl    $0x3,%eax
    bcae:	8d 48 05             	lea    0x5(%eax),%ecx
    bcb1:	8b 45 18             	mov    0x18(%ebp),%eax
    bcb4:	01 c8                	add    %ecx,%eax
    bcb6:	0f b6 00             	movzbl (%eax),%eax
    bcb9:	0f b6 c0             	movzbl %al,%eax
    bcbc:	01 c2                	add    %eax,%edx
    bcbe:	8b 45 10             	mov    0x10(%ebp),%eax
    bcc1:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    bcc4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bcc7:	c1 e0 03             	shl    $0x3,%eax
    bcca:	8d 50 06             	lea    0x6(%eax),%edx
    bccd:	8b 45 18             	mov    0x18(%ebp),%eax
    bcd0:	01 d0                	add    %edx,%eax
    bcd2:	0f b6 00             	movzbl (%eax),%eax
    bcd5:	0f b6 c0             	movzbl %al,%eax
    bcd8:	c1 e0 08             	shl    $0x8,%eax
    bcdb:	89 c2                	mov    %eax,%edx
    bcdd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bce0:	c1 e0 03             	shl    $0x3,%eax
    bce3:	8d 48 07             	lea    0x7(%eax),%ecx
    bce6:	8b 45 18             	mov    0x18(%ebp),%eax
    bce9:	01 c8                	add    %ecx,%eax
    bceb:	0f b6 00             	movzbl (%eax),%eax
    bcee:	0f b6 c0             	movzbl %al,%eax
    bcf1:	01 c2                	add    %eax,%edx
    bcf3:	8b 45 14             	mov    0x14(%ebp),%eax
    bcf6:	66 89 10             	mov    %dx,(%eax)
  }
}
    bcf9:	eb 00                	jmp    bcfb <getPixelColorRGBA16+0x3ef>
    bcfb:	90                   	nop
    bcfc:	5d                   	pop    %ebp
    bcfd:	c3                   	ret    

0000bcfe <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    bcfe:	55                   	push   %ebp
    bcff:	89 e5                	mov    %esp,%ebp
    bd01:	56                   	push   %esi
    bd02:	53                   	push   %ebx
    bd03:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    bd06:	8b 55 18             	mov    0x18(%ebp),%edx
    bd09:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bd0c:	0f af c2             	imul   %edx,%eax
    bd0f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    bd12:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    bd19:	8b 45 14             	mov    0x14(%ebp),%eax
    bd1c:	8b 00                	mov    (%eax),%eax
    bd1e:	83 f8 03             	cmp    $0x3,%eax
    bd21:	75 14                	jne    bd37 <lodepng_convert+0x39>
    bd23:	8b 45 14             	mov    0x14(%ebp),%eax
    bd26:	8b 40 08             	mov    0x8(%eax),%eax
    bd29:	85 c0                	test   %eax,%eax
    bd2b:	75 0a                	jne    bd37 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    bd2d:	b8 6b 00 00 00       	mov    $0x6b,%eax
    bd32:	e9 19 03 00 00       	jmp    c050 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    bd37:	ff 75 14             	pushl  0x14(%ebp)
    bd3a:	ff 75 10             	pushl  0x10(%ebp)
    bd3d:	e8 b7 d1 ff ff       	call   8ef9 <lodepng_color_mode_equal>
    bd42:	83 c4 08             	add    $0x8,%esp
    bd45:	85 c0                	test   %eax,%eax
    bd47:	74 2f                	je     bd78 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bd49:	ff 75 14             	pushl  0x14(%ebp)
    bd4c:	ff 75 1c             	pushl  0x1c(%ebp)
    bd4f:	ff 75 18             	pushl  0x18(%ebp)
    bd52:	e8 fb d4 ff ff       	call   9252 <lodepng_get_raw_size>
    bd57:	83 c4 0c             	add    $0xc,%esp
    bd5a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    bd5d:	ff 75 dc             	pushl  -0x24(%ebp)
    bd60:	ff 75 0c             	pushl  0xc(%ebp)
    bd63:	ff 75 08             	pushl  0x8(%ebp)
    bd66:	e8 ca 78 ff ff       	call   3635 <lodepng_memcpy>
    bd6b:	83 c4 0c             	add    $0xc,%esp
    return 0;
    bd6e:	b8 00 00 00 00       	mov    $0x0,%eax
    bd73:	e9 d8 02 00 00       	jmp    c050 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bd78:	8b 45 10             	mov    0x10(%ebp),%eax
    bd7b:	8b 00                	mov    (%eax),%eax
    bd7d:	83 f8 03             	cmp    $0x3,%eax
    bd80:	0f 85 16 01 00 00    	jne    be9c <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bd86:	8b 45 10             	mov    0x10(%ebp),%eax
    bd89:	8b 40 0c             	mov    0xc(%eax),%eax
    bd8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    bd8f:	8b 45 10             	mov    0x10(%ebp),%eax
    bd92:	8b 40 08             	mov    0x8(%eax),%eax
    bd95:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bd98:	8b 45 10             	mov    0x10(%ebp),%eax
    bd9b:	8b 40 04             	mov    0x4(%eax),%eax
    bd9e:	ba 01 00 00 00       	mov    $0x1,%edx
    bda3:	89 c1                	mov    %eax,%ecx
    bda5:	d3 e2                	shl    %cl,%edx
    bda7:	89 d0                	mov    %edx,%eax
    bda9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bdac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bdb0:	75 5b                	jne    be0d <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bdb2:	8b 45 14             	mov    0x14(%ebp),%eax
    bdb5:	8b 40 0c             	mov    0xc(%eax),%eax
    bdb8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bdbb:	8b 45 14             	mov    0x14(%ebp),%eax
    bdbe:	8b 40 08             	mov    0x8(%eax),%eax
    bdc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bdc4:	8b 45 14             	mov    0x14(%ebp),%eax
    bdc7:	8b 00                	mov    (%eax),%eax
    bdc9:	83 f8 03             	cmp    $0x3,%eax
    bdcc:	75 3f                	jne    be0d <lodepng_convert+0x10f>
    bdce:	8b 45 14             	mov    0x14(%ebp),%eax
    bdd1:	8b 50 04             	mov    0x4(%eax),%edx
    bdd4:	8b 45 10             	mov    0x10(%ebp),%eax
    bdd7:	8b 40 04             	mov    0x4(%eax),%eax
    bdda:	39 c2                	cmp    %eax,%edx
    bddc:	75 2f                	jne    be0d <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bdde:	ff 75 14             	pushl  0x14(%ebp)
    bde1:	ff 75 1c             	pushl  0x1c(%ebp)
    bde4:	ff 75 18             	pushl  0x18(%ebp)
    bde7:	e8 66 d4 ff ff       	call   9252 <lodepng_get_raw_size>
    bdec:	83 c4 0c             	add    $0xc,%esp
    bdef:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bdf2:	ff 75 d8             	pushl  -0x28(%ebp)
    bdf5:	ff 75 0c             	pushl  0xc(%ebp)
    bdf8:	ff 75 08             	pushl  0x8(%ebp)
    bdfb:	e8 35 78 ff ff       	call   3635 <lodepng_memcpy>
    be00:	83 c4 0c             	add    $0xc,%esp
        return 0;
    be03:	b8 00 00 00 00       	mov    $0x0,%eax
    be08:	e9 43 02 00 00       	jmp    c050 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    be0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    be10:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    be13:	7d 06                	jge    be1b <lodepng_convert+0x11d>
    be15:	8b 45 ec             	mov    -0x14(%ebp),%eax
    be18:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    be1b:	8d 45 90             	lea    -0x70(%ebp),%eax
    be1e:	50                   	push   %eax
    be1f:	e8 5f e1 ff ff       	call   9f83 <color_tree_init>
    be24:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    be27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    be2e:	eb 61                	jmp    be91 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    be30:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be33:	c1 e0 02             	shl    $0x2,%eax
    be36:	89 c2                	mov    %eax,%edx
    be38:	8b 45 e8             	mov    -0x18(%ebp),%eax
    be3b:	01 d0                	add    %edx,%eax
    be3d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    be40:	8b 75 f4             	mov    -0xc(%ebp),%esi
    be43:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    be46:	83 c0 03             	add    $0x3,%eax
    be49:	0f b6 00             	movzbl (%eax),%eax
    be4c:	0f b6 d8             	movzbl %al,%ebx
    be4f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    be52:	83 c0 02             	add    $0x2,%eax
    be55:	0f b6 00             	movzbl (%eax),%eax
    be58:	0f b6 c8             	movzbl %al,%ecx
    be5b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    be5e:	83 c0 01             	add    $0x1,%eax
    be61:	0f b6 00             	movzbl (%eax),%eax
    be64:	0f b6 d0             	movzbl %al,%edx
    be67:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    be6a:	0f b6 00             	movzbl (%eax),%eax
    be6d:	0f b6 c0             	movzbl %al,%eax
    be70:	83 ec 08             	sub    $0x8,%esp
    be73:	56                   	push   %esi
    be74:	53                   	push   %ebx
    be75:	51                   	push   %ecx
    be76:	52                   	push   %edx
    be77:	50                   	push   %eax
    be78:	8d 45 90             	lea    -0x70(%ebp),%eax
    be7b:	50                   	push   %eax
    be7c:	e8 85 e2 ff ff       	call   a106 <color_tree_add>
    be81:	83 c4 20             	add    $0x20,%esp
    be84:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    be87:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    be8b:	75 0e                	jne    be9b <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    be8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    be91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be94:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    be97:	75 97                	jne    be30 <lodepng_convert+0x132>
    be99:	eb 01                	jmp    be9c <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    be9b:	90                   	nop
    }
  }

  if(!error) {
    be9c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bea0:	0f 85 8e 01 00 00    	jne    c034 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bea6:	8b 45 14             	mov    0x14(%ebp),%eax
    bea9:	8b 40 04             	mov    0x4(%eax),%eax
    beac:	83 f8 10             	cmp    $0x10,%eax
    beaf:	0f 85 99 00 00 00    	jne    bf4e <lodepng_convert+0x250>
    beb5:	8b 45 10             	mov    0x10(%ebp),%eax
    beb8:	8b 40 04             	mov    0x4(%eax),%eax
    bebb:	83 f8 10             	cmp    $0x10,%eax
    bebe:	0f 85 8a 00 00 00    	jne    bf4e <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bec4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    becb:	eb 74                	jmp    bf41 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    becd:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bed3:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bed9:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bedf:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bee5:	83 ec 04             	sub    $0x4,%esp
    bee8:	ff 75 14             	pushl  0x14(%ebp)
    beeb:	ff 75 f4             	pushl  -0xc(%ebp)
    beee:	ff 75 0c             	pushl  0xc(%ebp)
    bef1:	8d 45 88             	lea    -0x78(%ebp),%eax
    bef4:	50                   	push   %eax
    bef5:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bef8:	50                   	push   %eax
    bef9:	8d 45 8c             	lea    -0x74(%ebp),%eax
    befc:	50                   	push   %eax
    befd:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bf00:	50                   	push   %eax
    bf01:	e8 06 fa ff ff       	call   b90c <getPixelColorRGBA16>
    bf06:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bf09:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bf0d:	0f b7 d8             	movzwl %ax,%ebx
    bf10:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bf14:	0f b7 c8             	movzwl %ax,%ecx
    bf17:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bf1b:	0f b7 d0             	movzwl %ax,%edx
    bf1e:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bf22:	0f b7 c0             	movzwl %ax,%eax
    bf25:	83 ec 04             	sub    $0x4,%esp
    bf28:	53                   	push   %ebx
    bf29:	51                   	push   %ecx
    bf2a:	52                   	push   %edx
    bf2b:	50                   	push   %eax
    bf2c:	ff 75 10             	pushl  0x10(%ebp)
    bf2f:	ff 75 f4             	pushl  -0xc(%ebp)
    bf32:	ff 75 08             	pushl  0x8(%ebp)
    bf35:	e8 d3 e6 ff ff       	call   a60d <rgba16ToPixel>
    bf3a:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bf3d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bf41:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf44:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bf47:	75 84                	jne    becd <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bf49:	e9 e6 00 00 00       	jmp    c034 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bf4e:	8b 45 10             	mov    0x10(%ebp),%eax
    bf51:	8b 40 04             	mov    0x4(%eax),%eax
    bf54:	83 f8 08             	cmp    $0x8,%eax
    bf57:	75 23                	jne    bf7c <lodepng_convert+0x27e>
    bf59:	8b 45 10             	mov    0x10(%ebp),%eax
    bf5c:	8b 00                	mov    (%eax),%eax
    bf5e:	83 f8 06             	cmp    $0x6,%eax
    bf61:	75 19                	jne    bf7c <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bf63:	ff 75 14             	pushl  0x14(%ebp)
    bf66:	ff 75 0c             	pushl  0xc(%ebp)
    bf69:	ff 75 e0             	pushl  -0x20(%ebp)
    bf6c:	ff 75 08             	pushl  0x8(%ebp)
    bf6f:	e8 ae ee ff ff       	call   ae22 <getPixelColorsRGBA8>
    bf74:	83 c4 10             	add    $0x10,%esp
    bf77:	e9 b8 00 00 00       	jmp    c034 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bf7c:	8b 45 10             	mov    0x10(%ebp),%eax
    bf7f:	8b 40 04             	mov    0x4(%eax),%eax
    bf82:	83 f8 08             	cmp    $0x8,%eax
    bf85:	75 23                	jne    bfaa <lodepng_convert+0x2ac>
    bf87:	8b 45 10             	mov    0x10(%ebp),%eax
    bf8a:	8b 00                	mov    (%eax),%eax
    bf8c:	83 f8 02             	cmp    $0x2,%eax
    bf8f:	75 19                	jne    bfaa <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bf91:	ff 75 14             	pushl  0x14(%ebp)
    bf94:	ff 75 0c             	pushl  0xc(%ebp)
    bf97:	ff 75 e0             	pushl  -0x20(%ebp)
    bf9a:	ff 75 08             	pushl  0x8(%ebp)
    bf9d:	e8 50 f5 ff ff       	call   b4f2 <getPixelColorsRGB8>
    bfa2:	83 c4 10             	add    $0x10,%esp
    bfa5:	e9 8a 00 00 00       	jmp    c034 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bfaa:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bfae:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bfb2:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bfb6:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bfba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bfc1:	eb 66                	jmp    c029 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bfc3:	83 ec 04             	sub    $0x4,%esp
    bfc6:	ff 75 14             	pushl  0x14(%ebp)
    bfc9:	ff 75 f4             	pushl  -0xc(%ebp)
    bfcc:	ff 75 0c             	pushl  0xc(%ebp)
    bfcf:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bfd2:	50                   	push   %eax
    bfd3:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bfd6:	50                   	push   %eax
    bfd7:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bfda:	50                   	push   %eax
    bfdb:	8d 45 87             	lea    -0x79(%ebp),%eax
    bfde:	50                   	push   %eax
    bfdf:	e8 71 e8 ff ff       	call   a855 <getPixelColorRGBA8>
    bfe4:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bfe7:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bfeb:	0f b6 d8             	movzbl %al,%ebx
    bfee:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bff2:	0f b6 c8             	movzbl %al,%ecx
    bff5:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bff9:	0f b6 d0             	movzbl %al,%edx
    bffc:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    c000:	0f b6 c0             	movzbl %al,%eax
    c003:	53                   	push   %ebx
    c004:	51                   	push   %ecx
    c005:	52                   	push   %edx
    c006:	50                   	push   %eax
    c007:	8d 45 90             	lea    -0x70(%ebp),%eax
    c00a:	50                   	push   %eax
    c00b:	ff 75 10             	pushl  0x10(%ebp)
    c00e:	ff 75 f4             	pushl  -0xc(%ebp)
    c011:	ff 75 08             	pushl  0x8(%ebp)
    c014:	e8 e5 e1 ff ff       	call   a1fe <rgba8ToPixel>
    c019:	83 c4 20             	add    $0x20,%esp
    c01c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    c01f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c023:	75 0e                	jne    c033 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    c025:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c029:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c02c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c02f:	75 92                	jne    bfc3 <lodepng_convert+0x2c5>
    c031:	eb 01                	jmp    c034 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    c033:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c034:	8b 45 10             	mov    0x10(%ebp),%eax
    c037:	8b 00                	mov    (%eax),%eax
    c039:	83 f8 03             	cmp    $0x3,%eax
    c03c:	75 0f                	jne    c04d <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    c03e:	83 ec 0c             	sub    $0xc,%esp
    c041:	8d 45 90             	lea    -0x70(%ebp),%eax
    c044:	50                   	push   %eax
    c045:	e8 59 df ff ff       	call   9fa3 <color_tree_cleanup>
    c04a:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    c04d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    c050:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c053:	5b                   	pop    %ebx
    c054:	5e                   	pop    %esi
    c055:	5d                   	pop    %ebp
    c056:	c3                   	ret    

0000c057 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    c057:	55                   	push   %ebp
    c058:	89 e5                	mov    %esp,%ebp
    c05a:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    c05d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    c064:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c06b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    c072:	8b 45 24             	mov    0x24(%ebp),%eax
    c075:	8b 40 04             	mov    0x4(%eax),%eax
    c078:	ba 01 00 00 00       	mov    $0x1,%edx
    c07d:	89 c1                	mov    %eax,%ecx
    c07f:	d3 e2                	shl    %cl,%edx
    c081:	89 d0                	mov    %edx,%eax
    c083:	8d 48 ff             	lea    -0x1(%eax),%ecx
    c086:	b8 ff ff 00 00       	mov    $0xffff,%eax
    c08b:	ba 00 00 00 00       	mov    $0x0,%edx
    c090:	f7 f1                	div    %ecx
    c092:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    c095:	8b 45 20             	mov    0x20(%ebp),%eax
    c098:	8b 40 04             	mov    0x4(%eax),%eax
    c09b:	ba 10 00 00 00       	mov    $0x10,%edx
    c0a0:	29 c2                	sub    %eax,%edx
    c0a2:	89 d0                	mov    %edx,%eax
    c0a4:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    c0a7:	8b 45 24             	mov    0x24(%ebp),%eax
    c0aa:	8b 00                	mov    (%eax),%eax
    c0ac:	85 c0                	test   %eax,%eax
    c0ae:	74 0a                	je     c0ba <lodepng_convert_rgb+0x63>
    c0b0:	8b 45 24             	mov    0x24(%ebp),%eax
    c0b3:	8b 00                	mov    (%eax),%eax
    c0b5:	83 f8 04             	cmp    $0x4,%eax
    c0b8:	75 1b                	jne    c0d5 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    c0ba:	8b 45 14             	mov    0x14(%ebp),%eax
    c0bd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c0c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c0c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0c7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    c0ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c0cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    c0d0:	e9 c2 00 00 00       	jmp    c197 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    c0d5:	8b 45 24             	mov    0x24(%ebp),%eax
    c0d8:	8b 00                	mov    (%eax),%eax
    c0da:	83 f8 02             	cmp    $0x2,%eax
    c0dd:	74 0a                	je     c0e9 <lodepng_convert_rgb+0x92>
    c0df:	8b 45 24             	mov    0x24(%ebp),%eax
    c0e2:	8b 00                	mov    (%eax),%eax
    c0e4:	83 f8 06             	cmp    $0x6,%eax
    c0e7:	75 23                	jne    c10c <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    c0e9:	8b 45 14             	mov    0x14(%ebp),%eax
    c0ec:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c0f0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    c0f3:	8b 45 18             	mov    0x18(%ebp),%eax
    c0f6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c0fa:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    c0fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c100:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c104:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c107:	e9 8b 00 00 00       	jmp    c197 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    c10c:	8b 45 24             	mov    0x24(%ebp),%eax
    c10f:	8b 00                	mov    (%eax),%eax
    c111:	83 f8 03             	cmp    $0x3,%eax
    c114:	75 77                	jne    c18d <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    c116:	8b 45 24             	mov    0x24(%ebp),%eax
    c119:	8b 40 0c             	mov    0xc(%eax),%eax
    c11c:	3b 45 14             	cmp    0x14(%ebp),%eax
    c11f:	77 0a                	ja     c12b <lodepng_convert_rgb+0xd4>
    c121:	b8 52 00 00 00       	mov    $0x52,%eax
    c126:	e9 cb 01 00 00       	jmp    c2f6 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    c12b:	8b 45 24             	mov    0x24(%ebp),%eax
    c12e:	8b 40 08             	mov    0x8(%eax),%eax
    c131:	8b 55 14             	mov    0x14(%ebp),%edx
    c134:	c1 e2 02             	shl    $0x2,%edx
    c137:	01 d0                	add    %edx,%eax
    c139:	0f b6 00             	movzbl (%eax),%eax
    c13c:	0f b6 d0             	movzbl %al,%edx
    c13f:	89 d0                	mov    %edx,%eax
    c141:	c1 e0 08             	shl    $0x8,%eax
    c144:	01 d0                	add    %edx,%eax
    c146:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    c149:	8b 45 24             	mov    0x24(%ebp),%eax
    c14c:	8b 40 08             	mov    0x8(%eax),%eax
    c14f:	8b 55 14             	mov    0x14(%ebp),%edx
    c152:	c1 e2 02             	shl    $0x2,%edx
    c155:	83 c2 01             	add    $0x1,%edx
    c158:	01 d0                	add    %edx,%eax
    c15a:	0f b6 00             	movzbl (%eax),%eax
    c15d:	0f b6 d0             	movzbl %al,%edx
    c160:	89 d0                	mov    %edx,%eax
    c162:	c1 e0 08             	shl    $0x8,%eax
    c165:	01 d0                	add    %edx,%eax
    c167:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    c16a:	8b 45 24             	mov    0x24(%ebp),%eax
    c16d:	8b 40 08             	mov    0x8(%eax),%eax
    c170:	8b 55 14             	mov    0x14(%ebp),%edx
    c173:	c1 e2 02             	shl    $0x2,%edx
    c176:	83 c2 02             	add    $0x2,%edx
    c179:	01 d0                	add    %edx,%eax
    c17b:	0f b6 00             	movzbl (%eax),%eax
    c17e:	0f b6 d0             	movzbl %al,%edx
    c181:	89 d0                	mov    %edx,%eax
    c183:	c1 e0 08             	shl    $0x8,%eax
    c186:	01 d0                	add    %edx,%eax
    c188:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c18b:	eb 0a                	jmp    c197 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    c18d:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c192:	e9 5f 01 00 00       	jmp    c2f6 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    c197:	8b 45 20             	mov    0x20(%ebp),%eax
    c19a:	8b 00                	mov    (%eax),%eax
    c19c:	85 c0                	test   %eax,%eax
    c19e:	74 0a                	je     c1aa <lodepng_convert_rgb+0x153>
    c1a0:	8b 45 20             	mov    0x20(%ebp),%eax
    c1a3:	8b 00                	mov    (%eax),%eax
    c1a5:	83 f8 04             	cmp    $0x4,%eax
    c1a8:	75 14                	jne    c1be <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    c1aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1ad:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c1b0:	89 c1                	mov    %eax,%ecx
    c1b2:	d3 ea                	shr    %cl,%edx
    c1b4:	8b 45 08             	mov    0x8(%ebp),%eax
    c1b7:	89 10                	mov    %edx,(%eax)
    c1b9:	e9 33 01 00 00       	jmp    c2f1 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    c1be:	8b 45 20             	mov    0x20(%ebp),%eax
    c1c1:	8b 00                	mov    (%eax),%eax
    c1c3:	83 f8 02             	cmp    $0x2,%eax
    c1c6:	74 0a                	je     c1d2 <lodepng_convert_rgb+0x17b>
    c1c8:	8b 45 20             	mov    0x20(%ebp),%eax
    c1cb:	8b 00                	mov    (%eax),%eax
    c1cd:	83 f8 06             	cmp    $0x6,%eax
    c1d0:	75 32                	jne    c204 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    c1d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1d5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c1d8:	89 c1                	mov    %eax,%ecx
    c1da:	d3 ea                	shr    %cl,%edx
    c1dc:	8b 45 08             	mov    0x8(%ebp),%eax
    c1df:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    c1e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c1e7:	89 c1                	mov    %eax,%ecx
    c1e9:	d3 ea                	shr    %cl,%edx
    c1eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    c1ee:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    c1f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c1f6:	89 c1                	mov    %eax,%ecx
    c1f8:	d3 ea                	shr    %cl,%edx
    c1fa:	8b 45 10             	mov    0x10(%ebp),%eax
    c1fd:	89 10                	mov    %edx,(%eax)
    c1ff:	e9 ed 00 00 00       	jmp    c2f1 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    c204:	8b 45 20             	mov    0x20(%ebp),%eax
    c207:	8b 00                	mov    (%eax),%eax
    c209:	83 f8 03             	cmp    $0x3,%eax
    c20c:	0f 85 d8 00 00 00    	jne    c2ea <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    c212:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c215:	c1 e8 08             	shr    $0x8,%eax
    c218:	89 c2                	mov    %eax,%edx
    c21a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c21d:	0f b6 c0             	movzbl %al,%eax
    c220:	39 c2                	cmp    %eax,%edx
    c222:	75 24                	jne    c248 <lodepng_convert_rgb+0x1f1>
    c224:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c227:	c1 e8 08             	shr    $0x8,%eax
    c22a:	89 c2                	mov    %eax,%edx
    c22c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c22f:	0f b6 c0             	movzbl %al,%eax
    c232:	39 c2                	cmp    %eax,%edx
    c234:	75 12                	jne    c248 <lodepng_convert_rgb+0x1f1>
    c236:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c239:	c1 e8 08             	shr    $0x8,%eax
    c23c:	89 c2                	mov    %eax,%edx
    c23e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c241:	0f b6 c0             	movzbl %al,%eax
    c244:	39 c2                	cmp    %eax,%edx
    c246:	74 0a                	je     c252 <lodepng_convert_rgb+0x1fb>
    c248:	b8 52 00 00 00       	mov    $0x52,%eax
    c24d:	e9 a4 00 00 00       	jmp    c2f6 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c252:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c259:	eb 79                	jmp    c2d4 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c25b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c25e:	c1 e0 02             	shl    $0x2,%eax
    c261:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c264:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c267:	c1 e8 08             	shr    $0x8,%eax
    c26a:	89 c1                	mov    %eax,%ecx
    c26c:	8b 45 20             	mov    0x20(%ebp),%eax
    c26f:	8b 50 08             	mov    0x8(%eax),%edx
    c272:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c275:	01 d0                	add    %edx,%eax
    c277:	0f b6 00             	movzbl (%eax),%eax
    c27a:	0f b6 c0             	movzbl %al,%eax
    c27d:	39 c1                	cmp    %eax,%ecx
    c27f:	75 4f                	jne    c2d0 <lodepng_convert_rgb+0x279>
    c281:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c284:	c1 e8 08             	shr    $0x8,%eax
    c287:	89 c1                	mov    %eax,%ecx
    c289:	8b 45 20             	mov    0x20(%ebp),%eax
    c28c:	8b 40 08             	mov    0x8(%eax),%eax
    c28f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c292:	83 c2 01             	add    $0x1,%edx
    c295:	01 d0                	add    %edx,%eax
    c297:	0f b6 00             	movzbl (%eax),%eax
    c29a:	0f b6 c0             	movzbl %al,%eax
    c29d:	39 c1                	cmp    %eax,%ecx
    c29f:	75 2f                	jne    c2d0 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c2a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2a4:	c1 e8 08             	shr    $0x8,%eax
    c2a7:	89 c1                	mov    %eax,%ecx
    c2a9:	8b 45 20             	mov    0x20(%ebp),%eax
    c2ac:	8b 40 08             	mov    0x8(%eax),%eax
    c2af:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c2b2:	83 c2 02             	add    $0x2,%edx
    c2b5:	01 d0                	add    %edx,%eax
    c2b7:	0f b6 00             	movzbl (%eax),%eax
    c2ba:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c2bd:	39 c1                	cmp    %eax,%ecx
    c2bf:	75 0f                	jne    c2d0 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c2c1:	8b 45 08             	mov    0x8(%ebp),%eax
    c2c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c2c7:	89 10                	mov    %edx,(%eax)
        return 0;
    c2c9:	b8 00 00 00 00       	mov    $0x0,%eax
    c2ce:	eb 26                	jmp    c2f6 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c2d0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c2d4:	8b 45 20             	mov    0x20(%ebp),%eax
    c2d7:	8b 40 0c             	mov    0xc(%eax),%eax
    c2da:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c2dd:	0f 87 78 ff ff ff    	ja     c25b <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c2e3:	b8 52 00 00 00       	mov    $0x52,%eax
    c2e8:	eb 0c                	jmp    c2f6 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c2ea:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c2ef:	eb 05                	jmp    c2f6 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c2f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c2f6:	c9                   	leave  
    c2f7:	c3                   	ret    

0000c2f8 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c2f8:	55                   	push   %ebp
    c2f9:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c2fb:	8b 45 08             	mov    0x8(%ebp),%eax
    c2fe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c304:	8b 45 08             	mov    0x8(%ebp),%eax
    c307:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c30e:	8b 45 08             	mov    0x8(%ebp),%eax
    c311:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c317:	8b 45 08             	mov    0x8(%ebp),%eax
    c31a:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c31e:	8b 45 08             	mov    0x8(%ebp),%eax
    c321:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c325:	8b 45 08             	mov    0x8(%ebp),%eax
    c328:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c32c:	8b 45 08             	mov    0x8(%ebp),%eax
    c32f:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c333:	8b 45 08             	mov    0x8(%ebp),%eax
    c336:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c33d:	8b 45 08             	mov    0x8(%ebp),%eax
    c340:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c347:	8b 45 08             	mov    0x8(%ebp),%eax
    c34a:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c351:	00 00 00 
  stats->numpixels = 0;
    c354:	8b 45 08             	mov    0x8(%ebp),%eax
    c357:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c35e:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c361:	8b 45 08             	mov    0x8(%ebp),%eax
    c364:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c36b:	00 00 00 
  stats->allow_greyscale = 1;
    c36e:	8b 45 08             	mov    0x8(%ebp),%eax
    c371:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c378:	00 00 00 
}
    c37b:	90                   	nop
    c37c:	5d                   	pop    %ebp
    c37d:	c3                   	ret    

0000c37e <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c37e:	55                   	push   %ebp
    c37f:	89 e5                	mov    %esp,%ebp
    c381:	53                   	push   %ebx
    c382:	83 ec 04             	sub    $0x4,%esp
    c385:	8b 45 08             	mov    0x8(%ebp),%eax
    c388:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c38b:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c38f:	74 06                	je     c397 <getValueRequiredBits+0x19>
    c391:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c395:	75 07                	jne    c39e <getValueRequiredBits+0x20>
    c397:	b8 01 00 00 00       	mov    $0x1,%eax
    c39c:	eb 6b                	jmp    c409 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c39e:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c3a2:	0f b6 d9             	movzbl %cl,%ebx
    c3a5:	89 da                	mov    %ebx,%edx
    c3a7:	89 d0                	mov    %edx,%eax
    c3a9:	c1 e0 04             	shl    $0x4,%eax
    c3ac:	89 c2                	mov    %eax,%edx
    c3ae:	89 d0                	mov    %edx,%eax
    c3b0:	c1 e0 04             	shl    $0x4,%eax
    c3b3:	29 d0                	sub    %edx,%eax
    c3b5:	01 d8                	add    %ebx,%eax
    c3b7:	66 c1 e8 08          	shr    $0x8,%ax
    c3bb:	c0 e8 04             	shr    $0x4,%al
    c3be:	89 c2                	mov    %eax,%edx
    c3c0:	c1 e2 04             	shl    $0x4,%edx
    c3c3:	01 c2                	add    %eax,%edx
    c3c5:	89 c8                	mov    %ecx,%eax
    c3c7:	29 d0                	sub    %edx,%eax
    c3c9:	84 c0                	test   %al,%al
    c3cb:	75 37                	jne    c404 <getValueRequiredBits+0x86>
    c3cd:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c3d1:	0f b6 d1             	movzbl %cl,%edx
    c3d4:	89 d0                	mov    %edx,%eax
    c3d6:	01 c0                	add    %eax,%eax
    c3d8:	01 d0                	add    %edx,%eax
    c3da:	c1 e0 06             	shl    $0x6,%eax
    c3dd:	01 d0                	add    %edx,%eax
    c3df:	66 c1 e8 08          	shr    $0x8,%ax
    c3e3:	c0 e8 06             	shr    $0x6,%al
    c3e6:	ba 55 00 00 00       	mov    $0x55,%edx
    c3eb:	0f af c2             	imul   %edx,%eax
    c3ee:	29 c1                	sub    %eax,%ecx
    c3f0:	89 c8                	mov    %ecx,%eax
    c3f2:	84 c0                	test   %al,%al
    c3f4:	75 07                	jne    c3fd <getValueRequiredBits+0x7f>
    c3f6:	b8 02 00 00 00       	mov    $0x2,%eax
    c3fb:	eb 0c                	jmp    c409 <getValueRequiredBits+0x8b>
    c3fd:	b8 04 00 00 00       	mov    $0x4,%eax
    c402:	eb 05                	jmp    c409 <getValueRequiredBits+0x8b>
  return 8;
    c404:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c409:	83 c4 04             	add    $0x4,%esp
    c40c:	5b                   	pop    %ebx
    c40d:	5d                   	pop    %ebp
    c40e:	c3                   	ret    

0000c40f <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c40f:	55                   	push   %ebp
    c410:	89 e5                	mov    %esp,%ebp
    c412:	56                   	push   %esi
    c413:	53                   	push   %ebx
    c414:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c41a:	8b 55 10             	mov    0x10(%ebp),%edx
    c41d:	8b 45 14             	mov    0x14(%ebp),%eax
    c420:	0f af c2             	imul   %edx,%eax
    c423:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c426:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c42d:	ff 75 18             	pushl  0x18(%ebp)
    c430:	e8 0b cd ff ff       	call   9140 <lodepng_is_greyscale_type>
    c435:	83 c4 04             	add    $0x4,%esp
    c438:	85 c0                	test   %eax,%eax
    c43a:	0f 95 c0             	setne  %al
    c43d:	0f b6 c0             	movzbl %al,%eax
    c440:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c443:	ff 75 18             	pushl  0x18(%ebp)
    c446:	e8 85 cd ff ff       	call   91d0 <lodepng_can_have_alpha>
    c44b:	83 c4 04             	add    $0x4,%esp
    c44e:	85 c0                	test   %eax,%eax
    c450:	0f 94 c0             	sete   %al
    c453:	0f b6 c0             	movzbl %al,%eax
    c456:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c459:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c460:	ff 75 18             	pushl  0x18(%ebp)
    c463:	e8 ab cc ff ff       	call   9113 <lodepng_get_bpp>
    c468:	83 c4 04             	add    $0x4,%esp
    c46b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c46e:	8b 45 08             	mov    0x8(%ebp),%eax
    c471:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c477:	83 f8 01             	cmp    $0x1,%eax
    c47a:	75 0d                	jne    c489 <lodepng_compute_color_stats+0x7a>
    c47c:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c480:	75 07                	jne    c489 <lodepng_compute_color_stats+0x7a>
    c482:	b8 01 00 00 00       	mov    $0x1,%eax
    c487:	eb 05                	jmp    c48e <lodepng_compute_color_stats+0x7f>
    c489:	b8 00 00 00 00       	mov    $0x0,%eax
    c48e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c491:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c498:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c49f:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c4a3:	77 26                	ja     c4cb <lodepng_compute_color_stats+0xbc>
    c4a5:	8b 45 08             	mov    0x8(%ebp),%eax
    c4a8:	8b 50 14             	mov    0x14(%eax),%edx
    c4ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c4ae:	bb 01 00 00 00       	mov    $0x1,%ebx
    c4b3:	89 c1                	mov    %eax,%ecx
    c4b5:	d3 e3                	shl    %cl,%ebx
    c4b7:	89 d8                	mov    %ebx,%eax
    c4b9:	01 d0                	add    %edx,%eax
    c4bb:	ba 01 01 00 00       	mov    $0x101,%edx
    c4c0:	3d 01 01 00 00       	cmp    $0x101,%eax
    c4c5:	0f 47 c2             	cmova  %edx,%eax
    c4c8:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c4cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c4ce:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c4d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c4d7:	01 c2                	add    %eax,%edx
    c4d9:	8b 45 08             	mov    0x8(%ebp),%eax
    c4dc:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c4e2:	8b 45 08             	mov    0x8(%ebp),%eax
    c4e5:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c4eb:	85 c0                	test   %eax,%eax
    c4ed:	75 07                	jne    c4f6 <lodepng_compute_color_stats+0xe7>
    c4ef:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c4f6:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c4fc:	50                   	push   %eax
    c4fd:	e8 81 da ff ff       	call   9f83 <color_tree_init>
    c502:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c505:	8b 45 08             	mov    0x8(%ebp),%eax
    c508:	8b 40 10             	mov    0x10(%eax),%eax
    c50b:	85 c0                	test   %eax,%eax
    c50d:	74 07                	je     c516 <lodepng_compute_color_stats+0x107>
    c50f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c516:	8b 45 08             	mov    0x8(%ebp),%eax
    c519:	8b 00                	mov    (%eax),%eax
    c51b:	85 c0                	test   %eax,%eax
    c51d:	74 07                	je     c526 <lodepng_compute_color_stats+0x117>
    c51f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c526:	8b 45 08             	mov    0x8(%ebp),%eax
    c529:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c52f:	83 f8 10             	cmp    $0x10,%eax
    c532:	75 07                	jne    c53b <lodepng_compute_color_stats+0x12c>
    c534:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c53b:	8b 45 08             	mov    0x8(%ebp),%eax
    c53e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c544:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c547:	72 07                	jb     c550 <lodepng_compute_color_stats+0x141>
    c549:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c550:	8b 45 08             	mov    0x8(%ebp),%eax
    c553:	8b 40 14             	mov    0x14(%eax),%eax
    c556:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c559:	72 07                	jb     c562 <lodepng_compute_color_stats+0x153>
    c55b:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c562:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c566:	0f 85 82 00 00 00    	jne    c5ee <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c56c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c573:	eb 6c                	jmp    c5e1 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c575:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c578:	c1 e0 02             	shl    $0x2,%eax
    c57b:	8d 50 10             	lea    0x10(%eax),%edx
    c57e:	8b 45 08             	mov    0x8(%ebp),%eax
    c581:	01 d0                	add    %edx,%eax
    c583:	83 c0 08             	add    $0x8,%eax
    c586:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c589:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c58c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c58f:	83 c0 03             	add    $0x3,%eax
    c592:	0f b6 00             	movzbl (%eax),%eax
    c595:	0f b6 d8             	movzbl %al,%ebx
    c598:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c59b:	83 c0 02             	add    $0x2,%eax
    c59e:	0f b6 00             	movzbl (%eax),%eax
    c5a1:	0f b6 c8             	movzbl %al,%ecx
    c5a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c5a7:	83 c0 01             	add    $0x1,%eax
    c5aa:	0f b6 00             	movzbl (%eax),%eax
    c5ad:	0f b6 d0             	movzbl %al,%edx
    c5b0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c5b3:	0f b6 00             	movzbl (%eax),%eax
    c5b6:	0f b6 c0             	movzbl %al,%eax
    c5b9:	83 ec 08             	sub    $0x8,%esp
    c5bc:	56                   	push   %esi
    c5bd:	53                   	push   %ebx
    c5be:	51                   	push   %ecx
    c5bf:	52                   	push   %edx
    c5c0:	50                   	push   %eax
    c5c1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c5c7:	50                   	push   %eax
    c5c8:	e8 39 db ff ff       	call   a106 <color_tree_add>
    c5cd:	83 c4 20             	add    $0x20,%esp
    c5d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c5d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c5d7:	0f 85 22 09 00 00    	jne    ceff <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c5dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c5e1:	8b 45 08             	mov    0x8(%ebp),%eax
    c5e4:	8b 50 14             	mov    0x14(%eax),%edx
    c5e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c5ea:	39 c2                	cmp    %eax,%edx
    c5ec:	77 87                	ja     c575 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c5ee:	8b 45 18             	mov    0x18(%ebp),%eax
    c5f1:	8b 40 04             	mov    0x4(%eax),%eax
    c5f4:	83 f8 10             	cmp    $0x10,%eax
    c5f7:	0f 85 1e 01 00 00    	jne    c71b <lodepng_compute_color_stats+0x30c>
    c5fd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c601:	0f 85 14 01 00 00    	jne    c71b <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c607:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c60e:	00 00 
    c610:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c617:	00 00 
    c619:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c620:	00 00 
    c622:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c629:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c62b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c632:	e9 d8 00 00 00       	jmp    c70f <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c637:	83 ec 04             	sub    $0x4,%esp
    c63a:	ff 75 18             	pushl  0x18(%ebp)
    c63d:	ff 75 f4             	pushl  -0xc(%ebp)
    c640:	ff 75 0c             	pushl  0xc(%ebp)
    c643:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c649:	50                   	push   %eax
    c64a:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c650:	50                   	push   %eax
    c651:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c657:	50                   	push   %eax
    c658:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c65e:	50                   	push   %eax
    c65f:	e8 a8 f2 ff ff       	call   b90c <getPixelColorRGBA16>
    c664:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c667:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c66e:	66 c1 e8 08          	shr    $0x8,%ax
    c672:	89 c2                	mov    %eax,%edx
    c674:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c67b:	31 d0                	xor    %edx,%eax
    c67d:	0f b7 c0             	movzwl %ax,%eax
    c680:	0f b6 c0             	movzbl %al,%eax
    c683:	85 c0                	test   %eax,%eax
    c685:	75 60                	jne    c6e7 <lodepng_compute_color_stats+0x2d8>
    c687:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c68e:	66 c1 e8 08          	shr    $0x8,%ax
    c692:	89 c2                	mov    %eax,%edx
    c694:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c69b:	31 d0                	xor    %edx,%eax
    c69d:	0f b7 c0             	movzwl %ax,%eax
    c6a0:	0f b6 c0             	movzbl %al,%eax
    c6a3:	85 c0                	test   %eax,%eax
    c6a5:	75 40                	jne    c6e7 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c6a7:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c6ae:	66 c1 e8 08          	shr    $0x8,%ax
    c6b2:	89 c2                	mov    %eax,%edx
    c6b4:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c6bb:	31 d0                	xor    %edx,%eax
    c6bd:	0f b7 c0             	movzwl %ax,%eax
    c6c0:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c6c3:	85 c0                	test   %eax,%eax
    c6c5:	75 20                	jne    c6e7 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c6c7:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c6ce:	66 c1 e8 08          	shr    $0x8,%ax
    c6d2:	89 c2                	mov    %eax,%edx
    c6d4:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c6db:	31 d0                	xor    %edx,%eax
    c6dd:	0f b7 c0             	movzwl %ax,%eax
    c6e0:	0f b6 c0             	movzbl %al,%eax
    c6e3:	85 c0                	test   %eax,%eax
    c6e5:	74 24                	je     c70b <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c6e7:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ea:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c6f1:	00 00 00 
        sixteen = 1;
    c6f4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c6fb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c702:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c709:	eb 10                	jmp    c71b <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c70b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c70f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c712:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c715:	0f 85 1c ff ff ff    	jne    c637 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c71b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c71f:	0f 84 bd 02 00 00    	je     c9e2 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c725:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c72c:	00 00 
    c72e:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c735:	00 00 
    c737:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c73e:	00 00 
    c740:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c747:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c749:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c750:	e9 b1 01 00 00       	jmp    c906 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c755:	83 ec 04             	sub    $0x4,%esp
    c758:	ff 75 18             	pushl  0x18(%ebp)
    c75b:	ff 75 f4             	pushl  -0xc(%ebp)
    c75e:	ff 75 0c             	pushl  0xc(%ebp)
    c761:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c767:	50                   	push   %eax
    c768:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c76e:	50                   	push   %eax
    c76f:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c775:	50                   	push   %eax
    c776:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c77c:	50                   	push   %eax
    c77d:	e8 8a f1 ff ff       	call   b90c <getPixelColorRGBA16>
    c782:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c785:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c789:	75 36                	jne    c7c1 <lodepng_compute_color_stats+0x3b2>
    c78b:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c792:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c799:	66 39 c2             	cmp    %ax,%dx
    c79c:	75 13                	jne    c7b1 <lodepng_compute_color_stats+0x3a2>
    c79e:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c7a5:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c7ac:	66 39 c2             	cmp    %ax,%dx
    c7af:	74 10                	je     c7c1 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c7b1:	8b 45 08             	mov    0x8(%ebp),%eax
    c7b4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c7ba:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c7c1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c7c5:	0f 85 1f 01 00 00    	jne    c8ea <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c7cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c7ce:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c7d2:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c7d9:	66 39 c2             	cmp    %ax,%dx
    c7dc:	75 2d                	jne    c80b <lodepng_compute_color_stats+0x3fc>
    c7de:	8b 45 08             	mov    0x8(%ebp),%eax
    c7e1:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c7e5:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c7ec:	66 39 c2             	cmp    %ax,%dx
    c7ef:	75 1a                	jne    c80b <lodepng_compute_color_stats+0x3fc>
    c7f1:	8b 45 08             	mov    0x8(%ebp),%eax
    c7f4:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c7f8:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c7ff:	66 39 c2             	cmp    %ax,%dx
    c802:	75 07                	jne    c80b <lodepng_compute_color_stats+0x3fc>
    c804:	b8 01 00 00 00       	mov    $0x1,%eax
    c809:	eb 05                	jmp    c810 <lodepng_compute_color_stats+0x401>
    c80b:	b8 00 00 00 00       	mov    $0x0,%eax
    c810:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c813:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c81a:	66 83 f8 ff          	cmp    $0xffff,%ax
    c81e:	74 3c                	je     c85c <lodepng_compute_color_stats+0x44d>
    c820:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c827:	66 85 c0             	test   %ax,%ax
    c82a:	75 10                	jne    c83c <lodepng_compute_color_stats+0x42d>
    c82c:	8b 45 08             	mov    0x8(%ebp),%eax
    c82f:	8b 40 04             	mov    0x4(%eax),%eax
    c832:	85 c0                	test   %eax,%eax
    c834:	74 26                	je     c85c <lodepng_compute_color_stats+0x44d>
    c836:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c83a:	75 20                	jne    c85c <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c83c:	8b 45 08             	mov    0x8(%ebp),%eax
    c83f:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c846:	8b 45 08             	mov    0x8(%ebp),%eax
    c849:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c850:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c857:	e9 8e 00 00 00       	jmp    c8ea <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c85c:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c863:	66 85 c0             	test   %ax,%ax
    c866:	75 4a                	jne    c8b2 <lodepng_compute_color_stats+0x4a3>
    c868:	8b 45 08             	mov    0x8(%ebp),%eax
    c86b:	8b 40 10             	mov    0x10(%eax),%eax
    c86e:	85 c0                	test   %eax,%eax
    c870:	75 40                	jne    c8b2 <lodepng_compute_color_stats+0x4a3>
    c872:	8b 45 08             	mov    0x8(%ebp),%eax
    c875:	8b 40 04             	mov    0x4(%eax),%eax
    c878:	85 c0                	test   %eax,%eax
    c87a:	75 36                	jne    c8b2 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c87c:	8b 45 08             	mov    0x8(%ebp),%eax
    c87f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c886:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c88d:	8b 45 08             	mov    0x8(%ebp),%eax
    c890:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c894:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c89b:	8b 45 08             	mov    0x8(%ebp),%eax
    c89e:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c8a2:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c8a9:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ac:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c8b0:	eb 38                	jmp    c8ea <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c8b2:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c8b9:	66 83 f8 ff          	cmp    $0xffff,%ax
    c8bd:	75 2b                	jne    c8ea <lodepng_compute_color_stats+0x4db>
    c8bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c8c2:	8b 40 04             	mov    0x4(%eax),%eax
    c8c5:	85 c0                	test   %eax,%eax
    c8c7:	74 21                	je     c8ea <lodepng_compute_color_stats+0x4db>
    c8c9:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c8cd:	74 1b                	je     c8ea <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c8cf:	8b 45 08             	mov    0x8(%ebp),%eax
    c8d2:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c8d9:	8b 45 08             	mov    0x8(%ebp),%eax
    c8dc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c8e3:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c8ea:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c8ee:	74 12                	je     c902 <lodepng_compute_color_stats+0x4f3>
    c8f0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c8f4:	74 0c                	je     c902 <lodepng_compute_color_stats+0x4f3>
    c8f6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c8fa:	74 06                	je     c902 <lodepng_compute_color_stats+0x4f3>
    c8fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c900:	75 12                	jne    c914 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c902:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c906:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c909:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c90c:	0f 85 43 fe ff ff    	jne    c755 <lodepng_compute_color_stats+0x346>
    c912:	eb 01                	jmp    c915 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c914:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c915:	8b 45 08             	mov    0x8(%ebp),%eax
    c918:	8b 40 04             	mov    0x4(%eax),%eax
    c91b:	85 c0                	test   %eax,%eax
    c91d:	0f 84 e0 05 00 00    	je     cf03 <lodepng_compute_color_stats+0xaf4>
    c923:	8b 45 08             	mov    0x8(%ebp),%eax
    c926:	8b 40 10             	mov    0x10(%eax),%eax
    c929:	85 c0                	test   %eax,%eax
    c92b:	0f 85 d2 05 00 00    	jne    cf03 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c931:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c938:	e9 94 00 00 00       	jmp    c9d1 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c93d:	83 ec 04             	sub    $0x4,%esp
    c940:	ff 75 18             	pushl  0x18(%ebp)
    c943:	ff 75 f4             	pushl  -0xc(%ebp)
    c946:	ff 75 0c             	pushl  0xc(%ebp)
    c949:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c94f:	50                   	push   %eax
    c950:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c956:	50                   	push   %eax
    c957:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c95d:	50                   	push   %eax
    c95e:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c964:	50                   	push   %eax
    c965:	e8 a2 ef ff ff       	call   b90c <getPixelColorRGBA16>
    c96a:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c96d:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c974:	66 85 c0             	test   %ax,%ax
    c977:	74 54                	je     c9cd <lodepng_compute_color_stats+0x5be>
    c979:	8b 45 08             	mov    0x8(%ebp),%eax
    c97c:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c980:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c987:	66 39 c2             	cmp    %ax,%dx
    c98a:	75 41                	jne    c9cd <lodepng_compute_color_stats+0x5be>
    c98c:	8b 45 08             	mov    0x8(%ebp),%eax
    c98f:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c993:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c99a:	66 39 c2             	cmp    %ax,%dx
    c99d:	75 2e                	jne    c9cd <lodepng_compute_color_stats+0x5be>
    c99f:	8b 45 08             	mov    0x8(%ebp),%eax
    c9a2:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c9a6:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c9ad:	66 39 c2             	cmp    %ax,%dx
    c9b0:	75 1b                	jne    c9cd <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c9b2:	8b 45 08             	mov    0x8(%ebp),%eax
    c9b5:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c9bc:	8b 45 08             	mov    0x8(%ebp),%eax
    c9bf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c9c6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c9cd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c9d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c9d4:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c9d7:	0f 85 60 ff ff ff    	jne    c93d <lodepng_compute_color_stats+0x52e>
    c9dd:	e9 21 05 00 00       	jmp    cf03 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c9e2:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c9e9:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c9f0:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c9f7:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c9fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ca05:	e9 ab 03 00 00       	jmp    cdb5 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    ca0a:	83 ec 04             	sub    $0x4,%esp
    ca0d:	ff 75 18             	pushl  0x18(%ebp)
    ca10:	ff 75 f4             	pushl  -0xc(%ebp)
    ca13:	ff 75 0c             	pushl  0xc(%ebp)
    ca16:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    ca1c:	50                   	push   %eax
    ca1d:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    ca23:	50                   	push   %eax
    ca24:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    ca2a:	50                   	push   %eax
    ca2b:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    ca31:	50                   	push   %eax
    ca32:	e8 1e de ff ff       	call   a855 <getPixelColorRGBA8>
    ca37:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    ca3a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ca3e:	75 41                	jne    ca81 <lodepng_compute_color_stats+0x672>
    ca40:	8b 45 08             	mov    0x8(%ebp),%eax
    ca43:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca49:	83 f8 07             	cmp    $0x7,%eax
    ca4c:	77 33                	ja     ca81 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    ca4e:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca55:	0f b6 c0             	movzbl %al,%eax
    ca58:	83 ec 0c             	sub    $0xc,%esp
    ca5b:	50                   	push   %eax
    ca5c:	e8 1d f9 ff ff       	call   c37e <getValueRequiredBits>
    ca61:	83 c4 10             	add    $0x10,%esp
    ca64:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    ca67:	8b 45 08             	mov    0x8(%ebp),%eax
    ca6a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca70:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    ca73:	73 0c                	jae    ca81 <lodepng_compute_color_stats+0x672>
    ca75:	8b 45 08             	mov    0x8(%ebp),%eax
    ca78:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    ca7b:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    ca81:	8b 45 08             	mov    0x8(%ebp),%eax
    ca84:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca8a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    ca8d:	0f 93 c0             	setae  %al
    ca90:	0f b6 c0             	movzbl %al,%eax
    ca93:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    ca96:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ca9a:	75 4f                	jne    caeb <lodepng_compute_color_stats+0x6dc>
    ca9c:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    caa3:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    caaa:	38 c2                	cmp    %al,%dl
    caac:	75 12                	jne    cac0 <lodepng_compute_color_stats+0x6b1>
    caae:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    cab5:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cabc:	38 c2                	cmp    %al,%dl
    cabe:	74 2b                	je     caeb <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    cac0:	8b 45 08             	mov    0x8(%ebp),%eax
    cac3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    cac9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    cad0:	8b 45 08             	mov    0x8(%ebp),%eax
    cad3:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cad9:	83 f8 07             	cmp    $0x7,%eax
    cadc:	77 0d                	ja     caeb <lodepng_compute_color_stats+0x6dc>
    cade:	8b 45 08             	mov    0x8(%ebp),%eax
    cae1:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cae8:	00 00 00 
      }

      if(!alpha_done) {
    caeb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    caef:	0f 85 65 01 00 00    	jne    cc5a <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    caf5:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cafc:	0f b6 d0             	movzbl %al,%edx
    caff:	8b 45 08             	mov    0x8(%ebp),%eax
    cb02:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cb06:	66 39 c2             	cmp    %ax,%dx
    cb09:	75 33                	jne    cb3e <lodepng_compute_color_stats+0x72f>
    cb0b:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb12:	0f b6 d0             	movzbl %al,%edx
    cb15:	8b 45 08             	mov    0x8(%ebp),%eax
    cb18:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cb1c:	66 39 c2             	cmp    %ax,%dx
    cb1f:	75 1d                	jne    cb3e <lodepng_compute_color_stats+0x72f>
    cb21:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb28:	0f b6 d0             	movzbl %al,%edx
    cb2b:	8b 45 08             	mov    0x8(%ebp),%eax
    cb2e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cb32:	66 39 c2             	cmp    %ax,%dx
    cb35:	75 07                	jne    cb3e <lodepng_compute_color_stats+0x72f>
    cb37:	b8 01 00 00 00       	mov    $0x1,%eax
    cb3c:	eb 05                	jmp    cb43 <lodepng_compute_color_stats+0x734>
    cb3e:	b8 00 00 00 00       	mov    $0x0,%eax
    cb43:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    cb46:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb4d:	3c ff                	cmp    $0xff,%al
    cb4f:	74 5a                	je     cbab <lodepng_compute_color_stats+0x79c>
    cb51:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb58:	84 c0                	test   %al,%al
    cb5a:	75 10                	jne    cb6c <lodepng_compute_color_stats+0x75d>
    cb5c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb5f:	8b 40 04             	mov    0x4(%eax),%eax
    cb62:	85 c0                	test   %eax,%eax
    cb64:	74 45                	je     cbab <lodepng_compute_color_stats+0x79c>
    cb66:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    cb6a:	75 3f                	jne    cbab <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    cb6c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb6f:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cb76:	8b 45 08             	mov    0x8(%ebp),%eax
    cb79:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cb80:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cb87:	8b 45 08             	mov    0x8(%ebp),%eax
    cb8a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cb90:	83 f8 07             	cmp    $0x7,%eax
    cb93:	0f 87 c1 00 00 00    	ja     cc5a <lodepng_compute_color_stats+0x84b>
    cb99:	8b 45 08             	mov    0x8(%ebp),%eax
    cb9c:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cba3:	00 00 00 
    cba6:	e9 af 00 00 00       	jmp    cc5a <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    cbab:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cbb2:	84 c0                	test   %al,%al
    cbb4:	75 53                	jne    cc09 <lodepng_compute_color_stats+0x7fa>
    cbb6:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb9:	8b 40 10             	mov    0x10(%eax),%eax
    cbbc:	85 c0                	test   %eax,%eax
    cbbe:	75 49                	jne    cc09 <lodepng_compute_color_stats+0x7fa>
    cbc0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbc3:	8b 40 04             	mov    0x4(%eax),%eax
    cbc6:	85 c0                	test   %eax,%eax
    cbc8:	75 3f                	jne    cc09 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    cbca:	8b 45 08             	mov    0x8(%ebp),%eax
    cbcd:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    cbd4:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cbdb:	0f b6 d0             	movzbl %al,%edx
    cbde:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe1:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    cbe5:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cbec:	0f b6 d0             	movzbl %al,%edx
    cbef:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf2:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    cbf6:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cbfd:	0f b6 d0             	movzbl %al,%edx
    cc00:	8b 45 08             	mov    0x8(%ebp),%eax
    cc03:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cc07:	eb 51                	jmp    cc5a <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    cc09:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc10:	3c ff                	cmp    $0xff,%al
    cc12:	75 46                	jne    cc5a <lodepng_compute_color_stats+0x84b>
    cc14:	8b 45 08             	mov    0x8(%ebp),%eax
    cc17:	8b 40 04             	mov    0x4(%eax),%eax
    cc1a:	85 c0                	test   %eax,%eax
    cc1c:	74 3c                	je     cc5a <lodepng_compute_color_stats+0x84b>
    cc1e:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    cc22:	74 36                	je     cc5a <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cc24:	8b 45 08             	mov    0x8(%ebp),%eax
    cc27:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cc2e:	8b 45 08             	mov    0x8(%ebp),%eax
    cc31:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cc38:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cc3f:	8b 45 08             	mov    0x8(%ebp),%eax
    cc42:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cc48:	83 f8 07             	cmp    $0x7,%eax
    cc4b:	77 0d                	ja     cc5a <lodepng_compute_color_stats+0x84b>
    cc4d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc50:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cc57:	00 00 00 
        }
      }

      if(!numcolors_done) {
    cc5a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cc5e:	0f 85 35 01 00 00    	jne    cd99 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    cc64:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc6b:	0f b6 d8             	movzbl %al,%ebx
    cc6e:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cc75:	0f b6 c8             	movzbl %al,%ecx
    cc78:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cc7f:	0f b6 d0             	movzbl %al,%edx
    cc82:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cc89:	0f b6 c0             	movzbl %al,%eax
    cc8c:	83 ec 0c             	sub    $0xc,%esp
    cc8f:	53                   	push   %ebx
    cc90:	51                   	push   %ecx
    cc91:	52                   	push   %edx
    cc92:	50                   	push   %eax
    cc93:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cc99:	50                   	push   %eax
    cc9a:	e8 1c d4 ff ff       	call   a0bb <color_tree_has>
    cc9f:	83 c4 20             	add    $0x20,%esp
    cca2:	85 c0                	test   %eax,%eax
    cca4:	0f 85 ef 00 00 00    	jne    cd99 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    ccaa:	8b 45 08             	mov    0x8(%ebp),%eax
    ccad:	8b 70 14             	mov    0x14(%eax),%esi
    ccb0:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ccb7:	0f b6 d8             	movzbl %al,%ebx
    ccba:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ccc1:	0f b6 c8             	movzbl %al,%ecx
    ccc4:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cccb:	0f b6 d0             	movzbl %al,%edx
    ccce:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ccd5:	0f b6 c0             	movzbl %al,%eax
    ccd8:	83 ec 08             	sub    $0x8,%esp
    ccdb:	56                   	push   %esi
    ccdc:	53                   	push   %ebx
    ccdd:	51                   	push   %ecx
    ccde:	52                   	push   %edx
    ccdf:	50                   	push   %eax
    cce0:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cce6:	50                   	push   %eax
    cce7:	e8 1a d4 ff ff       	call   a106 <color_tree_add>
    ccec:	83 c4 20             	add    $0x20,%esp
    ccef:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    ccf2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ccf6:	0f 85 06 02 00 00    	jne    cf02 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    ccfc:	8b 45 08             	mov    0x8(%ebp),%eax
    ccff:	8b 40 14             	mov    0x14(%eax),%eax
    cd02:	3d ff 00 00 00       	cmp    $0xff,%eax
    cd07:	77 6f                	ja     cd78 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    cd09:	8b 45 08             	mov    0x8(%ebp),%eax
    cd0c:	83 c0 18             	add    $0x18,%eax
    cd0f:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    cd12:	8b 45 08             	mov    0x8(%ebp),%eax
    cd15:	8b 40 14             	mov    0x14(%eax),%eax
    cd18:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    cd1b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd1e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cd25:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cd28:	01 c2                	add    %eax,%edx
    cd2a:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cd31:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    cd33:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd36:	c1 e0 02             	shl    $0x2,%eax
    cd39:	8d 50 01             	lea    0x1(%eax),%edx
    cd3c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cd3f:	01 c2                	add    %eax,%edx
    cd41:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cd48:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    cd4a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd4d:	c1 e0 02             	shl    $0x2,%eax
    cd50:	8d 50 02             	lea    0x2(%eax),%edx
    cd53:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cd56:	01 c2                	add    %eax,%edx
    cd58:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cd5f:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    cd61:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd64:	c1 e0 02             	shl    $0x2,%eax
    cd67:	8d 50 03             	lea    0x3(%eax),%edx
    cd6a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cd6d:	01 c2                	add    %eax,%edx
    cd6f:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cd76:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    cd78:	8b 45 08             	mov    0x8(%ebp),%eax
    cd7b:	8b 40 14             	mov    0x14(%eax),%eax
    cd7e:	8d 50 01             	lea    0x1(%eax),%edx
    cd81:	8b 45 08             	mov    0x8(%ebp),%eax
    cd84:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cd87:	8b 45 08             	mov    0x8(%ebp),%eax
    cd8a:	8b 40 14             	mov    0x14(%eax),%eax
    cd8d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cd90:	0f 93 c0             	setae  %al
    cd93:	0f b6 c0             	movzbl %al,%eax
    cd96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cd99:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd9d:	74 12                	je     cdb1 <lodepng_compute_color_stats+0x9a2>
    cd9f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cda3:	74 0c                	je     cdb1 <lodepng_compute_color_stats+0x9a2>
    cda5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cda9:	74 06                	je     cdb1 <lodepng_compute_color_stats+0x9a2>
    cdab:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cdaf:	75 12                	jne    cdc3 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cdb1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cdb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cdb8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cdbb:	0f 85 49 fc ff ff    	jne    ca0a <lodepng_compute_color_stats+0x5fb>
    cdc1:	eb 01                	jmp    cdc4 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cdc3:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cdc4:	8b 45 08             	mov    0x8(%ebp),%eax
    cdc7:	8b 40 04             	mov    0x4(%eax),%eax
    cdca:	85 c0                	test   %eax,%eax
    cdcc:	0f 84 dd 00 00 00    	je     ceaf <lodepng_compute_color_stats+0xaa0>
    cdd2:	8b 45 08             	mov    0x8(%ebp),%eax
    cdd5:	8b 40 10             	mov    0x10(%eax),%eax
    cdd8:	85 c0                	test   %eax,%eax
    cdda:	0f 85 cf 00 00 00    	jne    ceaf <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cde0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cde7:	e9 b7 00 00 00       	jmp    cea3 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cdec:	83 ec 04             	sub    $0x4,%esp
    cdef:	ff 75 18             	pushl  0x18(%ebp)
    cdf2:	ff 75 f4             	pushl  -0xc(%ebp)
    cdf5:	ff 75 0c             	pushl  0xc(%ebp)
    cdf8:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cdfe:	50                   	push   %eax
    cdff:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    ce05:	50                   	push   %eax
    ce06:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    ce0c:	50                   	push   %eax
    ce0d:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    ce13:	50                   	push   %eax
    ce14:	e8 3c da ff ff       	call   a855 <getPixelColorRGBA8>
    ce19:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    ce1c:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ce23:	84 c0                	test   %al,%al
    ce25:	74 78                	je     ce9f <lodepng_compute_color_stats+0xa90>
    ce27:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ce2e:	0f b6 d0             	movzbl %al,%edx
    ce31:	8b 45 08             	mov    0x8(%ebp),%eax
    ce34:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    ce38:	66 39 c2             	cmp    %ax,%dx
    ce3b:	75 62                	jne    ce9f <lodepng_compute_color_stats+0xa90>
    ce3d:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ce44:	0f b6 d0             	movzbl %al,%edx
    ce47:	8b 45 08             	mov    0x8(%ebp),%eax
    ce4a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    ce4e:	66 39 c2             	cmp    %ax,%dx
    ce51:	75 4c                	jne    ce9f <lodepng_compute_color_stats+0xa90>
    ce53:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ce5a:	0f b6 d0             	movzbl %al,%edx
    ce5d:	8b 45 08             	mov    0x8(%ebp),%eax
    ce60:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    ce64:	66 39 c2             	cmp    %ax,%dx
    ce67:	75 36                	jne    ce9f <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    ce69:	8b 45 08             	mov    0x8(%ebp),%eax
    ce6c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    ce73:	8b 45 08             	mov    0x8(%ebp),%eax
    ce76:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    ce7d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ce84:	8b 45 08             	mov    0x8(%ebp),%eax
    ce87:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ce8d:	83 f8 07             	cmp    $0x7,%eax
    ce90:	77 0d                	ja     ce9f <lodepng_compute_color_stats+0xa90>
    ce92:	8b 45 08             	mov    0x8(%ebp),%eax
    ce95:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    ce9c:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    ce9f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cea3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cea6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cea9:	0f 85 3d ff ff ff    	jne    cdec <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    ceaf:	8b 45 08             	mov    0x8(%ebp),%eax
    ceb2:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    ceb6:	8b 45 08             	mov    0x8(%ebp),%eax
    ceb9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cebd:	c1 e0 08             	shl    $0x8,%eax
    cec0:	01 c2                	add    %eax,%edx
    cec2:	8b 45 08             	mov    0x8(%ebp),%eax
    cec5:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cec9:	8b 45 08             	mov    0x8(%ebp),%eax
    cecc:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    ced0:	8b 45 08             	mov    0x8(%ebp),%eax
    ced3:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    ced7:	c1 e0 08             	shl    $0x8,%eax
    ceda:	01 c2                	add    %eax,%edx
    cedc:	8b 45 08             	mov    0x8(%ebp),%eax
    cedf:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cee3:	8b 45 08             	mov    0x8(%ebp),%eax
    cee6:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    ceea:	8b 45 08             	mov    0x8(%ebp),%eax
    ceed:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cef1:	c1 e0 08             	shl    $0x8,%eax
    cef4:	01 c2                	add    %eax,%edx
    cef6:	8b 45 08             	mov    0x8(%ebp),%eax
    cef9:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cefd:	eb 04                	jmp    cf03 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    ceff:	90                   	nop
    cf00:	eb 01                	jmp    cf03 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cf02:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cf03:	83 ec 0c             	sub    $0xc,%esp
    cf06:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cf0c:	50                   	push   %eax
    cf0d:	e8 91 d0 ff ff       	call   9fa3 <color_tree_cleanup>
    cf12:	83 c4 10             	add    $0x10,%esp
  return error;
    cf15:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cf18:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cf1b:	5b                   	pop    %ebx
    cf1c:	5e                   	pop    %esi
    cf1d:	5d                   	pop    %ebp
    cf1e:	c3                   	ret    

0000cf1f <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cf1f:	55                   	push   %ebp
    cf20:	89 e5                	mov    %esp,%ebp
    cf22:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cf25:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cf2c:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cf2f:	50                   	push   %eax
    cf30:	e8 d1 bd ff ff       	call   8d06 <lodepng_color_mode_init>
    cf35:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cf38:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf3b:	c1 e8 08             	shr    $0x8,%eax
    cf3e:	88 45 ec             	mov    %al,-0x14(%ebp)
    cf41:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf44:	88 45 ed             	mov    %al,-0x13(%ebp)
    cf47:	8b 45 10             	mov    0x10(%ebp),%eax
    cf4a:	c1 e8 08             	shr    $0x8,%eax
    cf4d:	88 45 ee             	mov    %al,-0x12(%ebp)
    cf50:	8b 45 10             	mov    0x10(%ebp),%eax
    cf53:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cf56:	8b 45 14             	mov    0x14(%ebp),%eax
    cf59:	c1 e8 08             	shr    $0x8,%eax
    cf5c:	88 45 f0             	mov    %al,-0x10(%ebp)
    cf5f:	8b 45 14             	mov    0x14(%ebp),%eax
    cf62:	88 45 f1             	mov    %al,-0xf(%ebp)
    cf65:	8b 45 18             	mov    0x18(%ebp),%eax
    cf68:	c1 e8 08             	shr    $0x8,%eax
    cf6b:	88 45 f2             	mov    %al,-0xe(%ebp)
    cf6e:	8b 45 18             	mov    0x18(%ebp),%eax
    cf71:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cf74:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cf7b:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cf82:	83 ec 0c             	sub    $0xc,%esp
    cf85:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cf88:	50                   	push   %eax
    cf89:	6a 01                	push   $0x1
    cf8b:	6a 01                	push   $0x1
    cf8d:	8d 45 ec             	lea    -0x14(%ebp),%eax
    cf90:	50                   	push   %eax
    cf91:	ff 75 08             	pushl  0x8(%ebp)
    cf94:	e8 76 f4 ff ff       	call   c40f <lodepng_compute_color_stats>
    cf99:	83 c4 20             	add    $0x20,%esp
    cf9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cf9f:	83 ec 0c             	sub    $0xc,%esp
    cfa2:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cfa5:	50                   	push   %eax
    cfa6:	e8 4e be ff ff       	call   8df9 <lodepng_color_mode_cleanup>
    cfab:	83 c4 10             	add    $0x10,%esp
  return error;
    cfae:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cfb1:	c9                   	leave  
    cfb2:	c3                   	ret    

0000cfb3 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    cfb3:	55                   	push   %ebp
    cfb4:	89 e5                	mov    %esp,%ebp
    cfb6:	56                   	push   %esi
    cfb7:	53                   	push   %ebx
    cfb8:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cfbb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    cfc2:	8b 45 10             	mov    0x10(%ebp),%eax
    cfc5:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    cfcb:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    cfce:	8b 45 10             	mov    0x10(%ebp),%eax
    cfd1:	8b 40 10             	mov    0x10(%eax),%eax
    cfd4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    cfd7:	8b 45 10             	mov    0x10(%ebp),%eax
    cfda:	8b 40 04             	mov    0x4(%eax),%eax
    cfdd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    cfe0:	8b 45 10             	mov    0x10(%ebp),%eax
    cfe3:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cfe9:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cfec:	8b 45 08             	mov    0x8(%ebp),%eax
    cfef:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    cff6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cffa:	74 21                	je     d01d <auto_choose_color+0x6a>
    cffc:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    d000:	7f 1b                	jg     d01d <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    d002:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    d009:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d010:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d014:	77 07                	ja     d01d <auto_choose_color+0x6a>
    d016:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    d01d:	8b 45 10             	mov    0x10(%ebp),%eax
    d020:	8b 00                	mov    (%eax),%eax
    d022:	85 c0                	test   %eax,%eax
    d024:	0f 94 c0             	sete   %al
    d027:	0f b6 c0             	movzbl %al,%eax
    d02a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    d02d:	8b 45 10             	mov    0x10(%ebp),%eax
    d030:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    d036:	85 c0                	test   %eax,%eax
    d038:	75 07                	jne    d041 <auto_choose_color+0x8e>
    d03a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    d041:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d045:	75 0d                	jne    d054 <auto_choose_color+0xa1>
    d047:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d04b:	77 07                	ja     d054 <auto_choose_color+0xa1>
    d04d:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    d054:	8b 45 10             	mov    0x10(%ebp),%eax
    d057:	8b 40 14             	mov    0x14(%eax),%eax
    d05a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    d05d:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    d061:	7e 21                	jle    d084 <auto_choose_color+0xd1>
    d063:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    d067:	7e 14                	jle    d07d <auto_choose_color+0xca>
    d069:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    d06d:	7f 07                	jg     d076 <auto_choose_color+0xc3>
    d06f:	b8 04 00 00 00       	mov    $0x4,%eax
    d074:	eb 13                	jmp    d089 <auto_choose_color+0xd6>
    d076:	b8 08 00 00 00       	mov    $0x8,%eax
    d07b:	eb 0c                	jmp    d089 <auto_choose_color+0xd6>
    d07d:	b8 02 00 00 00       	mov    $0x2,%eax
    d082:	eb 05                	jmp    d089 <auto_choose_color+0xd6>
    d084:	b8 01 00 00 00       	mov    $0x1,%eax
    d089:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    d08c:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    d093:	7f 13                	jg     d0a8 <auto_choose_color+0xf5>
    d095:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    d099:	77 0d                	ja     d0a8 <auto_choose_color+0xf5>
    d09b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    d09f:	74 07                	je     d0a8 <auto_choose_color+0xf5>
    d0a1:	b8 01 00 00 00       	mov    $0x1,%eax
    d0a6:	eb 05                	jmp    d0ad <auto_choose_color+0xfa>
    d0a8:	b8 00 00 00 00       	mov    $0x0,%eax
    d0ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    d0b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d0b3:	01 c0                	add    %eax,%eax
    d0b5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d0b8:	7e 07                	jle    d0c1 <auto_choose_color+0x10e>
    d0ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    d0c1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d0c5:	74 15                	je     d0dc <auto_choose_color+0x129>
    d0c7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d0cb:	75 0f                	jne    d0dc <auto_choose_color+0x129>
    d0cd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d0d0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d0d3:	77 07                	ja     d0dc <auto_choose_color+0x129>
    d0d5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    d0dc:	8b 45 10             	mov    0x10(%ebp),%eax
    d0df:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    d0e5:	85 c0                	test   %eax,%eax
    d0e7:	75 07                	jne    d0f0 <auto_choose_color+0x13d>
    d0e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    d0f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d0f4:	0f 84 0a 01 00 00    	je     d204 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    d0fa:	8b 45 10             	mov    0x10(%ebp),%eax
    d0fd:	83 c0 18             	add    $0x18,%eax
    d100:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    d103:	83 ec 0c             	sub    $0xc,%esp
    d106:	ff 75 08             	pushl  0x8(%ebp)
    d109:	e8 ef be ff ff       	call   8ffd <lodepng_palette_clear>
    d10e:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    d111:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d118:	eb 6e                	jmp    d188 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    d11a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d11d:	c1 e0 02             	shl    $0x2,%eax
    d120:	8d 50 03             	lea    0x3(%eax),%edx
    d123:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d126:	01 d0                	add    %edx,%eax
    d128:	0f b6 00             	movzbl (%eax),%eax
    d12b:	0f b6 d8             	movzbl %al,%ebx
    d12e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d131:	c1 e0 02             	shl    $0x2,%eax
    d134:	8d 50 02             	lea    0x2(%eax),%edx
    d137:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d13a:	01 d0                	add    %edx,%eax
    d13c:	0f b6 00             	movzbl (%eax),%eax
    d13f:	0f b6 c8             	movzbl %al,%ecx
    d142:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d145:	c1 e0 02             	shl    $0x2,%eax
    d148:	8d 50 01             	lea    0x1(%eax),%edx
    d14b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d14e:	01 d0                	add    %edx,%eax
    d150:	0f b6 00             	movzbl (%eax),%eax
    d153:	0f b6 d0             	movzbl %al,%edx
    d156:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d159:	c1 e0 02             	shl    $0x2,%eax
    d15c:	89 c6                	mov    %eax,%esi
    d15e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d161:	01 f0                	add    %esi,%eax
    d163:	0f b6 00             	movzbl (%eax),%eax
    d166:	0f b6 c0             	movzbl %al,%eax
    d169:	83 ec 0c             	sub    $0xc,%esp
    d16c:	53                   	push   %ebx
    d16d:	51                   	push   %ecx
    d16e:	52                   	push   %edx
    d16f:	50                   	push   %eax
    d170:	ff 75 08             	pushl  0x8(%ebp)
    d173:	e8 be be ff ff       	call   9036 <lodepng_palette_add>
    d178:	83 c4 20             	add    $0x20,%esp
    d17b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    d17e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d182:	75 13                	jne    d197 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    d184:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    d188:	8b 45 10             	mov    0x10(%ebp),%eax
    d18b:	8b 50 14             	mov    0x14(%eax),%edx
    d18e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d191:	39 c2                	cmp    %eax,%edx
    d193:	75 85                	jne    d11a <auto_choose_color+0x167>
    d195:	eb 01                	jmp    d198 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    d197:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    d198:	8b 45 08             	mov    0x8(%ebp),%eax
    d19b:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    d1a1:	8b 45 08             	mov    0x8(%ebp),%eax
    d1a4:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d1a7:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    d1aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1ad:	8b 00                	mov    (%eax),%eax
    d1af:	83 f8 03             	cmp    $0x3,%eax
    d1b2:	0f 85 ec 00 00 00    	jne    d2a4 <auto_choose_color+0x2f1>
    d1b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1bb:	8b 50 0c             	mov    0xc(%eax),%edx
    d1be:	8b 45 08             	mov    0x8(%ebp),%eax
    d1c1:	8b 40 0c             	mov    0xc(%eax),%eax
    d1c4:	39 c2                	cmp    %eax,%edx
    d1c6:	0f 8c d8 00 00 00    	jl     d2a4 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    d1cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1cf:	8b 50 04             	mov    0x4(%eax),%edx
    d1d2:	8b 45 08             	mov    0x8(%ebp),%eax
    d1d5:	8b 40 04             	mov    0x4(%eax),%eax
    d1d8:	39 c2                	cmp    %eax,%edx
    d1da:	0f 85 c4 00 00 00    	jne    d2a4 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    d1e0:	83 ec 0c             	sub    $0xc,%esp
    d1e3:	ff 75 08             	pushl  0x8(%ebp)
    d1e6:	e8 0e bc ff ff       	call   8df9 <lodepng_color_mode_cleanup>
    d1eb:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    d1ee:	83 ec 08             	sub    $0x8,%esp
    d1f1:	ff 75 0c             	pushl  0xc(%ebp)
    d1f4:	ff 75 08             	pushl  0x8(%ebp)
    d1f7:	e8 14 bc ff ff       	call   8e10 <lodepng_color_mode_copy>
    d1fc:	83 c4 10             	add    $0x10,%esp
    d1ff:	e9 a0 00 00 00       	jmp    d2a4 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    d204:	8b 45 08             	mov    0x8(%ebp),%eax
    d207:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d20a:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    d20d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d211:	74 14                	je     d227 <auto_choose_color+0x274>
    d213:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d217:	74 07                	je     d220 <auto_choose_color+0x26d>
    d219:	b8 04 00 00 00       	mov    $0x4,%eax
    d21e:	eb 19                	jmp    d239 <auto_choose_color+0x286>
    d220:	b8 06 00 00 00       	mov    $0x6,%eax
    d225:	eb 12                	jmp    d239 <auto_choose_color+0x286>
    d227:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d22b:	74 07                	je     d234 <auto_choose_color+0x281>
    d22d:	b8 00 00 00 00       	mov    $0x0,%eax
    d232:	eb 05                	jmp    d239 <auto_choose_color+0x286>
    d234:	b8 02 00 00 00       	mov    $0x2,%eax
    d239:	8b 55 08             	mov    0x8(%ebp),%edx
    d23c:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    d23e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d242:	74 60                	je     d2a4 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    d244:	8b 45 08             	mov    0x8(%ebp),%eax
    d247:	8b 40 04             	mov    0x4(%eax),%eax
    d24a:	ba 01 00 00 00       	mov    $0x1,%edx
    d24f:	89 c1                	mov    %eax,%ecx
    d251:	d3 e2                	shl    %cl,%edx
    d253:	89 d0                	mov    %edx,%eax
    d255:	83 e8 01             	sub    $0x1,%eax
    d258:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d25b:	8b 45 10             	mov    0x10(%ebp),%eax
    d25e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d262:	0f b7 c0             	movzwl %ax,%eax
    d265:	23 45 c8             	and    -0x38(%ebp),%eax
    d268:	89 c2                	mov    %eax,%edx
    d26a:	8b 45 08             	mov    0x8(%ebp),%eax
    d26d:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d270:	8b 45 10             	mov    0x10(%ebp),%eax
    d273:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d277:	0f b7 c0             	movzwl %ax,%eax
    d27a:	23 45 c8             	and    -0x38(%ebp),%eax
    d27d:	89 c2                	mov    %eax,%edx
    d27f:	8b 45 08             	mov    0x8(%ebp),%eax
    d282:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d285:	8b 45 10             	mov    0x10(%ebp),%eax
    d288:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d28c:	0f b7 c0             	movzwl %ax,%eax
    d28f:	23 45 c8             	and    -0x38(%ebp),%eax
    d292:	89 c2                	mov    %eax,%edx
    d294:	8b 45 08             	mov    0x8(%ebp),%eax
    d297:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d29a:	8b 45 08             	mov    0x8(%ebp),%eax
    d29d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d2a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d2a7:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d2aa:	5b                   	pop    %ebx
    d2ab:	5e                   	pop    %esi
    d2ac:	5d                   	pop    %ebp
    d2ad:	c3                   	ret    

0000d2ae <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d2ae:	55                   	push   %ebp
    d2af:	89 e5                	mov    %esp,%ebp
    d2b1:	83 ec 1c             	sub    $0x1c,%esp
    d2b4:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d2b7:	8b 55 0c             	mov    0xc(%ebp),%edx
    d2ba:	8b 45 10             	mov    0x10(%ebp),%eax
    d2bd:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d2c1:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d2c5:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d2c9:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d2cd:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d2d1:	29 c2                	sub    %eax,%edx
    d2d3:	89 d0                	mov    %edx,%eax
    d2d5:	99                   	cltd   
    d2d6:	31 d0                	xor    %edx,%eax
    d2d8:	29 d0                	sub    %edx,%eax
    d2da:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d2de:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d2e2:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d2e6:	29 c2                	sub    %eax,%edx
    d2e8:	89 d0                	mov    %edx,%eax
    d2ea:	99                   	cltd   
    d2eb:	31 d0                	xor    %edx,%eax
    d2ed:	29 d0                	sub    %edx,%eax
    d2ef:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d2f3:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d2f7:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d2fb:	01 c2                	add    %eax,%edx
    d2fd:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d301:	29 c2                	sub    %eax,%edx
    d303:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d307:	29 c2                	sub    %eax,%edx
    d309:	89 d0                	mov    %edx,%eax
    d30b:	99                   	cltd   
    d30c:	31 d0                	xor    %edx,%eax
    d30e:	29 d0                	sub    %edx,%eax
    d310:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d314:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d318:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d31c:	7d 10                	jge    d32e <paethPredictor+0x80>
    d31e:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d322:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d326:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d32a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d32e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d332:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d336:	7d 06                	jge    d33e <paethPredictor+0x90>
    d338:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d33c:	eb 04                	jmp    d342 <paethPredictor+0x94>
    d33e:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d342:	c9                   	leave  
    d343:	c3                   	ret    

0000d344 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d344:	55                   	push   %ebp
    d345:	89 e5                	mov    %esp,%ebp
    d347:	56                   	push   %esi
    d348:	53                   	push   %ebx
    d349:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d34c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d353:	e9 e2 00 00 00       	jmp    d43a <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d358:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d35b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d362:	8b 45 08             	mov    0x8(%ebp),%eax
    d365:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d368:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d36b:	8b 14 85 14 a3 01 00 	mov    0x1a314(,%eax,4),%edx
    d372:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d375:	01 c2                	add    %eax,%edx
    d377:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d37a:	8b 04 85 dc a2 01 00 	mov    0x1a2dc(,%eax,4),%eax
    d381:	29 c2                	sub    %eax,%edx
    d383:	89 d0                	mov    %edx,%eax
    d385:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d388:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d38b:	8b 34 85 14 a3 01 00 	mov    0x1a314(,%eax,4),%esi
    d392:	89 d8                	mov    %ebx,%eax
    d394:	ba 00 00 00 00       	mov    $0x0,%edx
    d399:	f7 f6                	div    %esi
    d39b:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d39d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3a0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d3a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d3aa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d3ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3b0:	8b 14 85 30 a3 01 00 	mov    0x1a330(,%eax,4),%edx
    d3b7:	8b 45 20             	mov    0x20(%ebp),%eax
    d3ba:	01 c2                	add    %eax,%edx
    d3bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3bf:	8b 04 85 f8 a2 01 00 	mov    0x1a2f8(,%eax,4),%eax
    d3c6:	29 c2                	sub    %eax,%edx
    d3c8:	89 d0                	mov    %edx,%eax
    d3ca:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d3cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3d0:	8b 34 85 30 a3 01 00 	mov    0x1a330(,%eax,4),%esi
    d3d7:	89 d8                	mov    %ebx,%eax
    d3d9:	ba 00 00 00 00       	mov    $0x0,%edx
    d3de:	f7 f6                	div    %esi
    d3e0:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d3e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d3ec:	8b 45 08             	mov    0x8(%ebp),%eax
    d3ef:	01 d0                	add    %edx,%eax
    d3f1:	8b 00                	mov    (%eax),%eax
    d3f3:	85 c0                	test   %eax,%eax
    d3f5:	75 15                	jne    d40c <Adam7_getpassvalues+0xc8>
    d3f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3fa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d401:	8b 45 0c             	mov    0xc(%ebp),%eax
    d404:	01 d0                	add    %edx,%eax
    d406:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d40c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d40f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d416:	8b 45 0c             	mov    0xc(%ebp),%eax
    d419:	01 d0                	add    %edx,%eax
    d41b:	8b 00                	mov    (%eax),%eax
    d41d:	85 c0                	test   %eax,%eax
    d41f:	75 15                	jne    d436 <Adam7_getpassvalues+0xf2>
    d421:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d424:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d42b:	8b 45 08             	mov    0x8(%ebp),%eax
    d42e:	01 d0                	add    %edx,%eax
    d430:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d436:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d43a:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d43e:	0f 85 14 ff ff ff    	jne    d358 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d444:	8b 45 18             	mov    0x18(%ebp),%eax
    d447:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d44d:	8b 45 18             	mov    0x18(%ebp),%eax
    d450:	8b 10                	mov    (%eax),%edx
    d452:	8b 45 14             	mov    0x14(%ebp),%eax
    d455:	89 10                	mov    %edx,(%eax)
    d457:	8b 45 14             	mov    0x14(%ebp),%eax
    d45a:	8b 10                	mov    (%eax),%edx
    d45c:	8b 45 10             	mov    0x10(%ebp),%eax
    d45f:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d461:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d468:	e9 40 01 00 00       	jmp    d5ad <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d46d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d470:	83 c0 01             	add    $0x1,%eax
    d473:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d47a:	8b 45 10             	mov    0x10(%ebp),%eax
    d47d:	01 c2                	add    %eax,%edx
    d47f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d482:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d489:	8b 45 10             	mov    0x10(%ebp),%eax
    d48c:	01 c8                	add    %ecx,%eax
    d48e:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d490:	89 c6                	mov    %eax,%esi
    d492:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d495:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d49c:	8b 45 08             	mov    0x8(%ebp),%eax
    d49f:	01 c8                	add    %ecx,%eax
    d4a1:	8b 00                	mov    (%eax),%eax
    d4a3:	85 c0                	test   %eax,%eax
    d4a5:	74 49                	je     d4f0 <Adam7_getpassvalues+0x1ac>
    d4a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4aa:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d4b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d4b4:	01 c8                	add    %ecx,%eax
    d4b6:	8b 00                	mov    (%eax),%eax
    d4b8:	85 c0                	test   %eax,%eax
    d4ba:	74 34                	je     d4f0 <Adam7_getpassvalues+0x1ac>
    d4bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4bf:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d4c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    d4c9:	01 c8                	add    %ecx,%eax
    d4cb:	8b 08                	mov    (%eax),%ecx
    d4cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4d0:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d4d7:	8b 45 08             	mov    0x8(%ebp),%eax
    d4da:	01 d8                	add    %ebx,%eax
    d4dc:	8b 00                	mov    (%eax),%eax
    d4de:	0f af 45 24          	imul   0x24(%ebp),%eax
    d4e2:	83 c0 07             	add    $0x7,%eax
    d4e5:	c1 e8 03             	shr    $0x3,%eax
    d4e8:	83 c0 01             	add    $0x1,%eax
    d4eb:	0f af c1             	imul   %ecx,%eax
    d4ee:	eb 05                	jmp    d4f5 <Adam7_getpassvalues+0x1b1>
    d4f0:	b8 00 00 00 00       	mov    $0x0,%eax
    d4f5:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d4f7:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d4f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4fc:	83 c0 01             	add    $0x1,%eax
    d4ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d506:	8b 45 14             	mov    0x14(%ebp),%eax
    d509:	01 c2                	add    %eax,%edx
    d50b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d50e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d515:	8b 45 14             	mov    0x14(%ebp),%eax
    d518:	01 c8                	add    %ecx,%eax
    d51a:	8b 00                	mov    (%eax),%eax
    d51c:	89 c6                	mov    %eax,%esi
    d51e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d521:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d528:	8b 45 0c             	mov    0xc(%ebp),%eax
    d52b:	01 c8                	add    %ecx,%eax
    d52d:	8b 08                	mov    (%eax),%ecx
    d52f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d532:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d539:	8b 45 08             	mov    0x8(%ebp),%eax
    d53c:	01 d8                	add    %ebx,%eax
    d53e:	8b 00                	mov    (%eax),%eax
    d540:	0f af 45 24          	imul   0x24(%ebp),%eax
    d544:	83 c0 07             	add    $0x7,%eax
    d547:	c1 e8 03             	shr    $0x3,%eax
    d54a:	0f af c1             	imul   %ecx,%eax
    d54d:	01 f0                	add    %esi,%eax
    d54f:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d551:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d554:	83 c0 01             	add    $0x1,%eax
    d557:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d55e:	8b 45 18             	mov    0x18(%ebp),%eax
    d561:	01 c2                	add    %eax,%edx
    d563:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d566:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d56d:	8b 45 18             	mov    0x18(%ebp),%eax
    d570:	01 c8                	add    %ecx,%eax
    d572:	8b 00                	mov    (%eax),%eax
    d574:	89 c6                	mov    %eax,%esi
    d576:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d579:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d580:	8b 45 0c             	mov    0xc(%ebp),%eax
    d583:	01 c8                	add    %ecx,%eax
    d585:	8b 08                	mov    (%eax),%ecx
    d587:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d58a:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d591:	8b 45 08             	mov    0x8(%ebp),%eax
    d594:	01 d8                	add    %ebx,%eax
    d596:	8b 00                	mov    (%eax),%eax
    d598:	0f af c1             	imul   %ecx,%eax
    d59b:	0f af 45 24          	imul   0x24(%ebp),%eax
    d59f:	83 c0 07             	add    $0x7,%eax
    d5a2:	c1 e8 03             	shr    $0x3,%eax
    d5a5:	01 f0                	add    %esi,%eax
    d5a7:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d5a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d5ad:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d5b1:	0f 85 b6 fe ff ff    	jne    d46d <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d5b7:	90                   	nop
    d5b8:	83 c4 10             	add    $0x10,%esp
    d5bb:	5b                   	pop    %ebx
    d5bc:	5e                   	pop    %esi
    d5bd:	5d                   	pop    %ebp
    d5be:	c3                   	ret    

0000d5bf <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d5bf:	55                   	push   %ebp
    d5c0:	89 e5                	mov    %esp,%ebp
    d5c2:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d5c5:	8b 45 10             	mov    0x10(%ebp),%eax
    d5c8:	05 98 00 00 00       	add    $0x98,%eax
    d5cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d5d0:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d5d4:	74 06                	je     d5dc <lodepng_inspect+0x1d>
    d5d6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d5da:	75 17                	jne    d5f3 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d5dc:	8b 45 10             	mov    0x10(%ebp),%eax
    d5df:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d5e6:	00 00 00 
    d5e9:	b8 30 00 00 00       	mov    $0x30,%eax
    d5ee:	e9 ce 02 00 00       	jmp    d8c1 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d5f3:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d5f7:	7f 17                	jg     d610 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d5f9:	8b 45 10             	mov    0x10(%ebp),%eax
    d5fc:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d603:	00 00 00 
    d606:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d60b:	e9 b1 02 00 00       	jmp    d8c1 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d610:	83 ec 0c             	sub    $0xc,%esp
    d613:	ff 75 f4             	pushl  -0xc(%ebp)
    d616:	e8 63 c7 ff ff       	call   9d7e <lodepng_info_cleanup>
    d61b:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d61e:	83 ec 0c             	sub    $0xc,%esp
    d621:	ff 75 f4             	pushl  -0xc(%ebp)
    d624:	e8 74 c6 ff ff       	call   9c9d <lodepng_info_init>
    d629:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d62c:	8b 45 14             	mov    0x14(%ebp),%eax
    d62f:	0f b6 00             	movzbl (%eax),%eax
    d632:	3c 89                	cmp    $0x89,%al
    d634:	75 5b                	jne    d691 <lodepng_inspect+0xd2>
    d636:	8b 45 14             	mov    0x14(%ebp),%eax
    d639:	83 c0 01             	add    $0x1,%eax
    d63c:	0f b6 00             	movzbl (%eax),%eax
    d63f:	3c 50                	cmp    $0x50,%al
    d641:	75 4e                	jne    d691 <lodepng_inspect+0xd2>
    d643:	8b 45 14             	mov    0x14(%ebp),%eax
    d646:	83 c0 02             	add    $0x2,%eax
    d649:	0f b6 00             	movzbl (%eax),%eax
    d64c:	3c 4e                	cmp    $0x4e,%al
    d64e:	75 41                	jne    d691 <lodepng_inspect+0xd2>
    d650:	8b 45 14             	mov    0x14(%ebp),%eax
    d653:	83 c0 03             	add    $0x3,%eax
    d656:	0f b6 00             	movzbl (%eax),%eax
    d659:	3c 47                	cmp    $0x47,%al
    d65b:	75 34                	jne    d691 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d65d:	8b 45 14             	mov    0x14(%ebp),%eax
    d660:	83 c0 04             	add    $0x4,%eax
    d663:	0f b6 00             	movzbl (%eax),%eax
    d666:	3c 0d                	cmp    $0xd,%al
    d668:	75 27                	jne    d691 <lodepng_inspect+0xd2>
    d66a:	8b 45 14             	mov    0x14(%ebp),%eax
    d66d:	83 c0 05             	add    $0x5,%eax
    d670:	0f b6 00             	movzbl (%eax),%eax
    d673:	3c 0a                	cmp    $0xa,%al
    d675:	75 1a                	jne    d691 <lodepng_inspect+0xd2>
    d677:	8b 45 14             	mov    0x14(%ebp),%eax
    d67a:	83 c0 06             	add    $0x6,%eax
    d67d:	0f b6 00             	movzbl (%eax),%eax
    d680:	3c 1a                	cmp    $0x1a,%al
    d682:	75 0d                	jne    d691 <lodepng_inspect+0xd2>
    d684:	8b 45 14             	mov    0x14(%ebp),%eax
    d687:	83 c0 07             	add    $0x7,%eax
    d68a:	0f b6 00             	movzbl (%eax),%eax
    d68d:	3c 0a                	cmp    $0xa,%al
    d68f:	74 17                	je     d6a8 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d691:	8b 45 10             	mov    0x10(%ebp),%eax
    d694:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d69b:	00 00 00 
    d69e:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d6a3:	e9 19 02 00 00       	jmp    d8c1 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d6a8:	8b 45 14             	mov    0x14(%ebp),%eax
    d6ab:	83 c0 08             	add    $0x8,%eax
    d6ae:	83 ec 0c             	sub    $0xc,%esp
    d6b1:	50                   	push   %eax
    d6b2:	e8 c2 ae ff ff       	call   8579 <lodepng_chunk_length>
    d6b7:	83 c4 10             	add    $0x10,%esp
    d6ba:	83 f8 0d             	cmp    $0xd,%eax
    d6bd:	74 17                	je     d6d6 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d6bf:	8b 45 10             	mov    0x10(%ebp),%eax
    d6c2:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d6c9:	00 00 00 
    d6cc:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d6d1:	e9 eb 01 00 00       	jmp    d8c1 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d6d6:	8b 45 14             	mov    0x14(%ebp),%eax
    d6d9:	83 c0 08             	add    $0x8,%eax
    d6dc:	83 ec 08             	sub    $0x8,%esp
    d6df:	68 4c a3 01 00       	push   $0x1a34c
    d6e4:	50                   	push   %eax
    d6e5:	e8 dc ae ff ff       	call   85c6 <lodepng_chunk_type_equals>
    d6ea:	83 c4 10             	add    $0x10,%esp
    d6ed:	84 c0                	test   %al,%al
    d6ef:	75 17                	jne    d708 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d6f1:	8b 45 10             	mov    0x10(%ebp),%eax
    d6f4:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d6fb:	00 00 00 
    d6fe:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d703:	e9 b9 01 00 00       	jmp    d8c1 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d708:	8b 45 14             	mov    0x14(%ebp),%eax
    d70b:	83 c0 10             	add    $0x10,%eax
    d70e:	83 ec 0c             	sub    $0xc,%esp
    d711:	50                   	push   %eax
    d712:	e8 5e 62 ff ff       	call   3975 <lodepng_read32bitInt>
    d717:	83 c4 10             	add    $0x10,%esp
    d71a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d71d:	8b 45 14             	mov    0x14(%ebp),%eax
    d720:	83 c0 14             	add    $0x14,%eax
    d723:	83 ec 0c             	sub    $0xc,%esp
    d726:	50                   	push   %eax
    d727:	e8 49 62 ff ff       	call   3975 <lodepng_read32bitInt>
    d72c:	83 c4 10             	add    $0x10,%esp
    d72f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d732:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d736:	74 08                	je     d740 <lodepng_inspect+0x181>
    d738:	8b 45 08             	mov    0x8(%ebp),%eax
    d73b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d73e:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d740:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d744:	74 08                	je     d74e <lodepng_inspect+0x18f>
    d746:	8b 45 0c             	mov    0xc(%ebp),%eax
    d749:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d74c:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d74e:	8b 45 14             	mov    0x14(%ebp),%eax
    d751:	83 c0 18             	add    $0x18,%eax
    d754:	0f b6 00             	movzbl (%eax),%eax
    d757:	0f b6 d0             	movzbl %al,%edx
    d75a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d75d:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d760:	8b 45 14             	mov    0x14(%ebp),%eax
    d763:	83 c0 19             	add    $0x19,%eax
    d766:	0f b6 00             	movzbl (%eax),%eax
    d769:	0f b6 d0             	movzbl %al,%edx
    d76c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d76f:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d772:	8b 45 14             	mov    0x14(%ebp),%eax
    d775:	83 c0 1a             	add    $0x1a,%eax
    d778:	0f b6 00             	movzbl (%eax),%eax
    d77b:	0f b6 d0             	movzbl %al,%edx
    d77e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d781:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d783:	8b 45 14             	mov    0x14(%ebp),%eax
    d786:	83 c0 1b             	add    $0x1b,%eax
    d789:	0f b6 00             	movzbl (%eax),%eax
    d78c:	0f b6 d0             	movzbl %al,%edx
    d78f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d792:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d795:	8b 45 14             	mov    0x14(%ebp),%eax
    d798:	83 c0 1c             	add    $0x1c,%eax
    d79b:	0f b6 00             	movzbl (%eax),%eax
    d79e:	0f b6 d0             	movzbl %al,%edx
    d7a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7a4:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d7a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d7ab:	74 06                	je     d7b3 <lodepng_inspect+0x1f4>
    d7ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d7b1:	75 17                	jne    d7ca <lodepng_inspect+0x20b>
    d7b3:	8b 45 10             	mov    0x10(%ebp),%eax
    d7b6:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d7bd:	00 00 00 
    d7c0:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d7c5:	e9 f7 00 00 00       	jmp    d8c1 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d7ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7cd:	8b 50 10             	mov    0x10(%eax),%edx
    d7d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7d3:	8b 40 0c             	mov    0xc(%eax),%eax
    d7d6:	83 ec 08             	sub    $0x8,%esp
    d7d9:	52                   	push   %edx
    d7da:	50                   	push   %eax
    d7db:	e8 d4 b3 ff ff       	call   8bb4 <checkColorValidity>
    d7e0:	83 c4 10             	add    $0x10,%esp
    d7e3:	89 c2                	mov    %eax,%edx
    d7e5:	8b 45 10             	mov    0x10(%ebp),%eax
    d7e8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d7ee:	8b 45 10             	mov    0x10(%ebp),%eax
    d7f1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d7f7:	85 c0                	test   %eax,%eax
    d7f9:	74 0e                	je     d809 <lodepng_inspect+0x24a>
    d7fb:	8b 45 10             	mov    0x10(%ebp),%eax
    d7fe:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d804:	e9 b8 00 00 00       	jmp    d8c1 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d809:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d80c:	8b 00                	mov    (%eax),%eax
    d80e:	85 c0                	test   %eax,%eax
    d810:	74 17                	je     d829 <lodepng_inspect+0x26a>
    d812:	8b 45 10             	mov    0x10(%ebp),%eax
    d815:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d81c:	00 00 00 
    d81f:	b8 20 00 00 00       	mov    $0x20,%eax
    d824:	e9 98 00 00 00       	jmp    d8c1 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d829:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d82c:	8b 40 04             	mov    0x4(%eax),%eax
    d82f:	85 c0                	test   %eax,%eax
    d831:	74 14                	je     d847 <lodepng_inspect+0x288>
    d833:	8b 45 10             	mov    0x10(%ebp),%eax
    d836:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d83d:	00 00 00 
    d840:	b8 21 00 00 00       	mov    $0x21,%eax
    d845:	eb 7a                	jmp    d8c1 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d847:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d84a:	8b 40 08             	mov    0x8(%eax),%eax
    d84d:	83 f8 01             	cmp    $0x1,%eax
    d850:	76 14                	jbe    d866 <lodepng_inspect+0x2a7>
    d852:	8b 45 10             	mov    0x10(%ebp),%eax
    d855:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d85c:	00 00 00 
    d85f:	b8 22 00 00 00       	mov    $0x22,%eax
    d864:	eb 5b                	jmp    d8c1 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d866:	8b 45 10             	mov    0x10(%ebp),%eax
    d869:	8b 40 18             	mov    0x18(%eax),%eax
    d86c:	85 c0                	test   %eax,%eax
    d86e:	75 48                	jne    d8b8 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d870:	8b 45 14             	mov    0x14(%ebp),%eax
    d873:	83 c0 1d             	add    $0x1d,%eax
    d876:	83 ec 0c             	sub    $0xc,%esp
    d879:	50                   	push   %eax
    d87a:	e8 f6 60 ff ff       	call   3975 <lodepng_read32bitInt>
    d87f:	83 c4 10             	add    $0x10,%esp
    d882:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d885:	8b 45 14             	mov    0x14(%ebp),%eax
    d888:	83 c0 0c             	add    $0xc,%eax
    d88b:	83 ec 08             	sub    $0x8,%esp
    d88e:	6a 11                	push   $0x11
    d890:	50                   	push   %eax
    d891:	e8 71 ab ff ff       	call   8407 <lodepng_crc32>
    d896:	83 c4 10             	add    $0x10,%esp
    d899:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d89c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d89f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d8a2:	74 14                	je     d8b8 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d8a4:	8b 45 10             	mov    0x10(%ebp),%eax
    d8a7:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d8ae:	00 00 00 
    d8b1:	b8 39 00 00 00       	mov    $0x39,%eax
    d8b6:	eb 09                	jmp    d8c1 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d8b8:	8b 45 10             	mov    0x10(%ebp),%eax
    d8bb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d8c1:	c9                   	leave  
    d8c2:	c3                   	ret    

0000d8c3 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d8c3:	55                   	push   %ebp
    d8c4:	89 e5                	mov    %esp,%ebp
    d8c6:	56                   	push   %esi
    d8c7:	53                   	push   %ebx
    d8c8:	83 ec 44             	sub    $0x44,%esp
    d8cb:	8b 45 18             	mov    0x18(%ebp),%eax
    d8ce:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d8d1:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d8d5:	83 f8 04             	cmp    $0x4,%eax
    d8d8:	0f 87 81 07 00 00    	ja     e05f <unfilterScanline+0x79c>
    d8de:	8b 04 85 54 a3 01 00 	mov    0x1a354(,%eax,4),%eax
    d8e5:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d8e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d8ee:	eb 19                	jmp    d909 <unfilterScanline+0x46>
    d8f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8f3:	8b 45 08             	mov    0x8(%ebp),%eax
    d8f6:	01 c2                	add    %eax,%edx
    d8f8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d8fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8fe:	01 c8                	add    %ecx,%eax
    d900:	0f b6 00             	movzbl (%eax),%eax
    d903:	88 02                	mov    %al,(%edx)
    d905:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d909:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d90c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d90f:	75 df                	jne    d8f0 <unfilterScanline+0x2d>
      break;
    d911:	e9 50 07 00 00       	jmp    e066 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d916:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d91d:	eb 19                	jmp    d938 <unfilterScanline+0x75>
    d91f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d922:	8b 45 08             	mov    0x8(%ebp),%eax
    d925:	01 c2                	add    %eax,%edx
    d927:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d92a:	8b 45 0c             	mov    0xc(%ebp),%eax
    d92d:	01 c8                	add    %ecx,%eax
    d92f:	0f b6 00             	movzbl (%eax),%eax
    d932:	88 02                	mov    %al,(%edx)
    d934:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d938:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d93b:	3b 45 14             	cmp    0x14(%ebp),%eax
    d93e:	75 df                	jne    d91f <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d940:	8b 45 14             	mov    0x14(%ebp),%eax
    d943:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d946:	eb 2b                	jmp    d973 <unfilterScanline+0xb0>
    d948:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d94b:	8b 45 08             	mov    0x8(%ebp),%eax
    d94e:	01 c2                	add    %eax,%edx
    d950:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d953:	8b 45 0c             	mov    0xc(%ebp),%eax
    d956:	01 c8                	add    %ecx,%eax
    d958:	0f b6 08             	movzbl (%eax),%ecx
    d95b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d95e:	2b 45 14             	sub    0x14(%ebp),%eax
    d961:	89 c3                	mov    %eax,%ebx
    d963:	8b 45 08             	mov    0x8(%ebp),%eax
    d966:	01 d8                	add    %ebx,%eax
    d968:	0f b6 00             	movzbl (%eax),%eax
    d96b:	01 c8                	add    %ecx,%eax
    d96d:	88 02                	mov    %al,(%edx)
    d96f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d973:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d976:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d979:	7c cd                	jl     d948 <unfilterScanline+0x85>
      break;
    d97b:	e9 e6 06 00 00       	jmp    e066 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d980:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d984:	74 3c                	je     d9c2 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d986:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d98d:	eb 26                	jmp    d9b5 <unfilterScanline+0xf2>
    d98f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d992:	8b 45 08             	mov    0x8(%ebp),%eax
    d995:	01 d0                	add    %edx,%eax
    d997:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d99a:	8b 55 0c             	mov    0xc(%ebp),%edx
    d99d:	01 ca                	add    %ecx,%edx
    d99f:	0f b6 0a             	movzbl (%edx),%ecx
    d9a2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d9a5:	8b 55 10             	mov    0x10(%ebp),%edx
    d9a8:	01 da                	add    %ebx,%edx
    d9aa:	0f b6 12             	movzbl (%edx),%edx
    d9ad:	01 ca                	add    %ecx,%edx
    d9af:	88 10                	mov    %dl,(%eax)
    d9b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d9b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9b8:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d9bb:	75 d2                	jne    d98f <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d9bd:	e9 a4 06 00 00       	jmp    e066 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d9c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d9c9:	eb 19                	jmp    d9e4 <unfilterScanline+0x121>
    d9cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d9ce:	8b 45 08             	mov    0x8(%ebp),%eax
    d9d1:	01 c2                	add    %eax,%edx
    d9d3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d9d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9d9:	01 c8                	add    %ecx,%eax
    d9db:	0f b6 00             	movzbl (%eax),%eax
    d9de:	88 02                	mov    %al,(%edx)
    d9e0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d9e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9e7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d9ea:	75 df                	jne    d9cb <unfilterScanline+0x108>
      }
      break;
    d9ec:	e9 75 06 00 00       	jmp    e066 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d9f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d9f5:	0f 84 8e 00 00 00    	je     da89 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d9fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    da02:	eb 28                	jmp    da2c <unfilterScanline+0x169>
    da04:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da07:	8b 45 08             	mov    0x8(%ebp),%eax
    da0a:	01 d0                	add    %edx,%eax
    da0c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    da0f:	8b 55 0c             	mov    0xc(%ebp),%edx
    da12:	01 ca                	add    %ecx,%edx
    da14:	0f b6 12             	movzbl (%edx),%edx
    da17:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    da1a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    da1d:	01 d9                	add    %ebx,%ecx
    da1f:	0f b6 09             	movzbl (%ecx),%ecx
    da22:	d0 e9                	shr    %cl
    da24:	01 ca                	add    %ecx,%edx
    da26:	88 10                	mov    %dl,(%eax)
    da28:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da2f:	3b 45 14             	cmp    0x14(%ebp),%eax
    da32:	75 d0                	jne    da04 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    da34:	8b 45 14             	mov    0x14(%ebp),%eax
    da37:	89 45 f4             	mov    %eax,-0xc(%ebp)
    da3a:	eb 40                	jmp    da7c <unfilterScanline+0x1b9>
    da3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da3f:	8b 45 08             	mov    0x8(%ebp),%eax
    da42:	01 c2                	add    %eax,%edx
    da44:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    da47:	8b 45 0c             	mov    0xc(%ebp),%eax
    da4a:	01 c8                	add    %ecx,%eax
    da4c:	0f b6 08             	movzbl (%eax),%ecx
    da4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da52:	2b 45 14             	sub    0x14(%ebp),%eax
    da55:	89 c3                	mov    %eax,%ebx
    da57:	8b 45 08             	mov    0x8(%ebp),%eax
    da5a:	01 d8                	add    %ebx,%eax
    da5c:	0f b6 00             	movzbl (%eax),%eax
    da5f:	0f b6 d8             	movzbl %al,%ebx
    da62:	8b 75 f4             	mov    -0xc(%ebp),%esi
    da65:	8b 45 10             	mov    0x10(%ebp),%eax
    da68:	01 f0                	add    %esi,%eax
    da6a:	0f b6 00             	movzbl (%eax),%eax
    da6d:	0f b6 c0             	movzbl %al,%eax
    da70:	01 d8                	add    %ebx,%eax
    da72:	d1 f8                	sar    %eax
    da74:	01 c8                	add    %ecx,%eax
    da76:	88 02                	mov    %al,(%edx)
    da78:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da7f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    da82:	7c b8                	jl     da3c <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    da84:	e9 dd 05 00 00       	jmp    e066 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    da89:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    da90:	eb 19                	jmp    daab <unfilterScanline+0x1e8>
    da92:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da95:	8b 45 08             	mov    0x8(%ebp),%eax
    da98:	01 c2                	add    %eax,%edx
    da9a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    da9d:	8b 45 0c             	mov    0xc(%ebp),%eax
    daa0:	01 c8                	add    %ecx,%eax
    daa2:	0f b6 00             	movzbl (%eax),%eax
    daa5:	88 02                	mov    %al,(%edx)
    daa7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    daab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daae:	3b 45 14             	cmp    0x14(%ebp),%eax
    dab1:	75 df                	jne    da92 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    dab3:	8b 45 14             	mov    0x14(%ebp),%eax
    dab6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dab9:	eb 2d                	jmp    dae8 <unfilterScanline+0x225>
    dabb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dabe:	8b 45 08             	mov    0x8(%ebp),%eax
    dac1:	01 c2                	add    %eax,%edx
    dac3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dac6:	8b 45 0c             	mov    0xc(%ebp),%eax
    dac9:	01 c8                	add    %ecx,%eax
    dacb:	0f b6 08             	movzbl (%eax),%ecx
    dace:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dad1:	2b 45 14             	sub    0x14(%ebp),%eax
    dad4:	89 c3                	mov    %eax,%ebx
    dad6:	8b 45 08             	mov    0x8(%ebp),%eax
    dad9:	01 d8                	add    %ebx,%eax
    dadb:	0f b6 00             	movzbl (%eax),%eax
    dade:	d0 e8                	shr    %al
    dae0:	01 c8                	add    %ecx,%eax
    dae2:	88 02                	mov    %al,(%edx)
    dae4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dae8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daeb:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    daee:	7c cb                	jl     dabb <unfilterScanline+0x1f8>
      }
      break;
    daf0:	e9 71 05 00 00       	jmp    e066 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    daf5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    daf9:	0f 84 f9 04 00 00    	je     dff8 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    daff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    db06:	eb 26                	jmp    db2e <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    db08:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db0b:	8b 45 08             	mov    0x8(%ebp),%eax
    db0e:	01 d0                	add    %edx,%eax
    db10:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    db13:	8b 55 0c             	mov    0xc(%ebp),%edx
    db16:	01 ca                	add    %ecx,%edx
    db18:	0f b6 0a             	movzbl (%edx),%ecx
    db1b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    db1e:	8b 55 10             	mov    0x10(%ebp),%edx
    db21:	01 da                	add    %ebx,%edx
    db23:	0f b6 12             	movzbl (%edx),%edx
    db26:	01 ca                	add    %ecx,%edx
    db28:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    db2a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    db2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db31:	3b 45 14             	cmp    0x14(%ebp),%eax
    db34:	75 d2                	jne    db08 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    db36:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    db3a:	0f 8e db 01 00 00    	jle    dd1b <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    db40:	e9 c2 01 00 00       	jmp    dd07 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    db45:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db48:	2b 45 14             	sub    0x14(%ebp),%eax
    db4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    db4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db51:	8b 45 0c             	mov    0xc(%ebp),%eax
    db54:	01 d0                	add    %edx,%eax
    db56:	0f b6 00             	movzbl (%eax),%eax
    db59:	88 45 ef             	mov    %al,-0x11(%ebp)
    db5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db5f:	8d 50 01             	lea    0x1(%eax),%edx
    db62:	8b 45 0c             	mov    0xc(%ebp),%eax
    db65:	01 d0                	add    %edx,%eax
    db67:	0f b6 00             	movzbl (%eax),%eax
    db6a:	88 45 ee             	mov    %al,-0x12(%ebp)
    db6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db70:	8d 50 02             	lea    0x2(%eax),%edx
    db73:	8b 45 0c             	mov    0xc(%ebp),%eax
    db76:	01 d0                	add    %edx,%eax
    db78:	0f b6 00             	movzbl (%eax),%eax
    db7b:	88 45 ed             	mov    %al,-0x13(%ebp)
    db7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db81:	8d 50 03             	lea    0x3(%eax),%edx
    db84:	8b 45 0c             	mov    0xc(%ebp),%eax
    db87:	01 d0                	add    %edx,%eax
    db89:	0f b6 00             	movzbl (%eax),%eax
    db8c:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    db8f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    db92:	8b 45 08             	mov    0x8(%ebp),%eax
    db95:	01 d0                	add    %edx,%eax
    db97:	0f b6 00             	movzbl (%eax),%eax
    db9a:	88 45 eb             	mov    %al,-0x15(%ebp)
    db9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dba0:	8d 50 01             	lea    0x1(%eax),%edx
    dba3:	8b 45 08             	mov    0x8(%ebp),%eax
    dba6:	01 d0                	add    %edx,%eax
    dba8:	0f b6 00             	movzbl (%eax),%eax
    dbab:	88 45 ea             	mov    %al,-0x16(%ebp)
    dbae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dbb1:	8d 50 02             	lea    0x2(%eax),%edx
    dbb4:	8b 45 08             	mov    0x8(%ebp),%eax
    dbb7:	01 d0                	add    %edx,%eax
    dbb9:	0f b6 00             	movzbl (%eax),%eax
    dbbc:	88 45 e9             	mov    %al,-0x17(%ebp)
    dbbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dbc2:	8d 50 03             	lea    0x3(%eax),%edx
    dbc5:	8b 45 08             	mov    0x8(%ebp),%eax
    dbc8:	01 d0                	add    %edx,%eax
    dbca:	0f b6 00             	movzbl (%eax),%eax
    dbcd:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    dbd0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbd3:	8b 45 10             	mov    0x10(%ebp),%eax
    dbd6:	01 d0                	add    %edx,%eax
    dbd8:	0f b6 00             	movzbl (%eax),%eax
    dbdb:	88 45 e7             	mov    %al,-0x19(%ebp)
    dbde:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbe1:	8d 50 01             	lea    0x1(%eax),%edx
    dbe4:	8b 45 10             	mov    0x10(%ebp),%eax
    dbe7:	01 d0                	add    %edx,%eax
    dbe9:	0f b6 00             	movzbl (%eax),%eax
    dbec:	88 45 e6             	mov    %al,-0x1a(%ebp)
    dbef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbf2:	8d 50 02             	lea    0x2(%eax),%edx
    dbf5:	8b 45 10             	mov    0x10(%ebp),%eax
    dbf8:	01 d0                	add    %edx,%eax
    dbfa:	0f b6 00             	movzbl (%eax),%eax
    dbfd:	88 45 e5             	mov    %al,-0x1b(%ebp)
    dc00:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc03:	8d 50 03             	lea    0x3(%eax),%edx
    dc06:	8b 45 10             	mov    0x10(%ebp),%eax
    dc09:	01 d0                	add    %edx,%eax
    dc0b:	0f b6 00             	movzbl (%eax),%eax
    dc0e:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    dc11:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dc14:	8b 45 10             	mov    0x10(%ebp),%eax
    dc17:	01 d0                	add    %edx,%eax
    dc19:	0f b6 00             	movzbl (%eax),%eax
    dc1c:	88 45 e3             	mov    %al,-0x1d(%ebp)
    dc1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc22:	8d 50 01             	lea    0x1(%eax),%edx
    dc25:	8b 45 10             	mov    0x10(%ebp),%eax
    dc28:	01 d0                	add    %edx,%eax
    dc2a:	0f b6 00             	movzbl (%eax),%eax
    dc2d:	88 45 e2             	mov    %al,-0x1e(%ebp)
    dc30:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc33:	8d 50 02             	lea    0x2(%eax),%edx
    dc36:	8b 45 10             	mov    0x10(%ebp),%eax
    dc39:	01 d0                	add    %edx,%eax
    dc3b:	0f b6 00             	movzbl (%eax),%eax
    dc3e:	88 45 e1             	mov    %al,-0x1f(%ebp)
    dc41:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc44:	8d 50 03             	lea    0x3(%eax),%edx
    dc47:	8b 45 10             	mov    0x10(%ebp),%eax
    dc4a:	01 d0                	add    %edx,%eax
    dc4c:	0f b6 00             	movzbl (%eax),%eax
    dc4f:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dc52:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc55:	8b 45 08             	mov    0x8(%ebp),%eax
    dc58:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc5b:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    dc5f:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    dc63:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    dc67:	51                   	push   %ecx
    dc68:	52                   	push   %edx
    dc69:	50                   	push   %eax
    dc6a:	e8 3f f6 ff ff       	call   d2ae <paethPredictor>
    dc6f:	83 c4 0c             	add    $0xc,%esp
    dc72:	89 c2                	mov    %eax,%edx
    dc74:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    dc78:	01 d0                	add    %edx,%eax
    dc7a:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc7f:	8d 50 01             	lea    0x1(%eax),%edx
    dc82:	8b 45 08             	mov    0x8(%ebp),%eax
    dc85:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc88:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    dc8c:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    dc90:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    dc94:	51                   	push   %ecx
    dc95:	52                   	push   %edx
    dc96:	50                   	push   %eax
    dc97:	e8 12 f6 ff ff       	call   d2ae <paethPredictor>
    dc9c:	83 c4 0c             	add    $0xc,%esp
    dc9f:	89 c2                	mov    %eax,%edx
    dca1:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    dca5:	01 d0                	add    %edx,%eax
    dca7:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    dca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcac:	8d 50 02             	lea    0x2(%eax),%edx
    dcaf:	8b 45 08             	mov    0x8(%ebp),%eax
    dcb2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dcb5:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    dcb9:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    dcbd:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    dcc1:	51                   	push   %ecx
    dcc2:	52                   	push   %edx
    dcc3:	50                   	push   %eax
    dcc4:	e8 e5 f5 ff ff       	call   d2ae <paethPredictor>
    dcc9:	83 c4 0c             	add    $0xc,%esp
    dccc:	89 c2                	mov    %eax,%edx
    dcce:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    dcd2:	01 d0                	add    %edx,%eax
    dcd4:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    dcd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcd9:	8d 50 03             	lea    0x3(%eax),%edx
    dcdc:	8b 45 08             	mov    0x8(%ebp),%eax
    dcdf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dce2:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    dce6:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    dcea:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    dcee:	51                   	push   %ecx
    dcef:	52                   	push   %edx
    dcf0:	50                   	push   %eax
    dcf1:	e8 b8 f5 ff ff       	call   d2ae <paethPredictor>
    dcf6:	83 c4 0c             	add    $0xc,%esp
    dcf9:	89 c2                	mov    %eax,%edx
    dcfb:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    dcff:	01 d0                	add    %edx,%eax
    dd01:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    dd03:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    dd07:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd0a:	83 c0 03             	add    $0x3,%eax
    dd0d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd10:	0f 8c 2f fe ff ff    	jl     db45 <unfilterScanline+0x282>
    dd16:	e9 d3 02 00 00       	jmp    dfee <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    dd1b:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    dd1f:	0f 8e 6a 01 00 00    	jle    de8f <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    dd25:	e9 51 01 00 00       	jmp    de7b <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    dd2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd2d:	2b 45 14             	sub    0x14(%ebp),%eax
    dd30:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    dd33:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd36:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd39:	01 d0                	add    %edx,%eax
    dd3b:	0f b6 00             	movzbl (%eax),%eax
    dd3e:	88 45 db             	mov    %al,-0x25(%ebp)
    dd41:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd44:	8d 50 01             	lea    0x1(%eax),%edx
    dd47:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd4a:	01 d0                	add    %edx,%eax
    dd4c:	0f b6 00             	movzbl (%eax),%eax
    dd4f:	88 45 da             	mov    %al,-0x26(%ebp)
    dd52:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd55:	8d 50 02             	lea    0x2(%eax),%edx
    dd58:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd5b:	01 d0                	add    %edx,%eax
    dd5d:	0f b6 00             	movzbl (%eax),%eax
    dd60:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    dd63:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dd66:	8b 45 08             	mov    0x8(%ebp),%eax
    dd69:	01 d0                	add    %edx,%eax
    dd6b:	0f b6 00             	movzbl (%eax),%eax
    dd6e:	88 45 d8             	mov    %al,-0x28(%ebp)
    dd71:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dd74:	8d 50 01             	lea    0x1(%eax),%edx
    dd77:	8b 45 08             	mov    0x8(%ebp),%eax
    dd7a:	01 d0                	add    %edx,%eax
    dd7c:	0f b6 00             	movzbl (%eax),%eax
    dd7f:	88 45 d7             	mov    %al,-0x29(%ebp)
    dd82:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dd85:	8d 50 02             	lea    0x2(%eax),%edx
    dd88:	8b 45 08             	mov    0x8(%ebp),%eax
    dd8b:	01 d0                	add    %edx,%eax
    dd8d:	0f b6 00             	movzbl (%eax),%eax
    dd90:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    dd93:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd96:	8b 45 10             	mov    0x10(%ebp),%eax
    dd99:	01 d0                	add    %edx,%eax
    dd9b:	0f b6 00             	movzbl (%eax),%eax
    dd9e:	88 45 d5             	mov    %al,-0x2b(%ebp)
    dda1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dda4:	8d 50 01             	lea    0x1(%eax),%edx
    dda7:	8b 45 10             	mov    0x10(%ebp),%eax
    ddaa:	01 d0                	add    %edx,%eax
    ddac:	0f b6 00             	movzbl (%eax),%eax
    ddaf:	88 45 d4             	mov    %al,-0x2c(%ebp)
    ddb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddb5:	8d 50 02             	lea    0x2(%eax),%edx
    ddb8:	8b 45 10             	mov    0x10(%ebp),%eax
    ddbb:	01 d0                	add    %edx,%eax
    ddbd:	0f b6 00             	movzbl (%eax),%eax
    ddc0:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    ddc3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    ddc6:	8b 45 10             	mov    0x10(%ebp),%eax
    ddc9:	01 d0                	add    %edx,%eax
    ddcb:	0f b6 00             	movzbl (%eax),%eax
    ddce:	88 45 d2             	mov    %al,-0x2e(%ebp)
    ddd1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ddd4:	8d 50 01             	lea    0x1(%eax),%edx
    ddd7:	8b 45 10             	mov    0x10(%ebp),%eax
    ddda:	01 d0                	add    %edx,%eax
    dddc:	0f b6 00             	movzbl (%eax),%eax
    dddf:	88 45 d1             	mov    %al,-0x2f(%ebp)
    dde2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dde5:	8d 50 02             	lea    0x2(%eax),%edx
    dde8:	8b 45 10             	mov    0x10(%ebp),%eax
    ddeb:	01 d0                	add    %edx,%eax
    dded:	0f b6 00             	movzbl (%eax),%eax
    ddf0:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    ddf3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ddf6:	8b 45 08             	mov    0x8(%ebp),%eax
    ddf9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ddfc:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    de00:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    de04:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    de08:	51                   	push   %ecx
    de09:	52                   	push   %edx
    de0a:	50                   	push   %eax
    de0b:	e8 9e f4 ff ff       	call   d2ae <paethPredictor>
    de10:	83 c4 0c             	add    $0xc,%esp
    de13:	89 c2                	mov    %eax,%edx
    de15:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    de19:	01 d0                	add    %edx,%eax
    de1b:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    de1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de20:	8d 50 01             	lea    0x1(%eax),%edx
    de23:	8b 45 08             	mov    0x8(%ebp),%eax
    de26:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    de29:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    de2d:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    de31:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    de35:	51                   	push   %ecx
    de36:	52                   	push   %edx
    de37:	50                   	push   %eax
    de38:	e8 71 f4 ff ff       	call   d2ae <paethPredictor>
    de3d:	83 c4 0c             	add    $0xc,%esp
    de40:	89 c2                	mov    %eax,%edx
    de42:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    de46:	01 d0                	add    %edx,%eax
    de48:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    de4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de4d:	8d 50 02             	lea    0x2(%eax),%edx
    de50:	8b 45 08             	mov    0x8(%ebp),%eax
    de53:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    de56:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    de5a:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    de5e:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    de62:	51                   	push   %ecx
    de63:	52                   	push   %edx
    de64:	50                   	push   %eax
    de65:	e8 44 f4 ff ff       	call   d2ae <paethPredictor>
    de6a:	83 c4 0c             	add    $0xc,%esp
    de6d:	89 c2                	mov    %eax,%edx
    de6f:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    de73:	01 d0                	add    %edx,%eax
    de75:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    de77:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    de7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de7e:	83 c0 02             	add    $0x2,%eax
    de81:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de84:	0f 8c a0 fe ff ff    	jl     dd2a <unfilterScanline+0x467>
    de8a:	e9 5f 01 00 00       	jmp    dfee <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    de8f:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    de93:	0f 8e 55 01 00 00    	jle    dfee <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    de99:	e9 e0 00 00 00       	jmp    df7e <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    de9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dea1:	2b 45 14             	sub    0x14(%ebp),%eax
    dea4:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dea7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    deaa:	8b 45 0c             	mov    0xc(%ebp),%eax
    dead:	01 d0                	add    %edx,%eax
    deaf:	0f b6 00             	movzbl (%eax),%eax
    deb2:	88 45 cb             	mov    %al,-0x35(%ebp)
    deb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    deb8:	8d 50 01             	lea    0x1(%eax),%edx
    debb:	8b 45 0c             	mov    0xc(%ebp),%eax
    debe:	01 d0                	add    %edx,%eax
    dec0:	0f b6 00             	movzbl (%eax),%eax
    dec3:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dec6:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dec9:	8b 45 08             	mov    0x8(%ebp),%eax
    decc:	01 d0                	add    %edx,%eax
    dece:	0f b6 00             	movzbl (%eax),%eax
    ded1:	88 45 c9             	mov    %al,-0x37(%ebp)
    ded4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ded7:	8d 50 01             	lea    0x1(%eax),%edx
    deda:	8b 45 08             	mov    0x8(%ebp),%eax
    dedd:	01 d0                	add    %edx,%eax
    dedf:	0f b6 00             	movzbl (%eax),%eax
    dee2:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dee5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dee8:	8b 45 10             	mov    0x10(%ebp),%eax
    deeb:	01 d0                	add    %edx,%eax
    deed:	0f b6 00             	movzbl (%eax),%eax
    def0:	88 45 c7             	mov    %al,-0x39(%ebp)
    def3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    def6:	8d 50 01             	lea    0x1(%eax),%edx
    def9:	8b 45 10             	mov    0x10(%ebp),%eax
    defc:	01 d0                	add    %edx,%eax
    defe:	0f b6 00             	movzbl (%eax),%eax
    df01:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    df04:	8b 55 cc             	mov    -0x34(%ebp),%edx
    df07:	8b 45 10             	mov    0x10(%ebp),%eax
    df0a:	01 d0                	add    %edx,%eax
    df0c:	0f b6 00             	movzbl (%eax),%eax
    df0f:	88 45 c5             	mov    %al,-0x3b(%ebp)
    df12:	8b 45 cc             	mov    -0x34(%ebp),%eax
    df15:	8d 50 01             	lea    0x1(%eax),%edx
    df18:	8b 45 10             	mov    0x10(%ebp),%eax
    df1b:	01 d0                	add    %edx,%eax
    df1d:	0f b6 00             	movzbl (%eax),%eax
    df20:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    df23:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df26:	8b 45 08             	mov    0x8(%ebp),%eax
    df29:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df2c:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    df30:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    df34:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    df38:	51                   	push   %ecx
    df39:	52                   	push   %edx
    df3a:	50                   	push   %eax
    df3b:	e8 6e f3 ff ff       	call   d2ae <paethPredictor>
    df40:	83 c4 0c             	add    $0xc,%esp
    df43:	89 c2                	mov    %eax,%edx
    df45:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    df49:	01 d0                	add    %edx,%eax
    df4b:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    df4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df50:	8d 50 01             	lea    0x1(%eax),%edx
    df53:	8b 45 08             	mov    0x8(%ebp),%eax
    df56:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df59:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    df5d:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    df61:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    df65:	51                   	push   %ecx
    df66:	52                   	push   %edx
    df67:	50                   	push   %eax
    df68:	e8 41 f3 ff ff       	call   d2ae <paethPredictor>
    df6d:	83 c4 0c             	add    $0xc,%esp
    df70:	89 c2                	mov    %eax,%edx
    df72:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    df76:	01 d0                	add    %edx,%eax
    df78:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    df7a:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    df7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df81:	83 c0 01             	add    $0x1,%eax
    df84:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    df87:	0f 8c 11 ff ff ff    	jl     de9e <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    df8d:	eb 5f                	jmp    dfee <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    df8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df92:	8b 45 08             	mov    0x8(%ebp),%eax
    df95:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df98:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df9b:	8b 45 0c             	mov    0xc(%ebp),%eax
    df9e:	01 d0                	add    %edx,%eax
    dfa0:	0f b6 00             	movzbl (%eax),%eax
    dfa3:	88 45 b7             	mov    %al,-0x49(%ebp)
    dfa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfa9:	2b 45 14             	sub    0x14(%ebp),%eax
    dfac:	89 c2                	mov    %eax,%edx
    dfae:	8b 45 10             	mov    0x10(%ebp),%eax
    dfb1:	01 d0                	add    %edx,%eax
    dfb3:	0f b6 00             	movzbl (%eax),%eax
    dfb6:	0f b6 c8             	movzbl %al,%ecx
    dfb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dfbc:	8b 45 10             	mov    0x10(%ebp),%eax
    dfbf:	01 d0                	add    %edx,%eax
    dfc1:	0f b6 00             	movzbl (%eax),%eax
    dfc4:	0f b6 d0             	movzbl %al,%edx
    dfc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfca:	2b 45 14             	sub    0x14(%ebp),%eax
    dfcd:	89 c6                	mov    %eax,%esi
    dfcf:	8b 45 08             	mov    0x8(%ebp),%eax
    dfd2:	01 f0                	add    %esi,%eax
    dfd4:	0f b6 00             	movzbl (%eax),%eax
    dfd7:	0f b6 c0             	movzbl %al,%eax
    dfda:	51                   	push   %ecx
    dfdb:	52                   	push   %edx
    dfdc:	50                   	push   %eax
    dfdd:	e8 cc f2 ff ff       	call   d2ae <paethPredictor>
    dfe2:	83 c4 0c             	add    $0xc,%esp
    dfe5:	02 45 b7             	add    -0x49(%ebp),%al
    dfe8:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dfea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dfee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dff1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dff4:	75 99                	jne    df8f <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dff6:	eb 6e                	jmp    e066 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dff8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dfff:	eb 19                	jmp    e01a <unfilterScanline+0x757>
          recon[i] = scanline[i];
    e001:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e004:	8b 45 08             	mov    0x8(%ebp),%eax
    e007:	01 c2                	add    %eax,%edx
    e009:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e00c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e00f:	01 c8                	add    %ecx,%eax
    e011:	0f b6 00             	movzbl (%eax),%eax
    e014:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e016:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e01a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e01d:	3b 45 14             	cmp    0x14(%ebp),%eax
    e020:	75 df                	jne    e001 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e022:	8b 45 14             	mov    0x14(%ebp),%eax
    e025:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e028:	eb 2b                	jmp    e055 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    e02a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e02d:	8b 45 08             	mov    0x8(%ebp),%eax
    e030:	01 c2                	add    %eax,%edx
    e032:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e035:	8b 45 0c             	mov    0xc(%ebp),%eax
    e038:	01 c8                	add    %ecx,%eax
    e03a:	0f b6 08             	movzbl (%eax),%ecx
    e03d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e040:	2b 45 14             	sub    0x14(%ebp),%eax
    e043:	89 c3                	mov    %eax,%ebx
    e045:	8b 45 08             	mov    0x8(%ebp),%eax
    e048:	01 d8                	add    %ebx,%eax
    e04a:	0f b6 00             	movzbl (%eax),%eax
    e04d:	01 c8                	add    %ecx,%eax
    e04f:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e051:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e055:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e058:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e05b:	7c cd                	jl     e02a <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e05d:	eb 07                	jmp    e066 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    e05f:	b8 24 00 00 00       	mov    $0x24,%eax
    e064:	eb 05                	jmp    e06b <unfilterScanline+0x7a8>
  }
  return 0;
    e066:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e06b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e06e:	5b                   	pop    %ebx
    e06f:	5e                   	pop    %esi
    e070:	5d                   	pop    %ebp
    e071:	c3                   	ret    

0000e072 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e072:	55                   	push   %ebp
    e073:	89 e5                	mov    %esp,%ebp
    e075:	53                   	push   %ebx
    e076:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    e079:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    e080:	8b 45 18             	mov    0x18(%ebp),%eax
    e083:	83 c0 07             	add    $0x7,%eax
    e086:	c1 e8 03             	shr    $0x3,%eax
    e089:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    e08c:	ff 75 18             	pushl  0x18(%ebp)
    e08f:	6a 01                	push   $0x1
    e091:	ff 75 10             	pushl  0x10(%ebp)
    e094:	e8 d9 b1 ff ff       	call   9272 <lodepng_get_raw_size_idat>
    e099:	83 c4 0c             	add    $0xc,%esp
    e09c:	83 e8 01             	sub    $0x1,%eax
    e09f:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    e0a2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e0a9:	eb 6d                	jmp    e118 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    e0ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e0ae:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e0b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    e0b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e0b8:	83 c0 01             	add    $0x1,%eax
    e0bb:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e0bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    e0c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e0c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    e0c8:	01 d0                	add    %edx,%eax
    e0ca:	0f b6 00             	movzbl (%eax),%eax
    e0cd:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    e0d0:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    e0d4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e0d7:	8d 4a 01             	lea    0x1(%edx),%ecx
    e0da:	8b 55 0c             	mov    0xc(%ebp),%edx
    e0dd:	01 d1                	add    %edx,%ecx
    e0df:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    e0e2:	8b 55 08             	mov    0x8(%ebp),%edx
    e0e5:	01 da                	add    %ebx,%edx
    e0e7:	ff 75 ec             	pushl  -0x14(%ebp)
    e0ea:	50                   	push   %eax
    e0eb:	ff 75 f0             	pushl  -0x10(%ebp)
    e0ee:	ff 75 f4             	pushl  -0xc(%ebp)
    e0f1:	51                   	push   %ecx
    e0f2:	52                   	push   %edx
    e0f3:	e8 cb f7 ff ff       	call   d8c3 <unfilterScanline>
    e0f8:	83 c4 18             	add    $0x18,%esp
    e0fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    e0fe:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    e102:	74 05                	je     e109 <unfilter+0x97>
    e104:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e107:	eb 1c                	jmp    e125 <unfilter+0xb3>

    prevline = &out[outindex];
    e109:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e10c:	8b 45 08             	mov    0x8(%ebp),%eax
    e10f:	01 d0                	add    %edx,%eax
    e111:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    e114:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e118:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e11b:	3b 45 14             	cmp    0x14(%ebp),%eax
    e11e:	72 8b                	jb     e0ab <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    e120:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e125:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e128:	c9                   	leave  
    e129:	c3                   	ret    

0000e12a <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e12a:	55                   	push   %ebp
    e12b:	89 e5                	mov    %esp,%ebp
    e12d:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e133:	ff 75 18             	pushl  0x18(%ebp)
    e136:	ff 75 14             	pushl  0x14(%ebp)
    e139:	ff 75 10             	pushl  0x10(%ebp)
    e13c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    e142:	50                   	push   %eax
    e143:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    e149:	50                   	push   %eax
    e14a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    e150:	50                   	push   %eax
    e151:	8d 45 94             	lea    -0x6c(%ebp),%eax
    e154:	50                   	push   %eax
    e155:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e158:	50                   	push   %eax
    e159:	e8 e6 f1 ff ff       	call   d344 <Adam7_getpassvalues>
    e15e:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    e161:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    e165:	0f 86 0a 01 00 00    	jbe    e275 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    e16b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e172:	e9 ef 00 00 00       	jmp    e266 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    e177:	8b 45 18             	mov    0x18(%ebp),%eax
    e17a:	c1 e8 03             	shr    $0x3,%eax
    e17d:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    e180:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e187:	e9 c6 00 00 00       	jmp    e252 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    e18c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e193:	e9 a6 00 00 00       	jmp    e23e <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    e198:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e19b:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e1a2:	89 c1                	mov    %eax,%ecx
    e1a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1a7:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e1ab:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e1af:	89 c2                	mov    %eax,%edx
    e1b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e1b4:	01 c2                	add    %eax,%edx
    e1b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e1b9:	0f af c2             	imul   %edx,%eax
    e1bc:	01 c8                	add    %ecx,%eax
    e1be:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e1c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1c4:	8b 14 85 f8 a2 01 00 	mov    0x1a2f8(,%eax,4),%edx
    e1cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1ce:	8b 04 85 30 a3 01 00 	mov    0x1a330(,%eax,4),%eax
    e1d5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e1d9:	01 d0                	add    %edx,%eax
    e1db:	0f af 45 10          	imul   0x10(%ebp),%eax
    e1df:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    e1e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1e4:	8b 04 85 14 a3 01 00 	mov    0x1a314(,%eax,4),%eax
    e1eb:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e1ef:	01 c2                	add    %eax,%edx
    e1f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1f4:	8b 04 85 dc a2 01 00 	mov    0x1a2dc(,%eax,4),%eax
    e1fb:	01 c2                	add    %eax,%edx
    e1fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e200:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e203:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e206:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e20d:	eb 23                	jmp    e232 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    e20f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e212:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e215:	01 c2                	add    %eax,%edx
    e217:	8b 45 08             	mov    0x8(%ebp),%eax
    e21a:	01 c2                	add    %eax,%edx
    e21c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e21f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e222:	01 c1                	add    %eax,%ecx
    e224:	8b 45 0c             	mov    0xc(%ebp),%eax
    e227:	01 c8                	add    %ecx,%eax
    e229:	0f b6 00             	movzbl (%eax),%eax
    e22c:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e22e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e232:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e235:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e238:	72 d5                	jb     e20f <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e23a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e23e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e241:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e245:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e248:	0f 87 4a ff ff ff    	ja     e198 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e24e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e252:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e255:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e259:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e25c:	0f 87 2a ff ff ff    	ja     e18c <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e262:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e266:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e26a:	0f 85 07 ff ff ff    	jne    e177 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e270:	e9 22 01 00 00       	jmp    e397 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e275:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e27c:	e9 0c 01 00 00       	jmp    e38d <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e281:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e284:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e288:	0f af 45 18          	imul   0x18(%ebp),%eax
    e28c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e28f:	8b 45 18             	mov    0x18(%ebp),%eax
    e292:	0f af 45 10          	imul   0x10(%ebp),%eax
    e296:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e299:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e2a0:	e9 d4 00 00 00       	jmp    e379 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e2a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e2ac:	e9 b4 00 00 00       	jmp    e365 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e2b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2b4:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e2bb:	c1 e0 03             	shl    $0x3,%eax
    e2be:	89 c1                	mov    %eax,%ecx
    e2c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e2c3:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e2c7:	89 c2                	mov    %eax,%edx
    e2c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e2cc:	0f af 45 18          	imul   0x18(%ebp),%eax
    e2d0:	01 d0                	add    %edx,%eax
    e2d2:	01 c8                	add    %ecx,%eax
    e2d4:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e2da:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2dd:	8b 14 85 f8 a2 01 00 	mov    0x1a2f8(,%eax,4),%edx
    e2e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2e7:	8b 04 85 30 a3 01 00 	mov    0x1a330(,%eax,4),%eax
    e2ee:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e2f2:	01 d0                	add    %edx,%eax
    e2f4:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e2f8:	89 c2                	mov    %eax,%edx
    e2fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2fd:	8b 0c 85 dc a2 01 00 	mov    0x1a2dc(,%eax,4),%ecx
    e304:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e307:	8b 04 85 14 a3 01 00 	mov    0x1a314(,%eax,4),%eax
    e30e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e312:	01 c8                	add    %ecx,%eax
    e314:	0f af 45 18          	imul   0x18(%ebp),%eax
    e318:	01 d0                	add    %edx,%eax
    e31a:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e320:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e327:	eb 30                	jmp    e359 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e329:	ff 75 0c             	pushl  0xc(%ebp)
    e32c:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e332:	50                   	push   %eax
    e333:	e8 1e a1 ff ff       	call   8456 <readBitFromReversedStream>
    e338:	83 c4 08             	add    $0x8,%esp
    e33b:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e33e:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e342:	50                   	push   %eax
    e343:	ff 75 08             	pushl  0x8(%ebp)
    e346:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e34c:	50                   	push   %eax
    e34d:	e8 86 a1 ff ff       	call   84d8 <setBitOfReversedStream>
    e352:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e355:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e359:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e35c:	3b 45 18             	cmp    0x18(%ebp),%eax
    e35f:	72 c8                	jb     e329 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e361:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e365:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e368:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e36c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e36f:	0f 87 3c ff ff ff    	ja     e2b1 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e375:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e379:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e37c:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e380:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e383:	0f 87 1c ff ff ff    	ja     e2a5 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e389:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e38d:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e391:	0f 85 ea fe ff ff    	jne    e281 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e397:	90                   	nop
    e398:	c9                   	leave  
    e399:	c3                   	ret    

0000e39a <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e39a:	55                   	push   %ebp
    e39b:	89 e5                	mov    %esp,%ebp
    e39d:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e3a0:	8b 45 14             	mov    0x14(%ebp),%eax
    e3a3:	2b 45 10             	sub    0x10(%ebp),%eax
    e3a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e3a9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e3b0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e3b7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e3be:	eb 4a                	jmp    e40a <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e3c0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e3c7:	eb 2a                	jmp    e3f3 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e3c9:	ff 75 0c             	pushl  0xc(%ebp)
    e3cc:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e3cf:	50                   	push   %eax
    e3d0:	e8 81 a0 ff ff       	call   8456 <readBitFromReversedStream>
    e3d5:	83 c4 08             	add    $0x8,%esp
    e3d8:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e3db:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e3df:	50                   	push   %eax
    e3e0:	ff 75 08             	pushl  0x8(%ebp)
    e3e3:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e3e6:	50                   	push   %eax
    e3e7:	e8 ec a0 ff ff       	call   84d8 <setBitOfReversedStream>
    e3ec:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e3ef:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e3f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e3f6:	3b 45 10             	cmp    0x10(%ebp),%eax
    e3f9:	7c ce                	jl     e3c9 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e3fb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e3fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e401:	01 d0                	add    %edx,%eax
    e403:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e406:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e40a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e40d:	3b 45 18             	cmp    0x18(%ebp),%eax
    e410:	72 ae                	jb     e3c0 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e412:	90                   	nop
    e413:	c9                   	leave  
    e414:	c3                   	ret    

0000e415 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e415:	55                   	push   %ebp
    e416:	89 e5                	mov    %esp,%ebp
    e418:	57                   	push   %edi
    e419:	56                   	push   %esi
    e41a:	53                   	push   %ebx
    e41b:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e421:	8b 45 18             	mov    0x18(%ebp),%eax
    e424:	83 c0 0c             	add    $0xc,%eax
    e427:	50                   	push   %eax
    e428:	e8 e6 ac ff ff       	call   9113 <lodepng_get_bpp>
    e42d:	83 c4 04             	add    $0x4,%esp
    e430:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e433:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e437:	75 0a                	jne    e443 <postProcessScanlines+0x2e>
    e439:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e43e:	e9 c3 01 00 00       	jmp    e606 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e443:	8b 45 18             	mov    0x18(%ebp),%eax
    e446:	8b 40 08             	mov    0x8(%eax),%eax
    e449:	85 c0                	test   %eax,%eax
    e44b:	0f 85 a8 00 00 00    	jne    e4f9 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e451:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e455:	77 76                	ja     e4cd <postProcessScanlines+0xb8>
    e457:	8b 45 10             	mov    0x10(%ebp),%eax
    e45a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e45e:	89 c2                	mov    %eax,%edx
    e460:	8b 45 10             	mov    0x10(%ebp),%eax
    e463:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e467:	83 c0 07             	add    $0x7,%eax
    e46a:	c1 e8 03             	shr    $0x3,%eax
    e46d:	c1 e0 03             	shl    $0x3,%eax
    e470:	39 c2                	cmp    %eax,%edx
    e472:	74 59                	je     e4cd <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e474:	ff 75 ec             	pushl  -0x14(%ebp)
    e477:	ff 75 14             	pushl  0x14(%ebp)
    e47a:	ff 75 10             	pushl  0x10(%ebp)
    e47d:	ff 75 0c             	pushl  0xc(%ebp)
    e480:	ff 75 0c             	pushl  0xc(%ebp)
    e483:	e8 ea fb ff ff       	call   e072 <unfilter>
    e488:	83 c4 14             	add    $0x14,%esp
    e48b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e48e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e492:	74 08                	je     e49c <postProcessScanlines+0x87>
    e494:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e497:	e9 6a 01 00 00       	jmp    e606 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e49c:	8b 45 10             	mov    0x10(%ebp),%eax
    e49f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e4a3:	83 c0 07             	add    $0x7,%eax
    e4a6:	c1 e8 03             	shr    $0x3,%eax
    e4a9:	c1 e0 03             	shl    $0x3,%eax
    e4ac:	89 c2                	mov    %eax,%edx
    e4ae:	8b 45 10             	mov    0x10(%ebp),%eax
    e4b1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e4b5:	ff 75 14             	pushl  0x14(%ebp)
    e4b8:	52                   	push   %edx
    e4b9:	50                   	push   %eax
    e4ba:	ff 75 0c             	pushl  0xc(%ebp)
    e4bd:	ff 75 08             	pushl  0x8(%ebp)
    e4c0:	e8 d5 fe ff ff       	call   e39a <removePaddingBits>
    e4c5:	83 c4 14             	add    $0x14,%esp
    e4c8:	e9 34 01 00 00       	jmp    e601 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e4cd:	ff 75 ec             	pushl  -0x14(%ebp)
    e4d0:	ff 75 14             	pushl  0x14(%ebp)
    e4d3:	ff 75 10             	pushl  0x10(%ebp)
    e4d6:	ff 75 0c             	pushl  0xc(%ebp)
    e4d9:	ff 75 08             	pushl  0x8(%ebp)
    e4dc:	e8 91 fb ff ff       	call   e072 <unfilter>
    e4e1:	83 c4 14             	add    $0x14,%esp
    e4e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e4e7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e4eb:	0f 84 10 01 00 00    	je     e601 <postProcessScanlines+0x1ec>
    e4f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e4f4:	e9 0d 01 00 00       	jmp    e606 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e4f9:	ff 75 ec             	pushl  -0x14(%ebp)
    e4fc:	ff 75 14             	pushl  0x14(%ebp)
    e4ff:	ff 75 10             	pushl  0x10(%ebp)
    e502:	8d 45 88             	lea    -0x78(%ebp),%eax
    e505:	50                   	push   %eax
    e506:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e50c:	50                   	push   %eax
    e50d:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e513:	50                   	push   %eax
    e514:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e517:	50                   	push   %eax
    e518:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e51b:	50                   	push   %eax
    e51c:	e8 23 ee ff ff       	call   d344 <Adam7_getpassvalues>
    e521:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e524:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e52b:	e9 b0 00 00 00       	jmp    e5e0 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e530:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e533:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e537:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e53a:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e53e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e541:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e548:	89 cb                	mov    %ecx,%ebx
    e54a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e54d:	01 cb                	add    %ecx,%ebx
    e54f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e552:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e559:	89 ce                	mov    %ecx,%esi
    e55b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e55e:	01 f1                	add    %esi,%ecx
    e560:	ff 75 ec             	pushl  -0x14(%ebp)
    e563:	52                   	push   %edx
    e564:	50                   	push   %eax
    e565:	53                   	push   %ebx
    e566:	51                   	push   %ecx
    e567:	e8 06 fb ff ff       	call   e072 <unfilter>
    e56c:	83 c4 14             	add    $0x14,%esp
    e56f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e572:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e576:	74 08                	je     e580 <postProcessScanlines+0x16b>
    e578:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e57b:	e9 86 00 00 00       	jmp    e606 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e580:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e584:	77 56                	ja     e5dc <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e586:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e589:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e58d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e590:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e594:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e598:	83 c2 07             	add    $0x7,%edx
    e59b:	c1 ea 03             	shr    $0x3,%edx
    e59e:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e5a1:	89 d6                	mov    %edx,%esi
    e5a3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e5a6:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e5aa:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e5ae:	89 d3                	mov    %edx,%ebx
    e5b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e5b3:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e5ba:	89 d1                	mov    %edx,%ecx
    e5bc:	8b 55 0c             	mov    0xc(%ebp),%edx
    e5bf:	01 d1                	add    %edx,%ecx
    e5c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e5c4:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e5c8:	89 d7                	mov    %edx,%edi
    e5ca:	8b 55 0c             	mov    0xc(%ebp),%edx
    e5cd:	01 fa                	add    %edi,%edx
    e5cf:	50                   	push   %eax
    e5d0:	56                   	push   %esi
    e5d1:	53                   	push   %ebx
    e5d2:	51                   	push   %ecx
    e5d3:	52                   	push   %edx
    e5d4:	e8 c1 fd ff ff       	call   e39a <removePaddingBits>
    e5d9:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e5dc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e5e0:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e5e4:	0f 85 46 ff ff ff    	jne    e530 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e5ea:	ff 75 ec             	pushl  -0x14(%ebp)
    e5ed:	ff 75 14             	pushl  0x14(%ebp)
    e5f0:	ff 75 10             	pushl  0x10(%ebp)
    e5f3:	ff 75 0c             	pushl  0xc(%ebp)
    e5f6:	ff 75 08             	pushl  0x8(%ebp)
    e5f9:	e8 2c fb ff ff       	call   e12a <Adam7_deinterlace>
    e5fe:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e601:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e606:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e609:	5b                   	pop    %ebx
    e60a:	5e                   	pop    %esi
    e60b:	5f                   	pop    %edi
    e60c:	5d                   	pop    %ebp
    e60d:	c3                   	ret    

0000e60e <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e60e:	55                   	push   %ebp
    e60f:	89 e5                	mov    %esp,%ebp
    e611:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e614:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e61b:	8b 45 10             	mov    0x10(%ebp),%eax
    e61e:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e623:	f7 e2                	mul    %edx
    e625:	89 d0                	mov    %edx,%eax
    e627:	d1 e8                	shr    %eax
    e629:	89 c2                	mov    %eax,%edx
    e62b:	8b 45 08             	mov    0x8(%ebp),%eax
    e62e:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e631:	8b 45 08             	mov    0x8(%ebp),%eax
    e634:	8b 40 0c             	mov    0xc(%eax),%eax
    e637:	85 c0                	test   %eax,%eax
    e639:	74 0d                	je     e648 <readChunk_PLTE+0x3a>
    e63b:	8b 45 08             	mov    0x8(%ebp),%eax
    e63e:	8b 40 0c             	mov    0xc(%eax),%eax
    e641:	3d 00 01 00 00       	cmp    $0x100,%eax
    e646:	7e 0a                	jle    e652 <readChunk_PLTE+0x44>
    e648:	b8 26 00 00 00       	mov    $0x26,%eax
    e64d:	e9 da 00 00 00       	jmp    e72c <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e652:	83 ec 0c             	sub    $0xc,%esp
    e655:	ff 75 08             	pushl  0x8(%ebp)
    e658:	e8 02 a7 ff ff       	call   8d5f <lodepng_color_mode_alloc_palette>
    e65d:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e660:	8b 45 08             	mov    0x8(%ebp),%eax
    e663:	8b 40 08             	mov    0x8(%eax),%eax
    e666:	85 c0                	test   %eax,%eax
    e668:	75 1e                	jne    e688 <readChunk_PLTE+0x7a>
    e66a:	8b 45 08             	mov    0x8(%ebp),%eax
    e66d:	8b 40 0c             	mov    0xc(%eax),%eax
    e670:	85 c0                	test   %eax,%eax
    e672:	74 14                	je     e688 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e674:	8b 45 08             	mov    0x8(%ebp),%eax
    e677:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e67e:	b8 53 00 00 00       	mov    $0x53,%eax
    e683:	e9 a4 00 00 00       	jmp    e72c <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e688:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e68f:	e9 84 00 00 00       	jmp    e718 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e694:	8b 45 08             	mov    0x8(%ebp),%eax
    e697:	8b 40 08             	mov    0x8(%eax),%eax
    e69a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e69d:	c1 e2 02             	shl    $0x2,%edx
    e6a0:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e6a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e6a6:	8d 50 01             	lea    0x1(%eax),%edx
    e6a9:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e6ac:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6af:	01 d0                	add    %edx,%eax
    e6b1:	0f b6 00             	movzbl (%eax),%eax
    e6b4:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e6b6:	8b 45 08             	mov    0x8(%ebp),%eax
    e6b9:	8b 40 08             	mov    0x8(%eax),%eax
    e6bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e6bf:	c1 e2 02             	shl    $0x2,%edx
    e6c2:	83 c2 01             	add    $0x1,%edx
    e6c5:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e6c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e6cb:	8d 50 01             	lea    0x1(%eax),%edx
    e6ce:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e6d1:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6d4:	01 d0                	add    %edx,%eax
    e6d6:	0f b6 00             	movzbl (%eax),%eax
    e6d9:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e6db:	8b 45 08             	mov    0x8(%ebp),%eax
    e6de:	8b 40 08             	mov    0x8(%eax),%eax
    e6e1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e6e4:	c1 e2 02             	shl    $0x2,%edx
    e6e7:	83 c2 02             	add    $0x2,%edx
    e6ea:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e6ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e6f0:	8d 50 01             	lea    0x1(%eax),%edx
    e6f3:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e6f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6f9:	01 d0                	add    %edx,%eax
    e6fb:	0f b6 00             	movzbl (%eax),%eax
    e6fe:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e700:	8b 45 08             	mov    0x8(%ebp),%eax
    e703:	8b 40 08             	mov    0x8(%eax),%eax
    e706:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e709:	c1 e2 02             	shl    $0x2,%edx
    e70c:	83 c2 03             	add    $0x3,%edx
    e70f:	01 d0                	add    %edx,%eax
    e711:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e714:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e718:	8b 45 08             	mov    0x8(%ebp),%eax
    e71b:	8b 40 0c             	mov    0xc(%eax),%eax
    e71e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e721:	0f 85 6d ff ff ff    	jne    e694 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e727:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e72c:	c9                   	leave  
    e72d:	c3                   	ret    

0000e72e <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e72e:	55                   	push   %ebp
    e72f:	89 e5                	mov    %esp,%ebp
    e731:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e734:	8b 45 08             	mov    0x8(%ebp),%eax
    e737:	8b 00                	mov    (%eax),%eax
    e739:	83 f8 03             	cmp    $0x3,%eax
    e73c:	75 4d                	jne    e78b <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e73e:	8b 45 08             	mov    0x8(%ebp),%eax
    e741:	8b 40 0c             	mov    0xc(%eax),%eax
    e744:	3b 45 10             	cmp    0x10(%ebp),%eax
    e747:	7d 0a                	jge    e753 <readChunk_tRNS+0x25>
    e749:	b8 27 00 00 00       	mov    $0x27,%eax
    e74e:	e9 3c 01 00 00       	jmp    e88f <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e753:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e75a:	eb 22                	jmp    e77e <readChunk_tRNS+0x50>
    e75c:	8b 45 08             	mov    0x8(%ebp),%eax
    e75f:	8b 40 08             	mov    0x8(%eax),%eax
    e762:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e765:	c1 e2 02             	shl    $0x2,%edx
    e768:	83 c2 03             	add    $0x3,%edx
    e76b:	01 c2                	add    %eax,%edx
    e76d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e770:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e773:	01 c8                	add    %ecx,%eax
    e775:	0f b6 00             	movzbl (%eax),%eax
    e778:	88 02                	mov    %al,(%edx)
    e77a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e77e:	8b 45 10             	mov    0x10(%ebp),%eax
    e781:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e784:	75 d6                	jne    e75c <readChunk_tRNS+0x2e>
    e786:	e9 ff 00 00 00       	jmp    e88a <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e78b:	8b 45 08             	mov    0x8(%ebp),%eax
    e78e:	8b 00                	mov    (%eax),%eax
    e790:	85 c0                	test   %eax,%eax
    e792:	75 59                	jne    e7ed <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e794:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e798:	74 0a                	je     e7a4 <readChunk_tRNS+0x76>
    e79a:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e79f:	e9 eb 00 00 00       	jmp    e88f <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e7a4:	8b 45 08             	mov    0x8(%ebp),%eax
    e7a7:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e7ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7b1:	0f b6 00             	movzbl (%eax),%eax
    e7b4:	0f b6 c0             	movzbl %al,%eax
    e7b7:	c1 e0 08             	shl    $0x8,%eax
    e7ba:	89 c2                	mov    %eax,%edx
    e7bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7bf:	83 c0 01             	add    $0x1,%eax
    e7c2:	0f b6 00             	movzbl (%eax),%eax
    e7c5:	0f b6 c0             	movzbl %al,%eax
    e7c8:	01 c2                	add    %eax,%edx
    e7ca:	8b 45 08             	mov    0x8(%ebp),%eax
    e7cd:	89 50 1c             	mov    %edx,0x1c(%eax)
    e7d0:	8b 45 08             	mov    0x8(%ebp),%eax
    e7d3:	8b 50 1c             	mov    0x1c(%eax),%edx
    e7d6:	8b 45 08             	mov    0x8(%ebp),%eax
    e7d9:	89 50 18             	mov    %edx,0x18(%eax)
    e7dc:	8b 45 08             	mov    0x8(%ebp),%eax
    e7df:	8b 50 18             	mov    0x18(%eax),%edx
    e7e2:	8b 45 08             	mov    0x8(%ebp),%eax
    e7e5:	89 50 14             	mov    %edx,0x14(%eax)
    e7e8:	e9 9d 00 00 00       	jmp    e88a <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e7ed:	8b 45 08             	mov    0x8(%ebp),%eax
    e7f0:	8b 00                	mov    (%eax),%eax
    e7f2:	83 f8 02             	cmp    $0x2,%eax
    e7f5:	0f 85 88 00 00 00    	jne    e883 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e7fb:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e7ff:	74 0a                	je     e80b <readChunk_tRNS+0xdd>
    e801:	b8 29 00 00 00       	mov    $0x29,%eax
    e806:	e9 84 00 00 00       	jmp    e88f <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e80b:	8b 45 08             	mov    0x8(%ebp),%eax
    e80e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e815:	8b 45 0c             	mov    0xc(%ebp),%eax
    e818:	0f b6 00             	movzbl (%eax),%eax
    e81b:	0f b6 c0             	movzbl %al,%eax
    e81e:	c1 e0 08             	shl    $0x8,%eax
    e821:	89 c2                	mov    %eax,%edx
    e823:	8b 45 0c             	mov    0xc(%ebp),%eax
    e826:	83 c0 01             	add    $0x1,%eax
    e829:	0f b6 00             	movzbl (%eax),%eax
    e82c:	0f b6 c0             	movzbl %al,%eax
    e82f:	01 c2                	add    %eax,%edx
    e831:	8b 45 08             	mov    0x8(%ebp),%eax
    e834:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e837:	8b 45 0c             	mov    0xc(%ebp),%eax
    e83a:	83 c0 02             	add    $0x2,%eax
    e83d:	0f b6 00             	movzbl (%eax),%eax
    e840:	0f b6 c0             	movzbl %al,%eax
    e843:	c1 e0 08             	shl    $0x8,%eax
    e846:	89 c2                	mov    %eax,%edx
    e848:	8b 45 0c             	mov    0xc(%ebp),%eax
    e84b:	83 c0 03             	add    $0x3,%eax
    e84e:	0f b6 00             	movzbl (%eax),%eax
    e851:	0f b6 c0             	movzbl %al,%eax
    e854:	01 c2                	add    %eax,%edx
    e856:	8b 45 08             	mov    0x8(%ebp),%eax
    e859:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e85c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e85f:	83 c0 04             	add    $0x4,%eax
    e862:	0f b6 00             	movzbl (%eax),%eax
    e865:	0f b6 c0             	movzbl %al,%eax
    e868:	c1 e0 08             	shl    $0x8,%eax
    e86b:	89 c2                	mov    %eax,%edx
    e86d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e870:	83 c0 05             	add    $0x5,%eax
    e873:	0f b6 00             	movzbl (%eax),%eax
    e876:	0f b6 c0             	movzbl %al,%eax
    e879:	01 c2                	add    %eax,%edx
    e87b:	8b 45 08             	mov    0x8(%ebp),%eax
    e87e:	89 50 1c             	mov    %edx,0x1c(%eax)
    e881:	eb 07                	jmp    e88a <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e883:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e888:	eb 05                	jmp    e88f <readChunk_tRNS+0x161>

  return 0; /* OK */
    e88a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e88f:	c9                   	leave  
    e890:	c3                   	ret    

0000e891 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e891:	55                   	push   %ebp
    e892:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e894:	8b 45 08             	mov    0x8(%ebp),%eax
    e897:	8b 40 0c             	mov    0xc(%eax),%eax
    e89a:	83 f8 03             	cmp    $0x3,%eax
    e89d:	75 63                	jne    e902 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e89f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e8a3:	74 0a                	je     e8af <readChunk_bKGD+0x1e>
    e8a5:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e8aa:	e9 63 01 00 00       	jmp    ea12 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e8af:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8b2:	0f b6 00             	movzbl (%eax),%eax
    e8b5:	0f b6 d0             	movzbl %al,%edx
    e8b8:	8b 45 08             	mov    0x8(%ebp),%eax
    e8bb:	8b 40 18             	mov    0x18(%eax),%eax
    e8be:	39 c2                	cmp    %eax,%edx
    e8c0:	7c 0a                	jl     e8cc <readChunk_bKGD+0x3b>
    e8c2:	b8 67 00 00 00       	mov    $0x67,%eax
    e8c7:	e9 46 01 00 00       	jmp    ea12 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e8cc:	8b 45 08             	mov    0x8(%ebp),%eax
    e8cf:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e8d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8d9:	0f b6 00             	movzbl (%eax),%eax
    e8dc:	0f b6 d0             	movzbl %al,%edx
    e8df:	8b 45 08             	mov    0x8(%ebp),%eax
    e8e2:	89 50 38             	mov    %edx,0x38(%eax)
    e8e5:	8b 45 08             	mov    0x8(%ebp),%eax
    e8e8:	8b 50 38             	mov    0x38(%eax),%edx
    e8eb:	8b 45 08             	mov    0x8(%ebp),%eax
    e8ee:	89 50 34             	mov    %edx,0x34(%eax)
    e8f1:	8b 45 08             	mov    0x8(%ebp),%eax
    e8f4:	8b 50 34             	mov    0x34(%eax),%edx
    e8f7:	8b 45 08             	mov    0x8(%ebp),%eax
    e8fa:	89 50 30             	mov    %edx,0x30(%eax)
    e8fd:	e9 0b 01 00 00       	jmp    ea0d <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e902:	8b 45 08             	mov    0x8(%ebp),%eax
    e905:	8b 40 0c             	mov    0xc(%eax),%eax
    e908:	85 c0                	test   %eax,%eax
    e90a:	74 0b                	je     e917 <readChunk_bKGD+0x86>
    e90c:	8b 45 08             	mov    0x8(%ebp),%eax
    e90f:	8b 40 0c             	mov    0xc(%eax),%eax
    e912:	83 f8 04             	cmp    $0x4,%eax
    e915:	75 59                	jne    e970 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e917:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e91b:	74 0a                	je     e927 <readChunk_bKGD+0x96>
    e91d:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e922:	e9 eb 00 00 00       	jmp    ea12 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e927:	8b 45 08             	mov    0x8(%ebp),%eax
    e92a:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e931:	8b 45 0c             	mov    0xc(%ebp),%eax
    e934:	0f b6 00             	movzbl (%eax),%eax
    e937:	0f b6 c0             	movzbl %al,%eax
    e93a:	c1 e0 08             	shl    $0x8,%eax
    e93d:	89 c2                	mov    %eax,%edx
    e93f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e942:	83 c0 01             	add    $0x1,%eax
    e945:	0f b6 00             	movzbl (%eax),%eax
    e948:	0f b6 c0             	movzbl %al,%eax
    e94b:	01 c2                	add    %eax,%edx
    e94d:	8b 45 08             	mov    0x8(%ebp),%eax
    e950:	89 50 38             	mov    %edx,0x38(%eax)
    e953:	8b 45 08             	mov    0x8(%ebp),%eax
    e956:	8b 50 38             	mov    0x38(%eax),%edx
    e959:	8b 45 08             	mov    0x8(%ebp),%eax
    e95c:	89 50 34             	mov    %edx,0x34(%eax)
    e95f:	8b 45 08             	mov    0x8(%ebp),%eax
    e962:	8b 50 34             	mov    0x34(%eax),%edx
    e965:	8b 45 08             	mov    0x8(%ebp),%eax
    e968:	89 50 30             	mov    %edx,0x30(%eax)
    e96b:	e9 9d 00 00 00       	jmp    ea0d <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e970:	8b 45 08             	mov    0x8(%ebp),%eax
    e973:	8b 40 0c             	mov    0xc(%eax),%eax
    e976:	83 f8 02             	cmp    $0x2,%eax
    e979:	74 0f                	je     e98a <readChunk_bKGD+0xf9>
    e97b:	8b 45 08             	mov    0x8(%ebp),%eax
    e97e:	8b 40 0c             	mov    0xc(%eax),%eax
    e981:	83 f8 06             	cmp    $0x6,%eax
    e984:	0f 85 83 00 00 00    	jne    ea0d <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e98a:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e98e:	74 07                	je     e997 <readChunk_bKGD+0x106>
    e990:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e995:	eb 7b                	jmp    ea12 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e997:	8b 45 08             	mov    0x8(%ebp),%eax
    e99a:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e9a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9a4:	0f b6 00             	movzbl (%eax),%eax
    e9a7:	0f b6 c0             	movzbl %al,%eax
    e9aa:	c1 e0 08             	shl    $0x8,%eax
    e9ad:	89 c2                	mov    %eax,%edx
    e9af:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9b2:	83 c0 01             	add    $0x1,%eax
    e9b5:	0f b6 00             	movzbl (%eax),%eax
    e9b8:	0f b6 c0             	movzbl %al,%eax
    e9bb:	01 c2                	add    %eax,%edx
    e9bd:	8b 45 08             	mov    0x8(%ebp),%eax
    e9c0:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e9c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9c6:	83 c0 02             	add    $0x2,%eax
    e9c9:	0f b6 00             	movzbl (%eax),%eax
    e9cc:	0f b6 c0             	movzbl %al,%eax
    e9cf:	c1 e0 08             	shl    $0x8,%eax
    e9d2:	89 c2                	mov    %eax,%edx
    e9d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9d7:	83 c0 03             	add    $0x3,%eax
    e9da:	0f b6 00             	movzbl (%eax),%eax
    e9dd:	0f b6 c0             	movzbl %al,%eax
    e9e0:	01 c2                	add    %eax,%edx
    e9e2:	8b 45 08             	mov    0x8(%ebp),%eax
    e9e5:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e9e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9eb:	83 c0 04             	add    $0x4,%eax
    e9ee:	0f b6 00             	movzbl (%eax),%eax
    e9f1:	0f b6 c0             	movzbl %al,%eax
    e9f4:	c1 e0 08             	shl    $0x8,%eax
    e9f7:	89 c2                	mov    %eax,%edx
    e9f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9fc:	83 c0 05             	add    $0x5,%eax
    e9ff:	0f b6 00             	movzbl (%eax),%eax
    ea02:	0f b6 c0             	movzbl %al,%eax
    ea05:	01 c2                	add    %eax,%edx
    ea07:	8b 45 08             	mov    0x8(%ebp),%eax
    ea0a:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    ea0d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ea12:	5d                   	pop    %ebp
    ea13:	c3                   	ret    

0000ea14 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ea14:	55                   	push   %ebp
    ea15:	89 e5                	mov    %esp,%ebp
    ea17:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    ea1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    ea21:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ea28:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ea2f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea33:	0f 85 06 01 00 00    	jne    eb3f <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    ea39:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    ea40:	eb 04                	jmp    ea46 <readChunk_tEXt+0x32>
    ea42:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ea46:	8b 45 10             	mov    0x10(%ebp),%eax
    ea49:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ea4c:	73 0f                	jae    ea5d <readChunk_tEXt+0x49>
    ea4e:	8b 55 0c             	mov    0xc(%ebp),%edx
    ea51:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ea54:	01 d0                	add    %edx,%eax
    ea56:	0f b6 00             	movzbl (%eax),%eax
    ea59:	84 c0                	test   %al,%al
    ea5b:	75 e5                	jne    ea42 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ea5d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ea61:	74 06                	je     ea69 <readChunk_tEXt+0x55>
    ea63:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    ea67:	76 0c                	jbe    ea75 <readChunk_tEXt+0x61>
    ea69:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ea70:	e9 ca 00 00 00       	jmp    eb3f <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    ea75:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ea78:	83 c0 01             	add    $0x1,%eax
    ea7b:	83 ec 0c             	sub    $0xc,%esp
    ea7e:	50                   	push   %eax
    ea7f:	e8 73 4b ff ff       	call   35f7 <lodepng_malloc>
    ea84:	83 c4 10             	add    $0x10,%esp
    ea87:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ea8a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ea8e:	75 0c                	jne    ea9c <readChunk_tEXt+0x88>
    ea90:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ea97:	e9 a3 00 00 00       	jmp    eb3f <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    ea9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ea9f:	83 ec 04             	sub    $0x4,%esp
    eaa2:	50                   	push   %eax
    eaa3:	ff 75 0c             	pushl  0xc(%ebp)
    eaa6:	ff 75 f0             	pushl  -0x10(%ebp)
    eaa9:	e8 87 4b ff ff       	call   3635 <lodepng_memcpy>
    eaae:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eab1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eab4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eab7:	01 d0                	add    %edx,%eax
    eab9:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    eabc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eabf:	83 c0 01             	add    $0x1,%eax
    eac2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    eac5:	8b 45 10             	mov    0x10(%ebp),%eax
    eac8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    eacb:	72 08                	jb     ead5 <readChunk_tEXt+0xc1>
    eacd:	8b 45 10             	mov    0x10(%ebp),%eax
    ead0:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    ead3:	eb 05                	jmp    eada <readChunk_tEXt+0xc6>
    ead5:	b8 00 00 00 00       	mov    $0x0,%eax
    eada:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    eadd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eae0:	83 c0 01             	add    $0x1,%eax
    eae3:	83 ec 0c             	sub    $0xc,%esp
    eae6:	50                   	push   %eax
    eae7:	e8 0b 4b ff ff       	call   35f7 <lodepng_malloc>
    eaec:	83 c4 10             	add    $0x10,%esp
    eaef:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    eaf2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eaf6:	75 09                	jne    eb01 <readChunk_tEXt+0xed>
    eaf8:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eaff:	eb 3e                	jmp    eb3f <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    eb01:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb04:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    eb07:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    eb0a:	01 ca                	add    %ecx,%edx
    eb0c:	83 ec 04             	sub    $0x4,%esp
    eb0f:	50                   	push   %eax
    eb10:	52                   	push   %edx
    eb11:	ff 75 ec             	pushl  -0x14(%ebp)
    eb14:	e8 1c 4b ff ff       	call   3635 <lodepng_memcpy>
    eb19:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    eb1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eb1f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb22:	01 d0                	add    %edx,%eax
    eb24:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    eb27:	83 ec 04             	sub    $0x4,%esp
    eb2a:	ff 75 ec             	pushl  -0x14(%ebp)
    eb2d:	ff 75 f0             	pushl  -0x10(%ebp)
    eb30:	ff 75 08             	pushl  0x8(%ebp)
    eb33:	e8 3f ac ff ff       	call   9777 <lodepng_add_text>
    eb38:	83 c4 10             	add    $0x10,%esp
    eb3b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    eb3e:	90                   	nop
  }

  lodepng_free(key);
    eb3f:	83 ec 0c             	sub    $0xc,%esp
    eb42:	ff 75 f0             	pushl  -0x10(%ebp)
    eb45:	e8 ce 4a ff ff       	call   3618 <lodepng_free>
    eb4a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    eb4d:	83 ec 0c             	sub    $0xc,%esp
    eb50:	ff 75 ec             	pushl  -0x14(%ebp)
    eb53:	e8 c0 4a ff ff       	call   3618 <lodepng_free>
    eb58:	83 c4 10             	add    $0x10,%esp

  return error;
    eb5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    eb5e:	c9                   	leave  
    eb5f:	c3                   	ret    

0000eb60 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    eb60:	55                   	push   %ebp
    eb61:	89 e5                	mov    %esp,%ebp
    eb63:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    eb66:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    eb6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb70:	8b 10                	mov    (%eax),%edx
    eb72:	89 55 d0             	mov    %edx,-0x30(%ebp)
    eb75:	8b 50 04             	mov    0x4(%eax),%edx
    eb78:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    eb7b:	8b 50 08             	mov    0x8(%eax),%edx
    eb7e:	89 55 d8             	mov    %edx,-0x28(%ebp)
    eb81:	8b 50 0c             	mov    0xc(%eax),%edx
    eb84:	89 55 dc             	mov    %edx,-0x24(%ebp)
    eb87:	8b 50 10             	mov    0x10(%eax),%edx
    eb8a:	89 55 e0             	mov    %edx,-0x20(%ebp)
    eb8d:	8b 40 14             	mov    0x14(%eax),%eax
    eb90:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    eb93:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    eb9a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    eba1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    eba8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ebac:	0f 85 48 01 00 00    	jne    ecfa <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ebb2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ebb9:	eb 04                	jmp    ebbf <readChunk_zTXt+0x5f>
    ebbb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ebbf:	8b 45 14             	mov    0x14(%ebp),%eax
    ebc2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ebc5:	73 0f                	jae    ebd6 <readChunk_zTXt+0x76>
    ebc7:	8b 55 10             	mov    0x10(%ebp),%edx
    ebca:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebcd:	01 d0                	add    %edx,%eax
    ebcf:	0f b6 00             	movzbl (%eax),%eax
    ebd2:	84 c0                	test   %al,%al
    ebd4:	75 e5                	jne    ebbb <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ebd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebd9:	8d 50 02             	lea    0x2(%eax),%edx
    ebdc:	8b 45 14             	mov    0x14(%ebp),%eax
    ebdf:	39 c2                	cmp    %eax,%edx
    ebe1:	72 0c                	jb     ebef <readChunk_zTXt+0x8f>
    ebe3:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ebea:	e9 0b 01 00 00       	jmp    ecfa <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ebef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ebf3:	74 06                	je     ebfb <readChunk_zTXt+0x9b>
    ebf5:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    ebf9:	76 0c                	jbe    ec07 <readChunk_zTXt+0xa7>
    ebfb:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ec02:	e9 f3 00 00 00       	jmp    ecfa <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    ec07:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec0a:	83 c0 01             	add    $0x1,%eax
    ec0d:	83 ec 0c             	sub    $0xc,%esp
    ec10:	50                   	push   %eax
    ec11:	e8 e1 49 ff ff       	call   35f7 <lodepng_malloc>
    ec16:	83 c4 10             	add    $0x10,%esp
    ec19:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ec1c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ec20:	75 0c                	jne    ec2e <readChunk_zTXt+0xce>
    ec22:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec29:	e9 cc 00 00 00       	jmp    ecfa <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    ec2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec31:	83 ec 04             	sub    $0x4,%esp
    ec34:	50                   	push   %eax
    ec35:	ff 75 10             	pushl  0x10(%ebp)
    ec38:	ff 75 ec             	pushl  -0x14(%ebp)
    ec3b:	e8 f5 49 ff ff       	call   3635 <lodepng_memcpy>
    ec40:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ec43:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec46:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec49:	01 d0                	add    %edx,%eax
    ec4b:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ec4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec51:	8d 50 01             	lea    0x1(%eax),%edx
    ec54:	8b 45 10             	mov    0x10(%ebp),%eax
    ec57:	01 d0                	add    %edx,%eax
    ec59:	0f b6 00             	movzbl (%eax),%eax
    ec5c:	84 c0                	test   %al,%al
    ec5e:	74 0c                	je     ec6c <readChunk_zTXt+0x10c>
    ec60:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ec67:	e9 8e 00 00 00       	jmp    ecfa <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    ec6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec6f:	83 c0 02             	add    $0x2,%eax
    ec72:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ec75:	8b 45 14             	mov    0x14(%ebp),%eax
    ec78:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ec7b:	76 09                	jbe    ec86 <readChunk_zTXt+0x126>
    ec7d:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ec84:	eb 74                	jmp    ecfa <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    ec86:	8b 45 14             	mov    0x14(%ebp),%eax
    ec89:	2b 45 e8             	sub    -0x18(%ebp),%eax
    ec8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    ec8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec92:	8b 40 30             	mov    0x30(%eax),%eax
    ec95:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    ec98:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec9b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec9e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eca1:	01 d1                	add    %edx,%ecx
    eca3:	83 ec 08             	sub    $0x8,%esp
    eca6:	8d 55 d0             	lea    -0x30(%ebp),%edx
    eca9:	52                   	push   %edx
    ecaa:	50                   	push   %eax
    ecab:	51                   	push   %ecx
    ecac:	6a 00                	push   $0x0
    ecae:	8d 45 c8             	lea    -0x38(%ebp),%eax
    ecb1:	50                   	push   %eax
    ecb2:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ecb5:	50                   	push   %eax
    ecb6:	e8 f7 93 ff ff       	call   80b2 <zlib_decompress>
    ecbb:	83 c4 20             	add    $0x20,%esp
    ecbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    ecc1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ecc5:	74 11                	je     ecd8 <readChunk_zTXt+0x178>
    ecc7:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ecca:	8b 45 c8             	mov    -0x38(%ebp),%eax
    eccd:	39 c2                	cmp    %eax,%edx
    eccf:	7d 07                	jge    ecd8 <readChunk_zTXt+0x178>
    ecd1:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    ecd8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ecdc:	75 1b                	jne    ecf9 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    ecde:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ece1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ece4:	52                   	push   %edx
    ece5:	50                   	push   %eax
    ece6:	ff 75 ec             	pushl  -0x14(%ebp)
    ece9:	ff 75 08             	pushl  0x8(%ebp)
    ecec:	e8 60 a9 ff ff       	call   9651 <lodepng_add_text_sized>
    ecf1:	83 c4 10             	add    $0x10,%esp
    ecf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    ecf7:	eb 01                	jmp    ecfa <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    ecf9:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    ecfa:	83 ec 0c             	sub    $0xc,%esp
    ecfd:	ff 75 ec             	pushl  -0x14(%ebp)
    ed00:	e8 13 49 ff ff       	call   3618 <lodepng_free>
    ed05:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ed08:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ed0b:	83 ec 0c             	sub    $0xc,%esp
    ed0e:	50                   	push   %eax
    ed0f:	e8 04 49 ff ff       	call   3618 <lodepng_free>
    ed14:	83 c4 10             	add    $0x10,%esp

  return error;
    ed17:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ed1a:	c9                   	leave  
    ed1b:	c3                   	ret    

0000ed1c <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ed1c:	55                   	push   %ebp
    ed1d:	89 e5                	mov    %esp,%ebp
    ed1f:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    ed22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ed29:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed2c:	8b 10                	mov    (%eax),%edx
    ed2e:	89 55 c0             	mov    %edx,-0x40(%ebp)
    ed31:	8b 50 04             	mov    0x4(%eax),%edx
    ed34:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ed37:	8b 50 08             	mov    0x8(%eax),%edx
    ed3a:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ed3d:	8b 50 0c             	mov    0xc(%eax),%edx
    ed40:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ed43:	8b 50 10             	mov    0x10(%eax),%edx
    ed46:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ed49:	8b 40 14             	mov    0x14(%eax),%eax
    ed4c:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ed4f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ed56:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ed5d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ed64:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed68:	0f 85 d5 02 00 00    	jne    f043 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    ed6e:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    ed72:	7f 0c                	jg     ed80 <readChunk_iTXt+0x64>
    ed74:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    ed7b:	e9 c3 02 00 00       	jmp    f043 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ed80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ed87:	eb 04                	jmp    ed8d <readChunk_iTXt+0x71>
    ed89:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ed8d:	8b 45 14             	mov    0x14(%ebp),%eax
    ed90:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    ed93:	73 0f                	jae    eda4 <readChunk_iTXt+0x88>
    ed95:	8b 55 10             	mov    0x10(%ebp),%edx
    ed98:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed9b:	01 d0                	add    %edx,%eax
    ed9d:	0f b6 00             	movzbl (%eax),%eax
    eda0:	84 c0                	test   %al,%al
    eda2:	75 e5                	jne    ed89 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    eda4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eda7:	8d 50 03             	lea    0x3(%eax),%edx
    edaa:	8b 45 14             	mov    0x14(%ebp),%eax
    edad:	39 c2                	cmp    %eax,%edx
    edaf:	72 0c                	jb     edbd <readChunk_iTXt+0xa1>
    edb1:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    edb8:	e9 86 02 00 00       	jmp    f043 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    edbd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    edc1:	74 06                	je     edc9 <readChunk_iTXt+0xad>
    edc3:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    edc7:	76 0c                	jbe    edd5 <readChunk_iTXt+0xb9>
    edc9:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    edd0:	e9 6e 02 00 00       	jmp    f043 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    edd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    edd8:	83 c0 01             	add    $0x1,%eax
    eddb:	83 ec 0c             	sub    $0xc,%esp
    edde:	50                   	push   %eax
    eddf:	e8 13 48 ff ff       	call   35f7 <lodepng_malloc>
    ede4:	83 c4 10             	add    $0x10,%esp
    ede7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    edea:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    edee:	75 0c                	jne    edfc <readChunk_iTXt+0xe0>
    edf0:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    edf7:	e9 47 02 00 00       	jmp    f043 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    edfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    edff:	83 ec 04             	sub    $0x4,%esp
    ee02:	50                   	push   %eax
    ee03:	ff 75 10             	pushl  0x10(%ebp)
    ee06:	ff 75 e8             	pushl  -0x18(%ebp)
    ee09:	e8 27 48 ff ff       	call   3635 <lodepng_memcpy>
    ee0e:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ee11:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ee14:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee17:	01 d0                	add    %edx,%eax
    ee19:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    ee1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee1f:	8d 50 01             	lea    0x1(%eax),%edx
    ee22:	8b 45 10             	mov    0x10(%ebp),%eax
    ee25:	01 d0                	add    %edx,%eax
    ee27:	0f b6 00             	movzbl (%eax),%eax
    ee2a:	0f b6 c0             	movzbl %al,%eax
    ee2d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ee30:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee33:	8d 50 02             	lea    0x2(%eax),%edx
    ee36:	8b 45 10             	mov    0x10(%ebp),%eax
    ee39:	01 d0                	add    %edx,%eax
    ee3b:	0f b6 00             	movzbl (%eax),%eax
    ee3e:	84 c0                	test   %al,%al
    ee40:	74 0c                	je     ee4e <readChunk_iTXt+0x132>
    ee42:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ee49:	e9 f5 01 00 00       	jmp    f043 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    ee4e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee51:	83 c0 03             	add    $0x3,%eax
    ee54:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ee57:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ee5e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ee61:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ee64:	eb 08                	jmp    ee6e <readChunk_iTXt+0x152>
    ee66:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ee6a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ee6e:	8b 45 14             	mov    0x14(%ebp),%eax
    ee71:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ee74:	73 0f                	jae    ee85 <readChunk_iTXt+0x169>
    ee76:	8b 55 10             	mov    0x10(%ebp),%edx
    ee79:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ee7c:	01 d0                	add    %edx,%eax
    ee7e:	0f b6 00             	movzbl (%eax),%eax
    ee81:	84 c0                	test   %al,%al
    ee83:	75 e1                	jne    ee66 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ee85:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee88:	83 c0 01             	add    $0x1,%eax
    ee8b:	83 ec 0c             	sub    $0xc,%esp
    ee8e:	50                   	push   %eax
    ee8f:	e8 63 47 ff ff       	call   35f7 <lodepng_malloc>
    ee94:	83 c4 10             	add    $0x10,%esp
    ee97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ee9a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ee9e:	75 0c                	jne    eeac <readChunk_iTXt+0x190>
    eea0:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eea7:	e9 97 01 00 00       	jmp    f043 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    eeac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eeaf:	8b 4d 10             	mov    0x10(%ebp),%ecx
    eeb2:	8b 55 d8             	mov    -0x28(%ebp),%edx
    eeb5:	01 ca                	add    %ecx,%edx
    eeb7:	83 ec 04             	sub    $0x4,%esp
    eeba:	50                   	push   %eax
    eebb:	52                   	push   %edx
    eebc:	ff 75 e4             	pushl  -0x1c(%ebp)
    eebf:	e8 71 47 ff ff       	call   3635 <lodepng_memcpy>
    eec4:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    eec7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    eeca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eecd:	01 d0                	add    %edx,%eax
    eecf:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    eed2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eed5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eed8:	01 d0                	add    %edx,%eax
    eeda:	83 c0 01             	add    $0x1,%eax
    eedd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    eee0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    eee7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eeea:	89 45 f0             	mov    %eax,-0x10(%ebp)
    eeed:	eb 08                	jmp    eef7 <readChunk_iTXt+0x1db>
    eeef:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eef3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eef7:	8b 45 14             	mov    0x14(%ebp),%eax
    eefa:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eefd:	73 0f                	jae    ef0e <readChunk_iTXt+0x1f2>
    eeff:	8b 55 10             	mov    0x10(%ebp),%edx
    ef02:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ef05:	01 d0                	add    %edx,%eax
    ef07:	0f b6 00             	movzbl (%eax),%eax
    ef0a:	84 c0                	test   %al,%al
    ef0c:	75 e1                	jne    eeef <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ef0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef11:	83 c0 01             	add    $0x1,%eax
    ef14:	83 ec 0c             	sub    $0xc,%esp
    ef17:	50                   	push   %eax
    ef18:	e8 da 46 ff ff       	call   35f7 <lodepng_malloc>
    ef1d:	83 c4 10             	add    $0x10,%esp
    ef20:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ef23:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ef27:	75 0c                	jne    ef35 <readChunk_iTXt+0x219>
    ef29:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ef30:	e9 0e 01 00 00       	jmp    f043 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ef35:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef38:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ef3b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ef3e:	01 ca                	add    %ecx,%edx
    ef40:	83 ec 04             	sub    $0x4,%esp
    ef43:	50                   	push   %eax
    ef44:	52                   	push   %edx
    ef45:	ff 75 e0             	pushl  -0x20(%ebp)
    ef48:	e8 e8 46 ff ff       	call   3635 <lodepng_memcpy>
    ef4d:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ef50:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ef53:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef56:	01 d0                	add    %edx,%eax
    ef58:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ef5b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ef5e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ef61:	01 d0                	add    %edx,%eax
    ef63:	83 c0 01             	add    $0x1,%eax
    ef66:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ef69:	8b 45 14             	mov    0x14(%ebp),%eax
    ef6c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ef6f:	72 08                	jb     ef79 <readChunk_iTXt+0x25d>
    ef71:	8b 45 14             	mov    0x14(%ebp),%eax
    ef74:	2b 45 d8             	sub    -0x28(%ebp),%eax
    ef77:	eb 05                	jmp    ef7e <readChunk_iTXt+0x262>
    ef79:	b8 00 00 00 00       	mov    $0x0,%eax
    ef7e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    ef81:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ef85:	0f 84 90 00 00 00    	je     f01b <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ef8b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ef92:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ef99:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef9c:	8b 40 30             	mov    0x30(%eax),%eax
    ef9f:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    efa2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    efa5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    efa8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    efab:	01 d1                	add    %edx,%ecx
    efad:	83 ec 08             	sub    $0x8,%esp
    efb0:	8d 55 c0             	lea    -0x40(%ebp),%edx
    efb3:	52                   	push   %edx
    efb4:	50                   	push   %eax
    efb5:	51                   	push   %ecx
    efb6:	6a 00                	push   $0x0
    efb8:	8d 45 b8             	lea    -0x48(%ebp),%eax
    efbb:	50                   	push   %eax
    efbc:	8d 45 bc             	lea    -0x44(%ebp),%eax
    efbf:	50                   	push   %eax
    efc0:	e8 ed 90 ff ff       	call   80b2 <zlib_decompress>
    efc5:	83 c4 20             	add    $0x20,%esp
    efc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    efcb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    efcf:	74 11                	je     efe2 <readChunk_iTXt+0x2c6>
    efd1:	8b 55 c8             	mov    -0x38(%ebp),%edx
    efd4:	8b 45 b8             	mov    -0x48(%ebp),%eax
    efd7:	39 c2                	cmp    %eax,%edx
    efd9:	7d 07                	jge    efe2 <readChunk_iTXt+0x2c6>
    efdb:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    efe2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    efe6:	75 22                	jne    f00a <readChunk_iTXt+0x2ee>
    efe8:	8b 55 b8             	mov    -0x48(%ebp),%edx
    efeb:	8b 45 bc             	mov    -0x44(%ebp),%eax
    efee:	83 ec 08             	sub    $0x8,%esp
    eff1:	52                   	push   %edx
    eff2:	50                   	push   %eax
    eff3:	ff 75 e0             	pushl  -0x20(%ebp)
    eff6:	ff 75 e4             	pushl  -0x1c(%ebp)
    eff9:	ff 75 e8             	pushl  -0x18(%ebp)
    effc:	ff 75 08             	pushl  0x8(%ebp)
    efff:	e8 94 a9 ff ff       	call   9998 <lodepng_add_itext_sized>
    f004:	83 c4 20             	add    $0x20,%esp
    f007:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    f00a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f00d:	83 ec 0c             	sub    $0xc,%esp
    f010:	50                   	push   %eax
    f011:	e8 02 46 ff ff       	call   3618 <lodepng_free>
    f016:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    f019:	eb 27                	jmp    f042 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    f01b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f01e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f021:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f024:	01 ca                	add    %ecx,%edx
    f026:	83 ec 08             	sub    $0x8,%esp
    f029:	50                   	push   %eax
    f02a:	52                   	push   %edx
    f02b:	ff 75 e0             	pushl  -0x20(%ebp)
    f02e:	ff 75 e4             	pushl  -0x1c(%ebp)
    f031:	ff 75 e8             	pushl  -0x18(%ebp)
    f034:	ff 75 08             	pushl  0x8(%ebp)
    f037:	e8 5c a9 ff ff       	call   9998 <lodepng_add_itext_sized>
    f03c:	83 c4 20             	add    $0x20,%esp
    f03f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    f042:	90                   	nop
  }

  lodepng_free(key);
    f043:	83 ec 0c             	sub    $0xc,%esp
    f046:	ff 75 e8             	pushl  -0x18(%ebp)
    f049:	e8 ca 45 ff ff       	call   3618 <lodepng_free>
    f04e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    f051:	83 ec 0c             	sub    $0xc,%esp
    f054:	ff 75 e4             	pushl  -0x1c(%ebp)
    f057:	e8 bc 45 ff ff       	call   3618 <lodepng_free>
    f05c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    f05f:	83 ec 0c             	sub    $0xc,%esp
    f062:	ff 75 e0             	pushl  -0x20(%ebp)
    f065:	e8 ae 45 ff ff       	call   3618 <lodepng_free>
    f06a:	83 c4 10             	add    $0x10,%esp

  return error;
    f06d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f070:	c9                   	leave  
    f071:	c3                   	ret    

0000f072 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f072:	55                   	push   %ebp
    f073:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    f075:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    f079:	74 0a                	je     f085 <readChunk_tIME+0x13>
    f07b:	b8 49 00 00 00       	mov    $0x49,%eax
    f080:	e9 8b 00 00 00       	jmp    f110 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    f085:	8b 45 08             	mov    0x8(%ebp),%eax
    f088:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    f08f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f092:	0f b6 00             	movzbl (%eax),%eax
    f095:	0f b6 c0             	movzbl %al,%eax
    f098:	c1 e0 08             	shl    $0x8,%eax
    f09b:	89 c2                	mov    %eax,%edx
    f09d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0a0:	83 c0 01             	add    $0x1,%eax
    f0a3:	0f b6 00             	movzbl (%eax),%eax
    f0a6:	0f b6 c0             	movzbl %al,%eax
    f0a9:	01 c2                	add    %eax,%edx
    f0ab:	8b 45 08             	mov    0x8(%ebp),%eax
    f0ae:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    f0b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0b4:	83 c0 02             	add    $0x2,%eax
    f0b7:	0f b6 00             	movzbl (%eax),%eax
    f0ba:	0f b6 d0             	movzbl %al,%edx
    f0bd:	8b 45 08             	mov    0x8(%ebp),%eax
    f0c0:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    f0c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0c6:	83 c0 03             	add    $0x3,%eax
    f0c9:	0f b6 00             	movzbl (%eax),%eax
    f0cc:	0f b6 d0             	movzbl %al,%edx
    f0cf:	8b 45 08             	mov    0x8(%ebp),%eax
    f0d2:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    f0d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0d8:	83 c0 04             	add    $0x4,%eax
    f0db:	0f b6 00             	movzbl (%eax),%eax
    f0de:	0f b6 d0             	movzbl %al,%edx
    f0e1:	8b 45 08             	mov    0x8(%ebp),%eax
    f0e4:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    f0e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ea:	83 c0 05             	add    $0x5,%eax
    f0ed:	0f b6 00             	movzbl (%eax),%eax
    f0f0:	0f b6 d0             	movzbl %al,%edx
    f0f3:	8b 45 08             	mov    0x8(%ebp),%eax
    f0f6:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    f0f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0fc:	83 c0 06             	add    $0x6,%eax
    f0ff:	0f b6 00             	movzbl (%eax),%eax
    f102:	0f b6 d0             	movzbl %al,%edx
    f105:	8b 45 08             	mov    0x8(%ebp),%eax
    f108:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    f10b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f110:	5d                   	pop    %ebp
    f111:	c3                   	ret    

0000f112 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f112:	55                   	push   %ebp
    f113:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    f115:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    f119:	74 0a                	je     f125 <readChunk_pHYs+0x13>
    f11b:	b8 4a 00 00 00       	mov    $0x4a,%eax
    f120:	e9 ba 00 00 00       	jmp    f1df <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    f125:	8b 45 08             	mov    0x8(%ebp),%eax
    f128:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f12f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f132:	0f b6 00             	movzbl (%eax),%eax
    f135:	0f b6 c0             	movzbl %al,%eax
    f138:	c1 e0 08             	shl    $0x8,%eax
    f13b:	89 c2                	mov    %eax,%edx
    f13d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f140:	83 c0 01             	add    $0x1,%eax
    f143:	0f b6 00             	movzbl (%eax),%eax
    f146:	0f b6 c0             	movzbl %al,%eax
    f149:	01 d0                	add    %edx,%eax
    f14b:	c1 e0 08             	shl    $0x8,%eax
    f14e:	89 c2                	mov    %eax,%edx
    f150:	8b 45 0c             	mov    0xc(%ebp),%eax
    f153:	83 c0 02             	add    $0x2,%eax
    f156:	0f b6 00             	movzbl (%eax),%eax
    f159:	0f b6 c0             	movzbl %al,%eax
    f15c:	01 d0                	add    %edx,%eax
    f15e:	c1 e0 08             	shl    $0x8,%eax
    f161:	89 c2                	mov    %eax,%edx
    f163:	8b 45 0c             	mov    0xc(%ebp),%eax
    f166:	83 c0 03             	add    $0x3,%eax
    f169:	0f b6 00             	movzbl (%eax),%eax
    f16c:	0f b6 c0             	movzbl %al,%eax
    f16f:	01 c2                	add    %eax,%edx
    f171:	8b 45 08             	mov    0x8(%ebp),%eax
    f174:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    f177:	8b 45 0c             	mov    0xc(%ebp),%eax
    f17a:	83 c0 04             	add    $0x4,%eax
    f17d:	0f b6 00             	movzbl (%eax),%eax
    f180:	0f b6 c0             	movzbl %al,%eax
    f183:	c1 e0 08             	shl    $0x8,%eax
    f186:	89 c2                	mov    %eax,%edx
    f188:	8b 45 0c             	mov    0xc(%ebp),%eax
    f18b:	83 c0 05             	add    $0x5,%eax
    f18e:	0f b6 00             	movzbl (%eax),%eax
    f191:	0f b6 c0             	movzbl %al,%eax
    f194:	01 d0                	add    %edx,%eax
    f196:	c1 e0 08             	shl    $0x8,%eax
    f199:	89 c2                	mov    %eax,%edx
    f19b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f19e:	83 c0 06             	add    $0x6,%eax
    f1a1:	0f b6 00             	movzbl (%eax),%eax
    f1a4:	0f b6 c0             	movzbl %al,%eax
    f1a7:	01 d0                	add    %edx,%eax
    f1a9:	c1 e0 08             	shl    $0x8,%eax
    f1ac:	89 c2                	mov    %eax,%edx
    f1ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1b1:	83 c0 07             	add    $0x7,%eax
    f1b4:	0f b6 00             	movzbl (%eax),%eax
    f1b7:	0f b6 c0             	movzbl %al,%eax
    f1ba:	01 c2                	add    %eax,%edx
    f1bc:	8b 45 08             	mov    0x8(%ebp),%eax
    f1bf:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    f1c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1c8:	83 c0 08             	add    $0x8,%eax
    f1cb:	0f b6 00             	movzbl (%eax),%eax
    f1ce:	0f b6 d0             	movzbl %al,%edx
    f1d1:	8b 45 08             	mov    0x8(%ebp),%eax
    f1d4:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    f1da:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f1df:	5d                   	pop    %ebp
    f1e0:	c3                   	ret    

0000f1e1 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f1e1:	55                   	push   %ebp
    f1e2:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    f1e4:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    f1e8:	74 07                	je     f1f1 <readChunk_gAMA+0x10>
    f1ea:	b8 60 00 00 00       	mov    $0x60,%eax
    f1ef:	eb 5d                	jmp    f24e <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    f1f1:	8b 45 08             	mov    0x8(%ebp),%eax
    f1f4:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    f1fb:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f1fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    f201:	0f b6 00             	movzbl (%eax),%eax
    f204:	0f b6 c0             	movzbl %al,%eax
    f207:	c1 e0 08             	shl    $0x8,%eax
    f20a:	89 c2                	mov    %eax,%edx
    f20c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f20f:	83 c0 01             	add    $0x1,%eax
    f212:	0f b6 00             	movzbl (%eax),%eax
    f215:	0f b6 c0             	movzbl %al,%eax
    f218:	01 d0                	add    %edx,%eax
    f21a:	c1 e0 08             	shl    $0x8,%eax
    f21d:	89 c2                	mov    %eax,%edx
    f21f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f222:	83 c0 02             	add    $0x2,%eax
    f225:	0f b6 00             	movzbl (%eax),%eax
    f228:	0f b6 c0             	movzbl %al,%eax
    f22b:	01 d0                	add    %edx,%eax
    f22d:	c1 e0 08             	shl    $0x8,%eax
    f230:	89 c2                	mov    %eax,%edx
    f232:	8b 45 0c             	mov    0xc(%ebp),%eax
    f235:	83 c0 03             	add    $0x3,%eax
    f238:	0f b6 00             	movzbl (%eax),%eax
    f23b:	0f b6 c0             	movzbl %al,%eax
    f23e:	01 c2                	add    %eax,%edx
    f240:	8b 45 08             	mov    0x8(%ebp),%eax
    f243:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f249:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f24e:	5d                   	pop    %ebp
    f24f:	c3                   	ret    

0000f250 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f250:	55                   	push   %ebp
    f251:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f253:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f257:	74 0a                	je     f263 <readChunk_cHRM+0x13>
    f259:	b8 61 00 00 00       	mov    $0x61,%eax
    f25e:	e9 7f 02 00 00       	jmp    f4e2 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f263:	8b 45 08             	mov    0x8(%ebp),%eax
    f266:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f26d:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f270:	8b 45 0c             	mov    0xc(%ebp),%eax
    f273:	0f b6 00             	movzbl (%eax),%eax
    f276:	0f b6 c0             	movzbl %al,%eax
    f279:	c1 e0 08             	shl    $0x8,%eax
    f27c:	89 c2                	mov    %eax,%edx
    f27e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f281:	83 c0 01             	add    $0x1,%eax
    f284:	0f b6 00             	movzbl (%eax),%eax
    f287:	0f b6 c0             	movzbl %al,%eax
    f28a:	01 d0                	add    %edx,%eax
    f28c:	c1 e0 08             	shl    $0x8,%eax
    f28f:	89 c2                	mov    %eax,%edx
    f291:	8b 45 0c             	mov    0xc(%ebp),%eax
    f294:	83 c0 02             	add    $0x2,%eax
    f297:	0f b6 00             	movzbl (%eax),%eax
    f29a:	0f b6 c0             	movzbl %al,%eax
    f29d:	01 d0                	add    %edx,%eax
    f29f:	c1 e0 08             	shl    $0x8,%eax
    f2a2:	89 c2                	mov    %eax,%edx
    f2a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2a7:	83 c0 03             	add    $0x3,%eax
    f2aa:	0f b6 00             	movzbl (%eax),%eax
    f2ad:	0f b6 c0             	movzbl %al,%eax
    f2b0:	01 c2                	add    %eax,%edx
    f2b2:	8b 45 08             	mov    0x8(%ebp),%eax
    f2b5:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f2bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2be:	83 c0 04             	add    $0x4,%eax
    f2c1:	0f b6 00             	movzbl (%eax),%eax
    f2c4:	0f b6 c0             	movzbl %al,%eax
    f2c7:	c1 e0 08             	shl    $0x8,%eax
    f2ca:	89 c2                	mov    %eax,%edx
    f2cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2cf:	83 c0 05             	add    $0x5,%eax
    f2d2:	0f b6 00             	movzbl (%eax),%eax
    f2d5:	0f b6 c0             	movzbl %al,%eax
    f2d8:	01 d0                	add    %edx,%eax
    f2da:	c1 e0 08             	shl    $0x8,%eax
    f2dd:	89 c2                	mov    %eax,%edx
    f2df:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2e2:	83 c0 06             	add    $0x6,%eax
    f2e5:	0f b6 00             	movzbl (%eax),%eax
    f2e8:	0f b6 c0             	movzbl %al,%eax
    f2eb:	01 d0                	add    %edx,%eax
    f2ed:	c1 e0 08             	shl    $0x8,%eax
    f2f0:	89 c2                	mov    %eax,%edx
    f2f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2f5:	83 c0 07             	add    $0x7,%eax
    f2f8:	0f b6 00             	movzbl (%eax),%eax
    f2fb:	0f b6 c0             	movzbl %al,%eax
    f2fe:	01 c2                	add    %eax,%edx
    f300:	8b 45 08             	mov    0x8(%ebp),%eax
    f303:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f309:	8b 45 0c             	mov    0xc(%ebp),%eax
    f30c:	83 c0 08             	add    $0x8,%eax
    f30f:	0f b6 00             	movzbl (%eax),%eax
    f312:	0f b6 c0             	movzbl %al,%eax
    f315:	c1 e0 08             	shl    $0x8,%eax
    f318:	89 c2                	mov    %eax,%edx
    f31a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f31d:	83 c0 09             	add    $0x9,%eax
    f320:	0f b6 00             	movzbl (%eax),%eax
    f323:	0f b6 c0             	movzbl %al,%eax
    f326:	01 d0                	add    %edx,%eax
    f328:	c1 e0 08             	shl    $0x8,%eax
    f32b:	89 c2                	mov    %eax,%edx
    f32d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f330:	83 c0 0a             	add    $0xa,%eax
    f333:	0f b6 00             	movzbl (%eax),%eax
    f336:	0f b6 c0             	movzbl %al,%eax
    f339:	01 d0                	add    %edx,%eax
    f33b:	c1 e0 08             	shl    $0x8,%eax
    f33e:	89 c2                	mov    %eax,%edx
    f340:	8b 45 0c             	mov    0xc(%ebp),%eax
    f343:	83 c0 0b             	add    $0xb,%eax
    f346:	0f b6 00             	movzbl (%eax),%eax
    f349:	0f b6 c0             	movzbl %al,%eax
    f34c:	01 c2                	add    %eax,%edx
    f34e:	8b 45 08             	mov    0x8(%ebp),%eax
    f351:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f357:	8b 45 0c             	mov    0xc(%ebp),%eax
    f35a:	83 c0 0c             	add    $0xc,%eax
    f35d:	0f b6 00             	movzbl (%eax),%eax
    f360:	0f b6 c0             	movzbl %al,%eax
    f363:	c1 e0 08             	shl    $0x8,%eax
    f366:	89 c2                	mov    %eax,%edx
    f368:	8b 45 0c             	mov    0xc(%ebp),%eax
    f36b:	83 c0 0d             	add    $0xd,%eax
    f36e:	0f b6 00             	movzbl (%eax),%eax
    f371:	0f b6 c0             	movzbl %al,%eax
    f374:	01 d0                	add    %edx,%eax
    f376:	c1 e0 08             	shl    $0x8,%eax
    f379:	89 c2                	mov    %eax,%edx
    f37b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f37e:	83 c0 0e             	add    $0xe,%eax
    f381:	0f b6 00             	movzbl (%eax),%eax
    f384:	0f b6 c0             	movzbl %al,%eax
    f387:	01 d0                	add    %edx,%eax
    f389:	c1 e0 08             	shl    $0x8,%eax
    f38c:	89 c2                	mov    %eax,%edx
    f38e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f391:	83 c0 0f             	add    $0xf,%eax
    f394:	0f b6 00             	movzbl (%eax),%eax
    f397:	0f b6 c0             	movzbl %al,%eax
    f39a:	01 c2                	add    %eax,%edx
    f39c:	8b 45 08             	mov    0x8(%ebp),%eax
    f39f:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f3a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3a8:	83 c0 10             	add    $0x10,%eax
    f3ab:	0f b6 00             	movzbl (%eax),%eax
    f3ae:	0f b6 c0             	movzbl %al,%eax
    f3b1:	c1 e0 08             	shl    $0x8,%eax
    f3b4:	89 c2                	mov    %eax,%edx
    f3b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3b9:	83 c0 11             	add    $0x11,%eax
    f3bc:	0f b6 00             	movzbl (%eax),%eax
    f3bf:	0f b6 c0             	movzbl %al,%eax
    f3c2:	01 d0                	add    %edx,%eax
    f3c4:	c1 e0 08             	shl    $0x8,%eax
    f3c7:	89 c2                	mov    %eax,%edx
    f3c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3cc:	83 c0 12             	add    $0x12,%eax
    f3cf:	0f b6 00             	movzbl (%eax),%eax
    f3d2:	0f b6 c0             	movzbl %al,%eax
    f3d5:	01 d0                	add    %edx,%eax
    f3d7:	c1 e0 08             	shl    $0x8,%eax
    f3da:	89 c2                	mov    %eax,%edx
    f3dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3df:	83 c0 13             	add    $0x13,%eax
    f3e2:	0f b6 00             	movzbl (%eax),%eax
    f3e5:	0f b6 c0             	movzbl %al,%eax
    f3e8:	01 c2                	add    %eax,%edx
    f3ea:	8b 45 08             	mov    0x8(%ebp),%eax
    f3ed:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f3f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3f6:	83 c0 14             	add    $0x14,%eax
    f3f9:	0f b6 00             	movzbl (%eax),%eax
    f3fc:	0f b6 c0             	movzbl %al,%eax
    f3ff:	c1 e0 08             	shl    $0x8,%eax
    f402:	89 c2                	mov    %eax,%edx
    f404:	8b 45 0c             	mov    0xc(%ebp),%eax
    f407:	83 c0 15             	add    $0x15,%eax
    f40a:	0f b6 00             	movzbl (%eax),%eax
    f40d:	0f b6 c0             	movzbl %al,%eax
    f410:	01 d0                	add    %edx,%eax
    f412:	c1 e0 08             	shl    $0x8,%eax
    f415:	89 c2                	mov    %eax,%edx
    f417:	8b 45 0c             	mov    0xc(%ebp),%eax
    f41a:	83 c0 16             	add    $0x16,%eax
    f41d:	0f b6 00             	movzbl (%eax),%eax
    f420:	0f b6 c0             	movzbl %al,%eax
    f423:	01 d0                	add    %edx,%eax
    f425:	c1 e0 08             	shl    $0x8,%eax
    f428:	89 c2                	mov    %eax,%edx
    f42a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f42d:	83 c0 17             	add    $0x17,%eax
    f430:	0f b6 00             	movzbl (%eax),%eax
    f433:	0f b6 c0             	movzbl %al,%eax
    f436:	01 c2                	add    %eax,%edx
    f438:	8b 45 08             	mov    0x8(%ebp),%eax
    f43b:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f441:	8b 45 0c             	mov    0xc(%ebp),%eax
    f444:	83 c0 18             	add    $0x18,%eax
    f447:	0f b6 00             	movzbl (%eax),%eax
    f44a:	0f b6 c0             	movzbl %al,%eax
    f44d:	c1 e0 08             	shl    $0x8,%eax
    f450:	89 c2                	mov    %eax,%edx
    f452:	8b 45 0c             	mov    0xc(%ebp),%eax
    f455:	83 c0 19             	add    $0x19,%eax
    f458:	0f b6 00             	movzbl (%eax),%eax
    f45b:	0f b6 c0             	movzbl %al,%eax
    f45e:	01 d0                	add    %edx,%eax
    f460:	c1 e0 08             	shl    $0x8,%eax
    f463:	89 c2                	mov    %eax,%edx
    f465:	8b 45 0c             	mov    0xc(%ebp),%eax
    f468:	83 c0 1a             	add    $0x1a,%eax
    f46b:	0f b6 00             	movzbl (%eax),%eax
    f46e:	0f b6 c0             	movzbl %al,%eax
    f471:	01 d0                	add    %edx,%eax
    f473:	c1 e0 08             	shl    $0x8,%eax
    f476:	89 c2                	mov    %eax,%edx
    f478:	8b 45 0c             	mov    0xc(%ebp),%eax
    f47b:	83 c0 1b             	add    $0x1b,%eax
    f47e:	0f b6 00             	movzbl (%eax),%eax
    f481:	0f b6 c0             	movzbl %al,%eax
    f484:	01 c2                	add    %eax,%edx
    f486:	8b 45 08             	mov    0x8(%ebp),%eax
    f489:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f48f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f492:	83 c0 1c             	add    $0x1c,%eax
    f495:	0f b6 00             	movzbl (%eax),%eax
    f498:	0f b6 c0             	movzbl %al,%eax
    f49b:	c1 e0 08             	shl    $0x8,%eax
    f49e:	89 c2                	mov    %eax,%edx
    f4a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4a3:	83 c0 1d             	add    $0x1d,%eax
    f4a6:	0f b6 00             	movzbl (%eax),%eax
    f4a9:	0f b6 c0             	movzbl %al,%eax
    f4ac:	01 d0                	add    %edx,%eax
    f4ae:	c1 e0 08             	shl    $0x8,%eax
    f4b1:	89 c2                	mov    %eax,%edx
    f4b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4b6:	83 c0 1e             	add    $0x1e,%eax
    f4b9:	0f b6 00             	movzbl (%eax),%eax
    f4bc:	0f b6 c0             	movzbl %al,%eax
    f4bf:	01 d0                	add    %edx,%eax
    f4c1:	c1 e0 08             	shl    $0x8,%eax
    f4c4:	89 c2                	mov    %eax,%edx
    f4c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4c9:	83 c0 1f             	add    $0x1f,%eax
    f4cc:	0f b6 00             	movzbl (%eax),%eax
    f4cf:	0f b6 c0             	movzbl %al,%eax
    f4d2:	01 c2                	add    %eax,%edx
    f4d4:	8b 45 08             	mov    0x8(%ebp),%eax
    f4d7:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f4dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f4e2:	5d                   	pop    %ebp
    f4e3:	c3                   	ret    

0000f4e4 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f4e4:	55                   	push   %ebp
    f4e5:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f4e7:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f4eb:	74 07                	je     f4f4 <readChunk_sRGB+0x10>
    f4ed:	b8 62 00 00 00       	mov    $0x62,%eax
    f4f2:	eb 24                	jmp    f518 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f4f4:	8b 45 08             	mov    0x8(%ebp),%eax
    f4f7:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f4fe:	00 00 00 
  info->srgb_intent = data[0];
    f501:	8b 45 0c             	mov    0xc(%ebp),%eax
    f504:	0f b6 00             	movzbl (%eax),%eax
    f507:	0f b6 d0             	movzbl %al,%edx
    f50a:	8b 45 08             	mov    0x8(%ebp),%eax
    f50d:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f513:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f518:	5d                   	pop    %ebp
    f519:	c3                   	ret    

0000f51a <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f51a:	55                   	push   %ebp
    f51b:	89 e5                	mov    %esp,%ebp
    f51d:	53                   	push   %ebx
    f51e:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f521:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f528:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f52f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f532:	8b 10                	mov    (%eax),%edx
    f534:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f537:	8b 50 04             	mov    0x4(%eax),%edx
    f53a:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f53d:	8b 50 08             	mov    0x8(%eax),%edx
    f540:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f543:	8b 50 0c             	mov    0xc(%eax),%edx
    f546:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f549:	8b 50 10             	mov    0x10(%eax),%edx
    f54c:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f54f:	8b 40 14             	mov    0x14(%eax),%eax
    f552:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f555:	8b 45 08             	mov    0x8(%ebp),%eax
    f558:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f55f:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f562:	8b 45 08             	mov    0x8(%ebp),%eax
    f565:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f56b:	85 c0                	test   %eax,%eax
    f56d:	74 0e                	je     f57d <readChunk_iCCP+0x63>
    f56f:	83 ec 0c             	sub    $0xc,%esp
    f572:	ff 75 08             	pushl  0x8(%ebp)
    f575:	e8 ca a6 ff ff       	call   9c44 <lodepng_clear_icc>
    f57a:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f57d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f584:	eb 04                	jmp    f58a <readChunk_iCCP+0x70>
    f586:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f58a:	8b 45 14             	mov    0x14(%ebp),%eax
    f58d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f590:	73 0f                	jae    f5a1 <readChunk_iCCP+0x87>
    f592:	8b 55 10             	mov    0x10(%ebp),%edx
    f595:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f598:	01 d0                	add    %edx,%eax
    f59a:	0f b6 00             	movzbl (%eax),%eax
    f59d:	84 c0                	test   %al,%al
    f59f:	75 e5                	jne    f586 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f5a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f5a4:	8d 50 02             	lea    0x2(%eax),%edx
    f5a7:	8b 45 14             	mov    0x14(%ebp),%eax
    f5aa:	39 c2                	cmp    %eax,%edx
    f5ac:	72 0a                	jb     f5b8 <readChunk_iCCP+0x9e>
    f5ae:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f5b3:	e9 46 01 00 00       	jmp    f6fe <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f5b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f5bc:	74 06                	je     f5c4 <readChunk_iCCP+0xaa>
    f5be:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f5c2:	76 0a                	jbe    f5ce <readChunk_iCCP+0xb4>
    f5c4:	b8 59 00 00 00       	mov    $0x59,%eax
    f5c9:	e9 30 01 00 00       	jmp    f6fe <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f5ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f5d1:	83 c0 01             	add    $0x1,%eax
    f5d4:	83 ec 0c             	sub    $0xc,%esp
    f5d7:	50                   	push   %eax
    f5d8:	e8 1a 40 ff ff       	call   35f7 <lodepng_malloc>
    f5dd:	83 c4 10             	add    $0x10,%esp
    f5e0:	89 c2                	mov    %eax,%edx
    f5e2:	8b 45 08             	mov    0x8(%ebp),%eax
    f5e5:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f5eb:	8b 45 08             	mov    0x8(%ebp),%eax
    f5ee:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f5f4:	85 c0                	test   %eax,%eax
    f5f6:	75 0a                	jne    f602 <readChunk_iCCP+0xe8>
    f5f8:	b8 53 00 00 00       	mov    $0x53,%eax
    f5fd:	e9 fc 00 00 00       	jmp    f6fe <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f602:	8b 45 08             	mov    0x8(%ebp),%eax
    f605:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f60b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f60e:	01 d0                	add    %edx,%eax
    f610:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f613:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f61a:	eb 1f                	jmp    f63b <readChunk_iCCP+0x121>
    f61c:	8b 45 08             	mov    0x8(%ebp),%eax
    f61f:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f625:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f628:	01 d0                	add    %edx,%eax
    f62a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f62d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f630:	01 ca                	add    %ecx,%edx
    f632:	0f b6 12             	movzbl (%edx),%edx
    f635:	88 10                	mov    %dl,(%eax)
    f637:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f63b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f63e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f641:	75 d9                	jne    f61c <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f643:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f646:	8d 50 01             	lea    0x1(%eax),%edx
    f649:	8b 45 10             	mov    0x10(%ebp),%eax
    f64c:	01 d0                	add    %edx,%eax
    f64e:	0f b6 00             	movzbl (%eax),%eax
    f651:	84 c0                	test   %al,%al
    f653:	74 0a                	je     f65f <readChunk_iCCP+0x145>
    f655:	b8 48 00 00 00       	mov    $0x48,%eax
    f65a:	e9 9f 00 00 00       	jmp    f6fe <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f65f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f662:	83 c0 02             	add    $0x2,%eax
    f665:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f668:	8b 45 14             	mov    0x14(%ebp),%eax
    f66b:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f66e:	76 0a                	jbe    f67a <readChunk_iCCP+0x160>
    f670:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f675:	e9 84 00 00 00       	jmp    f6fe <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f67a:	8b 45 14             	mov    0x14(%ebp),%eax
    f67d:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f680:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f683:	8b 45 0c             	mov    0xc(%ebp),%eax
    f686:	8b 40 34             	mov    0x34(%eax),%eax
    f689:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f68c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f68f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f692:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f695:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f698:	8b 55 08             	mov    0x8(%ebp),%edx
    f69b:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f6a1:	83 ec 08             	sub    $0x8,%esp
    f6a4:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f6a7:	52                   	push   %edx
    f6a8:	50                   	push   %eax
    f6a9:	53                   	push   %ebx
    f6aa:	6a 00                	push   $0x0
    f6ac:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f6af:	50                   	push   %eax
    f6b0:	51                   	push   %ecx
    f6b1:	e8 fc 89 ff ff       	call   80b2 <zlib_decompress>
    f6b6:	83 c4 20             	add    $0x20,%esp
    f6b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f6bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f6c0:	74 11                	je     f6d3 <readChunk_iCCP+0x1b9>
    f6c2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f6c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f6c8:	39 c2                	cmp    %eax,%edx
    f6ca:	7d 07                	jge    f6d3 <readChunk_iCCP+0x1b9>
    f6cc:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f6d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f6d6:	89 c2                	mov    %eax,%edx
    f6d8:	8b 45 08             	mov    0x8(%ebp),%eax
    f6db:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f6e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f6e5:	75 14                	jne    f6fb <readChunk_iCCP+0x1e1>
    f6e7:	8b 45 08             	mov    0x8(%ebp),%eax
    f6ea:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f6f0:	85 c0                	test   %eax,%eax
    f6f2:	75 07                	jne    f6fb <readChunk_iCCP+0x1e1>
    f6f4:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f6fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f6fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f701:	c9                   	leave  
    f702:	c3                   	ret    

0000f703 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f703:	55                   	push   %ebp
    f704:	89 e5                	mov    %esp,%ebp
    f706:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f709:	8b 55 0c             	mov    0xc(%ebp),%edx
    f70c:	8b 45 10             	mov    0x10(%ebp),%eax
    f70f:	01 d0                	add    %edx,%eax
    f711:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f714:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f71b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f722:	8b 45 0c             	mov    0xc(%ebp),%eax
    f725:	83 c0 04             	add    $0x4,%eax
    f728:	3b 45 14             	cmp    0x14(%ebp),%eax
    f72b:	7e 0a                	jle    f737 <lodepng_inspect_chunk+0x34>
    f72d:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f732:	e9 43 03 00 00       	jmp    fa7a <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f737:	ff 75 ec             	pushl  -0x14(%ebp)
    f73a:	e8 3a 8e ff ff       	call   8579 <lodepng_chunk_length>
    f73f:	83 c4 04             	add    $0x4,%esp
    f742:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f745:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f748:	85 c0                	test   %eax,%eax
    f74a:	79 0a                	jns    f756 <lodepng_inspect_chunk+0x53>
    f74c:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f751:	e9 24 03 00 00       	jmp    fa7a <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f756:	ff 75 ec             	pushl  -0x14(%ebp)
    f759:	e8 53 8f ff ff       	call   86b1 <lodepng_chunk_data_const>
    f75e:	83 c4 04             	add    $0x4,%esp
    f761:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f764:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f767:	8d 50 04             	lea    0x4(%eax),%edx
    f76a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f76d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f770:	8b 55 14             	mov    0x14(%ebp),%edx
    f773:	8b 45 10             	mov    0x10(%ebp),%eax
    f776:	01 d0                	add    %edx,%eax
    f778:	39 c1                	cmp    %eax,%ecx
    f77a:	76 0a                	jbe    f786 <lodepng_inspect_chunk+0x83>
    f77c:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f781:	e9 f4 02 00 00       	jmp    fa7a <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f786:	68 68 a3 01 00       	push   $0x1a368
    f78b:	ff 75 ec             	pushl  -0x14(%ebp)
    f78e:	e8 33 8e ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f793:	83 c4 08             	add    $0x8,%esp
    f796:	84 c0                	test   %al,%al
    f798:	74 24                	je     f7be <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f79a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f79d:	8b 55 08             	mov    0x8(%ebp),%edx
    f7a0:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f7a6:	83 ec 04             	sub    $0x4,%esp
    f7a9:	50                   	push   %eax
    f7aa:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7ad:	52                   	push   %edx
    f7ae:	e8 5b ee ff ff       	call   e60e <readChunk_PLTE>
    f7b3:	83 c4 10             	add    $0x10,%esp
    f7b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7b9:	e9 8a 02 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f7be:	83 ec 08             	sub    $0x8,%esp
    f7c1:	68 6d a3 01 00       	push   $0x1a36d
    f7c6:	ff 75 ec             	pushl  -0x14(%ebp)
    f7c9:	e8 f8 8d ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f7ce:	83 c4 10             	add    $0x10,%esp
    f7d1:	84 c0                	test   %al,%al
    f7d3:	74 24                	je     f7f9 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f7d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f7d8:	8b 55 08             	mov    0x8(%ebp),%edx
    f7db:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f7e1:	83 ec 04             	sub    $0x4,%esp
    f7e4:	50                   	push   %eax
    f7e5:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7e8:	52                   	push   %edx
    f7e9:	e8 40 ef ff ff       	call   e72e <readChunk_tRNS>
    f7ee:	83 c4 10             	add    $0x10,%esp
    f7f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7f4:	e9 4f 02 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f7f9:	83 ec 08             	sub    $0x8,%esp
    f7fc:	68 72 a3 01 00       	push   $0x1a372
    f801:	ff 75 ec             	pushl  -0x14(%ebp)
    f804:	e8 bd 8d ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f809:	83 c4 10             	add    $0x10,%esp
    f80c:	84 c0                	test   %al,%al
    f80e:	74 24                	je     f834 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f810:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f813:	8b 55 08             	mov    0x8(%ebp),%edx
    f816:	81 c2 98 00 00 00    	add    $0x98,%edx
    f81c:	83 ec 04             	sub    $0x4,%esp
    f81f:	50                   	push   %eax
    f820:	ff 75 e4             	pushl  -0x1c(%ebp)
    f823:	52                   	push   %edx
    f824:	e8 68 f0 ff ff       	call   e891 <readChunk_bKGD>
    f829:	83 c4 10             	add    $0x10,%esp
    f82c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f82f:	e9 14 02 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f834:	83 ec 08             	sub    $0x8,%esp
    f837:	68 77 a3 01 00       	push   $0x1a377
    f83c:	ff 75 ec             	pushl  -0x14(%ebp)
    f83f:	e8 82 8d ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f844:	83 c4 10             	add    $0x10,%esp
    f847:	84 c0                	test   %al,%al
    f849:	74 24                	je     f86f <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f84b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f84e:	8b 55 08             	mov    0x8(%ebp),%edx
    f851:	81 c2 98 00 00 00    	add    $0x98,%edx
    f857:	83 ec 04             	sub    $0x4,%esp
    f85a:	50                   	push   %eax
    f85b:	ff 75 e4             	pushl  -0x1c(%ebp)
    f85e:	52                   	push   %edx
    f85f:	e8 b0 f1 ff ff       	call   ea14 <readChunk_tEXt>
    f864:	83 c4 10             	add    $0x10,%esp
    f867:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f86a:	e9 d9 01 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f86f:	83 ec 08             	sub    $0x8,%esp
    f872:	68 7c a3 01 00       	push   $0x1a37c
    f877:	ff 75 ec             	pushl  -0x14(%ebp)
    f87a:	e8 47 8d ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f87f:	83 c4 10             	add    $0x10,%esp
    f882:	84 c0                	test   %al,%al
    f884:	74 25                	je     f8ab <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f886:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f889:	8b 45 08             	mov    0x8(%ebp),%eax
    f88c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f88f:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f895:	52                   	push   %edx
    f896:	ff 75 e4             	pushl  -0x1c(%ebp)
    f899:	50                   	push   %eax
    f89a:	51                   	push   %ecx
    f89b:	e8 c0 f2 ff ff       	call   eb60 <readChunk_zTXt>
    f8a0:	83 c4 10             	add    $0x10,%esp
    f8a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f8a6:	e9 9d 01 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f8ab:	83 ec 08             	sub    $0x8,%esp
    f8ae:	68 81 a3 01 00       	push   $0x1a381
    f8b3:	ff 75 ec             	pushl  -0x14(%ebp)
    f8b6:	e8 0b 8d ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f8bb:	83 c4 10             	add    $0x10,%esp
    f8be:	84 c0                	test   %al,%al
    f8c0:	74 25                	je     f8e7 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f8c2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f8c5:	8b 45 08             	mov    0x8(%ebp),%eax
    f8c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f8cb:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f8d1:	52                   	push   %edx
    f8d2:	ff 75 e4             	pushl  -0x1c(%ebp)
    f8d5:	50                   	push   %eax
    f8d6:	51                   	push   %ecx
    f8d7:	e8 40 f4 ff ff       	call   ed1c <readChunk_iTXt>
    f8dc:	83 c4 10             	add    $0x10,%esp
    f8df:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f8e2:	e9 61 01 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f8e7:	83 ec 08             	sub    $0x8,%esp
    f8ea:	68 86 a3 01 00       	push   $0x1a386
    f8ef:	ff 75 ec             	pushl  -0x14(%ebp)
    f8f2:	e8 cf 8c ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f8f7:	83 c4 10             	add    $0x10,%esp
    f8fa:	84 c0                	test   %al,%al
    f8fc:	74 24                	je     f922 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f8fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f901:	8b 55 08             	mov    0x8(%ebp),%edx
    f904:	81 c2 98 00 00 00    	add    $0x98,%edx
    f90a:	83 ec 04             	sub    $0x4,%esp
    f90d:	50                   	push   %eax
    f90e:	ff 75 e4             	pushl  -0x1c(%ebp)
    f911:	52                   	push   %edx
    f912:	e8 5b f7 ff ff       	call   f072 <readChunk_tIME>
    f917:	83 c4 10             	add    $0x10,%esp
    f91a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f91d:	e9 26 01 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f922:	83 ec 08             	sub    $0x8,%esp
    f925:	68 8b a3 01 00       	push   $0x1a38b
    f92a:	ff 75 ec             	pushl  -0x14(%ebp)
    f92d:	e8 94 8c ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f932:	83 c4 10             	add    $0x10,%esp
    f935:	84 c0                	test   %al,%al
    f937:	74 24                	je     f95d <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f939:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f93c:	8b 55 08             	mov    0x8(%ebp),%edx
    f93f:	81 c2 98 00 00 00    	add    $0x98,%edx
    f945:	83 ec 04             	sub    $0x4,%esp
    f948:	50                   	push   %eax
    f949:	ff 75 e4             	pushl  -0x1c(%ebp)
    f94c:	52                   	push   %edx
    f94d:	e8 c0 f7 ff ff       	call   f112 <readChunk_pHYs>
    f952:	83 c4 10             	add    $0x10,%esp
    f955:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f958:	e9 eb 00 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f95d:	83 ec 08             	sub    $0x8,%esp
    f960:	68 90 a3 01 00       	push   $0x1a390
    f965:	ff 75 ec             	pushl  -0x14(%ebp)
    f968:	e8 59 8c ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f96d:	83 c4 10             	add    $0x10,%esp
    f970:	84 c0                	test   %al,%al
    f972:	74 24                	je     f998 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f974:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f977:	8b 55 08             	mov    0x8(%ebp),%edx
    f97a:	81 c2 98 00 00 00    	add    $0x98,%edx
    f980:	83 ec 04             	sub    $0x4,%esp
    f983:	50                   	push   %eax
    f984:	ff 75 e4             	pushl  -0x1c(%ebp)
    f987:	52                   	push   %edx
    f988:	e8 54 f8 ff ff       	call   f1e1 <readChunk_gAMA>
    f98d:	83 c4 10             	add    $0x10,%esp
    f990:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f993:	e9 b0 00 00 00       	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f998:	83 ec 08             	sub    $0x8,%esp
    f99b:	68 95 a3 01 00       	push   $0x1a395
    f9a0:	ff 75 ec             	pushl  -0x14(%ebp)
    f9a3:	e8 1e 8c ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f9a8:	83 c4 10             	add    $0x10,%esp
    f9ab:	84 c0                	test   %al,%al
    f9ad:	74 21                	je     f9d0 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f9af:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f9b2:	8b 55 08             	mov    0x8(%ebp),%edx
    f9b5:	81 c2 98 00 00 00    	add    $0x98,%edx
    f9bb:	83 ec 04             	sub    $0x4,%esp
    f9be:	50                   	push   %eax
    f9bf:	ff 75 e4             	pushl  -0x1c(%ebp)
    f9c2:	52                   	push   %edx
    f9c3:	e8 88 f8 ff ff       	call   f250 <readChunk_cHRM>
    f9c8:	83 c4 10             	add    $0x10,%esp
    f9cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f9ce:	eb 78                	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f9d0:	83 ec 08             	sub    $0x8,%esp
    f9d3:	68 9a a3 01 00       	push   $0x1a39a
    f9d8:	ff 75 ec             	pushl  -0x14(%ebp)
    f9db:	e8 e6 8b ff ff       	call   85c6 <lodepng_chunk_type_equals>
    f9e0:	83 c4 10             	add    $0x10,%esp
    f9e3:	84 c0                	test   %al,%al
    f9e5:	74 21                	je     fa08 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f9e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f9ea:	8b 55 08             	mov    0x8(%ebp),%edx
    f9ed:	81 c2 98 00 00 00    	add    $0x98,%edx
    f9f3:	83 ec 04             	sub    $0x4,%esp
    f9f6:	50                   	push   %eax
    f9f7:	ff 75 e4             	pushl  -0x1c(%ebp)
    f9fa:	52                   	push   %edx
    f9fb:	e8 e4 fa ff ff       	call   f4e4 <readChunk_sRGB>
    fa00:	83 c4 10             	add    $0x10,%esp
    fa03:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fa06:	eb 40                	jmp    fa48 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fa08:	83 ec 08             	sub    $0x8,%esp
    fa0b:	68 9f a3 01 00       	push   $0x1a39f
    fa10:	ff 75 ec             	pushl  -0x14(%ebp)
    fa13:	e8 ae 8b ff ff       	call   85c6 <lodepng_chunk_type_equals>
    fa18:	83 c4 10             	add    $0x10,%esp
    fa1b:	84 c0                	test   %al,%al
    fa1d:	74 22                	je     fa41 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fa1f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fa22:	8b 45 08             	mov    0x8(%ebp),%eax
    fa25:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fa28:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fa2e:	52                   	push   %edx
    fa2f:	ff 75 e4             	pushl  -0x1c(%ebp)
    fa32:	50                   	push   %eax
    fa33:	51                   	push   %ecx
    fa34:	e8 e1 fa ff ff       	call   f51a <readChunk_iCCP>
    fa39:	83 c4 10             	add    $0x10,%esp
    fa3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fa3f:	eb 07                	jmp    fa48 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    fa41:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    fa48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fa4c:	75 29                	jne    fa77 <lodepng_inspect_chunk+0x374>
    fa4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fa52:	75 23                	jne    fa77 <lodepng_inspect_chunk+0x374>
    fa54:	8b 45 08             	mov    0x8(%ebp),%eax
    fa57:	8b 40 18             	mov    0x18(%eax),%eax
    fa5a:	85 c0                	test   %eax,%eax
    fa5c:	75 19                	jne    fa77 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    fa5e:	83 ec 0c             	sub    $0xc,%esp
    fa61:	ff 75 ec             	pushl  -0x14(%ebp)
    fa64:	e8 53 8c ff ff       	call   86bc <lodepng_chunk_check_crc>
    fa69:	83 c4 10             	add    $0x10,%esp
    fa6c:	85 c0                	test   %eax,%eax
    fa6e:	74 07                	je     fa77 <lodepng_inspect_chunk+0x374>
    fa70:	b8 39 00 00 00       	mov    $0x39,%eax
    fa75:	eb 03                	jmp    fa7a <lodepng_inspect_chunk+0x377>
  }

  return error;
    fa77:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    fa7a:	c9                   	leave  
    fa7b:	c3                   	ret    

0000fa7c <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    fa7c:	55                   	push   %ebp
    fa7d:	89 e5                	mov    %esp,%ebp
    fa7f:	56                   	push   %esi
    fa80:	53                   	push   %ebx
    fa81:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    fa84:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    fa88:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    fa8f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    fa96:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    fa9d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    faa4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    faab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    fab2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    fab9:	8b 45 08             	mov    0x8(%ebp),%eax
    fabc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    fac2:	8b 45 10             	mov    0x10(%ebp),%eax
    fac5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    facb:	8b 45 10             	mov    0x10(%ebp),%eax
    face:	8b 10                	mov    (%eax),%edx
    fad0:	8b 45 0c             	mov    0xc(%ebp),%eax
    fad3:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    fad5:	83 ec 0c             	sub    $0xc,%esp
    fad8:	ff 75 1c             	pushl  0x1c(%ebp)
    fadb:	ff 75 18             	pushl  0x18(%ebp)
    fade:	ff 75 14             	pushl  0x14(%ebp)
    fae1:	ff 75 10             	pushl  0x10(%ebp)
    fae4:	ff 75 0c             	pushl  0xc(%ebp)
    fae7:	e8 d3 da ff ff       	call   d5bf <lodepng_inspect>
    faec:	83 c4 20             	add    $0x20,%esp
    faef:	89 c2                	mov    %eax,%edx
    faf1:	8b 45 14             	mov    0x14(%ebp),%eax
    faf4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    fafa:	8b 45 14             	mov    0x14(%ebp),%eax
    fafd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb03:	85 c0                	test   %eax,%eax
    fb05:	0f 85 24 0a 00 00    	jne    1052f <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    fb0b:	8b 45 14             	mov    0x14(%ebp),%eax
    fb0e:	8d 58 78             	lea    0x78(%eax),%ebx
    fb11:	8b 45 14             	mov    0x14(%ebp),%eax
    fb14:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    fb1a:	8b 45 10             	mov    0x10(%ebp),%eax
    fb1d:	8b 10                	mov    (%eax),%edx
    fb1f:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb22:	8b 00                	mov    (%eax),%eax
    fb24:	53                   	push   %ebx
    fb25:	51                   	push   %ecx
    fb26:	52                   	push   %edx
    fb27:	50                   	push   %eax
    fb28:	e8 76 97 ff ff       	call   92a3 <lodepng_pixel_overflow>
    fb2d:	83 c4 10             	add    $0x10,%esp
    fb30:	85 c0                	test   %eax,%eax
    fb32:	74 12                	je     fb46 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    fb34:	8b 45 14             	mov    0x14(%ebp),%eax
    fb37:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    fb3e:	00 00 00 
    fb41:	e9 ea 09 00 00       	jmp    10530 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    fb46:	83 ec 0c             	sub    $0xc,%esp
    fb49:	ff 75 1c             	pushl  0x1c(%ebp)
    fb4c:	e8 a6 3a ff ff       	call   35f7 <lodepng_malloc>
    fb51:	83 c4 10             	add    $0x10,%esp
    fb54:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    fb57:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    fb5b:	75 12                	jne    fb6f <decodeGeneric+0xf3>
    fb5d:	8b 45 14             	mov    0x14(%ebp),%eax
    fb60:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    fb67:	00 00 00 
    fb6a:	e9 c1 09 00 00       	jmp    10530 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    fb6f:	8b 45 18             	mov    0x18(%ebp),%eax
    fb72:	83 c0 21             	add    $0x21,%eax
    fb75:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    fb78:	e9 81 06 00 00       	jmp    101fe <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    fb7d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fb80:	8b 45 18             	mov    0x18(%ebp),%eax
    fb83:	29 c2                	sub    %eax,%edx
    fb85:	89 d0                	mov    %edx,%eax
    fb87:	83 c0 0c             	add    $0xc,%eax
    fb8a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fb8d:	7f 08                	jg     fb97 <decodeGeneric+0x11b>
    fb8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fb92:	3b 45 18             	cmp    0x18(%ebp),%eax
    fb95:	73 20                	jae    fbb7 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fb97:	8b 45 14             	mov    0x14(%ebp),%eax
    fb9a:	8b 40 20             	mov    0x20(%eax),%eax
    fb9d:	85 c0                	test   %eax,%eax
    fb9f:	0f 85 72 06 00 00    	jne    10217 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    fba5:	8b 45 14             	mov    0x14(%ebp),%eax
    fba8:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    fbaf:	00 00 00 
    fbb2:	e9 6a 06 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    fbb7:	83 ec 0c             	sub    $0xc,%esp
    fbba:	ff 75 f0             	pushl  -0x10(%ebp)
    fbbd:	e8 b7 89 ff ff       	call   8579 <lodepng_chunk_length>
    fbc2:	83 c4 10             	add    $0x10,%esp
    fbc5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    fbc8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbcb:	85 c0                	test   %eax,%eax
    fbcd:	79 20                	jns    fbef <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fbcf:	8b 45 14             	mov    0x14(%ebp),%eax
    fbd2:	8b 40 20             	mov    0x20(%eax),%eax
    fbd5:	85 c0                	test   %eax,%eax
    fbd7:	0f 85 3d 06 00 00    	jne    1021a <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    fbdd:	8b 45 14             	mov    0x14(%ebp),%eax
    fbe0:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    fbe7:	00 00 00 
    fbea:	e9 32 06 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    fbef:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fbf2:	8b 45 18             	mov    0x18(%ebp),%eax
    fbf5:	29 c2                	sub    %eax,%edx
    fbf7:	89 d0                	mov    %edx,%eax
    fbf9:	89 c2                	mov    %eax,%edx
    fbfb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbfe:	01 d0                	add    %edx,%eax
    fc00:	83 c0 0c             	add    $0xc,%eax
    fc03:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fc06:	7f 10                	jg     fc18 <decodeGeneric+0x19c>
    fc08:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc0b:	8d 50 0c             	lea    0xc(%eax),%edx
    fc0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fc11:	01 d0                	add    %edx,%eax
    fc13:	3b 45 18             	cmp    0x18(%ebp),%eax
    fc16:	73 12                	jae    fc2a <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    fc18:	8b 45 14             	mov    0x14(%ebp),%eax
    fc1b:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    fc22:	00 00 00 
    fc25:	e9 f7 05 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    fc2a:	83 ec 0c             	sub    $0xc,%esp
    fc2d:	ff 75 f0             	pushl  -0x10(%ebp)
    fc30:	e8 7c 8a ff ff       	call   86b1 <lodepng_chunk_data_const>
    fc35:	83 c4 10             	add    $0x10,%esp
    fc38:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    fc3b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    fc42:	83 ec 08             	sub    $0x8,%esp
    fc45:	68 a4 a3 01 00       	push   $0x1a3a4
    fc4a:	ff 75 f0             	pushl  -0x10(%ebp)
    fc4d:	e8 74 89 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    fc52:	83 c4 10             	add    $0x10,%esp
    fc55:	84 c0                	test   %al,%al
    fc57:	74 79                	je     fcd2 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    fc59:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc5c:	83 ec 04             	sub    $0x4,%esp
    fc5f:	8d 55 bc             	lea    -0x44(%ebp),%edx
    fc62:	52                   	push   %edx
    fc63:	50                   	push   %eax
    fc64:	ff 75 ec             	pushl  -0x14(%ebp)
    fc67:	e8 4f 3a ff ff       	call   36bb <lodepng_addofl>
    fc6c:	83 c4 10             	add    $0x10,%esp
    fc6f:	85 c0                	test   %eax,%eax
    fc71:	74 12                	je     fc85 <decodeGeneric+0x209>
    fc73:	8b 45 14             	mov    0x14(%ebp),%eax
    fc76:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fc7d:	00 00 00 
    fc80:	e9 9c 05 00 00       	jmp    10221 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    fc85:	8b 45 bc             	mov    -0x44(%ebp),%eax
    fc88:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fc8b:	7e 13                	jle    fca0 <decodeGeneric+0x224>
    fc8d:	8b 45 14             	mov    0x14(%ebp),%eax
    fc90:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fc97:	00 00 00 
    fc9a:	90                   	nop
    fc9b:	e9 81 05 00 00       	jmp    10221 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    fca0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fca3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    fca6:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fca9:	01 ca                	add    %ecx,%edx
    fcab:	83 ec 04             	sub    $0x4,%esp
    fcae:	50                   	push   %eax
    fcaf:	ff 75 d0             	pushl  -0x30(%ebp)
    fcb2:	52                   	push   %edx
    fcb3:	e8 7d 39 ff ff       	call   3635 <lodepng_memcpy>
    fcb8:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    fcbb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fcbe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcc1:	01 d0                	add    %edx,%eax
    fcc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    fcc6:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    fccd:	e9 db 04 00 00       	jmp    101ad <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fcd2:	83 ec 08             	sub    $0x8,%esp
    fcd5:	68 a9 a3 01 00       	push   $0x1a3a9
    fcda:	ff 75 f0             	pushl  -0x10(%ebp)
    fcdd:	e8 e4 88 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    fce2:	83 c4 10             	add    $0x10,%esp
    fce5:	84 c0                	test   %al,%al
    fce7:	74 09                	je     fcf2 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fce9:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fced:	e9 bb 04 00 00       	jmp    101ad <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fcf2:	83 ec 08             	sub    $0x8,%esp
    fcf5:	68 68 a3 01 00       	push   $0x1a368
    fcfa:	ff 75 f0             	pushl  -0x10(%ebp)
    fcfd:	e8 c4 88 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    fd02:	83 c4 10             	add    $0x10,%esp
    fd05:	84 c0                	test   %al,%al
    fd07:	74 44                	je     fd4d <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fd09:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd0c:	8b 55 14             	mov    0x14(%ebp),%edx
    fd0f:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fd15:	83 ec 04             	sub    $0x4,%esp
    fd18:	50                   	push   %eax
    fd19:	ff 75 d0             	pushl  -0x30(%ebp)
    fd1c:	52                   	push   %edx
    fd1d:	e8 ec e8 ff ff       	call   e60e <readChunk_PLTE>
    fd22:	83 c4 10             	add    $0x10,%esp
    fd25:	89 c2                	mov    %eax,%edx
    fd27:	8b 45 14             	mov    0x14(%ebp),%eax
    fd2a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd30:	8b 45 14             	mov    0x14(%ebp),%eax
    fd33:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd39:	85 c0                	test   %eax,%eax
    fd3b:	0f 85 dc 04 00 00    	jne    1021d <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fd41:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fd48:	e9 60 04 00 00       	jmp    101ad <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fd4d:	83 ec 08             	sub    $0x8,%esp
    fd50:	68 6d a3 01 00       	push   $0x1a36d
    fd55:	ff 75 f0             	pushl  -0x10(%ebp)
    fd58:	e8 69 88 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    fd5d:	83 c4 10             	add    $0x10,%esp
    fd60:	84 c0                	test   %al,%al
    fd62:	74 3d                	je     fda1 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fd64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd67:	8b 55 14             	mov    0x14(%ebp),%edx
    fd6a:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fd70:	83 ec 04             	sub    $0x4,%esp
    fd73:	50                   	push   %eax
    fd74:	ff 75 d0             	pushl  -0x30(%ebp)
    fd77:	52                   	push   %edx
    fd78:	e8 b1 e9 ff ff       	call   e72e <readChunk_tRNS>
    fd7d:	83 c4 10             	add    $0x10,%esp
    fd80:	89 c2                	mov    %eax,%edx
    fd82:	8b 45 14             	mov    0x14(%ebp),%eax
    fd85:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd8b:	8b 45 14             	mov    0x14(%ebp),%eax
    fd8e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd94:	85 c0                	test   %eax,%eax
    fd96:	0f 84 11 04 00 00    	je     101ad <decodeGeneric+0x731>
    fd9c:	e9 80 04 00 00       	jmp    10221 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fda1:	83 ec 08             	sub    $0x8,%esp
    fda4:	68 72 a3 01 00       	push   $0x1a372
    fda9:	ff 75 f0             	pushl  -0x10(%ebp)
    fdac:	e8 15 88 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    fdb1:	83 c4 10             	add    $0x10,%esp
    fdb4:	84 c0                	test   %al,%al
    fdb6:	74 3d                	je     fdf5 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fdb8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdbb:	8b 55 14             	mov    0x14(%ebp),%edx
    fdbe:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdc4:	83 ec 04             	sub    $0x4,%esp
    fdc7:	50                   	push   %eax
    fdc8:	ff 75 d0             	pushl  -0x30(%ebp)
    fdcb:	52                   	push   %edx
    fdcc:	e8 c0 ea ff ff       	call   e891 <readChunk_bKGD>
    fdd1:	83 c4 10             	add    $0x10,%esp
    fdd4:	89 c2                	mov    %eax,%edx
    fdd6:	8b 45 14             	mov    0x14(%ebp),%eax
    fdd9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fddf:	8b 45 14             	mov    0x14(%ebp),%eax
    fde2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fde8:	85 c0                	test   %eax,%eax
    fdea:	0f 84 bd 03 00 00    	je     101ad <decodeGeneric+0x731>
    fdf0:	e9 2c 04 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fdf5:	83 ec 08             	sub    $0x8,%esp
    fdf8:	68 77 a3 01 00       	push   $0x1a377
    fdfd:	ff 75 f0             	pushl  -0x10(%ebp)
    fe00:	e8 c1 87 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    fe05:	83 c4 10             	add    $0x10,%esp
    fe08:	84 c0                	test   %al,%al
    fe0a:	74 4b                	je     fe57 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fe0c:	8b 45 14             	mov    0x14(%ebp),%eax
    fe0f:	8b 40 28             	mov    0x28(%eax),%eax
    fe12:	85 c0                	test   %eax,%eax
    fe14:	0f 84 93 03 00 00    	je     101ad <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fe1a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe1d:	8b 55 14             	mov    0x14(%ebp),%edx
    fe20:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe26:	83 ec 04             	sub    $0x4,%esp
    fe29:	50                   	push   %eax
    fe2a:	ff 75 d0             	pushl  -0x30(%ebp)
    fe2d:	52                   	push   %edx
    fe2e:	e8 e1 eb ff ff       	call   ea14 <readChunk_tEXt>
    fe33:	83 c4 10             	add    $0x10,%esp
    fe36:	89 c2                	mov    %eax,%edx
    fe38:	8b 45 14             	mov    0x14(%ebp),%eax
    fe3b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fe41:	8b 45 14             	mov    0x14(%ebp),%eax
    fe44:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe4a:	85 c0                	test   %eax,%eax
    fe4c:	0f 84 5b 03 00 00    	je     101ad <decodeGeneric+0x731>
    fe52:	e9 ca 03 00 00       	jmp    10221 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fe57:	83 ec 08             	sub    $0x8,%esp
    fe5a:	68 7c a3 01 00       	push   $0x1a37c
    fe5f:	ff 75 f0             	pushl  -0x10(%ebp)
    fe62:	e8 5f 87 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    fe67:	83 c4 10             	add    $0x10,%esp
    fe6a:	84 c0                	test   %al,%al
    fe6c:	74 4c                	je     feba <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fe6e:	8b 45 14             	mov    0x14(%ebp),%eax
    fe71:	8b 40 28             	mov    0x28(%eax),%eax
    fe74:	85 c0                	test   %eax,%eax
    fe76:	0f 84 31 03 00 00    	je     101ad <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fe7c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fe7f:	8b 45 14             	mov    0x14(%ebp),%eax
    fe82:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fe85:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fe8b:	52                   	push   %edx
    fe8c:	ff 75 d0             	pushl  -0x30(%ebp)
    fe8f:	50                   	push   %eax
    fe90:	51                   	push   %ecx
    fe91:	e8 ca ec ff ff       	call   eb60 <readChunk_zTXt>
    fe96:	83 c4 10             	add    $0x10,%esp
    fe99:	89 c2                	mov    %eax,%edx
    fe9b:	8b 45 14             	mov    0x14(%ebp),%eax
    fe9e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fea4:	8b 45 14             	mov    0x14(%ebp),%eax
    fea7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fead:	85 c0                	test   %eax,%eax
    feaf:	0f 84 f8 02 00 00    	je     101ad <decodeGeneric+0x731>
    feb5:	e9 67 03 00 00       	jmp    10221 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    feba:	83 ec 08             	sub    $0x8,%esp
    febd:	68 81 a3 01 00       	push   $0x1a381
    fec2:	ff 75 f0             	pushl  -0x10(%ebp)
    fec5:	e8 fc 86 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    feca:	83 c4 10             	add    $0x10,%esp
    fecd:	84 c0                	test   %al,%al
    fecf:	74 4c                	je     ff1d <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fed1:	8b 45 14             	mov    0x14(%ebp),%eax
    fed4:	8b 40 28             	mov    0x28(%eax),%eax
    fed7:	85 c0                	test   %eax,%eax
    fed9:	0f 84 ce 02 00 00    	je     101ad <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fedf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fee2:	8b 45 14             	mov    0x14(%ebp),%eax
    fee5:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fee8:	81 c1 98 00 00 00    	add    $0x98,%ecx
    feee:	52                   	push   %edx
    feef:	ff 75 d0             	pushl  -0x30(%ebp)
    fef2:	50                   	push   %eax
    fef3:	51                   	push   %ecx
    fef4:	e8 23 ee ff ff       	call   ed1c <readChunk_iTXt>
    fef9:	83 c4 10             	add    $0x10,%esp
    fefc:	89 c2                	mov    %eax,%edx
    fefe:	8b 45 14             	mov    0x14(%ebp),%eax
    ff01:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    ff07:	8b 45 14             	mov    0x14(%ebp),%eax
    ff0a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff10:	85 c0                	test   %eax,%eax
    ff12:	0f 84 95 02 00 00    	je     101ad <decodeGeneric+0x731>
    ff18:	e9 04 03 00 00       	jmp    10221 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    ff1d:	83 ec 08             	sub    $0x8,%esp
    ff20:	68 86 a3 01 00       	push   $0x1a386
    ff25:	ff 75 f0             	pushl  -0x10(%ebp)
    ff28:	e8 99 86 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    ff2d:	83 c4 10             	add    $0x10,%esp
    ff30:	84 c0                	test   %al,%al
    ff32:	74 3d                	je     ff71 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    ff34:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ff37:	8b 55 14             	mov    0x14(%ebp),%edx
    ff3a:	81 c2 98 00 00 00    	add    $0x98,%edx
    ff40:	83 ec 04             	sub    $0x4,%esp
    ff43:	50                   	push   %eax
    ff44:	ff 75 d0             	pushl  -0x30(%ebp)
    ff47:	52                   	push   %edx
    ff48:	e8 25 f1 ff ff       	call   f072 <readChunk_tIME>
    ff4d:	83 c4 10             	add    $0x10,%esp
    ff50:	89 c2                	mov    %eax,%edx
    ff52:	8b 45 14             	mov    0x14(%ebp),%eax
    ff55:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    ff5b:	8b 45 14             	mov    0x14(%ebp),%eax
    ff5e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff64:	85 c0                	test   %eax,%eax
    ff66:	0f 84 41 02 00 00    	je     101ad <decodeGeneric+0x731>
    ff6c:	e9 b0 02 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    ff71:	83 ec 08             	sub    $0x8,%esp
    ff74:	68 8b a3 01 00       	push   $0x1a38b
    ff79:	ff 75 f0             	pushl  -0x10(%ebp)
    ff7c:	e8 45 86 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    ff81:	83 c4 10             	add    $0x10,%esp
    ff84:	84 c0                	test   %al,%al
    ff86:	74 3d                	je     ffc5 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    ff88:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ff8b:	8b 55 14             	mov    0x14(%ebp),%edx
    ff8e:	81 c2 98 00 00 00    	add    $0x98,%edx
    ff94:	83 ec 04             	sub    $0x4,%esp
    ff97:	50                   	push   %eax
    ff98:	ff 75 d0             	pushl  -0x30(%ebp)
    ff9b:	52                   	push   %edx
    ff9c:	e8 71 f1 ff ff       	call   f112 <readChunk_pHYs>
    ffa1:	83 c4 10             	add    $0x10,%esp
    ffa4:	89 c2                	mov    %eax,%edx
    ffa6:	8b 45 14             	mov    0x14(%ebp),%eax
    ffa9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    ffaf:	8b 45 14             	mov    0x14(%ebp),%eax
    ffb2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ffb8:	85 c0                	test   %eax,%eax
    ffba:	0f 84 ed 01 00 00    	je     101ad <decodeGeneric+0x731>
    ffc0:	e9 5c 02 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    ffc5:	83 ec 08             	sub    $0x8,%esp
    ffc8:	68 90 a3 01 00       	push   $0x1a390
    ffcd:	ff 75 f0             	pushl  -0x10(%ebp)
    ffd0:	e8 f1 85 ff ff       	call   85c6 <lodepng_chunk_type_equals>
    ffd5:	83 c4 10             	add    $0x10,%esp
    ffd8:	84 c0                	test   %al,%al
    ffda:	74 3d                	je     10019 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    ffdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ffdf:	8b 55 14             	mov    0x14(%ebp),%edx
    ffe2:	81 c2 98 00 00 00    	add    $0x98,%edx
    ffe8:	83 ec 04             	sub    $0x4,%esp
    ffeb:	50                   	push   %eax
    ffec:	ff 75 d0             	pushl  -0x30(%ebp)
    ffef:	52                   	push   %edx
    fff0:	e8 ec f1 ff ff       	call   f1e1 <readChunk_gAMA>
    fff5:	83 c4 10             	add    $0x10,%esp
    fff8:	89 c2                	mov    %eax,%edx
    fffa:	8b 45 14             	mov    0x14(%ebp),%eax
    fffd:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10003:	8b 45 14             	mov    0x14(%ebp),%eax
   10006:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1000c:	85 c0                	test   %eax,%eax
   1000e:	0f 84 99 01 00 00    	je     101ad <decodeGeneric+0x731>
   10014:	e9 08 02 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   10019:	83 ec 08             	sub    $0x8,%esp
   1001c:	68 95 a3 01 00       	push   $0x1a395
   10021:	ff 75 f0             	pushl  -0x10(%ebp)
   10024:	e8 9d 85 ff ff       	call   85c6 <lodepng_chunk_type_equals>
   10029:	83 c4 10             	add    $0x10,%esp
   1002c:	84 c0                	test   %al,%al
   1002e:	74 3d                	je     1006d <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   10030:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10033:	8b 55 14             	mov    0x14(%ebp),%edx
   10036:	81 c2 98 00 00 00    	add    $0x98,%edx
   1003c:	83 ec 04             	sub    $0x4,%esp
   1003f:	50                   	push   %eax
   10040:	ff 75 d0             	pushl  -0x30(%ebp)
   10043:	52                   	push   %edx
   10044:	e8 07 f2 ff ff       	call   f250 <readChunk_cHRM>
   10049:	83 c4 10             	add    $0x10,%esp
   1004c:	89 c2                	mov    %eax,%edx
   1004e:	8b 45 14             	mov    0x14(%ebp),%eax
   10051:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10057:	8b 45 14             	mov    0x14(%ebp),%eax
   1005a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10060:	85 c0                	test   %eax,%eax
   10062:	0f 84 45 01 00 00    	je     101ad <decodeGeneric+0x731>
   10068:	e9 b4 01 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   1006d:	83 ec 08             	sub    $0x8,%esp
   10070:	68 9a a3 01 00       	push   $0x1a39a
   10075:	ff 75 f0             	pushl  -0x10(%ebp)
   10078:	e8 49 85 ff ff       	call   85c6 <lodepng_chunk_type_equals>
   1007d:	83 c4 10             	add    $0x10,%esp
   10080:	84 c0                	test   %al,%al
   10082:	74 3d                	je     100c1 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   10084:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10087:	8b 55 14             	mov    0x14(%ebp),%edx
   1008a:	81 c2 98 00 00 00    	add    $0x98,%edx
   10090:	83 ec 04             	sub    $0x4,%esp
   10093:	50                   	push   %eax
   10094:	ff 75 d0             	pushl  -0x30(%ebp)
   10097:	52                   	push   %edx
   10098:	e8 47 f4 ff ff       	call   f4e4 <readChunk_sRGB>
   1009d:	83 c4 10             	add    $0x10,%esp
   100a0:	89 c2                	mov    %eax,%edx
   100a2:	8b 45 14             	mov    0x14(%ebp),%eax
   100a5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   100ab:	8b 45 14             	mov    0x14(%ebp),%eax
   100ae:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   100b4:	85 c0                	test   %eax,%eax
   100b6:	0f 84 f1 00 00 00    	je     101ad <decodeGeneric+0x731>
   100bc:	e9 60 01 00 00       	jmp    10221 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   100c1:	83 ec 08             	sub    $0x8,%esp
   100c4:	68 9f a3 01 00       	push   $0x1a39f
   100c9:	ff 75 f0             	pushl  -0x10(%ebp)
   100cc:	e8 f5 84 ff ff       	call   85c6 <lodepng_chunk_type_equals>
   100d1:	83 c4 10             	add    $0x10,%esp
   100d4:	84 c0                	test   %al,%al
   100d6:	74 3e                	je     10116 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   100d8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   100db:	8b 45 14             	mov    0x14(%ebp),%eax
   100de:	8b 4d 14             	mov    0x14(%ebp),%ecx
   100e1:	81 c1 98 00 00 00    	add    $0x98,%ecx
   100e7:	52                   	push   %edx
   100e8:	ff 75 d0             	pushl  -0x30(%ebp)
   100eb:	50                   	push   %eax
   100ec:	51                   	push   %ecx
   100ed:	e8 28 f4 ff ff       	call   f51a <readChunk_iCCP>
   100f2:	83 c4 10             	add    $0x10,%esp
   100f5:	89 c2                	mov    %eax,%edx
   100f7:	8b 45 14             	mov    0x14(%ebp),%eax
   100fa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10100:	8b 45 14             	mov    0x14(%ebp),%eax
   10103:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10109:	85 c0                	test   %eax,%eax
   1010b:	0f 84 9c 00 00 00    	je     101ad <decodeGeneric+0x731>
   10111:	e9 0b 01 00 00       	jmp    10221 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   10116:	8b 45 14             	mov    0x14(%ebp),%eax
   10119:	8b 40 1c             	mov    0x1c(%eax),%eax
   1011c:	85 c0                	test   %eax,%eax
   1011e:	75 24                	jne    10144 <decodeGeneric+0x6c8>
   10120:	83 ec 0c             	sub    $0xc,%esp
   10123:	ff 75 f0             	pushl  -0x10(%ebp)
   10126:	e8 30 85 ff ff       	call   865b <lodepng_chunk_ancillary>
   1012b:	83 c4 10             	add    $0x10,%esp
   1012e:	84 c0                	test   %al,%al
   10130:	75 12                	jne    10144 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   10132:	8b 45 14             	mov    0x14(%ebp),%eax
   10135:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   1013c:	00 00 00 
   1013f:	e9 dd 00 00 00       	jmp    10221 <decodeGeneric+0x7a5>
      }

      unknown = 1;
   10144:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   1014b:	8b 45 14             	mov    0x14(%ebp),%eax
   1014e:	8b 40 2c             	mov    0x2c(%eax),%eax
   10151:	85 c0                	test   %eax,%eax
   10153:	74 58                	je     101ad <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   10155:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10158:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   1015b:	83 c0 58             	add    $0x58,%eax
   1015e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10165:	8b 45 14             	mov    0x14(%ebp),%eax
   10168:	01 d0                	add    %edx,%eax
   1016a:	8d 50 10             	lea    0x10(%eax),%edx
   1016d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10170:	83 e8 01             	sub    $0x1,%eax
   10173:	83 c0 54             	add    $0x54,%eax
   10176:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   1017d:	8b 45 14             	mov    0x14(%ebp),%eax
   10180:	01 c8                	add    %ecx,%eax
   10182:	83 c0 14             	add    $0x14,%eax
   10185:	83 ec 04             	sub    $0x4,%esp
   10188:	ff 75 f0             	pushl  -0x10(%ebp)
   1018b:	52                   	push   %edx
   1018c:	50                   	push   %eax
   1018d:	e8 15 88 ff ff       	call   89a7 <lodepng_chunk_append>
   10192:	83 c4 10             	add    $0x10,%esp
   10195:	89 c2                	mov    %eax,%edx
   10197:	8b 45 14             	mov    0x14(%ebp),%eax
   1019a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   101a0:	8b 45 14             	mov    0x14(%ebp),%eax
   101a3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101a9:	85 c0                	test   %eax,%eax
   101ab:	75 73                	jne    10220 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   101ad:	8b 45 14             	mov    0x14(%ebp),%eax
   101b0:	8b 40 18             	mov    0x18(%eax),%eax
   101b3:	85 c0                	test   %eax,%eax
   101b5:	75 27                	jne    101de <decodeGeneric+0x762>
   101b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   101bb:	75 21                	jne    101de <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   101bd:	83 ec 0c             	sub    $0xc,%esp
   101c0:	ff 75 f0             	pushl  -0x10(%ebp)
   101c3:	e8 f4 84 ff ff       	call   86bc <lodepng_chunk_check_crc>
   101c8:	83 c4 10             	add    $0x10,%esp
   101cb:	85 c0                	test   %eax,%eax
   101cd:	74 0f                	je     101de <decodeGeneric+0x762>
   101cf:	8b 45 14             	mov    0x14(%ebp),%eax
   101d2:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   101d9:	00 00 00 
   101dc:	eb 43                	jmp    10221 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   101de:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   101e2:	75 1a                	jne    101fe <decodeGeneric+0x782>
   101e4:	8b 55 1c             	mov    0x1c(%ebp),%edx
   101e7:	8b 45 18             	mov    0x18(%ebp),%eax
   101ea:	01 d0                	add    %edx,%eax
   101ec:	83 ec 08             	sub    $0x8,%esp
   101ef:	50                   	push   %eax
   101f0:	ff 75 f0             	pushl  -0x10(%ebp)
   101f3:	e8 3f 86 ff ff       	call   8837 <lodepng_chunk_next_const>
   101f8:	83 c4 10             	add    $0x10,%esp
   101fb:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   101fe:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   10202:	75 1d                	jne    10221 <decodeGeneric+0x7a5>
   10204:	8b 45 14             	mov    0x14(%ebp),%eax
   10207:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1020d:	85 c0                	test   %eax,%eax
   1020f:	0f 84 68 f9 ff ff    	je     fb7d <decodeGeneric+0x101>
   10215:	eb 0a                	jmp    10221 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10217:	90                   	nop
   10218:	eb 07                	jmp    10221 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   1021a:	90                   	nop
   1021b:	eb 04                	jmp    10221 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   1021d:	90                   	nop
   1021e:	eb 01                	jmp    10221 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10220:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   10221:	8b 45 14             	mov    0x14(%ebp),%eax
   10224:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1022a:	85 c0                	test   %eax,%eax
   1022c:	75 28                	jne    10256 <decodeGeneric+0x7da>
   1022e:	8b 45 14             	mov    0x14(%ebp),%eax
   10231:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   10237:	83 f8 03             	cmp    $0x3,%eax
   1023a:	75 1a                	jne    10256 <decodeGeneric+0x7da>
   1023c:	8b 45 14             	mov    0x14(%ebp),%eax
   1023f:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10245:	85 c0                	test   %eax,%eax
   10247:	75 0d                	jne    10256 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   10249:	8b 45 14             	mov    0x14(%ebp),%eax
   1024c:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   10253:	00 00 00 
  }

  if(!state->error) {
   10256:	8b 45 14             	mov    0x14(%ebp),%eax
   10259:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1025f:	85 c0                	test   %eax,%eax
   10261:	0f 85 d2 01 00 00    	jne    10439 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   10267:	8b 45 14             	mov    0x14(%ebp),%eax
   1026a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   10270:	85 c0                	test   %eax,%eax
   10272:	75 3a                	jne    102ae <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10274:	8b 45 14             	mov    0x14(%ebp),%eax
   10277:	05 a4 00 00 00       	add    $0xa4,%eax
   1027c:	83 ec 0c             	sub    $0xc,%esp
   1027f:	50                   	push   %eax
   10280:	e8 8e 8e ff ff       	call   9113 <lodepng_get_bpp>
   10285:	83 c4 10             	add    $0x10,%esp
   10288:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   1028b:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   1028e:	8b 45 10             	mov    0x10(%ebp),%eax
   10291:	8b 10                	mov    (%eax),%edx
   10293:	8b 45 0c             	mov    0xc(%ebp),%eax
   10296:	8b 00                	mov    (%eax),%eax
   10298:	83 ec 04             	sub    $0x4,%esp
   1029b:	51                   	push   %ecx
   1029c:	52                   	push   %edx
   1029d:	50                   	push   %eax
   1029e:	e8 cf 8f ff ff       	call   9272 <lodepng_get_raw_size_idat>
   102a3:	83 c4 10             	add    $0x10,%esp
   102a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
   102a9:	e9 60 01 00 00       	jmp    1040e <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   102ae:	8b 45 14             	mov    0x14(%ebp),%eax
   102b1:	05 a4 00 00 00       	add    $0xa4,%eax
   102b6:	83 ec 0c             	sub    $0xc,%esp
   102b9:	50                   	push   %eax
   102ba:	e8 54 8e ff ff       	call   9113 <lodepng_get_bpp>
   102bf:	83 c4 10             	add    $0x10,%esp
   102c2:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   102c5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   102cc:	8b 45 c8             	mov    -0x38(%ebp),%eax
   102cf:	8b 55 10             	mov    0x10(%ebp),%edx
   102d2:	8b 12                	mov    (%edx),%edx
   102d4:	83 c2 07             	add    $0x7,%edx
   102d7:	89 d1                	mov    %edx,%ecx
   102d9:	c1 e9 03             	shr    $0x3,%ecx
   102dc:	8b 55 0c             	mov    0xc(%ebp),%edx
   102df:	8b 12                	mov    (%edx),%edx
   102e1:	83 c2 07             	add    $0x7,%edx
   102e4:	c1 ea 03             	shr    $0x3,%edx
   102e7:	83 ec 04             	sub    $0x4,%esp
   102ea:	50                   	push   %eax
   102eb:	51                   	push   %ecx
   102ec:	52                   	push   %edx
   102ed:	e8 80 8f ff ff       	call   9272 <lodepng_get_raw_size_idat>
   102f2:	83 c4 10             	add    $0x10,%esp
   102f5:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   102f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   102fb:	8b 00                	mov    (%eax),%eax
   102fd:	83 f8 04             	cmp    $0x4,%eax
   10300:	76 2c                	jbe    1032e <decodeGeneric+0x8b2>
   10302:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10305:	8b 55 10             	mov    0x10(%ebp),%edx
   10308:	8b 12                	mov    (%edx),%edx
   1030a:	83 c2 07             	add    $0x7,%edx
   1030d:	89 d1                	mov    %edx,%ecx
   1030f:	c1 e9 03             	shr    $0x3,%ecx
   10312:	8b 55 0c             	mov    0xc(%ebp),%edx
   10315:	8b 12                	mov    (%edx),%edx
   10317:	83 c2 03             	add    $0x3,%edx
   1031a:	c1 ea 03             	shr    $0x3,%edx
   1031d:	83 ec 04             	sub    $0x4,%esp
   10320:	50                   	push   %eax
   10321:	51                   	push   %ecx
   10322:	52                   	push   %edx
   10323:	e8 4a 8f ff ff       	call   9272 <lodepng_get_raw_size_idat>
   10328:	83 c4 10             	add    $0x10,%esp
   1032b:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   1032e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10331:	8b 55 10             	mov    0x10(%ebp),%edx
   10334:	8b 12                	mov    (%edx),%edx
   10336:	83 c2 03             	add    $0x3,%edx
   10339:	89 d1                	mov    %edx,%ecx
   1033b:	c1 e9 03             	shr    $0x3,%ecx
   1033e:	8b 55 0c             	mov    0xc(%ebp),%edx
   10341:	8b 12                	mov    (%edx),%edx
   10343:	83 c2 03             	add    $0x3,%edx
   10346:	c1 ea 02             	shr    $0x2,%edx
   10349:	83 ec 04             	sub    $0x4,%esp
   1034c:	50                   	push   %eax
   1034d:	51                   	push   %ecx
   1034e:	52                   	push   %edx
   1034f:	e8 1e 8f ff ff       	call   9272 <lodepng_get_raw_size_idat>
   10354:	83 c4 10             	add    $0x10,%esp
   10357:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   1035a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1035d:	8b 00                	mov    (%eax),%eax
   1035f:	83 f8 02             	cmp    $0x2,%eax
   10362:	76 2c                	jbe    10390 <decodeGeneric+0x914>
   10364:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10367:	8b 55 10             	mov    0x10(%ebp),%edx
   1036a:	8b 12                	mov    (%edx),%edx
   1036c:	83 c2 03             	add    $0x3,%edx
   1036f:	89 d1                	mov    %edx,%ecx
   10371:	c1 e9 02             	shr    $0x2,%ecx
   10374:	8b 55 0c             	mov    0xc(%ebp),%edx
   10377:	8b 12                	mov    (%edx),%edx
   10379:	83 c2 01             	add    $0x1,%edx
   1037c:	c1 ea 02             	shr    $0x2,%edx
   1037f:	83 ec 04             	sub    $0x4,%esp
   10382:	50                   	push   %eax
   10383:	51                   	push   %ecx
   10384:	52                   	push   %edx
   10385:	e8 e8 8e ff ff       	call   9272 <lodepng_get_raw_size_idat>
   1038a:	83 c4 10             	add    $0x10,%esp
   1038d:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   10390:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10393:	8b 55 10             	mov    0x10(%ebp),%edx
   10396:	8b 12                	mov    (%edx),%edx
   10398:	83 c2 01             	add    $0x1,%edx
   1039b:	89 d1                	mov    %edx,%ecx
   1039d:	c1 e9 02             	shr    $0x2,%ecx
   103a0:	8b 55 0c             	mov    0xc(%ebp),%edx
   103a3:	8b 12                	mov    (%edx),%edx
   103a5:	83 c2 01             	add    $0x1,%edx
   103a8:	d1 ea                	shr    %edx
   103aa:	83 ec 04             	sub    $0x4,%esp
   103ad:	50                   	push   %eax
   103ae:	51                   	push   %ecx
   103af:	52                   	push   %edx
   103b0:	e8 bd 8e ff ff       	call   9272 <lodepng_get_raw_size_idat>
   103b5:	83 c4 10             	add    $0x10,%esp
   103b8:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   103bb:	8b 45 0c             	mov    0xc(%ebp),%eax
   103be:	8b 00                	mov    (%eax),%eax
   103c0:	83 f8 01             	cmp    $0x1,%eax
   103c3:	76 27                	jbe    103ec <decodeGeneric+0x970>
   103c5:	8b 45 c8             	mov    -0x38(%ebp),%eax
   103c8:	8b 55 10             	mov    0x10(%ebp),%edx
   103cb:	8b 12                	mov    (%edx),%edx
   103cd:	83 c2 01             	add    $0x1,%edx
   103d0:	89 d1                	mov    %edx,%ecx
   103d2:	d1 e9                	shr    %ecx
   103d4:	8b 55 0c             	mov    0xc(%ebp),%edx
   103d7:	8b 12                	mov    (%edx),%edx
   103d9:	d1 ea                	shr    %edx
   103db:	83 ec 04             	sub    $0x4,%esp
   103de:	50                   	push   %eax
   103df:	51                   	push   %ecx
   103e0:	52                   	push   %edx
   103e1:	e8 8c 8e ff ff       	call   9272 <lodepng_get_raw_size_idat>
   103e6:	83 c4 10             	add    $0x10,%esp
   103e9:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   103ec:	8b 55 c8             	mov    -0x38(%ebp),%edx
   103ef:	8b 45 10             	mov    0x10(%ebp),%eax
   103f2:	8b 00                	mov    (%eax),%eax
   103f4:	d1 e8                	shr    %eax
   103f6:	89 c1                	mov    %eax,%ecx
   103f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   103fb:	8b 00                	mov    (%eax),%eax
   103fd:	83 ec 04             	sub    $0x4,%esp
   10400:	52                   	push   %edx
   10401:	51                   	push   %ecx
   10402:	50                   	push   %eax
   10403:	e8 6a 8e ff ff       	call   9272 <lodepng_get_raw_size_idat>
   10408:	83 c4 10             	add    $0x10,%esp
   1040b:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   1040e:	8b 45 14             	mov    0x14(%ebp),%eax
   10411:	83 ec 08             	sub    $0x8,%esp
   10414:	50                   	push   %eax
   10415:	ff 75 ec             	pushl  -0x14(%ebp)
   10418:	ff 75 d8             	pushl  -0x28(%ebp)
   1041b:	ff 75 e8             	pushl  -0x18(%ebp)
   1041e:	8d 45 c0             	lea    -0x40(%ebp),%eax
   10421:	50                   	push   %eax
   10422:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   10425:	50                   	push   %eax
   10426:	e8 87 7c ff ff       	call   80b2 <zlib_decompress>
   1042b:	83 c4 20             	add    $0x20,%esp
   1042e:	89 c2                	mov    %eax,%edx
   10430:	8b 45 14             	mov    0x14(%ebp),%eax
   10433:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10439:	8b 45 14             	mov    0x14(%ebp),%eax
   1043c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10442:	85 c0                	test   %eax,%eax
   10444:	75 15                	jne    1045b <decodeGeneric+0x9df>
   10446:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10449:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1044c:	74 0d                	je     1045b <decodeGeneric+0x9df>
   1044e:	8b 45 14             	mov    0x14(%ebp),%eax
   10451:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10458:	00 00 00 
  lodepng_free(idat);
   1045b:	83 ec 0c             	sub    $0xc,%esp
   1045e:	ff 75 d8             	pushl  -0x28(%ebp)
   10461:	e8 b2 31 ff ff       	call   3618 <lodepng_free>
   10466:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10469:	8b 45 14             	mov    0x14(%ebp),%eax
   1046c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10472:	85 c0                	test   %eax,%eax
   10474:	75 4f                	jne    104c5 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   10476:	8b 45 14             	mov    0x14(%ebp),%eax
   10479:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   1047f:	8b 45 10             	mov    0x10(%ebp),%eax
   10482:	8b 10                	mov    (%eax),%edx
   10484:	8b 45 0c             	mov    0xc(%ebp),%eax
   10487:	8b 00                	mov    (%eax),%eax
   10489:	83 ec 04             	sub    $0x4,%esp
   1048c:	51                   	push   %ecx
   1048d:	52                   	push   %edx
   1048e:	50                   	push   %eax
   1048f:	e8 be 8d ff ff       	call   9252 <lodepng_get_raw_size>
   10494:	83 c4 10             	add    $0x10,%esp
   10497:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1049a:	83 ec 0c             	sub    $0xc,%esp
   1049d:	ff 75 e4             	pushl  -0x1c(%ebp)
   104a0:	e8 52 31 ff ff       	call   35f7 <lodepng_malloc>
   104a5:	83 c4 10             	add    $0x10,%esp
   104a8:	89 c2                	mov    %eax,%edx
   104aa:	8b 45 08             	mov    0x8(%ebp),%eax
   104ad:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   104af:	8b 45 08             	mov    0x8(%ebp),%eax
   104b2:	8b 00                	mov    (%eax),%eax
   104b4:	85 c0                	test   %eax,%eax
   104b6:	75 0d                	jne    104c5 <decodeGeneric+0xa49>
   104b8:	8b 45 14             	mov    0x14(%ebp),%eax
   104bb:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   104c2:	00 00 00 
  }
  if(!state->error) {
   104c5:	8b 45 14             	mov    0x14(%ebp),%eax
   104c8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   104ce:	85 c0                	test   %eax,%eax
   104d0:	75 4c                	jne    1051e <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   104d2:	8b 45 08             	mov    0x8(%ebp),%eax
   104d5:	8b 00                	mov    (%eax),%eax
   104d7:	83 ec 04             	sub    $0x4,%esp
   104da:	ff 75 e4             	pushl  -0x1c(%ebp)
   104dd:	6a 00                	push   $0x0
   104df:	50                   	push   %eax
   104e0:	e8 83 31 ff ff       	call   3668 <lodepng_memset>
   104e5:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   104e8:	8b 45 14             	mov    0x14(%ebp),%eax
   104eb:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   104f1:	8b 45 10             	mov    0x10(%ebp),%eax
   104f4:	8b 18                	mov    (%eax),%ebx
   104f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   104f9:	8b 08                	mov    (%eax),%ecx
   104fb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   104fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10501:	8b 00                	mov    (%eax),%eax
   10503:	83 ec 0c             	sub    $0xc,%esp
   10506:	56                   	push   %esi
   10507:	53                   	push   %ebx
   10508:	51                   	push   %ecx
   10509:	52                   	push   %edx
   1050a:	50                   	push   %eax
   1050b:	e8 05 df ff ff       	call   e415 <postProcessScanlines>
   10510:	83 c4 20             	add    $0x20,%esp
   10513:	89 c2                	mov    %eax,%edx
   10515:	8b 45 14             	mov    0x14(%ebp),%eax
   10518:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   1051e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10521:	83 ec 0c             	sub    $0xc,%esp
   10524:	50                   	push   %eax
   10525:	e8 ee 30 ff ff       	call   3618 <lodepng_free>
   1052a:	83 c4 10             	add    $0x10,%esp
   1052d:	eb 01                	jmp    10530 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   1052f:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   10530:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10533:	5b                   	pop    %ebx
   10534:	5e                   	pop    %esi
   10535:	5d                   	pop    %ebp
   10536:	c3                   	ret    

00010537 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10537:	55                   	push   %ebp
   10538:	89 e5                	mov    %esp,%ebp
   1053a:	56                   	push   %esi
   1053b:	53                   	push   %ebx
   1053c:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   1053f:	8b 45 08             	mov    0x8(%ebp),%eax
   10542:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10548:	83 ec 08             	sub    $0x8,%esp
   1054b:	ff 75 1c             	pushl  0x1c(%ebp)
   1054e:	ff 75 18             	pushl  0x18(%ebp)
   10551:	ff 75 14             	pushl  0x14(%ebp)
   10554:	ff 75 10             	pushl  0x10(%ebp)
   10557:	ff 75 0c             	pushl  0xc(%ebp)
   1055a:	ff 75 08             	pushl  0x8(%ebp)
   1055d:	e8 1a f5 ff ff       	call   fa7c <decodeGeneric>
   10562:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10565:	8b 45 14             	mov    0x14(%ebp),%eax
   10568:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1056e:	85 c0                	test   %eax,%eax
   10570:	74 0e                	je     10580 <lodepng_decode+0x49>
   10572:	8b 45 14             	mov    0x14(%ebp),%eax
   10575:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1057b:	e9 55 01 00 00       	jmp    106d5 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   10580:	8b 45 14             	mov    0x14(%ebp),%eax
   10583:	8b 40 24             	mov    0x24(%eax),%eax
   10586:	85 c0                	test   %eax,%eax
   10588:	74 20                	je     105aa <lodepng_decode+0x73>
   1058a:	8b 45 14             	mov    0x14(%ebp),%eax
   1058d:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10593:	8b 45 14             	mov    0x14(%ebp),%eax
   10596:	83 c0 78             	add    $0x78,%eax
   10599:	83 ec 08             	sub    $0x8,%esp
   1059c:	52                   	push   %edx
   1059d:	50                   	push   %eax
   1059e:	e8 56 89 ff ff       	call   8ef9 <lodepng_color_mode_equal>
   105a3:	83 c4 10             	add    $0x10,%esp
   105a6:	85 c0                	test   %eax,%eax
   105a8:	74 54                	je     105fe <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   105aa:	8b 45 14             	mov    0x14(%ebp),%eax
   105ad:	8b 40 24             	mov    0x24(%eax),%eax
   105b0:	85 c0                	test   %eax,%eax
   105b2:	0f 85 13 01 00 00    	jne    106cb <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   105b8:	8b 45 14             	mov    0x14(%ebp),%eax
   105bb:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   105c1:	8b 45 14             	mov    0x14(%ebp),%eax
   105c4:	83 c0 78             	add    $0x78,%eax
   105c7:	83 ec 08             	sub    $0x8,%esp
   105ca:	52                   	push   %edx
   105cb:	50                   	push   %eax
   105cc:	e8 3f 88 ff ff       	call   8e10 <lodepng_color_mode_copy>
   105d1:	83 c4 10             	add    $0x10,%esp
   105d4:	89 c2                	mov    %eax,%edx
   105d6:	8b 45 14             	mov    0x14(%ebp),%eax
   105d9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   105df:	8b 45 14             	mov    0x14(%ebp),%eax
   105e2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   105e8:	85 c0                	test   %eax,%eax
   105ea:	0f 84 db 00 00 00    	je     106cb <lodepng_decode+0x194>
   105f0:	8b 45 14             	mov    0x14(%ebp),%eax
   105f3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   105f9:	e9 d7 00 00 00       	jmp    106d5 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   105fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10601:	8b 00                	mov    (%eax),%eax
   10603:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   10606:	8b 45 14             	mov    0x14(%ebp),%eax
   10609:	8b 40 78             	mov    0x78(%eax),%eax
   1060c:	83 f8 02             	cmp    $0x2,%eax
   1060f:	74 20                	je     10631 <lodepng_decode+0xfa>
   10611:	8b 45 14             	mov    0x14(%ebp),%eax
   10614:	8b 40 78             	mov    0x78(%eax),%eax
   10617:	83 f8 06             	cmp    $0x6,%eax
   1061a:	74 15                	je     10631 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   1061c:	8b 45 14             	mov    0x14(%ebp),%eax
   1061f:	8b 40 7c             	mov    0x7c(%eax),%eax
   10622:	83 f8 08             	cmp    $0x8,%eax
   10625:	74 0a                	je     10631 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10627:	b8 38 00 00 00       	mov    $0x38,%eax
   1062c:	e9 a4 00 00 00       	jmp    106d5 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   10631:	8b 45 14             	mov    0x14(%ebp),%eax
   10634:	8d 48 78             	lea    0x78(%eax),%ecx
   10637:	8b 45 10             	mov    0x10(%ebp),%eax
   1063a:	8b 10                	mov    (%eax),%edx
   1063c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1063f:	8b 00                	mov    (%eax),%eax
   10641:	83 ec 04             	sub    $0x4,%esp
   10644:	51                   	push   %ecx
   10645:	52                   	push   %edx
   10646:	50                   	push   %eax
   10647:	e8 06 8c ff ff       	call   9252 <lodepng_get_raw_size>
   1064c:	83 c4 10             	add    $0x10,%esp
   1064f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10652:	83 ec 0c             	sub    $0xc,%esp
   10655:	ff 75 f0             	pushl  -0x10(%ebp)
   10658:	e8 9a 2f ff ff       	call   35f7 <lodepng_malloc>
   1065d:	83 c4 10             	add    $0x10,%esp
   10660:	89 c2                	mov    %eax,%edx
   10662:	8b 45 08             	mov    0x8(%ebp),%eax
   10665:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10667:	8b 45 08             	mov    0x8(%ebp),%eax
   1066a:	8b 00                	mov    (%eax),%eax
   1066c:	85 c0                	test   %eax,%eax
   1066e:	75 0f                	jne    1067f <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   10670:	8b 45 14             	mov    0x14(%ebp),%eax
   10673:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1067a:	00 00 00 
   1067d:	eb 3c                	jmp    106bb <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1067f:	8b 45 10             	mov    0x10(%ebp),%eax
   10682:	8b 08                	mov    (%eax),%ecx
   10684:	8b 45 0c             	mov    0xc(%ebp),%eax
   10687:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10689:	8b 45 14             	mov    0x14(%ebp),%eax
   1068c:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10692:	8b 45 14             	mov    0x14(%ebp),%eax
   10695:	8d 58 78             	lea    0x78(%eax),%ebx
   10698:	8b 45 08             	mov    0x8(%ebp),%eax
   1069b:	8b 00                	mov    (%eax),%eax
   1069d:	83 ec 08             	sub    $0x8,%esp
   106a0:	51                   	push   %ecx
   106a1:	52                   	push   %edx
   106a2:	56                   	push   %esi
   106a3:	53                   	push   %ebx
   106a4:	ff 75 f4             	pushl  -0xc(%ebp)
   106a7:	50                   	push   %eax
   106a8:	e8 51 b6 ff ff       	call   bcfe <lodepng_convert>
   106ad:	83 c4 20             	add    $0x20,%esp
   106b0:	89 c2                	mov    %eax,%edx
   106b2:	8b 45 14             	mov    0x14(%ebp),%eax
   106b5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   106bb:	83 ec 0c             	sub    $0xc,%esp
   106be:	ff 75 f4             	pushl  -0xc(%ebp)
   106c1:	e8 52 2f ff ff       	call   3618 <lodepng_free>
   106c6:	83 c4 10             	add    $0x10,%esp
   106c9:	eb 01                	jmp    106cc <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   106cb:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   106cc:	8b 45 14             	mov    0x14(%ebp),%eax
   106cf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   106d5:	8d 65 f8             	lea    -0x8(%ebp),%esp
   106d8:	5b                   	pop    %ebx
   106d9:	5e                   	pop    %esi
   106da:	5d                   	pop    %ebp
   106db:	c3                   	ret    

000106dc <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   106dc:	55                   	push   %ebp
   106dd:	89 e5                	mov    %esp,%ebp
   106df:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   106e5:	83 ec 0c             	sub    $0xc,%esp
   106e8:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   106ee:	50                   	push   %eax
   106ef:	e8 d9 01 00 00       	call   108cd <lodepng_state_init>
   106f4:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   106f7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   106fa:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   10700:	8b 45 20             	mov    0x20(%ebp),%eax
   10703:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10709:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   10710:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   10713:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   1071a:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   1071d:	83 ec 08             	sub    $0x8,%esp
   10720:	ff 75 18             	pushl  0x18(%ebp)
   10723:	ff 75 14             	pushl  0x14(%ebp)
   10726:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1072c:	50                   	push   %eax
   1072d:	ff 75 10             	pushl  0x10(%ebp)
   10730:	ff 75 0c             	pushl  0xc(%ebp)
   10733:	ff 75 08             	pushl  0x8(%ebp)
   10736:	e8 fc fd ff ff       	call   10537 <lodepng_decode>
   1073b:	83 c4 20             	add    $0x20,%esp
   1073e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   10741:	83 ec 0c             	sub    $0xc,%esp
   10744:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1074a:	50                   	push   %eax
   1074b:	e8 d7 01 00 00       	call   10927 <lodepng_state_cleanup>
   10750:	83 c4 10             	add    $0x10,%esp
  return error;
   10753:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10756:	c9                   	leave  
   10757:	c3                   	ret    

00010758 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10758:	55                   	push   %ebp
   10759:	89 e5                	mov    %esp,%ebp
   1075b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   1075e:	83 ec 04             	sub    $0x4,%esp
   10761:	6a 08                	push   $0x8
   10763:	6a 06                	push   $0x6
   10765:	ff 75 18             	pushl  0x18(%ebp)
   10768:	ff 75 14             	pushl  0x14(%ebp)
   1076b:	ff 75 10             	pushl  0x10(%ebp)
   1076e:	ff 75 0c             	pushl  0xc(%ebp)
   10771:	ff 75 08             	pushl  0x8(%ebp)
   10774:	e8 63 ff ff ff       	call   106dc <lodepng_decode_memory>
   10779:	83 c4 20             	add    $0x20,%esp
}
   1077c:	c9                   	leave  
   1077d:	c3                   	ret    

0001077e <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   1077e:	55                   	push   %ebp
   1077f:	89 e5                	mov    %esp,%ebp
   10781:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   10784:	83 ec 04             	sub    $0x4,%esp
   10787:	6a 08                	push   $0x8
   10789:	6a 02                	push   $0x2
   1078b:	ff 75 18             	pushl  0x18(%ebp)
   1078e:	ff 75 14             	pushl  0x14(%ebp)
   10791:	ff 75 10             	pushl  0x10(%ebp)
   10794:	ff 75 0c             	pushl  0xc(%ebp)
   10797:	ff 75 08             	pushl  0x8(%ebp)
   1079a:	e8 3d ff ff ff       	call   106dc <lodepng_decode_memory>
   1079f:	83 c4 20             	add    $0x20,%esp
}
   107a2:	c9                   	leave  
   107a3:	c3                   	ret    

000107a4 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   107a4:	55                   	push   %ebp
   107a5:	89 e5                	mov    %esp,%ebp
   107a7:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   107aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   107b1:	8b 45 08             	mov    0x8(%ebp),%eax
   107b4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   107ba:	8b 45 10             	mov    0x10(%ebp),%eax
   107bd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   107c3:	8b 45 10             	mov    0x10(%ebp),%eax
   107c6:	8b 10                	mov    (%eax),%edx
   107c8:	8b 45 0c             	mov    0xc(%ebp),%eax
   107cb:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   107cd:	83 ec 04             	sub    $0x4,%esp
   107d0:	ff 75 14             	pushl  0x14(%ebp)
   107d3:	8d 45 ec             	lea    -0x14(%ebp),%eax
   107d6:	50                   	push   %eax
   107d7:	8d 45 f0             	lea    -0x10(%ebp),%eax
   107da:	50                   	push   %eax
   107db:	e8 70 32 ff ff       	call   3a50 <lodepng_load_file>
   107e0:	83 c4 10             	add    $0x10,%esp
   107e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   107e6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   107ea:	75 25                	jne    10811 <lodepng_decode_file+0x6d>
   107ec:	8b 55 ec             	mov    -0x14(%ebp),%edx
   107ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   107f2:	83 ec 04             	sub    $0x4,%esp
   107f5:	ff 75 1c             	pushl  0x1c(%ebp)
   107f8:	ff 75 18             	pushl  0x18(%ebp)
   107fb:	52                   	push   %edx
   107fc:	50                   	push   %eax
   107fd:	ff 75 10             	pushl  0x10(%ebp)
   10800:	ff 75 0c             	pushl  0xc(%ebp)
   10803:	ff 75 08             	pushl  0x8(%ebp)
   10806:	e8 d1 fe ff ff       	call   106dc <lodepng_decode_memory>
   1080b:	83 c4 20             	add    $0x20,%esp
   1080e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   10811:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10814:	83 ec 0c             	sub    $0xc,%esp
   10817:	50                   	push   %eax
   10818:	e8 fb 2d ff ff       	call   3618 <lodepng_free>
   1081d:	83 c4 10             	add    $0x10,%esp
  return error;
   10820:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10823:	c9                   	leave  
   10824:	c3                   	ret    

00010825 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10825:	55                   	push   %ebp
   10826:	89 e5                	mov    %esp,%ebp
   10828:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   1082b:	83 ec 08             	sub    $0x8,%esp
   1082e:	6a 08                	push   $0x8
   10830:	6a 06                	push   $0x6
   10832:	ff 75 14             	pushl  0x14(%ebp)
   10835:	ff 75 10             	pushl  0x10(%ebp)
   10838:	ff 75 0c             	pushl  0xc(%ebp)
   1083b:	ff 75 08             	pushl  0x8(%ebp)
   1083e:	e8 61 ff ff ff       	call   107a4 <lodepng_decode_file>
   10843:	83 c4 20             	add    $0x20,%esp
}
   10846:	c9                   	leave  
   10847:	c3                   	ret    

00010848 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10848:	55                   	push   %ebp
   10849:	89 e5                	mov    %esp,%ebp
   1084b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   1084e:	83 ec 08             	sub    $0x8,%esp
   10851:	6a 08                	push   $0x8
   10853:	6a 02                	push   $0x2
   10855:	ff 75 14             	pushl  0x14(%ebp)
   10858:	ff 75 10             	pushl  0x10(%ebp)
   1085b:	ff 75 0c             	pushl  0xc(%ebp)
   1085e:	ff 75 08             	pushl  0x8(%ebp)
   10861:	e8 3e ff ff ff       	call   107a4 <lodepng_decode_file>
   10866:	83 c4 20             	add    $0x20,%esp
}
   10869:	c9                   	leave  
   1086a:	c3                   	ret    

0001086b <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   1086b:	55                   	push   %ebp
   1086c:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   1086e:	8b 45 08             	mov    0x8(%ebp),%eax
   10871:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10878:	8b 45 08             	mov    0x8(%ebp),%eax
   1087b:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   10882:	8b 45 08             	mov    0x8(%ebp),%eax
   10885:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   1088c:	8b 45 08             	mov    0x8(%ebp),%eax
   1088f:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   10896:	8b 45 08             	mov    0x8(%ebp),%eax
   10899:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   108a0:	8b 45 08             	mov    0x8(%ebp),%eax
   108a3:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   108aa:	8b 45 08             	mov    0x8(%ebp),%eax
   108ad:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   108b4:	8b 45 08             	mov    0x8(%ebp),%eax
   108b7:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   108be:	8b 45 08             	mov    0x8(%ebp),%eax
   108c1:	50                   	push   %eax
   108c2:	e8 ff 7a ff ff       	call   83c6 <lodepng_decompress_settings_init>
   108c7:	83 c4 04             	add    $0x4,%esp
}
   108ca:	90                   	nop
   108cb:	c9                   	leave  
   108cc:	c3                   	ret    

000108cd <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   108cd:	55                   	push   %ebp
   108ce:	89 e5                	mov    %esp,%ebp
   108d0:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   108d3:	8b 45 08             	mov    0x8(%ebp),%eax
   108d6:	50                   	push   %eax
   108d7:	e8 8f ff ff ff       	call   1086b <lodepng_decoder_settings_init>
   108dc:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   108df:	8b 45 08             	mov    0x8(%ebp),%eax
   108e2:	83 c0 38             	add    $0x38,%eax
   108e5:	83 ec 0c             	sub    $0xc,%esp
   108e8:	50                   	push   %eax
   108e9:	e8 fc 30 00 00       	call   139ea <lodepng_encoder_settings_init>
   108ee:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   108f1:	8b 45 08             	mov    0x8(%ebp),%eax
   108f4:	83 c0 78             	add    $0x78,%eax
   108f7:	83 ec 0c             	sub    $0xc,%esp
   108fa:	50                   	push   %eax
   108fb:	e8 06 84 ff ff       	call   8d06 <lodepng_color_mode_init>
   10900:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   10903:	8b 45 08             	mov    0x8(%ebp),%eax
   10906:	05 98 00 00 00       	add    $0x98,%eax
   1090b:	83 ec 0c             	sub    $0xc,%esp
   1090e:	50                   	push   %eax
   1090f:	e8 89 93 ff ff       	call   9c9d <lodepng_info_init>
   10914:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10917:	8b 45 08             	mov    0x8(%ebp),%eax
   1091a:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   10921:	00 00 00 
}
   10924:	90                   	nop
   10925:	c9                   	leave  
   10926:	c3                   	ret    

00010927 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10927:	55                   	push   %ebp
   10928:	89 e5                	mov    %esp,%ebp
   1092a:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   1092d:	8b 45 08             	mov    0x8(%ebp),%eax
   10930:	83 c0 78             	add    $0x78,%eax
   10933:	83 ec 0c             	sub    $0xc,%esp
   10936:	50                   	push   %eax
   10937:	e8 bd 84 ff ff       	call   8df9 <lodepng_color_mode_cleanup>
   1093c:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   1093f:	8b 45 08             	mov    0x8(%ebp),%eax
   10942:	05 98 00 00 00       	add    $0x98,%eax
   10947:	83 ec 0c             	sub    $0xc,%esp
   1094a:	50                   	push   %eax
   1094b:	e8 2e 94 ff ff       	call   9d7e <lodepng_info_cleanup>
   10950:	83 c4 10             	add    $0x10,%esp
}
   10953:	90                   	nop
   10954:	c9                   	leave  
   10955:	c3                   	ret    

00010956 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10956:	55                   	push   %ebp
   10957:	89 e5                	mov    %esp,%ebp
   10959:	57                   	push   %edi
   1095a:	56                   	push   %esi
   1095b:	53                   	push   %ebx
   1095c:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   1095f:	83 ec 0c             	sub    $0xc,%esp
   10962:	ff 75 08             	pushl  0x8(%ebp)
   10965:	e8 bd ff ff ff       	call   10927 <lodepng_state_cleanup>
   1096a:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   1096d:	8b 55 08             	mov    0x8(%ebp),%edx
   10970:	8b 45 0c             	mov    0xc(%ebp),%eax
   10973:	89 c3                	mov    %eax,%ebx
   10975:	b8 60 00 00 00       	mov    $0x60,%eax
   1097a:	89 d7                	mov    %edx,%edi
   1097c:	89 de                	mov    %ebx,%esi
   1097e:	89 c1                	mov    %eax,%ecx
   10980:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   10982:	8b 45 08             	mov    0x8(%ebp),%eax
   10985:	83 c0 78             	add    $0x78,%eax
   10988:	83 ec 0c             	sub    $0xc,%esp
   1098b:	50                   	push   %eax
   1098c:	e8 75 83 ff ff       	call   8d06 <lodepng_color_mode_init>
   10991:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   10994:	8b 45 08             	mov    0x8(%ebp),%eax
   10997:	05 98 00 00 00       	add    $0x98,%eax
   1099c:	83 ec 0c             	sub    $0xc,%esp
   1099f:	50                   	push   %eax
   109a0:	e8 f8 92 ff ff       	call   9c9d <lodepng_info_init>
   109a5:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   109a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   109ab:	8d 50 78             	lea    0x78(%eax),%edx
   109ae:	8b 45 08             	mov    0x8(%ebp),%eax
   109b1:	83 c0 78             	add    $0x78,%eax
   109b4:	83 ec 08             	sub    $0x8,%esp
   109b7:	52                   	push   %edx
   109b8:	50                   	push   %eax
   109b9:	e8 52 84 ff ff       	call   8e10 <lodepng_color_mode_copy>
   109be:	83 c4 10             	add    $0x10,%esp
   109c1:	89 c2                	mov    %eax,%edx
   109c3:	8b 45 08             	mov    0x8(%ebp),%eax
   109c6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   109cc:	8b 45 08             	mov    0x8(%ebp),%eax
   109cf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   109d5:	85 c0                	test   %eax,%eax
   109d7:	75 36                	jne    10a0f <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   109d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   109dc:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   109e2:	8b 45 08             	mov    0x8(%ebp),%eax
   109e5:	05 98 00 00 00       	add    $0x98,%eax
   109ea:	83 ec 08             	sub    $0x8,%esp
   109ed:	52                   	push   %edx
   109ee:	50                   	push   %eax
   109ef:	e8 dd 93 ff ff       	call   9dd1 <lodepng_info_copy>
   109f4:	83 c4 10             	add    $0x10,%esp
   109f7:	89 c2                	mov    %eax,%edx
   109f9:	8b 45 08             	mov    0x8(%ebp),%eax
   109fc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10a02:	8b 45 08             	mov    0x8(%ebp),%eax
   10a05:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10a0b:	85 c0                	test   %eax,%eax
   10a0d:	eb 01                	jmp    10a10 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10a0f:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   10a10:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10a13:	5b                   	pop    %ebx
   10a14:	5e                   	pop    %esi
   10a15:	5f                   	pop    %edi
   10a16:	5d                   	pop    %ebp
   10a17:	c3                   	ret    

00010a18 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10a18:	55                   	push   %ebp
   10a19:	89 e5                	mov    %esp,%ebp
   10a1b:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   10a1e:	8b 45 08             	mov    0x8(%ebp),%eax
   10a21:	8b 40 04             	mov    0x4(%eax),%eax
   10a24:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10a27:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10a2b:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   10a2f:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   10a33:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10a37:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10a3b:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   10a3f:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   10a43:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10a47:	8b 45 08             	mov    0x8(%ebp),%eax
   10a4a:	8b 40 04             	mov    0x4(%eax),%eax
   10a4d:	83 c0 08             	add    $0x8,%eax
   10a50:	50                   	push   %eax
   10a51:	ff 75 08             	pushl  0x8(%ebp)
   10a54:	e8 f8 2d ff ff       	call   3851 <ucvector_resize>
   10a59:	83 c4 08             	add    $0x8,%esp
   10a5c:	85 c0                	test   %eax,%eax
   10a5e:	75 07                	jne    10a67 <writeSignature+0x4f>
   10a60:	b8 53 00 00 00       	mov    $0x53,%eax
   10a65:	eb 1e                	jmp    10a85 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10a67:	8b 45 08             	mov    0x8(%ebp),%eax
   10a6a:	8b 10                	mov    (%eax),%edx
   10a6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a6f:	01 c2                	add    %eax,%edx
   10a71:	6a 08                	push   $0x8
   10a73:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10a76:	50                   	push   %eax
   10a77:	52                   	push   %edx
   10a78:	e8 b8 2b ff ff       	call   3635 <lodepng_memcpy>
   10a7d:	83 c4 0c             	add    $0xc,%esp
  return 0;
   10a80:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10a85:	c9                   	leave  
   10a86:	c3                   	ret    

00010a87 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   10a87:	55                   	push   %ebp
   10a88:	89 e5                	mov    %esp,%ebp
   10a8a:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10a8d:	68 4c a3 01 00       	push   $0x1a34c
   10a92:	6a 0d                	push   $0xd
   10a94:	ff 75 08             	pushl  0x8(%ebp)
   10a97:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10a9a:	50                   	push   %eax
   10a9b:	e8 cf 7f ff ff       	call   8a6f <lodepng_chunk_init>
   10aa0:	83 c4 10             	add    $0x10,%esp
   10aa3:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10aa6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10aaa:	74 05                	je     10ab1 <addChunk_IHDR+0x2a>
   10aac:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10aaf:	eb 6d                	jmp    10b1e <addChunk_IHDR+0x97>
  data = chunk + 8;
   10ab1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ab4:	83 c0 08             	add    $0x8,%eax
   10ab7:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10aba:	ff 75 0c             	pushl  0xc(%ebp)
   10abd:	ff 75 f8             	pushl  -0x8(%ebp)
   10ac0:	e8 f3 2e ff ff       	call   39b8 <lodepng_set32bitInt>
   10ac5:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   10ac8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10acb:	83 c0 04             	add    $0x4,%eax
   10ace:	ff 75 10             	pushl  0x10(%ebp)
   10ad1:	50                   	push   %eax
   10ad2:	e8 e1 2e ff ff       	call   39b8 <lodepng_set32bitInt>
   10ad7:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10ada:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10add:	83 c0 08             	add    $0x8,%eax
   10ae0:	8b 55 18             	mov    0x18(%ebp),%edx
   10ae3:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   10ae5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10ae8:	83 c0 09             	add    $0x9,%eax
   10aeb:	8b 55 14             	mov    0x14(%ebp),%edx
   10aee:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   10af0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10af3:	83 c0 0a             	add    $0xa,%eax
   10af6:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10af9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10afc:	83 c0 0b             	add    $0xb,%eax
   10aff:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   10b02:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10b05:	83 c0 0c             	add    $0xc,%eax
   10b08:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10b0b:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b10:	50                   	push   %eax
   10b11:	e8 02 7c ff ff       	call   8718 <lodepng_chunk_generate_crc>
   10b16:	83 c4 04             	add    $0x4,%esp
  return 0;
   10b19:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b1e:	c9                   	leave  
   10b1f:	c3                   	ret    

00010b20 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   10b20:	55                   	push   %ebp
   10b21:	89 e5                	mov    %esp,%ebp
   10b23:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10b26:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10b2d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b30:	8b 50 0c             	mov    0xc(%eax),%edx
   10b33:	89 d0                	mov    %edx,%eax
   10b35:	01 c0                	add    %eax,%eax
   10b37:	01 d0                	add    %edx,%eax
   10b39:	68 68 a3 01 00       	push   $0x1a368
   10b3e:	50                   	push   %eax
   10b3f:	ff 75 08             	pushl  0x8(%ebp)
   10b42:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10b45:	50                   	push   %eax
   10b46:	e8 24 7f ff ff       	call   8a6f <lodepng_chunk_init>
   10b4b:	83 c4 10             	add    $0x10,%esp
   10b4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10b51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10b55:	74 08                	je     10b5f <addChunk_PLTE+0x3f>
   10b57:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b5a:	e9 95 00 00 00       	jmp    10bf4 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   10b5f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10b66:	eb 70                	jmp    10bd8 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10b68:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10b6b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10b6e:	8d 50 01             	lea    0x1(%eax),%edx
   10b71:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10b74:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10b77:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b7a:	8b 40 08             	mov    0x8(%eax),%eax
   10b7d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10b80:	c1 e1 02             	shl    $0x2,%ecx
   10b83:	01 c8                	add    %ecx,%eax
   10b85:	0f b6 00             	movzbl (%eax),%eax
   10b88:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10b8a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10b8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10b90:	8d 50 01             	lea    0x1(%eax),%edx
   10b93:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10b96:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10b99:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b9c:	8b 40 08             	mov    0x8(%eax),%eax
   10b9f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10ba2:	c1 e1 02             	shl    $0x2,%ecx
   10ba5:	83 c1 01             	add    $0x1,%ecx
   10ba8:	01 c8                	add    %ecx,%eax
   10baa:	0f b6 00             	movzbl (%eax),%eax
   10bad:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   10baf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10bb2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bb5:	8d 50 01             	lea    0x1(%eax),%edx
   10bb8:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10bbb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10bbe:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bc1:	8b 40 08             	mov    0x8(%eax),%eax
   10bc4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10bc7:	c1 e1 02             	shl    $0x2,%ecx
   10bca:	83 c1 02             	add    $0x2,%ecx
   10bcd:	01 c8                	add    %ecx,%eax
   10bcf:	0f b6 00             	movzbl (%eax),%eax
   10bd2:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   10bd4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10bd8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bdb:	8b 40 0c             	mov    0xc(%eax),%eax
   10bde:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   10be1:	75 85                	jne    10b68 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   10be3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10be6:	50                   	push   %eax
   10be7:	e8 2c 7b ff ff       	call   8718 <lodepng_chunk_generate_crc>
   10bec:	83 c4 04             	add    $0x4,%esp
  return 0;
   10bef:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10bf4:	c9                   	leave  
   10bf5:	c3                   	ret    

00010bf6 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10bf6:	55                   	push   %ebp
   10bf7:	89 e5                	mov    %esp,%ebp
   10bf9:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10bfc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   10c03:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c06:	8b 00                	mov    (%eax),%eax
   10c08:	83 f8 03             	cmp    $0x3,%eax
   10c0b:	0f 85 ae 00 00 00    	jne    10cbf <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   10c11:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c14:	8b 40 0c             	mov    0xc(%eax),%eax
   10c17:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10c1a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c1d:	8b 40 0c             	mov    0xc(%eax),%eax
   10c20:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10c23:	eb 23                	jmp    10c48 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10c25:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c28:	8b 40 08             	mov    0x8(%eax),%eax
   10c2b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c2e:	83 ea 01             	sub    $0x1,%edx
   10c31:	c1 e2 02             	shl    $0x2,%edx
   10c34:	83 c2 03             	add    $0x3,%edx
   10c37:	01 d0                	add    %edx,%eax
   10c39:	0f b6 00             	movzbl (%eax),%eax
   10c3c:	3c ff                	cmp    $0xff,%al
   10c3e:	75 10                	jne    10c50 <addChunk_tRNS+0x5a>
      --amount;
   10c40:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10c44:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10c48:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10c4c:	75 d7                	jne    10c25 <addChunk_tRNS+0x2f>
   10c4e:	eb 01                	jmp    10c51 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10c50:	90                   	nop
      --amount;
    }
    if(amount) {
   10c51:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10c55:	0f 84 63 01 00 00    	je     10dbe <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10c5b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10c5e:	68 6d a3 01 00       	push   $0x1a36d
   10c63:	50                   	push   %eax
   10c64:	ff 75 08             	pushl  0x8(%ebp)
   10c67:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10c6a:	50                   	push   %eax
   10c6b:	e8 ff 7d ff ff       	call   8a6f <lodepng_chunk_init>
   10c70:	83 c4 10             	add    $0x10,%esp
   10c73:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10c76:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c7a:	74 08                	je     10c84 <addChunk_tRNS+0x8e>
   10c7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c7f:	e9 52 01 00 00       	jmp    10dd6 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   10c84:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10c8b:	eb 25                	jmp    10cb2 <addChunk_tRNS+0xbc>
   10c8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c90:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c93:	83 c2 08             	add    $0x8,%edx
   10c96:	01 c2                	add    %eax,%edx
   10c98:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c9b:	8b 40 08             	mov    0x8(%eax),%eax
   10c9e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10ca1:	c1 e1 02             	shl    $0x2,%ecx
   10ca4:	83 c1 03             	add    $0x3,%ecx
   10ca7:	01 c8                	add    %ecx,%eax
   10ca9:	0f b6 00             	movzbl (%eax),%eax
   10cac:	88 02                	mov    %al,(%edx)
   10cae:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10cb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10cb5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10cb8:	75 d3                	jne    10c8d <addChunk_tRNS+0x97>
   10cba:	e9 ff 00 00 00       	jmp    10dbe <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10cbf:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cc2:	8b 00                	mov    (%eax),%eax
   10cc4:	85 c0                	test   %eax,%eax
   10cc6:	75 59                	jne    10d21 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10cc8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ccb:	8b 40 10             	mov    0x10(%eax),%eax
   10cce:	85 c0                	test   %eax,%eax
   10cd0:	0f 84 e8 00 00 00    	je     10dbe <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10cd6:	68 6d a3 01 00       	push   $0x1a36d
   10cdb:	6a 02                	push   $0x2
   10cdd:	ff 75 08             	pushl  0x8(%ebp)
   10ce0:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10ce3:	50                   	push   %eax
   10ce4:	e8 86 7d ff ff       	call   8a6f <lodepng_chunk_init>
   10ce9:	83 c4 10             	add    $0x10,%esp
   10cec:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10cef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10cf3:	74 08                	je     10cfd <addChunk_tRNS+0x107>
   10cf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cf8:	e9 d9 00 00 00       	jmp    10dd6 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10cfd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d00:	8d 50 08             	lea    0x8(%eax),%edx
   10d03:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d06:	8b 40 14             	mov    0x14(%eax),%eax
   10d09:	c1 e8 08             	shr    $0x8,%eax
   10d0c:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10d0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d11:	8d 50 09             	lea    0x9(%eax),%edx
   10d14:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d17:	8b 40 14             	mov    0x14(%eax),%eax
   10d1a:	88 02                	mov    %al,(%edx)
   10d1c:	e9 9d 00 00 00       	jmp    10dbe <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10d21:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d24:	8b 00                	mov    (%eax),%eax
   10d26:	83 f8 02             	cmp    $0x2,%eax
   10d29:	0f 85 8f 00 00 00    	jne    10dbe <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10d2f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d32:	8b 40 10             	mov    0x10(%eax),%eax
   10d35:	85 c0                	test   %eax,%eax
   10d37:	0f 84 81 00 00 00    	je     10dbe <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10d3d:	68 6d a3 01 00       	push   $0x1a36d
   10d42:	6a 06                	push   $0x6
   10d44:	ff 75 08             	pushl  0x8(%ebp)
   10d47:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10d4a:	50                   	push   %eax
   10d4b:	e8 1f 7d ff ff       	call   8a6f <lodepng_chunk_init>
   10d50:	83 c4 10             	add    $0x10,%esp
   10d53:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10d56:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10d5a:	74 05                	je     10d61 <addChunk_tRNS+0x16b>
   10d5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d5f:	eb 75                	jmp    10dd6 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10d61:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d64:	8d 50 08             	lea    0x8(%eax),%edx
   10d67:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d6a:	8b 40 14             	mov    0x14(%eax),%eax
   10d6d:	c1 e8 08             	shr    $0x8,%eax
   10d70:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10d72:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d75:	8d 50 09             	lea    0x9(%eax),%edx
   10d78:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d7b:	8b 40 14             	mov    0x14(%eax),%eax
   10d7e:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10d80:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d83:	8d 50 0a             	lea    0xa(%eax),%edx
   10d86:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d89:	8b 40 18             	mov    0x18(%eax),%eax
   10d8c:	c1 e8 08             	shr    $0x8,%eax
   10d8f:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10d91:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d94:	8d 50 0b             	lea    0xb(%eax),%edx
   10d97:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d9a:	8b 40 18             	mov    0x18(%eax),%eax
   10d9d:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10d9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10da2:	8d 50 0c             	lea    0xc(%eax),%edx
   10da5:	8b 45 0c             	mov    0xc(%ebp),%eax
   10da8:	8b 40 1c             	mov    0x1c(%eax),%eax
   10dab:	c1 e8 08             	shr    $0x8,%eax
   10dae:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10db0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10db3:	8d 50 0d             	lea    0xd(%eax),%edx
   10db6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10db9:	8b 40 1c             	mov    0x1c(%eax),%eax
   10dbc:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10dbe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10dc1:	85 c0                	test   %eax,%eax
   10dc3:	74 0c                	je     10dd1 <addChunk_tRNS+0x1db>
   10dc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10dc8:	50                   	push   %eax
   10dc9:	e8 4a 79 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   10dce:	83 c4 04             	add    $0x4,%esp
  return 0;
   10dd1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10dd6:	c9                   	leave  
   10dd7:	c3                   	ret    

00010dd8 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10dd8:	55                   	push   %ebp
   10dd9:	89 e5                	mov    %esp,%ebp
   10ddb:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10dde:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10de5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10dec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10df3:	83 ec 0c             	sub    $0xc,%esp
   10df6:	ff 75 14             	pushl  0x14(%ebp)
   10df9:	ff 75 10             	pushl  0x10(%ebp)
   10dfc:	ff 75 0c             	pushl  0xc(%ebp)
   10dff:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10e02:	50                   	push   %eax
   10e03:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10e06:	50                   	push   %eax
   10e07:	e8 fb 74 ff ff       	call   8307 <zlib_compress>
   10e0c:	83 c4 20             	add    $0x20,%esp
   10e0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10e12:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e16:	75 1b                	jne    10e33 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e1b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e1e:	50                   	push   %eax
   10e1f:	68 a4 a3 01 00       	push   $0x1a3a4
   10e24:	52                   	push   %edx
   10e25:	ff 75 08             	pushl  0x8(%ebp)
   10e28:	e8 ea 7c ff ff       	call   8b17 <lodepng_chunk_createv>
   10e2d:	83 c4 10             	add    $0x10,%esp
   10e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10e33:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e36:	83 ec 0c             	sub    $0xc,%esp
   10e39:	50                   	push   %eax
   10e3a:	e8 d9 27 ff ff       	call   3618 <lodepng_free>
   10e3f:	83 c4 10             	add    $0x10,%esp
  return error;
   10e42:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10e45:	c9                   	leave  
   10e46:	c3                   	ret    

00010e47 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10e47:	55                   	push   %ebp
   10e48:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10e4a:	6a 00                	push   $0x0
   10e4c:	68 a9 a3 01 00       	push   $0x1a3a9
   10e51:	6a 00                	push   $0x0
   10e53:	ff 75 08             	pushl  0x8(%ebp)
   10e56:	e8 bc 7c ff ff       	call   8b17 <lodepng_chunk_createv>
   10e5b:	83 c4 10             	add    $0x10,%esp
}
   10e5e:	c9                   	leave  
   10e5f:	c3                   	ret    

00010e60 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10e60:	55                   	push   %ebp
   10e61:	89 e5                	mov    %esp,%ebp
   10e63:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10e66:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10e6d:	ff 75 0c             	pushl  0xc(%ebp)
   10e70:	e8 1e 28 ff ff       	call   3693 <lodepng_strlen>
   10e75:	83 c4 04             	add    $0x4,%esp
   10e78:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10e7b:	ff 75 10             	pushl  0x10(%ebp)
   10e7e:	e8 10 28 ff ff       	call   3693 <lodepng_strlen>
   10e83:	83 c4 04             	add    $0x4,%esp
   10e86:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10e89:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10e8c:	8d 50 01             	lea    0x1(%eax),%edx
   10e8f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10e92:	01 d0                	add    %edx,%eax
   10e94:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10e97:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10e9b:	7e 06                	jle    10ea3 <addChunk_tEXt+0x43>
   10e9d:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10ea1:	7e 07                	jle    10eaa <addChunk_tEXt+0x4a>
   10ea3:	b8 59 00 00 00       	mov    $0x59,%eax
   10ea8:	eb 74                	jmp    10f1e <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10eaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ead:	68 77 a3 01 00       	push   $0x1a377
   10eb2:	50                   	push   %eax
   10eb3:	ff 75 08             	pushl  0x8(%ebp)
   10eb6:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10eb9:	50                   	push   %eax
   10eba:	e8 b0 7b ff ff       	call   8a6f <lodepng_chunk_init>
   10ebf:	83 c4 10             	add    $0x10,%esp
   10ec2:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10ec5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10ec9:	74 05                	je     10ed0 <addChunk_tEXt+0x70>
   10ecb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ece:	eb 4e                	jmp    10f1e <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10ed0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ed3:	83 c0 08             	add    $0x8,%eax
   10ed6:	ff 75 fc             	pushl  -0x4(%ebp)
   10ed9:	ff 75 0c             	pushl  0xc(%ebp)
   10edc:	50                   	push   %eax
   10edd:	e8 53 27 ff ff       	call   3635 <lodepng_memcpy>
   10ee2:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10ee5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ee8:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10eeb:	83 c2 08             	add    $0x8,%edx
   10eee:	01 d0                	add    %edx,%eax
   10ef0:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10ef3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ef6:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10ef9:	83 c2 09             	add    $0x9,%edx
   10efc:	01 d0                	add    %edx,%eax
   10efe:	ff 75 f8             	pushl  -0x8(%ebp)
   10f01:	ff 75 10             	pushl  0x10(%ebp)
   10f04:	50                   	push   %eax
   10f05:	e8 2b 27 ff ff       	call   3635 <lodepng_memcpy>
   10f0a:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10f0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10f10:	50                   	push   %eax
   10f11:	e8 02 78 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   10f16:	83 c4 04             	add    $0x4,%esp
  return 0;
   10f19:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10f1e:	c9                   	leave  
   10f1f:	c3                   	ret    

00010f20 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10f20:	55                   	push   %ebp
   10f21:	89 e5                	mov    %esp,%ebp
   10f23:	53                   	push   %ebx
   10f24:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10f27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10f2e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10f35:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10f3c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10f43:	ff 75 10             	pushl  0x10(%ebp)
   10f46:	e8 48 27 ff ff       	call   3693 <lodepng_strlen>
   10f4b:	83 c4 04             	add    $0x4,%esp
   10f4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10f51:	ff 75 0c             	pushl  0xc(%ebp)
   10f54:	e8 3a 27 ff ff       	call   3693 <lodepng_strlen>
   10f59:	83 c4 04             	add    $0x4,%esp
   10f5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10f5f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10f63:	7e 06                	jle    10f6b <addChunk_zTXt+0x4b>
   10f65:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10f69:	7e 0a                	jle    10f75 <addChunk_zTXt+0x55>
   10f6b:	b8 59 00 00 00       	mov    $0x59,%eax
   10f70:	e9 c8 00 00 00       	jmp    1103d <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10f75:	83 ec 0c             	sub    $0xc,%esp
   10f78:	ff 75 14             	pushl  0x14(%ebp)
   10f7b:	ff 75 f0             	pushl  -0x10(%ebp)
   10f7e:	ff 75 10             	pushl  0x10(%ebp)
   10f81:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10f84:	50                   	push   %eax
   10f85:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10f88:	50                   	push   %eax
   10f89:	e8 79 73 ff ff       	call   8307 <zlib_compress>
   10f8e:	83 c4 20             	add    $0x20,%esp
   10f91:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10f94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f98:	75 29                	jne    10fc3 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10f9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10f9d:	8d 50 02             	lea    0x2(%eax),%edx
   10fa0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fa3:	01 d0                	add    %edx,%eax
   10fa5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10fa8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10fab:	68 7c a3 01 00       	push   $0x1a37c
   10fb0:	50                   	push   %eax
   10fb1:	ff 75 08             	pushl  0x8(%ebp)
   10fb4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10fb7:	50                   	push   %eax
   10fb8:	e8 b2 7a ff ff       	call   8a6f <lodepng_chunk_init>
   10fbd:	83 c4 10             	add    $0x10,%esp
   10fc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10fc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10fc7:	75 62                	jne    1102b <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10fc9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10fcc:	83 c0 08             	add    $0x8,%eax
   10fcf:	83 ec 04             	sub    $0x4,%esp
   10fd2:	ff 75 ec             	pushl  -0x14(%ebp)
   10fd5:	ff 75 0c             	pushl  0xc(%ebp)
   10fd8:	50                   	push   %eax
   10fd9:	e8 57 26 ff ff       	call   3635 <lodepng_memcpy>
   10fde:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10fe1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10fe4:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10fe7:	83 c2 08             	add    $0x8,%edx
   10fea:	01 d0                	add    %edx,%eax
   10fec:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10fef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ff2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10ff5:	83 c2 09             	add    $0x9,%edx
   10ff8:	01 d0                	add    %edx,%eax
   10ffa:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10ffd:	8b 55 dc             	mov    -0x24(%ebp),%edx
   11000:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11003:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11006:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   11009:	83 c3 0a             	add    $0xa,%ebx
   1100c:	01 d9                	add    %ebx,%ecx
   1100e:	83 ec 04             	sub    $0x4,%esp
   11011:	52                   	push   %edx
   11012:	50                   	push   %eax
   11013:	51                   	push   %ecx
   11014:	e8 1c 26 ff ff       	call   3635 <lodepng_memcpy>
   11019:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   1101c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1101f:	83 ec 0c             	sub    $0xc,%esp
   11022:	50                   	push   %eax
   11023:	e8 f0 76 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   11028:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1102b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1102e:	83 ec 0c             	sub    $0xc,%esp
   11031:	50                   	push   %eax
   11032:	e8 e1 25 ff ff       	call   3618 <lodepng_free>
   11037:	83 c4 10             	add    $0x10,%esp
  return error;
   1103a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1103d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11040:	c9                   	leave  
   11041:	c3                   	ret    

00011042 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   11042:	55                   	push   %ebp
   11043:	89 e5                	mov    %esp,%ebp
   11045:	53                   	push   %ebx
   11046:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   11049:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11050:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   11057:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   1105e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11065:	ff 75 1c             	pushl  0x1c(%ebp)
   11068:	e8 26 26 ff ff       	call   3693 <lodepng_strlen>
   1106d:	83 c4 04             	add    $0x4,%esp
   11070:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   11073:	ff 75 10             	pushl  0x10(%ebp)
   11076:	e8 18 26 ff ff       	call   3693 <lodepng_strlen>
   1107b:	83 c4 04             	add    $0x4,%esp
   1107e:	89 45 ec             	mov    %eax,-0x14(%ebp)
   11081:	ff 75 14             	pushl  0x14(%ebp)
   11084:	e8 0a 26 ff ff       	call   3693 <lodepng_strlen>
   11089:	83 c4 04             	add    $0x4,%esp
   1108c:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1108f:	ff 75 18             	pushl  0x18(%ebp)
   11092:	e8 fc 25 ff ff       	call   3693 <lodepng_strlen>
   11097:	83 c4 04             	add    $0x4,%esp
   1109a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1109d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   110a1:	7e 06                	jle    110a9 <addChunk_iTXt+0x67>
   110a3:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   110a7:	7e 0a                	jle    110b3 <addChunk_iTXt+0x71>
   110a9:	b8 59 00 00 00       	mov    $0x59,%eax
   110ae:	e9 9a 01 00 00       	jmp    1124d <addChunk_iTXt+0x20b>

  if(compress) {
   110b3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   110b7:	74 1f                	je     110d8 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   110b9:	83 ec 0c             	sub    $0xc,%esp
   110bc:	ff 75 20             	pushl  0x20(%ebp)
   110bf:	ff 75 f0             	pushl  -0x10(%ebp)
   110c2:	ff 75 1c             	pushl  0x1c(%ebp)
   110c5:	8d 45 d0             	lea    -0x30(%ebp),%eax
   110c8:	50                   	push   %eax
   110c9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   110cc:	50                   	push   %eax
   110cd:	e8 35 72 ff ff       	call   8307 <zlib_compress>
   110d2:	83 c4 20             	add    $0x20,%esp
   110d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   110d8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   110dc:	75 44                	jne    11122 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   110de:	8b 45 ec             	mov    -0x14(%ebp),%eax
   110e1:	8d 50 03             	lea    0x3(%eax),%edx
   110e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   110e7:	01 d0                	add    %edx,%eax
   110e9:	8d 50 01             	lea    0x1(%eax),%edx
   110ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   110ef:	01 d0                	add    %edx,%eax
   110f1:	8d 50 01             	lea    0x1(%eax),%edx
   110f4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   110f8:	74 05                	je     110ff <addChunk_iTXt+0xbd>
   110fa:	8b 45 d0             	mov    -0x30(%ebp),%eax
   110fd:	eb 03                	jmp    11102 <addChunk_iTXt+0xc0>
   110ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11102:	01 d0                	add    %edx,%eax
   11104:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   11107:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1110a:	68 81 a3 01 00       	push   $0x1a381
   1110f:	50                   	push   %eax
   11110:	ff 75 08             	pushl  0x8(%ebp)
   11113:	8d 45 d8             	lea    -0x28(%ebp),%eax
   11116:	50                   	push   %eax
   11117:	e8 53 79 ff ff       	call   8a6f <lodepng_chunk_init>
   1111c:	83 c4 10             	add    $0x10,%esp
   1111f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11122:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11126:	0f 85 0f 01 00 00    	jne    1123b <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   1112c:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   11133:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11136:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11139:	01 d0                	add    %edx,%eax
   1113b:	83 ec 04             	sub    $0x4,%esp
   1113e:	ff 75 ec             	pushl  -0x14(%ebp)
   11141:	ff 75 10             	pushl  0x10(%ebp)
   11144:	50                   	push   %eax
   11145:	e8 eb 24 ff ff       	call   3635 <lodepng_memcpy>
   1114a:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   1114d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11150:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11153:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11156:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11159:	8d 50 01             	lea    0x1(%eax),%edx
   1115c:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1115f:	01 c8                	add    %ecx,%eax
   11161:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   11164:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11167:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1116a:	8d 50 01             	lea    0x1(%eax),%edx
   1116d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11170:	01 c8                	add    %ecx,%eax
   11172:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11176:	0f 95 c2             	setne  %dl
   11179:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   1117b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1117e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11181:	8d 50 01             	lea    0x1(%eax),%edx
   11184:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11187:	01 c8                	add    %ecx,%eax
   11189:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   1118c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1118f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11192:	01 d0                	add    %edx,%eax
   11194:	83 ec 04             	sub    $0x4,%esp
   11197:	ff 75 e8             	pushl  -0x18(%ebp)
   1119a:	ff 75 14             	pushl  0x14(%ebp)
   1119d:	50                   	push   %eax
   1119e:	e8 92 24 ff ff       	call   3635 <lodepng_memcpy>
   111a3:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   111a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111a9:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   111ac:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   111af:	8b 45 dc             	mov    -0x24(%ebp),%eax
   111b2:	8d 50 01             	lea    0x1(%eax),%edx
   111b5:	89 55 dc             	mov    %edx,-0x24(%ebp)
   111b8:	01 c8                	add    %ecx,%eax
   111ba:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   111bd:	8b 55 d8             	mov    -0x28(%ebp),%edx
   111c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   111c3:	01 d0                	add    %edx,%eax
   111c5:	83 ec 04             	sub    $0x4,%esp
   111c8:	ff 75 e4             	pushl  -0x1c(%ebp)
   111cb:	ff 75 18             	pushl  0x18(%ebp)
   111ce:	50                   	push   %eax
   111cf:	e8 61 24 ff ff       	call   3635 <lodepng_memcpy>
   111d4:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   111d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   111da:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   111dd:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   111e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   111e3:	8d 50 01             	lea    0x1(%eax),%edx
   111e6:	89 55 dc             	mov    %edx,-0x24(%ebp)
   111e9:	01 c8                	add    %ecx,%eax
   111eb:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   111ee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   111f2:	74 1e                	je     11212 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   111f4:	8b 55 d0             	mov    -0x30(%ebp),%edx
   111f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   111fa:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   111fd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   11200:	01 d9                	add    %ebx,%ecx
   11202:	83 ec 04             	sub    $0x4,%esp
   11205:	52                   	push   %edx
   11206:	50                   	push   %eax
   11207:	51                   	push   %ecx
   11208:	e8 28 24 ff ff       	call   3635 <lodepng_memcpy>
   1120d:	83 c4 10             	add    $0x10,%esp
   11210:	eb 1a                	jmp    1122c <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   11212:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11215:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11218:	01 d0                	add    %edx,%eax
   1121a:	83 ec 04             	sub    $0x4,%esp
   1121d:	ff 75 f0             	pushl  -0x10(%ebp)
   11220:	ff 75 1c             	pushl  0x1c(%ebp)
   11223:	50                   	push   %eax
   11224:	e8 0c 24 ff ff       	call   3635 <lodepng_memcpy>
   11229:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   1122c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1122f:	83 ec 0c             	sub    $0xc,%esp
   11232:	50                   	push   %eax
   11233:	e8 e0 74 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   11238:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1123b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1123e:	83 ec 0c             	sub    $0xc,%esp
   11241:	50                   	push   %eax
   11242:	e8 d1 23 ff ff       	call   3618 <lodepng_free>
   11247:	83 c4 10             	add    $0x10,%esp
  return error;
   1124a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1124d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11250:	c9                   	leave  
   11251:	c3                   	ret    

00011252 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   11252:	55                   	push   %ebp
   11253:	89 e5                	mov    %esp,%ebp
   11255:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   11258:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   1125f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11262:	8b 40 0c             	mov    0xc(%eax),%eax
   11265:	85 c0                	test   %eax,%eax
   11267:	74 0b                	je     11274 <addChunk_bKGD+0x22>
   11269:	8b 45 0c             	mov    0xc(%ebp),%eax
   1126c:	8b 40 0c             	mov    0xc(%eax),%eax
   1126f:	83 f8 04             	cmp    $0x4,%eax
   11272:	75 4b                	jne    112bf <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   11274:	68 72 a3 01 00       	push   $0x1a372
   11279:	6a 02                	push   $0x2
   1127b:	ff 75 08             	pushl  0x8(%ebp)
   1127e:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11281:	50                   	push   %eax
   11282:	e8 e8 77 ff ff       	call   8a6f <lodepng_chunk_init>
   11287:	83 c4 10             	add    $0x10,%esp
   1128a:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1128d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11291:	74 08                	je     1129b <addChunk_bKGD+0x49>
   11293:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11296:	e9 19 01 00 00       	jmp    113b4 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   1129b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1129e:	8d 50 08             	lea    0x8(%eax),%edx
   112a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   112a4:	8b 40 30             	mov    0x30(%eax),%eax
   112a7:	c1 e8 08             	shr    $0x8,%eax
   112aa:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   112ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   112af:	8d 50 09             	lea    0x9(%eax),%edx
   112b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   112b5:	8b 40 30             	mov    0x30(%eax),%eax
   112b8:	88 02                	mov    %al,(%edx)
   112ba:	e9 dd 00 00 00       	jmp    1139c <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   112bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   112c2:	8b 40 0c             	mov    0xc(%eax),%eax
   112c5:	83 f8 02             	cmp    $0x2,%eax
   112c8:	74 0f                	je     112d9 <addChunk_bKGD+0x87>
   112ca:	8b 45 0c             	mov    0xc(%ebp),%eax
   112cd:	8b 40 0c             	mov    0xc(%eax),%eax
   112d0:	83 f8 06             	cmp    $0x6,%eax
   112d3:	0f 85 86 00 00 00    	jne    1135f <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   112d9:	68 72 a3 01 00       	push   $0x1a372
   112de:	6a 06                	push   $0x6
   112e0:	ff 75 08             	pushl  0x8(%ebp)
   112e3:	8d 45 f0             	lea    -0x10(%ebp),%eax
   112e6:	50                   	push   %eax
   112e7:	e8 83 77 ff ff       	call   8a6f <lodepng_chunk_init>
   112ec:	83 c4 10             	add    $0x10,%esp
   112ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
   112f2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   112f6:	74 08                	je     11300 <addChunk_bKGD+0xae>
   112f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112fb:	e9 b4 00 00 00       	jmp    113b4 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11300:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11303:	8d 50 08             	lea    0x8(%eax),%edx
   11306:	8b 45 0c             	mov    0xc(%ebp),%eax
   11309:	8b 40 30             	mov    0x30(%eax),%eax
   1130c:	c1 e8 08             	shr    $0x8,%eax
   1130f:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11311:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11314:	8d 50 09             	lea    0x9(%eax),%edx
   11317:	8b 45 0c             	mov    0xc(%ebp),%eax
   1131a:	8b 40 30             	mov    0x30(%eax),%eax
   1131d:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   1131f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11322:	8d 50 0a             	lea    0xa(%eax),%edx
   11325:	8b 45 0c             	mov    0xc(%ebp),%eax
   11328:	8b 40 34             	mov    0x34(%eax),%eax
   1132b:	c1 e8 08             	shr    $0x8,%eax
   1132e:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   11330:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11333:	8d 50 0b             	lea    0xb(%eax),%edx
   11336:	8b 45 0c             	mov    0xc(%ebp),%eax
   11339:	8b 40 34             	mov    0x34(%eax),%eax
   1133c:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   1133e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11341:	8d 50 0c             	lea    0xc(%eax),%edx
   11344:	8b 45 0c             	mov    0xc(%ebp),%eax
   11347:	8b 40 38             	mov    0x38(%eax),%eax
   1134a:	c1 e8 08             	shr    $0x8,%eax
   1134d:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   1134f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11352:	8d 50 0d             	lea    0xd(%eax),%edx
   11355:	8b 45 0c             	mov    0xc(%ebp),%eax
   11358:	8b 40 38             	mov    0x38(%eax),%eax
   1135b:	88 02                	mov    %al,(%edx)
   1135d:	eb 3d                	jmp    1139c <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   1135f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11362:	8b 40 0c             	mov    0xc(%eax),%eax
   11365:	83 f8 03             	cmp    $0x3,%eax
   11368:	75 32                	jne    1139c <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   1136a:	68 72 a3 01 00       	push   $0x1a372
   1136f:	6a 01                	push   $0x1
   11371:	ff 75 08             	pushl  0x8(%ebp)
   11374:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11377:	50                   	push   %eax
   11378:	e8 f2 76 ff ff       	call   8a6f <lodepng_chunk_init>
   1137d:	83 c4 10             	add    $0x10,%esp
   11380:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11383:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11387:	74 05                	je     1138e <addChunk_bKGD+0x13c>
   11389:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1138c:	eb 26                	jmp    113b4 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   1138e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11391:	8d 50 08             	lea    0x8(%eax),%edx
   11394:	8b 45 0c             	mov    0xc(%ebp),%eax
   11397:	8b 40 30             	mov    0x30(%eax),%eax
   1139a:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   1139c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1139f:	85 c0                	test   %eax,%eax
   113a1:	74 0c                	je     113af <addChunk_bKGD+0x15d>
   113a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   113a6:	50                   	push   %eax
   113a7:	e8 6c 73 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   113ac:	83 c4 04             	add    $0x4,%esp
  return 0;
   113af:	b8 00 00 00 00       	mov    $0x0,%eax
}
   113b4:	c9                   	leave  
   113b5:	c3                   	ret    

000113b6 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   113b6:	55                   	push   %ebp
   113b7:	89 e5                	mov    %esp,%ebp
   113b9:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   113bc:	68 86 a3 01 00       	push   $0x1a386
   113c1:	6a 07                	push   $0x7
   113c3:	ff 75 08             	pushl  0x8(%ebp)
   113c6:	8d 45 f8             	lea    -0x8(%ebp),%eax
   113c9:	50                   	push   %eax
   113ca:	e8 a0 76 ff ff       	call   8a6f <lodepng_chunk_init>
   113cf:	83 c4 10             	add    $0x10,%esp
   113d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
   113d5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   113d9:	74 05                	je     113e0 <addChunk_tIME+0x2a>
   113db:	8b 45 fc             	mov    -0x4(%ebp),%eax
   113de:	eb 74                	jmp    11454 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   113e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113e3:	8d 50 08             	lea    0x8(%eax),%edx
   113e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   113e9:	8b 00                	mov    (%eax),%eax
   113eb:	c1 e8 08             	shr    $0x8,%eax
   113ee:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   113f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113f3:	8d 50 09             	lea    0x9(%eax),%edx
   113f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   113f9:	8b 00                	mov    (%eax),%eax
   113fb:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   113fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11400:	8d 50 0a             	lea    0xa(%eax),%edx
   11403:	8b 45 0c             	mov    0xc(%ebp),%eax
   11406:	8b 40 04             	mov    0x4(%eax),%eax
   11409:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   1140b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1140e:	8d 50 0b             	lea    0xb(%eax),%edx
   11411:	8b 45 0c             	mov    0xc(%ebp),%eax
   11414:	8b 40 08             	mov    0x8(%eax),%eax
   11417:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11419:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1141c:	8d 50 0c             	lea    0xc(%eax),%edx
   1141f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11422:	8b 40 0c             	mov    0xc(%eax),%eax
   11425:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11427:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1142a:	8d 50 0d             	lea    0xd(%eax),%edx
   1142d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11430:	8b 40 10             	mov    0x10(%eax),%eax
   11433:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   11435:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11438:	8d 50 0e             	lea    0xe(%eax),%edx
   1143b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1143e:	8b 40 14             	mov    0x14(%eax),%eax
   11441:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11443:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11446:	50                   	push   %eax
   11447:	e8 cc 72 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   1144c:	83 c4 04             	add    $0x4,%esp
  return 0;
   1144f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11454:	c9                   	leave  
   11455:	c3                   	ret    

00011456 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11456:	55                   	push   %ebp
   11457:	89 e5                	mov    %esp,%ebp
   11459:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   1145c:	68 8b a3 01 00       	push   $0x1a38b
   11461:	6a 09                	push   $0x9
   11463:	ff 75 08             	pushl  0x8(%ebp)
   11466:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11469:	50                   	push   %eax
   1146a:	e8 00 76 ff ff       	call   8a6f <lodepng_chunk_init>
   1146f:	83 c4 10             	add    $0x10,%esp
   11472:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11475:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11479:	74 05                	je     11480 <addChunk_pHYs+0x2a>
   1147b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1147e:	eb 51                	jmp    114d1 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   11480:	8b 45 0c             	mov    0xc(%ebp),%eax
   11483:	8b 40 7c             	mov    0x7c(%eax),%eax
   11486:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11489:	83 c2 08             	add    $0x8,%edx
   1148c:	50                   	push   %eax
   1148d:	52                   	push   %edx
   1148e:	e8 25 25 ff ff       	call   39b8 <lodepng_set32bitInt>
   11493:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   11496:	8b 45 0c             	mov    0xc(%ebp),%eax
   11499:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1149f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   114a2:	83 c2 0c             	add    $0xc,%edx
   114a5:	50                   	push   %eax
   114a6:	52                   	push   %edx
   114a7:	e8 0c 25 ff ff       	call   39b8 <lodepng_set32bitInt>
   114ac:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   114af:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114b2:	8d 50 10             	lea    0x10(%eax),%edx
   114b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   114b8:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   114be:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   114c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114c3:	50                   	push   %eax
   114c4:	e8 4f 72 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   114c9:	83 c4 04             	add    $0x4,%esp
  return 0;
   114cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
   114d1:	c9                   	leave  
   114d2:	c3                   	ret    

000114d3 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   114d3:	55                   	push   %ebp
   114d4:	89 e5                	mov    %esp,%ebp
   114d6:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   114d9:	68 90 a3 01 00       	push   $0x1a390
   114de:	6a 04                	push   $0x4
   114e0:	ff 75 08             	pushl  0x8(%ebp)
   114e3:	8d 45 f8             	lea    -0x8(%ebp),%eax
   114e6:	50                   	push   %eax
   114e7:	e8 83 75 ff ff       	call   8a6f <lodepng_chunk_init>
   114ec:	83 c4 10             	add    $0x10,%esp
   114ef:	89 45 fc             	mov    %eax,-0x4(%ebp)
   114f2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   114f6:	74 05                	je     114fd <addChunk_gAMA+0x2a>
   114f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   114fb:	eb 2a                	jmp    11527 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   114fd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11500:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   11506:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11509:	83 c2 08             	add    $0x8,%edx
   1150c:	50                   	push   %eax
   1150d:	52                   	push   %edx
   1150e:	e8 a5 24 ff ff       	call   39b8 <lodepng_set32bitInt>
   11513:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11516:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11519:	50                   	push   %eax
   1151a:	e8 f9 71 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   1151f:	83 c4 04             	add    $0x4,%esp
  return 0;
   11522:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11527:	c9                   	leave  
   11528:	c3                   	ret    

00011529 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   11529:	55                   	push   %ebp
   1152a:	89 e5                	mov    %esp,%ebp
   1152c:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   1152f:	68 95 a3 01 00       	push   $0x1a395
   11534:	6a 20                	push   $0x20
   11536:	ff 75 08             	pushl  0x8(%ebp)
   11539:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1153c:	50                   	push   %eax
   1153d:	e8 2d 75 ff ff       	call   8a6f <lodepng_chunk_init>
   11542:	83 c4 10             	add    $0x10,%esp
   11545:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11548:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1154c:	74 08                	je     11556 <addChunk_cHRM+0x2d>
   1154e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11551:	e9 d9 00 00 00       	jmp    1162f <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11556:	8b 45 0c             	mov    0xc(%ebp),%eax
   11559:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1155f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11562:	83 c2 08             	add    $0x8,%edx
   11565:	50                   	push   %eax
   11566:	52                   	push   %edx
   11567:	e8 4c 24 ff ff       	call   39b8 <lodepng_set32bitInt>
   1156c:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   1156f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11572:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11578:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1157b:	83 c2 0c             	add    $0xc,%edx
   1157e:	50                   	push   %eax
   1157f:	52                   	push   %edx
   11580:	e8 33 24 ff ff       	call   39b8 <lodepng_set32bitInt>
   11585:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   11588:	8b 45 0c             	mov    0xc(%ebp),%eax
   1158b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   11591:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11594:	83 c2 10             	add    $0x10,%edx
   11597:	50                   	push   %eax
   11598:	52                   	push   %edx
   11599:	e8 1a 24 ff ff       	call   39b8 <lodepng_set32bitInt>
   1159e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   115a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   115a4:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   115aa:	8b 55 f8             	mov    -0x8(%ebp),%edx
   115ad:	83 c2 14             	add    $0x14,%edx
   115b0:	50                   	push   %eax
   115b1:	52                   	push   %edx
   115b2:	e8 01 24 ff ff       	call   39b8 <lodepng_set32bitInt>
   115b7:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   115ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   115bd:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   115c3:	8b 55 f8             	mov    -0x8(%ebp),%edx
   115c6:	83 c2 18             	add    $0x18,%edx
   115c9:	50                   	push   %eax
   115ca:	52                   	push   %edx
   115cb:	e8 e8 23 ff ff       	call   39b8 <lodepng_set32bitInt>
   115d0:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   115d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   115d6:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   115dc:	8b 55 f8             	mov    -0x8(%ebp),%edx
   115df:	83 c2 1c             	add    $0x1c,%edx
   115e2:	50                   	push   %eax
   115e3:	52                   	push   %edx
   115e4:	e8 cf 23 ff ff       	call   39b8 <lodepng_set32bitInt>
   115e9:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   115ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   115ef:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   115f5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   115f8:	83 c2 20             	add    $0x20,%edx
   115fb:	50                   	push   %eax
   115fc:	52                   	push   %edx
   115fd:	e8 b6 23 ff ff       	call   39b8 <lodepng_set32bitInt>
   11602:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   11605:	8b 45 0c             	mov    0xc(%ebp),%eax
   11608:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   1160e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11611:	83 c2 24             	add    $0x24,%edx
   11614:	50                   	push   %eax
   11615:	52                   	push   %edx
   11616:	e8 9d 23 ff ff       	call   39b8 <lodepng_set32bitInt>
   1161b:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1161e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11621:	50                   	push   %eax
   11622:	e8 f1 70 ff ff       	call   8718 <lodepng_chunk_generate_crc>
   11627:	83 c4 04             	add    $0x4,%esp
  return 0;
   1162a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1162f:	c9                   	leave  
   11630:	c3                   	ret    

00011631 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   11631:	55                   	push   %ebp
   11632:	89 e5                	mov    %esp,%ebp
   11634:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11637:	8b 45 0c             	mov    0xc(%ebp),%eax
   1163a:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11640:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   11643:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11646:	50                   	push   %eax
   11647:	68 9a a3 01 00       	push   $0x1a39a
   1164c:	6a 01                	push   $0x1
   1164e:	ff 75 08             	pushl  0x8(%ebp)
   11651:	e8 c1 74 ff ff       	call   8b17 <lodepng_chunk_createv>
   11656:	83 c4 10             	add    $0x10,%esp
}
   11659:	c9                   	leave  
   1165a:	c3                   	ret    

0001165b <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   1165b:	55                   	push   %ebp
   1165c:	89 e5                	mov    %esp,%ebp
   1165e:	53                   	push   %ebx
   1165f:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11662:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11669:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   11670:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11677:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   1167e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11681:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11687:	50                   	push   %eax
   11688:	e8 06 20 ff ff       	call   3693 <lodepng_strlen>
   1168d:	83 c4 04             	add    $0x4,%esp
   11690:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11693:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11697:	7e 06                	jle    1169f <addChunk_iCCP+0x44>
   11699:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   1169d:	7e 0a                	jle    116a9 <addChunk_iCCP+0x4e>
   1169f:	b8 59 00 00 00       	mov    $0x59,%eax
   116a4:	e9 df 00 00 00       	jmp    11788 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   116a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   116ac:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   116b2:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   116b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   116b7:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   116bd:	83 ec 0c             	sub    $0xc,%esp
   116c0:	ff 75 10             	pushl  0x10(%ebp)
   116c3:	52                   	push   %edx
   116c4:	50                   	push   %eax
   116c5:	8d 45 e0             	lea    -0x20(%ebp),%eax
   116c8:	50                   	push   %eax
   116c9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   116cc:	50                   	push   %eax
   116cd:	e8 35 6c ff ff       	call   8307 <zlib_compress>
   116d2:	83 c4 20             	add    $0x20,%esp
   116d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   116d8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   116dc:	75 29                	jne    11707 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   116de:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116e1:	8d 50 02             	lea    0x2(%eax),%edx
   116e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   116e7:	01 d0                	add    %edx,%eax
   116e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   116ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116ef:	68 9f a3 01 00       	push   $0x1a39f
   116f4:	50                   	push   %eax
   116f5:	ff 75 08             	pushl  0x8(%ebp)
   116f8:	8d 45 e8             	lea    -0x18(%ebp),%eax
   116fb:	50                   	push   %eax
   116fc:	e8 6e 73 ff ff       	call   8a6f <lodepng_chunk_init>
   11701:	83 c4 10             	add    $0x10,%esp
   11704:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11707:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1170b:	75 69                	jne    11776 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   1170d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11710:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11716:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11719:	83 c2 08             	add    $0x8,%edx
   1171c:	83 ec 04             	sub    $0x4,%esp
   1171f:	ff 75 f0             	pushl  -0x10(%ebp)
   11722:	50                   	push   %eax
   11723:	52                   	push   %edx
   11724:	e8 0c 1f ff ff       	call   3635 <lodepng_memcpy>
   11729:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   1172c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1172f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11732:	83 c2 08             	add    $0x8,%edx
   11735:	01 d0                	add    %edx,%eax
   11737:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   1173a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1173d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11740:	83 c2 09             	add    $0x9,%edx
   11743:	01 d0                	add    %edx,%eax
   11745:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11748:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1174b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1174e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   11751:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11754:	83 c3 0a             	add    $0xa,%ebx
   11757:	01 d9                	add    %ebx,%ecx
   11759:	83 ec 04             	sub    $0x4,%esp
   1175c:	52                   	push   %edx
   1175d:	50                   	push   %eax
   1175e:	51                   	push   %ecx
   1175f:	e8 d1 1e ff ff       	call   3635 <lodepng_memcpy>
   11764:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11767:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1176a:	83 ec 0c             	sub    $0xc,%esp
   1176d:	50                   	push   %eax
   1176e:	e8 a5 6f ff ff       	call   8718 <lodepng_chunk_generate_crc>
   11773:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11776:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11779:	83 ec 0c             	sub    $0xc,%esp
   1177c:	50                   	push   %eax
   1177d:	e8 96 1e ff ff       	call   3618 <lodepng_free>
   11782:	83 c4 10             	add    $0x10,%esp
  return error;
   11785:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11788:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1178b:	c9                   	leave  
   1178c:	c3                   	ret    

0001178d <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   1178d:	55                   	push   %ebp
   1178e:	89 e5                	mov    %esp,%ebp
   11790:	56                   	push   %esi
   11791:	53                   	push   %ebx
   11792:	83 ec 14             	sub    $0x14,%esp
   11795:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11798:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   1179b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   1179f:	83 f8 04             	cmp    $0x4,%eax
   117a2:	0f 87 41 03 00 00    	ja     11ae9 <filterScanline+0x35c>
   117a8:	8b 04 85 b0 a3 01 00 	mov    0x1a3b0(,%eax,4),%eax
   117af:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   117b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117b8:	eb 19                	jmp    117d3 <filterScanline+0x46>
   117ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117bd:	8b 45 08             	mov    0x8(%ebp),%eax
   117c0:	01 c2                	add    %eax,%edx
   117c2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   117c8:	01 c8                	add    %ecx,%eax
   117ca:	0f b6 00             	movzbl (%eax),%eax
   117cd:	88 02                	mov    %al,(%edx)
   117cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117d6:	3b 45 14             	cmp    0x14(%ebp),%eax
   117d9:	75 df                	jne    117ba <filterScanline+0x2d>
      break;
   117db:	e9 0a 03 00 00       	jmp    11aea <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   117e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117e7:	eb 19                	jmp    11802 <filterScanline+0x75>
   117e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117ec:	8b 45 08             	mov    0x8(%ebp),%eax
   117ef:	01 c2                	add    %eax,%edx
   117f1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   117f7:	01 c8                	add    %ecx,%eax
   117f9:	0f b6 00             	movzbl (%eax),%eax
   117fc:	88 02                	mov    %al,(%edx)
   117fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11802:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11805:	3b 45 18             	cmp    0x18(%ebp),%eax
   11808:	75 df                	jne    117e9 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   1180a:	8b 45 18             	mov    0x18(%ebp),%eax
   1180d:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11810:	eb 2d                	jmp    1183f <filterScanline+0xb2>
   11812:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11815:	8b 45 08             	mov    0x8(%ebp),%eax
   11818:	01 c2                	add    %eax,%edx
   1181a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1181d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11820:	01 c8                	add    %ecx,%eax
   11822:	0f b6 08             	movzbl (%eax),%ecx
   11825:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11828:	2b 45 18             	sub    0x18(%ebp),%eax
   1182b:	89 c3                	mov    %eax,%ebx
   1182d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11830:	01 d8                	add    %ebx,%eax
   11832:	0f b6 00             	movzbl (%eax),%eax
   11835:	29 c1                	sub    %eax,%ecx
   11837:	89 c8                	mov    %ecx,%eax
   11839:	88 02                	mov    %al,(%edx)
   1183b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1183f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11842:	3b 45 14             	cmp    0x14(%ebp),%eax
   11845:	7c cb                	jl     11812 <filterScanline+0x85>
      break;
   11847:	e9 9e 02 00 00       	jmp    11aea <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   1184c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11850:	74 3e                	je     11890 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   11852:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11859:	eb 28                	jmp    11883 <filterScanline+0xf6>
   1185b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1185e:	8b 45 08             	mov    0x8(%ebp),%eax
   11861:	01 d0                	add    %edx,%eax
   11863:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11866:	8b 55 0c             	mov    0xc(%ebp),%edx
   11869:	01 ca                	add    %ecx,%edx
   1186b:	0f b6 0a             	movzbl (%edx),%ecx
   1186e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11871:	8b 55 10             	mov    0x10(%ebp),%edx
   11874:	01 da                	add    %ebx,%edx
   11876:	0f b6 12             	movzbl (%edx),%edx
   11879:	29 d1                	sub    %edx,%ecx
   1187b:	89 ca                	mov    %ecx,%edx
   1187d:	88 10                	mov    %dl,(%eax)
   1187f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11883:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11886:	3b 45 14             	cmp    0x14(%ebp),%eax
   11889:	75 d0                	jne    1185b <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   1188b:	e9 5a 02 00 00       	jmp    11aea <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   11890:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11897:	eb 19                	jmp    118b2 <filterScanline+0x125>
   11899:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1189c:	8b 45 08             	mov    0x8(%ebp),%eax
   1189f:	01 c2                	add    %eax,%edx
   118a1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   118a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   118a7:	01 c8                	add    %ecx,%eax
   118a9:	0f b6 00             	movzbl (%eax),%eax
   118ac:	88 02                	mov    %al,(%edx)
   118ae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118b5:	3b 45 14             	cmp    0x14(%ebp),%eax
   118b8:	75 df                	jne    11899 <filterScanline+0x10c>
      }
      break;
   118ba:	e9 2b 02 00 00       	jmp    11aea <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   118bf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   118c3:	0f 84 90 00 00 00    	je     11959 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   118c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   118d0:	eb 28                	jmp    118fa <filterScanline+0x16d>
   118d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118d5:	8b 45 08             	mov    0x8(%ebp),%eax
   118d8:	01 d0                	add    %edx,%eax
   118da:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   118dd:	8b 55 0c             	mov    0xc(%ebp),%edx
   118e0:	01 ca                	add    %ecx,%edx
   118e2:	0f b6 12             	movzbl (%edx),%edx
   118e5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   118e8:	8b 4d 10             	mov    0x10(%ebp),%ecx
   118eb:	01 d9                	add    %ebx,%ecx
   118ed:	0f b6 09             	movzbl (%ecx),%ecx
   118f0:	d0 e9                	shr    %cl
   118f2:	29 ca                	sub    %ecx,%edx
   118f4:	88 10                	mov    %dl,(%eax)
   118f6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118fd:	3b 45 18             	cmp    0x18(%ebp),%eax
   11900:	75 d0                	jne    118d2 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   11902:	8b 45 18             	mov    0x18(%ebp),%eax
   11905:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11908:	eb 42                	jmp    1194c <filterScanline+0x1bf>
   1190a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1190d:	8b 45 08             	mov    0x8(%ebp),%eax
   11910:	01 c2                	add    %eax,%edx
   11912:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11915:	8b 45 0c             	mov    0xc(%ebp),%eax
   11918:	01 c8                	add    %ecx,%eax
   1191a:	0f b6 08             	movzbl (%eax),%ecx
   1191d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11920:	2b 45 18             	sub    0x18(%ebp),%eax
   11923:	89 c3                	mov    %eax,%ebx
   11925:	8b 45 0c             	mov    0xc(%ebp),%eax
   11928:	01 d8                	add    %ebx,%eax
   1192a:	0f b6 00             	movzbl (%eax),%eax
   1192d:	0f b6 d8             	movzbl %al,%ebx
   11930:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11933:	8b 45 10             	mov    0x10(%ebp),%eax
   11936:	01 f0                	add    %esi,%eax
   11938:	0f b6 00             	movzbl (%eax),%eax
   1193b:	0f b6 c0             	movzbl %al,%eax
   1193e:	01 d8                	add    %ebx,%eax
   11940:	d1 f8                	sar    %eax
   11942:	29 c1                	sub    %eax,%ecx
   11944:	89 c8                	mov    %ecx,%eax
   11946:	88 02                	mov    %al,(%edx)
   11948:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1194c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1194f:	3b 45 14             	cmp    0x14(%ebp),%eax
   11952:	7c b6                	jl     1190a <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11954:	e9 91 01 00 00       	jmp    11aea <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11959:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11960:	eb 19                	jmp    1197b <filterScanline+0x1ee>
   11962:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11965:	8b 45 08             	mov    0x8(%ebp),%eax
   11968:	01 c2                	add    %eax,%edx
   1196a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1196d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11970:	01 c8                	add    %ecx,%eax
   11972:	0f b6 00             	movzbl (%eax),%eax
   11975:	88 02                	mov    %al,(%edx)
   11977:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1197b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1197e:	3b 45 18             	cmp    0x18(%ebp),%eax
   11981:	75 df                	jne    11962 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   11983:	8b 45 18             	mov    0x18(%ebp),%eax
   11986:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11989:	eb 2f                	jmp    119ba <filterScanline+0x22d>
   1198b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1198e:	8b 45 08             	mov    0x8(%ebp),%eax
   11991:	01 c2                	add    %eax,%edx
   11993:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11996:	8b 45 0c             	mov    0xc(%ebp),%eax
   11999:	01 c8                	add    %ecx,%eax
   1199b:	0f b6 08             	movzbl (%eax),%ecx
   1199e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   119a1:	2b 45 18             	sub    0x18(%ebp),%eax
   119a4:	89 c3                	mov    %eax,%ebx
   119a6:	8b 45 0c             	mov    0xc(%ebp),%eax
   119a9:	01 d8                	add    %ebx,%eax
   119ab:	0f b6 00             	movzbl (%eax),%eax
   119ae:	d0 e8                	shr    %al
   119b0:	29 c1                	sub    %eax,%ecx
   119b2:	89 c8                	mov    %ecx,%eax
   119b4:	88 02                	mov    %al,(%edx)
   119b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   119ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
   119bd:	3b 45 14             	cmp    0x14(%ebp),%eax
   119c0:	7c c9                	jl     1198b <filterScanline+0x1fe>
      }
      break;
   119c2:	e9 23 01 00 00       	jmp    11aea <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   119c7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   119cb:	0f 84 af 00 00 00    	je     11a80 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   119d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   119d8:	eb 28                	jmp    11a02 <filterScanline+0x275>
   119da:	8b 55 f4             	mov    -0xc(%ebp),%edx
   119dd:	8b 45 08             	mov    0x8(%ebp),%eax
   119e0:	01 d0                	add    %edx,%eax
   119e2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   119e5:	8b 55 0c             	mov    0xc(%ebp),%edx
   119e8:	01 ca                	add    %ecx,%edx
   119ea:	0f b6 0a             	movzbl (%edx),%ecx
   119ed:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   119f0:	8b 55 10             	mov    0x10(%ebp),%edx
   119f3:	01 da                	add    %ebx,%edx
   119f5:	0f b6 12             	movzbl (%edx),%edx
   119f8:	29 d1                	sub    %edx,%ecx
   119fa:	89 ca                	mov    %ecx,%edx
   119fc:	88 10                	mov    %dl,(%eax)
   119fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a05:	3b 45 18             	cmp    0x18(%ebp),%eax
   11a08:	75 d0                	jne    119da <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11a0a:	8b 45 18             	mov    0x18(%ebp),%eax
   11a0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11a10:	eb 64                	jmp    11a76 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   11a12:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a15:	8b 45 08             	mov    0x8(%ebp),%eax
   11a18:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11a1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a1e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a21:	01 d0                	add    %edx,%eax
   11a23:	0f b6 00             	movzbl (%eax),%eax
   11a26:	88 45 e7             	mov    %al,-0x19(%ebp)
   11a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a2c:	2b 45 18             	sub    0x18(%ebp),%eax
   11a2f:	89 c2                	mov    %eax,%edx
   11a31:	8b 45 10             	mov    0x10(%ebp),%eax
   11a34:	01 d0                	add    %edx,%eax
   11a36:	0f b6 00             	movzbl (%eax),%eax
   11a39:	0f b6 c8             	movzbl %al,%ecx
   11a3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a3f:	8b 45 10             	mov    0x10(%ebp),%eax
   11a42:	01 d0                	add    %edx,%eax
   11a44:	0f b6 00             	movzbl (%eax),%eax
   11a47:	0f b6 d0             	movzbl %al,%edx
   11a4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a4d:	2b 45 18             	sub    0x18(%ebp),%eax
   11a50:	89 c6                	mov    %eax,%esi
   11a52:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a55:	01 f0                	add    %esi,%eax
   11a57:	0f b6 00             	movzbl (%eax),%eax
   11a5a:	0f b6 c0             	movzbl %al,%eax
   11a5d:	51                   	push   %ecx
   11a5e:	52                   	push   %edx
   11a5f:	50                   	push   %eax
   11a60:	e8 49 b8 ff ff       	call   d2ae <paethPredictor>
   11a65:	83 c4 0c             	add    $0xc,%esp
   11a68:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11a6c:	29 c1                	sub    %eax,%ecx
   11a6e:	89 c8                	mov    %ecx,%eax
   11a70:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   11a72:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a76:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a79:	3b 45 14             	cmp    0x14(%ebp),%eax
   11a7c:	7c 94                	jl     11a12 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   11a7e:	eb 6a                	jmp    11aea <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11a80:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11a87:	eb 19                	jmp    11aa2 <filterScanline+0x315>
   11a89:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a8c:	8b 45 08             	mov    0x8(%ebp),%eax
   11a8f:	01 c2                	add    %eax,%edx
   11a91:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11a94:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a97:	01 c8                	add    %ecx,%eax
   11a99:	0f b6 00             	movzbl (%eax),%eax
   11a9c:	88 02                	mov    %al,(%edx)
   11a9e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11aa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11aa5:	3b 45 18             	cmp    0x18(%ebp),%eax
   11aa8:	75 df                	jne    11a89 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11aaa:	8b 45 18             	mov    0x18(%ebp),%eax
   11aad:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11ab0:	eb 2d                	jmp    11adf <filterScanline+0x352>
   11ab2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11ab5:	8b 45 08             	mov    0x8(%ebp),%eax
   11ab8:	01 c2                	add    %eax,%edx
   11aba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11abd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ac0:	01 c8                	add    %ecx,%eax
   11ac2:	0f b6 08             	movzbl (%eax),%ecx
   11ac5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ac8:	2b 45 18             	sub    0x18(%ebp),%eax
   11acb:	89 c3                	mov    %eax,%ebx
   11acd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ad0:	01 d8                	add    %ebx,%eax
   11ad2:	0f b6 00             	movzbl (%eax),%eax
   11ad5:	29 c1                	sub    %eax,%ecx
   11ad7:	89 c8                	mov    %ecx,%eax
   11ad9:	88 02                	mov    %al,(%edx)
   11adb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11adf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ae2:	3b 45 14             	cmp    0x14(%ebp),%eax
   11ae5:	7c cb                	jl     11ab2 <filterScanline+0x325>
      }
      break;
   11ae7:	eb 01                	jmp    11aea <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11ae9:	90                   	nop
  }
}
   11aea:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11aed:	5b                   	pop    %ebx
   11aee:	5e                   	pop    %esi
   11aef:	5d                   	pop    %ebp
   11af0:	c3                   	ret    

00011af1 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   11af1:	55                   	push   %ebp
   11af2:	89 e5                	mov    %esp,%ebp
   11af4:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11af7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   11afe:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11b05:	7e 08                	jle    11b0f <ilog2+0x1e>
   11b07:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11b0b:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   11b0f:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11b16:	7e 08                	jle    11b20 <ilog2+0x2f>
   11b18:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11b1c:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   11b20:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11b24:	7e 08                	jle    11b2e <ilog2+0x3d>
   11b26:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11b2a:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   11b2e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   11b32:	7e 08                	jle    11b3c <ilog2+0x4b>
   11b34:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11b38:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11b3c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   11b40:	7e 04                	jle    11b46 <ilog2+0x55>
   11b42:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11b46:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11b49:	c9                   	leave  
   11b4a:	c3                   	ret    

00011b4b <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11b4b:	55                   	push   %ebp
   11b4c:	89 e5                	mov    %esp,%ebp
   11b4e:	56                   	push   %esi
   11b4f:	53                   	push   %ebx
   11b50:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   11b53:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11b57:	75 07                	jne    11b60 <ilog2i+0x15>
   11b59:	b8 00 00 00 00       	mov    $0x0,%eax
   11b5e:	eb 30                	jmp    11b90 <ilog2i+0x45>
  l = ilog2(i);
   11b60:	ff 75 08             	pushl  0x8(%ebp)
   11b63:	e8 89 ff ff ff       	call   11af1 <ilog2>
   11b68:	83 c4 04             	add    $0x4,%esp
   11b6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   11b6e:	8b 45 08             	mov    0x8(%ebp),%eax
   11b71:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11b75:	89 c3                	mov    %eax,%ebx
   11b77:	8b 55 08             	mov    0x8(%ebp),%edx
   11b7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b7d:	be 01 00 00 00       	mov    $0x1,%esi
   11b82:	89 c1                	mov    %eax,%ecx
   11b84:	d3 e6                	shl    %cl,%esi
   11b86:	89 f0                	mov    %esi,%eax
   11b88:	29 c2                	sub    %eax,%edx
   11b8a:	89 d0                	mov    %edx,%eax
   11b8c:	01 c0                	add    %eax,%eax
   11b8e:	01 d8                	add    %ebx,%eax
}
   11b90:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11b93:	5b                   	pop    %ebx
   11b94:	5e                   	pop    %esi
   11b95:	5d                   	pop    %ebp
   11b96:	c3                   	ret    

00011b97 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   11b97:	55                   	push   %ebp
   11b98:	89 e5                	mov    %esp,%ebp
   11b9a:	53                   	push   %ebx
   11b9b:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   11ba1:	ff 75 18             	pushl  0x18(%ebp)
   11ba4:	e8 6a 75 ff ff       	call   9113 <lodepng_get_bpp>
   11ba9:	83 c4 04             	add    $0x4,%esp
   11bac:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   11baf:	ff 75 b8             	pushl  -0x48(%ebp)
   11bb2:	6a 01                	push   $0x1
   11bb4:	ff 75 10             	pushl  0x10(%ebp)
   11bb7:	e8 b6 76 ff ff       	call   9272 <lodepng_get_raw_size_idat>
   11bbc:	83 c4 0c             	add    $0xc,%esp
   11bbf:	83 e8 01             	sub    $0x1,%eax
   11bc2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   11bc5:	8b 45 b8             	mov    -0x48(%ebp),%eax
   11bc8:	83 c0 07             	add    $0x7,%eax
   11bcb:	c1 e8 03             	shr    $0x3,%eax
   11bce:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   11bd1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11bd8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   11bdf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11be2:	8b 40 2c             	mov    0x2c(%eax),%eax
   11be5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11be8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11beb:	8b 40 28             	mov    0x28(%eax),%eax
   11bee:	85 c0                	test   %eax,%eax
   11bf0:	74 1c                	je     11c0e <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11bf2:	8b 45 18             	mov    0x18(%ebp),%eax
   11bf5:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11bf7:	83 f8 03             	cmp    $0x3,%eax
   11bfa:	74 0b                	je     11c07 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11bfc:	8b 45 18             	mov    0x18(%ebp),%eax
   11bff:	8b 40 04             	mov    0x4(%eax),%eax
   11c02:	83 f8 07             	cmp    $0x7,%eax
   11c05:	77 07                	ja     11c0e <filter+0x77>
   11c07:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   11c0e:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   11c12:	75 0a                	jne    11c1e <filter+0x87>
   11c14:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11c19:	e9 5b 07 00 00       	jmp    12379 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   11c1e:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11c22:	77 7b                	ja     11c9f <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11c24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11c27:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11c2a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11c31:	eb 5f                	jmp    11c92 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11c33:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c36:	83 c0 01             	add    $0x1,%eax
   11c39:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c3d:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   11c40:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c43:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c47:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11c4a:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11c4d:	8b 45 08             	mov    0x8(%ebp),%eax
   11c50:	01 c2                	add    %eax,%edx
   11c52:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11c56:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11c58:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11c5c:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11c5f:	8b 55 0c             	mov    0xc(%ebp),%edx
   11c62:	01 d1                	add    %edx,%ecx
   11c64:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11c67:	8d 5a 01             	lea    0x1(%edx),%ebx
   11c6a:	8b 55 08             	mov    0x8(%ebp),%edx
   11c6d:	01 da                	add    %ebx,%edx
   11c6f:	50                   	push   %eax
   11c70:	ff 75 b0             	pushl  -0x50(%ebp)
   11c73:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c76:	ff 75 f4             	pushl  -0xc(%ebp)
   11c79:	51                   	push   %ecx
   11c7a:	52                   	push   %edx
   11c7b:	e8 0d fb ff ff       	call   1178d <filterScanline>
   11c80:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11c83:	8b 55 98             	mov    -0x68(%ebp),%edx
   11c86:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c89:	01 d0                	add    %edx,%eax
   11c8b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11c8e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11c92:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c95:	3b 45 14             	cmp    0x14(%ebp),%eax
   11c98:	75 99                	jne    11c33 <filter+0x9c>
   11c9a:	e9 d7 06 00 00       	jmp    12376 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11c9f:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11ca3:	0f 85 e3 01 00 00    	jne    11e8c <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11ca9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11cb0:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   11cb4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11cb8:	eb 2d                	jmp    11ce7 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11cba:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11cbe:	83 ec 0c             	sub    $0xc,%esp
   11cc1:	ff 75 b4             	pushl  -0x4c(%ebp)
   11cc4:	e8 2e 19 ff ff       	call   35f7 <lodepng_malloc>
   11cc9:	83 c4 10             	add    $0x10,%esp
   11ccc:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11cd0:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11cd4:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11cd8:	85 c0                	test   %eax,%eax
   11cda:	75 07                	jne    11ce3 <filter+0x14c>
   11cdc:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11ce3:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11ce7:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11ceb:	75 cd                	jne    11cba <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11ced:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11cf1:	0f 85 6c 01 00 00    	jne    11e63 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11cf7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11cfe:	e9 54 01 00 00       	jmp    11e57 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11d03:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11d07:	e9 d5 00 00 00       	jmp    11de1 <filter+0x24a>
          size_t sum = 0;
   11d0c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11d13:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11d17:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d1a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d1e:	89 c1                	mov    %eax,%ecx
   11d20:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d23:	01 c1                	add    %eax,%ecx
   11d25:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11d29:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11d2d:	83 ec 08             	sub    $0x8,%esp
   11d30:	52                   	push   %edx
   11d31:	ff 75 b0             	pushl  -0x50(%ebp)
   11d34:	ff 75 b4             	pushl  -0x4c(%ebp)
   11d37:	ff 75 f4             	pushl  -0xc(%ebp)
   11d3a:	51                   	push   %ecx
   11d3b:	50                   	push   %eax
   11d3c:	e8 4c fa ff ff       	call   1178d <filterScanline>
   11d41:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11d44:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11d48:	75 2d                	jne    11d77 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11d4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d51:	eb 1a                	jmp    11d6d <filter+0x1d6>
   11d53:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11d57:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11d5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d5e:	01 d0                	add    %edx,%eax
   11d60:	0f b6 00             	movzbl (%eax),%eax
   11d63:	0f b6 c0             	movzbl %al,%eax
   11d66:	01 45 d8             	add    %eax,-0x28(%ebp)
   11d69:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d6d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d70:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d73:	75 de                	jne    11d53 <filter+0x1bc>
   11d75:	eb 4b                	jmp    11dc2 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11d77:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d7e:	eb 3a                	jmp    11dba <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11d80:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11d84:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11d88:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d8b:	01 d0                	add    %edx,%eax
   11d8d:	0f b6 00             	movzbl (%eax),%eax
   11d90:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11d93:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11d97:	84 c0                	test   %al,%al
   11d99:	78 06                	js     11da1 <filter+0x20a>
   11d9b:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11d9f:	eb 0d                	jmp    11dae <filter+0x217>
   11da1:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11da5:	ba ff 00 00 00       	mov    $0xff,%edx
   11daa:	29 c2                	sub    %eax,%edx
   11dac:	89 d0                	mov    %edx,%eax
   11dae:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11db1:	01 d0                	add    %edx,%eax
   11db3:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11db6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11dba:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dbd:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11dc0:	75 be                	jne    11d80 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11dc2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11dc6:	74 08                	je     11dd0 <filter+0x239>
   11dc8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11dcb:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11dce:	7d 0d                	jge    11ddd <filter+0x246>
            bestType = type;
   11dd0:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11dd4:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11dd7:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11dda:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11ddd:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11de1:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11de5:	0f 85 21 ff ff ff    	jne    11d0c <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11deb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dee:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11df2:	89 c2                	mov    %eax,%edx
   11df4:	8b 45 0c             	mov    0xc(%ebp),%eax
   11df7:	01 d0                	add    %edx,%eax
   11df9:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11dfc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dff:	83 c0 01             	add    $0x1,%eax
   11e02:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e06:	89 c2                	mov    %eax,%edx
   11e08:	8b 45 08             	mov    0x8(%ebp),%eax
   11e0b:	01 c2                	add    %eax,%edx
   11e0d:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11e11:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11e13:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11e1a:	eb 2f                	jmp    11e4b <filter+0x2b4>
   11e1c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e1f:	83 c0 01             	add    $0x1,%eax
   11e22:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e26:	89 c2                	mov    %eax,%edx
   11e28:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e2b:	01 d0                	add    %edx,%eax
   11e2d:	8d 50 01             	lea    0x1(%eax),%edx
   11e30:	8b 45 08             	mov    0x8(%ebp),%eax
   11e33:	01 c2                	add    %eax,%edx
   11e35:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11e39:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11e3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e40:	01 c8                	add    %ecx,%eax
   11e42:	0f b6 00             	movzbl (%eax),%eax
   11e45:	88 02                	mov    %al,(%edx)
   11e47:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e4b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e4e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11e51:	75 c9                	jne    11e1c <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11e53:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e57:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e5a:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e5d:	0f 85 a0 fe ff ff    	jne    11d03 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11e63:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11e67:	eb 18                	jmp    11e81 <filter+0x2ea>
   11e69:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11e6d:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11e71:	83 ec 0c             	sub    $0xc,%esp
   11e74:	50                   	push   %eax
   11e75:	e8 9e 17 ff ff       	call   3618 <lodepng_free>
   11e7a:	83 c4 10             	add    $0x10,%esp
   11e7d:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11e81:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11e85:	75 e2                	jne    11e69 <filter+0x2d2>
   11e87:	e9 ea 04 00 00       	jmp    12376 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11e8c:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11e90:	0f 85 17 02 00 00    	jne    120ad <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11e96:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11e9d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11ea4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11eab:	eb 33                	jmp    11ee0 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11ead:	83 ec 0c             	sub    $0xc,%esp
   11eb0:	ff 75 b4             	pushl  -0x4c(%ebp)
   11eb3:	e8 3f 17 ff ff       	call   35f7 <lodepng_malloc>
   11eb8:	83 c4 10             	add    $0x10,%esp
   11ebb:	89 c2                	mov    %eax,%edx
   11ebd:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11ec0:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11ec7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11eca:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11ed1:	85 c0                	test   %eax,%eax
   11ed3:	75 07                	jne    11edc <filter+0x345>
   11ed5:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11edc:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11ee0:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11ee4:	75 c7                	jne    11ead <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11ee6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11eea:	0f 85 8f 01 00 00    	jne    1207f <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11ef0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ef7:	e9 77 01 00 00       	jmp    12073 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11efc:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11f03:	e9 f4 00 00 00       	jmp    11ffc <filter+0x465>
          size_t sum = 0;
   11f08:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11f0f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f12:	0f b6 d0             	movzbl %al,%edx
   11f15:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f18:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f1c:	89 c1                	mov    %eax,%ecx
   11f1e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f21:	01 c1                	add    %eax,%ecx
   11f23:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f26:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11f2d:	83 ec 08             	sub    $0x8,%esp
   11f30:	52                   	push   %edx
   11f31:	ff 75 b0             	pushl  -0x50(%ebp)
   11f34:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f37:	ff 75 f4             	pushl  -0xc(%ebp)
   11f3a:	51                   	push   %ecx
   11f3b:	50                   	push   %eax
   11f3c:	e8 4c f8 ff ff       	call   1178d <filterScanline>
   11f41:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11f44:	83 ec 04             	sub    $0x4,%esp
   11f47:	68 00 04 00 00       	push   $0x400
   11f4c:	6a 00                	push   $0x0
   11f4e:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11f54:	50                   	push   %eax
   11f55:	e8 0e 17 ff ff       	call   3668 <lodepng_memset>
   11f5a:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11f5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11f64:	eb 2a                	jmp    11f90 <filter+0x3f9>
   11f66:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f69:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11f70:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11f73:	01 d0                	add    %edx,%eax
   11f75:	0f b6 00             	movzbl (%eax),%eax
   11f78:	0f b6 c0             	movzbl %al,%eax
   11f7b:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11f82:	83 c2 01             	add    $0x1,%edx
   11f85:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11f8c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11f90:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f93:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11f96:	75 ce                	jne    11f66 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11f98:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f9b:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11fa2:	8d 50 01             	lea    0x1(%eax),%edx
   11fa5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11fa8:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11faf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11fb6:	eb 1d                	jmp    11fd5 <filter+0x43e>
            sum += ilog2i(count[x]);
   11fb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11fbb:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11fc2:	83 ec 0c             	sub    $0xc,%esp
   11fc5:	50                   	push   %eax
   11fc6:	e8 80 fb ff ff       	call   11b4b <ilog2i>
   11fcb:	83 c4 10             	add    $0x10,%esp
   11fce:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11fd1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11fd5:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11fdc:	75 da                	jne    11fb8 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11fde:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11fe2:	74 08                	je     11fec <filter+0x455>
   11fe4:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11fe7:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11fea:	7e 0c                	jle    11ff8 <filter+0x461>
            bestType = type;
   11fec:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11fef:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11ff2:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11ff5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11ff8:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11ffc:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12000:	0f 85 02 ff ff ff    	jne    11f08 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   12006:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12009:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1200d:	89 c2                	mov    %eax,%edx
   1200f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12012:	01 d0                	add    %edx,%eax
   12014:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12017:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1201a:	83 c0 01             	add    $0x1,%eax
   1201d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12021:	89 c2                	mov    %eax,%edx
   12023:	8b 45 08             	mov    0x8(%ebp),%eax
   12026:	01 d0                	add    %edx,%eax
   12028:	8b 55 cc             	mov    -0x34(%ebp),%edx
   1202b:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1202d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12034:	eb 31                	jmp    12067 <filter+0x4d0>
   12036:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12039:	83 c0 01             	add    $0x1,%eax
   1203c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12040:	89 c2                	mov    %eax,%edx
   12042:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12045:	01 d0                	add    %edx,%eax
   12047:	8d 50 01             	lea    0x1(%eax),%edx
   1204a:	8b 45 08             	mov    0x8(%ebp),%eax
   1204d:	01 c2                	add    %eax,%edx
   1204f:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12052:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   12059:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1205c:	01 c8                	add    %ecx,%eax
   1205e:	0f b6 00             	movzbl (%eax),%eax
   12061:	88 02                	mov    %al,(%edx)
   12063:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12067:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1206a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1206d:	75 c7                	jne    12036 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   1206f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12073:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12076:	3b 45 14             	cmp    0x14(%ebp),%eax
   12079:	0f 85 7d fe ff ff    	jne    11efc <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   1207f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12086:	eb 1a                	jmp    120a2 <filter+0x50b>
   12088:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1208b:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12092:	83 ec 0c             	sub    $0xc,%esp
   12095:	50                   	push   %eax
   12096:	e8 7d 15 ff ff       	call   3618 <lodepng_free>
   1209b:	83 c4 10             	add    $0x10,%esp
   1209e:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   120a2:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   120a6:	75 e0                	jne    12088 <filter+0x4f1>
   120a8:	e9 c9 02 00 00       	jmp    12376 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   120ad:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   120b1:	0f 85 89 00 00 00    	jne    12140 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   120b7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   120be:	eb 73                	jmp    12133 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   120c0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120c3:	83 c0 01             	add    $0x1,%eax
   120c6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120ca:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   120cd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120d0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120d4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   120d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   120da:	8b 50 30             	mov    0x30(%eax),%edx
   120dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120e0:	01 d0                	add    %edx,%eax
   120e2:	0f b6 00             	movzbl (%eax),%eax
   120e5:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   120e8:	8b 55 a8             	mov    -0x58(%ebp),%edx
   120eb:	8b 45 08             	mov    0x8(%ebp),%eax
   120ee:	01 c2                	add    %eax,%edx
   120f0:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   120f4:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   120f6:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   120fa:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   120fd:	8b 55 0c             	mov    0xc(%ebp),%edx
   12100:	01 d1                	add    %edx,%ecx
   12102:	8b 55 a8             	mov    -0x58(%ebp),%edx
   12105:	8d 5a 01             	lea    0x1(%edx),%ebx
   12108:	8b 55 08             	mov    0x8(%ebp),%edx
   1210b:	01 da                	add    %ebx,%edx
   1210d:	83 ec 08             	sub    $0x8,%esp
   12110:	50                   	push   %eax
   12111:	ff 75 b0             	pushl  -0x50(%ebp)
   12114:	ff 75 b4             	pushl  -0x4c(%ebp)
   12117:	ff 75 f4             	pushl  -0xc(%ebp)
   1211a:	51                   	push   %ecx
   1211b:	52                   	push   %edx
   1211c:	e8 6c f6 ff ff       	call   1178d <filterScanline>
   12121:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   12124:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12127:	8b 45 0c             	mov    0xc(%ebp),%eax
   1212a:	01 d0                	add    %edx,%eax
   1212c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   1212f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12133:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12136:	3b 45 14             	cmp    0x14(%ebp),%eax
   12139:	75 85                	jne    120c0 <filter+0x529>
   1213b:	e9 36 02 00 00       	jmp    12376 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   12140:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   12144:	0f 85 25 02 00 00    	jne    1236f <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   1214a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   12151:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12158:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   1215f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12162:	83 ec 04             	sub    $0x4,%esp
   12165:	6a 24                	push   $0x24
   12167:	50                   	push   %eax
   12168:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   1216e:	50                   	push   %eax
   1216f:	e8 c1 14 ff ff       	call   3635 <lodepng_memcpy>
   12174:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   12177:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   1217e:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   12181:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   12188:	00 00 00 
    zlibsettings.custom_deflate = 0;
   1218b:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   12192:	00 00 00 
    for(type = 0; type != 5; ++type) {
   12195:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1219c:	eb 33                	jmp    121d1 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   1219e:	83 ec 0c             	sub    $0xc,%esp
   121a1:	ff 75 b4             	pushl  -0x4c(%ebp)
   121a4:	e8 4e 14 ff ff       	call   35f7 <lodepng_malloc>
   121a9:	83 c4 10             	add    $0x10,%esp
   121ac:	89 c2                	mov    %eax,%edx
   121ae:	8b 45 c0             	mov    -0x40(%ebp),%eax
   121b1:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   121b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
   121bb:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   121c2:	85 c0                	test   %eax,%eax
   121c4:	75 07                	jne    121cd <filter+0x636>
   121c6:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   121cd:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   121d1:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   121d5:	75 c7                	jne    1219e <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   121d7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   121db:	0f 85 63 01 00 00    	jne    12344 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   121e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   121e8:	e9 4b 01 00 00       	jmp    12338 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   121ed:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   121f4:	e9 c8 00 00 00       	jmp    122c1 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   121f9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   121fc:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   121ff:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12202:	0f b6 d0             	movzbl %al,%edx
   12205:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12208:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1220c:	89 c1                	mov    %eax,%ecx
   1220e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12211:	01 c1                	add    %eax,%ecx
   12213:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12216:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1221d:	83 ec 08             	sub    $0x8,%esp
   12220:	52                   	push   %edx
   12221:	ff 75 b0             	pushl  -0x50(%ebp)
   12224:	ff 75 b4             	pushl  -0x4c(%ebp)
   12227:	ff 75 f4             	pushl  -0xc(%ebp)
   1222a:	51                   	push   %ecx
   1222b:	50                   	push   %eax
   1222c:	e8 5c f5 ff ff       	call   1178d <filterScanline>
   12231:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   12234:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12237:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   1223e:	00 00 00 00 
          dummy = 0;
   12242:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   12249:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   1224c:	8b 55 ac             	mov    -0x54(%ebp),%edx
   1224f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12252:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12259:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   1225f:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   12262:	c1 e3 02             	shl    $0x2,%ebx
   12265:	01 cb                	add    %ecx,%ebx
   12267:	83 ec 0c             	sub    $0xc,%esp
   1226a:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   12270:	51                   	push   %ecx
   12271:	52                   	push   %edx
   12272:	50                   	push   %eax
   12273:	53                   	push   %ebx
   12274:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   1227a:	50                   	push   %eax
   1227b:	e8 87 60 ff ff       	call   8307 <zlib_compress>
   12280:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   12283:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   12289:	83 ec 0c             	sub    $0xc,%esp
   1228c:	50                   	push   %eax
   1228d:	e8 86 13 ff ff       	call   3618 <lodepng_free>
   12292:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   12295:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   12299:	74 0f                	je     122aa <filter+0x713>
   1229b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1229e:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   122a5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   122a8:	7d 13                	jge    122bd <filter+0x726>
            bestType = type;
   122aa:	8b 45 c0             	mov    -0x40(%ebp),%eax
   122ad:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   122b0:	8b 45 c0             	mov    -0x40(%ebp),%eax
   122b3:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   122ba:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   122bd:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   122c1:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   122c5:	0f 85 2e ff ff ff    	jne    121f9 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   122cb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122ce:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122d2:	89 c2                	mov    %eax,%edx
   122d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   122d7:	01 d0                	add    %edx,%eax
   122d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   122dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122df:	83 c0 01             	add    $0x1,%eax
   122e2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122e6:	89 c2                	mov    %eax,%edx
   122e8:	8b 45 08             	mov    0x8(%ebp),%eax
   122eb:	01 d0                	add    %edx,%eax
   122ed:	8b 55 bc             	mov    -0x44(%ebp),%edx
   122f0:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   122f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   122f9:	eb 31                	jmp    1232c <filter+0x795>
   122fb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122fe:	83 c0 01             	add    $0x1,%eax
   12301:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12305:	89 c2                	mov    %eax,%edx
   12307:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1230a:	01 d0                	add    %edx,%eax
   1230c:	8d 50 01             	lea    0x1(%eax),%edx
   1230f:	8b 45 08             	mov    0x8(%ebp),%eax
   12312:	01 c2                	add    %eax,%edx
   12314:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12317:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   1231e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12321:	01 c8                	add    %ecx,%eax
   12323:	0f b6 00             	movzbl (%eax),%eax
   12326:	88 02                	mov    %al,(%edx)
   12328:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1232c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1232f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12332:	75 c7                	jne    122fb <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12334:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12338:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1233b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1233e:	0f 85 a9 fe ff ff    	jne    121ed <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12344:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1234b:	eb 1a                	jmp    12367 <filter+0x7d0>
   1234d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12350:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12357:	83 ec 0c             	sub    $0xc,%esp
   1235a:	50                   	push   %eax
   1235b:	e8 b8 12 ff ff       	call   3618 <lodepng_free>
   12360:	83 c4 10             	add    $0x10,%esp
   12363:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12367:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1236b:	75 e0                	jne    1234d <filter+0x7b6>
   1236d:	eb 07                	jmp    12376 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   1236f:	b8 58 00 00 00       	mov    $0x58,%eax
   12374:	eb 03                	jmp    12379 <filter+0x7e2>

  return error;
   12376:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   12379:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1237c:	c9                   	leave  
   1237d:	c3                   	ret    

0001237e <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   1237e:	55                   	push   %ebp
   1237f:	89 e5                	mov    %esp,%ebp
   12381:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   12384:	8b 45 10             	mov    0x10(%ebp),%eax
   12387:	2b 45 14             	sub    0x14(%ebp),%eax
   1238a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   1238d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12394:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   1239b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   123a2:	eb 65                	jmp    12409 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   123a4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   123ab:	eb 2a                	jmp    123d7 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   123ad:	ff 75 0c             	pushl  0xc(%ebp)
   123b0:	8d 45 e8             	lea    -0x18(%ebp),%eax
   123b3:	50                   	push   %eax
   123b4:	e8 9d 60 ff ff       	call   8456 <readBitFromReversedStream>
   123b9:	83 c4 08             	add    $0x8,%esp
   123bc:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   123bf:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   123c3:	50                   	push   %eax
   123c4:	ff 75 08             	pushl  0x8(%ebp)
   123c7:	8d 45 ec             	lea    -0x14(%ebp),%eax
   123ca:	50                   	push   %eax
   123cb:	e8 08 61 ff ff       	call   84d8 <setBitOfReversedStream>
   123d0:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   123d3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   123d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   123da:	3b 45 14             	cmp    0x14(%ebp),%eax
   123dd:	7c ce                	jl     123ad <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   123df:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   123e6:	eb 15                	jmp    123fd <addPaddingBits+0x7f>
   123e8:	6a 00                	push   $0x0
   123ea:	ff 75 08             	pushl  0x8(%ebp)
   123ed:	8d 45 ec             	lea    -0x14(%ebp),%eax
   123f0:	50                   	push   %eax
   123f1:	e8 e2 60 ff ff       	call   84d8 <setBitOfReversedStream>
   123f6:	83 c4 0c             	add    $0xc,%esp
   123f9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   123fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12400:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12403:	75 e3                	jne    123e8 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   12405:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12409:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1240c:	3b 45 18             	cmp    0x18(%ebp),%eax
   1240f:	75 93                	jne    123a4 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   12411:	90                   	nop
   12412:	c9                   	leave  
   12413:	c3                   	ret    

00012414 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   12414:	55                   	push   %ebp
   12415:	89 e5                	mov    %esp,%ebp
   12417:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1241d:	ff 75 18             	pushl  0x18(%ebp)
   12420:	ff 75 14             	pushl  0x14(%ebp)
   12423:	ff 75 10             	pushl  0x10(%ebp)
   12426:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   1242c:	50                   	push   %eax
   1242d:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   12433:	50                   	push   %eax
   12434:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   1243a:	50                   	push   %eax
   1243b:	8d 45 94             	lea    -0x6c(%ebp),%eax
   1243e:	50                   	push   %eax
   1243f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12442:	50                   	push   %eax
   12443:	e8 fc ae ff ff       	call   d344 <Adam7_getpassvalues>
   12448:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   1244b:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   1244f:	0f 86 0a 01 00 00    	jbe    1255f <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12455:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1245c:	e9 ef 00 00 00       	jmp    12550 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   12461:	8b 45 18             	mov    0x18(%ebp),%eax
   12464:	c1 e8 03             	shr    $0x3,%eax
   12467:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   1246a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12471:	e9 c6 00 00 00       	jmp    1253c <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   12476:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1247d:	e9 a6 00 00 00       	jmp    12528 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   12482:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12485:	8b 14 85 f8 a2 01 00 	mov    0x1a2f8(,%eax,4),%edx
   1248c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1248f:	8b 04 85 30 a3 01 00 	mov    0x1a330(,%eax,4),%eax
   12496:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1249a:	01 d0                	add    %edx,%eax
   1249c:	0f af 45 10          	imul   0x10(%ebp),%eax
   124a0:	89 c2                	mov    %eax,%edx
   124a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124a5:	8b 04 85 14 a3 01 00 	mov    0x1a314(,%eax,4),%eax
   124ac:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   124b0:	01 c2                	add    %eax,%edx
   124b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124b5:	8b 04 85 dc a2 01 00 	mov    0x1a2dc(,%eax,4),%eax
   124bc:	01 c2                	add    %eax,%edx
   124be:	8b 45 e0             	mov    -0x20(%ebp),%eax
   124c1:	0f af c2             	imul   %edx,%eax
   124c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   124c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124ca:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   124d1:	89 c1                	mov    %eax,%ecx
   124d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124d6:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   124da:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   124de:	89 c2                	mov    %eax,%edx
   124e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   124e3:	01 c2                	add    %eax,%edx
   124e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   124e8:	0f af c2             	imul   %edx,%eax
   124eb:	01 c8                	add    %ecx,%eax
   124ed:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   124f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   124f7:	eb 23                	jmp    1251c <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   124f9:	8b 55 d8             	mov    -0x28(%ebp),%edx
   124fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124ff:	01 c2                	add    %eax,%edx
   12501:	8b 45 08             	mov    0x8(%ebp),%eax
   12504:	01 c2                	add    %eax,%edx
   12506:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12509:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1250c:	01 c1                	add    %eax,%ecx
   1250e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12511:	01 c8                	add    %ecx,%eax
   12513:	0f b6 00             	movzbl (%eax),%eax
   12516:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   12518:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1251c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1251f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12522:	72 d5                	jb     124f9 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12524:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12528:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1252b:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1252f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12532:	0f 87 4a ff ff ff    	ja     12482 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12538:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1253c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1253f:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12543:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12546:	0f 87 2a ff ff ff    	ja     12476 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   1254c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12550:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12554:	0f 85 07 ff ff ff    	jne    12461 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1255a:	e9 22 01 00 00       	jmp    12681 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1255f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12566:	e9 0c 01 00 00       	jmp    12677 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   1256b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1256e:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12572:	0f af 45 18          	imul   0x18(%ebp),%eax
   12576:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   12579:	8b 45 18             	mov    0x18(%ebp),%eax
   1257c:	0f af 45 10          	imul   0x10(%ebp),%eax
   12580:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12583:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1258a:	e9 d4 00 00 00       	jmp    12663 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   1258f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12596:	e9 b4 00 00 00       	jmp    1264f <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   1259b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1259e:	8b 14 85 f8 a2 01 00 	mov    0x1a2f8(,%eax,4),%edx
   125a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125a8:	8b 04 85 30 a3 01 00 	mov    0x1a330(,%eax,4),%eax
   125af:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   125b3:	01 d0                	add    %edx,%eax
   125b5:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   125b9:	89 c2                	mov    %eax,%edx
   125bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125be:	8b 0c 85 dc a2 01 00 	mov    0x1a2dc(,%eax,4),%ecx
   125c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125c8:	8b 04 85 14 a3 01 00 	mov    0x1a314(,%eax,4),%eax
   125cf:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   125d3:	01 c8                	add    %ecx,%eax
   125d5:	0f af 45 18          	imul   0x18(%ebp),%eax
   125d9:	01 d0                	add    %edx,%eax
   125db:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   125e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125e4:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   125eb:	c1 e0 03             	shl    $0x3,%eax
   125ee:	89 c1                	mov    %eax,%ecx
   125f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   125f3:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   125f7:	89 c2                	mov    %eax,%edx
   125f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   125fc:	0f af 45 18          	imul   0x18(%ebp),%eax
   12600:	01 d0                	add    %edx,%eax
   12602:	01 c8                	add    %ecx,%eax
   12604:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   1260a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   12611:	eb 30                	jmp    12643 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   12613:	ff 75 0c             	pushl  0xc(%ebp)
   12616:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   1261c:	50                   	push   %eax
   1261d:	e8 34 5e ff ff       	call   8456 <readBitFromReversedStream>
   12622:	83 c4 08             	add    $0x8,%esp
   12625:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12628:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   1262c:	50                   	push   %eax
   1262d:	ff 75 08             	pushl  0x8(%ebp)
   12630:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12636:	50                   	push   %eax
   12637:	e8 9c 5e ff ff       	call   84d8 <setBitOfReversedStream>
   1263c:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   1263f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   12643:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12646:	3b 45 18             	cmp    0x18(%ebp),%eax
   12649:	72 c8                	jb     12613 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1264b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1264f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12652:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12656:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12659:	0f 87 3c ff ff ff    	ja     1259b <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1265f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12663:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12666:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   1266a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1266d:	0f 87 1c ff ff ff    	ja     1258f <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12673:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12677:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1267b:	0f 85 ea fe ff ff    	jne    1256b <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12681:	90                   	nop
   12682:	c9                   	leave  
   12683:	c3                   	ret    

00012684 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   12684:	55                   	push   %ebp
   12685:	89 e5                	mov    %esp,%ebp
   12687:	57                   	push   %edi
   12688:	56                   	push   %esi
   12689:	53                   	push   %ebx
   1268a:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   12690:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12693:	83 c0 0c             	add    $0xc,%eax
   12696:	50                   	push   %eax
   12697:	e8 77 6a ff ff       	call   9113 <lodepng_get_bpp>
   1269c:	83 c4 04             	add    $0x4,%esp
   1269f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   126a2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   126a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   126ac:	8b 40 08             	mov    0x8(%eax),%eax
   126af:	85 c0                	test   %eax,%eax
   126b1:	0f 85 49 01 00 00    	jne    12800 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   126b7:	8b 45 14             	mov    0x14(%ebp),%eax
   126ba:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   126be:	83 c0 07             	add    $0x7,%eax
   126c1:	c1 e8 03             	shr    $0x3,%eax
   126c4:	83 c0 01             	add    $0x1,%eax
   126c7:	0f af 45 18          	imul   0x18(%ebp),%eax
   126cb:	89 c2                	mov    %eax,%edx
   126cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   126d0:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   126d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   126d5:	8b 00                	mov    (%eax),%eax
   126d7:	83 ec 0c             	sub    $0xc,%esp
   126da:	50                   	push   %eax
   126db:	e8 17 0f ff ff       	call   35f7 <lodepng_malloc>
   126e0:	83 c4 10             	add    $0x10,%esp
   126e3:	89 c2                	mov    %eax,%edx
   126e5:	8b 45 08             	mov    0x8(%ebp),%eax
   126e8:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   126ea:	8b 45 08             	mov    0x8(%ebp),%eax
   126ed:	8b 00                	mov    (%eax),%eax
   126ef:	85 c0                	test   %eax,%eax
   126f1:	75 10                	jne    12703 <preProcessScanlines+0x7f>
   126f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   126f6:	8b 00                	mov    (%eax),%eax
   126f8:	85 c0                	test   %eax,%eax
   126fa:	74 07                	je     12703 <preProcessScanlines+0x7f>
   126fc:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12703:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12707:	0f 85 fb 02 00 00    	jne    12a08 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   1270d:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12711:	0f 87 bd 00 00 00    	ja     127d4 <preProcessScanlines+0x150>
   12717:	8b 45 14             	mov    0x14(%ebp),%eax
   1271a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1271e:	89 c2                	mov    %eax,%edx
   12720:	8b 45 14             	mov    0x14(%ebp),%eax
   12723:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12727:	83 c0 07             	add    $0x7,%eax
   1272a:	c1 e8 03             	shr    $0x3,%eax
   1272d:	c1 e0 03             	shl    $0x3,%eax
   12730:	39 c2                	cmp    %eax,%edx
   12732:	0f 84 9c 00 00 00    	je     127d4 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12738:	8b 45 14             	mov    0x14(%ebp),%eax
   1273b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1273f:	83 c0 07             	add    $0x7,%eax
   12742:	c1 e8 03             	shr    $0x3,%eax
   12745:	0f af 45 18          	imul   0x18(%ebp),%eax
   12749:	83 ec 0c             	sub    $0xc,%esp
   1274c:	50                   	push   %eax
   1274d:	e8 a5 0e ff ff       	call   35f7 <lodepng_malloc>
   12752:	83 c4 10             	add    $0x10,%esp
   12755:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12758:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1275c:	75 07                	jne    12765 <preProcessScanlines+0xe1>
   1275e:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12765:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12769:	75 56                	jne    127c1 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   1276b:	8b 45 14             	mov    0x14(%ebp),%eax
   1276e:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12772:	89 c2                	mov    %eax,%edx
   12774:	8b 45 14             	mov    0x14(%ebp),%eax
   12777:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1277b:	83 c0 07             	add    $0x7,%eax
   1277e:	c1 e8 03             	shr    $0x3,%eax
   12781:	c1 e0 03             	shl    $0x3,%eax
   12784:	83 ec 0c             	sub    $0xc,%esp
   12787:	ff 75 18             	pushl  0x18(%ebp)
   1278a:	52                   	push   %edx
   1278b:	50                   	push   %eax
   1278c:	ff 75 10             	pushl  0x10(%ebp)
   1278f:	ff 75 d8             	pushl  -0x28(%ebp)
   12792:	e8 e7 fb ff ff       	call   1237e <addPaddingBits>
   12797:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   1279a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1279d:	8d 50 0c             	lea    0xc(%eax),%edx
   127a0:	8b 45 08             	mov    0x8(%ebp),%eax
   127a3:	8b 00                	mov    (%eax),%eax
   127a5:	83 ec 08             	sub    $0x8,%esp
   127a8:	ff 75 20             	pushl  0x20(%ebp)
   127ab:	52                   	push   %edx
   127ac:	ff 75 18             	pushl  0x18(%ebp)
   127af:	ff 75 14             	pushl  0x14(%ebp)
   127b2:	ff 75 d8             	pushl  -0x28(%ebp)
   127b5:	50                   	push   %eax
   127b6:	e8 dc f3 ff ff       	call   11b97 <filter>
   127bb:	83 c4 20             	add    $0x20,%esp
   127be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   127c1:	83 ec 0c             	sub    $0xc,%esp
   127c4:	ff 75 d8             	pushl  -0x28(%ebp)
   127c7:	e8 4c 0e ff ff       	call   3618 <lodepng_free>
   127cc:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   127cf:	e9 34 02 00 00       	jmp    12a08 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   127d4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   127d7:	8d 50 0c             	lea    0xc(%eax),%edx
   127da:	8b 45 08             	mov    0x8(%ebp),%eax
   127dd:	8b 00                	mov    (%eax),%eax
   127df:	83 ec 08             	sub    $0x8,%esp
   127e2:	ff 75 20             	pushl  0x20(%ebp)
   127e5:	52                   	push   %edx
   127e6:	ff 75 18             	pushl  0x18(%ebp)
   127e9:	ff 75 14             	pushl  0x14(%ebp)
   127ec:	ff 75 10             	pushl  0x10(%ebp)
   127ef:	50                   	push   %eax
   127f0:	e8 a2 f3 ff ff       	call   11b97 <filter>
   127f5:	83 c4 20             	add    $0x20,%esp
   127f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   127fb:	e9 08 02 00 00       	jmp    12a08 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12800:	ff 75 dc             	pushl  -0x24(%ebp)
   12803:	ff 75 18             	pushl  0x18(%ebp)
   12806:	ff 75 14             	pushl  0x14(%ebp)
   12809:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1280f:	50                   	push   %eax
   12810:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12816:	50                   	push   %eax
   12817:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   1281d:	50                   	push   %eax
   1281e:	8d 45 98             	lea    -0x68(%ebp),%eax
   12821:	50                   	push   %eax
   12822:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12825:	50                   	push   %eax
   12826:	e8 19 ab ff ff       	call   d344 <Adam7_getpassvalues>
   1282b:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   1282e:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12834:	8b 45 0c             	mov    0xc(%ebp),%eax
   12837:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12839:	8b 45 0c             	mov    0xc(%ebp),%eax
   1283c:	8b 00                	mov    (%eax),%eax
   1283e:	83 ec 0c             	sub    $0xc,%esp
   12841:	50                   	push   %eax
   12842:	e8 b0 0d ff ff       	call   35f7 <lodepng_malloc>
   12847:	83 c4 10             	add    $0x10,%esp
   1284a:	89 c2                	mov    %eax,%edx
   1284c:	8b 45 08             	mov    0x8(%ebp),%eax
   1284f:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   12851:	8b 45 08             	mov    0x8(%ebp),%eax
   12854:	8b 00                	mov    (%eax),%eax
   12856:	85 c0                	test   %eax,%eax
   12858:	75 07                	jne    12861 <preProcessScanlines+0x1dd>
   1285a:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   12861:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12864:	83 ec 0c             	sub    $0xc,%esp
   12867:	50                   	push   %eax
   12868:	e8 8a 0d ff ff       	call   35f7 <lodepng_malloc>
   1286d:	83 c4 10             	add    $0x10,%esp
   12870:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   12873:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12877:	75 0e                	jne    12887 <preProcessScanlines+0x203>
   12879:	8b 45 94             	mov    -0x6c(%ebp),%eax
   1287c:	85 c0                	test   %eax,%eax
   1287e:	74 07                	je     12887 <preProcessScanlines+0x203>
   12880:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12887:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1288b:	0f 85 69 01 00 00    	jne    129fa <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   12891:	83 ec 0c             	sub    $0xc,%esp
   12894:	ff 75 dc             	pushl  -0x24(%ebp)
   12897:	ff 75 18             	pushl  0x18(%ebp)
   1289a:	ff 75 14             	pushl  0x14(%ebp)
   1289d:	ff 75 10             	pushl  0x10(%ebp)
   128a0:	ff 75 d4             	pushl  -0x2c(%ebp)
   128a3:	e8 6c fb ff ff       	call   12414 <Adam7_interlace>
   128a8:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   128ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   128b2:	e9 36 01 00 00       	jmp    129ed <preProcessScanlines+0x369>
        if(bpp < 8) {
   128b7:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   128bb:	0f 87 d6 00 00 00    	ja     12997 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   128c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   128c4:	83 c0 01             	add    $0x1,%eax
   128c7:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   128ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
   128d1:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   128d8:	29 c2                	sub    %eax,%edx
   128da:	89 d0                	mov    %edx,%eax
   128dc:	83 ec 0c             	sub    $0xc,%esp
   128df:	50                   	push   %eax
   128e0:	e8 12 0d ff ff       	call   35f7 <lodepng_malloc>
   128e5:	83 c4 10             	add    $0x10,%esp
   128e8:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   128eb:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   128ef:	75 0c                	jne    128fd <preProcessScanlines+0x279>
   128f1:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   128f8:	e9 fd 00 00 00       	jmp    129fa <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   128fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12900:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12904:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12907:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   1290b:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1290f:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12911:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12914:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12918:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   1291c:	83 c2 07             	add    $0x7,%edx
   1291f:	c1 ea 03             	shr    $0x3,%edx
   12922:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12925:	89 d1                	mov    %edx,%ecx
   12927:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1292a:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   12931:	89 d6                	mov    %edx,%esi
   12933:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12936:	01 f2                	add    %esi,%edx
   12938:	83 ec 0c             	sub    $0xc,%esp
   1293b:	50                   	push   %eax
   1293c:	53                   	push   %ebx
   1293d:	51                   	push   %ecx
   1293e:	52                   	push   %edx
   1293f:	ff 75 d0             	pushl  -0x30(%ebp)
   12942:	e8 37 fa ff ff       	call   1237e <addPaddingBits>
   12947:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   1294a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1294d:	8d 58 0c             	lea    0xc(%eax),%ebx
   12950:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12953:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12957:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1295a:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   1295e:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12961:	8b 31                	mov    (%ecx),%esi
   12963:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12966:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   1296d:	01 f1                	add    %esi,%ecx
   1296f:	83 ec 08             	sub    $0x8,%esp
   12972:	ff 75 20             	pushl  0x20(%ebp)
   12975:	53                   	push   %ebx
   12976:	52                   	push   %edx
   12977:	50                   	push   %eax
   12978:	ff 75 d0             	pushl  -0x30(%ebp)
   1297b:	51                   	push   %ecx
   1297c:	e8 16 f2 ff ff       	call   11b97 <filter>
   12981:	83 c4 20             	add    $0x20,%esp
   12984:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   12987:	83 ec 0c             	sub    $0xc,%esp
   1298a:	ff 75 d0             	pushl  -0x30(%ebp)
   1298d:	e8 86 0c ff ff       	call   3618 <lodepng_free>
   12992:	83 c4 10             	add    $0x10,%esp
   12995:	eb 4c                	jmp    129e3 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   12997:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1299a:	8d 70 0c             	lea    0xc(%eax),%esi
   1299d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   129a0:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   129a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   129a7:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   129ab:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   129ae:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   129b5:	89 cb                	mov    %ecx,%ebx
   129b7:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   129ba:	01 cb                	add    %ecx,%ebx
   129bc:	8b 4d 08             	mov    0x8(%ebp),%ecx
   129bf:	8b 39                	mov    (%ecx),%edi
   129c1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   129c4:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   129cb:	01 f9                	add    %edi,%ecx
   129cd:	83 ec 08             	sub    $0x8,%esp
   129d0:	ff 75 20             	pushl  0x20(%ebp)
   129d3:	56                   	push   %esi
   129d4:	52                   	push   %edx
   129d5:	50                   	push   %eax
   129d6:	53                   	push   %ebx
   129d7:	51                   	push   %ecx
   129d8:	e8 ba f1 ff ff       	call   11b97 <filter>
   129dd:	83 c4 20             	add    $0x20,%esp
   129e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   129e3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   129e7:	75 10                	jne    129f9 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   129e9:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   129ed:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   129f1:	0f 85 c0 fe ff ff    	jne    128b7 <preProcessScanlines+0x233>
   129f7:	eb 01                	jmp    129fa <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   129f9:	90                   	nop
      }
    }

    lodepng_free(adam7);
   129fa:	83 ec 0c             	sub    $0xc,%esp
   129fd:	ff 75 d4             	pushl  -0x2c(%ebp)
   12a00:	e8 13 0c ff ff       	call   3618 <lodepng_free>
   12a05:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12a08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12a0b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12a0e:	5b                   	pop    %ebx
   12a0f:	5e                   	pop    %esi
   12a10:	5f                   	pop    %edi
   12a11:	5d                   	pop    %ebp
   12a12:	c3                   	ret    

00012a13 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   12a13:	55                   	push   %ebp
   12a14:	89 e5                	mov    %esp,%ebp
   12a16:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12a19:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a1c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   12a1f:	eb 47                	jmp    12a68 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   12a21:	8b 45 08             	mov    0x8(%ebp),%eax
   12a24:	8d 50 04             	lea    0x4(%eax),%edx
   12a27:	8b 45 08             	mov    0x8(%ebp),%eax
   12a2a:	ff 75 fc             	pushl  -0x4(%ebp)
   12a2d:	52                   	push   %edx
   12a2e:	50                   	push   %eax
   12a2f:	e8 73 5f ff ff       	call   89a7 <lodepng_chunk_append>
   12a34:	83 c4 0c             	add    $0xc,%esp
   12a37:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12a3a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12a3e:	74 05                	je     12a45 <addUnknownChunks+0x32>
   12a40:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12a43:	eb 37                	jmp    12a7c <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12a45:	8b 45 08             	mov    0x8(%ebp),%eax
   12a48:	8b 50 04             	mov    0x4(%eax),%edx
   12a4b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a4e:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   12a51:	8b 55 10             	mov    0x10(%ebp),%edx
   12a54:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a57:	01 d0                	add    %edx,%eax
   12a59:	50                   	push   %eax
   12a5a:	ff 75 fc             	pushl  -0x4(%ebp)
   12a5d:	e8 ff 5c ff ff       	call   8761 <lodepng_chunk_next>
   12a62:	83 c4 08             	add    $0x8,%esp
   12a65:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12a68:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12a6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a6e:	29 c2                	sub    %eax,%edx
   12a70:	89 d0                	mov    %edx,%eax
   12a72:	3b 45 10             	cmp    0x10(%ebp),%eax
   12a75:	7c aa                	jl     12a21 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12a77:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12a7c:	c9                   	leave  
   12a7d:	c3                   	ret    

00012a7e <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   12a7e:	55                   	push   %ebp
   12a7f:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   12a81:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12a85:	77 07                	ja     12a8e <isGrayICCProfile+0x10>
   12a87:	b8 00 00 00 00       	mov    $0x0,%eax
   12a8c:	eb 40                	jmp    12ace <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12a8e:	8b 45 08             	mov    0x8(%ebp),%eax
   12a91:	83 c0 10             	add    $0x10,%eax
   12a94:	0f b6 00             	movzbl (%eax),%eax
   12a97:	3c 47                	cmp    $0x47,%al
   12a99:	75 2e                	jne    12ac9 <isGrayICCProfile+0x4b>
   12a9b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a9e:	83 c0 11             	add    $0x11,%eax
   12aa1:	0f b6 00             	movzbl (%eax),%eax
   12aa4:	3c 52                	cmp    $0x52,%al
   12aa6:	75 21                	jne    12ac9 <isGrayICCProfile+0x4b>
   12aa8:	8b 45 08             	mov    0x8(%ebp),%eax
   12aab:	83 c0 12             	add    $0x12,%eax
   12aae:	0f b6 00             	movzbl (%eax),%eax
   12ab1:	3c 41                	cmp    $0x41,%al
   12ab3:	75 14                	jne    12ac9 <isGrayICCProfile+0x4b>
   12ab5:	8b 45 08             	mov    0x8(%ebp),%eax
   12ab8:	83 c0 13             	add    $0x13,%eax
   12abb:	0f b6 00             	movzbl (%eax),%eax
   12abe:	3c 59                	cmp    $0x59,%al
   12ac0:	75 07                	jne    12ac9 <isGrayICCProfile+0x4b>
   12ac2:	b8 01 00 00 00       	mov    $0x1,%eax
   12ac7:	eb 05                	jmp    12ace <isGrayICCProfile+0x50>
   12ac9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12ace:	5d                   	pop    %ebp
   12acf:	c3                   	ret    

00012ad0 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   12ad0:	55                   	push   %ebp
   12ad1:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   12ad3:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12ad7:	77 07                	ja     12ae0 <isRGBICCProfile+0x10>
   12ad9:	b8 00 00 00 00       	mov    $0x0,%eax
   12ade:	eb 40                	jmp    12b20 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   12ae0:	8b 45 08             	mov    0x8(%ebp),%eax
   12ae3:	83 c0 10             	add    $0x10,%eax
   12ae6:	0f b6 00             	movzbl (%eax),%eax
   12ae9:	3c 52                	cmp    $0x52,%al
   12aeb:	75 2e                	jne    12b1b <isRGBICCProfile+0x4b>
   12aed:	8b 45 08             	mov    0x8(%ebp),%eax
   12af0:	83 c0 11             	add    $0x11,%eax
   12af3:	0f b6 00             	movzbl (%eax),%eax
   12af6:	3c 47                	cmp    $0x47,%al
   12af8:	75 21                	jne    12b1b <isRGBICCProfile+0x4b>
   12afa:	8b 45 08             	mov    0x8(%ebp),%eax
   12afd:	83 c0 12             	add    $0x12,%eax
   12b00:	0f b6 00             	movzbl (%eax),%eax
   12b03:	3c 42                	cmp    $0x42,%al
   12b05:	75 14                	jne    12b1b <isRGBICCProfile+0x4b>
   12b07:	8b 45 08             	mov    0x8(%ebp),%eax
   12b0a:	83 c0 13             	add    $0x13,%eax
   12b0d:	0f b6 00             	movzbl (%eax),%eax
   12b10:	3c 20                	cmp    $0x20,%al
   12b12:	75 07                	jne    12b1b <isRGBICCProfile+0x4b>
   12b14:	b8 01 00 00 00       	mov    $0x1,%eax
   12b19:	eb 05                	jmp    12b20 <isRGBICCProfile+0x50>
   12b1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12b20:	5d                   	pop    %ebp
   12b21:	c3                   	ret    

00012b22 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12b22:	55                   	push   %ebp
   12b23:	89 e5                	mov    %esp,%ebp
   12b25:	57                   	push   %edi
   12b26:	56                   	push   %esi
   12b27:	53                   	push   %ebx
   12b28:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   12b2e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12b35:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12b3c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12b3f:	6a 00                	push   $0x0
   12b41:	6a 00                	push   $0x0
   12b43:	50                   	push   %eax
   12b44:	e8 6f 0d ff ff       	call   38b8 <ucvector_init>
   12b49:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12b4c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b4f:	05 98 00 00 00       	add    $0x98,%eax
   12b54:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12b57:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b5d:	50                   	push   %eax
   12b5e:	e8 3a 71 ff ff       	call   9c9d <lodepng_info_init>
   12b63:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12b66:	8b 45 08             	mov    0x8(%ebp),%eax
   12b69:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   12b6f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12b78:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b7b:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   12b82:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   12b85:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b88:	8b 40 0c             	mov    0xc(%eax),%eax
   12b8b:	83 f8 03             	cmp    $0x3,%eax
   12b8e:	74 0a                	je     12b9a <lodepng_encode+0x78>
   12b90:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b93:	8b 40 6c             	mov    0x6c(%eax),%eax
   12b96:	85 c0                	test   %eax,%eax
   12b98:	74 29                	je     12bc3 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12b9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b9d:	8b 40 18             	mov    0x18(%eax),%eax
   12ba0:	85 c0                	test   %eax,%eax
   12ba2:	74 0d                	je     12bb1 <lodepng_encode+0x8f>
   12ba4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ba7:	8b 40 18             	mov    0x18(%eax),%eax
   12baa:	3d 00 01 00 00       	cmp    $0x100,%eax
   12baf:	7e 12                	jle    12bc3 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   12bb1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bb4:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   12bbb:	00 00 00 
    goto cleanup;
   12bbe:	e9 78 0c 00 00       	jmp    1383b <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   12bc3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bc6:	8b 40 38             	mov    0x38(%eax),%eax
   12bc9:	83 f8 02             	cmp    $0x2,%eax
   12bcc:	76 12                	jbe    12be0 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   12bce:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bd1:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12bd8:	00 00 00 
    goto cleanup;
   12bdb:	e9 5b 0c 00 00       	jmp    1383b <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   12be0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12be3:	8b 40 08             	mov    0x8(%eax),%eax
   12be6:	83 f8 01             	cmp    $0x1,%eax
   12be9:	76 12                	jbe    12bfd <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   12beb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bee:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12bf5:	00 00 00 
    goto cleanup;
   12bf8:	e9 3e 0c 00 00       	jmp    1383b <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   12bfd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c00:	8b 50 10             	mov    0x10(%eax),%edx
   12c03:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c06:	8b 40 0c             	mov    0xc(%eax),%eax
   12c09:	52                   	push   %edx
   12c0a:	50                   	push   %eax
   12c0b:	e8 a4 5f ff ff       	call   8bb4 <checkColorValidity>
   12c10:	83 c4 08             	add    $0x8,%esp
   12c13:	89 c2                	mov    %eax,%edx
   12c15:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c18:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12c1e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c21:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c27:	85 c0                	test   %eax,%eax
   12c29:	0f 85 c6 0b 00 00    	jne    137f5 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   12c2f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c32:	8b 50 7c             	mov    0x7c(%eax),%edx
   12c35:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c38:	8b 40 78             	mov    0x78(%eax),%eax
   12c3b:	52                   	push   %edx
   12c3c:	50                   	push   %eax
   12c3d:	e8 72 5f ff ff       	call   8bb4 <checkColorValidity>
   12c42:	83 c4 08             	add    $0x8,%esp
   12c45:	89 c2                	mov    %eax,%edx
   12c47:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c4a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12c50:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c53:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c59:	85 c0                	test   %eax,%eax
   12c5b:	0f 85 97 0b 00 00    	jne    137f8 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12c61:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c64:	05 98 00 00 00       	add    $0x98,%eax
   12c69:	83 ec 08             	sub    $0x8,%esp
   12c6c:	50                   	push   %eax
   12c6d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c73:	50                   	push   %eax
   12c74:	e8 58 71 ff ff       	call   9dd1 <lodepng_info_copy>
   12c79:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12c7c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c7f:	8b 40 5c             	mov    0x5c(%eax),%eax
   12c82:	85 c0                	test   %eax,%eax
   12c84:	0f 84 3c 02 00 00    	je     12ec6 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12c8a:	83 ec 0c             	sub    $0xc,%esp
   12c8d:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12c93:	50                   	push   %eax
   12c94:	e8 5f 96 ff ff       	call   c2f8 <lodepng_color_stats_init>
   12c99:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12c9c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c9f:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12ca5:	85 c0                	test   %eax,%eax
   12ca7:	74 2d                	je     12cd6 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12ca9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cac:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12cb2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cb5:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12cbb:	83 ec 08             	sub    $0x8,%esp
   12cbe:	52                   	push   %edx
   12cbf:	50                   	push   %eax
   12cc0:	e8 b9 fd ff ff       	call   12a7e <isGrayICCProfile>
   12cc5:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12cc8:	85 c0                	test   %eax,%eax
   12cca:	74 0a                	je     12cd6 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12ccc:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12cd3:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12cd6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cd9:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12cdf:	85 c0                	test   %eax,%eax
   12ce1:	74 2d                	je     12d10 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12ce3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ce6:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12cec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cef:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12cf5:	83 ec 08             	sub    $0x8,%esp
   12cf8:	52                   	push   %edx
   12cf9:	50                   	push   %eax
   12cfa:	e8 d1 fd ff ff       	call   12ad0 <isRGBICCProfile>
   12cff:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12d02:	85 c0                	test   %eax,%eax
   12d04:	74 0a                	je     12d10 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12d06:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12d0d:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12d10:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d13:	83 c0 78             	add    $0x78,%eax
   12d16:	83 ec 0c             	sub    $0xc,%esp
   12d19:	50                   	push   %eax
   12d1a:	ff 75 18             	pushl  0x18(%ebp)
   12d1d:	ff 75 14             	pushl  0x14(%ebp)
   12d20:	ff 75 10             	pushl  0x10(%ebp)
   12d23:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12d29:	50                   	push   %eax
   12d2a:	e8 e0 96 ff ff       	call   c40f <lodepng_compute_color_stats>
   12d2f:	83 c4 20             	add    $0x20,%esp
   12d32:	89 c2                	mov    %eax,%edx
   12d34:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d37:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12d3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d40:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d46:	85 c0                	test   %eax,%eax
   12d48:	0f 85 ad 0a 00 00    	jne    137fb <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12d4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d51:	8b 40 2c             	mov    0x2c(%eax),%eax
   12d54:	85 c0                	test   %eax,%eax
   12d56:	0f 84 be 00 00 00    	je     12e1a <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12d5c:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12d63:	00 00 00 
   12d66:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12d6d:	00 00 00 
   12d70:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12d77:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12d7a:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12d80:	83 ec 04             	sub    $0x4,%esp
   12d83:	6a 10                	push   $0x10
   12d85:	6a 02                	push   $0x2
   12d87:	50                   	push   %eax
   12d88:	e8 15 61 ff ff       	call   8ea2 <lodepng_color_mode_make>
   12d8d:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12d90:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d93:	8d 58 0c             	lea    0xc(%eax),%ebx
   12d96:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d99:	8b 48 38             	mov    0x38(%eax),%ecx
   12d9c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d9f:	8b 50 34             	mov    0x34(%eax),%edx
   12da2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12da5:	8b 40 30             	mov    0x30(%eax),%eax
   12da8:	53                   	push   %ebx
   12da9:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12daf:	53                   	push   %ebx
   12db0:	51                   	push   %ecx
   12db1:	52                   	push   %edx
   12db2:	50                   	push   %eax
   12db3:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12db9:	50                   	push   %eax
   12dba:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12dc0:	50                   	push   %eax
   12dc1:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12dc7:	50                   	push   %eax
   12dc8:	e8 8a 92 ff ff       	call   c057 <lodepng_convert_rgb>
   12dcd:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12dd0:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12dd6:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12ddc:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12de2:	83 ec 0c             	sub    $0xc,%esp
   12de5:	68 ff ff 00 00       	push   $0xffff
   12dea:	51                   	push   %ecx
   12deb:	52                   	push   %edx
   12dec:	50                   	push   %eax
   12ded:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12df3:	50                   	push   %eax
   12df4:	e8 26 a1 ff ff       	call   cf1f <lodepng_color_stats_add>
   12df9:	83 c4 20             	add    $0x20,%esp
   12dfc:	89 c2                	mov    %eax,%edx
   12dfe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e01:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12e07:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e0a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e10:	85 c0                	test   %eax,%eax
   12e12:	74 06                	je     12e1a <lodepng_encode+0x2f8>
   12e14:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12e15:	e9 e1 09 00 00       	jmp    137fb <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12e1a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e1d:	8d 50 78             	lea    0x78(%eax),%edx
   12e20:	83 ec 04             	sub    $0x4,%esp
   12e23:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12e29:	50                   	push   %eax
   12e2a:	52                   	push   %edx
   12e2b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e31:	83 c0 0c             	add    $0xc,%eax
   12e34:	50                   	push   %eax
   12e35:	e8 79 a1 ff ff       	call   cfb3 <auto_choose_color>
   12e3a:	83 c4 10             	add    $0x10,%esp
   12e3d:	89 c2                	mov    %eax,%edx
   12e3f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e42:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e48:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e4b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e51:	85 c0                	test   %eax,%eax
   12e53:	0f 85 a5 09 00 00    	jne    137fe <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12e59:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e5c:	8b 40 2c             	mov    0x2c(%eax),%eax
   12e5f:	85 c0                	test   %eax,%eax
   12e61:	74 63                	je     12ec6 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12e63:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e66:	8d 58 0c             	lea    0xc(%eax),%ebx
   12e69:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e6c:	8b 48 38             	mov    0x38(%eax),%ecx
   12e6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e72:	8b 50 34             	mov    0x34(%eax),%edx
   12e75:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e78:	8b 40 30             	mov    0x30(%eax),%eax
   12e7b:	53                   	push   %ebx
   12e7c:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12e82:	83 c3 0c             	add    $0xc,%ebx
   12e85:	53                   	push   %ebx
   12e86:	51                   	push   %ecx
   12e87:	52                   	push   %edx
   12e88:	50                   	push   %eax
   12e89:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e8f:	83 c0 38             	add    $0x38,%eax
   12e92:	50                   	push   %eax
   12e93:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e99:	83 c0 34             	add    $0x34,%eax
   12e9c:	50                   	push   %eax
   12e9d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ea3:	83 c0 30             	add    $0x30,%eax
   12ea6:	50                   	push   %eax
   12ea7:	e8 ab 91 ff ff       	call   c057 <lodepng_convert_rgb>
   12eac:	83 c4 20             	add    $0x20,%esp
   12eaf:	85 c0                	test   %eax,%eax
   12eb1:	74 13                	je     12ec6 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12eb3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eb6:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12ebd:	00 00 00 
        goto cleanup;
   12ec0:	90                   	nop
   12ec1:	e9 75 09 00 00       	jmp    1383b <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12ec6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ec9:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12ecf:	85 c0                	test   %eax,%eax
   12ed1:	0f 84 b2 00 00 00    	je     12f89 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12ed7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12eda:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12ee0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ee3:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12ee9:	83 ec 08             	sub    $0x8,%esp
   12eec:	52                   	push   %edx
   12eed:	50                   	push   %eax
   12eee:	e8 8b fb ff ff       	call   12a7e <isGrayICCProfile>
   12ef3:	83 c4 10             	add    $0x10,%esp
   12ef6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12ef9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12efc:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12f02:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12f05:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12f0b:	83 ec 08             	sub    $0x8,%esp
   12f0e:	52                   	push   %edx
   12f0f:	50                   	push   %eax
   12f10:	e8 bb fb ff ff       	call   12ad0 <isRGBICCProfile>
   12f15:	83 c4 10             	add    $0x10,%esp
   12f18:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12f1b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12f21:	85 c0                	test   %eax,%eax
   12f23:	74 0b                	je     12f30 <lodepng_encode+0x40e>
   12f25:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12f2b:	83 f8 04             	cmp    $0x4,%eax
   12f2e:	75 07                	jne    12f37 <lodepng_encode+0x415>
   12f30:	b8 01 00 00 00       	mov    $0x1,%eax
   12f35:	eb 05                	jmp    12f3c <lodepng_encode+0x41a>
   12f37:	b8 00 00 00 00       	mov    $0x0,%eax
   12f3c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12f3f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12f43:	75 18                	jne    12f5d <lodepng_encode+0x43b>
   12f45:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12f49:	75 12                	jne    12f5d <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12f4b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f4e:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12f55:	00 00 00 
      goto cleanup;
   12f58:	e9 de 08 00 00       	jmp    1383b <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12f5d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12f60:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12f63:	74 24                	je     12f89 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12f65:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f68:	8b 40 5c             	mov    0x5c(%eax),%eax
   12f6b:	85 c0                	test   %eax,%eax
   12f6d:	74 07                	je     12f76 <lodepng_encode+0x454>
   12f6f:	ba 66 00 00 00       	mov    $0x66,%edx
   12f74:	eb 05                	jmp    12f7b <lodepng_encode+0x459>
   12f76:	ba 65 00 00 00       	mov    $0x65,%edx
   12f7b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f7e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12f84:	e9 b2 08 00 00       	jmp    1383b <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12f89:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f8c:	83 c0 78             	add    $0x78,%eax
   12f8f:	83 ec 08             	sub    $0x8,%esp
   12f92:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12f98:	83 c2 0c             	add    $0xc,%edx
   12f9b:	52                   	push   %edx
   12f9c:	50                   	push   %eax
   12f9d:	e8 57 5f ff ff       	call   8ef9 <lodepng_color_mode_equal>
   12fa2:	83 c4 10             	add    $0x10,%esp
   12fa5:	85 c0                	test   %eax,%eax
   12fa7:	0f 85 f8 00 00 00    	jne    130a5 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12fad:	8b 55 14             	mov    0x14(%ebp),%edx
   12fb0:	8b 45 18             	mov    0x18(%ebp),%eax
   12fb3:	89 d3                	mov    %edx,%ebx
   12fb5:	0f af d8             	imul   %eax,%ebx
   12fb8:	83 ec 0c             	sub    $0xc,%esp
   12fbb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fc1:	83 c0 0c             	add    $0xc,%eax
   12fc4:	50                   	push   %eax
   12fc5:	e8 49 61 ff ff       	call   9113 <lodepng_get_bpp>
   12fca:	83 c4 10             	add    $0x10,%esp
   12fcd:	0f af c3             	imul   %ebx,%eax
   12fd0:	83 c0 07             	add    $0x7,%eax
   12fd3:	c1 e8 03             	shr    $0x3,%eax
   12fd6:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12fd9:	83 ec 0c             	sub    $0xc,%esp
   12fdc:	ff 75 cc             	pushl  -0x34(%ebp)
   12fdf:	e8 13 06 ff ff       	call   35f7 <lodepng_malloc>
   12fe4:	83 c4 10             	add    $0x10,%esp
   12fe7:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12fea:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12fee:	75 13                	jne    13003 <lodepng_encode+0x4e1>
   12ff0:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12ff4:	74 0d                	je     13003 <lodepng_encode+0x4e1>
   12ff6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ff9:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   13000:	00 00 00 
    if(!state->error) {
   13003:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13006:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1300c:	85 c0                	test   %eax,%eax
   1300e:	75 33                	jne    13043 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   13010:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13013:	83 c0 78             	add    $0x78,%eax
   13016:	83 ec 08             	sub    $0x8,%esp
   13019:	ff 75 18             	pushl  0x18(%ebp)
   1301c:	ff 75 14             	pushl  0x14(%ebp)
   1301f:	50                   	push   %eax
   13020:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13026:	83 c0 0c             	add    $0xc,%eax
   13029:	50                   	push   %eax
   1302a:	ff 75 10             	pushl  0x10(%ebp)
   1302d:	ff 75 c8             	pushl  -0x38(%ebp)
   13030:	e8 c9 8c ff ff       	call   bcfe <lodepng_convert>
   13035:	83 c4 20             	add    $0x20,%esp
   13038:	89 c2                	mov    %eax,%edx
   1303a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1303d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   13043:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13046:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1304c:	85 c0                	test   %eax,%eax
   1304e:	75 35                	jne    13085 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   13050:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13053:	83 c0 38             	add    $0x38,%eax
   13056:	83 ec 04             	sub    $0x4,%esp
   13059:	50                   	push   %eax
   1305a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13060:	50                   	push   %eax
   13061:	ff 75 18             	pushl  0x18(%ebp)
   13064:	ff 75 14             	pushl  0x14(%ebp)
   13067:	ff 75 c8             	pushl  -0x38(%ebp)
   1306a:	8d 45 bc             	lea    -0x44(%ebp),%eax
   1306d:	50                   	push   %eax
   1306e:	8d 45 c0             	lea    -0x40(%ebp),%eax
   13071:	50                   	push   %eax
   13072:	e8 0d f6 ff ff       	call   12684 <preProcessScanlines>
   13077:	83 c4 20             	add    $0x20,%esp
   1307a:	89 c2                	mov    %eax,%edx
   1307c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1307f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   13085:	83 ec 0c             	sub    $0xc,%esp
   13088:	ff 75 c8             	pushl  -0x38(%ebp)
   1308b:	e8 88 05 ff ff       	call   3618 <lodepng_free>
   13090:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   13093:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13096:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1309c:	85 c0                	test   %eax,%eax
   1309e:	74 4b                	je     130eb <lodepng_encode+0x5c9>
   130a0:	e9 96 07 00 00       	jmp    1383b <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   130a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130a8:	83 c0 38             	add    $0x38,%eax
   130ab:	83 ec 04             	sub    $0x4,%esp
   130ae:	50                   	push   %eax
   130af:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130b5:	50                   	push   %eax
   130b6:	ff 75 18             	pushl  0x18(%ebp)
   130b9:	ff 75 14             	pushl  0x14(%ebp)
   130bc:	ff 75 10             	pushl  0x10(%ebp)
   130bf:	8d 45 bc             	lea    -0x44(%ebp),%eax
   130c2:	50                   	push   %eax
   130c3:	8d 45 c0             	lea    -0x40(%ebp),%eax
   130c6:	50                   	push   %eax
   130c7:	e8 b8 f5 ff ff       	call   12684 <preProcessScanlines>
   130cc:	83 c4 20             	add    $0x20,%esp
   130cf:	89 c2                	mov    %eax,%edx
   130d1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130d4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   130da:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130dd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130e3:	85 c0                	test   %eax,%eax
   130e5:	0f 85 16 07 00 00    	jne    13801 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   130eb:	83 ec 0c             	sub    $0xc,%esp
   130ee:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130f1:	50                   	push   %eax
   130f2:	e8 21 d9 ff ff       	call   10a18 <writeSignature>
   130f7:	83 c4 10             	add    $0x10,%esp
   130fa:	89 c2                	mov    %eax,%edx
   130fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ff:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13105:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13108:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1310e:	85 c0                	test   %eax,%eax
   13110:	0f 85 ee 06 00 00    	jne    13804 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   13116:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   1311c:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   13122:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13128:	83 ec 08             	sub    $0x8,%esp
   1312b:	51                   	push   %ecx
   1312c:	52                   	push   %edx
   1312d:	50                   	push   %eax
   1312e:	ff 75 18             	pushl  0x18(%ebp)
   13131:	ff 75 14             	pushl  0x14(%ebp)
   13134:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13137:	50                   	push   %eax
   13138:	e8 4a d9 ff ff       	call   10a87 <addChunk_IHDR>
   1313d:	83 c4 20             	add    $0x20,%esp
   13140:	89 c2                	mov    %eax,%edx
   13142:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13145:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1314b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1314e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13154:	85 c0                	test   %eax,%eax
   13156:	0f 85 ab 06 00 00    	jne    13807 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   1315c:	8b 45 98             	mov    -0x68(%ebp),%eax
   1315f:	85 c0                	test   %eax,%eax
   13161:	74 33                	je     13196 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   13163:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   13166:	8b 45 98             	mov    -0x68(%ebp),%eax
   13169:	83 ec 04             	sub    $0x4,%esp
   1316c:	52                   	push   %edx
   1316d:	50                   	push   %eax
   1316e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13171:	50                   	push   %eax
   13172:	e8 9c f8 ff ff       	call   12a13 <addUnknownChunks>
   13177:	83 c4 10             	add    $0x10,%esp
   1317a:	89 c2                	mov    %eax,%edx
   1317c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1317f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13185:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13188:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1318e:	85 c0                	test   %eax,%eax
   13190:	0f 85 74 06 00 00    	jne    1380a <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   13196:	8b 45 88             	mov    -0x78(%ebp),%eax
   13199:	85 c0                	test   %eax,%eax
   1319b:	74 39                	je     131d6 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   1319d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131a0:	83 c0 38             	add    $0x38,%eax
   131a3:	83 ec 04             	sub    $0x4,%esp
   131a6:	50                   	push   %eax
   131a7:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   131ad:	50                   	push   %eax
   131ae:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131b1:	50                   	push   %eax
   131b2:	e8 a4 e4 ff ff       	call   1165b <addChunk_iCCP>
   131b7:	83 c4 10             	add    $0x10,%esp
   131ba:	89 c2                	mov    %eax,%edx
   131bc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131bf:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131c8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131ce:	85 c0                	test   %eax,%eax
   131d0:	0f 85 37 06 00 00    	jne    1380d <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   131d6:	8b 45 80             	mov    -0x80(%ebp),%eax
   131d9:	85 c0                	test   %eax,%eax
   131db:	74 32                	je     1320f <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   131dd:	83 ec 08             	sub    $0x8,%esp
   131e0:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   131e6:	50                   	push   %eax
   131e7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131ea:	50                   	push   %eax
   131eb:	e8 41 e4 ff ff       	call   11631 <addChunk_sRGB>
   131f0:	83 c4 10             	add    $0x10,%esp
   131f3:	89 c2                	mov    %eax,%edx
   131f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131f8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13201:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13207:	85 c0                	test   %eax,%eax
   13209:	0f 85 01 06 00 00    	jne    13810 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   1320f:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   13215:	85 c0                	test   %eax,%eax
   13217:	74 32                	je     1324b <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   13219:	83 ec 08             	sub    $0x8,%esp
   1321c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13222:	50                   	push   %eax
   13223:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13226:	50                   	push   %eax
   13227:	e8 a7 e2 ff ff       	call   114d3 <addChunk_gAMA>
   1322c:	83 c4 10             	add    $0x10,%esp
   1322f:	89 c2                	mov    %eax,%edx
   13231:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13234:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1323a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1323d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13243:	85 c0                	test   %eax,%eax
   13245:	0f 85 c8 05 00 00    	jne    13813 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   1324b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   13251:	85 c0                	test   %eax,%eax
   13253:	74 32                	je     13287 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   13255:	83 ec 08             	sub    $0x8,%esp
   13258:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1325e:	50                   	push   %eax
   1325f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13262:	50                   	push   %eax
   13263:	e8 c1 e2 ff ff       	call   11529 <addChunk_cHRM>
   13268:	83 c4 10             	add    $0x10,%esp
   1326b:	89 c2                	mov    %eax,%edx
   1326d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13270:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13276:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13279:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1327f:	85 c0                	test   %eax,%eax
   13281:	0f 85 8f 05 00 00    	jne    13816 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   13287:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1328d:	83 f8 03             	cmp    $0x3,%eax
   13290:	75 35                	jne    132c7 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   13292:	83 ec 08             	sub    $0x8,%esp
   13295:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1329b:	83 c0 0c             	add    $0xc,%eax
   1329e:	50                   	push   %eax
   1329f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   132a2:	50                   	push   %eax
   132a3:	e8 78 d8 ff ff       	call   10b20 <addChunk_PLTE>
   132a8:	83 c4 10             	add    $0x10,%esp
   132ab:	89 c2                	mov    %eax,%edx
   132ad:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132b0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   132b6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132b9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132bf:	85 c0                	test   %eax,%eax
   132c1:	0f 85 52 05 00 00    	jne    13819 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   132c7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132ca:	8b 40 6c             	mov    0x6c(%eax),%eax
   132cd:	85 c0                	test   %eax,%eax
   132cf:	74 4b                	je     1331c <lodepng_encode+0x7fa>
   132d1:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   132d7:	83 f8 02             	cmp    $0x2,%eax
   132da:	74 0b                	je     132e7 <lodepng_encode+0x7c5>
   132dc:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   132e2:	83 f8 06             	cmp    $0x6,%eax
   132e5:	75 35                	jne    1331c <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   132e7:	83 ec 08             	sub    $0x8,%esp
   132ea:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   132f0:	83 c0 0c             	add    $0xc,%eax
   132f3:	50                   	push   %eax
   132f4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   132f7:	50                   	push   %eax
   132f8:	e8 23 d8 ff ff       	call   10b20 <addChunk_PLTE>
   132fd:	83 c4 10             	add    $0x10,%esp
   13300:	89 c2                	mov    %eax,%edx
   13302:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13305:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1330b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1330e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13314:	85 c0                	test   %eax,%eax
   13316:	0f 85 00 05 00 00    	jne    1381c <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   1331c:	83 ec 08             	sub    $0x8,%esp
   1331f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13325:	83 c0 0c             	add    $0xc,%eax
   13328:	50                   	push   %eax
   13329:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1332c:	50                   	push   %eax
   1332d:	e8 c4 d8 ff ff       	call   10bf6 <addChunk_tRNS>
   13332:	83 c4 10             	add    $0x10,%esp
   13335:	89 c2                	mov    %eax,%edx
   13337:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1333a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13340:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13343:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13349:	85 c0                	test   %eax,%eax
   1334b:	0f 85 ce 04 00 00    	jne    1381f <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   13351:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13357:	85 c0                	test   %eax,%eax
   13359:	74 32                	je     1338d <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   1335b:	83 ec 08             	sub    $0x8,%esp
   1335e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13364:	50                   	push   %eax
   13365:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13368:	50                   	push   %eax
   13369:	e8 e4 de ff ff       	call   11252 <addChunk_bKGD>
   1336e:	83 c4 10             	add    $0x10,%esp
   13371:	89 c2                	mov    %eax,%edx
   13373:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13376:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1337c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1337f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13385:	85 c0                	test   %eax,%eax
   13387:	0f 85 95 04 00 00    	jne    13822 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   1338d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   13393:	85 c0                	test   %eax,%eax
   13395:	74 32                	je     133c9 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   13397:	83 ec 08             	sub    $0x8,%esp
   1339a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   133a0:	50                   	push   %eax
   133a1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133a4:	50                   	push   %eax
   133a5:	e8 ac e0 ff ff       	call   11456 <addChunk_pHYs>
   133aa:	83 c4 10             	add    $0x10,%esp
   133ad:	89 c2                	mov    %eax,%edx
   133af:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133b2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   133b8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133bb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133c1:	85 c0                	test   %eax,%eax
   133c3:	0f 85 5c 04 00 00    	jne    13825 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   133c9:	8b 45 9c             	mov    -0x64(%ebp),%eax
   133cc:	85 c0                	test   %eax,%eax
   133ce:	74 33                	je     13403 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   133d0:	8b 55 a8             	mov    -0x58(%ebp),%edx
   133d3:	8b 45 9c             	mov    -0x64(%ebp),%eax
   133d6:	83 ec 04             	sub    $0x4,%esp
   133d9:	52                   	push   %edx
   133da:	50                   	push   %eax
   133db:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133de:	50                   	push   %eax
   133df:	e8 2f f6 ff ff       	call   12a13 <addUnknownChunks>
   133e4:	83 c4 10             	add    $0x10,%esp
   133e7:	89 c2                	mov    %eax,%edx
   133e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ec:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   133f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133f5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133fb:	85 c0                	test   %eax,%eax
   133fd:	0f 85 25 04 00 00    	jne    13828 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   13403:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13406:	8d 48 38             	lea    0x38(%eax),%ecx
   13409:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1340c:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1340f:	51                   	push   %ecx
   13410:	52                   	push   %edx
   13411:	50                   	push   %eax
   13412:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13415:	50                   	push   %eax
   13416:	e8 bd d9 ff ff       	call   10dd8 <addChunk_IDAT>
   1341b:	83 c4 10             	add    $0x10,%esp
   1341e:	89 c2                	mov    %eax,%edx
   13420:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13423:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13429:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1342c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13432:	85 c0                	test   %eax,%eax
   13434:	0f 85 f1 03 00 00    	jne    1382b <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   1343a:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   13440:	85 c0                	test   %eax,%eax
   13442:	74 35                	je     13479 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   13444:	83 ec 08             	sub    $0x8,%esp
   13447:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1344d:	83 c0 60             	add    $0x60,%eax
   13450:	50                   	push   %eax
   13451:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13454:	50                   	push   %eax
   13455:	e8 5c df ff ff       	call   113b6 <addChunk_tIME>
   1345a:	83 c4 10             	add    $0x10,%esp
   1345d:	89 c2                	mov    %eax,%edx
   1345f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13462:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13468:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1346b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13471:	85 c0                	test   %eax,%eax
   13473:	0f 85 b5 03 00 00    	jne    1382e <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13479:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13480:	e9 12 01 00 00       	jmp    13597 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   13485:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1348b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1348e:	c1 e2 02             	shl    $0x2,%edx
   13491:	01 d0                	add    %edx,%eax
   13493:	8b 00                	mov    (%eax),%eax
   13495:	83 ec 0c             	sub    $0xc,%esp
   13498:	50                   	push   %eax
   13499:	e8 f5 01 ff ff       	call   3693 <lodepng_strlen>
   1349e:	83 c4 10             	add    $0x10,%esp
   134a1:	83 f8 4f             	cmp    $0x4f,%eax
   134a4:	7e 12                	jle    134b8 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   134a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134a9:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   134b0:	00 00 00 
        goto cleanup;
   134b3:	e9 83 03 00 00       	jmp    1383b <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   134b8:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   134be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134c1:	c1 e2 02             	shl    $0x2,%edx
   134c4:	01 d0                	add    %edx,%eax
   134c6:	8b 00                	mov    (%eax),%eax
   134c8:	83 ec 0c             	sub    $0xc,%esp
   134cb:	50                   	push   %eax
   134cc:	e8 c2 01 ff ff       	call   3693 <lodepng_strlen>
   134d1:	83 c4 10             	add    $0x10,%esp
   134d4:	85 c0                	test   %eax,%eax
   134d6:	7f 12                	jg     134ea <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   134d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134db:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   134e2:	00 00 00 
        goto cleanup;
   134e5:	e9 51 03 00 00       	jmp    1383b <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   134ea:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134ed:	8b 40 74             	mov    0x74(%eax),%eax
   134f0:	85 c0                	test   %eax,%eax
   134f2:	74 52                	je     13546 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   134f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134f7:	8d 48 38             	lea    0x38(%eax),%ecx
   134fa:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13500:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13503:	c1 e2 02             	shl    $0x2,%edx
   13506:	01 d0                	add    %edx,%eax
   13508:	8b 10                	mov    (%eax),%edx
   1350a:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13510:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   13513:	c1 e3 02             	shl    $0x2,%ebx
   13516:	01 d8                	add    %ebx,%eax
   13518:	8b 00                	mov    (%eax),%eax
   1351a:	51                   	push   %ecx
   1351b:	52                   	push   %edx
   1351c:	50                   	push   %eax
   1351d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13520:	50                   	push   %eax
   13521:	e8 fa d9 ff ff       	call   10f20 <addChunk_zTXt>
   13526:	83 c4 10             	add    $0x10,%esp
   13529:	89 c2                	mov    %eax,%edx
   1352b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1352e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13534:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13537:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1353d:	85 c0                	test   %eax,%eax
   1353f:	74 52                	je     13593 <lodepng_encode+0xa71>
   13541:	e9 f5 02 00 00       	jmp    1383b <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13546:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1354c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1354f:	c1 e2 02             	shl    $0x2,%edx
   13552:	01 d0                	add    %edx,%eax
   13554:	8b 10                	mov    (%eax),%edx
   13556:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1355c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1355f:	c1 e1 02             	shl    $0x2,%ecx
   13562:	01 c8                	add    %ecx,%eax
   13564:	8b 00                	mov    (%eax),%eax
   13566:	83 ec 04             	sub    $0x4,%esp
   13569:	52                   	push   %edx
   1356a:	50                   	push   %eax
   1356b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1356e:	50                   	push   %eax
   1356f:	e8 ec d8 ff ff       	call   10e60 <addChunk_tEXt>
   13574:	83 c4 10             	add    $0x10,%esp
   13577:	89 c2                	mov    %eax,%edx
   13579:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1357c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13582:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13585:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1358b:	85 c0                	test   %eax,%eax
   1358d:	0f 85 9e 02 00 00    	jne    13831 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13593:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13597:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1359d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   135a0:	0f 85 df fe ff ff    	jne    13485 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   135a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135a9:	8b 40 70             	mov    0x70(%eax),%eax
   135ac:	85 c0                	test   %eax,%eax
   135ae:	0f 84 e3 00 00 00    	je     13697 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   135b4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   135bb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   135c2:	e9 85 00 00 00       	jmp    1364c <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   135c7:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   135cd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   135d0:	c1 e2 02             	shl    $0x2,%edx
   135d3:	01 d0                	add    %edx,%eax
   135d5:	8b 00                	mov    (%eax),%eax
   135d7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   135da:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   135dd:	0f b6 00             	movzbl (%eax),%eax
   135e0:	3c 4c                	cmp    $0x4c,%al
   135e2:	75 64                	jne    13648 <lodepng_encode+0xb26>
   135e4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   135e7:	83 c0 01             	add    $0x1,%eax
   135ea:	0f b6 00             	movzbl (%eax),%eax
   135ed:	3c 6f                	cmp    $0x6f,%al
   135ef:	75 57                	jne    13648 <lodepng_encode+0xb26>
   135f1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   135f4:	83 c0 02             	add    $0x2,%eax
   135f7:	0f b6 00             	movzbl (%eax),%eax
   135fa:	3c 64                	cmp    $0x64,%al
   135fc:	75 4a                	jne    13648 <lodepng_encode+0xb26>
   135fe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13601:	83 c0 03             	add    $0x3,%eax
   13604:	0f b6 00             	movzbl (%eax),%eax
   13607:	3c 65                	cmp    $0x65,%al
   13609:	75 3d                	jne    13648 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   1360b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1360e:	83 c0 04             	add    $0x4,%eax
   13611:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13614:	3c 50                	cmp    $0x50,%al
   13616:	75 30                	jne    13648 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13618:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1361b:	83 c0 05             	add    $0x5,%eax
   1361e:	0f b6 00             	movzbl (%eax),%eax
   13621:	3c 4e                	cmp    $0x4e,%al
   13623:	75 23                	jne    13648 <lodepng_encode+0xb26>
   13625:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13628:	83 c0 06             	add    $0x6,%eax
   1362b:	0f b6 00             	movzbl (%eax),%eax
   1362e:	3c 47                	cmp    $0x47,%al
   13630:	75 16                	jne    13648 <lodepng_encode+0xb26>
   13632:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13635:	83 c0 07             	add    $0x7,%eax
   13638:	0f b6 00             	movzbl (%eax),%eax
   1363b:	84 c0                	test   %al,%al
   1363d:	75 09                	jne    13648 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   1363f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13646:	eb 13                	jmp    1365b <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13648:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1364c:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13652:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13655:	0f 85 6c ff ff ff    	jne    135c7 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   1365b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1365f:	75 36                	jne    13697 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   13661:	a1 40 e4 01 00       	mov    0x1e440,%eax
   13666:	83 ec 04             	sub    $0x4,%esp
   13669:	50                   	push   %eax
   1366a:	68 c4 a3 01 00       	push   $0x1a3c4
   1366f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13672:	50                   	push   %eax
   13673:	e8 e8 d7 ff ff       	call   10e60 <addChunk_tEXt>
   13678:	83 c4 10             	add    $0x10,%esp
   1367b:	89 c2                	mov    %eax,%edx
   1367d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13680:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13686:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13689:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1368f:	85 c0                	test   %eax,%eax
   13691:	0f 85 9d 01 00 00    	jne    13834 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13697:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1369e:	e9 e6 00 00 00       	jmp    13789 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   136a3:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   136a9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   136ac:	c1 e2 02             	shl    $0x2,%edx
   136af:	01 d0                	add    %edx,%eax
   136b1:	8b 00                	mov    (%eax),%eax
   136b3:	83 ec 0c             	sub    $0xc,%esp
   136b6:	50                   	push   %eax
   136b7:	e8 d7 ff fe ff       	call   3693 <lodepng_strlen>
   136bc:	83 c4 10             	add    $0x10,%esp
   136bf:	83 f8 4f             	cmp    $0x4f,%eax
   136c2:	7e 12                	jle    136d6 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   136c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136c7:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   136ce:	00 00 00 
        goto cleanup;
   136d1:	e9 65 01 00 00       	jmp    1383b <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   136d6:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   136dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   136df:	c1 e2 02             	shl    $0x2,%edx
   136e2:	01 d0                	add    %edx,%eax
   136e4:	8b 00                	mov    (%eax),%eax
   136e6:	83 ec 0c             	sub    $0xc,%esp
   136e9:	50                   	push   %eax
   136ea:	e8 a4 ff fe ff       	call   3693 <lodepng_strlen>
   136ef:	83 c4 10             	add    $0x10,%esp
   136f2:	85 c0                	test   %eax,%eax
   136f4:	7f 12                	jg     13708 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   136f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136f9:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13700:	00 00 00 
        goto cleanup;
   13703:	e9 33 01 00 00       	jmp    1383b <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   13708:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1370b:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1370e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   13714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13717:	c1 e2 02             	shl    $0x2,%edx
   1371a:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1371c:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1371e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13724:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13727:	c1 e2 02             	shl    $0x2,%edx
   1372a:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1372c:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1372e:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13734:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13737:	c1 e2 02             	shl    $0x2,%edx
   1373a:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1373c:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1373e:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13744:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13747:	c1 e2 02             	shl    $0x2,%edx
   1374a:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1374c:	8b 10                	mov    (%eax),%edx
   1374e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13751:	8b 40 74             	mov    0x74(%eax),%eax
   13754:	83 ec 04             	sub    $0x4,%esp
   13757:	57                   	push   %edi
   13758:	56                   	push   %esi
   13759:	53                   	push   %ebx
   1375a:	51                   	push   %ecx
   1375b:	52                   	push   %edx
   1375c:	50                   	push   %eax
   1375d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13760:	50                   	push   %eax
   13761:	e8 dc d8 ff ff       	call   11042 <addChunk_iTXt>
   13766:	83 c4 20             	add    $0x20,%esp
   13769:	89 c2                	mov    %eax,%edx
   1376b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1376e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13774:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13777:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1377d:	85 c0                	test   %eax,%eax
   1377f:	0f 85 b2 00 00 00    	jne    13837 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13785:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13789:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   1378f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13792:	0f 85 0b ff ff ff    	jne    136a3 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   13798:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1379b:	85 c0                	test   %eax,%eax
   1379d:	74 2f                	je     137ce <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   1379f:	8b 55 ac             	mov    -0x54(%ebp),%edx
   137a2:	8b 45 a0             	mov    -0x60(%ebp),%eax
   137a5:	83 ec 04             	sub    $0x4,%esp
   137a8:	52                   	push   %edx
   137a9:	50                   	push   %eax
   137aa:	8d 45 b0             	lea    -0x50(%ebp),%eax
   137ad:	50                   	push   %eax
   137ae:	e8 60 f2 ff ff       	call   12a13 <addUnknownChunks>
   137b3:	83 c4 10             	add    $0x10,%esp
   137b6:	89 c2                	mov    %eax,%edx
   137b8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137bb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   137c1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137c4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   137ca:	85 c0                	test   %eax,%eax
   137cc:	75 6c                	jne    1383a <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   137ce:	83 ec 0c             	sub    $0xc,%esp
   137d1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   137d4:	50                   	push   %eax
   137d5:	e8 6d d6 ff ff       	call   10e47 <addChunk_IEND>
   137da:	83 c4 10             	add    $0x10,%esp
   137dd:	89 c2                	mov    %eax,%edx
   137df:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137e2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   137e8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137eb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   137f1:	85 c0                	test   %eax,%eax
   137f3:	eb 46                	jmp    1383b <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   137f5:	90                   	nop
   137f6:	eb 43                	jmp    1383b <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   137f8:	90                   	nop
   137f9:	eb 40                	jmp    1383b <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   137fb:	90                   	nop
   137fc:	eb 3d                	jmp    1383b <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   137fe:	90                   	nop
   137ff:	eb 3a                	jmp    1383b <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   13801:	90                   	nop
   13802:	eb 37                	jmp    1383b <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   13804:	90                   	nop
   13805:	eb 34                	jmp    1383b <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   13807:	90                   	nop
   13808:	eb 31                	jmp    1383b <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   1380a:	90                   	nop
   1380b:	eb 2e                	jmp    1383b <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1380d:	90                   	nop
   1380e:	eb 2b                	jmp    1383b <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   13810:	90                   	nop
   13811:	eb 28                	jmp    1383b <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   13813:	90                   	nop
   13814:	eb 25                	jmp    1383b <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13816:	90                   	nop
   13817:	eb 22                	jmp    1383b <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13819:	90                   	nop
   1381a:	eb 1f                	jmp    1383b <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   1381c:	90                   	nop
   1381d:	eb 1c                	jmp    1383b <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   1381f:	90                   	nop
   13820:	eb 19                	jmp    1383b <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13822:	90                   	nop
   13823:	eb 16                	jmp    1383b <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13825:	90                   	nop
   13826:	eb 13                	jmp    1383b <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13828:	90                   	nop
   13829:	eb 10                	jmp    1383b <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   1382b:	90                   	nop
   1382c:	eb 0d                	jmp    1383b <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   1382e:	90                   	nop
   1382f:	eb 0a                	jmp    1383b <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   13831:	90                   	nop
   13832:	eb 07                	jmp    1383b <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13834:	90                   	nop
   13835:	eb 04                	jmp    1383b <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13837:	90                   	nop
   13838:	eb 01                	jmp    1383b <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   1383a:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   1383b:	83 ec 0c             	sub    $0xc,%esp
   1383e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13844:	50                   	push   %eax
   13845:	e8 34 65 ff ff       	call   9d7e <lodepng_info_cleanup>
   1384a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   1384d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13850:	83 ec 0c             	sub    $0xc,%esp
   13853:	50                   	push   %eax
   13854:	e8 bf fd fe ff       	call   3618 <lodepng_free>
   13859:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   1385c:	8b 55 b0             	mov    -0x50(%ebp),%edx
   1385f:	8b 45 08             	mov    0x8(%ebp),%eax
   13862:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13864:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13867:	8b 45 0c             	mov    0xc(%ebp),%eax
   1386a:	89 10                	mov    %edx,(%eax)

  return state->error;
   1386c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1386f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13875:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13878:	5b                   	pop    %ebx
   13879:	5e                   	pop    %esi
   1387a:	5f                   	pop    %edi
   1387b:	5d                   	pop    %ebp
   1387c:	c3                   	ret    

0001387d <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   1387d:	55                   	push   %ebp
   1387e:	89 e5                	mov    %esp,%ebp
   13880:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   13886:	83 ec 0c             	sub    $0xc,%esp
   13889:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1388f:	50                   	push   %eax
   13890:	e8 38 d0 ff ff       	call   108cd <lodepng_state_init>
   13895:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   13898:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1389b:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   138a1:	8b 45 20             	mov    0x20(%ebp),%eax
   138a4:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   138aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   138ad:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   138b3:	8b 45 20             	mov    0x20(%ebp),%eax
   138b6:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   138bc:	83 ec 08             	sub    $0x8,%esp
   138bf:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   138c5:	50                   	push   %eax
   138c6:	ff 75 18             	pushl  0x18(%ebp)
   138c9:	ff 75 14             	pushl  0x14(%ebp)
   138cc:	ff 75 10             	pushl  0x10(%ebp)
   138cf:	ff 75 0c             	pushl  0xc(%ebp)
   138d2:	ff 75 08             	pushl  0x8(%ebp)
   138d5:	e8 48 f2 ff ff       	call   12b22 <lodepng_encode>
   138da:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   138dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   138e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   138e3:	83 ec 0c             	sub    $0xc,%esp
   138e6:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   138ec:	50                   	push   %eax
   138ed:	e8 35 d0 ff ff       	call   10927 <lodepng_state_cleanup>
   138f2:	83 c4 10             	add    $0x10,%esp
  return error;
   138f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   138f8:	c9                   	leave  
   138f9:	c3                   	ret    

000138fa <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   138fa:	55                   	push   %ebp
   138fb:	89 e5                	mov    %esp,%ebp
   138fd:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   13900:	83 ec 04             	sub    $0x4,%esp
   13903:	6a 08                	push   $0x8
   13905:	6a 06                	push   $0x6
   13907:	ff 75 18             	pushl  0x18(%ebp)
   1390a:	ff 75 14             	pushl  0x14(%ebp)
   1390d:	ff 75 10             	pushl  0x10(%ebp)
   13910:	ff 75 0c             	pushl  0xc(%ebp)
   13913:	ff 75 08             	pushl  0x8(%ebp)
   13916:	e8 62 ff ff ff       	call   1387d <lodepng_encode_memory>
   1391b:	83 c4 20             	add    $0x20,%esp
}
   1391e:	c9                   	leave  
   1391f:	c3                   	ret    

00013920 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13920:	55                   	push   %ebp
   13921:	89 e5                	mov    %esp,%ebp
   13923:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13926:	83 ec 04             	sub    $0x4,%esp
   13929:	6a 08                	push   $0x8
   1392b:	6a 02                	push   $0x2
   1392d:	ff 75 18             	pushl  0x18(%ebp)
   13930:	ff 75 14             	pushl  0x14(%ebp)
   13933:	ff 75 10             	pushl  0x10(%ebp)
   13936:	ff 75 0c             	pushl  0xc(%ebp)
   13939:	ff 75 08             	pushl  0x8(%ebp)
   1393c:	e8 3c ff ff ff       	call   1387d <lodepng_encode_memory>
   13941:	83 c4 20             	add    $0x20,%esp
}
   13944:	c9                   	leave  
   13945:	c3                   	ret    

00013946 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13946:	55                   	push   %ebp
   13947:	89 e5                	mov    %esp,%ebp
   13949:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   1394c:	83 ec 04             	sub    $0x4,%esp
   1394f:	ff 75 1c             	pushl  0x1c(%ebp)
   13952:	ff 75 18             	pushl  0x18(%ebp)
   13955:	ff 75 14             	pushl  0x14(%ebp)
   13958:	ff 75 10             	pushl  0x10(%ebp)
   1395b:	ff 75 0c             	pushl  0xc(%ebp)
   1395e:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13961:	50                   	push   %eax
   13962:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13965:	50                   	push   %eax
   13966:	e8 12 ff ff ff       	call   1387d <lodepng_encode_memory>
   1396b:	83 c4 20             	add    $0x20,%esp
   1396e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   13971:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13975:	75 19                	jne    13990 <lodepng_encode_file+0x4a>
   13977:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1397a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1397d:	83 ec 04             	sub    $0x4,%esp
   13980:	ff 75 08             	pushl  0x8(%ebp)
   13983:	52                   	push   %edx
   13984:	50                   	push   %eax
   13985:	e8 36 01 ff ff       	call   3ac0 <lodepng_save_file>
   1398a:	83 c4 10             	add    $0x10,%esp
   1398d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   13990:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13993:	83 ec 0c             	sub    $0xc,%esp
   13996:	50                   	push   %eax
   13997:	e8 7c fc fe ff       	call   3618 <lodepng_free>
   1399c:	83 c4 10             	add    $0x10,%esp
  return error;
   1399f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   139a2:	c9                   	leave  
   139a3:	c3                   	ret    

000139a4 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   139a4:	55                   	push   %ebp
   139a5:	89 e5                	mov    %esp,%ebp
   139a7:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   139aa:	83 ec 08             	sub    $0x8,%esp
   139ad:	6a 08                	push   $0x8
   139af:	6a 06                	push   $0x6
   139b1:	ff 75 14             	pushl  0x14(%ebp)
   139b4:	ff 75 10             	pushl  0x10(%ebp)
   139b7:	ff 75 0c             	pushl  0xc(%ebp)
   139ba:	ff 75 08             	pushl  0x8(%ebp)
   139bd:	e8 84 ff ff ff       	call   13946 <lodepng_encode_file>
   139c2:	83 c4 20             	add    $0x20,%esp
}
   139c5:	c9                   	leave  
   139c6:	c3                   	ret    

000139c7 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   139c7:	55                   	push   %ebp
   139c8:	89 e5                	mov    %esp,%ebp
   139ca:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   139cd:	83 ec 08             	sub    $0x8,%esp
   139d0:	6a 08                	push   $0x8
   139d2:	6a 02                	push   $0x2
   139d4:	ff 75 14             	pushl  0x14(%ebp)
   139d7:	ff 75 10             	pushl  0x10(%ebp)
   139da:	ff 75 0c             	pushl  0xc(%ebp)
   139dd:	ff 75 08             	pushl  0x8(%ebp)
   139e0:	e8 61 ff ff ff       	call   13946 <lodepng_encode_file>
   139e5:	83 c4 20             	add    $0x20,%esp
}
   139e8:	c9                   	leave  
   139e9:	c3                   	ret    

000139ea <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   139ea:	55                   	push   %ebp
   139eb:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   139ed:	8b 45 08             	mov    0x8(%ebp),%eax
   139f0:	50                   	push   %eax
   139f1:	e8 71 49 ff ff       	call   8367 <lodepng_compress_settings_init>
   139f6:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   139f9:	8b 45 08             	mov    0x8(%ebp),%eax
   139fc:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   13a03:	8b 45 08             	mov    0x8(%ebp),%eax
   13a06:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   13a0d:	8b 45 08             	mov    0x8(%ebp),%eax
   13a10:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13a17:	8b 45 08             	mov    0x8(%ebp),%eax
   13a1a:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   13a21:	8b 45 08             	mov    0x8(%ebp),%eax
   13a24:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13a2b:	8b 45 08             	mov    0x8(%ebp),%eax
   13a2e:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13a35:	8b 45 08             	mov    0x8(%ebp),%eax
   13a38:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   13a3f:	90                   	nop
   13a40:	c9                   	leave  
   13a41:	c3                   	ret    

00013a42 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   13a42:	55                   	push   %ebp
   13a43:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13a45:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13a49:	0f 87 c1 03 00 00    	ja     13e10 <lodepng_error_text+0x3ce>
   13a4f:	8b 45 08             	mov    0x8(%ebp),%eax
   13a52:	c1 e0 02             	shl    $0x2,%eax
   13a55:	05 00 b7 01 00       	add    $0x1b700,%eax
   13a5a:	8b 00                	mov    (%eax),%eax
   13a5c:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   13a5e:	b8 cc a3 01 00       	mov    $0x1a3cc,%eax
   13a63:	e9 ad 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13a68:	b8 e9 a3 01 00       	mov    $0x1a3e9,%eax
   13a6d:	e9 a3 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   13a72:	b8 fc a3 01 00       	mov    $0x1a3fc,%eax
   13a77:	e9 99 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13a7c:	b8 34 a4 01 00       	mov    $0x1a434,%eax
   13a81:	e9 8f 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   13a86:	b8 6c a4 01 00       	mov    $0x1a46c,%eax
   13a8b:	e9 85 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   13a90:	b8 6c a4 01 00       	mov    $0x1a46c,%eax
   13a95:	e9 7b 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13a9a:	b8 6c a4 01 00       	mov    $0x1a46c,%eax
   13a9f:	e9 71 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   13aa4:	b8 9c a4 01 00       	mov    $0x1a49c,%eax
   13aa9:	e9 67 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13aae:	b8 d0 a4 01 00       	mov    $0x1a4d0,%eax
   13ab3:	e9 5d 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   13ab8:	b8 04 a5 01 00       	mov    $0x1a504,%eax
   13abd:	e9 53 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   13ac2:	b8 d0 a4 01 00       	mov    $0x1a4d0,%eax
   13ac7:	e9 49 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13acc:	b8 2c a5 01 00       	mov    $0x1a52c,%eax
   13ad1:	e9 3f 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13ad6:	b8 64 a5 01 00       	mov    $0x1a564,%eax
   13adb:	e9 35 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   13ae0:	b8 d0 a4 01 00       	mov    $0x1a4d0,%eax
   13ae5:	e9 2b 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13aea:	b8 9c a5 01 00       	mov    $0x1a59c,%eax
   13aef:	e9 21 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13af4:	b8 cc a5 01 00       	mov    $0x1a5cc,%eax
   13af9:	e9 17 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   13afe:	b8 ec a5 01 00       	mov    $0x1a5ec,%eax
   13b03:	e9 0d 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13b08:	b8 18 a6 01 00       	mov    $0x1a618,%eax
   13b0d:	e9 03 03 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   13b12:	b8 58 a6 01 00       	mov    $0x1a658,%eax
   13b17:	e9 f9 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13b1c:	b8 80 a6 01 00       	mov    $0x1a680,%eax
   13b21:	e9 ef 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13b26:	b8 b4 a6 01 00       	mov    $0x1a6b4,%eax
   13b2b:	e9 e5 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   13b30:	b8 d8 a6 01 00       	mov    $0x1a6d8,%eax
   13b35:	e9 db 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13b3a:	b8 10 a7 01 00       	mov    $0x1a710,%eax
   13b3f:	e9 d1 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13b44:	b8 30 a7 01 00       	mov    $0x1a730,%eax
   13b49:	e9 c7 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13b4e:	b8 4f a7 01 00       	mov    $0x1a74f,%eax
   13b53:	e9 bd 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13b58:	b8 69 a7 01 00       	mov    $0x1a769,%eax
   13b5d:	e9 b3 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   13b62:	b8 88 a7 01 00       	mov    $0x1a788,%eax
   13b67:	e9 a9 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13b6c:	b8 c4 a7 01 00       	mov    $0x1a7c4,%eax
   13b71:	e9 9f 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   13b76:	b8 e8 a7 01 00       	mov    $0x1a7e8,%eax
   13b7b:	e9 95 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   13b80:	b8 14 a8 01 00       	mov    $0x1a814,%eax
   13b85:	e9 8b 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13b8a:	b8 38 a8 01 00       	mov    $0x1a838,%eax
   13b8f:	e9 81 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   13b94:	b8 78 a8 01 00       	mov    $0x1a878,%eax
   13b99:	e9 77 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13b9e:	b8 a8 a8 01 00       	mov    $0x1a8a8,%eax
   13ba3:	e9 6d 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   13ba8:	b8 d0 a8 01 00       	mov    $0x1a8d0,%eax
   13bad:	e9 63 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   13bb2:	b8 14 a9 01 00       	mov    $0x1a914,%eax
   13bb7:	e9 59 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   13bbc:	b8 40 a9 01 00       	mov    $0x1a940,%eax
   13bc1:	e9 4f 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   13bc6:	b8 70 a9 01 00       	mov    $0x1a970,%eax
   13bcb:	e9 45 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   13bd0:	b8 98 a9 01 00       	mov    $0x1a998,%eax
   13bd5:	e9 3b 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13bda:	b8 e0 a9 01 00       	mov    $0x1a9e0,%eax
   13bdf:	e9 31 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   13be4:	b8 e0 a9 01 00       	mov    $0x1a9e0,%eax
   13be9:	e9 27 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   13bee:	b8 1c aa 01 00       	mov    $0x1aa1c,%eax
   13bf3:	e9 1d 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13bf8:	b8 50 aa 01 00       	mov    $0x1aa50,%eax
   13bfd:	e9 13 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   13c02:	b8 73 aa 01 00       	mov    $0x1aa73,%eax
   13c07:	e9 09 02 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   13c0c:	b8 90 aa 01 00       	mov    $0x1aa90,%eax
   13c11:	e9 ff 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13c16:	b8 cc aa 01 00       	mov    $0x1aacc,%eax
   13c1b:	e9 f5 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   13c20:	b8 fc aa 01 00       	mov    $0x1aafc,%eax
   13c25:	e9 eb 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13c2a:	b8 48 ab 01 00       	mov    $0x1ab48,%eax
   13c2f:	e9 e1 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13c34:	b8 80 ab 01 00       	mov    $0x1ab80,%eax
   13c39:	e9 d7 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13c3e:	b8 c0 ab 01 00       	mov    $0x1abc0,%eax
   13c43:	e9 cd 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13c48:	b8 ec ab 01 00       	mov    $0x1abec,%eax
   13c4d:	e9 c3 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13c52:	b8 38 ac 01 00       	mov    $0x1ac38,%eax
   13c57:	e9 b9 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13c5c:	b8 8c ac 01 00       	mov    $0x1ac8c,%eax
   13c61:	e9 af 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13c66:	b8 c0 ac 01 00       	mov    $0x1acc0,%eax
   13c6b:	e9 a5 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13c70:	b8 10 ad 01 00       	mov    $0x1ad10,%eax
   13c75:	e9 9b 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13c7a:	b8 4c ad 01 00       	mov    $0x1ad4c,%eax
   13c7f:	e9 91 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   13c84:	b8 ac ad 01 00       	mov    $0x1adac,%eax
   13c89:	e9 87 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13c8e:	b8 0c ae 01 00       	mov    $0x1ae0c,%eax
   13c93:	e9 7d 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   13c98:	b8 68 ae 01 00       	mov    $0x1ae68,%eax
   13c9d:	e9 73 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13ca2:	b8 ac ae 01 00       	mov    $0x1aeac,%eax
   13ca7:	e9 69 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13cac:	b8 e8 ae 01 00       	mov    $0x1aee8,%eax
   13cb1:	e9 5f 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13cb6:	b8 45 af 01 00       	mov    $0x1af45,%eax
   13cbb:	e9 55 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13cc0:	b8 5d af 01 00       	mov    $0x1af5d,%eax
   13cc5:	e9 4b 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13cca:	b8 78 af 01 00       	mov    $0x1af78,%eax
   13ccf:	e9 41 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13cd4:	b8 b4 af 01 00       	mov    $0x1afb4,%eax
   13cd9:	e9 37 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13cde:	b8 e4 af 01 00       	mov    $0x1afe4,%eax
   13ce3:	e9 2d 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13ce8:	b8 04 b0 01 00       	mov    $0x1b004,%eax
   13ced:	e9 23 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13cf2:	b8 24 b0 01 00       	mov    $0x1b024,%eax
   13cf7:	e9 19 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13cfc:	b8 44 b0 01 00       	mov    $0x1b044,%eax
   13d01:	e9 0f 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13d06:	b8 68 b0 01 00       	mov    $0x1b068,%eax
   13d0b:	e9 05 01 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13d10:	b8 90 b0 01 00       	mov    $0x1b090,%eax
   13d15:	e9 fb 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13d1a:	b8 ed b0 01 00       	mov    $0x1b0ed,%eax
   13d1f:	e9 f1 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13d24:	b8 08 b1 01 00       	mov    $0x1b108,%eax
   13d29:	e9 e7 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13d2e:	b8 44 b1 01 00       	mov    $0x1b144,%eax
   13d33:	e9 dd 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13d38:	b8 78 b1 01 00       	mov    $0x1b178,%eax
   13d3d:	e9 d3 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13d42:	b8 cc b1 01 00       	mov    $0x1b1cc,%eax
   13d47:	e9 c9 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13d4c:	b8 18 b2 01 00       	mov    $0x1b218,%eax
   13d51:	e9 bf 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13d56:	b8 54 b2 01 00       	mov    $0x1b254,%eax
   13d5b:	e9 b5 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13d60:	b8 78 b2 01 00       	mov    $0x1b278,%eax
   13d65:	e9 ab 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13d6a:	b8 98 b2 01 00       	mov    $0x1b298,%eax
   13d6f:	e9 a1 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13d74:	b8 c0 b2 01 00       	mov    $0x1b2c0,%eax
   13d79:	e9 97 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13d7e:	b8 e0 b2 01 00       	mov    $0x1b2e0,%eax
   13d83:	e9 8d 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13d88:	b8 0c b3 01 00       	mov    $0x1b30c,%eax
   13d8d:	e9 83 00 00 00       	jmp    13e15 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13d92:	b8 3b b3 01 00       	mov    $0x1b33b,%eax
   13d97:	eb 7c                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13d99:	b8 53 b3 01 00       	mov    $0x1b353,%eax
   13d9e:	eb 75                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13da0:	b8 6b b3 01 00       	mov    $0x1b36b,%eax
   13da5:	eb 6e                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13da7:	b8 83 b3 01 00       	mov    $0x1b383,%eax
   13dac:	eb 67                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13dae:	b8 a4 b3 01 00       	mov    $0x1b3a4,%eax
   13db3:	eb 60                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13db5:	b8 f4 b3 01 00       	mov    $0x1b3f4,%eax
   13dba:	eb 59                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13dbc:	b8 48 b4 01 00       	mov    $0x1b448,%eax
   13dc1:	eb 52                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13dc3:	b8 9c b4 01 00       	mov    $0x1b49c,%eax
   13dc8:	eb 4b                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13dca:	b8 e4 b4 01 00       	mov    $0x1b4e4,%eax
   13dcf:	eb 44                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13dd1:	b8 28 b5 01 00       	mov    $0x1b528,%eax
   13dd6:	eb 3d                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13dd8:	b8 44 b5 01 00       	mov    $0x1b544,%eax
   13ddd:	eb 36                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13ddf:	b8 7c b5 01 00       	mov    $0x1b57c,%eax
   13de4:	eb 2f                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13de6:	b8 d0 b5 01 00       	mov    $0x1b5d0,%eax
   13deb:	eb 28                	jmp    13e15 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13ded:	b8 00 b6 01 00       	mov    $0x1b600,%eax
   13df2:	eb 21                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13df4:	b8 50 b6 01 00       	mov    $0x1b650,%eax
   13df9:	eb 1a                	jmp    13e15 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13dfb:	b8 7c b6 01 00       	mov    $0x1b67c,%eax
   13e00:	eb 13                	jmp    13e15 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13e02:	b8 a8 b6 01 00       	mov    $0x1b6a8,%eax
   13e07:	eb 0c                	jmp    13e15 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13e09:	b8 cc b6 01 00       	mov    $0x1b6cc,%eax
   13e0e:	eb 05                	jmp    13e15 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13e10:	b8 eb b6 01 00       	mov    $0x1b6eb,%eax
}
   13e15:	5d                   	pop    %ebp
   13e16:	c3                   	ret    

00013e17 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13e17:	55                   	push   %ebp
   13e18:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13e1a:	8b 45 08             	mov    0x8(%ebp),%eax
   13e1d:	8b 40 28             	mov    0x28(%eax),%eax
   13e20:	83 f8 01             	cmp    $0x1,%eax
   13e23:	75 08                	jne    13e2d <GetImage+0x16>
   13e25:	8b 45 08             	mov    0x8(%ebp),%eax
   13e28:	8b 40 54             	mov    0x54(%eax),%eax
   13e2b:	eb 09                	jmp    13e36 <GetImage+0x1f>
   13e2d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e30:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13e36:	5d                   	pop    %ebp
   13e37:	c3                   	ret    

00013e38 <GetWidth>:

int GetWidth(Context* ctx){
   13e38:	55                   	push   %ebp
   13e39:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13e3b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e3e:	8b 40 10             	mov    0x10(%eax),%eax
}
   13e41:	5d                   	pop    %ebp
   13e42:	c3                   	ret    

00013e43 <GetHeight>:

int GetHeight(Context* ctx){
   13e43:	55                   	push   %ebp
   13e44:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13e46:	8b 45 08             	mov    0x8(%ebp),%eax
   13e49:	8b 40 14             	mov    0x14(%eax),%eax
}
   13e4c:	5d                   	pop    %ebp
   13e4d:	c3                   	ret    

00013e4e <GetImageSize>:

uint GetImageSize(Context* ctx){
   13e4e:	55                   	push   %ebp
   13e4f:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13e51:	8b 45 08             	mov    0x8(%ebp),%eax
   13e54:	8b 50 10             	mov    0x10(%eax),%edx
   13e57:	8b 45 08             	mov    0x8(%ebp),%eax
   13e5a:	8b 40 14             	mov    0x14(%eax),%eax
   13e5d:	0f af d0             	imul   %eax,%edx
   13e60:	8b 45 08             	mov    0x8(%ebp),%eax
   13e63:	8b 40 28             	mov    0x28(%eax),%eax
   13e66:	0f af c2             	imul   %edx,%eax
}
   13e69:	5d                   	pop    %ebp
   13e6a:	c3                   	ret    

00013e6b <_Clip>:

uchar _Clip(const int x){
   13e6b:	55                   	push   %ebp
   13e6c:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13e6e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13e72:	78 15                	js     13e89 <_Clip+0x1e>
   13e74:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13e7b:	7f 05                	jg     13e82 <_Clip+0x17>
   13e7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e80:	eb 0c                	jmp    13e8e <_Clip+0x23>
   13e82:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13e87:	eb 05                	jmp    13e8e <_Clip+0x23>
   13e89:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13e8e:	5d                   	pop    %ebp
   13e8f:	c3                   	ret    

00013e90 <_Skip>:

void _Skip(Context* ctx, int c){
   13e90:	55                   	push   %ebp
   13e91:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13e93:	8b 45 08             	mov    0x8(%ebp),%eax
   13e96:	8b 50 04             	mov    0x4(%eax),%edx
   13e99:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e9c:	01 c2                	add    %eax,%edx
   13e9e:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea1:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13ea4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea7:	8b 40 08             	mov    0x8(%eax),%eax
   13eaa:	2b 45 0c             	sub    0xc(%ebp),%eax
   13ead:	89 c2                	mov    %eax,%edx
   13eaf:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb2:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13eb5:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb8:	8b 40 0c             	mov    0xc(%eax),%eax
   13ebb:	2b 45 0c             	sub    0xc(%ebp),%eax
   13ebe:	89 c2                	mov    %eax,%edx
   13ec0:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec3:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13ec6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec9:	8b 40 08             	mov    0x8(%eax),%eax
   13ecc:	85 c0                	test   %eax,%eax
   13ece:	79 09                	jns    13ed9 <_Skip+0x49>
   13ed0:	8b 45 08             	mov    0x8(%ebp),%eax
   13ed3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13ed9:	90                   	nop
   13eda:	5d                   	pop    %ebp
   13edb:	c3                   	ret    

00013edc <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13edc:	55                   	push   %ebp
   13edd:	89 e5                	mov    %esp,%ebp
   13edf:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13ee2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee5:	8b 40 08             	mov    0x8(%eax),%eax
   13ee8:	83 f8 01             	cmp    $0x1,%eax
   13eeb:	7f 0b                	jg     13ef8 <_DecodeLength+0x1c>
   13eed:	8b 45 08             	mov    0x8(%ebp),%eax
   13ef0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13ef6:	eb 45                	jmp    13f3d <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13ef8:	8b 45 08             	mov    0x8(%ebp),%eax
   13efb:	8b 40 04             	mov    0x4(%eax),%eax
   13efe:	83 ec 0c             	sub    $0xc,%esp
   13f01:	50                   	push   %eax
   13f02:	e8 38 00 00 00       	call   13f3f <_Decode2Bytes>
   13f07:	83 c4 10             	add    $0x10,%esp
   13f0a:	89 c2                	mov    %eax,%edx
   13f0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0f:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13f12:	8b 45 08             	mov    0x8(%ebp),%eax
   13f15:	8b 50 0c             	mov    0xc(%eax),%edx
   13f18:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1b:	8b 40 08             	mov    0x8(%eax),%eax
   13f1e:	39 c2                	cmp    %eax,%edx
   13f20:	7e 0b                	jle    13f2d <_DecodeLength+0x51>
   13f22:	8b 45 08             	mov    0x8(%ebp),%eax
   13f25:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f2b:	eb 10                	jmp    13f3d <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13f2d:	83 ec 08             	sub    $0x8,%esp
   13f30:	6a 02                	push   $0x2
   13f32:	ff 75 08             	pushl  0x8(%ebp)
   13f35:	e8 56 ff ff ff       	call   13e90 <_Skip>
   13f3a:	83 c4 10             	add    $0x10,%esp
}
   13f3d:	c9                   	leave  
   13f3e:	c3                   	ret    

00013f3f <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13f3f:	55                   	push   %ebp
   13f40:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13f42:	8b 45 08             	mov    0x8(%ebp),%eax
   13f45:	0f b6 00             	movzbl (%eax),%eax
   13f48:	0f b6 c0             	movzbl %al,%eax
   13f4b:	c1 e0 08             	shl    $0x8,%eax
   13f4e:	89 c2                	mov    %eax,%edx
   13f50:	8b 45 08             	mov    0x8(%ebp),%eax
   13f53:	83 c0 01             	add    $0x1,%eax
   13f56:	0f b6 00             	movzbl (%eax),%eax
   13f59:	0f b6 c0             	movzbl %al,%eax
   13f5c:	09 d0                	or     %edx,%eax
}
   13f5e:	5d                   	pop    %ebp
   13f5f:	c3                   	ret    

00013f60 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13f60:	55                   	push   %ebp
   13f61:	89 e5                	mov    %esp,%ebp
   13f63:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13f66:	8b 45 08             	mov    0x8(%ebp),%eax
   13f69:	8b 55 10             	mov    0x10(%ebp),%edx
   13f6c:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13f6f:	8b 45 14             	mov    0x14(%ebp),%eax
   13f72:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13f77:	89 c2                	mov    %eax,%edx
   13f79:	8b 45 08             	mov    0x8(%ebp),%eax
   13f7c:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13f7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f82:	8b 40 08             	mov    0x8(%eax),%eax
   13f85:	83 f8 01             	cmp    $0x1,%eax
   13f88:	7e 1d                	jle    13fa7 <_DecodeJPEG+0x47>
   13f8a:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8d:	8b 40 04             	mov    0x4(%eax),%eax
   13f90:	0f b6 00             	movzbl (%eax),%eax
   13f93:	3c ff                	cmp    $0xff,%al
   13f95:	75 10                	jne    13fa7 <_DecodeJPEG+0x47>
   13f97:	8b 45 08             	mov    0x8(%ebp),%eax
   13f9a:	8b 40 04             	mov    0x4(%eax),%eax
   13f9d:	83 c0 01             	add    $0x1,%eax
   13fa0:	0f b6 00             	movzbl (%eax),%eax
   13fa3:	3c d8                	cmp    $0xd8,%al
   13fa5:	74 0a                	je     13fb1 <_DecodeJPEG+0x51>
   13fa7:	b8 01 00 00 00       	mov    $0x1,%eax
   13fac:	e9 56 01 00 00       	jmp    14107 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13fb1:	6a 02                	push   $0x2
   13fb3:	ff 75 08             	pushl  0x8(%ebp)
   13fb6:	e8 d5 fe ff ff       	call   13e90 <_Skip>
   13fbb:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13fbe:	e9 0a 01 00 00       	jmp    140cd <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13fc3:	8b 45 08             	mov    0x8(%ebp),%eax
   13fc6:	8b 40 08             	mov    0x8(%eax),%eax
   13fc9:	85 c0                	test   %eax,%eax
   13fcb:	78 0d                	js     13fda <_DecodeJPEG+0x7a>
   13fcd:	8b 45 08             	mov    0x8(%ebp),%eax
   13fd0:	8b 40 04             	mov    0x4(%eax),%eax
   13fd3:	0f b6 00             	movzbl (%eax),%eax
   13fd6:	3c ff                	cmp    $0xff,%al
   13fd8:	74 0a                	je     13fe4 <_DecodeJPEG+0x84>
   13fda:	b8 05 00 00 00       	mov    $0x5,%eax
   13fdf:	e9 23 01 00 00       	jmp    14107 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13fe4:	6a 02                	push   $0x2
   13fe6:	ff 75 08             	pushl  0x8(%ebp)
   13fe9:	e8 a2 fe ff ff       	call   13e90 <_Skip>
   13fee:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13ff1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff4:	8b 40 04             	mov    0x4(%eax),%eax
   13ff7:	83 e8 01             	sub    $0x1,%eax
   13ffa:	0f b6 00             	movzbl (%eax),%eax
   13ffd:	0f b6 c0             	movzbl %al,%eax
   14000:	3d da 00 00 00       	cmp    $0xda,%eax
   14005:	74 71                	je     14078 <_DecodeJPEG+0x118>
   14007:	3d da 00 00 00       	cmp    $0xda,%eax
   1400c:	7f 10                	jg     1401e <_DecodeJPEG+0xbe>
   1400e:	3d c0 00 00 00       	cmp    $0xc0,%eax
   14013:	74 20                	je     14035 <_DecodeJPEG+0xd5>
   14015:	3d c4 00 00 00       	cmp    $0xc4,%eax
   1401a:	74 2c                	je     14048 <_DecodeJPEG+0xe8>
   1401c:	eb 7d                	jmp    1409b <_DecodeJPEG+0x13b>
   1401e:	3d dd 00 00 00       	cmp    $0xdd,%eax
   14023:	74 43                	je     14068 <_DecodeJPEG+0x108>
   14025:	3d fe 00 00 00       	cmp    $0xfe,%eax
   1402a:	74 5f                	je     1408b <_DecodeJPEG+0x12b>
   1402c:	3d db 00 00 00       	cmp    $0xdb,%eax
   14031:	74 25                	je     14058 <_DecodeJPEG+0xf8>
   14033:	eb 66                	jmp    1409b <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   14035:	83 ec 0c             	sub    $0xc,%esp
   14038:	ff 75 08             	pushl  0x8(%ebp)
   1403b:	e8 c9 00 00 00       	call   14109 <_DecodeSOF>
   14040:	83 c4 10             	add    $0x10,%esp
   14043:	e9 85 00 00 00       	jmp    140cd <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   14048:	83 ec 0c             	sub    $0xc,%esp
   1404b:	ff 75 08             	pushl  0x8(%ebp)
   1404e:	e8 28 05 00 00       	call   1457b <_DecodeDHT>
   14053:	83 c4 10             	add    $0x10,%esp
   14056:	eb 75                	jmp    140cd <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   14058:	83 ec 0c             	sub    $0xc,%esp
   1405b:	ff 75 08             	pushl  0x8(%ebp)
   1405e:	e8 05 07 00 00       	call   14768 <_DecodeDQT>
   14063:	83 c4 10             	add    $0x10,%esp
   14066:	eb 65                	jmp    140cd <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   14068:	83 ec 0c             	sub    $0xc,%esp
   1406b:	ff 75 08             	pushl  0x8(%ebp)
   1406e:	e8 ff 07 00 00       	call   14872 <_DecodeDRI>
   14073:	83 c4 10             	add    $0x10,%esp
   14076:	eb 55                	jmp    140cd <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   14078:	83 ec 08             	sub    $0x8,%esp
   1407b:	ff 75 0c             	pushl  0xc(%ebp)
   1407e:	ff 75 08             	pushl  0x8(%ebp)
   14081:	e8 56 08 00 00       	call   148dc <_DecodeSOS>
   14086:	83 c4 10             	add    $0x10,%esp
   14089:	eb 42                	jmp    140cd <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   1408b:	83 ec 0c             	sub    $0xc,%esp
   1408e:	ff 75 08             	pushl  0x8(%ebp)
   14091:	e8 a8 15 00 00       	call   1563e <_SkipMarker>
   14096:	83 c4 10             	add    $0x10,%esp
   14099:	eb 32                	jmp    140cd <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   1409b:	8b 45 08             	mov    0x8(%ebp),%eax
   1409e:	8b 40 04             	mov    0x4(%eax),%eax
   140a1:	83 e8 01             	sub    $0x1,%eax
   140a4:	0f b6 00             	movzbl (%eax),%eax
   140a7:	0f b6 c0             	movzbl %al,%eax
   140aa:	25 f0 00 00 00       	and    $0xf0,%eax
   140af:	3d e0 00 00 00       	cmp    $0xe0,%eax
   140b4:	75 10                	jne    140c6 <_DecodeJPEG+0x166>
   140b6:	83 ec 0c             	sub    $0xc,%esp
   140b9:	ff 75 08             	pushl  0x8(%ebp)
   140bc:	e8 7d 15 00 00       	call   1563e <_SkipMarker>
   140c1:	83 c4 10             	add    $0x10,%esp
   140c4:	eb 07                	jmp    140cd <_DecodeJPEG+0x16d>
                else return Unsupported;
   140c6:	b8 02 00 00 00       	mov    $0x2,%eax
   140cb:	eb 3a                	jmp    14107 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   140cd:	8b 45 08             	mov    0x8(%ebp),%eax
   140d0:	8b 00                	mov    (%eax),%eax
   140d2:	85 c0                	test   %eax,%eax
   140d4:	0f 84 e9 fe ff ff    	je     13fc3 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   140da:	8b 45 08             	mov    0x8(%ebp),%eax
   140dd:	8b 00                	mov    (%eax),%eax
   140df:	83 f8 06             	cmp    $0x6,%eax
   140e2:	74 07                	je     140eb <_DecodeJPEG+0x18b>
   140e4:	8b 45 08             	mov    0x8(%ebp),%eax
   140e7:	8b 00                	mov    (%eax),%eax
   140e9:	eb 1c                	jmp    14107 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   140eb:	8b 45 08             	mov    0x8(%ebp),%eax
   140ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   140f4:	83 ec 0c             	sub    $0xc,%esp
   140f7:	ff 75 08             	pushl  0x8(%ebp)
   140fa:	e8 6b 15 00 00       	call   1566a <_Convert>
   140ff:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   14102:	8b 45 08             	mov    0x8(%ebp),%eax
   14105:	8b 00                	mov    (%eax),%eax
 }
   14107:	c9                   	leave  
   14108:	c3                   	ret    

00014109 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   14109:	55                   	push   %ebp
   1410a:	89 e5                	mov    %esp,%ebp
   1410c:	53                   	push   %ebx
   1410d:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   14110:	83 ec 0c             	sub    $0xc,%esp
   14113:	ff 75 08             	pushl  0x8(%ebp)
   14116:	e8 c1 fd ff ff       	call   13edc <_DecodeLength>
   1411b:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   1411e:	8b 45 08             	mov    0x8(%ebp),%eax
   14121:	8b 00                	mov    (%eax),%eax
   14123:	85 c0                	test   %eax,%eax
   14125:	0f 85 4a 04 00 00    	jne    14575 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   1412b:	8b 45 08             	mov    0x8(%ebp),%eax
   1412e:	8b 40 0c             	mov    0xc(%eax),%eax
   14131:	83 f8 08             	cmp    $0x8,%eax
   14134:	7f 0e                	jg     14144 <_DecodeSOF+0x3b>
   14136:	8b 45 08             	mov    0x8(%ebp),%eax
   14139:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1413f:	e9 32 04 00 00       	jmp    14576 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   14144:	8b 45 08             	mov    0x8(%ebp),%eax
   14147:	8b 40 04             	mov    0x4(%eax),%eax
   1414a:	0f b6 00             	movzbl (%eax),%eax
   1414d:	3c 08                	cmp    $0x8,%al
   1414f:	74 0e                	je     1415f <_DecodeSOF+0x56>
   14151:	8b 45 08             	mov    0x8(%ebp),%eax
   14154:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1415a:	e9 17 04 00 00       	jmp    14576 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   1415f:	8b 45 08             	mov    0x8(%ebp),%eax
   14162:	8b 40 04             	mov    0x4(%eax),%eax
   14165:	83 c0 01             	add    $0x1,%eax
   14168:	83 ec 0c             	sub    $0xc,%esp
   1416b:	50                   	push   %eax
   1416c:	e8 ce fd ff ff       	call   13f3f <_Decode2Bytes>
   14171:	83 c4 10             	add    $0x10,%esp
   14174:	89 c2                	mov    %eax,%edx
   14176:	8b 45 08             	mov    0x8(%ebp),%eax
   14179:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   1417c:	8b 45 08             	mov    0x8(%ebp),%eax
   1417f:	8b 40 04             	mov    0x4(%eax),%eax
   14182:	83 c0 03             	add    $0x3,%eax
   14185:	83 ec 0c             	sub    $0xc,%esp
   14188:	50                   	push   %eax
   14189:	e8 b1 fd ff ff       	call   13f3f <_Decode2Bytes>
   1418e:	83 c4 10             	add    $0x10,%esp
   14191:	89 c2                	mov    %eax,%edx
   14193:	8b 45 08             	mov    0x8(%ebp),%eax
   14196:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   14199:	8b 45 08             	mov    0x8(%ebp),%eax
   1419c:	8b 40 04             	mov    0x4(%eax),%eax
   1419f:	83 c0 05             	add    $0x5,%eax
   141a2:	0f b6 00             	movzbl (%eax),%eax
   141a5:	0f b6 d0             	movzbl %al,%edx
   141a8:	8b 45 08             	mov    0x8(%ebp),%eax
   141ab:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   141ae:	83 ec 08             	sub    $0x8,%esp
   141b1:	6a 06                	push   $0x6
   141b3:	ff 75 08             	pushl  0x8(%ebp)
   141b6:	e8 d5 fc ff ff       	call   13e90 <_Skip>
   141bb:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   141be:	8b 45 08             	mov    0x8(%ebp),%eax
   141c1:	8b 40 28             	mov    0x28(%eax),%eax
   141c4:	83 f8 01             	cmp    $0x1,%eax
   141c7:	74 13                	je     141dc <_DecodeSOF+0xd3>
   141c9:	83 f8 03             	cmp    $0x3,%eax
   141cc:	74 0e                	je     141dc <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   141ce:	8b 45 08             	mov    0x8(%ebp),%eax
   141d1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   141d7:	e9 9a 03 00 00       	jmp    14576 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   141dc:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   141dd:	8b 45 08             	mov    0x8(%ebp),%eax
   141e0:	8b 48 0c             	mov    0xc(%eax),%ecx
   141e3:	8b 45 08             	mov    0x8(%ebp),%eax
   141e6:	8b 50 28             	mov    0x28(%eax),%edx
   141e9:	89 d0                	mov    %edx,%eax
   141eb:	01 c0                	add    %eax,%eax
   141ed:	01 d0                	add    %edx,%eax
   141ef:	39 c1                	cmp    %eax,%ecx
   141f1:	7d 0e                	jge    14201 <_DecodeSOF+0xf8>
   141f3:	8b 45 08             	mov    0x8(%ebp),%eax
   141f6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   141fc:	e9 75 03 00 00       	jmp    14576 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   14201:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14208:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1420f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14216:	8b 45 08             	mov    0x8(%ebp),%eax
   14219:	83 c0 2c             	add    $0x2c,%eax
   1421c:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1421f:	e9 50 01 00 00       	jmp    14374 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   14224:	8b 45 08             	mov    0x8(%ebp),%eax
   14227:	8b 40 04             	mov    0x4(%eax),%eax
   1422a:	0f b6 00             	movzbl (%eax),%eax
   1422d:	0f b6 d0             	movzbl %al,%edx
   14230:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14233:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   14235:	8b 45 08             	mov    0x8(%ebp),%eax
   14238:	8b 40 04             	mov    0x4(%eax),%eax
   1423b:	83 c0 01             	add    $0x1,%eax
   1423e:	0f b6 00             	movzbl (%eax),%eax
   14241:	c0 e8 04             	shr    $0x4,%al
   14244:	0f b6 d0             	movzbl %al,%edx
   14247:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1424a:	89 50 04             	mov    %edx,0x4(%eax)
   1424d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14250:	8b 40 04             	mov    0x4(%eax),%eax
   14253:	85 c0                	test   %eax,%eax
   14255:	75 0e                	jne    14265 <_DecodeSOF+0x15c>
   14257:	8b 45 08             	mov    0x8(%ebp),%eax
   1425a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14260:	e9 11 03 00 00       	jmp    14576 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   14265:	8b 45 08             	mov    0x8(%ebp),%eax
   14268:	8b 40 04             	mov    0x4(%eax),%eax
   1426b:	83 c0 01             	add    $0x1,%eax
   1426e:	0f b6 00             	movzbl (%eax),%eax
   14271:	0f b6 c0             	movzbl %al,%eax
   14274:	83 e0 0f             	and    $0xf,%eax
   14277:	89 c2                	mov    %eax,%edx
   14279:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1427c:	89 50 08             	mov    %edx,0x8(%eax)
   1427f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14282:	8b 40 08             	mov    0x8(%eax),%eax
   14285:	85 c0                	test   %eax,%eax
   14287:	75 0e                	jne    14297 <_DecodeSOF+0x18e>
   14289:	8b 45 08             	mov    0x8(%ebp),%eax
   1428c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14292:	e9 df 02 00 00       	jmp    14576 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   14297:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1429a:	8b 50 04             	mov    0x4(%eax),%edx
   1429d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142a0:	8b 40 04             	mov    0x4(%eax),%eax
   142a3:	83 e8 01             	sub    $0x1,%eax
   142a6:	21 d0                	and    %edx,%eax
   142a8:	85 c0                	test   %eax,%eax
   142aa:	74 0e                	je     142ba <_DecodeSOF+0x1b1>
   142ac:	8b 45 08             	mov    0x8(%ebp),%eax
   142af:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   142b5:	e9 bc 02 00 00       	jmp    14576 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   142ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142bd:	8b 50 08             	mov    0x8(%eax),%edx
   142c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142c3:	8b 40 08             	mov    0x8(%eax),%eax
   142c6:	83 e8 01             	sub    $0x1,%eax
   142c9:	21 d0                	and    %edx,%eax
   142cb:	85 c0                	test   %eax,%eax
   142cd:	74 0e                	je     142dd <_DecodeSOF+0x1d4>
   142cf:	8b 45 08             	mov    0x8(%ebp),%eax
   142d2:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   142d8:	e9 99 02 00 00       	jmp    14576 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   142dd:	8b 45 08             	mov    0x8(%ebp),%eax
   142e0:	8b 40 04             	mov    0x4(%eax),%eax
   142e3:	83 c0 02             	add    $0x2,%eax
   142e6:	0f b6 00             	movzbl (%eax),%eax
   142e9:	0f b6 d0             	movzbl %al,%edx
   142ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142ef:	89 50 18             	mov    %edx,0x18(%eax)
   142f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142f5:	8b 40 18             	mov    0x18(%eax),%eax
   142f8:	25 fc 00 00 00       	and    $0xfc,%eax
   142fd:	85 c0                	test   %eax,%eax
   142ff:	74 0e                	je     1430f <_DecodeSOF+0x206>
   14301:	8b 45 08             	mov    0x8(%ebp),%eax
   14304:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1430a:	e9 67 02 00 00       	jmp    14576 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   1430f:	83 ec 08             	sub    $0x8,%esp
   14312:	6a 03                	push   $0x3
   14314:	ff 75 08             	pushl  0x8(%ebp)
   14317:	e8 74 fb ff ff       	call   13e90 <_Skip>
   1431c:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   1431f:	8b 45 08             	mov    0x8(%ebp),%eax
   14322:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14328:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1432b:	8b 40 18             	mov    0x18(%eax),%eax
   1432e:	bb 01 00 00 00       	mov    $0x1,%ebx
   14333:	89 c1                	mov    %eax,%ecx
   14335:	d3 e3                	shl    %cl,%ebx
   14337:	89 d8                	mov    %ebx,%eax
   14339:	09 c2                	or     %eax,%edx
   1433b:	8b 45 08             	mov    0x8(%ebp),%eax
   1433e:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   14344:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14347:	8b 40 04             	mov    0x4(%eax),%eax
   1434a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1434d:	7e 09                	jle    14358 <_DecodeSOF+0x24f>
   1434f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14352:	8b 40 04             	mov    0x4(%eax),%eax
   14355:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14358:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1435b:	8b 40 08             	mov    0x8(%eax),%eax
   1435e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14361:	7e 09                	jle    1436c <_DecodeSOF+0x263>
   14363:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14366:	8b 40 08             	mov    0x8(%eax),%eax
   14369:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1436c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14370:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14374:	8b 45 08             	mov    0x8(%ebp),%eax
   14377:	8b 40 28             	mov    0x28(%eax),%eax
   1437a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1437d:	0f 8f a1 fe ff ff    	jg     14224 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   14383:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14386:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1438d:	8b 45 08             	mov    0x8(%ebp),%eax
   14390:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   14393:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14396:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1439d:	8b 45 08             	mov    0x8(%ebp),%eax
   143a0:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   143a3:	8b 45 08             	mov    0x8(%ebp),%eax
   143a6:	8b 50 10             	mov    0x10(%eax),%edx
   143a9:	8b 45 08             	mov    0x8(%ebp),%eax
   143ac:	8b 40 20             	mov    0x20(%eax),%eax
   143af:	01 d0                	add    %edx,%eax
   143b1:	8d 48 ff             	lea    -0x1(%eax),%ecx
   143b4:	8b 45 08             	mov    0x8(%ebp),%eax
   143b7:	8b 58 20             	mov    0x20(%eax),%ebx
   143ba:	89 c8                	mov    %ecx,%eax
   143bc:	99                   	cltd   
   143bd:	f7 fb                	idiv   %ebx
   143bf:	89 c2                	mov    %eax,%edx
   143c1:	8b 45 08             	mov    0x8(%ebp),%eax
   143c4:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   143c7:	8b 45 08             	mov    0x8(%ebp),%eax
   143ca:	8b 50 14             	mov    0x14(%eax),%edx
   143cd:	8b 45 08             	mov    0x8(%ebp),%eax
   143d0:	8b 40 24             	mov    0x24(%eax),%eax
   143d3:	01 d0                	add    %edx,%eax
   143d5:	8d 48 ff             	lea    -0x1(%eax),%ecx
   143d8:	8b 45 08             	mov    0x8(%ebp),%eax
   143db:	8b 58 24             	mov    0x24(%eax),%ebx
   143de:	89 c8                	mov    %ecx,%eax
   143e0:	99                   	cltd   
   143e1:	f7 fb                	idiv   %ebx
   143e3:	89 c2                	mov    %eax,%edx
   143e5:	8b 45 08             	mov    0x8(%ebp),%eax
   143e8:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   143eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   143f2:	8b 45 08             	mov    0x8(%ebp),%eax
   143f5:	83 c0 2c             	add    $0x2c,%eax
   143f8:	89 45 e8             	mov    %eax,-0x18(%ebp)
   143fb:	e9 fd 00 00 00       	jmp    144fd <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   14400:	8b 45 08             	mov    0x8(%ebp),%eax
   14403:	8b 50 10             	mov    0x10(%eax),%edx
   14406:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14409:	8b 40 04             	mov    0x4(%eax),%eax
   1440c:	0f af d0             	imul   %eax,%edx
   1440f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14412:	01 d0                	add    %edx,%eax
   14414:	83 e8 01             	sub    $0x1,%eax
   14417:	99                   	cltd   
   14418:	f7 7d ec             	idivl  -0x14(%ebp)
   1441b:	89 c2                	mov    %eax,%edx
   1441d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14420:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   14423:	8b 45 08             	mov    0x8(%ebp),%eax
   14426:	8b 50 14             	mov    0x14(%eax),%edx
   14429:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1442c:	8b 40 08             	mov    0x8(%eax),%eax
   1442f:	0f af d0             	imul   %eax,%edx
   14432:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14435:	01 d0                	add    %edx,%eax
   14437:	83 e8 01             	sub    $0x1,%eax
   1443a:	99                   	cltd   
   1443b:	f7 7d f0             	idivl  -0x10(%ebp)
   1443e:	89 c2                	mov    %eax,%edx
   14440:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14443:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14446:	8b 45 08             	mov    0x8(%ebp),%eax
   14449:	8b 50 18             	mov    0x18(%eax),%edx
   1444c:	8b 45 08             	mov    0x8(%ebp),%eax
   1444f:	8b 40 20             	mov    0x20(%eax),%eax
   14452:	0f af d0             	imul   %eax,%edx
   14455:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14458:	8b 40 04             	mov    0x4(%eax),%eax
   1445b:	0f af c2             	imul   %edx,%eax
   1445e:	99                   	cltd   
   1445f:	f7 7d ec             	idivl  -0x14(%ebp)
   14462:	89 c2                	mov    %eax,%edx
   14464:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14467:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   1446a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1446d:	8b 40 0c             	mov    0xc(%eax),%eax
   14470:	83 f8 02             	cmp    $0x2,%eax
   14473:	7f 0b                	jg     14480 <_DecodeSOF+0x377>
   14475:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14478:	8b 40 04             	mov    0x4(%eax),%eax
   1447b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1447e:	75 16                	jne    14496 <_DecodeSOF+0x38d>
   14480:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14483:	8b 40 10             	mov    0x10(%eax),%eax
   14486:	83 f8 02             	cmp    $0x2,%eax
   14489:	7f 19                	jg     144a4 <_DecodeSOF+0x39b>
   1448b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1448e:	8b 40 08             	mov    0x8(%eax),%eax
   14491:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14494:	74 0e                	je     144a4 <_DecodeSOF+0x39b>
   14496:	8b 45 08             	mov    0x8(%ebp),%eax
   14499:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1449f:	e9 d2 00 00 00       	jmp    14576 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   144a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144a7:	8b 48 14             	mov    0x14(%eax),%ecx
   144aa:	8b 45 08             	mov    0x8(%ebp),%eax
   144ad:	8b 50 1c             	mov    0x1c(%eax),%edx
   144b0:	8b 45 08             	mov    0x8(%ebp),%eax
   144b3:	8b 40 24             	mov    0x24(%eax),%eax
   144b6:	0f af d0             	imul   %eax,%edx
   144b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144bc:	8b 40 08             	mov    0x8(%eax),%eax
   144bf:	0f af c2             	imul   %edx,%eax
   144c2:	99                   	cltd   
   144c3:	f7 7d f0             	idivl  -0x10(%ebp)
   144c6:	0f af c1             	imul   %ecx,%eax
   144c9:	83 ec 0c             	sub    $0xc,%esp
   144cc:	50                   	push   %eax
   144cd:	e8 45 c5 fe ff       	call   a17 <malloc>
   144d2:	83 c4 10             	add    $0x10,%esp
   144d5:	89 c2                	mov    %eax,%edx
   144d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144da:	89 50 28             	mov    %edx,0x28(%eax)
   144dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144e0:	8b 40 28             	mov    0x28(%eax),%eax
   144e3:	85 c0                	test   %eax,%eax
   144e5:	75 0e                	jne    144f5 <_DecodeSOF+0x3ec>
   144e7:	8b 45 08             	mov    0x8(%ebp),%eax
   144ea:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   144f0:	e9 81 00 00 00       	jmp    14576 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   144f5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   144f9:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   144fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14500:	8b 40 28             	mov    0x28(%eax),%eax
   14503:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14506:	0f 8f f4 fe ff ff    	jg     14400 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   1450c:	8b 45 08             	mov    0x8(%ebp),%eax
   1450f:	8b 40 28             	mov    0x28(%eax),%eax
   14512:	83 f8 03             	cmp    $0x3,%eax
   14515:	75 47                	jne    1455e <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   14517:	8b 45 08             	mov    0x8(%ebp),%eax
   1451a:	8b 50 10             	mov    0x10(%eax),%edx
   1451d:	8b 45 08             	mov    0x8(%ebp),%eax
   14520:	8b 40 14             	mov    0x14(%eax),%eax
   14523:	0f af d0             	imul   %eax,%edx
   14526:	8b 45 08             	mov    0x8(%ebp),%eax
   14529:	8b 40 28             	mov    0x28(%eax),%eax
   1452c:	0f af c2             	imul   %edx,%eax
   1452f:	83 ec 0c             	sub    $0xc,%esp
   14532:	50                   	push   %eax
   14533:	e8 df c4 fe ff       	call   a17 <malloc>
   14538:	83 c4 10             	add    $0x10,%esp
   1453b:	89 c2                	mov    %eax,%edx
   1453d:	8b 45 08             	mov    0x8(%ebp),%eax
   14540:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14546:	8b 45 08             	mov    0x8(%ebp),%eax
   14549:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1454f:	85 c0                	test   %eax,%eax
   14551:	75 0b                	jne    1455e <_DecodeSOF+0x455>
   14553:	8b 45 08             	mov    0x8(%ebp),%eax
   14556:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1455c:	eb 18                	jmp    14576 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1455e:	8b 45 08             	mov    0x8(%ebp),%eax
   14561:	8b 40 0c             	mov    0xc(%eax),%eax
   14564:	83 ec 08             	sub    $0x8,%esp
   14567:	50                   	push   %eax
   14568:	ff 75 08             	pushl  0x8(%ebp)
   1456b:	e8 20 f9 ff ff       	call   13e90 <_Skip>
   14570:	83 c4 10             	add    $0x10,%esp
   14573:	eb 01                	jmp    14576 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   14575:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   14576:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14579:	c9                   	leave  
   1457a:	c3                   	ret    

0001457b <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   1457b:	55                   	push   %ebp
   1457c:	89 e5                	mov    %esp,%ebp
   1457e:	53                   	push   %ebx
   1457f:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   14582:	83 ec 0c             	sub    $0xc,%esp
   14585:	ff 75 08             	pushl  0x8(%ebp)
   14588:	e8 4f f9 ff ff       	call   13edc <_DecodeLength>
   1458d:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14590:	8b 45 08             	mov    0x8(%ebp),%eax
   14593:	8b 00                	mov    (%eax),%eax
   14595:	85 c0                	test   %eax,%eax
   14597:	0f 85 c5 01 00 00    	jne    14762 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   1459d:	e9 9c 01 00 00       	jmp    1473e <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   145a2:	8b 45 08             	mov    0x8(%ebp),%eax
   145a5:	8b 40 04             	mov    0x4(%eax),%eax
   145a8:	0f b6 00             	movzbl (%eax),%eax
   145ab:	0f b6 c0             	movzbl %al,%eax
   145ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   145b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145b4:	25 ec 00 00 00       	and    $0xec,%eax
   145b9:	85 c0                	test   %eax,%eax
   145bb:	74 0e                	je     145cb <_DecodeDHT+0x50>
   145bd:	8b 45 08             	mov    0x8(%ebp),%eax
   145c0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145c6:	e9 98 01 00 00       	jmp    14763 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   145cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145ce:	83 e0 02             	and    $0x2,%eax
   145d1:	85 c0                	test   %eax,%eax
   145d3:	74 0e                	je     145e3 <_DecodeDHT+0x68>
   145d5:	8b 45 08             	mov    0x8(%ebp),%eax
   145d8:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   145de:	e9 80 01 00 00       	jmp    14763 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   145e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145e6:	c1 f8 03             	sar    $0x3,%eax
   145e9:	0b 45 f4             	or     -0xc(%ebp),%eax
   145ec:	83 e0 03             	and    $0x3,%eax
   145ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   145f2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   145f9:	eb 1c                	jmp    14617 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   145fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145fe:	8d 50 ff             	lea    -0x1(%eax),%edx
   14601:	8b 45 08             	mov    0x8(%ebp),%eax
   14604:	8b 48 04             	mov    0x4(%eax),%ecx
   14607:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1460a:	01 c8                	add    %ecx,%eax
   1460c:	0f b6 00             	movzbl (%eax),%eax
   1460f:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   14613:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14617:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1461b:	7e de                	jle    145fb <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   1461d:	83 ec 08             	sub    $0x8,%esp
   14620:	6a 11                	push   $0x11
   14622:	ff 75 08             	pushl  0x8(%ebp)
   14625:	e8 66 f8 ff ff       	call   13e90 <_Skip>
   1462a:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   1462d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14630:	c1 e0 11             	shl    $0x11,%eax
   14633:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14639:	8b 45 08             	mov    0x8(%ebp),%eax
   1463c:	01 d0                	add    %edx,%eax
   1463e:	83 c0 08             	add    $0x8,%eax
   14641:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14644:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   1464b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1464e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14651:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14658:	e9 be 00 00 00       	jmp    1471b <_DecodeDHT+0x1a0>
            spread >>= 1;
   1465d:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   14660:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14663:	83 e8 01             	sub    $0x1,%eax
   14666:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   1466b:	0f b6 c0             	movzbl %al,%eax
   1466e:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   14671:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14675:	0f 84 9b 00 00 00    	je     14716 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   1467b:	8b 45 08             	mov    0x8(%ebp),%eax
   1467e:	8b 40 0c             	mov    0xc(%eax),%eax
   14681:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14684:	7d 0e                	jge    14694 <_DecodeDHT+0x119>
   14686:	8b 45 08             	mov    0x8(%ebp),%eax
   14689:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1468f:	e9 cf 00 00 00       	jmp    14763 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   14694:	b8 10 00 00 00       	mov    $0x10,%eax
   14699:	2b 45 f0             	sub    -0x10(%ebp),%eax
   1469c:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1469f:	89 c1                	mov    %eax,%ecx
   146a1:	d3 e2                	shl    %cl,%edx
   146a3:	89 d0                	mov    %edx,%eax
   146a5:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   146a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   146ac:	79 0e                	jns    146bc <_DecodeDHT+0x141>
   146ae:	8b 45 08             	mov    0x8(%ebp),%eax
   146b1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146b7:	e9 a7 00 00 00       	jmp    14763 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   146bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   146c3:	eb 36                	jmp    146fb <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   146c5:	8b 45 08             	mov    0x8(%ebp),%eax
   146c8:	8b 50 04             	mov    0x4(%eax),%edx
   146cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146ce:	01 d0                	add    %edx,%eax
   146d0:	0f b6 00             	movzbl (%eax),%eax
   146d3:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   146d5:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   146d8:	eb 14                	jmp    146ee <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   146da:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146dd:	89 c2                	mov    %eax,%edx
   146df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   146e2:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   146e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   146e7:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   146ea:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   146ee:	89 d8                	mov    %ebx,%eax
   146f0:	8d 58 ff             	lea    -0x1(%eax),%ebx
   146f3:	85 c0                	test   %eax,%eax
   146f5:	75 e3                	jne    146da <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   146f7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   146fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146fe:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14701:	7c c2                	jl     146c5 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   14703:	83 ec 08             	sub    $0x8,%esp
   14706:	ff 75 e0             	pushl  -0x20(%ebp)
   14709:	ff 75 08             	pushl  0x8(%ebp)
   1470c:	e8 7f f7 ff ff       	call   13e90 <_Skip>
   14711:	83 c4 10             	add    $0x10,%esp
   14714:	eb 01                	jmp    14717 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14716:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14717:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1471b:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1471f:	0f 8e 38 ff ff ff    	jle    1465d <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14725:	eb 0a                	jmp    14731 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14727:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1472a:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   1472d:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14731:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14734:	8d 50 ff             	lea    -0x1(%eax),%edx
   14737:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1473a:	85 c0                	test   %eax,%eax
   1473c:	75 e9                	jne    14727 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   1473e:	8b 45 08             	mov    0x8(%ebp),%eax
   14741:	8b 40 0c             	mov    0xc(%eax),%eax
   14744:	83 f8 10             	cmp    $0x10,%eax
   14747:	0f 8f 55 fe ff ff    	jg     145a2 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1474d:	8b 45 08             	mov    0x8(%ebp),%eax
   14750:	8b 40 0c             	mov    0xc(%eax),%eax
   14753:	85 c0                	test   %eax,%eax
   14755:	74 0c                	je     14763 <_DecodeDHT+0x1e8>
   14757:	8b 45 08             	mov    0x8(%ebp),%eax
   1475a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14760:	eb 01                	jmp    14763 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   14762:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14763:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14766:	c9                   	leave  
   14767:	c3                   	ret    

00014768 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14768:	55                   	push   %ebp
   14769:	89 e5                	mov    %esp,%ebp
   1476b:	53                   	push   %ebx
   1476c:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   1476f:	83 ec 0c             	sub    $0xc,%esp
   14772:	ff 75 08             	pushl  0x8(%ebp)
   14775:	e8 62 f7 ff ff       	call   13edc <_DecodeLength>
   1477a:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1477d:	8b 45 08             	mov    0x8(%ebp),%eax
   14780:	8b 00                	mov    (%eax),%eax
   14782:	85 c0                	test   %eax,%eax
   14784:	0f 85 e2 00 00 00    	jne    1486c <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   1478a:	e9 b8 00 00 00       	jmp    14847 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   1478f:	8b 45 08             	mov    0x8(%ebp),%eax
   14792:	8b 40 04             	mov    0x4(%eax),%eax
   14795:	0f b6 00             	movzbl (%eax),%eax
   14798:	0f b6 c0             	movzbl %al,%eax
   1479b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   1479e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147a1:	25 ec 00 00 00       	and    $0xec,%eax
   147a6:	85 c0                	test   %eax,%eax
   147a8:	74 0e                	je     147b8 <_DecodeDQT+0x50>
   147aa:	8b 45 08             	mov    0x8(%ebp),%eax
   147ad:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   147b3:	e9 b5 00 00 00       	jmp    1486d <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   147b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147bb:	83 e0 10             	and    $0x10,%eax
   147be:	85 c0                	test   %eax,%eax
   147c0:	74 0e                	je     147d0 <_DecodeDQT+0x68>
   147c2:	8b 45 08             	mov    0x8(%ebp),%eax
   147c5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   147cb:	e9 9d 00 00 00       	jmp    1486d <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   147d0:	8b 45 08             	mov    0x8(%ebp),%eax
   147d3:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   147d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147dc:	bb 01 00 00 00       	mov    $0x1,%ebx
   147e1:	89 c1                	mov    %eax,%ecx
   147e3:	d3 e3                	shl    %cl,%ebx
   147e5:	89 d8                	mov    %ebx,%eax
   147e7:	09 c2                	or     %eax,%edx
   147e9:	8b 45 08             	mov    0x8(%ebp),%eax
   147ec:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   147f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147f5:	c1 e0 06             	shl    $0x6,%eax
   147f8:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   147fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14801:	01 d0                	add    %edx,%eax
   14803:	83 c0 08             	add    $0x8,%eax
   14806:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14809:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14810:	eb 1f                	jmp    14831 <_DecodeDQT+0xc9>
   14812:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14815:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14818:	01 c2                	add    %eax,%edx
   1481a:	8b 45 08             	mov    0x8(%ebp),%eax
   1481d:	8b 40 04             	mov    0x4(%eax),%eax
   14820:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14823:	83 c1 01             	add    $0x1,%ecx
   14826:	01 c8                	add    %ecx,%eax
   14828:	0f b6 00             	movzbl (%eax),%eax
   1482b:	88 02                	mov    %al,(%edx)
   1482d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14831:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14835:	7e db                	jle    14812 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14837:	83 ec 08             	sub    $0x8,%esp
   1483a:	6a 41                	push   $0x41
   1483c:	ff 75 08             	pushl  0x8(%ebp)
   1483f:	e8 4c f6 ff ff       	call   13e90 <_Skip>
   14844:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14847:	8b 45 08             	mov    0x8(%ebp),%eax
   1484a:	8b 40 0c             	mov    0xc(%eax),%eax
   1484d:	83 f8 40             	cmp    $0x40,%eax
   14850:	0f 8f 39 ff ff ff    	jg     1478f <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14856:	8b 45 08             	mov    0x8(%ebp),%eax
   14859:	8b 40 0c             	mov    0xc(%eax),%eax
   1485c:	85 c0                	test   %eax,%eax
   1485e:	74 0d                	je     1486d <_DecodeDQT+0x105>
   14860:	8b 45 08             	mov    0x8(%ebp),%eax
   14863:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14869:	90                   	nop
   1486a:	eb 01                	jmp    1486d <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1486c:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1486d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14870:	c9                   	leave  
   14871:	c3                   	ret    

00014872 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   14872:	55                   	push   %ebp
   14873:	89 e5                	mov    %esp,%ebp
   14875:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14878:	83 ec 0c             	sub    $0xc,%esp
   1487b:	ff 75 08             	pushl  0x8(%ebp)
   1487e:	e8 59 f6 ff ff       	call   13edc <_DecodeLength>
   14883:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14886:	8b 45 08             	mov    0x8(%ebp),%eax
   14889:	8b 00                	mov    (%eax),%eax
   1488b:	85 c0                	test   %eax,%eax
   1488d:	75 4a                	jne    148d9 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   1488f:	8b 45 08             	mov    0x8(%ebp),%eax
   14892:	8b 40 0c             	mov    0xc(%eax),%eax
   14895:	83 f8 01             	cmp    $0x1,%eax
   14898:	7f 0b                	jg     148a5 <_DecodeDRI+0x33>
   1489a:	8b 45 08             	mov    0x8(%ebp),%eax
   1489d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   148a3:	eb 35                	jmp    148da <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   148a5:	8b 45 08             	mov    0x8(%ebp),%eax
   148a8:	8b 40 04             	mov    0x4(%eax),%eax
   148ab:	83 ec 0c             	sub    $0xc,%esp
   148ae:	50                   	push   %eax
   148af:	e8 8b f6 ff ff       	call   13f3f <_Decode2Bytes>
   148b4:	83 c4 10             	add    $0x10,%esp
   148b7:	89 c2                	mov    %eax,%edx
   148b9:	8b 45 08             	mov    0x8(%ebp),%eax
   148bc:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   148c2:	8b 45 08             	mov    0x8(%ebp),%eax
   148c5:	8b 40 0c             	mov    0xc(%eax),%eax
   148c8:	83 ec 08             	sub    $0x8,%esp
   148cb:	50                   	push   %eax
   148cc:	ff 75 08             	pushl  0x8(%ebp)
   148cf:	e8 bc f5 ff ff       	call   13e90 <_Skip>
   148d4:	83 c4 10             	add    $0x10,%esp
   148d7:	eb 01                	jmp    148da <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   148d9:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   148da:	c9                   	leave  
   148db:	c3                   	ret    

000148dc <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   148dc:	55                   	push   %ebp
   148dd:	89 e5                	mov    %esp,%ebp
   148df:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   148e2:	8b 45 08             	mov    0x8(%ebp),%eax
   148e5:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   148eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
   148ee:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   148f5:	83 ec 0c             	sub    $0xc,%esp
   148f8:	ff 75 08             	pushl  0x8(%ebp)
   148fb:	e8 dc f5 ff ff       	call   13edc <_DecodeLength>
   14900:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14903:	8b 45 08             	mov    0x8(%ebp),%eax
   14906:	8b 00                	mov    (%eax),%eax
   14908:	85 c0                	test   %eax,%eax
   1490a:	0f 85 c2 02 00 00    	jne    14bd2 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   14910:	8b 45 08             	mov    0x8(%ebp),%eax
   14913:	8b 50 0c             	mov    0xc(%eax),%edx
   14916:	8b 45 08             	mov    0x8(%ebp),%eax
   14919:	8b 40 28             	mov    0x28(%eax),%eax
   1491c:	83 c0 02             	add    $0x2,%eax
   1491f:	01 c0                	add    %eax,%eax
   14921:	39 c2                	cmp    %eax,%edx
   14923:	7c 16                	jl     1493b <_DecodeSOS+0x5f>
   14925:	8b 45 08             	mov    0x8(%ebp),%eax
   14928:	8b 40 04             	mov    0x4(%eax),%eax
   1492b:	0f b6 00             	movzbl (%eax),%eax
   1492e:	0f b6 d0             	movzbl %al,%edx
   14931:	8b 45 08             	mov    0x8(%ebp),%eax
   14934:	8b 40 28             	mov    0x28(%eax),%eax
   14937:	39 c2                	cmp    %eax,%edx
   14939:	74 0e                	je     14949 <_DecodeSOS+0x6d>
   1493b:	8b 45 08             	mov    0x8(%ebp),%eax
   1493e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14944:	e9 8d 02 00 00       	jmp    14bd6 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14949:	83 ec 08             	sub    $0x8,%esp
   1494c:	6a 01                	push   $0x1
   1494e:	ff 75 08             	pushl  0x8(%ebp)
   14951:	e8 3a f5 ff ff       	call   13e90 <_Skip>
   14956:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14959:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14960:	8b 45 08             	mov    0x8(%ebp),%eax
   14963:	83 c0 2c             	add    $0x2c,%eax
   14966:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14969:	e9 ba 00 00 00       	jmp    14a28 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   1496e:	8b 45 08             	mov    0x8(%ebp),%eax
   14971:	8b 40 04             	mov    0x4(%eax),%eax
   14974:	0f b6 00             	movzbl (%eax),%eax
   14977:	0f b6 d0             	movzbl %al,%edx
   1497a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1497d:	8b 00                	mov    (%eax),%eax
   1497f:	39 c2                	cmp    %eax,%edx
   14981:	74 0e                	je     14991 <_DecodeSOS+0xb5>
   14983:	8b 45 08             	mov    0x8(%ebp),%eax
   14986:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1498c:	e9 45 02 00 00       	jmp    14bd6 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   14991:	8b 45 08             	mov    0x8(%ebp),%eax
   14994:	8b 40 04             	mov    0x4(%eax),%eax
   14997:	83 c0 01             	add    $0x1,%eax
   1499a:	0f b6 00             	movzbl (%eax),%eax
   1499d:	0f b6 c0             	movzbl %al,%eax
   149a0:	25 ec 00 00 00       	and    $0xec,%eax
   149a5:	85 c0                	test   %eax,%eax
   149a7:	74 0e                	je     149b7 <_DecodeSOS+0xdb>
   149a9:	8b 45 08             	mov    0x8(%ebp),%eax
   149ac:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149b2:	e9 1f 02 00 00       	jmp    14bd6 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   149b7:	8b 45 08             	mov    0x8(%ebp),%eax
   149ba:	8b 40 04             	mov    0x4(%eax),%eax
   149bd:	83 c0 01             	add    $0x1,%eax
   149c0:	0f b6 00             	movzbl (%eax),%eax
   149c3:	0f b6 c0             	movzbl %al,%eax
   149c6:	83 e0 02             	and    $0x2,%eax
   149c9:	85 c0                	test   %eax,%eax
   149cb:	74 0e                	je     149db <_DecodeSOS+0xff>
   149cd:	8b 45 08             	mov    0x8(%ebp),%eax
   149d0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   149d6:	e9 fb 01 00 00       	jmp    14bd6 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   149db:	8b 45 08             	mov    0x8(%ebp),%eax
   149de:	8b 40 04             	mov    0x4(%eax),%eax
   149e1:	83 c0 01             	add    $0x1,%eax
   149e4:	0f b6 00             	movzbl (%eax),%eax
   149e7:	c0 e8 04             	shr    $0x4,%al
   149ea:	0f b6 d0             	movzbl %al,%edx
   149ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
   149f0:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   149f3:	8b 45 08             	mov    0x8(%ebp),%eax
   149f6:	8b 40 04             	mov    0x4(%eax),%eax
   149f9:	83 c0 01             	add    $0x1,%eax
   149fc:	0f b6 00             	movzbl (%eax),%eax
   149ff:	0f b6 c0             	movzbl %al,%eax
   14a02:	83 e0 01             	and    $0x1,%eax
   14a05:	83 c8 02             	or     $0x2,%eax
   14a08:	89 c2                	mov    %eax,%edx
   14a0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14a0d:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   14a10:	83 ec 08             	sub    $0x8,%esp
   14a13:	6a 02                	push   $0x2
   14a15:	ff 75 08             	pushl  0x8(%ebp)
   14a18:	e8 73 f4 ff ff       	call   13e90 <_Skip>
   14a1d:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14a20:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14a24:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14a28:	8b 45 08             	mov    0x8(%ebp),%eax
   14a2b:	8b 40 28             	mov    0x28(%eax),%eax
   14a2e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14a31:	0f 8f 37 ff ff ff    	jg     1496e <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14a37:	8b 45 08             	mov    0x8(%ebp),%eax
   14a3a:	8b 40 04             	mov    0x4(%eax),%eax
   14a3d:	0f b6 00             	movzbl (%eax),%eax
   14a40:	84 c0                	test   %al,%al
   14a42:	75 10                	jne    14a54 <_DecodeSOS+0x178>
   14a44:	8b 45 08             	mov    0x8(%ebp),%eax
   14a47:	8b 40 04             	mov    0x4(%eax),%eax
   14a4a:	83 c0 01             	add    $0x1,%eax
   14a4d:	0f b6 00             	movzbl (%eax),%eax
   14a50:	3c 3f                	cmp    $0x3f,%al
   14a52:	74 0e                	je     14a62 <_DecodeSOS+0x186>
   14a54:	8b 45 08             	mov    0x8(%ebp),%eax
   14a57:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a5d:	e9 74 01 00 00       	jmp    14bd6 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   14a62:	8b 45 08             	mov    0x8(%ebp),%eax
   14a65:	8b 40 04             	mov    0x4(%eax),%eax
   14a68:	83 c0 02             	add    $0x2,%eax
   14a6b:	0f b6 00             	movzbl (%eax),%eax
   14a6e:	84 c0                	test   %al,%al
   14a70:	74 0e                	je     14a80 <_DecodeSOS+0x1a4>
   14a72:	8b 45 08             	mov    0x8(%ebp),%eax
   14a75:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14a7b:	e9 56 01 00 00       	jmp    14bd6 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   14a80:	8b 45 08             	mov    0x8(%ebp),%eax
   14a83:	8b 40 0c             	mov    0xc(%eax),%eax
   14a86:	83 ec 08             	sub    $0x8,%esp
   14a89:	50                   	push   %eax
   14a8a:	ff 75 08             	pushl  0x8(%ebp)
   14a8d:	e8 fe f3 ff ff       	call   13e90 <_Skip>
   14a92:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14a95:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14a9c:	e9 17 01 00 00       	jmp    14bb8 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14aa1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14aa8:	e9 f8 00 00 00       	jmp    14ba5 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14aad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14ab4:	8b 45 08             	mov    0x8(%ebp),%eax
   14ab7:	83 c0 2c             	add    $0x2c,%eax
   14aba:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14abd:	e9 8d 00 00 00       	jmp    14b4f <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   14ac2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14ac9:	eb 71                	jmp    14b3c <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14acb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14ad2:	eb 59                	jmp    14b2d <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   14ad4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ad7:	8b 50 28             	mov    0x28(%eax),%edx
   14ada:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14add:	8b 40 08             	mov    0x8(%eax),%eax
   14ae0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14ae4:	89 c1                	mov    %eax,%ecx
   14ae6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14ae9:	01 c1                	add    %eax,%ecx
   14aeb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14aee:	8b 40 14             	mov    0x14(%eax),%eax
   14af1:	0f af c8             	imul   %eax,%ecx
   14af4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14af7:	8b 40 04             	mov    0x4(%eax),%eax
   14afa:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14afe:	01 c1                	add    %eax,%ecx
   14b00:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14b03:	01 c8                	add    %ecx,%eax
   14b05:	c1 e0 03             	shl    $0x3,%eax
   14b08:	01 d0                	add    %edx,%eax
   14b0a:	50                   	push   %eax
   14b0b:	ff 75 dc             	pushl  -0x24(%ebp)
   14b0e:	ff 75 0c             	pushl  0xc(%ebp)
   14b11:	ff 75 08             	pushl  0x8(%ebp)
   14b14:	e8 bf 00 00 00       	call   14bd8 <_DecodeBlock>
   14b19:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14b1c:	8b 45 08             	mov    0x8(%ebp),%eax
   14b1f:	8b 00                	mov    (%eax),%eax
   14b21:	85 c0                	test   %eax,%eax
   14b23:	0f 85 ac 00 00 00    	jne    14bd5 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14b29:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14b2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14b30:	8b 40 04             	mov    0x4(%eax),%eax
   14b33:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14b36:	7f 9c                	jg     14ad4 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14b38:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14b3c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14b3f:	8b 40 08             	mov    0x8(%eax),%eax
   14b42:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14b45:	7f 84                	jg     14acb <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14b47:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14b4b:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14b4f:	8b 45 08             	mov    0x8(%ebp),%eax
   14b52:	8b 40 28             	mov    0x28(%eax),%eax
   14b55:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14b58:	0f 8f 64 ff ff ff    	jg     14ac2 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   14b5e:	8b 45 08             	mov    0x8(%ebp),%eax
   14b61:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14b67:	85 c0                	test   %eax,%eax
   14b69:	74 36                	je     14ba1 <_DecodeSOS+0x2c5>
   14b6b:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   14b6f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14b73:	75 2c                	jne    14ba1 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   14b75:	83 ec 0c             	sub    $0xc,%esp
   14b78:	ff 75 08             	pushl  0x8(%ebp)
   14b7b:	e8 9f 0a 00 00       	call   1561f <_ByteAlign>
   14b80:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   14b83:	83 ec 08             	sub    $0x8,%esp
   14b86:	6a 10                	push   $0x10
   14b88:	ff 75 08             	pushl  0x8(%ebp)
   14b8b:	e8 ce 04 00 00       	call   1505e <_GetBits>
   14b90:	83 c4 10             	add    $0x10,%esp
   14b93:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   14b96:	8b 45 08             	mov    0x8(%ebp),%eax
   14b99:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b9f:	eb 35                	jmp    14bd6 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14ba1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14ba5:	8b 45 08             	mov    0x8(%ebp),%eax
   14ba8:	8b 40 18             	mov    0x18(%eax),%eax
   14bab:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14bae:	0f 8f f9 fe ff ff    	jg     14aad <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14bb4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14bb8:	8b 45 08             	mov    0x8(%ebp),%eax
   14bbb:	8b 40 1c             	mov    0x1c(%eax),%eax
   14bbe:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14bc1:	0f 8f da fe ff ff    	jg     14aa1 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   14bc7:	8b 45 08             	mov    0x8(%ebp),%eax
   14bca:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   14bd0:	eb 04                	jmp    14bd6 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14bd2:	90                   	nop
   14bd3:	eb 01                	jmp    14bd6 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   14bd5:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14bd6:	c9                   	leave  
   14bd7:	c3                   	ret    

00014bd8 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14bd8:	55                   	push   %ebp
   14bd9:	89 e5                	mov    %esp,%ebp
   14bdb:	53                   	push   %ebx
   14bdc:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   14bdf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14be6:	8b 45 08             	mov    0x8(%ebp),%eax
   14be9:	05 c0 01 08 00       	add    $0x801c0,%eax
   14bee:	83 ec 04             	sub    $0x4,%esp
   14bf1:	68 00 01 00 00       	push   $0x100
   14bf6:	6a 00                	push   $0x0
   14bf8:	50                   	push   %eax
   14bf9:	e8 04 b8 fe ff       	call   402 <memset>
   14bfe:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   14c01:	8b 45 10             	mov    0x10(%ebp),%eax
   14c04:	8b 40 20             	mov    0x20(%eax),%eax
   14c07:	c1 e0 11             	shl    $0x11,%eax
   14c0a:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14c10:	8b 45 08             	mov    0x8(%ebp),%eax
   14c13:	01 d0                	add    %edx,%eax
   14c15:	83 c0 08             	add    $0x8,%eax
   14c18:	83 ec 04             	sub    $0x4,%esp
   14c1b:	6a 00                	push   $0x0
   14c1d:	50                   	push   %eax
   14c1e:	ff 75 08             	pushl  0x8(%ebp)
   14c21:	e8 86 01 00 00       	call   14dac <_GetVLC>
   14c26:	83 c4 10             	add    $0x10,%esp
   14c29:	89 c2                	mov    %eax,%edx
   14c2b:	8b 45 10             	mov    0x10(%ebp),%eax
   14c2e:	8b 40 24             	mov    0x24(%eax),%eax
   14c31:	01 c2                	add    %eax,%edx
   14c33:	8b 45 10             	mov    0x10(%ebp),%eax
   14c36:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14c39:	8b 45 10             	mov    0x10(%ebp),%eax
   14c3c:	8b 50 24             	mov    0x24(%eax),%edx
   14c3f:	8b 45 10             	mov    0x10(%ebp),%eax
   14c42:	8b 48 18             	mov    0x18(%eax),%ecx
   14c45:	8b 45 08             	mov    0x8(%ebp),%eax
   14c48:	c1 e1 06             	shl    $0x6,%ecx
   14c4b:	01 c8                	add    %ecx,%eax
   14c4d:	05 b8 00 00 00       	add    $0xb8,%eax
   14c52:	0f b6 00             	movzbl (%eax),%eax
   14c55:	0f b6 c0             	movzbl %al,%eax
   14c58:	0f af d0             	imul   %eax,%edx
   14c5b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c5e:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14c64:	8b 45 10             	mov    0x10(%ebp),%eax
   14c67:	8b 40 1c             	mov    0x1c(%eax),%eax
   14c6a:	c1 e0 11             	shl    $0x11,%eax
   14c6d:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14c73:	8b 45 08             	mov    0x8(%ebp),%eax
   14c76:	01 d0                	add    %edx,%eax
   14c78:	8d 50 08             	lea    0x8(%eax),%edx
   14c7b:	83 ec 04             	sub    $0x4,%esp
   14c7e:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14c81:	50                   	push   %eax
   14c82:	52                   	push   %edx
   14c83:	ff 75 08             	pushl  0x8(%ebp)
   14c86:	e8 21 01 00 00       	call   14dac <_GetVLC>
   14c8b:	83 c4 10             	add    $0x10,%esp
   14c8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14c91:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14c95:	84 c0                	test   %al,%al
   14c97:	0f 84 92 00 00 00    	je     14d2f <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14c9d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14ca1:	0f b6 c0             	movzbl %al,%eax
   14ca4:	83 e0 0f             	and    $0xf,%eax
   14ca7:	85 c0                	test   %eax,%eax
   14ca9:	75 16                	jne    14cc1 <_DecodeBlock+0xe9>
   14cab:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14caf:	3c f0                	cmp    $0xf0,%al
   14cb1:	74 0e                	je     14cc1 <_DecodeBlock+0xe9>
   14cb3:	8b 45 08             	mov    0x8(%ebp),%eax
   14cb6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14cbc:	e9 e6 00 00 00       	jmp    14da7 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14cc1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14cc5:	c0 e8 04             	shr    $0x4,%al
   14cc8:	0f b6 c0             	movzbl %al,%eax
   14ccb:	83 c0 01             	add    $0x1,%eax
   14cce:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14cd1:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14cd5:	7e 0e                	jle    14ce5 <_DecodeBlock+0x10d>
   14cd7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cda:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ce0:	e9 c2 00 00 00       	jmp    14da7 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14ce5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14ce8:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ceb:	01 d0                	add    %edx,%eax
   14ced:	0f b6 00             	movzbl (%eax),%eax
   14cf0:	0f be c8             	movsbl %al,%ecx
   14cf3:	8b 45 10             	mov    0x10(%ebp),%eax
   14cf6:	8b 50 18             	mov    0x18(%eax),%edx
   14cf9:	8b 45 08             	mov    0x8(%ebp),%eax
   14cfc:	c1 e2 06             	shl    $0x6,%edx
   14cff:	01 c2                	add    %eax,%edx
   14d01:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14d04:	01 d0                	add    %edx,%eax
   14d06:	05 b8 00 00 00       	add    $0xb8,%eax
   14d0b:	0f b6 00             	movzbl (%eax),%eax
   14d0e:	0f b6 c0             	movzbl %al,%eax
   14d11:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14d15:	89 c2                	mov    %eax,%edx
   14d17:	8b 45 08             	mov    0x8(%ebp),%eax
   14d1a:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14d20:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14d23:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14d27:	0f 8e 37 ff ff ff    	jle    14c64 <_DecodeBlock+0x8c>
   14d2d:	eb 01                	jmp    14d30 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14d2f:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14d30:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14d37:	eb 24                	jmp    14d5d <_DecodeBlock+0x185>
   14d39:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14d3c:	05 70 00 02 00       	add    $0x20070,%eax
   14d41:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14d48:	8b 45 08             	mov    0x8(%ebp),%eax
   14d4b:	01 d0                	add    %edx,%eax
   14d4d:	83 ec 0c             	sub    $0xc,%esp
   14d50:	50                   	push   %eax
   14d51:	e8 32 03 00 00       	call   15088 <_RowIDCT>
   14d56:	83 c4 10             	add    $0x10,%esp
   14d59:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14d5d:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14d61:	7e d6                	jle    14d39 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14d63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14d6a:	eb 35                	jmp    14da1 <_DecodeBlock+0x1c9>
   14d6c:	8b 45 10             	mov    0x10(%ebp),%eax
   14d6f:	8b 40 14             	mov    0x14(%eax),%eax
   14d72:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14d75:	8b 55 14             	mov    0x14(%ebp),%edx
   14d78:	01 d1                	add    %edx,%ecx
   14d7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14d7d:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14d83:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14d8a:	8b 55 08             	mov    0x8(%ebp),%edx
   14d8d:	01 da                	add    %ebx,%edx
   14d8f:	83 ec 04             	sub    $0x4,%esp
   14d92:	50                   	push   %eax
   14d93:	51                   	push   %ecx
   14d94:	52                   	push   %edx
   14d95:	e8 7b 05 00 00       	call   15315 <_ColIDCT>
   14d9a:	83 c4 10             	add    $0x10,%esp
   14d9d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14da1:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14da5:	7e c5                	jle    14d6c <_DecodeBlock+0x194>
}
   14da7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14daa:	c9                   	leave  
   14dab:	c3                   	ret    

00014dac <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14dac:	55                   	push   %ebp
   14dad:	89 e5                	mov    %esp,%ebp
   14daf:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14db2:	83 ec 08             	sub    $0x8,%esp
   14db5:	6a 10                	push   $0x10
   14db7:	ff 75 08             	pushl  0x8(%ebp)
   14dba:	e8 c2 00 00 00       	call   14e81 <_ShowBits>
   14dbf:	83 c4 10             	add    $0x10,%esp
   14dc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14dc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14dc8:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14dcb:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dce:	01 d0                	add    %edx,%eax
   14dd0:	0f b6 00             	movzbl (%eax),%eax
   14dd3:	0f b6 c0             	movzbl %al,%eax
   14dd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14dd9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14ddd:	75 13                	jne    14df2 <_GetVLC+0x46>
   14ddf:	8b 45 08             	mov    0x8(%ebp),%eax
   14de2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14de8:	b8 00 00 00 00       	mov    $0x0,%eax
   14ded:	e9 8d 00 00 00       	jmp    14e7f <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14df2:	83 ec 08             	sub    $0x8,%esp
   14df5:	ff 75 f0             	pushl  -0x10(%ebp)
   14df8:	ff 75 08             	pushl  0x8(%ebp)
   14dfb:	e8 25 02 00 00       	call   15025 <_SkipBits>
   14e00:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14e03:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e06:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14e09:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e0c:	01 d0                	add    %edx,%eax
   14e0e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14e12:	0f b6 c0             	movzbl %al,%eax
   14e15:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14e18:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14e1c:	74 0a                	je     14e28 <_GetVLC+0x7c>
   14e1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e21:	89 c2                	mov    %eax,%edx
   14e23:	8b 45 10             	mov    0x10(%ebp),%eax
   14e26:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14e28:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e2b:	83 e0 0f             	and    $0xf,%eax
   14e2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14e31:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14e35:	75 07                	jne    14e3e <_GetVLC+0x92>
   14e37:	b8 00 00 00 00       	mov    $0x0,%eax
   14e3c:	eb 41                	jmp    14e7f <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14e3e:	83 ec 08             	sub    $0x8,%esp
   14e41:	ff 75 f0             	pushl  -0x10(%ebp)
   14e44:	ff 75 08             	pushl  0x8(%ebp)
   14e47:	e8 12 02 00 00       	call   1505e <_GetBits>
   14e4c:	83 c4 10             	add    $0x10,%esp
   14e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14e52:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14e55:	83 e8 01             	sub    $0x1,%eax
   14e58:	ba 01 00 00 00       	mov    $0x1,%edx
   14e5d:	89 c1                	mov    %eax,%ecx
   14e5f:	d3 e2                	shl    %cl,%edx
   14e61:	89 d0                	mov    %edx,%eax
   14e63:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14e66:	7e 14                	jle    14e7c <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14e68:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14e6b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14e70:	89 c1                	mov    %eax,%ecx
   14e72:	d3 e2                	shl    %cl,%edx
   14e74:	89 d0                	mov    %edx,%eax
   14e76:	83 c0 01             	add    $0x1,%eax
   14e79:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14e7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14e7f:	c9                   	leave  
   14e80:	c3                   	ret    

00014e81 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14e81:	55                   	push   %ebp
   14e82:	89 e5                	mov    %esp,%ebp
   14e84:	53                   	push   %ebx
   14e85:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14e88:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14e8c:	0f 85 4f 01 00 00    	jne    14fe1 <_ShowBits+0x160>
   14e92:	b8 00 00 00 00       	mov    $0x0,%eax
   14e97:	e9 83 01 00 00       	jmp    1501f <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14e9c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e9f:	8b 40 08             	mov    0x8(%eax),%eax
   14ea2:	85 c0                	test   %eax,%eax
   14ea4:	7f 33                	jg     14ed9 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14ea6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ea9:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14eaf:	c1 e0 08             	shl    $0x8,%eax
   14eb2:	0c ff                	or     $0xff,%al
   14eb4:	89 c2                	mov    %eax,%edx
   14eb6:	8b 45 08             	mov    0x8(%ebp),%eax
   14eb9:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14ebf:	8b 45 08             	mov    0x8(%ebp),%eax
   14ec2:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14ec8:	8d 50 08             	lea    0x8(%eax),%edx
   14ecb:	8b 45 08             	mov    0x8(%ebp),%eax
   14ece:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14ed4:	e9 08 01 00 00       	jmp    14fe1 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14ed9:	8b 45 08             	mov    0x8(%ebp),%eax
   14edc:	8b 40 04             	mov    0x4(%eax),%eax
   14edf:	8d 48 01             	lea    0x1(%eax),%ecx
   14ee2:	8b 55 08             	mov    0x8(%ebp),%edx
   14ee5:	89 4a 04             	mov    %ecx,0x4(%edx)
   14ee8:	0f b6 00             	movzbl (%eax),%eax
   14eeb:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14eee:	8b 45 08             	mov    0x8(%ebp),%eax
   14ef1:	8b 40 08             	mov    0x8(%eax),%eax
   14ef4:	8d 50 ff             	lea    -0x1(%eax),%edx
   14ef7:	8b 45 08             	mov    0x8(%ebp),%eax
   14efa:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14efd:	8b 45 08             	mov    0x8(%ebp),%eax
   14f00:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14f06:	8d 50 08             	lea    0x8(%eax),%edx
   14f09:	8b 45 08             	mov    0x8(%ebp),%eax
   14f0c:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14f12:	8b 45 08             	mov    0x8(%ebp),%eax
   14f15:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14f1b:	c1 e0 08             	shl    $0x8,%eax
   14f1e:	89 c2                	mov    %eax,%edx
   14f20:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14f24:	09 c2                	or     %eax,%edx
   14f26:	8b 45 08             	mov    0x8(%ebp),%eax
   14f29:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14f2f:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14f33:	0f 85 a8 00 00 00    	jne    14fe1 <_ShowBits+0x160>
            if(ctx->size){
   14f39:	8b 45 08             	mov    0x8(%ebp),%eax
   14f3c:	8b 40 08             	mov    0x8(%eax),%eax
   14f3f:	85 c0                	test   %eax,%eax
   14f41:	0f 84 91 00 00 00    	je     14fd8 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14f47:	8b 45 08             	mov    0x8(%ebp),%eax
   14f4a:	8b 40 04             	mov    0x4(%eax),%eax
   14f4d:	8d 48 01             	lea    0x1(%eax),%ecx
   14f50:	8b 55 08             	mov    0x8(%ebp),%edx
   14f53:	89 4a 04             	mov    %ecx,0x4(%edx)
   14f56:	0f b6 00             	movzbl (%eax),%eax
   14f59:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14f5c:	8b 45 08             	mov    0x8(%ebp),%eax
   14f5f:	8b 40 08             	mov    0x8(%eax),%eax
   14f62:	8d 50 ff             	lea    -0x1(%eax),%edx
   14f65:	8b 45 08             	mov    0x8(%ebp),%eax
   14f68:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14f6b:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14f6f:	85 c0                	test   %eax,%eax
   14f71:	74 62                	je     14fd5 <_ShowBits+0x154>
   14f73:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14f78:	75 0c                	jne    14f86 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14f7a:	8b 45 08             	mov    0x8(%ebp),%eax
   14f7d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14f84:	eb 5b                	jmp    14fe1 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14f86:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14f8a:	25 f8 00 00 00       	and    $0xf8,%eax
   14f8f:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14f94:	74 0b                	je     14fa1 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14f96:	8b 45 08             	mov    0x8(%ebp),%eax
   14f99:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14f9f:	eb 40                	jmp    14fe1 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14fa1:	8b 45 08             	mov    0x8(%ebp),%eax
   14fa4:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14faa:	c1 e0 08             	shl    $0x8,%eax
   14fad:	89 c2                	mov    %eax,%edx
   14faf:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14fb3:	09 c2                	or     %eax,%edx
   14fb5:	8b 45 08             	mov    0x8(%ebp),%eax
   14fb8:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14fbe:	8b 45 08             	mov    0x8(%ebp),%eax
   14fc1:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14fc7:	8d 50 08             	lea    0x8(%eax),%edx
   14fca:	8b 45 08             	mov    0x8(%ebp),%eax
   14fcd:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14fd3:	eb 0c                	jmp    14fe1 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14fd5:	90                   	nop
   14fd6:	eb 09                	jmp    14fe1 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14fd8:	8b 45 08             	mov    0x8(%ebp),%eax
   14fdb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14fe1:	8b 45 08             	mov    0x8(%ebp),%eax
   14fe4:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14fea:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14fed:	0f 8c a9 fe ff ff    	jl     14e9c <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14ff3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ff6:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14ffc:	8b 45 08             	mov    0x8(%ebp),%eax
   14fff:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15005:	2b 45 0c             	sub    0xc(%ebp),%eax
   15008:	89 c1                	mov    %eax,%ecx
   1500a:	d3 fa                	sar    %cl,%edx
   1500c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1500f:	bb 01 00 00 00       	mov    $0x1,%ebx
   15014:	89 c1                	mov    %eax,%ecx
   15016:	d3 e3                	shl    %cl,%ebx
   15018:	89 d8                	mov    %ebx,%eax
   1501a:	83 e8 01             	sub    $0x1,%eax
   1501d:	21 d0                	and    %edx,%eax
}
   1501f:	83 c4 10             	add    $0x10,%esp
   15022:	5b                   	pop    %ebx
   15023:	5d                   	pop    %ebp
   15024:	c3                   	ret    

00015025 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   15025:	55                   	push   %ebp
   15026:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   15028:	8b 45 08             	mov    0x8(%ebp),%eax
   1502b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15031:	3b 45 0c             	cmp    0xc(%ebp),%eax
   15034:	7d 0e                	jge    15044 <_SkipBits+0x1f>
   15036:	ff 75 0c             	pushl  0xc(%ebp)
   15039:	ff 75 08             	pushl  0x8(%ebp)
   1503c:	e8 40 fe ff ff       	call   14e81 <_ShowBits>
   15041:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   15044:	8b 45 08             	mov    0x8(%ebp),%eax
   15047:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1504d:	2b 45 0c             	sub    0xc(%ebp),%eax
   15050:	89 c2                	mov    %eax,%edx
   15052:	8b 45 08             	mov    0x8(%ebp),%eax
   15055:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1505b:	90                   	nop
   1505c:	c9                   	leave  
   1505d:	c3                   	ret    

0001505e <_GetBits>:

int _GetBits(Context* ctx, int bits){
   1505e:	55                   	push   %ebp
   1505f:	89 e5                	mov    %esp,%ebp
   15061:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   15064:	ff 75 0c             	pushl  0xc(%ebp)
   15067:	ff 75 08             	pushl  0x8(%ebp)
   1506a:	e8 12 fe ff ff       	call   14e81 <_ShowBits>
   1506f:	83 c4 08             	add    $0x8,%esp
   15072:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   15075:	ff 75 0c             	pushl  0xc(%ebp)
   15078:	ff 75 08             	pushl  0x8(%ebp)
   1507b:	e8 a5 ff ff ff       	call   15025 <_SkipBits>
   15080:	83 c4 08             	add    $0x8,%esp
    return res;
   15083:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   15086:	c9                   	leave  
   15087:	c3                   	ret    

00015088 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   15088:	55                   	push   %ebp
   15089:	89 e5                	mov    %esp,%ebp
   1508b:	57                   	push   %edi
   1508c:	56                   	push   %esi
   1508d:	53                   	push   %ebx
   1508e:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   15091:	8b 45 08             	mov    0x8(%ebp),%eax
   15094:	83 c0 10             	add    $0x10,%eax
   15097:	8b 00                	mov    (%eax),%eax
   15099:	c1 e0 0b             	shl    $0xb,%eax
   1509c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   1509f:	8b 45 08             	mov    0x8(%ebp),%eax
   150a2:	8b 40 18             	mov    0x18(%eax),%eax
   150a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
   150a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   150ab:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   150ae:	8b 55 08             	mov    0x8(%ebp),%edx
   150b1:	8b 52 08             	mov    0x8(%edx),%edx
   150b4:	89 55 e8             	mov    %edx,-0x18(%ebp)
   150b7:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   150ba:	8b 55 08             	mov    0x8(%ebp),%edx
   150bd:	8b 52 04             	mov    0x4(%edx),%edx
   150c0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   150c3:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   150c6:	8b 55 08             	mov    0x8(%ebp),%edx
   150c9:	8b 52 1c             	mov    0x1c(%edx),%edx
   150cc:	89 55 e0             	mov    %edx,-0x20(%ebp)
   150cf:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   150d2:	8b 55 08             	mov    0x8(%ebp),%edx
   150d5:	8b 52 14             	mov    0x14(%edx),%edx
   150d8:	89 55 dc             	mov    %edx,-0x24(%ebp)
   150db:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   150de:	8b 55 08             	mov    0x8(%ebp),%edx
   150e1:	8b 52 0c             	mov    0xc(%edx),%edx
   150e4:	89 55 d8             	mov    %edx,-0x28(%ebp)
   150e7:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   150ea:	85 c0                	test   %eax,%eax
   150ec:	75 68                	jne    15156 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   150ee:	8b 45 08             	mov    0x8(%ebp),%eax
   150f1:	8d 48 04             	lea    0x4(%eax),%ecx
   150f4:	8b 45 08             	mov    0x8(%ebp),%eax
   150f7:	8d 58 08             	lea    0x8(%eax),%ebx
   150fa:	8b 45 08             	mov    0x8(%ebp),%eax
   150fd:	8d 70 0c             	lea    0xc(%eax),%esi
   15100:	8b 45 08             	mov    0x8(%ebp),%eax
   15103:	8d 78 10             	lea    0x10(%eax),%edi
   15106:	8b 45 08             	mov    0x8(%ebp),%eax
   15109:	83 c0 14             	add    $0x14,%eax
   1510c:	89 45 c0             	mov    %eax,-0x40(%ebp)
   1510f:	8b 45 08             	mov    0x8(%ebp),%eax
   15112:	83 c0 18             	add    $0x18,%eax
   15115:	89 45 bc             	mov    %eax,-0x44(%ebp)
   15118:	8b 45 08             	mov    0x8(%ebp),%eax
   1511b:	8d 50 1c             	lea    0x1c(%eax),%edx
   1511e:	8b 45 08             	mov    0x8(%ebp),%eax
   15121:	8b 00                	mov    (%eax),%eax
   15123:	c1 e0 03             	shl    $0x3,%eax
   15126:	89 02                	mov    %eax,(%edx)
   15128:	8b 02                	mov    (%edx),%eax
   1512a:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1512d:	89 02                	mov    %eax,(%edx)
   1512f:	89 d0                	mov    %edx,%eax
   15131:	8b 00                	mov    (%eax),%eax
   15133:	8b 55 c0             	mov    -0x40(%ebp),%edx
   15136:	89 02                	mov    %eax,(%edx)
   15138:	89 d0                	mov    %edx,%eax
   1513a:	8b 00                	mov    (%eax),%eax
   1513c:	89 07                	mov    %eax,(%edi)
   1513e:	8b 07                	mov    (%edi),%eax
   15140:	89 06                	mov    %eax,(%esi)
   15142:	8b 06                	mov    (%esi),%eax
   15144:	89 03                	mov    %eax,(%ebx)
   15146:	8b 03                	mov    (%ebx),%eax
   15148:	89 01                	mov    %eax,(%ecx)
   1514a:	8b 11                	mov    (%ecx),%edx
   1514c:	8b 45 08             	mov    0x8(%ebp),%eax
   1514f:	89 10                	mov    %edx,(%eax)
        return;
   15151:	e9 b7 01 00 00       	jmp    1530d <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   15156:	8b 45 08             	mov    0x8(%ebp),%eax
   15159:	8b 00                	mov    (%eax),%eax
   1515b:	c1 e0 0b             	shl    $0xb,%eax
   1515e:	83 e8 80             	sub    $0xffffff80,%eax
   15161:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   15164:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15167:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1516a:	01 d0                	add    %edx,%eax
   1516c:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15172:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   15175:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15178:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1517e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15181:	01 d0                	add    %edx,%eax
   15183:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   15186:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15189:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   1518f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15192:	01 d0                	add    %edx,%eax
   15194:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   15197:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1519a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1519d:	01 d0                	add    %edx,%eax
   1519f:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   151a5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   151a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   151ab:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   151b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
   151b4:	01 d0                	add    %edx,%eax
   151b6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   151b9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   151bc:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   151c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
   151c5:	01 d0                	add    %edx,%eax
   151c7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   151ca:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   151cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151d0:	01 d0                	add    %edx,%eax
   151d2:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   151d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151d8:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   151db:	8b 55 e8             	mov    -0x18(%ebp),%edx
   151de:	8b 45 ec             	mov    -0x14(%ebp),%eax
   151e1:	01 d0                	add    %edx,%eax
   151e3:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   151e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   151ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   151ef:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   151f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151f8:	01 d0                	add    %edx,%eax
   151fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   151fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15200:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15206:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15209:	01 d0                	add    %edx,%eax
   1520b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   1520e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15211:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15214:	01 d0                	add    %edx,%eax
   15216:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   15219:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1521c:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   1521f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15222:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15225:	01 d0                	add    %edx,%eax
   15227:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   1522a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1522d:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   15230:	8b 55 d0             	mov    -0x30(%ebp),%edx
   15233:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15236:	01 d0                	add    %edx,%eax
   15238:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   1523b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1523e:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   15241:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15244:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15247:	01 d0                	add    %edx,%eax
   15249:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   1524c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1524f:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15252:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15255:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15258:	01 d0                	add    %edx,%eax
   1525a:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15260:	83 e8 80             	sub    $0xffffff80,%eax
   15263:	c1 f8 08             	sar    $0x8,%eax
   15266:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15269:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1526c:	2b 45 e0             	sub    -0x20(%ebp),%eax
   1526f:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15275:	83 e8 80             	sub    $0xffffff80,%eax
   15278:	c1 f8 08             	sar    $0x8,%eax
   1527b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   1527e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15281:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15284:	01 d0                	add    %edx,%eax
   15286:	c1 f8 08             	sar    $0x8,%eax
   15289:	89 c2                	mov    %eax,%edx
   1528b:	8b 45 08             	mov    0x8(%ebp),%eax
   1528e:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   15290:	8b 45 08             	mov    0x8(%ebp),%eax
   15293:	83 c0 04             	add    $0x4,%eax
   15296:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   15299:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1529c:	01 ca                	add    %ecx,%edx
   1529e:	c1 fa 08             	sar    $0x8,%edx
   152a1:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   152a3:	8b 45 08             	mov    0x8(%ebp),%eax
   152a6:	83 c0 08             	add    $0x8,%eax
   152a9:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   152ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   152af:	01 ca                	add    %ecx,%edx
   152b1:	c1 fa 08             	sar    $0x8,%edx
   152b4:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   152b6:	8b 45 08             	mov    0x8(%ebp),%eax
   152b9:	83 c0 0c             	add    $0xc,%eax
   152bc:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   152bf:	8b 55 dc             	mov    -0x24(%ebp),%edx
   152c2:	01 ca                	add    %ecx,%edx
   152c4:	c1 fa 08             	sar    $0x8,%edx
   152c7:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   152c9:	8b 45 08             	mov    0x8(%ebp),%eax
   152cc:	8d 50 10             	lea    0x10(%eax),%edx
   152cf:	8b 45 d0             	mov    -0x30(%ebp),%eax
   152d2:	2b 45 dc             	sub    -0x24(%ebp),%eax
   152d5:	c1 f8 08             	sar    $0x8,%eax
   152d8:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   152da:	8b 45 08             	mov    0x8(%ebp),%eax
   152dd:	8d 50 14             	lea    0x14(%eax),%edx
   152e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   152e3:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   152e6:	c1 f8 08             	sar    $0x8,%eax
   152e9:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   152eb:	8b 45 08             	mov    0x8(%ebp),%eax
   152ee:	8d 50 18             	lea    0x18(%eax),%edx
   152f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152f4:	2b 45 ec             	sub    -0x14(%ebp),%eax
   152f7:	c1 f8 08             	sar    $0x8,%eax
   152fa:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   152fc:	8b 45 08             	mov    0x8(%ebp),%eax
   152ff:	8d 50 1c             	lea    0x1c(%eax),%edx
   15302:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15305:	2b 45 f0             	sub    -0x10(%ebp),%eax
   15308:	c1 f8 08             	sar    $0x8,%eax
   1530b:	89 02                	mov    %eax,(%edx)
}
   1530d:	83 c4 38             	add    $0x38,%esp
   15310:	5b                   	pop    %ebx
   15311:	5e                   	pop    %esi
   15312:	5f                   	pop    %edi
   15313:	5d                   	pop    %ebp
   15314:	c3                   	ret    

00015315 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   15315:	55                   	push   %ebp
   15316:	89 e5                	mov    %esp,%ebp
   15318:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1531b:	8b 45 08             	mov    0x8(%ebp),%eax
   1531e:	83 e8 80             	sub    $0xffffff80,%eax
   15321:	8b 00                	mov    (%eax),%eax
   15323:	c1 e0 08             	shl    $0x8,%eax
   15326:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   15329:	8b 45 08             	mov    0x8(%ebp),%eax
   1532c:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15332:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15335:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15338:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   1533b:	8b 55 08             	mov    0x8(%ebp),%edx
   1533e:	8b 52 40             	mov    0x40(%edx),%edx
   15341:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15344:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15347:	8b 55 08             	mov    0x8(%ebp),%edx
   1534a:	8b 52 20             	mov    0x20(%edx),%edx
   1534d:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15350:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15353:	8b 55 08             	mov    0x8(%ebp),%edx
   15356:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   1535c:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1535f:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   15362:	8b 55 08             	mov    0x8(%ebp),%edx
   15365:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   1536b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1536e:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   15371:	8b 55 08             	mov    0x8(%ebp),%edx
   15374:	8b 52 60             	mov    0x60(%edx),%edx
   15377:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1537a:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1537d:	85 c0                	test   %eax,%eax
   1537f:	75 45                	jne    153c6 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   15381:	8b 45 08             	mov    0x8(%ebp),%eax
   15384:	8b 00                	mov    (%eax),%eax
   15386:	83 c0 20             	add    $0x20,%eax
   15389:	c1 f8 06             	sar    $0x6,%eax
   1538c:	83 e8 80             	sub    $0xffffff80,%eax
   1538f:	50                   	push   %eax
   15390:	e8 d6 ea ff ff       	call   13e6b <_Clip>
   15395:	83 c4 04             	add    $0x4,%esp
   15398:	0f b6 c0             	movzbl %al,%eax
   1539b:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   1539e:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   153a5:	eb 14                	jmp    153bb <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   153a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   153aa:	89 c2                	mov    %eax,%edx
   153ac:	8b 45 0c             	mov    0xc(%ebp),%eax
   153af:	88 10                	mov    %dl,(%eax)
            out += stride;
   153b1:	8b 45 10             	mov    0x10(%ebp),%eax
   153b4:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   153b7:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   153bb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   153bf:	75 e6                	jne    153a7 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   153c1:	e9 57 02 00 00       	jmp    1561d <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   153c6:	8b 45 08             	mov    0x8(%ebp),%eax
   153c9:	8b 00                	mov    (%eax),%eax
   153cb:	c1 e0 08             	shl    $0x8,%eax
   153ce:	05 00 20 00 00       	add    $0x2000,%eax
   153d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   153d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   153d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   153dc:	01 d0                	add    %edx,%eax
   153de:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   153e4:	83 c0 04             	add    $0x4,%eax
   153e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   153ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
   153ed:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   153f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   153f6:	01 d0                	add    %edx,%eax
   153f8:	c1 f8 03             	sar    $0x3,%eax
   153fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   153fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15401:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15407:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1540a:	01 d0                	add    %edx,%eax
   1540c:	c1 f8 03             	sar    $0x3,%eax
   1540f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   15412:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15415:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15418:	01 d0                	add    %edx,%eax
   1541a:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15420:	83 c0 04             	add    $0x4,%eax
   15423:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15426:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15429:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1542f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15432:	01 d0                	add    %edx,%eax
   15434:	c1 f8 03             	sar    $0x3,%eax
   15437:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   1543a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1543d:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15443:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15446:	01 d0                	add    %edx,%eax
   15448:	c1 f8 03             	sar    $0x3,%eax
   1544b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1544e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15451:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15454:	01 d0                	add    %edx,%eax
   15456:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15459:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1545c:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1545f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15462:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15465:	01 d0                	add    %edx,%eax
   15467:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1546d:	83 c0 04             	add    $0x4,%eax
   15470:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   15473:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15476:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1547c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1547f:	01 d0                	add    %edx,%eax
   15481:	c1 f8 03             	sar    $0x3,%eax
   15484:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   15487:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1548a:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15490:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15493:	01 d0                	add    %edx,%eax
   15495:	c1 f8 03             	sar    $0x3,%eax
   15498:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   1549b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1549e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   154a1:	01 d0                	add    %edx,%eax
   154a3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   154a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   154a9:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   154ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
   154af:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154b2:	01 d0                	add    %edx,%eax
   154b4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   154b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154ba:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   154bd:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154c3:	01 d0                	add    %edx,%eax
   154c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   154c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154cb:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   154ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
   154d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   154d4:	01 d0                	add    %edx,%eax
   154d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   154d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   154dc:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   154df:	8b 55 ec             	mov    -0x14(%ebp),%edx
   154e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   154e5:	01 d0                	add    %edx,%eax
   154e7:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   154ed:	83 e8 80             	sub    $0xffffff80,%eax
   154f0:	c1 f8 08             	sar    $0x8,%eax
   154f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   154f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154f9:	2b 45 e8             	sub    -0x18(%ebp),%eax
   154fc:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15502:	83 e8 80             	sub    $0xffffff80,%eax
   15505:	c1 f8 08             	sar    $0x8,%eax
   15508:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   1550b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1550e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15511:	01 d0                	add    %edx,%eax
   15513:	c1 f8 0e             	sar    $0xe,%eax
   15516:	83 e8 80             	sub    $0xffffff80,%eax
   15519:	50                   	push   %eax
   1551a:	e8 4c e9 ff ff       	call   13e6b <_Clip>
   1551f:	83 c4 04             	add    $0x4,%esp
   15522:	89 c2                	mov    %eax,%edx
   15524:	8b 45 0c             	mov    0xc(%ebp),%eax
   15527:	88 10                	mov    %dl,(%eax)
   15529:	8b 45 10             	mov    0x10(%ebp),%eax
   1552c:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   1552f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15532:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15535:	01 d0                	add    %edx,%eax
   15537:	c1 f8 0e             	sar    $0xe,%eax
   1553a:	83 e8 80             	sub    $0xffffff80,%eax
   1553d:	50                   	push   %eax
   1553e:	e8 28 e9 ff ff       	call   13e6b <_Clip>
   15543:	83 c4 04             	add    $0x4,%esp
   15546:	89 c2                	mov    %eax,%edx
   15548:	8b 45 0c             	mov    0xc(%ebp),%eax
   1554b:	88 10                	mov    %dl,(%eax)
   1554d:	8b 45 10             	mov    0x10(%ebp),%eax
   15550:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15553:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15556:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15559:	01 d0                	add    %edx,%eax
   1555b:	c1 f8 0e             	sar    $0xe,%eax
   1555e:	83 e8 80             	sub    $0xffffff80,%eax
   15561:	50                   	push   %eax
   15562:	e8 04 e9 ff ff       	call   13e6b <_Clip>
   15567:	83 c4 04             	add    $0x4,%esp
   1556a:	89 c2                	mov    %eax,%edx
   1556c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1556f:	88 10                	mov    %dl,(%eax)
   15571:	8b 45 10             	mov    0x10(%ebp),%eax
   15574:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15577:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1557a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1557d:	01 d0                	add    %edx,%eax
   1557f:	c1 f8 0e             	sar    $0xe,%eax
   15582:	83 e8 80             	sub    $0xffffff80,%eax
   15585:	50                   	push   %eax
   15586:	e8 e0 e8 ff ff       	call   13e6b <_Clip>
   1558b:	83 c4 04             	add    $0x4,%esp
   1558e:	89 c2                	mov    %eax,%edx
   15590:	8b 45 0c             	mov    0xc(%ebp),%eax
   15593:	88 10                	mov    %dl,(%eax)
   15595:	8b 45 10             	mov    0x10(%ebp),%eax
   15598:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   1559b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1559e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   155a1:	c1 f8 0e             	sar    $0xe,%eax
   155a4:	83 e8 80             	sub    $0xffffff80,%eax
   155a7:	50                   	push   %eax
   155a8:	e8 be e8 ff ff       	call   13e6b <_Clip>
   155ad:	83 c4 04             	add    $0x4,%esp
   155b0:	89 c2                	mov    %eax,%edx
   155b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   155b5:	88 10                	mov    %dl,(%eax)
   155b7:	8b 45 10             	mov    0x10(%ebp),%eax
   155ba:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   155bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   155c0:	2b 45 ec             	sub    -0x14(%ebp),%eax
   155c3:	c1 f8 0e             	sar    $0xe,%eax
   155c6:	83 e8 80             	sub    $0xffffff80,%eax
   155c9:	50                   	push   %eax
   155ca:	e8 9c e8 ff ff       	call   13e6b <_Clip>
   155cf:	83 c4 04             	add    $0x4,%esp
   155d2:	89 c2                	mov    %eax,%edx
   155d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   155d7:	88 10                	mov    %dl,(%eax)
   155d9:	8b 45 10             	mov    0x10(%ebp),%eax
   155dc:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   155df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155e2:	2b 45 f4             	sub    -0xc(%ebp),%eax
   155e5:	c1 f8 0e             	sar    $0xe,%eax
   155e8:	83 e8 80             	sub    $0xffffff80,%eax
   155eb:	50                   	push   %eax
   155ec:	e8 7a e8 ff ff       	call   13e6b <_Clip>
   155f1:	83 c4 04             	add    $0x4,%esp
   155f4:	89 c2                	mov    %eax,%edx
   155f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   155f9:	88 10                	mov    %dl,(%eax)
   155fb:	8b 45 10             	mov    0x10(%ebp),%eax
   155fe:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   15601:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15604:	2b 45 f8             	sub    -0x8(%ebp),%eax
   15607:	c1 f8 0e             	sar    $0xe,%eax
   1560a:	83 e8 80             	sub    $0xffffff80,%eax
   1560d:	50                   	push   %eax
   1560e:	e8 58 e8 ff ff       	call   13e6b <_Clip>
   15613:	83 c4 04             	add    $0x4,%esp
   15616:	89 c2                	mov    %eax,%edx
   15618:	8b 45 0c             	mov    0xc(%ebp),%eax
   1561b:	88 10                	mov    %dl,(%eax)
}
   1561d:	c9                   	leave  
   1561e:	c3                   	ret    

0001561f <_ByteAlign>:

void _ByteAlign(Context* ctx){
   1561f:	55                   	push   %ebp
   15620:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15622:	8b 45 08             	mov    0x8(%ebp),%eax
   15625:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1562b:	25 f8 00 00 00       	and    $0xf8,%eax
   15630:	89 c2                	mov    %eax,%edx
   15632:	8b 45 08             	mov    0x8(%ebp),%eax
   15635:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1563b:	90                   	nop
   1563c:	5d                   	pop    %ebp
   1563d:	c3                   	ret    

0001563e <_SkipMarker>:

void _SkipMarker(Context* ctx){
   1563e:	55                   	push   %ebp
   1563f:	89 e5                	mov    %esp,%ebp
   15641:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15644:	83 ec 0c             	sub    $0xc,%esp
   15647:	ff 75 08             	pushl  0x8(%ebp)
   1564a:	e8 8d e8 ff ff       	call   13edc <_DecodeLength>
   1564f:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   15652:	8b 45 08             	mov    0x8(%ebp),%eax
   15655:	8b 40 0c             	mov    0xc(%eax),%eax
   15658:	83 ec 08             	sub    $0x8,%esp
   1565b:	50                   	push   %eax
   1565c:	ff 75 08             	pushl  0x8(%ebp)
   1565f:	e8 2c e8 ff ff       	call   13e90 <_Skip>
   15664:	83 c4 10             	add    $0x10,%esp
}
   15667:	90                   	nop
   15668:	c9                   	leave  
   15669:	c3                   	ret    

0001566a <_Convert>:

void _Convert(Context* ctx){
   1566a:	55                   	push   %ebp
   1566b:	89 e5                	mov    %esp,%ebp
   1566d:	57                   	push   %edi
   1566e:	56                   	push   %esi
   1566f:	53                   	push   %ebx
   15670:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15673:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1567a:	8b 45 08             	mov    0x8(%ebp),%eax
   1567d:	83 c0 2c             	add    $0x2c,%eax
   15680:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15683:	e9 b2 00 00 00       	jmp    1573a <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15688:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1568b:	8b 50 0c             	mov    0xc(%eax),%edx
   1568e:	8b 45 08             	mov    0x8(%ebp),%eax
   15691:	8b 40 10             	mov    0x10(%eax),%eax
   15694:	39 c2                	cmp    %eax,%edx
   15696:	7d 11                	jge    156a9 <_Convert+0x3f>
   15698:	83 ec 08             	sub    $0x8,%esp
   1569b:	ff 75 e0             	pushl  -0x20(%ebp)
   1569e:	ff 75 08             	pushl  0x8(%ebp)
   156a1:	e8 79 02 00 00       	call   1591f <_UpsampleH>
   156a6:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   156a9:	8b 45 08             	mov    0x8(%ebp),%eax
   156ac:	8b 00                	mov    (%eax),%eax
   156ae:	85 c0                	test   %eax,%eax
   156b0:	0f 85 5d 02 00 00    	jne    15913 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   156b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156b9:	8b 50 10             	mov    0x10(%eax),%edx
   156bc:	8b 45 08             	mov    0x8(%ebp),%eax
   156bf:	8b 40 14             	mov    0x14(%eax),%eax
   156c2:	39 c2                	cmp    %eax,%edx
   156c4:	7d 11                	jge    156d7 <_Convert+0x6d>
   156c6:	83 ec 08             	sub    $0x8,%esp
   156c9:	ff 75 e0             	pushl  -0x20(%ebp)
   156cc:	ff 75 08             	pushl  0x8(%ebp)
   156cf:	e8 db 05 00 00       	call   15caf <_UpsampleV>
   156d4:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   156d7:	8b 45 08             	mov    0x8(%ebp),%eax
   156da:	8b 00                	mov    (%eax),%eax
   156dc:	85 c0                	test   %eax,%eax
   156de:	0f 85 32 02 00 00    	jne    15916 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   156e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156e7:	8b 50 0c             	mov    0xc(%eax),%edx
   156ea:	8b 45 08             	mov    0x8(%ebp),%eax
   156ed:	8b 40 10             	mov    0x10(%eax),%eax
   156f0:	39 c2                	cmp    %eax,%edx
   156f2:	7c 94                	jl     15688 <_Convert+0x1e>
   156f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156f7:	8b 50 10             	mov    0x10(%eax),%edx
   156fa:	8b 45 08             	mov    0x8(%ebp),%eax
   156fd:	8b 40 14             	mov    0x14(%eax),%eax
   15700:	39 c2                	cmp    %eax,%edx
   15702:	7c 84                	jl     15688 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   15704:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15707:	8b 50 0c             	mov    0xc(%eax),%edx
   1570a:	8b 45 08             	mov    0x8(%ebp),%eax
   1570d:	8b 40 10             	mov    0x10(%eax),%eax
   15710:	39 c2                	cmp    %eax,%edx
   15712:	7c 10                	jl     15724 <_Convert+0xba>
   15714:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15717:	8b 50 10             	mov    0x10(%eax),%edx
   1571a:	8b 45 08             	mov    0x8(%ebp),%eax
   1571d:	8b 40 14             	mov    0x14(%eax),%eax
   15720:	39 c2                	cmp    %eax,%edx
   15722:	7d 0e                	jge    15732 <_Convert+0xc8>
   15724:	8b 45 08             	mov    0x8(%ebp),%eax
   15727:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   1572d:	e9 e5 01 00 00       	jmp    15917 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15732:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15736:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   1573a:	8b 45 08             	mov    0x8(%ebp),%eax
   1573d:	8b 40 28             	mov    0x28(%eax),%eax
   15740:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15743:	7f 9f                	jg     156e4 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15745:	8b 45 08             	mov    0x8(%ebp),%eax
   15748:	8b 40 28             	mov    0x28(%eax),%eax
   1574b:	83 f8 03             	cmp    $0x3,%eax
   1574e:	0f 85 3d 01 00 00    	jne    15891 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15754:	8b 45 08             	mov    0x8(%ebp),%eax
   15757:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1575d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   15760:	8b 45 08             	mov    0x8(%ebp),%eax
   15763:	8b 40 54             	mov    0x54(%eax),%eax
   15766:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15769:	8b 45 08             	mov    0x8(%ebp),%eax
   1576c:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   15772:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   15775:	8b 45 08             	mov    0x8(%ebp),%eax
   15778:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1577e:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   15781:	8b 45 08             	mov    0x8(%ebp),%eax
   15784:	8b 40 14             	mov    0x14(%eax),%eax
   15787:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1578a:	e9 f3 00 00 00       	jmp    15882 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   1578f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   15796:	e9 b6 00 00 00       	jmp    15851 <_Convert+0x1e7>
                register int y = py[x] << 8;
   1579b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1579e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   157a1:	01 d0                	add    %edx,%eax
   157a3:	0f b6 00             	movzbl (%eax),%eax
   157a6:	0f b6 c0             	movzbl %al,%eax
   157a9:	c1 e0 08             	shl    $0x8,%eax
   157ac:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   157ae:	8b 55 dc             	mov    -0x24(%ebp),%edx
   157b1:	8b 45 cc             	mov    -0x34(%ebp),%eax
   157b4:	01 d0                	add    %edx,%eax
   157b6:	0f b6 00             	movzbl (%eax),%eax
   157b9:	0f b6 c0             	movzbl %al,%eax
   157bc:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   157bf:	8b 55 dc             	mov    -0x24(%ebp),%edx
   157c2:	8b 45 c8             	mov    -0x38(%ebp),%eax
   157c5:	01 d0                	add    %edx,%eax
   157c7:	0f b6 00             	movzbl (%eax),%eax
   157ca:	0f b6 c0             	movzbl %al,%eax
   157cd:	83 c0 80             	add    $0xffffff80,%eax
   157d0:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   157d2:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   157d5:	8d 46 01             	lea    0x1(%esi),%eax
   157d8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   157db:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   157de:	89 c8                	mov    %ecx,%eax
   157e0:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   157e6:	01 d8                	add    %ebx,%eax
   157e8:	83 e8 80             	sub    $0xffffff80,%eax
   157eb:	c1 f8 08             	sar    $0x8,%eax
   157ee:	83 ec 0c             	sub    $0xc,%esp
   157f1:	50                   	push   %eax
   157f2:	e8 74 e6 ff ff       	call   13e6b <_Clip>
   157f7:	83 c4 10             	add    $0x10,%esp
   157fa:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   157fc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   157ff:	8d 46 01             	lea    0x1(%esi),%eax
   15802:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15805:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   15808:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   1580b:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   15812:	01 d0                	add    %edx,%eax
   15814:	83 e8 80             	sub    $0xffffff80,%eax
   15817:	c1 f8 08             	sar    $0x8,%eax
   1581a:	83 ec 0c             	sub    $0xc,%esp
   1581d:	50                   	push   %eax
   1581e:	e8 48 e6 ff ff       	call   13e6b <_Clip>
   15823:	83 c4 10             	add    $0x10,%esp
   15826:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15828:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1582b:	8d 46 01             	lea    0x1(%esi),%eax
   1582e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15831:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15837:	01 d8                	add    %ebx,%eax
   15839:	83 e8 80             	sub    $0xffffff80,%eax
   1583c:	c1 f8 08             	sar    $0x8,%eax
   1583f:	83 ec 0c             	sub    $0xc,%esp
   15842:	50                   	push   %eax
   15843:	e8 23 e6 ff ff       	call   13e6b <_Clip>
   15848:	83 c4 10             	add    $0x10,%esp
   1584b:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   1584d:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   15851:	8b 45 08             	mov    0x8(%ebp),%eax
   15854:	8b 40 10             	mov    0x10(%eax),%eax
   15857:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   1585a:	0f 8f 3b ff ff ff    	jg     1579b <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   15860:	8b 45 08             	mov    0x8(%ebp),%eax
   15863:	8b 40 40             	mov    0x40(%eax),%eax
   15866:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15869:	8b 45 08             	mov    0x8(%ebp),%eax
   1586c:	8b 40 6c             	mov    0x6c(%eax),%eax
   1586f:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   15872:	8b 45 08             	mov    0x8(%ebp),%eax
   15875:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1587b:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   1587e:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   15882:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15886:	0f 85 03 ff ff ff    	jne    1578f <_Convert+0x125>
   1588c:	e9 86 00 00 00       	jmp    15917 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   15891:	8b 45 08             	mov    0x8(%ebp),%eax
   15894:	8b 50 38             	mov    0x38(%eax),%edx
   15897:	8b 45 08             	mov    0x8(%ebp),%eax
   1589a:	8b 40 40             	mov    0x40(%eax),%eax
   1589d:	39 c2                	cmp    %eax,%edx
   1589f:	74 76                	je     15917 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   158a1:	8b 45 08             	mov    0x8(%ebp),%eax
   158a4:	8b 50 54             	mov    0x54(%eax),%edx
   158a7:	8b 45 08             	mov    0x8(%ebp),%eax
   158aa:	8b 40 40             	mov    0x40(%eax),%eax
   158ad:	01 d0                	add    %edx,%eax
   158af:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   158b2:	8b 45 08             	mov    0x8(%ebp),%eax
   158b5:	8b 50 54             	mov    0x54(%eax),%edx
   158b8:	8b 45 08             	mov    0x8(%ebp),%eax
   158bb:	8b 40 38             	mov    0x38(%eax),%eax
   158be:	01 d0                	add    %edx,%eax
   158c0:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   158c3:	8b 45 08             	mov    0x8(%ebp),%eax
   158c6:	8b 40 3c             	mov    0x3c(%eax),%eax
   158c9:	83 e8 01             	sub    $0x1,%eax
   158cc:	89 45 bc             	mov    %eax,-0x44(%ebp)
   158cf:	eb 2e                	jmp    158ff <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   158d1:	8b 45 08             	mov    0x8(%ebp),%eax
   158d4:	8b 40 38             	mov    0x38(%eax),%eax
   158d7:	83 ec 04             	sub    $0x4,%esp
   158da:	50                   	push   %eax
   158db:	ff 75 c4             	pushl  -0x3c(%ebp)
   158de:	ff 75 c0             	pushl  -0x40(%ebp)
   158e1:	e8 72 ac fe ff       	call   558 <memmove>
   158e6:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   158e9:	8b 45 08             	mov    0x8(%ebp),%eax
   158ec:	8b 40 40             	mov    0x40(%eax),%eax
   158ef:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   158f2:	8b 45 08             	mov    0x8(%ebp),%eax
   158f5:	8b 40 38             	mov    0x38(%eax),%eax
   158f8:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   158fb:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   158ff:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   15903:	75 cc                	jne    158d1 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   15905:	8b 45 08             	mov    0x8(%ebp),%eax
   15908:	8b 50 38             	mov    0x38(%eax),%edx
   1590b:	8b 45 08             	mov    0x8(%ebp),%eax
   1590e:	89 50 40             	mov    %edx,0x40(%eax)
   15911:	eb 04                	jmp    15917 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   15913:	90                   	nop
   15914:	eb 01                	jmp    15917 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15916:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15917:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1591a:	5b                   	pop    %ebx
   1591b:	5e                   	pop    %esi
   1591c:	5f                   	pop    %edi
   1591d:	5d                   	pop    %ebp
   1591e:	c3                   	ret    

0001591f <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   1591f:	55                   	push   %ebp
   15920:	89 e5                	mov    %esp,%ebp
   15922:	53                   	push   %ebx
   15923:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15926:	8b 45 0c             	mov    0xc(%ebp),%eax
   15929:	8b 40 0c             	mov    0xc(%eax),%eax
   1592c:	83 e8 03             	sub    $0x3,%eax
   1592f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15932:	8b 45 0c             	mov    0xc(%ebp),%eax
   15935:	8b 50 0c             	mov    0xc(%eax),%edx
   15938:	8b 45 0c             	mov    0xc(%ebp),%eax
   1593b:	8b 40 10             	mov    0x10(%eax),%eax
   1593e:	0f af c2             	imul   %edx,%eax
   15941:	01 c0                	add    %eax,%eax
   15943:	83 ec 0c             	sub    $0xc,%esp
   15946:	50                   	push   %eax
   15947:	e8 cb b0 fe ff       	call   a17 <malloc>
   1594c:	83 c4 10             	add    $0x10,%esp
   1594f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15952:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15956:	75 0e                	jne    15966 <_UpsampleH+0x47>
   15958:	8b 45 08             	mov    0x8(%ebp),%eax
   1595b:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15961:	e9 44 03 00 00       	jmp    15caa <_UpsampleH+0x38b>
    lin = c->pixels;
   15966:	8b 45 0c             	mov    0xc(%ebp),%eax
   15969:	8b 40 28             	mov    0x28(%eax),%eax
   1596c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   1596f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15972:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   15975:	8b 45 0c             	mov    0xc(%ebp),%eax
   15978:	8b 40 10             	mov    0x10(%eax),%eax
   1597b:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   1597e:	e9 e0 02 00 00       	jmp    15c63 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   15983:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15986:	0f b6 00             	movzbl (%eax),%eax
   15989:	0f b6 c0             	movzbl %al,%eax
   1598c:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15992:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15995:	83 c0 01             	add    $0x1,%eax
   15998:	0f b6 00             	movzbl (%eax),%eax
   1599b:	0f b6 c0             	movzbl %al,%eax
   1599e:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   159a1:	01 d0                	add    %edx,%eax
   159a3:	83 ec 0c             	sub    $0xc,%esp
   159a6:	50                   	push   %eax
   159a7:	e8 c4 06 00 00       	call   16070 <CF>
   159ac:	83 c4 10             	add    $0x10,%esp
   159af:	89 c2                	mov    %eax,%edx
   159b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159b4:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   159b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159b9:	8d 58 01             	lea    0x1(%eax),%ebx
   159bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159bf:	0f b6 00             	movzbl (%eax),%eax
   159c2:	0f b6 c0             	movzbl %al,%eax
   159c5:	6b c8 68             	imul   $0x68,%eax,%ecx
   159c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159cb:	83 c0 01             	add    $0x1,%eax
   159ce:	0f b6 00             	movzbl (%eax),%eax
   159d1:	0f b6 d0             	movzbl %al,%edx
   159d4:	89 d0                	mov    %edx,%eax
   159d6:	01 c0                	add    %eax,%eax
   159d8:	01 d0                	add    %edx,%eax
   159da:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   159e1:	01 d0                	add    %edx,%eax
   159e3:	01 c1                	add    %eax,%ecx
   159e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159e8:	83 c0 02             	add    $0x2,%eax
   159eb:	0f b6 00             	movzbl (%eax),%eax
   159ee:	0f b6 d0             	movzbl %al,%edx
   159f1:	89 d0                	mov    %edx,%eax
   159f3:	01 c0                	add    %eax,%eax
   159f5:	01 d0                	add    %edx,%eax
   159f7:	f7 d8                	neg    %eax
   159f9:	01 c8                	add    %ecx,%eax
   159fb:	83 ec 0c             	sub    $0xc,%esp
   159fe:	50                   	push   %eax
   159ff:	e8 6c 06 00 00       	call   16070 <CF>
   15a04:	83 c4 10             	add    $0x10,%esp
   15a07:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15a09:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a0c:	8d 58 02             	lea    0x2(%eax),%ebx
   15a0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a12:	0f b6 00             	movzbl (%eax),%eax
   15a15:	0f b6 c0             	movzbl %al,%eax
   15a18:	c1 e0 02             	shl    $0x2,%eax
   15a1b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15a22:	29 c2                	sub    %eax,%edx
   15a24:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a27:	83 c0 01             	add    $0x1,%eax
   15a2a:	0f b6 00             	movzbl (%eax),%eax
   15a2d:	0f b6 c0             	movzbl %al,%eax
   15a30:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15a33:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15a36:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a39:	83 c0 02             	add    $0x2,%eax
   15a3c:	0f b6 00             	movzbl (%eax),%eax
   15a3f:	0f b6 d0             	movzbl %al,%edx
   15a42:	89 d0                	mov    %edx,%eax
   15a44:	c1 e0 03             	shl    $0x3,%eax
   15a47:	01 d0                	add    %edx,%eax
   15a49:	f7 d8                	neg    %eax
   15a4b:	01 c8                	add    %ecx,%eax
   15a4d:	83 ec 0c             	sub    $0xc,%esp
   15a50:	50                   	push   %eax
   15a51:	e8 1a 06 00 00       	call   16070 <CF>
   15a56:	83 c4 10             	add    $0x10,%esp
   15a59:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15a5b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15a62:	e9 fa 00 00 00       	jmp    15b61 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15a67:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a6a:	01 c0                	add    %eax,%eax
   15a6c:	8d 50 03             	lea    0x3(%eax),%edx
   15a6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a72:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15a75:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a78:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a7b:	01 d0                	add    %edx,%eax
   15a7d:	0f b6 00             	movzbl (%eax),%eax
   15a80:	0f b6 d0             	movzbl %al,%edx
   15a83:	89 d0                	mov    %edx,%eax
   15a85:	c1 e0 03             	shl    $0x3,%eax
   15a88:	01 d0                	add    %edx,%eax
   15a8a:	f7 d8                	neg    %eax
   15a8c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a8f:	8d 4a 01             	lea    0x1(%edx),%ecx
   15a92:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15a95:	01 ca                	add    %ecx,%edx
   15a97:	0f b6 12             	movzbl (%edx),%edx
   15a9a:	0f b6 d2             	movzbl %dl,%edx
   15a9d:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15aa0:	01 c2                	add    %eax,%edx
   15aa2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15aa5:	8d 48 02             	lea    0x2(%eax),%ecx
   15aa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aab:	01 c8                	add    %ecx,%eax
   15aad:	0f b6 00             	movzbl (%eax),%eax
   15ab0:	0f b6 c0             	movzbl %al,%eax
   15ab3:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15ab6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15ab9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15abc:	8d 50 03             	lea    0x3(%eax),%edx
   15abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ac2:	01 d0                	add    %edx,%eax
   15ac4:	0f b6 00             	movzbl (%eax),%eax
   15ac7:	0f b6 d0             	movzbl %al,%edx
   15aca:	89 d0                	mov    %edx,%eax
   15acc:	01 c0                	add    %eax,%eax
   15ace:	01 d0                	add    %edx,%eax
   15ad0:	f7 d8                	neg    %eax
   15ad2:	01 c8                	add    %ecx,%eax
   15ad4:	83 ec 0c             	sub    $0xc,%esp
   15ad7:	50                   	push   %eax
   15ad8:	e8 93 05 00 00       	call   16070 <CF>
   15add:	83 c4 10             	add    $0x10,%esp
   15ae0:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   15ae2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15ae5:	01 c0                	add    %eax,%eax
   15ae7:	8d 50 04             	lea    0x4(%eax),%edx
   15aea:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15aed:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15af0:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15af3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15af6:	01 d0                	add    %edx,%eax
   15af8:	0f b6 00             	movzbl (%eax),%eax
   15afb:	0f b6 d0             	movzbl %al,%edx
   15afe:	89 d0                	mov    %edx,%eax
   15b00:	01 c0                	add    %eax,%eax
   15b02:	01 d0                	add    %edx,%eax
   15b04:	f7 d8                	neg    %eax
   15b06:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15b09:	8d 4a 01             	lea    0x1(%edx),%ecx
   15b0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b0f:	01 ca                	add    %ecx,%edx
   15b11:	0f b6 12             	movzbl (%edx),%edx
   15b14:	0f b6 d2             	movzbl %dl,%edx
   15b17:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15b1a:	01 c2                	add    %eax,%edx
   15b1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b1f:	8d 48 02             	lea    0x2(%eax),%ecx
   15b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b25:	01 c8                	add    %ecx,%eax
   15b27:	0f b6 00             	movzbl (%eax),%eax
   15b2a:	0f b6 c0             	movzbl %al,%eax
   15b2d:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15b30:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15b33:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b36:	8d 50 03             	lea    0x3(%eax),%edx
   15b39:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b3c:	01 d0                	add    %edx,%eax
   15b3e:	0f b6 00             	movzbl (%eax),%eax
   15b41:	0f b6 d0             	movzbl %al,%edx
   15b44:	89 d0                	mov    %edx,%eax
   15b46:	c1 e0 03             	shl    $0x3,%eax
   15b49:	01 d0                	add    %edx,%eax
   15b4b:	f7 d8                	neg    %eax
   15b4d:	01 c8                	add    %ecx,%eax
   15b4f:	83 ec 0c             	sub    $0xc,%esp
   15b52:	50                   	push   %eax
   15b53:	e8 18 05 00 00       	call   16070 <CF>
   15b58:	83 c4 10             	add    $0x10,%esp
   15b5b:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15b5d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15b61:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b64:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15b67:	0f 8c fa fe ff ff    	jl     15a67 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15b6d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b70:	8b 40 14             	mov    0x14(%eax),%eax
   15b73:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   15b76:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b79:	8b 40 0c             	mov    0xc(%eax),%eax
   15b7c:	01 c0                	add    %eax,%eax
   15b7e:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   15b81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b84:	8d 58 fd             	lea    -0x3(%eax),%ebx
   15b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b8a:	83 e8 01             	sub    $0x1,%eax
   15b8d:	0f b6 00             	movzbl (%eax),%eax
   15b90:	0f b6 c0             	movzbl %al,%eax
   15b93:	c1 e0 02             	shl    $0x2,%eax
   15b96:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b9d:	29 c2                	sub    %eax,%edx
   15b9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ba2:	83 e8 02             	sub    $0x2,%eax
   15ba5:	0f b6 00             	movzbl (%eax),%eax
   15ba8:	0f b6 c0             	movzbl %al,%eax
   15bab:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15bae:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15bb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bb4:	83 e8 03             	sub    $0x3,%eax
   15bb7:	0f b6 00             	movzbl (%eax),%eax
   15bba:	0f b6 d0             	movzbl %al,%edx
   15bbd:	89 d0                	mov    %edx,%eax
   15bbf:	c1 e0 03             	shl    $0x3,%eax
   15bc2:	01 d0                	add    %edx,%eax
   15bc4:	f7 d8                	neg    %eax
   15bc6:	01 c8                	add    %ecx,%eax
   15bc8:	83 ec 0c             	sub    $0xc,%esp
   15bcb:	50                   	push   %eax
   15bcc:	e8 9f 04 00 00       	call   16070 <CF>
   15bd1:	83 c4 10             	add    $0x10,%esp
   15bd4:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15bd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bd9:	8d 58 fe             	lea    -0x2(%eax),%ebx
   15bdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bdf:	83 e8 01             	sub    $0x1,%eax
   15be2:	0f b6 00             	movzbl (%eax),%eax
   15be5:	0f b6 c0             	movzbl %al,%eax
   15be8:	6b c8 68             	imul   $0x68,%eax,%ecx
   15beb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bee:	83 e8 02             	sub    $0x2,%eax
   15bf1:	0f b6 00             	movzbl (%eax),%eax
   15bf4:	0f b6 d0             	movzbl %al,%edx
   15bf7:	89 d0                	mov    %edx,%eax
   15bf9:	01 c0                	add    %eax,%eax
   15bfb:	01 d0                	add    %edx,%eax
   15bfd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c04:	01 d0                	add    %edx,%eax
   15c06:	01 c1                	add    %eax,%ecx
   15c08:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c0b:	83 e8 03             	sub    $0x3,%eax
   15c0e:	0f b6 00             	movzbl (%eax),%eax
   15c11:	0f b6 d0             	movzbl %al,%edx
   15c14:	89 d0                	mov    %edx,%eax
   15c16:	01 c0                	add    %eax,%eax
   15c18:	01 d0                	add    %edx,%eax
   15c1a:	f7 d8                	neg    %eax
   15c1c:	01 c8                	add    %ecx,%eax
   15c1e:	83 ec 0c             	sub    $0xc,%esp
   15c21:	50                   	push   %eax
   15c22:	e8 49 04 00 00       	call   16070 <CF>
   15c27:	83 c4 10             	add    $0x10,%esp
   15c2a:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15c2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c2f:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15c32:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c35:	83 e8 01             	sub    $0x1,%eax
   15c38:	0f b6 00             	movzbl (%eax),%eax
   15c3b:	0f b6 c0             	movzbl %al,%eax
   15c3e:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15c44:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c47:	83 e8 02             	sub    $0x2,%eax
   15c4a:	0f b6 00             	movzbl (%eax),%eax
   15c4d:	0f b6 c0             	movzbl %al,%eax
   15c50:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15c53:	01 d0                	add    %edx,%eax
   15c55:	83 ec 0c             	sub    $0xc,%esp
   15c58:	50                   	push   %eax
   15c59:	e8 12 04 00 00       	call   16070 <CF>
   15c5e:	83 c4 10             	add    $0x10,%esp
   15c61:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15c63:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c66:	8d 50 ff             	lea    -0x1(%eax),%edx
   15c69:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15c6c:	85 c0                	test   %eax,%eax
   15c6e:	0f 85 0f fd ff ff    	jne    15983 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15c74:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c77:	8b 40 0c             	mov    0xc(%eax),%eax
   15c7a:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15c7d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c80:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15c83:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c86:	8b 50 0c             	mov    0xc(%eax),%edx
   15c89:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c8c:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15c8f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c92:	8b 40 28             	mov    0x28(%eax),%eax
   15c95:	83 ec 0c             	sub    $0xc,%esp
   15c98:	50                   	push   %eax
   15c99:	e8 37 ac fe ff       	call   8d5 <free>
   15c9e:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15ca1:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ca4:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15ca7:	89 50 28             	mov    %edx,0x28(%eax)
}
   15caa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15cad:	c9                   	leave  
   15cae:	c3                   	ret    

00015caf <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15caf:	55                   	push   %ebp
   15cb0:	89 e5                	mov    %esp,%ebp
   15cb2:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   15cb5:	8b 45 0c             	mov    0xc(%ebp),%eax
   15cb8:	8b 40 0c             	mov    0xc(%eax),%eax
   15cbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15cbe:	8b 45 0c             	mov    0xc(%ebp),%eax
   15cc1:	8b 40 14             	mov    0x14(%eax),%eax
   15cc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15cc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cca:	01 c0                	add    %eax,%eax
   15ccc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15ccf:	8b 45 0c             	mov    0xc(%ebp),%eax
   15cd2:	8b 50 0c             	mov    0xc(%eax),%edx
   15cd5:	8b 45 0c             	mov    0xc(%ebp),%eax
   15cd8:	8b 40 10             	mov    0x10(%eax),%eax
   15cdb:	0f af c2             	imul   %edx,%eax
   15cde:	01 c0                	add    %eax,%eax
   15ce0:	83 ec 0c             	sub    $0xc,%esp
   15ce3:	50                   	push   %eax
   15ce4:	e8 2e ad fe ff       	call   a17 <malloc>
   15ce9:	83 c4 10             	add    $0x10,%esp
   15cec:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15cef:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15cf3:	75 0e                	jne    15d03 <_UpsampleV+0x54>
   15cf5:	8b 45 08             	mov    0x8(%ebp),%eax
   15cf8:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15cfe:	e9 6b 03 00 00       	jmp    1606e <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15d03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15d0a:	e9 1d 03 00 00       	jmp    1602c <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15d0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d12:	8b 50 28             	mov    0x28(%eax),%edx
   15d15:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d18:	01 d0                	add    %edx,%eax
   15d1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15d1d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15d20:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15d23:	01 d0                	add    %edx,%eax
   15d25:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15d28:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d2b:	0f b6 00             	movzbl (%eax),%eax
   15d2e:	0f b6 c0             	movzbl %al,%eax
   15d31:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15d37:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15d3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d3d:	01 c8                	add    %ecx,%eax
   15d3f:	0f b6 00             	movzbl (%eax),%eax
   15d42:	0f b6 c0             	movzbl %al,%eax
   15d45:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15d48:	01 d0                	add    %edx,%eax
   15d4a:	83 ec 0c             	sub    $0xc,%esp
   15d4d:	50                   	push   %eax
   15d4e:	e8 1d 03 00 00       	call   16070 <CF>
   15d53:	83 c4 10             	add    $0x10,%esp
   15d56:	89 c2                	mov    %eax,%edx
   15d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d5b:	88 10                	mov    %dl,(%eax)
   15d5d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d60:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15d63:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d66:	0f b6 00             	movzbl (%eax),%eax
   15d69:	0f b6 c0             	movzbl %al,%eax
   15d6c:	6b c8 68             	imul   $0x68,%eax,%ecx
   15d6f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d75:	01 d0                	add    %edx,%eax
   15d77:	0f b6 00             	movzbl (%eax),%eax
   15d7a:	0f b6 d0             	movzbl %al,%edx
   15d7d:	89 d0                	mov    %edx,%eax
   15d7f:	01 c0                	add    %eax,%eax
   15d81:	01 d0                	add    %edx,%eax
   15d83:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15d8a:	01 d0                	add    %edx,%eax
   15d8c:	01 c1                	add    %eax,%ecx
   15d8e:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15d91:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d94:	01 d0                	add    %edx,%eax
   15d96:	0f b6 00             	movzbl (%eax),%eax
   15d99:	0f b6 d0             	movzbl %al,%edx
   15d9c:	89 d0                	mov    %edx,%eax
   15d9e:	01 c0                	add    %eax,%eax
   15da0:	01 d0                	add    %edx,%eax
   15da2:	f7 d8                	neg    %eax
   15da4:	01 c8                	add    %ecx,%eax
   15da6:	83 ec 0c             	sub    $0xc,%esp
   15da9:	50                   	push   %eax
   15daa:	e8 c1 02 00 00       	call   16070 <CF>
   15daf:	83 c4 10             	add    $0x10,%esp
   15db2:	89 c2                	mov    %eax,%edx
   15db4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15db7:	88 10                	mov    %dl,(%eax)
   15db9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15dbc:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15dbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dc2:	0f b6 00             	movzbl (%eax),%eax
   15dc5:	0f b6 c0             	movzbl %al,%eax
   15dc8:	c1 e0 02             	shl    $0x2,%eax
   15dcb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15dd2:	89 d1                	mov    %edx,%ecx
   15dd4:	29 c1                	sub    %eax,%ecx
   15dd6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ddc:	01 d0                	add    %edx,%eax
   15dde:	0f b6 00             	movzbl (%eax),%eax
   15de1:	0f b6 c0             	movzbl %al,%eax
   15de4:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15de7:	01 c1                	add    %eax,%ecx
   15de9:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15dec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15def:	01 d0                	add    %edx,%eax
   15df1:	0f b6 00             	movzbl (%eax),%eax
   15df4:	0f b6 d0             	movzbl %al,%edx
   15df7:	89 d0                	mov    %edx,%eax
   15df9:	c1 e0 03             	shl    $0x3,%eax
   15dfc:	01 d0                	add    %edx,%eax
   15dfe:	f7 d8                	neg    %eax
   15e00:	01 c8                	add    %ecx,%eax
   15e02:	83 ec 0c             	sub    $0xc,%esp
   15e05:	50                   	push   %eax
   15e06:	e8 65 02 00 00       	call   16070 <CF>
   15e0b:	83 c4 10             	add    $0x10,%esp
   15e0e:	89 c2                	mov    %eax,%edx
   15e10:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e13:	88 10                	mov    %dl,(%eax)
   15e15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e18:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15e1b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e1e:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15e21:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e24:	8b 40 10             	mov    0x10(%eax),%eax
   15e27:	83 e8 03             	sub    $0x3,%eax
   15e2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15e2d:	e9 e6 00 00 00       	jmp    15f18 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15e32:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e35:	f7 d8                	neg    %eax
   15e37:	89 c2                	mov    %eax,%edx
   15e39:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e3c:	01 d0                	add    %edx,%eax
   15e3e:	0f b6 00             	movzbl (%eax),%eax
   15e41:	0f b6 d0             	movzbl %al,%edx
   15e44:	89 d0                	mov    %edx,%eax
   15e46:	c1 e0 03             	shl    $0x3,%eax
   15e49:	01 d0                	add    %edx,%eax
   15e4b:	f7 d8                	neg    %eax
   15e4d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15e50:	0f b6 12             	movzbl (%edx),%edx
   15e53:	0f b6 d2             	movzbl %dl,%edx
   15e56:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15e59:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15e5c:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15e5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e62:	01 d0                	add    %edx,%eax
   15e64:	0f b6 00             	movzbl (%eax),%eax
   15e67:	0f b6 c0             	movzbl %al,%eax
   15e6a:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15e6d:	01 c1                	add    %eax,%ecx
   15e6f:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15e72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e75:	01 d0                	add    %edx,%eax
   15e77:	0f b6 00             	movzbl (%eax),%eax
   15e7a:	0f b6 d0             	movzbl %al,%edx
   15e7d:	89 d0                	mov    %edx,%eax
   15e7f:	01 c0                	add    %eax,%eax
   15e81:	01 d0                	add    %edx,%eax
   15e83:	f7 d8                	neg    %eax
   15e85:	01 c8                	add    %ecx,%eax
   15e87:	83 ec 0c             	sub    $0xc,%esp
   15e8a:	50                   	push   %eax
   15e8b:	e8 e0 01 00 00       	call   16070 <CF>
   15e90:	83 c4 10             	add    $0x10,%esp
   15e93:	89 c2                	mov    %eax,%edx
   15e95:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e98:	88 10                	mov    %dl,(%eax)
   15e9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e9d:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15ea0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ea3:	f7 d8                	neg    %eax
   15ea5:	89 c2                	mov    %eax,%edx
   15ea7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15eaa:	01 d0                	add    %edx,%eax
   15eac:	0f b6 00             	movzbl (%eax),%eax
   15eaf:	0f b6 d0             	movzbl %al,%edx
   15eb2:	89 d0                	mov    %edx,%eax
   15eb4:	01 c0                	add    %eax,%eax
   15eb6:	01 d0                	add    %edx,%eax
   15eb8:	f7 d8                	neg    %eax
   15eba:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15ebd:	0f b6 12             	movzbl (%edx),%edx
   15ec0:	0f b6 d2             	movzbl %dl,%edx
   15ec3:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15ec6:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15ec9:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15ecc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ecf:	01 d0                	add    %edx,%eax
   15ed1:	0f b6 00             	movzbl (%eax),%eax
   15ed4:	0f b6 c0             	movzbl %al,%eax
   15ed7:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15eda:	01 c1                	add    %eax,%ecx
   15edc:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15edf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ee2:	01 d0                	add    %edx,%eax
   15ee4:	0f b6 00             	movzbl (%eax),%eax
   15ee7:	0f b6 d0             	movzbl %al,%edx
   15eea:	89 d0                	mov    %edx,%eax
   15eec:	c1 e0 03             	shl    $0x3,%eax
   15eef:	01 d0                	add    %edx,%eax
   15ef1:	f7 d8                	neg    %eax
   15ef3:	01 c8                	add    %ecx,%eax
   15ef5:	83 ec 0c             	sub    $0xc,%esp
   15ef8:	50                   	push   %eax
   15ef9:	e8 72 01 00 00       	call   16070 <CF>
   15efe:	83 c4 10             	add    $0x10,%esp
   15f01:	89 c2                	mov    %eax,%edx
   15f03:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f06:	88 10                	mov    %dl,(%eax)
   15f08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15f0b:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15f0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f11:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15f14:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15f18:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15f1c:	0f 85 10 ff ff ff    	jne    15e32 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15f22:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f25:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f2b:	0f b6 00             	movzbl (%eax),%eax
   15f2e:	0f b6 c0             	movzbl %al,%eax
   15f31:	c1 e0 02             	shl    $0x2,%eax
   15f34:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15f3b:	29 c2                	sub    %eax,%edx
   15f3d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f40:	f7 d8                	neg    %eax
   15f42:	89 c1                	mov    %eax,%ecx
   15f44:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f47:	01 c8                	add    %ecx,%eax
   15f49:	0f b6 00             	movzbl (%eax),%eax
   15f4c:	0f b6 c0             	movzbl %al,%eax
   15f4f:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15f52:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15f55:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15f58:	f7 d8                	neg    %eax
   15f5a:	89 c2                	mov    %eax,%edx
   15f5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f5f:	01 d0                	add    %edx,%eax
   15f61:	0f b6 00             	movzbl (%eax),%eax
   15f64:	0f b6 d0             	movzbl %al,%edx
   15f67:	89 d0                	mov    %edx,%eax
   15f69:	c1 e0 03             	shl    $0x3,%eax
   15f6c:	01 d0                	add    %edx,%eax
   15f6e:	f7 d8                	neg    %eax
   15f70:	01 c8                	add    %ecx,%eax
   15f72:	83 ec 0c             	sub    $0xc,%esp
   15f75:	50                   	push   %eax
   15f76:	e8 f5 00 00 00       	call   16070 <CF>
   15f7b:	83 c4 10             	add    $0x10,%esp
   15f7e:	89 c2                	mov    %eax,%edx
   15f80:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f83:	88 10                	mov    %dl,(%eax)
   15f85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15f88:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15f8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f8e:	0f b6 00             	movzbl (%eax),%eax
   15f91:	0f b6 c0             	movzbl %al,%eax
   15f94:	6b c8 68             	imul   $0x68,%eax,%ecx
   15f97:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f9a:	f7 d8                	neg    %eax
   15f9c:	89 c2                	mov    %eax,%edx
   15f9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fa1:	01 d0                	add    %edx,%eax
   15fa3:	0f b6 00             	movzbl (%eax),%eax
   15fa6:	0f b6 d0             	movzbl %al,%edx
   15fa9:	89 d0                	mov    %edx,%eax
   15fab:	01 c0                	add    %eax,%eax
   15fad:	01 d0                	add    %edx,%eax
   15faf:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15fb6:	01 d0                	add    %edx,%eax
   15fb8:	01 c1                	add    %eax,%ecx
   15fba:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15fbd:	f7 d8                	neg    %eax
   15fbf:	89 c2                	mov    %eax,%edx
   15fc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fc4:	01 d0                	add    %edx,%eax
   15fc6:	0f b6 00             	movzbl (%eax),%eax
   15fc9:	0f b6 d0             	movzbl %al,%edx
   15fcc:	89 d0                	mov    %edx,%eax
   15fce:	01 c0                	add    %eax,%eax
   15fd0:	01 d0                	add    %edx,%eax
   15fd2:	f7 d8                	neg    %eax
   15fd4:	01 c8                	add    %ecx,%eax
   15fd6:	83 ec 0c             	sub    $0xc,%esp
   15fd9:	50                   	push   %eax
   15fda:	e8 91 00 00 00       	call   16070 <CF>
   15fdf:	83 c4 10             	add    $0x10,%esp
   15fe2:	89 c2                	mov    %eax,%edx
   15fe4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15fe7:	88 10                	mov    %dl,(%eax)
   15fe9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15fec:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15fef:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ff2:	0f b6 00             	movzbl (%eax),%eax
   15ff5:	0f b6 c0             	movzbl %al,%eax
   15ff8:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15ffe:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16001:	f7 d8                	neg    %eax
   16003:	89 c1                	mov    %eax,%ecx
   16005:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16008:	01 c8                	add    %ecx,%eax
   1600a:	0f b6 00             	movzbl (%eax),%eax
   1600d:	0f b6 c0             	movzbl %al,%eax
   16010:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16013:	01 d0                	add    %edx,%eax
   16015:	83 ec 0c             	sub    $0xc,%esp
   16018:	50                   	push   %eax
   16019:	e8 52 00 00 00       	call   16070 <CF>
   1601e:	83 c4 10             	add    $0x10,%esp
   16021:	89 c2                	mov    %eax,%edx
   16023:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16026:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   16028:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1602c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1602f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16032:	0f 8c d7 fc ff ff    	jl     15d0f <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   16038:	8b 45 0c             	mov    0xc(%ebp),%eax
   1603b:	8b 40 10             	mov    0x10(%eax),%eax
   1603e:	8d 14 00             	lea    (%eax,%eax,1),%edx
   16041:	8b 45 0c             	mov    0xc(%ebp),%eax
   16044:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   16047:	8b 45 0c             	mov    0xc(%ebp),%eax
   1604a:	8b 50 0c             	mov    0xc(%eax),%edx
   1604d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16050:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16053:	8b 45 0c             	mov    0xc(%ebp),%eax
   16056:	8b 40 28             	mov    0x28(%eax),%eax
   16059:	83 ec 0c             	sub    $0xc,%esp
   1605c:	50                   	push   %eax
   1605d:	e8 73 a8 fe ff       	call   8d5 <free>
   16062:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   16065:	8b 45 0c             	mov    0xc(%ebp),%eax
   16068:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1606b:	89 50 28             	mov    %edx,0x28(%eax)
}
   1606e:	c9                   	leave  
   1606f:	c3                   	ret    

00016070 <CF>:

uchar CF(const int x){
   16070:	55                   	push   %ebp
   16071:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   16073:	8b 45 08             	mov    0x8(%ebp),%eax
   16076:	83 c0 40             	add    $0x40,%eax
   16079:	c1 f8 07             	sar    $0x7,%eax
   1607c:	50                   	push   %eax
   1607d:	e8 e9 dd ff ff       	call   13e6b <_Clip>
   16082:	83 c4 04             	add    $0x4,%esp
}
   16085:	c9                   	leave  
   16086:	c3                   	ret    
