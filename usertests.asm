
_usertests：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <iputtest>:
int stdout = 1;

// does chdir() call iput(p->cwd) in a transaction?
void
iputtest(void)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	83 ec 08             	sub    $0x8,%esp
  printf(stdout, "iput test\n");
       6:	a1 14 39 02 00       	mov    0x23914,%eax
       b:	83 ec 08             	sub    $0x8,%esp
       e:	68 d6 99 01 00       	push   $0x199d6
      13:	50                   	push   %eax
      14:	e8 5d 40 00 00       	call   4076 <printf>
      19:	83 c4 10             	add    $0x10,%esp

  if(mkdir("iputdir") < 0){
      1c:	83 ec 0c             	sub    $0xc,%esp
      1f:	68 e1 99 01 00       	push   $0x199e1
      24:	e8 0e 3f 00 00       	call   3f37 <mkdir>
      29:	83 c4 10             	add    $0x10,%esp
      2c:	85 c0                	test   %eax,%eax
      2e:	79 1b                	jns    4b <iputtest+0x4b>
    printf(stdout, "mkdir failed\n");
      30:	a1 14 39 02 00       	mov    0x23914,%eax
      35:	83 ec 08             	sub    $0x8,%esp
      38:	68 e9 99 01 00       	push   $0x199e9
      3d:	50                   	push   %eax
      3e:	e8 33 40 00 00       	call   4076 <printf>
      43:	83 c4 10             	add    $0x10,%esp
    exit();
      46:	e8 84 3e 00 00       	call   3ecf <exit>
  }
  if(chdir("iputdir") < 0){
      4b:	83 ec 0c             	sub    $0xc,%esp
      4e:	68 e1 99 01 00       	push   $0x199e1
      53:	e8 e7 3e 00 00       	call   3f3f <chdir>
      58:	83 c4 10             	add    $0x10,%esp
      5b:	85 c0                	test   %eax,%eax
      5d:	79 1b                	jns    7a <iputtest+0x7a>
    printf(stdout, "chdir iputdir failed\n");
      5f:	a1 14 39 02 00       	mov    0x23914,%eax
      64:	83 ec 08             	sub    $0x8,%esp
      67:	68 f7 99 01 00       	push   $0x199f7
      6c:	50                   	push   %eax
      6d:	e8 04 40 00 00       	call   4076 <printf>
      72:	83 c4 10             	add    $0x10,%esp
    exit();
      75:	e8 55 3e 00 00       	call   3ecf <exit>
  }
  if(unlink("../iputdir") < 0){
      7a:	83 ec 0c             	sub    $0xc,%esp
      7d:	68 0d 9a 01 00       	push   $0x19a0d
      82:	e8 98 3e 00 00       	call   3f1f <unlink>
      87:	83 c4 10             	add    $0x10,%esp
      8a:	85 c0                	test   %eax,%eax
      8c:	79 1b                	jns    a9 <iputtest+0xa9>
    printf(stdout, "unlink ../iputdir failed\n");
      8e:	a1 14 39 02 00       	mov    0x23914,%eax
      93:	83 ec 08             	sub    $0x8,%esp
      96:	68 18 9a 01 00       	push   $0x19a18
      9b:	50                   	push   %eax
      9c:	e8 d5 3f 00 00       	call   4076 <printf>
      a1:	83 c4 10             	add    $0x10,%esp
    exit();
      a4:	e8 26 3e 00 00       	call   3ecf <exit>
  }
  if(chdir("/") < 0){
      a9:	83 ec 0c             	sub    $0xc,%esp
      ac:	68 32 9a 01 00       	push   $0x19a32
      b1:	e8 89 3e 00 00       	call   3f3f <chdir>
      b6:	83 c4 10             	add    $0x10,%esp
      b9:	85 c0                	test   %eax,%eax
      bb:	79 1b                	jns    d8 <iputtest+0xd8>
    printf(stdout, "chdir / failed\n");
      bd:	a1 14 39 02 00       	mov    0x23914,%eax
      c2:	83 ec 08             	sub    $0x8,%esp
      c5:	68 34 9a 01 00       	push   $0x19a34
      ca:	50                   	push   %eax
      cb:	e8 a6 3f 00 00       	call   4076 <printf>
      d0:	83 c4 10             	add    $0x10,%esp
    exit();
      d3:	e8 f7 3d 00 00       	call   3ecf <exit>
  }
  printf(stdout, "iput test ok\n");
      d8:	a1 14 39 02 00       	mov    0x23914,%eax
      dd:	83 ec 08             	sub    $0x8,%esp
      e0:	68 44 9a 01 00       	push   $0x19a44
      e5:	50                   	push   %eax
      e6:	e8 8b 3f 00 00       	call   4076 <printf>
      eb:	83 c4 10             	add    $0x10,%esp
}
      ee:	90                   	nop
      ef:	c9                   	leave  
      f0:	c3                   	ret    

000000f1 <exitiputtest>:

// does exit() call iput(p->cwd) in a transaction?
void
exitiputtest(void)
{
      f1:	55                   	push   %ebp
      f2:	89 e5                	mov    %esp,%ebp
      f4:	83 ec 18             	sub    $0x18,%esp
  int pid;

  printf(stdout, "exitiput test\n");
      f7:	a1 14 39 02 00       	mov    0x23914,%eax
      fc:	83 ec 08             	sub    $0x8,%esp
      ff:	68 52 9a 01 00       	push   $0x19a52
     104:	50                   	push   %eax
     105:	e8 6c 3f 00 00       	call   4076 <printf>
     10a:	83 c4 10             	add    $0x10,%esp

  pid = fork();
     10d:	e8 b5 3d 00 00       	call   3ec7 <fork>
     112:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(pid < 0){
     115:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     119:	79 1b                	jns    136 <exitiputtest+0x45>
    printf(stdout, "fork failed\n");
     11b:	a1 14 39 02 00       	mov    0x23914,%eax
     120:	83 ec 08             	sub    $0x8,%esp
     123:	68 61 9a 01 00       	push   $0x19a61
     128:	50                   	push   %eax
     129:	e8 48 3f 00 00       	call   4076 <printf>
     12e:	83 c4 10             	add    $0x10,%esp
    exit();
     131:	e8 99 3d 00 00       	call   3ecf <exit>
  }
  if(pid == 0){
     136:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     13a:	0f 85 92 00 00 00    	jne    1d2 <exitiputtest+0xe1>
    if(mkdir("iputdir") < 0){
     140:	83 ec 0c             	sub    $0xc,%esp
     143:	68 e1 99 01 00       	push   $0x199e1
     148:	e8 ea 3d 00 00       	call   3f37 <mkdir>
     14d:	83 c4 10             	add    $0x10,%esp
     150:	85 c0                	test   %eax,%eax
     152:	79 1b                	jns    16f <exitiputtest+0x7e>
      printf(stdout, "mkdir failed\n");
     154:	a1 14 39 02 00       	mov    0x23914,%eax
     159:	83 ec 08             	sub    $0x8,%esp
     15c:	68 e9 99 01 00       	push   $0x199e9
     161:	50                   	push   %eax
     162:	e8 0f 3f 00 00       	call   4076 <printf>
     167:	83 c4 10             	add    $0x10,%esp
      exit();
     16a:	e8 60 3d 00 00       	call   3ecf <exit>
    }
    if(chdir("iputdir") < 0){
     16f:	83 ec 0c             	sub    $0xc,%esp
     172:	68 e1 99 01 00       	push   $0x199e1
     177:	e8 c3 3d 00 00       	call   3f3f <chdir>
     17c:	83 c4 10             	add    $0x10,%esp
     17f:	85 c0                	test   %eax,%eax
     181:	79 1b                	jns    19e <exitiputtest+0xad>
      printf(stdout, "child chdir failed\n");
     183:	a1 14 39 02 00       	mov    0x23914,%eax
     188:	83 ec 08             	sub    $0x8,%esp
     18b:	68 6e 9a 01 00       	push   $0x19a6e
     190:	50                   	push   %eax
     191:	e8 e0 3e 00 00       	call   4076 <printf>
     196:	83 c4 10             	add    $0x10,%esp
      exit();
     199:	e8 31 3d 00 00       	call   3ecf <exit>
    }
    if(unlink("../iputdir") < 0){
     19e:	83 ec 0c             	sub    $0xc,%esp
     1a1:	68 0d 9a 01 00       	push   $0x19a0d
     1a6:	e8 74 3d 00 00       	call   3f1f <unlink>
     1ab:	83 c4 10             	add    $0x10,%esp
     1ae:	85 c0                	test   %eax,%eax
     1b0:	79 1b                	jns    1cd <exitiputtest+0xdc>
      printf(stdout, "unlink ../iputdir failed\n");
     1b2:	a1 14 39 02 00       	mov    0x23914,%eax
     1b7:	83 ec 08             	sub    $0x8,%esp
     1ba:	68 18 9a 01 00       	push   $0x19a18
     1bf:	50                   	push   %eax
     1c0:	e8 b1 3e 00 00       	call   4076 <printf>
     1c5:	83 c4 10             	add    $0x10,%esp
      exit();
     1c8:	e8 02 3d 00 00       	call   3ecf <exit>
    }
    exit();
     1cd:	e8 fd 3c 00 00       	call   3ecf <exit>
  }
  wait();
     1d2:	e8 00 3d 00 00       	call   3ed7 <wait>
  printf(stdout, "exitiput test ok\n");
     1d7:	a1 14 39 02 00       	mov    0x23914,%eax
     1dc:	83 ec 08             	sub    $0x8,%esp
     1df:	68 82 9a 01 00       	push   $0x19a82
     1e4:	50                   	push   %eax
     1e5:	e8 8c 3e 00 00       	call   4076 <printf>
     1ea:	83 c4 10             	add    $0x10,%esp
}
     1ed:	90                   	nop
     1ee:	c9                   	leave  
     1ef:	c3                   	ret    

000001f0 <openiputtest>:
//      for(i = 0; i < 10000; i++)
//        yield();
//    }
void
openiputtest(void)
{
     1f0:	55                   	push   %ebp
     1f1:	89 e5                	mov    %esp,%ebp
     1f3:	83 ec 18             	sub    $0x18,%esp
  int pid;

  printf(stdout, "openiput test\n");
     1f6:	a1 14 39 02 00       	mov    0x23914,%eax
     1fb:	83 ec 08             	sub    $0x8,%esp
     1fe:	68 94 9a 01 00       	push   $0x19a94
     203:	50                   	push   %eax
     204:	e8 6d 3e 00 00       	call   4076 <printf>
     209:	83 c4 10             	add    $0x10,%esp
  if(mkdir("oidir") < 0){
     20c:	83 ec 0c             	sub    $0xc,%esp
     20f:	68 a3 9a 01 00       	push   $0x19aa3
     214:	e8 1e 3d 00 00       	call   3f37 <mkdir>
     219:	83 c4 10             	add    $0x10,%esp
     21c:	85 c0                	test   %eax,%eax
     21e:	79 1b                	jns    23b <openiputtest+0x4b>
    printf(stdout, "mkdir oidir failed\n");
     220:	a1 14 39 02 00       	mov    0x23914,%eax
     225:	83 ec 08             	sub    $0x8,%esp
     228:	68 a9 9a 01 00       	push   $0x19aa9
     22d:	50                   	push   %eax
     22e:	e8 43 3e 00 00       	call   4076 <printf>
     233:	83 c4 10             	add    $0x10,%esp
    exit();
     236:	e8 94 3c 00 00       	call   3ecf <exit>
  }
  pid = fork();
     23b:	e8 87 3c 00 00       	call   3ec7 <fork>
     240:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(pid < 0){
     243:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     247:	79 1b                	jns    264 <openiputtest+0x74>
    printf(stdout, "fork failed\n");
     249:	a1 14 39 02 00       	mov    0x23914,%eax
     24e:	83 ec 08             	sub    $0x8,%esp
     251:	68 61 9a 01 00       	push   $0x19a61
     256:	50                   	push   %eax
     257:	e8 1a 3e 00 00       	call   4076 <printf>
     25c:	83 c4 10             	add    $0x10,%esp
    exit();
     25f:	e8 6b 3c 00 00       	call   3ecf <exit>
  }
  if(pid == 0){
     264:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     268:	75 3b                	jne    2a5 <openiputtest+0xb5>
    int fd = open("oidir", O_RDWR);
     26a:	83 ec 08             	sub    $0x8,%esp
     26d:	6a 02                	push   $0x2
     26f:	68 a3 9a 01 00       	push   $0x19aa3
     274:	e8 96 3c 00 00       	call   3f0f <open>
     279:	83 c4 10             	add    $0x10,%esp
     27c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(fd >= 0){
     27f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     283:	78 1b                	js     2a0 <openiputtest+0xb0>
      printf(stdout, "open directory for write succeeded\n");
     285:	a1 14 39 02 00       	mov    0x23914,%eax
     28a:	83 ec 08             	sub    $0x8,%esp
     28d:	68 c0 9a 01 00       	push   $0x19ac0
     292:	50                   	push   %eax
     293:	e8 de 3d 00 00       	call   4076 <printf>
     298:	83 c4 10             	add    $0x10,%esp
      exit();
     29b:	e8 2f 3c 00 00       	call   3ecf <exit>
    }
    exit();
     2a0:	e8 2a 3c 00 00       	call   3ecf <exit>
  }
  sleep(1);
     2a5:	83 ec 0c             	sub    $0xc,%esp
     2a8:	6a 01                	push   $0x1
     2aa:	e8 b0 3c 00 00       	call   3f5f <sleep>
     2af:	83 c4 10             	add    $0x10,%esp
  if(unlink("oidir") != 0){
     2b2:	83 ec 0c             	sub    $0xc,%esp
     2b5:	68 a3 9a 01 00       	push   $0x19aa3
     2ba:	e8 60 3c 00 00       	call   3f1f <unlink>
     2bf:	83 c4 10             	add    $0x10,%esp
     2c2:	85 c0                	test   %eax,%eax
     2c4:	74 1b                	je     2e1 <openiputtest+0xf1>
    printf(stdout, "unlink failed\n");
     2c6:	a1 14 39 02 00       	mov    0x23914,%eax
     2cb:	83 ec 08             	sub    $0x8,%esp
     2ce:	68 e4 9a 01 00       	push   $0x19ae4
     2d3:	50                   	push   %eax
     2d4:	e8 9d 3d 00 00       	call   4076 <printf>
     2d9:	83 c4 10             	add    $0x10,%esp
    exit();
     2dc:	e8 ee 3b 00 00       	call   3ecf <exit>
  }
  wait();
     2e1:	e8 f1 3b 00 00       	call   3ed7 <wait>
  printf(stdout, "openiput test ok\n");
     2e6:	a1 14 39 02 00       	mov    0x23914,%eax
     2eb:	83 ec 08             	sub    $0x8,%esp
     2ee:	68 f3 9a 01 00       	push   $0x19af3
     2f3:	50                   	push   %eax
     2f4:	e8 7d 3d 00 00       	call   4076 <printf>
     2f9:	83 c4 10             	add    $0x10,%esp
}
     2fc:	90                   	nop
     2fd:	c9                   	leave  
     2fe:	c3                   	ret    

000002ff <opentest>:

// simple file system tests

void
opentest(void)
{
     2ff:	55                   	push   %ebp
     300:	89 e5                	mov    %esp,%ebp
     302:	83 ec 18             	sub    $0x18,%esp
  int fd;

  printf(stdout, "open test\n");
     305:	a1 14 39 02 00       	mov    0x23914,%eax
     30a:	83 ec 08             	sub    $0x8,%esp
     30d:	68 05 9b 01 00       	push   $0x19b05
     312:	50                   	push   %eax
     313:	e8 5e 3d 00 00       	call   4076 <printf>
     318:	83 c4 10             	add    $0x10,%esp
  fd = open("echo", 0);
     31b:	83 ec 08             	sub    $0x8,%esp
     31e:	6a 00                	push   $0x0
     320:	68 c0 99 01 00       	push   $0x199c0
     325:	e8 e5 3b 00 00       	call   3f0f <open>
     32a:	83 c4 10             	add    $0x10,%esp
     32d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
     330:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     334:	79 1b                	jns    351 <opentest+0x52>
    printf(stdout, "open echo failed!\n");
     336:	a1 14 39 02 00       	mov    0x23914,%eax
     33b:	83 ec 08             	sub    $0x8,%esp
     33e:	68 10 9b 01 00       	push   $0x19b10
     343:	50                   	push   %eax
     344:	e8 2d 3d 00 00       	call   4076 <printf>
     349:	83 c4 10             	add    $0x10,%esp
    exit();
     34c:	e8 7e 3b 00 00       	call   3ecf <exit>
  }
  close(fd);
     351:	83 ec 0c             	sub    $0xc,%esp
     354:	ff 75 f4             	pushl  -0xc(%ebp)
     357:	e8 9b 3b 00 00       	call   3ef7 <close>
     35c:	83 c4 10             	add    $0x10,%esp
  fd = open("doesnotexist", 0);
     35f:	83 ec 08             	sub    $0x8,%esp
     362:	6a 00                	push   $0x0
     364:	68 23 9b 01 00       	push   $0x19b23
     369:	e8 a1 3b 00 00       	call   3f0f <open>
     36e:	83 c4 10             	add    $0x10,%esp
     371:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd >= 0){
     374:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     378:	78 1b                	js     395 <opentest+0x96>
    printf(stdout, "open doesnotexist succeeded!\n");
     37a:	a1 14 39 02 00       	mov    0x23914,%eax
     37f:	83 ec 08             	sub    $0x8,%esp
     382:	68 30 9b 01 00       	push   $0x19b30
     387:	50                   	push   %eax
     388:	e8 e9 3c 00 00       	call   4076 <printf>
     38d:	83 c4 10             	add    $0x10,%esp
    exit();
     390:	e8 3a 3b 00 00       	call   3ecf <exit>
  }
  printf(stdout, "open test ok\n");
     395:	a1 14 39 02 00       	mov    0x23914,%eax
     39a:	83 ec 08             	sub    $0x8,%esp
     39d:	68 4e 9b 01 00       	push   $0x19b4e
     3a2:	50                   	push   %eax
     3a3:	e8 ce 3c 00 00       	call   4076 <printf>
     3a8:	83 c4 10             	add    $0x10,%esp
}
     3ab:	90                   	nop
     3ac:	c9                   	leave  
     3ad:	c3                   	ret    

000003ae <writetest>:

void
writetest(void)
{
     3ae:	55                   	push   %ebp
     3af:	89 e5                	mov    %esp,%ebp
     3b1:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int i;

  printf(stdout, "small file test\n");
     3b4:	a1 14 39 02 00       	mov    0x23914,%eax
     3b9:	83 ec 08             	sub    $0x8,%esp
     3bc:	68 5c 9b 01 00       	push   $0x19b5c
     3c1:	50                   	push   %eax
     3c2:	e8 af 3c 00 00       	call   4076 <printf>
     3c7:	83 c4 10             	add    $0x10,%esp
  fd = open("small", O_CREATE|O_RDWR);
     3ca:	83 ec 08             	sub    $0x8,%esp
     3cd:	68 02 02 00 00       	push   $0x202
     3d2:	68 6d 9b 01 00       	push   $0x19b6d
     3d7:	e8 33 3b 00 00       	call   3f0f <open>
     3dc:	83 c4 10             	add    $0x10,%esp
     3df:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(fd >= 0){
     3e2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     3e6:	78 22                	js     40a <writetest+0x5c>
    printf(stdout, "creat small succeeded; ok\n");
     3e8:	a1 14 39 02 00       	mov    0x23914,%eax
     3ed:	83 ec 08             	sub    $0x8,%esp
     3f0:	68 73 9b 01 00       	push   $0x19b73
     3f5:	50                   	push   %eax
     3f6:	e8 7b 3c 00 00       	call   4076 <printf>
     3fb:	83 c4 10             	add    $0x10,%esp
  } else {
    printf(stdout, "error: creat small failed!\n");
    exit();
  }
  for(i = 0; i < 100; i++){
     3fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     405:	e9 8f 00 00 00       	jmp    499 <writetest+0xeb>
  printf(stdout, "small file test\n");
  fd = open("small", O_CREATE|O_RDWR);
  if(fd >= 0){
    printf(stdout, "creat small succeeded; ok\n");
  } else {
    printf(stdout, "error: creat small failed!\n");
     40a:	a1 14 39 02 00       	mov    0x23914,%eax
     40f:	83 ec 08             	sub    $0x8,%esp
     412:	68 8e 9b 01 00       	push   $0x19b8e
     417:	50                   	push   %eax
     418:	e8 59 3c 00 00       	call   4076 <printf>
     41d:	83 c4 10             	add    $0x10,%esp
    exit();
     420:	e8 aa 3a 00 00       	call   3ecf <exit>
  }
  for(i = 0; i < 100; i++){
    if(write(fd, "aaaaaaaaaa", 10) != 10){
     425:	83 ec 04             	sub    $0x4,%esp
     428:	6a 0a                	push   $0xa
     42a:	68 aa 9b 01 00       	push   $0x19baa
     42f:	ff 75 f0             	pushl  -0x10(%ebp)
     432:	e8 b8 3a 00 00       	call   3eef <write>
     437:	83 c4 10             	add    $0x10,%esp
     43a:	83 f8 0a             	cmp    $0xa,%eax
     43d:	74 1e                	je     45d <writetest+0xaf>
      printf(stdout, "error: write aa %d new file failed\n", i);
     43f:	a1 14 39 02 00       	mov    0x23914,%eax
     444:	83 ec 04             	sub    $0x4,%esp
     447:	ff 75 f4             	pushl  -0xc(%ebp)
     44a:	68 b8 9b 01 00       	push   $0x19bb8
     44f:	50                   	push   %eax
     450:	e8 21 3c 00 00       	call   4076 <printf>
     455:	83 c4 10             	add    $0x10,%esp
      exit();
     458:	e8 72 3a 00 00       	call   3ecf <exit>
    }
    if(write(fd, "bbbbbbbbbb", 10) != 10){
     45d:	83 ec 04             	sub    $0x4,%esp
     460:	6a 0a                	push   $0xa
     462:	68 dc 9b 01 00       	push   $0x19bdc
     467:	ff 75 f0             	pushl  -0x10(%ebp)
     46a:	e8 80 3a 00 00       	call   3eef <write>
     46f:	83 c4 10             	add    $0x10,%esp
     472:	83 f8 0a             	cmp    $0xa,%eax
     475:	74 1e                	je     495 <writetest+0xe7>
      printf(stdout, "error: write bb %d new file failed\n", i);
     477:	a1 14 39 02 00       	mov    0x23914,%eax
     47c:	83 ec 04             	sub    $0x4,%esp
     47f:	ff 75 f4             	pushl  -0xc(%ebp)
     482:	68 e8 9b 01 00       	push   $0x19be8
     487:	50                   	push   %eax
     488:	e8 e9 3b 00 00       	call   4076 <printf>
     48d:	83 c4 10             	add    $0x10,%esp
      exit();
     490:	e8 3a 3a 00 00       	call   3ecf <exit>
    printf(stdout, "creat small succeeded; ok\n");
  } else {
    printf(stdout, "error: creat small failed!\n");
    exit();
  }
  for(i = 0; i < 100; i++){
     495:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     499:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
     49d:	7e 86                	jle    425 <writetest+0x77>
    if(write(fd, "bbbbbbbbbb", 10) != 10){
      printf(stdout, "error: write bb %d new file failed\n", i);
      exit();
    }
  }
  printf(stdout, "writes ok\n");
     49f:	a1 14 39 02 00       	mov    0x23914,%eax
     4a4:	83 ec 08             	sub    $0x8,%esp
     4a7:	68 0c 9c 01 00       	push   $0x19c0c
     4ac:	50                   	push   %eax
     4ad:	e8 c4 3b 00 00       	call   4076 <printf>
     4b2:	83 c4 10             	add    $0x10,%esp
  close(fd);
     4b5:	83 ec 0c             	sub    $0xc,%esp
     4b8:	ff 75 f0             	pushl  -0x10(%ebp)
     4bb:	e8 37 3a 00 00       	call   3ef7 <close>
     4c0:	83 c4 10             	add    $0x10,%esp
  fd = open("small", O_RDONLY);
     4c3:	83 ec 08             	sub    $0x8,%esp
     4c6:	6a 00                	push   $0x0
     4c8:	68 6d 9b 01 00       	push   $0x19b6d
     4cd:	e8 3d 3a 00 00       	call   3f0f <open>
     4d2:	83 c4 10             	add    $0x10,%esp
     4d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(fd >= 0){
     4d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     4dc:	78 3c                	js     51a <writetest+0x16c>
    printf(stdout, "open small succeeded ok\n");
     4de:	a1 14 39 02 00       	mov    0x23914,%eax
     4e3:	83 ec 08             	sub    $0x8,%esp
     4e6:	68 17 9c 01 00       	push   $0x19c17
     4eb:	50                   	push   %eax
     4ec:	e8 85 3b 00 00       	call   4076 <printf>
     4f1:	83 c4 10             	add    $0x10,%esp
  } else {
    printf(stdout, "error: open small failed!\n");
    exit();
  }
  i = read(fd, buf, 2000);
     4f4:	83 ec 04             	sub    $0x4,%esp
     4f7:	68 d0 07 00 00       	push   $0x7d0
     4fc:	68 20 65 02 00       	push   $0x26520
     501:	ff 75 f0             	pushl  -0x10(%ebp)
     504:	e8 de 39 00 00       	call   3ee7 <read>
     509:	83 c4 10             	add    $0x10,%esp
     50c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(i == 2000){
     50f:	81 7d f4 d0 07 00 00 	cmpl   $0x7d0,-0xc(%ebp)
     516:	75 57                	jne    56f <writetest+0x1c1>
     518:	eb 1b                	jmp    535 <writetest+0x187>
  close(fd);
  fd = open("small", O_RDONLY);
  if(fd >= 0){
    printf(stdout, "open small succeeded ok\n");
  } else {
    printf(stdout, "error: open small failed!\n");
     51a:	a1 14 39 02 00       	mov    0x23914,%eax
     51f:	83 ec 08             	sub    $0x8,%esp
     522:	68 30 9c 01 00       	push   $0x19c30
     527:	50                   	push   %eax
     528:	e8 49 3b 00 00       	call   4076 <printf>
     52d:	83 c4 10             	add    $0x10,%esp
    exit();
     530:	e8 9a 39 00 00       	call   3ecf <exit>
  }
  i = read(fd, buf, 2000);
  if(i == 2000){
    printf(stdout, "read succeeded ok\n");
     535:	a1 14 39 02 00       	mov    0x23914,%eax
     53a:	83 ec 08             	sub    $0x8,%esp
     53d:	68 4b 9c 01 00       	push   $0x19c4b
     542:	50                   	push   %eax
     543:	e8 2e 3b 00 00       	call   4076 <printf>
     548:	83 c4 10             	add    $0x10,%esp
  } else {
    printf(stdout, "read failed\n");
    exit();
  }
  close(fd);
     54b:	83 ec 0c             	sub    $0xc,%esp
     54e:	ff 75 f0             	pushl  -0x10(%ebp)
     551:	e8 a1 39 00 00       	call   3ef7 <close>
     556:	83 c4 10             	add    $0x10,%esp

  if(unlink("small") < 0){
     559:	83 ec 0c             	sub    $0xc,%esp
     55c:	68 6d 9b 01 00       	push   $0x19b6d
     561:	e8 b9 39 00 00       	call   3f1f <unlink>
     566:	83 c4 10             	add    $0x10,%esp
     569:	85 c0                	test   %eax,%eax
     56b:	79 38                	jns    5a5 <writetest+0x1f7>
     56d:	eb 1b                	jmp    58a <writetest+0x1dc>
  }
  i = read(fd, buf, 2000);
  if(i == 2000){
    printf(stdout, "read succeeded ok\n");
  } else {
    printf(stdout, "read failed\n");
     56f:	a1 14 39 02 00       	mov    0x23914,%eax
     574:	83 ec 08             	sub    $0x8,%esp
     577:	68 5e 9c 01 00       	push   $0x19c5e
     57c:	50                   	push   %eax
     57d:	e8 f4 3a 00 00       	call   4076 <printf>
     582:	83 c4 10             	add    $0x10,%esp
    exit();
     585:	e8 45 39 00 00       	call   3ecf <exit>
  }
  close(fd);

  if(unlink("small") < 0){
    printf(stdout, "unlink small failed\n");
     58a:	a1 14 39 02 00       	mov    0x23914,%eax
     58f:	83 ec 08             	sub    $0x8,%esp
     592:	68 6b 9c 01 00       	push   $0x19c6b
     597:	50                   	push   %eax
     598:	e8 d9 3a 00 00       	call   4076 <printf>
     59d:	83 c4 10             	add    $0x10,%esp
    exit();
     5a0:	e8 2a 39 00 00       	call   3ecf <exit>
  }
  printf(stdout, "small file test ok\n");
     5a5:	a1 14 39 02 00       	mov    0x23914,%eax
     5aa:	83 ec 08             	sub    $0x8,%esp
     5ad:	68 80 9c 01 00       	push   $0x19c80
     5b2:	50                   	push   %eax
     5b3:	e8 be 3a 00 00       	call   4076 <printf>
     5b8:	83 c4 10             	add    $0x10,%esp
}
     5bb:	90                   	nop
     5bc:	c9                   	leave  
     5bd:	c3                   	ret    

000005be <writetest1>:

void
writetest1(void)
{
     5be:	55                   	push   %ebp
     5bf:	89 e5                	mov    %esp,%ebp
     5c1:	83 ec 18             	sub    $0x18,%esp
  int i, fd, n;

  printf(stdout, "big files test\n");
     5c4:	a1 14 39 02 00       	mov    0x23914,%eax
     5c9:	83 ec 08             	sub    $0x8,%esp
     5cc:	68 94 9c 01 00       	push   $0x19c94
     5d1:	50                   	push   %eax
     5d2:	e8 9f 3a 00 00       	call   4076 <printf>
     5d7:	83 c4 10             	add    $0x10,%esp

  fd = open("big", O_CREATE|O_RDWR);
     5da:	83 ec 08             	sub    $0x8,%esp
     5dd:	68 02 02 00 00       	push   $0x202
     5e2:	68 a4 9c 01 00       	push   $0x19ca4
     5e7:	e8 23 39 00 00       	call   3f0f <open>
     5ec:	83 c4 10             	add    $0x10,%esp
     5ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(fd < 0){
     5f2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     5f6:	79 1b                	jns    613 <writetest1+0x55>
    printf(stdout, "error: creat big failed!\n");
     5f8:	a1 14 39 02 00       	mov    0x23914,%eax
     5fd:	83 ec 08             	sub    $0x8,%esp
     600:	68 a8 9c 01 00       	push   $0x19ca8
     605:	50                   	push   %eax
     606:	e8 6b 3a 00 00       	call   4076 <printf>
     60b:	83 c4 10             	add    $0x10,%esp
    exit();
     60e:	e8 bc 38 00 00       	call   3ecf <exit>
  }

  for(i = 0; i < MAXFILE; i++){
     613:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     61a:	eb 4b                	jmp    667 <writetest1+0xa9>
    ((int*)buf)[0] = i;
     61c:	ba 20 65 02 00       	mov    $0x26520,%edx
     621:	8b 45 f4             	mov    -0xc(%ebp),%eax
     624:	89 02                	mov    %eax,(%edx)
    if(write(fd, buf, 512) != 512){
     626:	83 ec 04             	sub    $0x4,%esp
     629:	68 00 02 00 00       	push   $0x200
     62e:	68 20 65 02 00       	push   $0x26520
     633:	ff 75 ec             	pushl  -0x14(%ebp)
     636:	e8 b4 38 00 00       	call   3eef <write>
     63b:	83 c4 10             	add    $0x10,%esp
     63e:	3d 00 02 00 00       	cmp    $0x200,%eax
     643:	74 1e                	je     663 <writetest1+0xa5>
      printf(stdout, "error: write big file failed\n", i);
     645:	a1 14 39 02 00       	mov    0x23914,%eax
     64a:	83 ec 04             	sub    $0x4,%esp
     64d:	ff 75 f4             	pushl  -0xc(%ebp)
     650:	68 c2 9c 01 00       	push   $0x19cc2
     655:	50                   	push   %eax
     656:	e8 1b 3a 00 00       	call   4076 <printf>
     65b:	83 c4 10             	add    $0x10,%esp
      exit();
     65e:	e8 6c 38 00 00       	call   3ecf <exit>
  if(fd < 0){
    printf(stdout, "error: creat big failed!\n");
    exit();
  }

  for(i = 0; i < MAXFILE; i++){
     663:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     667:	8b 45 f4             	mov    -0xc(%ebp),%eax
     66a:	3d 8a 40 00 00       	cmp    $0x408a,%eax
     66f:	76 ab                	jbe    61c <writetest1+0x5e>
      printf(stdout, "error: write big file failed\n", i);
      exit();
    }
  }

  close(fd);
     671:	83 ec 0c             	sub    $0xc,%esp
     674:	ff 75 ec             	pushl  -0x14(%ebp)
     677:	e8 7b 38 00 00       	call   3ef7 <close>
     67c:	83 c4 10             	add    $0x10,%esp

  fd = open("big", O_RDONLY);
     67f:	83 ec 08             	sub    $0x8,%esp
     682:	6a 00                	push   $0x0
     684:	68 a4 9c 01 00       	push   $0x19ca4
     689:	e8 81 38 00 00       	call   3f0f <open>
     68e:	83 c4 10             	add    $0x10,%esp
     691:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(fd < 0){
     694:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     698:	79 1b                	jns    6b5 <writetest1+0xf7>
    printf(stdout, "error: open big failed!\n");
     69a:	a1 14 39 02 00       	mov    0x23914,%eax
     69f:	83 ec 08             	sub    $0x8,%esp
     6a2:	68 e0 9c 01 00       	push   $0x19ce0
     6a7:	50                   	push   %eax
     6a8:	e8 c9 39 00 00       	call   4076 <printf>
     6ad:	83 c4 10             	add    $0x10,%esp
    exit();
     6b0:	e8 1a 38 00 00       	call   3ecf <exit>
  }

  n = 0;
     6b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(;;){
    i = read(fd, buf, 512);
     6bc:	83 ec 04             	sub    $0x4,%esp
     6bf:	68 00 02 00 00       	push   $0x200
     6c4:	68 20 65 02 00       	push   $0x26520
     6c9:	ff 75 ec             	pushl  -0x14(%ebp)
     6cc:	e8 16 38 00 00       	call   3ee7 <read>
     6d1:	83 c4 10             	add    $0x10,%esp
     6d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(i == 0){
     6d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     6db:	75 27                	jne    704 <writetest1+0x146>
      if(n == MAXFILE - 1){
     6dd:	81 7d f0 8a 40 00 00 	cmpl   $0x408a,-0x10(%ebp)
     6e4:	75 7d                	jne    763 <writetest1+0x1a5>
        printf(stdout, "read only %d blocks from big", n);
     6e6:	a1 14 39 02 00       	mov    0x23914,%eax
     6eb:	83 ec 04             	sub    $0x4,%esp
     6ee:	ff 75 f0             	pushl  -0x10(%ebp)
     6f1:	68 f9 9c 01 00       	push   $0x19cf9
     6f6:	50                   	push   %eax
     6f7:	e8 7a 39 00 00       	call   4076 <printf>
     6fc:	83 c4 10             	add    $0x10,%esp
        exit();
     6ff:	e8 cb 37 00 00       	call   3ecf <exit>
      }
      break;
    } else if(i != 512){
     704:	81 7d f4 00 02 00 00 	cmpl   $0x200,-0xc(%ebp)
     70b:	74 1e                	je     72b <writetest1+0x16d>
      printf(stdout, "read failed %d\n", i);
     70d:	a1 14 39 02 00       	mov    0x23914,%eax
     712:	83 ec 04             	sub    $0x4,%esp
     715:	ff 75 f4             	pushl  -0xc(%ebp)
     718:	68 16 9d 01 00       	push   $0x19d16
     71d:	50                   	push   %eax
     71e:	e8 53 39 00 00       	call   4076 <printf>
     723:	83 c4 10             	add    $0x10,%esp
      exit();
     726:	e8 a4 37 00 00       	call   3ecf <exit>
    }
    if(((int*)buf)[0] != n){
     72b:	b8 20 65 02 00       	mov    $0x26520,%eax
     730:	8b 00                	mov    (%eax),%eax
     732:	3b 45 f0             	cmp    -0x10(%ebp),%eax
     735:	74 23                	je     75a <writetest1+0x19c>
      printf(stdout, "read content of block %d is %d\n",
             n, ((int*)buf)[0]);
     737:	b8 20 65 02 00       	mov    $0x26520,%eax
    } else if(i != 512){
      printf(stdout, "read failed %d\n", i);
      exit();
    }
    if(((int*)buf)[0] != n){
      printf(stdout, "read content of block %d is %d\n",
     73c:	8b 10                	mov    (%eax),%edx
     73e:	a1 14 39 02 00       	mov    0x23914,%eax
     743:	52                   	push   %edx
     744:	ff 75 f0             	pushl  -0x10(%ebp)
     747:	68 28 9d 01 00       	push   $0x19d28
     74c:	50                   	push   %eax
     74d:	e8 24 39 00 00       	call   4076 <printf>
     752:	83 c4 10             	add    $0x10,%esp
             n, ((int*)buf)[0]);
      exit();
     755:	e8 75 37 00 00       	call   3ecf <exit>
    }
    n++;
     75a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  }
     75e:	e9 59 ff ff ff       	jmp    6bc <writetest1+0xfe>
    if(i == 0){
      if(n == MAXFILE - 1){
        printf(stdout, "read only %d blocks from big", n);
        exit();
      }
      break;
     763:	90                   	nop
             n, ((int*)buf)[0]);
      exit();
    }
    n++;
  }
  close(fd);
     764:	83 ec 0c             	sub    $0xc,%esp
     767:	ff 75 ec             	pushl  -0x14(%ebp)
     76a:	e8 88 37 00 00       	call   3ef7 <close>
     76f:	83 c4 10             	add    $0x10,%esp
  if(unlink("big") < 0){
     772:	83 ec 0c             	sub    $0xc,%esp
     775:	68 a4 9c 01 00       	push   $0x19ca4
     77a:	e8 a0 37 00 00       	call   3f1f <unlink>
     77f:	83 c4 10             	add    $0x10,%esp
     782:	85 c0                	test   %eax,%eax
     784:	79 1b                	jns    7a1 <writetest1+0x1e3>
    printf(stdout, "unlink big failed\n");
     786:	a1 14 39 02 00       	mov    0x23914,%eax
     78b:	83 ec 08             	sub    $0x8,%esp
     78e:	68 48 9d 01 00       	push   $0x19d48
     793:	50                   	push   %eax
     794:	e8 dd 38 00 00       	call   4076 <printf>
     799:	83 c4 10             	add    $0x10,%esp
    exit();
     79c:	e8 2e 37 00 00       	call   3ecf <exit>
  }
  printf(stdout, "big files ok\n");
     7a1:	a1 14 39 02 00       	mov    0x23914,%eax
     7a6:	83 ec 08             	sub    $0x8,%esp
     7a9:	68 5b 9d 01 00       	push   $0x19d5b
     7ae:	50                   	push   %eax
     7af:	e8 c2 38 00 00       	call   4076 <printf>
     7b4:	83 c4 10             	add    $0x10,%esp
}
     7b7:	90                   	nop
     7b8:	c9                   	leave  
     7b9:	c3                   	ret    

000007ba <createtest>:

void
createtest(void)
{
     7ba:	55                   	push   %ebp
     7bb:	89 e5                	mov    %esp,%ebp
     7bd:	83 ec 18             	sub    $0x18,%esp
  int i, fd;

  printf(stdout, "many creates, followed by unlink test\n");
     7c0:	a1 14 39 02 00       	mov    0x23914,%eax
     7c5:	83 ec 08             	sub    $0x8,%esp
     7c8:	68 6c 9d 01 00       	push   $0x19d6c
     7cd:	50                   	push   %eax
     7ce:	e8 a3 38 00 00       	call   4076 <printf>
     7d3:	83 c4 10             	add    $0x10,%esp

  name[0] = 'a';
     7d6:	c6 05 20 85 02 00 61 	movb   $0x61,0x28520
  name[2] = '\0';
     7dd:	c6 05 22 85 02 00 00 	movb   $0x0,0x28522
  for(i = 0; i < 52; i++){
     7e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     7eb:	eb 35                	jmp    822 <createtest+0x68>
    name[1] = '0' + i;
     7ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7f0:	83 c0 30             	add    $0x30,%eax
     7f3:	a2 21 85 02 00       	mov    %al,0x28521
    fd = open(name, O_CREATE|O_RDWR);
     7f8:	83 ec 08             	sub    $0x8,%esp
     7fb:	68 02 02 00 00       	push   $0x202
     800:	68 20 85 02 00       	push   $0x28520
     805:	e8 05 37 00 00       	call   3f0f <open>
     80a:	83 c4 10             	add    $0x10,%esp
     80d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    close(fd);
     810:	83 ec 0c             	sub    $0xc,%esp
     813:	ff 75 f0             	pushl  -0x10(%ebp)
     816:	e8 dc 36 00 00       	call   3ef7 <close>
     81b:	83 c4 10             	add    $0x10,%esp

  printf(stdout, "many creates, followed by unlink test\n");

  name[0] = 'a';
  name[2] = '\0';
  for(i = 0; i < 52; i++){
     81e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     822:	83 7d f4 33          	cmpl   $0x33,-0xc(%ebp)
     826:	7e c5                	jle    7ed <createtest+0x33>
    name[1] = '0' + i;
    fd = open(name, O_CREATE|O_RDWR);
    close(fd);
  }
  name[0] = 'a';
     828:	c6 05 20 85 02 00 61 	movb   $0x61,0x28520
  name[2] = '\0';
     82f:	c6 05 22 85 02 00 00 	movb   $0x0,0x28522
  for(i = 0; i < 52; i++){
     836:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     83d:	eb 1f                	jmp    85e <createtest+0xa4>
    name[1] = '0' + i;
     83f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     842:	83 c0 30             	add    $0x30,%eax
     845:	a2 21 85 02 00       	mov    %al,0x28521
    unlink(name);
     84a:	83 ec 0c             	sub    $0xc,%esp
     84d:	68 20 85 02 00       	push   $0x28520
     852:	e8 c8 36 00 00       	call   3f1f <unlink>
     857:	83 c4 10             	add    $0x10,%esp
    fd = open(name, O_CREATE|O_RDWR);
    close(fd);
  }
  name[0] = 'a';
  name[2] = '\0';
  for(i = 0; i < 52; i++){
     85a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     85e:	83 7d f4 33          	cmpl   $0x33,-0xc(%ebp)
     862:	7e db                	jle    83f <createtest+0x85>
    name[1] = '0' + i;
    unlink(name);
  }
  printf(stdout, "many creates, followed by unlink; ok\n");
     864:	a1 14 39 02 00       	mov    0x23914,%eax
     869:	83 ec 08             	sub    $0x8,%esp
     86c:	68 94 9d 01 00       	push   $0x19d94
     871:	50                   	push   %eax
     872:	e8 ff 37 00 00       	call   4076 <printf>
     877:	83 c4 10             	add    $0x10,%esp
}
     87a:	90                   	nop
     87b:	c9                   	leave  
     87c:	c3                   	ret    

0000087d <dirtest>:

void dirtest(void)
{
     87d:	55                   	push   %ebp
     87e:	89 e5                	mov    %esp,%ebp
     880:	83 ec 08             	sub    $0x8,%esp
  printf(stdout, "mkdir test\n");
     883:	a1 14 39 02 00       	mov    0x23914,%eax
     888:	83 ec 08             	sub    $0x8,%esp
     88b:	68 ba 9d 01 00       	push   $0x19dba
     890:	50                   	push   %eax
     891:	e8 e0 37 00 00       	call   4076 <printf>
     896:	83 c4 10             	add    $0x10,%esp

  if(mkdir("dir0") < 0){
     899:	83 ec 0c             	sub    $0xc,%esp
     89c:	68 c6 9d 01 00       	push   $0x19dc6
     8a1:	e8 91 36 00 00       	call   3f37 <mkdir>
     8a6:	83 c4 10             	add    $0x10,%esp
     8a9:	85 c0                	test   %eax,%eax
     8ab:	79 1b                	jns    8c8 <dirtest+0x4b>
    printf(stdout, "mkdir failed\n");
     8ad:	a1 14 39 02 00       	mov    0x23914,%eax
     8b2:	83 ec 08             	sub    $0x8,%esp
     8b5:	68 e9 99 01 00       	push   $0x199e9
     8ba:	50                   	push   %eax
     8bb:	e8 b6 37 00 00       	call   4076 <printf>
     8c0:	83 c4 10             	add    $0x10,%esp
    exit();
     8c3:	e8 07 36 00 00       	call   3ecf <exit>
  }

  if(chdir("dir0") < 0){
     8c8:	83 ec 0c             	sub    $0xc,%esp
     8cb:	68 c6 9d 01 00       	push   $0x19dc6
     8d0:	e8 6a 36 00 00       	call   3f3f <chdir>
     8d5:	83 c4 10             	add    $0x10,%esp
     8d8:	85 c0                	test   %eax,%eax
     8da:	79 1b                	jns    8f7 <dirtest+0x7a>
    printf(stdout, "chdir dir0 failed\n");
     8dc:	a1 14 39 02 00       	mov    0x23914,%eax
     8e1:	83 ec 08             	sub    $0x8,%esp
     8e4:	68 cb 9d 01 00       	push   $0x19dcb
     8e9:	50                   	push   %eax
     8ea:	e8 87 37 00 00       	call   4076 <printf>
     8ef:	83 c4 10             	add    $0x10,%esp
    exit();
     8f2:	e8 d8 35 00 00       	call   3ecf <exit>
  }

  if(chdir("..") < 0){
     8f7:	83 ec 0c             	sub    $0xc,%esp
     8fa:	68 de 9d 01 00       	push   $0x19dde
     8ff:	e8 3b 36 00 00       	call   3f3f <chdir>
     904:	83 c4 10             	add    $0x10,%esp
     907:	85 c0                	test   %eax,%eax
     909:	79 1b                	jns    926 <dirtest+0xa9>
    printf(stdout, "chdir .. failed\n");
     90b:	a1 14 39 02 00       	mov    0x23914,%eax
     910:	83 ec 08             	sub    $0x8,%esp
     913:	68 e1 9d 01 00       	push   $0x19de1
     918:	50                   	push   %eax
     919:	e8 58 37 00 00       	call   4076 <printf>
     91e:	83 c4 10             	add    $0x10,%esp
    exit();
     921:	e8 a9 35 00 00       	call   3ecf <exit>
  }

  if(unlink("dir0") < 0){
     926:	83 ec 0c             	sub    $0xc,%esp
     929:	68 c6 9d 01 00       	push   $0x19dc6
     92e:	e8 ec 35 00 00       	call   3f1f <unlink>
     933:	83 c4 10             	add    $0x10,%esp
     936:	85 c0                	test   %eax,%eax
     938:	79 1b                	jns    955 <dirtest+0xd8>
    printf(stdout, "unlink dir0 failed\n");
     93a:	a1 14 39 02 00       	mov    0x23914,%eax
     93f:	83 ec 08             	sub    $0x8,%esp
     942:	68 f2 9d 01 00       	push   $0x19df2
     947:	50                   	push   %eax
     948:	e8 29 37 00 00       	call   4076 <printf>
     94d:	83 c4 10             	add    $0x10,%esp
    exit();
     950:	e8 7a 35 00 00       	call   3ecf <exit>
  }
  printf(stdout, "mkdir test ok\n");
     955:	a1 14 39 02 00       	mov    0x23914,%eax
     95a:	83 ec 08             	sub    $0x8,%esp
     95d:	68 06 9e 01 00       	push   $0x19e06
     962:	50                   	push   %eax
     963:	e8 0e 37 00 00       	call   4076 <printf>
     968:	83 c4 10             	add    $0x10,%esp
}
     96b:	90                   	nop
     96c:	c9                   	leave  
     96d:	c3                   	ret    

0000096e <exectest>:

void
exectest(void)
{
     96e:	55                   	push   %ebp
     96f:	89 e5                	mov    %esp,%ebp
     971:	83 ec 08             	sub    $0x8,%esp
  printf(stdout, "exec test\n");
     974:	a1 14 39 02 00       	mov    0x23914,%eax
     979:	83 ec 08             	sub    $0x8,%esp
     97c:	68 15 9e 01 00       	push   $0x19e15
     981:	50                   	push   %eax
     982:	e8 ef 36 00 00       	call   4076 <printf>
     987:	83 c4 10             	add    $0x10,%esp
  if(exec("echo", echoargv) < 0){
     98a:	83 ec 08             	sub    $0x8,%esp
     98d:	68 00 39 02 00       	push   $0x23900
     992:	68 c0 99 01 00       	push   $0x199c0
     997:	e8 6b 35 00 00       	call   3f07 <exec>
     99c:	83 c4 10             	add    $0x10,%esp
     99f:	85 c0                	test   %eax,%eax
     9a1:	79 1b                	jns    9be <exectest+0x50>
    printf(stdout, "exec echo failed\n");
     9a3:	a1 14 39 02 00       	mov    0x23914,%eax
     9a8:	83 ec 08             	sub    $0x8,%esp
     9ab:	68 20 9e 01 00       	push   $0x19e20
     9b0:	50                   	push   %eax
     9b1:	e8 c0 36 00 00       	call   4076 <printf>
     9b6:	83 c4 10             	add    $0x10,%esp
    exit();
     9b9:	e8 11 35 00 00       	call   3ecf <exit>
  }
}
     9be:	90                   	nop
     9bf:	c9                   	leave  
     9c0:	c3                   	ret    

000009c1 <pipe1>:

// simple fork and pipe read/write

void
pipe1(void)
{
     9c1:	55                   	push   %ebp
     9c2:	89 e5                	mov    %esp,%ebp
     9c4:	83 ec 28             	sub    $0x28,%esp
  int fds[2], pid;
  int seq, i, n, cc, total;

  if(pipe(fds) != 0){
     9c7:	83 ec 0c             	sub    $0xc,%esp
     9ca:	8d 45 d8             	lea    -0x28(%ebp),%eax
     9cd:	50                   	push   %eax
     9ce:	e8 0c 35 00 00       	call   3edf <pipe>
     9d3:	83 c4 10             	add    $0x10,%esp
     9d6:	85 c0                	test   %eax,%eax
     9d8:	74 17                	je     9f1 <pipe1+0x30>
    printf(1, "pipe() failed\n");
     9da:	83 ec 08             	sub    $0x8,%esp
     9dd:	68 32 9e 01 00       	push   $0x19e32
     9e2:	6a 01                	push   $0x1
     9e4:	e8 8d 36 00 00       	call   4076 <printf>
     9e9:	83 c4 10             	add    $0x10,%esp
    exit();
     9ec:	e8 de 34 00 00       	call   3ecf <exit>
  }
  pid = fork();
     9f1:	e8 d1 34 00 00       	call   3ec7 <fork>
     9f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  seq = 0;
     9f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  if(pid == 0){
     a00:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
     a04:	0f 85 89 00 00 00    	jne    a93 <pipe1+0xd2>
    close(fds[0]);
     a0a:	8b 45 d8             	mov    -0x28(%ebp),%eax
     a0d:	83 ec 0c             	sub    $0xc,%esp
     a10:	50                   	push   %eax
     a11:	e8 e1 34 00 00       	call   3ef7 <close>
     a16:	83 c4 10             	add    $0x10,%esp
    for(n = 0; n < 5; n++){
     a19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
     a20:	eb 66                	jmp    a88 <pipe1+0xc7>
      for(i = 0; i < 1033; i++)
     a22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     a29:	eb 19                	jmp    a44 <pipe1+0x83>
        buf[i] = seq++;
     a2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a2e:	8d 50 01             	lea    0x1(%eax),%edx
     a31:	89 55 f4             	mov    %edx,-0xc(%ebp)
     a34:	89 c2                	mov    %eax,%edx
     a36:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a39:	05 20 65 02 00       	add    $0x26520,%eax
     a3e:	88 10                	mov    %dl,(%eax)
  pid = fork();
  seq = 0;
  if(pid == 0){
    close(fds[0]);
    for(n = 0; n < 5; n++){
      for(i = 0; i < 1033; i++)
     a40:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     a44:	81 7d f0 08 04 00 00 	cmpl   $0x408,-0x10(%ebp)
     a4b:	7e de                	jle    a2b <pipe1+0x6a>
        buf[i] = seq++;
      if(write(fds[1], buf, 1033) != 1033){
     a4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
     a50:	83 ec 04             	sub    $0x4,%esp
     a53:	68 09 04 00 00       	push   $0x409
     a58:	68 20 65 02 00       	push   $0x26520
     a5d:	50                   	push   %eax
     a5e:	e8 8c 34 00 00       	call   3eef <write>
     a63:	83 c4 10             	add    $0x10,%esp
     a66:	3d 09 04 00 00       	cmp    $0x409,%eax
     a6b:	74 17                	je     a84 <pipe1+0xc3>
        printf(1, "pipe1 oops 1\n");
     a6d:	83 ec 08             	sub    $0x8,%esp
     a70:	68 41 9e 01 00       	push   $0x19e41
     a75:	6a 01                	push   $0x1
     a77:	e8 fa 35 00 00       	call   4076 <printf>
     a7c:	83 c4 10             	add    $0x10,%esp
        exit();
     a7f:	e8 4b 34 00 00       	call   3ecf <exit>
  }
  pid = fork();
  seq = 0;
  if(pid == 0){
    close(fds[0]);
    for(n = 0; n < 5; n++){
     a84:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
     a88:	83 7d ec 04          	cmpl   $0x4,-0x14(%ebp)
     a8c:	7e 94                	jle    a22 <pipe1+0x61>
      if(write(fds[1], buf, 1033) != 1033){
        printf(1, "pipe1 oops 1\n");
        exit();
      }
    }
    exit();
     a8e:	e8 3c 34 00 00       	call   3ecf <exit>
  } else if(pid > 0){
     a93:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
     a97:	0f 8e f4 00 00 00    	jle    b91 <pipe1+0x1d0>
    close(fds[1]);
     a9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
     aa0:	83 ec 0c             	sub    $0xc,%esp
     aa3:	50                   	push   %eax
     aa4:	e8 4e 34 00 00       	call   3ef7 <close>
     aa9:	83 c4 10             	add    $0x10,%esp
    total = 0;
     aac:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    cc = 1;
     ab3:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    while((n = read(fds[0], buf, cc)) > 0){
     aba:	eb 66                	jmp    b22 <pipe1+0x161>
      for(i = 0; i < n; i++){
     abc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     ac3:	eb 3b                	jmp    b00 <pipe1+0x13f>
        if((buf[i] & 0xff) != (seq++ & 0xff)){
     ac5:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ac8:	05 20 65 02 00       	add    $0x26520,%eax
     acd:	0f b6 00             	movzbl (%eax),%eax
     ad0:	0f be c8             	movsbl %al,%ecx
     ad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ad6:	8d 50 01             	lea    0x1(%eax),%edx
     ad9:	89 55 f4             	mov    %edx,-0xc(%ebp)
     adc:	31 c8                	xor    %ecx,%eax
     ade:	0f b6 c0             	movzbl %al,%eax
     ae1:	85 c0                	test   %eax,%eax
     ae3:	74 17                	je     afc <pipe1+0x13b>
          printf(1, "pipe1 oops 2\n");
     ae5:	83 ec 08             	sub    $0x8,%esp
     ae8:	68 4f 9e 01 00       	push   $0x19e4f
     aed:	6a 01                	push   $0x1
     aef:	e8 82 35 00 00       	call   4076 <printf>
     af4:	83 c4 10             	add    $0x10,%esp
     af7:	e9 ac 00 00 00       	jmp    ba8 <pipe1+0x1e7>
  } else if(pid > 0){
    close(fds[1]);
    total = 0;
    cc = 1;
    while((n = read(fds[0], buf, cc)) > 0){
      for(i = 0; i < n; i++){
     afc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     b00:	8b 45 f0             	mov    -0x10(%ebp),%eax
     b03:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     b06:	7c bd                	jl     ac5 <pipe1+0x104>
        if((buf[i] & 0xff) != (seq++ & 0xff)){
          printf(1, "pipe1 oops 2\n");
          return;
        }
      }
      total += n;
     b08:	8b 45 ec             	mov    -0x14(%ebp),%eax
     b0b:	01 45 e4             	add    %eax,-0x1c(%ebp)
      cc = cc * 2;
     b0e:	d1 65 e8             	shll   -0x18(%ebp)
      if(cc > sizeof(buf))
     b11:	8b 45 e8             	mov    -0x18(%ebp),%eax
     b14:	3d 00 20 00 00       	cmp    $0x2000,%eax
     b19:	76 07                	jbe    b22 <pipe1+0x161>
        cc = sizeof(buf);
     b1b:	c7 45 e8 00 20 00 00 	movl   $0x2000,-0x18(%ebp)
    exit();
  } else if(pid > 0){
    close(fds[1]);
    total = 0;
    cc = 1;
    while((n = read(fds[0], buf, cc)) > 0){
     b22:	8b 45 d8             	mov    -0x28(%ebp),%eax
     b25:	83 ec 04             	sub    $0x4,%esp
     b28:	ff 75 e8             	pushl  -0x18(%ebp)
     b2b:	68 20 65 02 00       	push   $0x26520
     b30:	50                   	push   %eax
     b31:	e8 b1 33 00 00       	call   3ee7 <read>
     b36:	83 c4 10             	add    $0x10,%esp
     b39:	89 45 ec             	mov    %eax,-0x14(%ebp)
     b3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     b40:	0f 8f 76 ff ff ff    	jg     abc <pipe1+0xfb>
      total += n;
      cc = cc * 2;
      if(cc > sizeof(buf))
        cc = sizeof(buf);
    }
    if(total != 5 * 1033){
     b46:	81 7d e4 2d 14 00 00 	cmpl   $0x142d,-0x1c(%ebp)
     b4d:	74 1a                	je     b69 <pipe1+0x1a8>
      printf(1, "pipe1 oops 3 total %d\n", total);
     b4f:	83 ec 04             	sub    $0x4,%esp
     b52:	ff 75 e4             	pushl  -0x1c(%ebp)
     b55:	68 5d 9e 01 00       	push   $0x19e5d
     b5a:	6a 01                	push   $0x1
     b5c:	e8 15 35 00 00       	call   4076 <printf>
     b61:	83 c4 10             	add    $0x10,%esp
      exit();
     b64:	e8 66 33 00 00       	call   3ecf <exit>
    }
    close(fds[0]);
     b69:	8b 45 d8             	mov    -0x28(%ebp),%eax
     b6c:	83 ec 0c             	sub    $0xc,%esp
     b6f:	50                   	push   %eax
     b70:	e8 82 33 00 00       	call   3ef7 <close>
     b75:	83 c4 10             	add    $0x10,%esp
    wait();
     b78:	e8 5a 33 00 00       	call   3ed7 <wait>
  } else {
    printf(1, "fork() failed\n");
    exit();
  }
  printf(1, "pipe1 ok\n");
     b7d:	83 ec 08             	sub    $0x8,%esp
     b80:	68 83 9e 01 00       	push   $0x19e83
     b85:	6a 01                	push   $0x1
     b87:	e8 ea 34 00 00       	call   4076 <printf>
     b8c:	83 c4 10             	add    $0x10,%esp
     b8f:	eb 17                	jmp    ba8 <pipe1+0x1e7>
      exit();
    }
    close(fds[0]);
    wait();
  } else {
    printf(1, "fork() failed\n");
     b91:	83 ec 08             	sub    $0x8,%esp
     b94:	68 74 9e 01 00       	push   $0x19e74
     b99:	6a 01                	push   $0x1
     b9b:	e8 d6 34 00 00       	call   4076 <printf>
     ba0:	83 c4 10             	add    $0x10,%esp
    exit();
     ba3:	e8 27 33 00 00       	call   3ecf <exit>
  }
  printf(1, "pipe1 ok\n");
}
     ba8:	c9                   	leave  
     ba9:	c3                   	ret    

00000baa <preempt>:

// meant to be run w/ at most two CPUs
void
preempt(void)
{
     baa:	55                   	push   %ebp
     bab:	89 e5                	mov    %esp,%ebp
     bad:	83 ec 28             	sub    $0x28,%esp
  int pid1, pid2, pid3;
  int pfds[2];

  printf(1, "preempt: ");
     bb0:	83 ec 08             	sub    $0x8,%esp
     bb3:	68 8d 9e 01 00       	push   $0x19e8d
     bb8:	6a 01                	push   $0x1
     bba:	e8 b7 34 00 00       	call   4076 <printf>
     bbf:	83 c4 10             	add    $0x10,%esp
  pid1 = fork();
     bc2:	e8 00 33 00 00       	call   3ec7 <fork>
     bc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(pid1 == 0)
     bca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     bce:	75 02                	jne    bd2 <preempt+0x28>
    for(;;)
      ;
     bd0:	eb fe                	jmp    bd0 <preempt+0x26>

  pid2 = fork();
     bd2:	e8 f0 32 00 00       	call   3ec7 <fork>
     bd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(pid2 == 0)
     bda:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     bde:	75 02                	jne    be2 <preempt+0x38>
    for(;;)
      ;
     be0:	eb fe                	jmp    be0 <preempt+0x36>

  pipe(pfds);
     be2:	83 ec 0c             	sub    $0xc,%esp
     be5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
     be8:	50                   	push   %eax
     be9:	e8 f1 32 00 00       	call   3edf <pipe>
     bee:	83 c4 10             	add    $0x10,%esp
  pid3 = fork();
     bf1:	e8 d1 32 00 00       	call   3ec7 <fork>
     bf6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(pid3 == 0){
     bf9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     bfd:	75 4d                	jne    c4c <preempt+0xa2>
    close(pfds[0]);
     bff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     c02:	83 ec 0c             	sub    $0xc,%esp
     c05:	50                   	push   %eax
     c06:	e8 ec 32 00 00       	call   3ef7 <close>
     c0b:	83 c4 10             	add    $0x10,%esp
    if(write(pfds[1], "x", 1) != 1)
     c0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
     c11:	83 ec 04             	sub    $0x4,%esp
     c14:	6a 01                	push   $0x1
     c16:	68 97 9e 01 00       	push   $0x19e97
     c1b:	50                   	push   %eax
     c1c:	e8 ce 32 00 00       	call   3eef <write>
     c21:	83 c4 10             	add    $0x10,%esp
     c24:	83 f8 01             	cmp    $0x1,%eax
     c27:	74 12                	je     c3b <preempt+0x91>
      printf(1, "preempt write error");
     c29:	83 ec 08             	sub    $0x8,%esp
     c2c:	68 99 9e 01 00       	push   $0x19e99
     c31:	6a 01                	push   $0x1
     c33:	e8 3e 34 00 00       	call   4076 <printf>
     c38:	83 c4 10             	add    $0x10,%esp
    close(pfds[1]);
     c3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     c3e:	83 ec 0c             	sub    $0xc,%esp
     c41:	50                   	push   %eax
     c42:	e8 b0 32 00 00       	call   3ef7 <close>
     c47:	83 c4 10             	add    $0x10,%esp
    for(;;)
      ;
     c4a:	eb fe                	jmp    c4a <preempt+0xa0>
  }

  close(pfds[1]);
     c4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
     c4f:	83 ec 0c             	sub    $0xc,%esp
     c52:	50                   	push   %eax
     c53:	e8 9f 32 00 00       	call   3ef7 <close>
     c58:	83 c4 10             	add    $0x10,%esp
  if(read(pfds[0], buf, sizeof(buf)) != 1){
     c5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     c5e:	83 ec 04             	sub    $0x4,%esp
     c61:	68 00 20 00 00       	push   $0x2000
     c66:	68 20 65 02 00       	push   $0x26520
     c6b:	50                   	push   %eax
     c6c:	e8 76 32 00 00       	call   3ee7 <read>
     c71:	83 c4 10             	add    $0x10,%esp
     c74:	83 f8 01             	cmp    $0x1,%eax
     c77:	74 14                	je     c8d <preempt+0xe3>
    printf(1, "preempt read error");
     c79:	83 ec 08             	sub    $0x8,%esp
     c7c:	68 ad 9e 01 00       	push   $0x19ead
     c81:	6a 01                	push   $0x1
     c83:	e8 ee 33 00 00       	call   4076 <printf>
     c88:	83 c4 10             	add    $0x10,%esp
     c8b:	eb 7e                	jmp    d0b <preempt+0x161>
    return;
  }
  close(pfds[0]);
     c8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     c90:	83 ec 0c             	sub    $0xc,%esp
     c93:	50                   	push   %eax
     c94:	e8 5e 32 00 00       	call   3ef7 <close>
     c99:	83 c4 10             	add    $0x10,%esp
  printf(1, "kill... ");
     c9c:	83 ec 08             	sub    $0x8,%esp
     c9f:	68 c0 9e 01 00       	push   $0x19ec0
     ca4:	6a 01                	push   $0x1
     ca6:	e8 cb 33 00 00       	call   4076 <printf>
     cab:	83 c4 10             	add    $0x10,%esp
  kill(pid1);
     cae:	83 ec 0c             	sub    $0xc,%esp
     cb1:	ff 75 f4             	pushl  -0xc(%ebp)
     cb4:	e8 46 32 00 00       	call   3eff <kill>
     cb9:	83 c4 10             	add    $0x10,%esp
  kill(pid2);
     cbc:	83 ec 0c             	sub    $0xc,%esp
     cbf:	ff 75 f0             	pushl  -0x10(%ebp)
     cc2:	e8 38 32 00 00       	call   3eff <kill>
     cc7:	83 c4 10             	add    $0x10,%esp
  kill(pid3);
     cca:	83 ec 0c             	sub    $0xc,%esp
     ccd:	ff 75 ec             	pushl  -0x14(%ebp)
     cd0:	e8 2a 32 00 00       	call   3eff <kill>
     cd5:	83 c4 10             	add    $0x10,%esp
  printf(1, "wait... ");
     cd8:	83 ec 08             	sub    $0x8,%esp
     cdb:	68 c9 9e 01 00       	push   $0x19ec9
     ce0:	6a 01                	push   $0x1
     ce2:	e8 8f 33 00 00       	call   4076 <printf>
     ce7:	83 c4 10             	add    $0x10,%esp
  wait();
     cea:	e8 e8 31 00 00       	call   3ed7 <wait>
  wait();
     cef:	e8 e3 31 00 00       	call   3ed7 <wait>
  wait();
     cf4:	e8 de 31 00 00       	call   3ed7 <wait>
  printf(1, "preempt ok\n");
     cf9:	83 ec 08             	sub    $0x8,%esp
     cfc:	68 d2 9e 01 00       	push   $0x19ed2
     d01:	6a 01                	push   $0x1
     d03:	e8 6e 33 00 00       	call   4076 <printf>
     d08:	83 c4 10             	add    $0x10,%esp
}
     d0b:	c9                   	leave  
     d0c:	c3                   	ret    

00000d0d <exitwait>:

// try to find any races between exit and wait
void
exitwait(void)
{
     d0d:	55                   	push   %ebp
     d0e:	89 e5                	mov    %esp,%ebp
     d10:	83 ec 18             	sub    $0x18,%esp
  int i, pid;

  for(i = 0; i < 100; i++){
     d13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     d1a:	eb 4f                	jmp    d6b <exitwait+0x5e>
    pid = fork();
     d1c:	e8 a6 31 00 00       	call   3ec7 <fork>
     d21:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(pid < 0){
     d24:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     d28:	79 14                	jns    d3e <exitwait+0x31>
      printf(1, "fork failed\n");
     d2a:	83 ec 08             	sub    $0x8,%esp
     d2d:	68 61 9a 01 00       	push   $0x19a61
     d32:	6a 01                	push   $0x1
     d34:	e8 3d 33 00 00       	call   4076 <printf>
     d39:	83 c4 10             	add    $0x10,%esp
      return;
     d3c:	eb 45                	jmp    d83 <exitwait+0x76>
    }
    if(pid){
     d3e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     d42:	74 1e                	je     d62 <exitwait+0x55>
      if(wait() != pid){
     d44:	e8 8e 31 00 00       	call   3ed7 <wait>
     d49:	3b 45 f0             	cmp    -0x10(%ebp),%eax
     d4c:	74 19                	je     d67 <exitwait+0x5a>
        printf(1, "wait wrong pid\n");
     d4e:	83 ec 08             	sub    $0x8,%esp
     d51:	68 de 9e 01 00       	push   $0x19ede
     d56:	6a 01                	push   $0x1
     d58:	e8 19 33 00 00       	call   4076 <printf>
     d5d:	83 c4 10             	add    $0x10,%esp
        return;
     d60:	eb 21                	jmp    d83 <exitwait+0x76>
      }
    } else {
      exit();
     d62:	e8 68 31 00 00       	call   3ecf <exit>
void
exitwait(void)
{
  int i, pid;

  for(i = 0; i < 100; i++){
     d67:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     d6b:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
     d6f:	7e ab                	jle    d1c <exitwait+0xf>
      }
    } else {
      exit();
    }
  }
  printf(1, "exitwait ok\n");
     d71:	83 ec 08             	sub    $0x8,%esp
     d74:	68 ee 9e 01 00       	push   $0x19eee
     d79:	6a 01                	push   $0x1
     d7b:	e8 f6 32 00 00       	call   4076 <printf>
     d80:	83 c4 10             	add    $0x10,%esp
}
     d83:	c9                   	leave  
     d84:	c3                   	ret    

00000d85 <mem>:

void
mem(void)
{
     d85:	55                   	push   %ebp
     d86:	89 e5                	mov    %esp,%ebp
     d88:	83 ec 18             	sub    $0x18,%esp
  void *m1, *m2;
  int pid, ppid;

  printf(1, "mem test\n");
     d8b:	83 ec 08             	sub    $0x8,%esp
     d8e:	68 fb 9e 01 00       	push   $0x19efb
     d93:	6a 01                	push   $0x1
     d95:	e8 dc 32 00 00       	call   4076 <printf>
     d9a:	83 c4 10             	add    $0x10,%esp
  ppid = getpid();
     d9d:	e8 ad 31 00 00       	call   3f4f <getpid>
     da2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if((pid = fork()) == 0){
     da5:	e8 1d 31 00 00       	call   3ec7 <fork>
     daa:	89 45 ec             	mov    %eax,-0x14(%ebp)
     dad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     db1:	0f 85 b7 00 00 00    	jne    e6e <mem+0xe9>
    m1 = 0;
     db7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while((m2 = malloc(10001)) != 0){
     dbe:	eb 0e                	jmp    dce <mem+0x49>
      *(char**)m2 = m1;
     dc0:	8b 45 e8             	mov    -0x18(%ebp),%eax
     dc3:	8b 55 f4             	mov    -0xc(%ebp),%edx
     dc6:	89 10                	mov    %edx,(%eax)
      m1 = m2;
     dc8:	8b 45 e8             	mov    -0x18(%ebp),%eax
     dcb:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf(1, "mem test\n");
  ppid = getpid();
  if((pid = fork()) == 0){
    m1 = 0;
    while((m2 = malloc(10001)) != 0){
     dce:	83 ec 0c             	sub    $0xc,%esp
     dd1:	68 11 27 00 00       	push   $0x2711
     dd6:	e8 6e 35 00 00       	call   4349 <malloc>
     ddb:	83 c4 10             	add    $0x10,%esp
     dde:	89 45 e8             	mov    %eax,-0x18(%ebp)
     de1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
     de5:	75 d9                	jne    dc0 <mem+0x3b>
      *(char**)m2 = m1;
      m1 = m2;
    }
    while(m1){
     de7:	eb 1c                	jmp    e05 <mem+0x80>
      m2 = *(char**)m1;
     de9:	8b 45 f4             	mov    -0xc(%ebp),%eax
     dec:	8b 00                	mov    (%eax),%eax
     dee:	89 45 e8             	mov    %eax,-0x18(%ebp)
      free(m1);
     df1:	83 ec 0c             	sub    $0xc,%esp
     df4:	ff 75 f4             	pushl  -0xc(%ebp)
     df7:	e8 0b 34 00 00       	call   4207 <free>
     dfc:	83 c4 10             	add    $0x10,%esp
      m1 = m2;
     dff:	8b 45 e8             	mov    -0x18(%ebp),%eax
     e02:	89 45 f4             	mov    %eax,-0xc(%ebp)
    m1 = 0;
    while((m2 = malloc(10001)) != 0){
      *(char**)m2 = m1;
      m1 = m2;
    }
    while(m1){
     e05:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     e09:	75 de                	jne    de9 <mem+0x64>
      m2 = *(char**)m1;
      free(m1);
      m1 = m2;
    }
    m1 = malloc(1024*20);
     e0b:	83 ec 0c             	sub    $0xc,%esp
     e0e:	68 00 50 00 00       	push   $0x5000
     e13:	e8 31 35 00 00       	call   4349 <malloc>
     e18:	83 c4 10             	add    $0x10,%esp
     e1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(m1 == 0){
     e1e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     e22:	75 25                	jne    e49 <mem+0xc4>
      printf(1, "couldn't allocate mem?!!\n");
     e24:	83 ec 08             	sub    $0x8,%esp
     e27:	68 05 9f 01 00       	push   $0x19f05
     e2c:	6a 01                	push   $0x1
     e2e:	e8 43 32 00 00       	call   4076 <printf>
     e33:	83 c4 10             	add    $0x10,%esp
      kill(ppid);
     e36:	83 ec 0c             	sub    $0xc,%esp
     e39:	ff 75 f0             	pushl  -0x10(%ebp)
     e3c:	e8 be 30 00 00       	call   3eff <kill>
     e41:	83 c4 10             	add    $0x10,%esp
      exit();
     e44:	e8 86 30 00 00       	call   3ecf <exit>
    }
    free(m1);
     e49:	83 ec 0c             	sub    $0xc,%esp
     e4c:	ff 75 f4             	pushl  -0xc(%ebp)
     e4f:	e8 b3 33 00 00       	call   4207 <free>
     e54:	83 c4 10             	add    $0x10,%esp
    printf(1, "mem ok\n");
     e57:	83 ec 08             	sub    $0x8,%esp
     e5a:	68 1f 9f 01 00       	push   $0x19f1f
     e5f:	6a 01                	push   $0x1
     e61:	e8 10 32 00 00       	call   4076 <printf>
     e66:	83 c4 10             	add    $0x10,%esp
    exit();
     e69:	e8 61 30 00 00       	call   3ecf <exit>
  } else {
    wait();
     e6e:	e8 64 30 00 00       	call   3ed7 <wait>
  }
}
     e73:	90                   	nop
     e74:	c9                   	leave  
     e75:	c3                   	ret    

00000e76 <sharedfd>:

// two processes write to the same file descriptor
// is the offset shared? does inode locking work?
void
sharedfd(void)
{
     e76:	55                   	push   %ebp
     e77:	89 e5                	mov    %esp,%ebp
     e79:	83 ec 38             	sub    $0x38,%esp
  int fd, pid, i, n, nc, np;
  char buf[10];

  printf(1, "sharedfd test\n");
     e7c:	83 ec 08             	sub    $0x8,%esp
     e7f:	68 27 9f 01 00       	push   $0x19f27
     e84:	6a 01                	push   $0x1
     e86:	e8 eb 31 00 00       	call   4076 <printf>
     e8b:	83 c4 10             	add    $0x10,%esp

  unlink("sharedfd");
     e8e:	83 ec 0c             	sub    $0xc,%esp
     e91:	68 36 9f 01 00       	push   $0x19f36
     e96:	e8 84 30 00 00       	call   3f1f <unlink>
     e9b:	83 c4 10             	add    $0x10,%esp
  fd = open("sharedfd", O_CREATE|O_RDWR);
     e9e:	83 ec 08             	sub    $0x8,%esp
     ea1:	68 02 02 00 00       	push   $0x202
     ea6:	68 36 9f 01 00       	push   $0x19f36
     eab:	e8 5f 30 00 00       	call   3f0f <open>
     eb0:	83 c4 10             	add    $0x10,%esp
     eb3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(fd < 0){
     eb6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
     eba:	79 17                	jns    ed3 <sharedfd+0x5d>
    printf(1, "fstests: cannot open sharedfd for writing");
     ebc:	83 ec 08             	sub    $0x8,%esp
     ebf:	68 40 9f 01 00       	push   $0x19f40
     ec4:	6a 01                	push   $0x1
     ec6:	e8 ab 31 00 00       	call   4076 <printf>
     ecb:	83 c4 10             	add    $0x10,%esp
    return;
     ece:	e9 84 01 00 00       	jmp    1057 <sharedfd+0x1e1>
  }
  pid = fork();
     ed3:	e8 ef 2f 00 00       	call   3ec7 <fork>
     ed8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  memset(buf, pid==0?'c':'p', sizeof(buf));
     edb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
     edf:	75 07                	jne    ee8 <sharedfd+0x72>
     ee1:	b8 63 00 00 00       	mov    $0x63,%eax
     ee6:	eb 05                	jmp    eed <sharedfd+0x77>
     ee8:	b8 70 00 00 00       	mov    $0x70,%eax
     eed:	83 ec 04             	sub    $0x4,%esp
     ef0:	6a 0a                	push   $0xa
     ef2:	50                   	push   %eax
     ef3:	8d 45 d6             	lea    -0x2a(%ebp),%eax
     ef6:	50                   	push   %eax
     ef7:	e8 38 2e 00 00       	call   3d34 <memset>
     efc:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < 1000; i++){
     eff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     f06:	eb 31                	jmp    f39 <sharedfd+0xc3>
    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
     f08:	83 ec 04             	sub    $0x4,%esp
     f0b:	6a 0a                	push   $0xa
     f0d:	8d 45 d6             	lea    -0x2a(%ebp),%eax
     f10:	50                   	push   %eax
     f11:	ff 75 e8             	pushl  -0x18(%ebp)
     f14:	e8 d6 2f 00 00       	call   3eef <write>
     f19:	83 c4 10             	add    $0x10,%esp
     f1c:	83 f8 0a             	cmp    $0xa,%eax
     f1f:	74 14                	je     f35 <sharedfd+0xbf>
      printf(1, "fstests: write sharedfd failed\n");
     f21:	83 ec 08             	sub    $0x8,%esp
     f24:	68 6c 9f 01 00       	push   $0x19f6c
     f29:	6a 01                	push   $0x1
     f2b:	e8 46 31 00 00       	call   4076 <printf>
     f30:	83 c4 10             	add    $0x10,%esp
      break;
     f33:	eb 0d                	jmp    f42 <sharedfd+0xcc>
    printf(1, "fstests: cannot open sharedfd for writing");
    return;
  }
  pid = fork();
  memset(buf, pid==0?'c':'p', sizeof(buf));
  for(i = 0; i < 1000; i++){
     f35:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     f39:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
     f40:	7e c6                	jle    f08 <sharedfd+0x92>
    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
      printf(1, "fstests: write sharedfd failed\n");
      break;
    }
  }
  if(pid == 0)
     f42:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
     f46:	75 05                	jne    f4d <sharedfd+0xd7>
    exit();
     f48:	e8 82 2f 00 00       	call   3ecf <exit>
  else
    wait();
     f4d:	e8 85 2f 00 00       	call   3ed7 <wait>
  close(fd);
     f52:	83 ec 0c             	sub    $0xc,%esp
     f55:	ff 75 e8             	pushl  -0x18(%ebp)
     f58:	e8 9a 2f 00 00       	call   3ef7 <close>
     f5d:	83 c4 10             	add    $0x10,%esp
  fd = open("sharedfd", 0);
     f60:	83 ec 08             	sub    $0x8,%esp
     f63:	6a 00                	push   $0x0
     f65:	68 36 9f 01 00       	push   $0x19f36
     f6a:	e8 a0 2f 00 00       	call   3f0f <open>
     f6f:	83 c4 10             	add    $0x10,%esp
     f72:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(fd < 0){
     f75:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
     f79:	79 17                	jns    f92 <sharedfd+0x11c>
    printf(1, "fstests: cannot open sharedfd for reading\n");
     f7b:	83 ec 08             	sub    $0x8,%esp
     f7e:	68 8c 9f 01 00       	push   $0x19f8c
     f83:	6a 01                	push   $0x1
     f85:	e8 ec 30 00 00       	call   4076 <printf>
     f8a:	83 c4 10             	add    $0x10,%esp
    return;
     f8d:	e9 c5 00 00 00       	jmp    1057 <sharedfd+0x1e1>
  }
  nc = np = 0;
     f92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
     f99:	8b 45 ec             	mov    -0x14(%ebp),%eax
     f9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while((n = read(fd, buf, sizeof(buf))) > 0){
     f9f:	eb 3b                	jmp    fdc <sharedfd+0x166>
    for(i = 0; i < sizeof(buf); i++){
     fa1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     fa8:	eb 2a                	jmp    fd4 <sharedfd+0x15e>
      if(buf[i] == 'c')
     faa:	8d 55 d6             	lea    -0x2a(%ebp),%edx
     fad:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fb0:	01 d0                	add    %edx,%eax
     fb2:	0f b6 00             	movzbl (%eax),%eax
     fb5:	3c 63                	cmp    $0x63,%al
     fb7:	75 04                	jne    fbd <sharedfd+0x147>
        nc++;
     fb9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
      if(buf[i] == 'p')
     fbd:	8d 55 d6             	lea    -0x2a(%ebp),%edx
     fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fc3:	01 d0                	add    %edx,%eax
     fc5:	0f b6 00             	movzbl (%eax),%eax
     fc8:	3c 70                	cmp    $0x70,%al
     fca:	75 04                	jne    fd0 <sharedfd+0x15a>
        np++;
     fcc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    printf(1, "fstests: cannot open sharedfd for reading\n");
    return;
  }
  nc = np = 0;
  while((n = read(fd, buf, sizeof(buf))) > 0){
    for(i = 0; i < sizeof(buf); i++){
     fd0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fd7:	83 f8 09             	cmp    $0x9,%eax
     fda:	76 ce                	jbe    faa <sharedfd+0x134>
  if(fd < 0){
    printf(1, "fstests: cannot open sharedfd for reading\n");
    return;
  }
  nc = np = 0;
  while((n = read(fd, buf, sizeof(buf))) > 0){
     fdc:	83 ec 04             	sub    $0x4,%esp
     fdf:	6a 0a                	push   $0xa
     fe1:	8d 45 d6             	lea    -0x2a(%ebp),%eax
     fe4:	50                   	push   %eax
     fe5:	ff 75 e8             	pushl  -0x18(%ebp)
     fe8:	e8 fa 2e 00 00       	call   3ee7 <read>
     fed:	83 c4 10             	add    $0x10,%esp
     ff0:	89 45 e0             	mov    %eax,-0x20(%ebp)
     ff3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
     ff7:	7f a8                	jg     fa1 <sharedfd+0x12b>
        nc++;
      if(buf[i] == 'p')
        np++;
    }
  }
  close(fd);
     ff9:	83 ec 0c             	sub    $0xc,%esp
     ffc:	ff 75 e8             	pushl  -0x18(%ebp)
     fff:	e8 f3 2e 00 00       	call   3ef7 <close>
    1004:	83 c4 10             	add    $0x10,%esp
  unlink("sharedfd");
    1007:	83 ec 0c             	sub    $0xc,%esp
    100a:	68 36 9f 01 00       	push   $0x19f36
    100f:	e8 0b 2f 00 00       	call   3f1f <unlink>
    1014:	83 c4 10             	add    $0x10,%esp
  if(nc == 10000 && np == 10000){
    1017:	81 7d f0 10 27 00 00 	cmpl   $0x2710,-0x10(%ebp)
    101e:	75 1d                	jne    103d <sharedfd+0x1c7>
    1020:	81 7d ec 10 27 00 00 	cmpl   $0x2710,-0x14(%ebp)
    1027:	75 14                	jne    103d <sharedfd+0x1c7>
    printf(1, "sharedfd ok\n");
    1029:	83 ec 08             	sub    $0x8,%esp
    102c:	68 b7 9f 01 00       	push   $0x19fb7
    1031:	6a 01                	push   $0x1
    1033:	e8 3e 30 00 00       	call   4076 <printf>
    1038:	83 c4 10             	add    $0x10,%esp
    103b:	eb 1a                	jmp    1057 <sharedfd+0x1e1>
  } else {
    printf(1, "sharedfd oops %d %d\n", nc, np);
    103d:	ff 75 ec             	pushl  -0x14(%ebp)
    1040:	ff 75 f0             	pushl  -0x10(%ebp)
    1043:	68 c4 9f 01 00       	push   $0x19fc4
    1048:	6a 01                	push   $0x1
    104a:	e8 27 30 00 00       	call   4076 <printf>
    104f:	83 c4 10             	add    $0x10,%esp
    exit();
    1052:	e8 78 2e 00 00       	call   3ecf <exit>
  }
}
    1057:	c9                   	leave  
    1058:	c3                   	ret    

00001059 <fourfiles>:

// four processes write different files at the same
// time, to test block allocation.
void
fourfiles(void)
{
    1059:	55                   	push   %ebp
    105a:	89 e5                	mov    %esp,%ebp
    105c:	83 ec 38             	sub    $0x38,%esp
  int fd, pid, i, j, n, total, pi;
  char *names[] = { "f0", "f1", "f2", "f3" };
    105f:	c7 45 c8 d9 9f 01 00 	movl   $0x19fd9,-0x38(%ebp)
    1066:	c7 45 cc dc 9f 01 00 	movl   $0x19fdc,-0x34(%ebp)
    106d:	c7 45 d0 df 9f 01 00 	movl   $0x19fdf,-0x30(%ebp)
    1074:	c7 45 d4 e2 9f 01 00 	movl   $0x19fe2,-0x2c(%ebp)
  char *fname;

  printf(1, "fourfiles test\n");
    107b:	83 ec 08             	sub    $0x8,%esp
    107e:	68 e5 9f 01 00       	push   $0x19fe5
    1083:	6a 01                	push   $0x1
    1085:	e8 ec 2f 00 00       	call   4076 <printf>
    108a:	83 c4 10             	add    $0x10,%esp

  for(pi = 0; pi < 4; pi++){
    108d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    1094:	e9 f0 00 00 00       	jmp    1189 <fourfiles+0x130>
    fname = names[pi];
    1099:	8b 45 e8             	mov    -0x18(%ebp),%eax
    109c:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
    10a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unlink(fname);
    10a3:	83 ec 0c             	sub    $0xc,%esp
    10a6:	ff 75 e4             	pushl  -0x1c(%ebp)
    10a9:	e8 71 2e 00 00       	call   3f1f <unlink>
    10ae:	83 c4 10             	add    $0x10,%esp

    pid = fork();
    10b1:	e8 11 2e 00 00       	call   3ec7 <fork>
    10b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(pid < 0){
    10b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    10bd:	79 17                	jns    10d6 <fourfiles+0x7d>
      printf(1, "fork failed\n");
    10bf:	83 ec 08             	sub    $0x8,%esp
    10c2:	68 61 9a 01 00       	push   $0x19a61
    10c7:	6a 01                	push   $0x1
    10c9:	e8 a8 2f 00 00       	call   4076 <printf>
    10ce:	83 c4 10             	add    $0x10,%esp
      exit();
    10d1:	e8 f9 2d 00 00       	call   3ecf <exit>
    }

    if(pid == 0){
    10d6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    10da:	0f 85 a5 00 00 00    	jne    1185 <fourfiles+0x12c>
      fd = open(fname, O_CREATE | O_RDWR);
    10e0:	83 ec 08             	sub    $0x8,%esp
    10e3:	68 02 02 00 00       	push   $0x202
    10e8:	ff 75 e4             	pushl  -0x1c(%ebp)
    10eb:	e8 1f 2e 00 00       	call   3f0f <open>
    10f0:	83 c4 10             	add    $0x10,%esp
    10f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
      if(fd < 0){
    10f6:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    10fa:	79 17                	jns    1113 <fourfiles+0xba>
        printf(1, "create failed\n");
    10fc:	83 ec 08             	sub    $0x8,%esp
    10ff:	68 f5 9f 01 00       	push   $0x19ff5
    1104:	6a 01                	push   $0x1
    1106:	e8 6b 2f 00 00       	call   4076 <printf>
    110b:	83 c4 10             	add    $0x10,%esp
        exit();
    110e:	e8 bc 2d 00 00       	call   3ecf <exit>
      }
      
      memset(buf, '0'+pi, 512);
    1113:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1116:	83 c0 30             	add    $0x30,%eax
    1119:	83 ec 04             	sub    $0x4,%esp
    111c:	68 00 02 00 00       	push   $0x200
    1121:	50                   	push   %eax
    1122:	68 20 65 02 00       	push   $0x26520
    1127:	e8 08 2c 00 00       	call   3d34 <memset>
    112c:	83 c4 10             	add    $0x10,%esp
      for(i = 0; i < 12; i++){
    112f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1136:	eb 42                	jmp    117a <fourfiles+0x121>
        if((n = write(fd, buf, 500)) != 500){
    1138:	83 ec 04             	sub    $0x4,%esp
    113b:	68 f4 01 00 00       	push   $0x1f4
    1140:	68 20 65 02 00       	push   $0x26520
    1145:	ff 75 dc             	pushl  -0x24(%ebp)
    1148:	e8 a2 2d 00 00       	call   3eef <write>
    114d:	83 c4 10             	add    $0x10,%esp
    1150:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1153:	81 7d d8 f4 01 00 00 	cmpl   $0x1f4,-0x28(%ebp)
    115a:	74 1a                	je     1176 <fourfiles+0x11d>
          printf(1, "write failed %d\n", n);
    115c:	83 ec 04             	sub    $0x4,%esp
    115f:	ff 75 d8             	pushl  -0x28(%ebp)
    1162:	68 04 a0 01 00       	push   $0x1a004
    1167:	6a 01                	push   $0x1
    1169:	e8 08 2f 00 00       	call   4076 <printf>
    116e:	83 c4 10             	add    $0x10,%esp
          exit();
    1171:	e8 59 2d 00 00       	call   3ecf <exit>
        printf(1, "create failed\n");
        exit();
      }
      
      memset(buf, '0'+pi, 512);
      for(i = 0; i < 12; i++){
    1176:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    117a:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
    117e:	7e b8                	jle    1138 <fourfiles+0xdf>
        if((n = write(fd, buf, 500)) != 500){
          printf(1, "write failed %d\n", n);
          exit();
        }
      }
      exit();
    1180:	e8 4a 2d 00 00       	call   3ecf <exit>
  char *names[] = { "f0", "f1", "f2", "f3" };
  char *fname;

  printf(1, "fourfiles test\n");

  for(pi = 0; pi < 4; pi++){
    1185:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    1189:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    118d:	0f 8e 06 ff ff ff    	jle    1099 <fourfiles+0x40>
      }
      exit();
    }
  }

  for(pi = 0; pi < 4; pi++){
    1193:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    119a:	eb 09                	jmp    11a5 <fourfiles+0x14c>
    wait();
    119c:	e8 36 2d 00 00       	call   3ed7 <wait>
      }
      exit();
    }
  }

  for(pi = 0; pi < 4; pi++){
    11a1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    11a5:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    11a9:	7e f1                	jle    119c <fourfiles+0x143>
    wait();
  }

  for(i = 0; i < 2; i++){
    11ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    11b2:	e9 d4 00 00 00       	jmp    128b <fourfiles+0x232>
    fname = names[i];
    11b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    11ba:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
    11be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    fd = open(fname, 0);
    11c1:	83 ec 08             	sub    $0x8,%esp
    11c4:	6a 00                	push   $0x0
    11c6:	ff 75 e4             	pushl  -0x1c(%ebp)
    11c9:	e8 41 2d 00 00       	call   3f0f <open>
    11ce:	83 c4 10             	add    $0x10,%esp
    11d1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    total = 0;
    11d4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while((n = read(fd, buf, sizeof(buf))) > 0){
    11db:	eb 4a                	jmp    1227 <fourfiles+0x1ce>
      for(j = 0; j < n; j++){
    11dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    11e4:	eb 33                	jmp    1219 <fourfiles+0x1c0>
        if(buf[j] != '0'+i){
    11e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    11e9:	05 20 65 02 00       	add    $0x26520,%eax
    11ee:	0f b6 00             	movzbl (%eax),%eax
    11f1:	0f be c0             	movsbl %al,%eax
    11f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    11f7:	83 c2 30             	add    $0x30,%edx
    11fa:	39 d0                	cmp    %edx,%eax
    11fc:	74 17                	je     1215 <fourfiles+0x1bc>
          printf(1, "wrong char\n");
    11fe:	83 ec 08             	sub    $0x8,%esp
    1201:	68 15 a0 01 00       	push   $0x1a015
    1206:	6a 01                	push   $0x1
    1208:	e8 69 2e 00 00       	call   4076 <printf>
    120d:	83 c4 10             	add    $0x10,%esp
          exit();
    1210:	e8 ba 2c 00 00       	call   3ecf <exit>
  for(i = 0; i < 2; i++){
    fname = names[i];
    fd = open(fname, 0);
    total = 0;
    while((n = read(fd, buf, sizeof(buf))) > 0){
      for(j = 0; j < n; j++){
    1215:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1219:	8b 45 f0             	mov    -0x10(%ebp),%eax
    121c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    121f:	7c c5                	jl     11e6 <fourfiles+0x18d>
        if(buf[j] != '0'+i){
          printf(1, "wrong char\n");
          exit();
        }
      }
      total += n;
    1221:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1224:	01 45 ec             	add    %eax,-0x14(%ebp)

  for(i = 0; i < 2; i++){
    fname = names[i];
    fd = open(fname, 0);
    total = 0;
    while((n = read(fd, buf, sizeof(buf))) > 0){
    1227:	83 ec 04             	sub    $0x4,%esp
    122a:	68 00 20 00 00       	push   $0x2000
    122f:	68 20 65 02 00       	push   $0x26520
    1234:	ff 75 dc             	pushl  -0x24(%ebp)
    1237:	e8 ab 2c 00 00       	call   3ee7 <read>
    123c:	83 c4 10             	add    $0x10,%esp
    123f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1242:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    1246:	7f 95                	jg     11dd <fourfiles+0x184>
          exit();
        }
      }
      total += n;
    }
    close(fd);
    1248:	83 ec 0c             	sub    $0xc,%esp
    124b:	ff 75 dc             	pushl  -0x24(%ebp)
    124e:	e8 a4 2c 00 00       	call   3ef7 <close>
    1253:	83 c4 10             	add    $0x10,%esp
    if(total != 12*500){
    1256:	81 7d ec 70 17 00 00 	cmpl   $0x1770,-0x14(%ebp)
    125d:	74 1a                	je     1279 <fourfiles+0x220>
      printf(1, "wrong length %d\n", total);
    125f:	83 ec 04             	sub    $0x4,%esp
    1262:	ff 75 ec             	pushl  -0x14(%ebp)
    1265:	68 21 a0 01 00       	push   $0x1a021
    126a:	6a 01                	push   $0x1
    126c:	e8 05 2e 00 00       	call   4076 <printf>
    1271:	83 c4 10             	add    $0x10,%esp
      exit();
    1274:	e8 56 2c 00 00       	call   3ecf <exit>
    }
    unlink(fname);
    1279:	83 ec 0c             	sub    $0xc,%esp
    127c:	ff 75 e4             	pushl  -0x1c(%ebp)
    127f:	e8 9b 2c 00 00       	call   3f1f <unlink>
    1284:	83 c4 10             	add    $0x10,%esp

  for(pi = 0; pi < 4; pi++){
    wait();
  }

  for(i = 0; i < 2; i++){
    1287:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    128b:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
    128f:	0f 8e 22 ff ff ff    	jle    11b7 <fourfiles+0x15e>
      exit();
    }
    unlink(fname);
  }

  printf(1, "fourfiles ok\n");
    1295:	83 ec 08             	sub    $0x8,%esp
    1298:	68 32 a0 01 00       	push   $0x1a032
    129d:	6a 01                	push   $0x1
    129f:	e8 d2 2d 00 00       	call   4076 <printf>
    12a4:	83 c4 10             	add    $0x10,%esp
}
    12a7:	90                   	nop
    12a8:	c9                   	leave  
    12a9:	c3                   	ret    

000012aa <createdelete>:

// four processes create and delete different files in same directory
void
createdelete(void)
{
    12aa:	55                   	push   %ebp
    12ab:	89 e5                	mov    %esp,%ebp
    12ad:	83 ec 38             	sub    $0x38,%esp
  enum { N = 20 };
  int pid, i, fd, pi;
  char name[32];

  printf(1, "createdelete test\n");
    12b0:	83 ec 08             	sub    $0x8,%esp
    12b3:	68 40 a0 01 00       	push   $0x1a040
    12b8:	6a 01                	push   $0x1
    12ba:	e8 b7 2d 00 00       	call   4076 <printf>
    12bf:	83 c4 10             	add    $0x10,%esp

  for(pi = 0; pi < 4; pi++){
    12c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    12c9:	e9 f6 00 00 00       	jmp    13c4 <createdelete+0x11a>
    pid = fork();
    12ce:	e8 f4 2b 00 00       	call   3ec7 <fork>
    12d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(pid < 0){
    12d6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    12da:	79 17                	jns    12f3 <createdelete+0x49>
      printf(1, "fork failed\n");
    12dc:	83 ec 08             	sub    $0x8,%esp
    12df:	68 61 9a 01 00       	push   $0x19a61
    12e4:	6a 01                	push   $0x1
    12e6:	e8 8b 2d 00 00       	call   4076 <printf>
    12eb:	83 c4 10             	add    $0x10,%esp
      exit();
    12ee:	e8 dc 2b 00 00       	call   3ecf <exit>
    }

    if(pid == 0){
    12f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    12f7:	0f 85 c3 00 00 00    	jne    13c0 <createdelete+0x116>
      name[0] = 'p' + pi;
    12fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1300:	83 c0 70             	add    $0x70,%eax
    1303:	88 45 c8             	mov    %al,-0x38(%ebp)
      name[2] = '\0';
    1306:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
      for(i = 0; i < N; i++){
    130a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1311:	e9 9b 00 00 00       	jmp    13b1 <createdelete+0x107>
        name[1] = '0' + i;
    1316:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1319:	83 c0 30             	add    $0x30,%eax
    131c:	88 45 c9             	mov    %al,-0x37(%ebp)
        fd = open(name, O_CREATE | O_RDWR);
    131f:	83 ec 08             	sub    $0x8,%esp
    1322:	68 02 02 00 00       	push   $0x202
    1327:	8d 45 c8             	lea    -0x38(%ebp),%eax
    132a:	50                   	push   %eax
    132b:	e8 df 2b 00 00       	call   3f0f <open>
    1330:	83 c4 10             	add    $0x10,%esp
    1333:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(fd < 0){
    1336:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    133a:	79 17                	jns    1353 <createdelete+0xa9>
          printf(1, "create failed\n");
    133c:	83 ec 08             	sub    $0x8,%esp
    133f:	68 f5 9f 01 00       	push   $0x19ff5
    1344:	6a 01                	push   $0x1
    1346:	e8 2b 2d 00 00       	call   4076 <printf>
    134b:	83 c4 10             	add    $0x10,%esp
          exit();
    134e:	e8 7c 2b 00 00       	call   3ecf <exit>
        }
        close(fd);
    1353:	83 ec 0c             	sub    $0xc,%esp
    1356:	ff 75 e8             	pushl  -0x18(%ebp)
    1359:	e8 99 2b 00 00       	call   3ef7 <close>
    135e:	83 c4 10             	add    $0x10,%esp
        if(i > 0 && (i % 2 ) == 0){
    1361:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1365:	7e 46                	jle    13ad <createdelete+0x103>
    1367:	8b 45 f4             	mov    -0xc(%ebp),%eax
    136a:	83 e0 01             	and    $0x1,%eax
    136d:	85 c0                	test   %eax,%eax
    136f:	75 3c                	jne    13ad <createdelete+0x103>
          name[1] = '0' + (i / 2);
    1371:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1374:	89 c2                	mov    %eax,%edx
    1376:	c1 ea 1f             	shr    $0x1f,%edx
    1379:	01 d0                	add    %edx,%eax
    137b:	d1 f8                	sar    %eax
    137d:	83 c0 30             	add    $0x30,%eax
    1380:	88 45 c9             	mov    %al,-0x37(%ebp)
          if(unlink(name) < 0){
    1383:	83 ec 0c             	sub    $0xc,%esp
    1386:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1389:	50                   	push   %eax
    138a:	e8 90 2b 00 00       	call   3f1f <unlink>
    138f:	83 c4 10             	add    $0x10,%esp
    1392:	85 c0                	test   %eax,%eax
    1394:	79 17                	jns    13ad <createdelete+0x103>
            printf(1, "unlink failed\n");
    1396:	83 ec 08             	sub    $0x8,%esp
    1399:	68 e4 9a 01 00       	push   $0x19ae4
    139e:	6a 01                	push   $0x1
    13a0:	e8 d1 2c 00 00       	call   4076 <printf>
    13a5:	83 c4 10             	add    $0x10,%esp
            exit();
    13a8:	e8 22 2b 00 00       	call   3ecf <exit>
    }

    if(pid == 0){
      name[0] = 'p' + pi;
      name[2] = '\0';
      for(i = 0; i < N; i++){
    13ad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    13b1:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
    13b5:	0f 8e 5b ff ff ff    	jle    1316 <createdelete+0x6c>
            printf(1, "unlink failed\n");
            exit();
          }
        }
      }
      exit();
    13bb:	e8 0f 2b 00 00       	call   3ecf <exit>
  int pid, i, fd, pi;
  char name[32];

  printf(1, "createdelete test\n");

  for(pi = 0; pi < 4; pi++){
    13c0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    13c4:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
    13c8:	0f 8e 00 ff ff ff    	jle    12ce <createdelete+0x24>
      }
      exit();
    }
  }

  for(pi = 0; pi < 4; pi++){
    13ce:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    13d5:	eb 09                	jmp    13e0 <createdelete+0x136>
    wait();
    13d7:	e8 fb 2a 00 00       	call   3ed7 <wait>
      }
      exit();
    }
  }

  for(pi = 0; pi < 4; pi++){
    13dc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    13e0:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
    13e4:	7e f1                	jle    13d7 <createdelete+0x12d>
    wait();
  }

  name[0] = name[1] = name[2] = 0;
    13e6:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
    13ea:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    13ee:	88 45 c9             	mov    %al,-0x37(%ebp)
    13f1:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    13f5:	88 45 c8             	mov    %al,-0x38(%ebp)
  for(i = 0; i < N; i++){
    13f8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    13ff:	e9 b2 00 00 00       	jmp    14b6 <createdelete+0x20c>
    for(pi = 0; pi < 4; pi++){
    1404:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    140b:	e9 98 00 00 00       	jmp    14a8 <createdelete+0x1fe>
      name[0] = 'p' + pi;
    1410:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1413:	83 c0 70             	add    $0x70,%eax
    1416:	88 45 c8             	mov    %al,-0x38(%ebp)
      name[1] = '0' + i;
    1419:	8b 45 f4             	mov    -0xc(%ebp),%eax
    141c:	83 c0 30             	add    $0x30,%eax
    141f:	88 45 c9             	mov    %al,-0x37(%ebp)
      fd = open(name, 0);
    1422:	83 ec 08             	sub    $0x8,%esp
    1425:	6a 00                	push   $0x0
    1427:	8d 45 c8             	lea    -0x38(%ebp),%eax
    142a:	50                   	push   %eax
    142b:	e8 df 2a 00 00       	call   3f0f <open>
    1430:	83 c4 10             	add    $0x10,%esp
    1433:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if((i == 0 || i >= N/2) && fd < 0){
    1436:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    143a:	74 06                	je     1442 <createdelete+0x198>
    143c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
    1440:	7e 21                	jle    1463 <createdelete+0x1b9>
    1442:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    1446:	79 1b                	jns    1463 <createdelete+0x1b9>
        printf(1, "oops createdelete %s didn't exist\n", name);
    1448:	83 ec 04             	sub    $0x4,%esp
    144b:	8d 45 c8             	lea    -0x38(%ebp),%eax
    144e:	50                   	push   %eax
    144f:	68 54 a0 01 00       	push   $0x1a054
    1454:	6a 01                	push   $0x1
    1456:	e8 1b 2c 00 00       	call   4076 <printf>
    145b:	83 c4 10             	add    $0x10,%esp
        exit();
    145e:	e8 6c 2a 00 00       	call   3ecf <exit>
      } else if((i >= 1 && i < N/2) && fd >= 0){
    1463:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1467:	7e 27                	jle    1490 <createdelete+0x1e6>
    1469:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
    146d:	7f 21                	jg     1490 <createdelete+0x1e6>
    146f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    1473:	78 1b                	js     1490 <createdelete+0x1e6>
        printf(1, "oops createdelete %s did exist\n", name);
    1475:	83 ec 04             	sub    $0x4,%esp
    1478:	8d 45 c8             	lea    -0x38(%ebp),%eax
    147b:	50                   	push   %eax
    147c:	68 78 a0 01 00       	push   $0x1a078
    1481:	6a 01                	push   $0x1
    1483:	e8 ee 2b 00 00       	call   4076 <printf>
    1488:	83 c4 10             	add    $0x10,%esp
        exit();
    148b:	e8 3f 2a 00 00       	call   3ecf <exit>
      }
      if(fd >= 0)
    1490:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    1494:	78 0e                	js     14a4 <createdelete+0x1fa>
        close(fd);
    1496:	83 ec 0c             	sub    $0xc,%esp
    1499:	ff 75 e8             	pushl  -0x18(%ebp)
    149c:	e8 56 2a 00 00       	call   3ef7 <close>
    14a1:	83 c4 10             	add    $0x10,%esp
    wait();
  }

  name[0] = name[1] = name[2] = 0;
  for(i = 0; i < N; i++){
    for(pi = 0; pi < 4; pi++){
    14a4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    14a8:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
    14ac:	0f 8e 5e ff ff ff    	jle    1410 <createdelete+0x166>
  for(pi = 0; pi < 4; pi++){
    wait();
  }

  name[0] = name[1] = name[2] = 0;
  for(i = 0; i < N; i++){
    14b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    14b6:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
    14ba:	0f 8e 44 ff ff ff    	jle    1404 <createdelete+0x15a>
      if(fd >= 0)
        close(fd);
    }
  }

  for(i = 0; i < N; i++){
    14c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    14c7:	eb 38                	jmp    1501 <createdelete+0x257>
    for(pi = 0; pi < 4; pi++){
    14c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    14d0:	eb 25                	jmp    14f7 <createdelete+0x24d>
      name[0] = 'p' + i;
    14d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    14d5:	83 c0 70             	add    $0x70,%eax
    14d8:	88 45 c8             	mov    %al,-0x38(%ebp)
      name[1] = '0' + i;
    14db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    14de:	83 c0 30             	add    $0x30,%eax
    14e1:	88 45 c9             	mov    %al,-0x37(%ebp)
      unlink(name);
    14e4:	83 ec 0c             	sub    $0xc,%esp
    14e7:	8d 45 c8             	lea    -0x38(%ebp),%eax
    14ea:	50                   	push   %eax
    14eb:	e8 2f 2a 00 00       	call   3f1f <unlink>
    14f0:	83 c4 10             	add    $0x10,%esp
        close(fd);
    }
  }

  for(i = 0; i < N; i++){
    for(pi = 0; pi < 4; pi++){
    14f3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    14f7:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
    14fb:	7e d5                	jle    14d2 <createdelete+0x228>
      if(fd >= 0)
        close(fd);
    }
  }

  for(i = 0; i < N; i++){
    14fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1501:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
    1505:	7e c2                	jle    14c9 <createdelete+0x21f>
      name[1] = '0' + i;
      unlink(name);
    }
  }

  printf(1, "createdelete ok\n");
    1507:	83 ec 08             	sub    $0x8,%esp
    150a:	68 98 a0 01 00       	push   $0x1a098
    150f:	6a 01                	push   $0x1
    1511:	e8 60 2b 00 00       	call   4076 <printf>
    1516:	83 c4 10             	add    $0x10,%esp
}
    1519:	90                   	nop
    151a:	c9                   	leave  
    151b:	c3                   	ret    

0000151c <unlinkread>:

// can I unlink a file and still read it?
void
unlinkread(void)
{
    151c:	55                   	push   %ebp
    151d:	89 e5                	mov    %esp,%ebp
    151f:	83 ec 18             	sub    $0x18,%esp
  int fd, fd1;

  printf(1, "unlinkread test\n");
    1522:	83 ec 08             	sub    $0x8,%esp
    1525:	68 a9 a0 01 00       	push   $0x1a0a9
    152a:	6a 01                	push   $0x1
    152c:	e8 45 2b 00 00       	call   4076 <printf>
    1531:	83 c4 10             	add    $0x10,%esp
  fd = open("unlinkread", O_CREATE | O_RDWR);
    1534:	83 ec 08             	sub    $0x8,%esp
    1537:	68 02 02 00 00       	push   $0x202
    153c:	68 ba a0 01 00       	push   $0x1a0ba
    1541:	e8 c9 29 00 00       	call   3f0f <open>
    1546:	83 c4 10             	add    $0x10,%esp
    1549:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    154c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1550:	79 17                	jns    1569 <unlinkread+0x4d>
    printf(1, "create unlinkread failed\n");
    1552:	83 ec 08             	sub    $0x8,%esp
    1555:	68 c5 a0 01 00       	push   $0x1a0c5
    155a:	6a 01                	push   $0x1
    155c:	e8 15 2b 00 00       	call   4076 <printf>
    1561:	83 c4 10             	add    $0x10,%esp
    exit();
    1564:	e8 66 29 00 00       	call   3ecf <exit>
  }
  write(fd, "hello", 5);
    1569:	83 ec 04             	sub    $0x4,%esp
    156c:	6a 05                	push   $0x5
    156e:	68 df a0 01 00       	push   $0x1a0df
    1573:	ff 75 f4             	pushl  -0xc(%ebp)
    1576:	e8 74 29 00 00       	call   3eef <write>
    157b:	83 c4 10             	add    $0x10,%esp
  close(fd);
    157e:	83 ec 0c             	sub    $0xc,%esp
    1581:	ff 75 f4             	pushl  -0xc(%ebp)
    1584:	e8 6e 29 00 00       	call   3ef7 <close>
    1589:	83 c4 10             	add    $0x10,%esp

  fd = open("unlinkread", O_RDWR);
    158c:	83 ec 08             	sub    $0x8,%esp
    158f:	6a 02                	push   $0x2
    1591:	68 ba a0 01 00       	push   $0x1a0ba
    1596:	e8 74 29 00 00       	call   3f0f <open>
    159b:	83 c4 10             	add    $0x10,%esp
    159e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    15a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    15a5:	79 17                	jns    15be <unlinkread+0xa2>
    printf(1, "open unlinkread failed\n");
    15a7:	83 ec 08             	sub    $0x8,%esp
    15aa:	68 e5 a0 01 00       	push   $0x1a0e5
    15af:	6a 01                	push   $0x1
    15b1:	e8 c0 2a 00 00       	call   4076 <printf>
    15b6:	83 c4 10             	add    $0x10,%esp
    exit();
    15b9:	e8 11 29 00 00       	call   3ecf <exit>
  }
  if(unlink("unlinkread") != 0){
    15be:	83 ec 0c             	sub    $0xc,%esp
    15c1:	68 ba a0 01 00       	push   $0x1a0ba
    15c6:	e8 54 29 00 00       	call   3f1f <unlink>
    15cb:	83 c4 10             	add    $0x10,%esp
    15ce:	85 c0                	test   %eax,%eax
    15d0:	74 17                	je     15e9 <unlinkread+0xcd>
    printf(1, "unlink unlinkread failed\n");
    15d2:	83 ec 08             	sub    $0x8,%esp
    15d5:	68 fd a0 01 00       	push   $0x1a0fd
    15da:	6a 01                	push   $0x1
    15dc:	e8 95 2a 00 00       	call   4076 <printf>
    15e1:	83 c4 10             	add    $0x10,%esp
    exit();
    15e4:	e8 e6 28 00 00       	call   3ecf <exit>
  }

  fd1 = open("unlinkread", O_CREATE | O_RDWR);
    15e9:	83 ec 08             	sub    $0x8,%esp
    15ec:	68 02 02 00 00       	push   $0x202
    15f1:	68 ba a0 01 00       	push   $0x1a0ba
    15f6:	e8 14 29 00 00       	call   3f0f <open>
    15fb:	83 c4 10             	add    $0x10,%esp
    15fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
  write(fd1, "yyy", 3);
    1601:	83 ec 04             	sub    $0x4,%esp
    1604:	6a 03                	push   $0x3
    1606:	68 17 a1 01 00       	push   $0x1a117
    160b:	ff 75 f0             	pushl  -0x10(%ebp)
    160e:	e8 dc 28 00 00       	call   3eef <write>
    1613:	83 c4 10             	add    $0x10,%esp
  close(fd1);
    1616:	83 ec 0c             	sub    $0xc,%esp
    1619:	ff 75 f0             	pushl  -0x10(%ebp)
    161c:	e8 d6 28 00 00       	call   3ef7 <close>
    1621:	83 c4 10             	add    $0x10,%esp

  if(read(fd, buf, sizeof(buf)) != 5){
    1624:	83 ec 04             	sub    $0x4,%esp
    1627:	68 00 20 00 00       	push   $0x2000
    162c:	68 20 65 02 00       	push   $0x26520
    1631:	ff 75 f4             	pushl  -0xc(%ebp)
    1634:	e8 ae 28 00 00       	call   3ee7 <read>
    1639:	83 c4 10             	add    $0x10,%esp
    163c:	83 f8 05             	cmp    $0x5,%eax
    163f:	74 17                	je     1658 <unlinkread+0x13c>
    printf(1, "unlinkread read failed");
    1641:	83 ec 08             	sub    $0x8,%esp
    1644:	68 1b a1 01 00       	push   $0x1a11b
    1649:	6a 01                	push   $0x1
    164b:	e8 26 2a 00 00       	call   4076 <printf>
    1650:	83 c4 10             	add    $0x10,%esp
    exit();
    1653:	e8 77 28 00 00       	call   3ecf <exit>
  }
  if(buf[0] != 'h'){
    1658:	0f b6 05 20 65 02 00 	movzbl 0x26520,%eax
    165f:	3c 68                	cmp    $0x68,%al
    1661:	74 17                	je     167a <unlinkread+0x15e>
    printf(1, "unlinkread wrong data\n");
    1663:	83 ec 08             	sub    $0x8,%esp
    1666:	68 32 a1 01 00       	push   $0x1a132
    166b:	6a 01                	push   $0x1
    166d:	e8 04 2a 00 00       	call   4076 <printf>
    1672:	83 c4 10             	add    $0x10,%esp
    exit();
    1675:	e8 55 28 00 00       	call   3ecf <exit>
  }
  if(write(fd, buf, 10) != 10){
    167a:	83 ec 04             	sub    $0x4,%esp
    167d:	6a 0a                	push   $0xa
    167f:	68 20 65 02 00       	push   $0x26520
    1684:	ff 75 f4             	pushl  -0xc(%ebp)
    1687:	e8 63 28 00 00       	call   3eef <write>
    168c:	83 c4 10             	add    $0x10,%esp
    168f:	83 f8 0a             	cmp    $0xa,%eax
    1692:	74 17                	je     16ab <unlinkread+0x18f>
    printf(1, "unlinkread write failed\n");
    1694:	83 ec 08             	sub    $0x8,%esp
    1697:	68 49 a1 01 00       	push   $0x1a149
    169c:	6a 01                	push   $0x1
    169e:	e8 d3 29 00 00       	call   4076 <printf>
    16a3:	83 c4 10             	add    $0x10,%esp
    exit();
    16a6:	e8 24 28 00 00       	call   3ecf <exit>
  }
  close(fd);
    16ab:	83 ec 0c             	sub    $0xc,%esp
    16ae:	ff 75 f4             	pushl  -0xc(%ebp)
    16b1:	e8 41 28 00 00       	call   3ef7 <close>
    16b6:	83 c4 10             	add    $0x10,%esp
  unlink("unlinkread");
    16b9:	83 ec 0c             	sub    $0xc,%esp
    16bc:	68 ba a0 01 00       	push   $0x1a0ba
    16c1:	e8 59 28 00 00       	call   3f1f <unlink>
    16c6:	83 c4 10             	add    $0x10,%esp
  printf(1, "unlinkread ok\n");
    16c9:	83 ec 08             	sub    $0x8,%esp
    16cc:	68 62 a1 01 00       	push   $0x1a162
    16d1:	6a 01                	push   $0x1
    16d3:	e8 9e 29 00 00       	call   4076 <printf>
    16d8:	83 c4 10             	add    $0x10,%esp
}
    16db:	90                   	nop
    16dc:	c9                   	leave  
    16dd:	c3                   	ret    

000016de <linktest>:

void
linktest(void)
{
    16de:	55                   	push   %ebp
    16df:	89 e5                	mov    %esp,%ebp
    16e1:	83 ec 18             	sub    $0x18,%esp
  int fd;

  printf(1, "linktest\n");
    16e4:	83 ec 08             	sub    $0x8,%esp
    16e7:	68 71 a1 01 00       	push   $0x1a171
    16ec:	6a 01                	push   $0x1
    16ee:	e8 83 29 00 00       	call   4076 <printf>
    16f3:	83 c4 10             	add    $0x10,%esp

  unlink("lf1");
    16f6:	83 ec 0c             	sub    $0xc,%esp
    16f9:	68 7b a1 01 00       	push   $0x1a17b
    16fe:	e8 1c 28 00 00       	call   3f1f <unlink>
    1703:	83 c4 10             	add    $0x10,%esp
  unlink("lf2");
    1706:	83 ec 0c             	sub    $0xc,%esp
    1709:	68 7f a1 01 00       	push   $0x1a17f
    170e:	e8 0c 28 00 00       	call   3f1f <unlink>
    1713:	83 c4 10             	add    $0x10,%esp

  fd = open("lf1", O_CREATE|O_RDWR);
    1716:	83 ec 08             	sub    $0x8,%esp
    1719:	68 02 02 00 00       	push   $0x202
    171e:	68 7b a1 01 00       	push   $0x1a17b
    1723:	e8 e7 27 00 00       	call   3f0f <open>
    1728:	83 c4 10             	add    $0x10,%esp
    172b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    172e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1732:	79 17                	jns    174b <linktest+0x6d>
    printf(1, "create lf1 failed\n");
    1734:	83 ec 08             	sub    $0x8,%esp
    1737:	68 83 a1 01 00       	push   $0x1a183
    173c:	6a 01                	push   $0x1
    173e:	e8 33 29 00 00       	call   4076 <printf>
    1743:	83 c4 10             	add    $0x10,%esp
    exit();
    1746:	e8 84 27 00 00       	call   3ecf <exit>
  }
  if(write(fd, "hello", 5) != 5){
    174b:	83 ec 04             	sub    $0x4,%esp
    174e:	6a 05                	push   $0x5
    1750:	68 df a0 01 00       	push   $0x1a0df
    1755:	ff 75 f4             	pushl  -0xc(%ebp)
    1758:	e8 92 27 00 00       	call   3eef <write>
    175d:	83 c4 10             	add    $0x10,%esp
    1760:	83 f8 05             	cmp    $0x5,%eax
    1763:	74 17                	je     177c <linktest+0x9e>
    printf(1, "write lf1 failed\n");
    1765:	83 ec 08             	sub    $0x8,%esp
    1768:	68 96 a1 01 00       	push   $0x1a196
    176d:	6a 01                	push   $0x1
    176f:	e8 02 29 00 00       	call   4076 <printf>
    1774:	83 c4 10             	add    $0x10,%esp
    exit();
    1777:	e8 53 27 00 00       	call   3ecf <exit>
  }
  close(fd);
    177c:	83 ec 0c             	sub    $0xc,%esp
    177f:	ff 75 f4             	pushl  -0xc(%ebp)
    1782:	e8 70 27 00 00       	call   3ef7 <close>
    1787:	83 c4 10             	add    $0x10,%esp

  if(link("lf1", "lf2") < 0){
    178a:	83 ec 08             	sub    $0x8,%esp
    178d:	68 7f a1 01 00       	push   $0x1a17f
    1792:	68 7b a1 01 00       	push   $0x1a17b
    1797:	e8 93 27 00 00       	call   3f2f <link>
    179c:	83 c4 10             	add    $0x10,%esp
    179f:	85 c0                	test   %eax,%eax
    17a1:	79 17                	jns    17ba <linktest+0xdc>
    printf(1, "link lf1 lf2 failed\n");
    17a3:	83 ec 08             	sub    $0x8,%esp
    17a6:	68 a8 a1 01 00       	push   $0x1a1a8
    17ab:	6a 01                	push   $0x1
    17ad:	e8 c4 28 00 00       	call   4076 <printf>
    17b2:	83 c4 10             	add    $0x10,%esp
    exit();
    17b5:	e8 15 27 00 00       	call   3ecf <exit>
  }
  unlink("lf1");
    17ba:	83 ec 0c             	sub    $0xc,%esp
    17bd:	68 7b a1 01 00       	push   $0x1a17b
    17c2:	e8 58 27 00 00       	call   3f1f <unlink>
    17c7:	83 c4 10             	add    $0x10,%esp

  if(open("lf1", 0) >= 0){
    17ca:	83 ec 08             	sub    $0x8,%esp
    17cd:	6a 00                	push   $0x0
    17cf:	68 7b a1 01 00       	push   $0x1a17b
    17d4:	e8 36 27 00 00       	call   3f0f <open>
    17d9:	83 c4 10             	add    $0x10,%esp
    17dc:	85 c0                	test   %eax,%eax
    17de:	78 17                	js     17f7 <linktest+0x119>
    printf(1, "unlinked lf1 but it is still there!\n");
    17e0:	83 ec 08             	sub    $0x8,%esp
    17e3:	68 c0 a1 01 00       	push   $0x1a1c0
    17e8:	6a 01                	push   $0x1
    17ea:	e8 87 28 00 00       	call   4076 <printf>
    17ef:	83 c4 10             	add    $0x10,%esp
    exit();
    17f2:	e8 d8 26 00 00       	call   3ecf <exit>
  }

  fd = open("lf2", 0);
    17f7:	83 ec 08             	sub    $0x8,%esp
    17fa:	6a 00                	push   $0x0
    17fc:	68 7f a1 01 00       	push   $0x1a17f
    1801:	e8 09 27 00 00       	call   3f0f <open>
    1806:	83 c4 10             	add    $0x10,%esp
    1809:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    180c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1810:	79 17                	jns    1829 <linktest+0x14b>
    printf(1, "open lf2 failed\n");
    1812:	83 ec 08             	sub    $0x8,%esp
    1815:	68 e5 a1 01 00       	push   $0x1a1e5
    181a:	6a 01                	push   $0x1
    181c:	e8 55 28 00 00       	call   4076 <printf>
    1821:	83 c4 10             	add    $0x10,%esp
    exit();
    1824:	e8 a6 26 00 00       	call   3ecf <exit>
  }
  if(read(fd, buf, sizeof(buf)) != 5){
    1829:	83 ec 04             	sub    $0x4,%esp
    182c:	68 00 20 00 00       	push   $0x2000
    1831:	68 20 65 02 00       	push   $0x26520
    1836:	ff 75 f4             	pushl  -0xc(%ebp)
    1839:	e8 a9 26 00 00       	call   3ee7 <read>
    183e:	83 c4 10             	add    $0x10,%esp
    1841:	83 f8 05             	cmp    $0x5,%eax
    1844:	74 17                	je     185d <linktest+0x17f>
    printf(1, "read lf2 failed\n");
    1846:	83 ec 08             	sub    $0x8,%esp
    1849:	68 f6 a1 01 00       	push   $0x1a1f6
    184e:	6a 01                	push   $0x1
    1850:	e8 21 28 00 00       	call   4076 <printf>
    1855:	83 c4 10             	add    $0x10,%esp
    exit();
    1858:	e8 72 26 00 00       	call   3ecf <exit>
  }
  close(fd);
    185d:	83 ec 0c             	sub    $0xc,%esp
    1860:	ff 75 f4             	pushl  -0xc(%ebp)
    1863:	e8 8f 26 00 00       	call   3ef7 <close>
    1868:	83 c4 10             	add    $0x10,%esp

  if(link("lf2", "lf2") >= 0){
    186b:	83 ec 08             	sub    $0x8,%esp
    186e:	68 7f a1 01 00       	push   $0x1a17f
    1873:	68 7f a1 01 00       	push   $0x1a17f
    1878:	e8 b2 26 00 00       	call   3f2f <link>
    187d:	83 c4 10             	add    $0x10,%esp
    1880:	85 c0                	test   %eax,%eax
    1882:	78 17                	js     189b <linktest+0x1bd>
    printf(1, "link lf2 lf2 succeeded! oops\n");
    1884:	83 ec 08             	sub    $0x8,%esp
    1887:	68 07 a2 01 00       	push   $0x1a207
    188c:	6a 01                	push   $0x1
    188e:	e8 e3 27 00 00       	call   4076 <printf>
    1893:	83 c4 10             	add    $0x10,%esp
    exit();
    1896:	e8 34 26 00 00       	call   3ecf <exit>
  }

  unlink("lf2");
    189b:	83 ec 0c             	sub    $0xc,%esp
    189e:	68 7f a1 01 00       	push   $0x1a17f
    18a3:	e8 77 26 00 00       	call   3f1f <unlink>
    18a8:	83 c4 10             	add    $0x10,%esp
  if(link("lf2", "lf1") >= 0){
    18ab:	83 ec 08             	sub    $0x8,%esp
    18ae:	68 7b a1 01 00       	push   $0x1a17b
    18b3:	68 7f a1 01 00       	push   $0x1a17f
    18b8:	e8 72 26 00 00       	call   3f2f <link>
    18bd:	83 c4 10             	add    $0x10,%esp
    18c0:	85 c0                	test   %eax,%eax
    18c2:	78 17                	js     18db <linktest+0x1fd>
    printf(1, "link non-existant succeeded! oops\n");
    18c4:	83 ec 08             	sub    $0x8,%esp
    18c7:	68 28 a2 01 00       	push   $0x1a228
    18cc:	6a 01                	push   $0x1
    18ce:	e8 a3 27 00 00       	call   4076 <printf>
    18d3:	83 c4 10             	add    $0x10,%esp
    exit();
    18d6:	e8 f4 25 00 00       	call   3ecf <exit>
  }

  if(link(".", "lf1") >= 0){
    18db:	83 ec 08             	sub    $0x8,%esp
    18de:	68 7b a1 01 00       	push   $0x1a17b
    18e3:	68 4b a2 01 00       	push   $0x1a24b
    18e8:	e8 42 26 00 00       	call   3f2f <link>
    18ed:	83 c4 10             	add    $0x10,%esp
    18f0:	85 c0                	test   %eax,%eax
    18f2:	78 17                	js     190b <linktest+0x22d>
    printf(1, "link . lf1 succeeded! oops\n");
    18f4:	83 ec 08             	sub    $0x8,%esp
    18f7:	68 4d a2 01 00       	push   $0x1a24d
    18fc:	6a 01                	push   $0x1
    18fe:	e8 73 27 00 00       	call   4076 <printf>
    1903:	83 c4 10             	add    $0x10,%esp
    exit();
    1906:	e8 c4 25 00 00       	call   3ecf <exit>
  }

  printf(1, "linktest ok\n");
    190b:	83 ec 08             	sub    $0x8,%esp
    190e:	68 69 a2 01 00       	push   $0x1a269
    1913:	6a 01                	push   $0x1
    1915:	e8 5c 27 00 00       	call   4076 <printf>
    191a:	83 c4 10             	add    $0x10,%esp
}
    191d:	90                   	nop
    191e:	c9                   	leave  
    191f:	c3                   	ret    

00001920 <concreate>:

// test concurrent create/link/unlink of the same file
void
concreate(void)
{
    1920:	55                   	push   %ebp
    1921:	89 e5                	mov    %esp,%ebp
    1923:	83 ec 58             	sub    $0x58,%esp
  struct {
    ushort inum;
    char name[14];
  } de;

  printf(1, "concreate test\n");
    1926:	83 ec 08             	sub    $0x8,%esp
    1929:	68 76 a2 01 00       	push   $0x1a276
    192e:	6a 01                	push   $0x1
    1930:	e8 41 27 00 00       	call   4076 <printf>
    1935:	83 c4 10             	add    $0x10,%esp
  file[0] = 'C';
    1938:	c6 45 e5 43          	movb   $0x43,-0x1b(%ebp)
  file[2] = '\0';
    193c:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  for(i = 0; i < 40; i++){
    1940:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1947:	e9 fc 00 00 00       	jmp    1a48 <concreate+0x128>
    file[1] = '0' + i;
    194c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    194f:	83 c0 30             	add    $0x30,%eax
    1952:	88 45 e6             	mov    %al,-0x1a(%ebp)
    unlink(file);
    1955:	83 ec 0c             	sub    $0xc,%esp
    1958:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    195b:	50                   	push   %eax
    195c:	e8 be 25 00 00       	call   3f1f <unlink>
    1961:	83 c4 10             	add    $0x10,%esp
    pid = fork();
    1964:	e8 5e 25 00 00       	call   3ec7 <fork>
    1969:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(pid && (i % 3) == 1){
    196c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1970:	74 3b                	je     19ad <concreate+0x8d>
    1972:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1975:	ba 56 55 55 55       	mov    $0x55555556,%edx
    197a:	89 c8                	mov    %ecx,%eax
    197c:	f7 ea                	imul   %edx
    197e:	89 c8                	mov    %ecx,%eax
    1980:	c1 f8 1f             	sar    $0x1f,%eax
    1983:	29 c2                	sub    %eax,%edx
    1985:	89 d0                	mov    %edx,%eax
    1987:	01 c0                	add    %eax,%eax
    1989:	01 d0                	add    %edx,%eax
    198b:	29 c1                	sub    %eax,%ecx
    198d:	89 ca                	mov    %ecx,%edx
    198f:	83 fa 01             	cmp    $0x1,%edx
    1992:	75 19                	jne    19ad <concreate+0x8d>
      link("C0", file);
    1994:	83 ec 08             	sub    $0x8,%esp
    1997:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    199a:	50                   	push   %eax
    199b:	68 86 a2 01 00       	push   $0x1a286
    19a0:	e8 8a 25 00 00       	call   3f2f <link>
    19a5:	83 c4 10             	add    $0x10,%esp
    19a8:	e9 87 00 00 00       	jmp    1a34 <concreate+0x114>
    } else if(pid == 0 && (i % 5) == 1){
    19ad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    19b1:	75 3b                	jne    19ee <concreate+0xce>
    19b3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    19b6:	ba 67 66 66 66       	mov    $0x66666667,%edx
    19bb:	89 c8                	mov    %ecx,%eax
    19bd:	f7 ea                	imul   %edx
    19bf:	d1 fa                	sar    %edx
    19c1:	89 c8                	mov    %ecx,%eax
    19c3:	c1 f8 1f             	sar    $0x1f,%eax
    19c6:	29 c2                	sub    %eax,%edx
    19c8:	89 d0                	mov    %edx,%eax
    19ca:	c1 e0 02             	shl    $0x2,%eax
    19cd:	01 d0                	add    %edx,%eax
    19cf:	29 c1                	sub    %eax,%ecx
    19d1:	89 ca                	mov    %ecx,%edx
    19d3:	83 fa 01             	cmp    $0x1,%edx
    19d6:	75 16                	jne    19ee <concreate+0xce>
      link("C0", file);
    19d8:	83 ec 08             	sub    $0x8,%esp
    19db:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    19de:	50                   	push   %eax
    19df:	68 86 a2 01 00       	push   $0x1a286
    19e4:	e8 46 25 00 00       	call   3f2f <link>
    19e9:	83 c4 10             	add    $0x10,%esp
    19ec:	eb 46                	jmp    1a34 <concreate+0x114>
    } else {
      fd = open(file, O_CREATE | O_RDWR);
    19ee:	83 ec 08             	sub    $0x8,%esp
    19f1:	68 02 02 00 00       	push   $0x202
    19f6:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    19f9:	50                   	push   %eax
    19fa:	e8 10 25 00 00       	call   3f0f <open>
    19ff:	83 c4 10             	add    $0x10,%esp
    1a02:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if(fd < 0){
    1a05:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    1a09:	79 1b                	jns    1a26 <concreate+0x106>
        printf(1, "concreate create %s failed\n", file);
    1a0b:	83 ec 04             	sub    $0x4,%esp
    1a0e:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1a11:	50                   	push   %eax
    1a12:	68 89 a2 01 00       	push   $0x1a289
    1a17:	6a 01                	push   $0x1
    1a19:	e8 58 26 00 00       	call   4076 <printf>
    1a1e:	83 c4 10             	add    $0x10,%esp
        exit();
    1a21:	e8 a9 24 00 00       	call   3ecf <exit>
      }
      close(fd);
    1a26:	83 ec 0c             	sub    $0xc,%esp
    1a29:	ff 75 e8             	pushl  -0x18(%ebp)
    1a2c:	e8 c6 24 00 00       	call   3ef7 <close>
    1a31:	83 c4 10             	add    $0x10,%esp
    }
    if(pid == 0)
    1a34:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1a38:	75 05                	jne    1a3f <concreate+0x11f>
      exit();
    1a3a:	e8 90 24 00 00       	call   3ecf <exit>
    else
      wait();
    1a3f:	e8 93 24 00 00       	call   3ed7 <wait>
  } de;

  printf(1, "concreate test\n");
  file[0] = 'C';
  file[2] = '\0';
  for(i = 0; i < 40; i++){
    1a44:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1a48:	83 7d f4 27          	cmpl   $0x27,-0xc(%ebp)
    1a4c:	0f 8e fa fe ff ff    	jle    194c <concreate+0x2c>
      exit();
    else
      wait();
  }

  memset(fa, 0, sizeof(fa));
    1a52:	83 ec 04             	sub    $0x4,%esp
    1a55:	6a 28                	push   $0x28
    1a57:	6a 00                	push   $0x0
    1a59:	8d 45 bd             	lea    -0x43(%ebp),%eax
    1a5c:	50                   	push   %eax
    1a5d:	e8 d2 22 00 00       	call   3d34 <memset>
    1a62:	83 c4 10             	add    $0x10,%esp
  fd = open(".", 0);
    1a65:	83 ec 08             	sub    $0x8,%esp
    1a68:	6a 00                	push   $0x0
    1a6a:	68 4b a2 01 00       	push   $0x1a24b
    1a6f:	e8 9b 24 00 00       	call   3f0f <open>
    1a74:	83 c4 10             	add    $0x10,%esp
    1a77:	89 45 e8             	mov    %eax,-0x18(%ebp)
  n = 0;
    1a7a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  while(read(fd, &de, sizeof(de)) > 0){
    1a81:	e9 93 00 00 00       	jmp    1b19 <concreate+0x1f9>
    if(de.inum == 0)
    1a86:	0f b7 45 ac          	movzwl -0x54(%ebp),%eax
    1a8a:	66 85 c0             	test   %ax,%ax
    1a8d:	75 05                	jne    1a94 <concreate+0x174>
      continue;
    1a8f:	e9 85 00 00 00       	jmp    1b19 <concreate+0x1f9>
    if(de.name[0] == 'C' && de.name[2] == '\0'){
    1a94:	0f b6 45 ae          	movzbl -0x52(%ebp),%eax
    1a98:	3c 43                	cmp    $0x43,%al
    1a9a:	75 7d                	jne    1b19 <concreate+0x1f9>
    1a9c:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
    1aa0:	84 c0                	test   %al,%al
    1aa2:	75 75                	jne    1b19 <concreate+0x1f9>
      i = de.name[1] - '0';
    1aa4:	0f b6 45 af          	movzbl -0x51(%ebp),%eax
    1aa8:	0f be c0             	movsbl %al,%eax
    1aab:	83 e8 30             	sub    $0x30,%eax
    1aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(i < 0 || i >= sizeof(fa)){
    1ab1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1ab5:	78 08                	js     1abf <concreate+0x19f>
    1ab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1aba:	83 f8 27             	cmp    $0x27,%eax
    1abd:	76 1e                	jbe    1add <concreate+0x1bd>
        printf(1, "concreate weird file %s\n", de.name);
    1abf:	83 ec 04             	sub    $0x4,%esp
    1ac2:	8d 45 ac             	lea    -0x54(%ebp),%eax
    1ac5:	83 c0 02             	add    $0x2,%eax
    1ac8:	50                   	push   %eax
    1ac9:	68 a5 a2 01 00       	push   $0x1a2a5
    1ace:	6a 01                	push   $0x1
    1ad0:	e8 a1 25 00 00       	call   4076 <printf>
    1ad5:	83 c4 10             	add    $0x10,%esp
        exit();
    1ad8:	e8 f2 23 00 00       	call   3ecf <exit>
      }
      if(fa[i]){
    1add:	8d 55 bd             	lea    -0x43(%ebp),%edx
    1ae0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ae3:	01 d0                	add    %edx,%eax
    1ae5:	0f b6 00             	movzbl (%eax),%eax
    1ae8:	84 c0                	test   %al,%al
    1aea:	74 1e                	je     1b0a <concreate+0x1ea>
        printf(1, "concreate duplicate file %s\n", de.name);
    1aec:	83 ec 04             	sub    $0x4,%esp
    1aef:	8d 45 ac             	lea    -0x54(%ebp),%eax
    1af2:	83 c0 02             	add    $0x2,%eax
    1af5:	50                   	push   %eax
    1af6:	68 be a2 01 00       	push   $0x1a2be
    1afb:	6a 01                	push   $0x1
    1afd:	e8 74 25 00 00       	call   4076 <printf>
    1b02:	83 c4 10             	add    $0x10,%esp
        exit();
    1b05:	e8 c5 23 00 00       	call   3ecf <exit>
      }
      fa[i] = 1;
    1b0a:	8d 55 bd             	lea    -0x43(%ebp),%edx
    1b0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1b10:	01 d0                	add    %edx,%eax
    1b12:	c6 00 01             	movb   $0x1,(%eax)
      n++;
    1b15:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  }

  memset(fa, 0, sizeof(fa));
  fd = open(".", 0);
  n = 0;
  while(read(fd, &de, sizeof(de)) > 0){
    1b19:	83 ec 04             	sub    $0x4,%esp
    1b1c:	6a 10                	push   $0x10
    1b1e:	8d 45 ac             	lea    -0x54(%ebp),%eax
    1b21:	50                   	push   %eax
    1b22:	ff 75 e8             	pushl  -0x18(%ebp)
    1b25:	e8 bd 23 00 00       	call   3ee7 <read>
    1b2a:	83 c4 10             	add    $0x10,%esp
    1b2d:	85 c0                	test   %eax,%eax
    1b2f:	0f 8f 51 ff ff ff    	jg     1a86 <concreate+0x166>
      }
      fa[i] = 1;
      n++;
    }
  }
  close(fd);
    1b35:	83 ec 0c             	sub    $0xc,%esp
    1b38:	ff 75 e8             	pushl  -0x18(%ebp)
    1b3b:	e8 b7 23 00 00       	call   3ef7 <close>
    1b40:	83 c4 10             	add    $0x10,%esp

  if(n != 40){
    1b43:	83 7d f0 28          	cmpl   $0x28,-0x10(%ebp)
    1b47:	74 17                	je     1b60 <concreate+0x240>
    printf(1, "concreate not enough files in directory listing\n");
    1b49:	83 ec 08             	sub    $0x8,%esp
    1b4c:	68 dc a2 01 00       	push   $0x1a2dc
    1b51:	6a 01                	push   $0x1
    1b53:	e8 1e 25 00 00       	call   4076 <printf>
    1b58:	83 c4 10             	add    $0x10,%esp
    exit();
    1b5b:	e8 6f 23 00 00       	call   3ecf <exit>
  }

  for(i = 0; i < 40; i++){
    1b60:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1b67:	e9 45 01 00 00       	jmp    1cb1 <concreate+0x391>
    file[1] = '0' + i;
    1b6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1b6f:	83 c0 30             	add    $0x30,%eax
    1b72:	88 45 e6             	mov    %al,-0x1a(%ebp)
    pid = fork();
    1b75:	e8 4d 23 00 00       	call   3ec7 <fork>
    1b7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(pid < 0){
    1b7d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1b81:	79 17                	jns    1b9a <concreate+0x27a>
      printf(1, "fork failed\n");
    1b83:	83 ec 08             	sub    $0x8,%esp
    1b86:	68 61 9a 01 00       	push   $0x19a61
    1b8b:	6a 01                	push   $0x1
    1b8d:	e8 e4 24 00 00       	call   4076 <printf>
    1b92:	83 c4 10             	add    $0x10,%esp
      exit();
    1b95:	e8 35 23 00 00       	call   3ecf <exit>
    }
    if(((i % 3) == 0 && pid == 0) ||
    1b9a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1b9d:	ba 56 55 55 55       	mov    $0x55555556,%edx
    1ba2:	89 c8                	mov    %ecx,%eax
    1ba4:	f7 ea                	imul   %edx
    1ba6:	89 c8                	mov    %ecx,%eax
    1ba8:	c1 f8 1f             	sar    $0x1f,%eax
    1bab:	29 c2                	sub    %eax,%edx
    1bad:	89 d0                	mov    %edx,%eax
    1baf:	89 c2                	mov    %eax,%edx
    1bb1:	01 d2                	add    %edx,%edx
    1bb3:	01 c2                	add    %eax,%edx
    1bb5:	89 c8                	mov    %ecx,%eax
    1bb7:	29 d0                	sub    %edx,%eax
    1bb9:	85 c0                	test   %eax,%eax
    1bbb:	75 06                	jne    1bc3 <concreate+0x2a3>
    1bbd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1bc1:	74 28                	je     1beb <concreate+0x2cb>
       ((i % 3) == 1 && pid != 0)){
    1bc3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1bc6:	ba 56 55 55 55       	mov    $0x55555556,%edx
    1bcb:	89 c8                	mov    %ecx,%eax
    1bcd:	f7 ea                	imul   %edx
    1bcf:	89 c8                	mov    %ecx,%eax
    1bd1:	c1 f8 1f             	sar    $0x1f,%eax
    1bd4:	29 c2                	sub    %eax,%edx
    1bd6:	89 d0                	mov    %edx,%eax
    1bd8:	01 c0                	add    %eax,%eax
    1bda:	01 d0                	add    %edx,%eax
    1bdc:	29 c1                	sub    %eax,%ecx
    1bde:	89 ca                	mov    %ecx,%edx
    pid = fork();
    if(pid < 0){
      printf(1, "fork failed\n");
      exit();
    }
    if(((i % 3) == 0 && pid == 0) ||
    1be0:	83 fa 01             	cmp    $0x1,%edx
    1be3:	75 7c                	jne    1c61 <concreate+0x341>
       ((i % 3) == 1 && pid != 0)){
    1be5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1be9:	74 76                	je     1c61 <concreate+0x341>
      close(open(file, 0));
    1beb:	83 ec 08             	sub    $0x8,%esp
    1bee:	6a 00                	push   $0x0
    1bf0:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1bf3:	50                   	push   %eax
    1bf4:	e8 16 23 00 00       	call   3f0f <open>
    1bf9:	83 c4 10             	add    $0x10,%esp
    1bfc:	83 ec 0c             	sub    $0xc,%esp
    1bff:	50                   	push   %eax
    1c00:	e8 f2 22 00 00       	call   3ef7 <close>
    1c05:	83 c4 10             	add    $0x10,%esp
      close(open(file, 0));
    1c08:	83 ec 08             	sub    $0x8,%esp
    1c0b:	6a 00                	push   $0x0
    1c0d:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1c10:	50                   	push   %eax
    1c11:	e8 f9 22 00 00       	call   3f0f <open>
    1c16:	83 c4 10             	add    $0x10,%esp
    1c19:	83 ec 0c             	sub    $0xc,%esp
    1c1c:	50                   	push   %eax
    1c1d:	e8 d5 22 00 00       	call   3ef7 <close>
    1c22:	83 c4 10             	add    $0x10,%esp
      close(open(file, 0));
    1c25:	83 ec 08             	sub    $0x8,%esp
    1c28:	6a 00                	push   $0x0
    1c2a:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1c2d:	50                   	push   %eax
    1c2e:	e8 dc 22 00 00       	call   3f0f <open>
    1c33:	83 c4 10             	add    $0x10,%esp
    1c36:	83 ec 0c             	sub    $0xc,%esp
    1c39:	50                   	push   %eax
    1c3a:	e8 b8 22 00 00       	call   3ef7 <close>
    1c3f:	83 c4 10             	add    $0x10,%esp
      close(open(file, 0));
    1c42:	83 ec 08             	sub    $0x8,%esp
    1c45:	6a 00                	push   $0x0
    1c47:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1c4a:	50                   	push   %eax
    1c4b:	e8 bf 22 00 00       	call   3f0f <open>
    1c50:	83 c4 10             	add    $0x10,%esp
    1c53:	83 ec 0c             	sub    $0xc,%esp
    1c56:	50                   	push   %eax
    1c57:	e8 9b 22 00 00       	call   3ef7 <close>
    1c5c:	83 c4 10             	add    $0x10,%esp
    1c5f:	eb 3c                	jmp    1c9d <concreate+0x37d>
    } else {
      unlink(file);
    1c61:	83 ec 0c             	sub    $0xc,%esp
    1c64:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1c67:	50                   	push   %eax
    1c68:	e8 b2 22 00 00       	call   3f1f <unlink>
    1c6d:	83 c4 10             	add    $0x10,%esp
      unlink(file);
    1c70:	83 ec 0c             	sub    $0xc,%esp
    1c73:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1c76:	50                   	push   %eax
    1c77:	e8 a3 22 00 00       	call   3f1f <unlink>
    1c7c:	83 c4 10             	add    $0x10,%esp
      unlink(file);
    1c7f:	83 ec 0c             	sub    $0xc,%esp
    1c82:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1c85:	50                   	push   %eax
    1c86:	e8 94 22 00 00       	call   3f1f <unlink>
    1c8b:	83 c4 10             	add    $0x10,%esp
      unlink(file);
    1c8e:	83 ec 0c             	sub    $0xc,%esp
    1c91:	8d 45 e5             	lea    -0x1b(%ebp),%eax
    1c94:	50                   	push   %eax
    1c95:	e8 85 22 00 00       	call   3f1f <unlink>
    1c9a:	83 c4 10             	add    $0x10,%esp
    }
    if(pid == 0)
    1c9d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1ca1:	75 05                	jne    1ca8 <concreate+0x388>
      exit();
    1ca3:	e8 27 22 00 00       	call   3ecf <exit>
    else
      wait();
    1ca8:	e8 2a 22 00 00       	call   3ed7 <wait>
  if(n != 40){
    printf(1, "concreate not enough files in directory listing\n");
    exit();
  }

  for(i = 0; i < 40; i++){
    1cad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1cb1:	83 7d f4 27          	cmpl   $0x27,-0xc(%ebp)
    1cb5:	0f 8e b1 fe ff ff    	jle    1b6c <concreate+0x24c>
      exit();
    else
      wait();
  }

  printf(1, "concreate ok\n");
    1cbb:	83 ec 08             	sub    $0x8,%esp
    1cbe:	68 0d a3 01 00       	push   $0x1a30d
    1cc3:	6a 01                	push   $0x1
    1cc5:	e8 ac 23 00 00       	call   4076 <printf>
    1cca:	83 c4 10             	add    $0x10,%esp
}
    1ccd:	90                   	nop
    1cce:	c9                   	leave  
    1ccf:	c3                   	ret    

00001cd0 <linkunlink>:

// another concurrent link/unlink/create test,
// to look for deadlocks.
void
linkunlink()
{
    1cd0:	55                   	push   %ebp
    1cd1:	89 e5                	mov    %esp,%ebp
    1cd3:	83 ec 18             	sub    $0x18,%esp
  int pid, i;

  printf(1, "linkunlink test\n");
    1cd6:	83 ec 08             	sub    $0x8,%esp
    1cd9:	68 1b a3 01 00       	push   $0x1a31b
    1cde:	6a 01                	push   $0x1
    1ce0:	e8 91 23 00 00       	call   4076 <printf>
    1ce5:	83 c4 10             	add    $0x10,%esp

  unlink("x");
    1ce8:	83 ec 0c             	sub    $0xc,%esp
    1ceb:	68 97 9e 01 00       	push   $0x19e97
    1cf0:	e8 2a 22 00 00       	call   3f1f <unlink>
    1cf5:	83 c4 10             	add    $0x10,%esp
  pid = fork();
    1cf8:	e8 ca 21 00 00       	call   3ec7 <fork>
    1cfd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(pid < 0){
    1d00:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1d04:	79 17                	jns    1d1d <linkunlink+0x4d>
    printf(1, "fork failed\n");
    1d06:	83 ec 08             	sub    $0x8,%esp
    1d09:	68 61 9a 01 00       	push   $0x19a61
    1d0e:	6a 01                	push   $0x1
    1d10:	e8 61 23 00 00       	call   4076 <printf>
    1d15:	83 c4 10             	add    $0x10,%esp
    exit();
    1d18:	e8 b2 21 00 00       	call   3ecf <exit>
  }

  unsigned int x = (pid ? 1 : 97);
    1d1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1d21:	74 07                	je     1d2a <linkunlink+0x5a>
    1d23:	b8 01 00 00 00       	mov    $0x1,%eax
    1d28:	eb 05                	jmp    1d2f <linkunlink+0x5f>
    1d2a:	b8 61 00 00 00       	mov    $0x61,%eax
    1d2f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for(i = 0; i < 100; i++){
    1d32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1d39:	e9 9a 00 00 00       	jmp    1dd8 <linkunlink+0x108>
    x = x * 1103515245 + 12345;
    1d3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d41:	69 c0 6d 4e c6 41    	imul   $0x41c64e6d,%eax,%eax
    1d47:	05 39 30 00 00       	add    $0x3039,%eax
    1d4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if((x % 3) == 0){
    1d4f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    1d52:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    1d57:	89 c8                	mov    %ecx,%eax
    1d59:	f7 e2                	mul    %edx
    1d5b:	89 d0                	mov    %edx,%eax
    1d5d:	d1 e8                	shr    %eax
    1d5f:	89 c2                	mov    %eax,%edx
    1d61:	01 d2                	add    %edx,%edx
    1d63:	01 c2                	add    %eax,%edx
    1d65:	89 c8                	mov    %ecx,%eax
    1d67:	29 d0                	sub    %edx,%eax
    1d69:	85 c0                	test   %eax,%eax
    1d6b:	75 23                	jne    1d90 <linkunlink+0xc0>
      close(open("x", O_RDWR | O_CREATE));
    1d6d:	83 ec 08             	sub    $0x8,%esp
    1d70:	68 02 02 00 00       	push   $0x202
    1d75:	68 97 9e 01 00       	push   $0x19e97
    1d7a:	e8 90 21 00 00       	call   3f0f <open>
    1d7f:	83 c4 10             	add    $0x10,%esp
    1d82:	83 ec 0c             	sub    $0xc,%esp
    1d85:	50                   	push   %eax
    1d86:	e8 6c 21 00 00       	call   3ef7 <close>
    1d8b:	83 c4 10             	add    $0x10,%esp
    1d8e:	eb 44                	jmp    1dd4 <linkunlink+0x104>
    } else if((x % 3) == 1){
    1d90:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    1d93:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    1d98:	89 c8                	mov    %ecx,%eax
    1d9a:	f7 e2                	mul    %edx
    1d9c:	d1 ea                	shr    %edx
    1d9e:	89 d0                	mov    %edx,%eax
    1da0:	01 c0                	add    %eax,%eax
    1da2:	01 d0                	add    %edx,%eax
    1da4:	29 c1                	sub    %eax,%ecx
    1da6:	89 ca                	mov    %ecx,%edx
    1da8:	83 fa 01             	cmp    $0x1,%edx
    1dab:	75 17                	jne    1dc4 <linkunlink+0xf4>
      link("cat", "x");
    1dad:	83 ec 08             	sub    $0x8,%esp
    1db0:	68 97 9e 01 00       	push   $0x19e97
    1db5:	68 2c a3 01 00       	push   $0x1a32c
    1dba:	e8 70 21 00 00       	call   3f2f <link>
    1dbf:	83 c4 10             	add    $0x10,%esp
    1dc2:	eb 10                	jmp    1dd4 <linkunlink+0x104>
    } else {
      unlink("x");
    1dc4:	83 ec 0c             	sub    $0xc,%esp
    1dc7:	68 97 9e 01 00       	push   $0x19e97
    1dcc:	e8 4e 21 00 00       	call   3f1f <unlink>
    1dd1:	83 c4 10             	add    $0x10,%esp
    printf(1, "fork failed\n");
    exit();
  }

  unsigned int x = (pid ? 1 : 97);
  for(i = 0; i < 100; i++){
    1dd4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1dd8:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
    1ddc:	0f 8e 5c ff ff ff    	jle    1d3e <linkunlink+0x6e>
    } else {
      unlink("x");
    }
  }

  if(pid)
    1de2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1de6:	74 07                	je     1def <linkunlink+0x11f>
    wait();
    1de8:	e8 ea 20 00 00       	call   3ed7 <wait>
    1ded:	eb 05                	jmp    1df4 <linkunlink+0x124>
  else 
    exit();
    1def:	e8 db 20 00 00       	call   3ecf <exit>

  printf(1, "linkunlink ok\n");
    1df4:	83 ec 08             	sub    $0x8,%esp
    1df7:	68 30 a3 01 00       	push   $0x1a330
    1dfc:	6a 01                	push   $0x1
    1dfe:	e8 73 22 00 00       	call   4076 <printf>
    1e03:	83 c4 10             	add    $0x10,%esp
}
    1e06:	90                   	nop
    1e07:	c9                   	leave  
    1e08:	c3                   	ret    

00001e09 <bigdir>:

// directory that uses indirect blocks
void
bigdir(void)
{
    1e09:	55                   	push   %ebp
    1e0a:	89 e5                	mov    %esp,%ebp
    1e0c:	83 ec 28             	sub    $0x28,%esp
  int i, fd;
  char name[10];

  printf(1, "bigdir test\n");
    1e0f:	83 ec 08             	sub    $0x8,%esp
    1e12:	68 3f a3 01 00       	push   $0x1a33f
    1e17:	6a 01                	push   $0x1
    1e19:	e8 58 22 00 00       	call   4076 <printf>
    1e1e:	83 c4 10             	add    $0x10,%esp
  unlink("bd");
    1e21:	83 ec 0c             	sub    $0xc,%esp
    1e24:	68 4c a3 01 00       	push   $0x1a34c
    1e29:	e8 f1 20 00 00       	call   3f1f <unlink>
    1e2e:	83 c4 10             	add    $0x10,%esp

  fd = open("bd", O_CREATE);
    1e31:	83 ec 08             	sub    $0x8,%esp
    1e34:	68 00 02 00 00       	push   $0x200
    1e39:	68 4c a3 01 00       	push   $0x1a34c
    1e3e:	e8 cc 20 00 00       	call   3f0f <open>
    1e43:	83 c4 10             	add    $0x10,%esp
    1e46:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(fd < 0){
    1e49:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    1e4d:	79 17                	jns    1e66 <bigdir+0x5d>
    printf(1, "bigdir create failed\n");
    1e4f:	83 ec 08             	sub    $0x8,%esp
    1e52:	68 4f a3 01 00       	push   $0x1a34f
    1e57:	6a 01                	push   $0x1
    1e59:	e8 18 22 00 00       	call   4076 <printf>
    1e5e:	83 c4 10             	add    $0x10,%esp
    exit();
    1e61:	e8 69 20 00 00       	call   3ecf <exit>
  }
  close(fd);
    1e66:	83 ec 0c             	sub    $0xc,%esp
    1e69:	ff 75 f0             	pushl  -0x10(%ebp)
    1e6c:	e8 86 20 00 00       	call   3ef7 <close>
    1e71:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i < 500; i++){
    1e74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1e7b:	eb 63                	jmp    1ee0 <bigdir+0xd7>
    name[0] = 'x';
    1e7d:	c6 45 e6 78          	movb   $0x78,-0x1a(%ebp)
    name[1] = '0' + (i / 64);
    1e81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e84:	8d 50 3f             	lea    0x3f(%eax),%edx
    1e87:	85 c0                	test   %eax,%eax
    1e89:	0f 48 c2             	cmovs  %edx,%eax
    1e8c:	c1 f8 06             	sar    $0x6,%eax
    1e8f:	83 c0 30             	add    $0x30,%eax
    1e92:	88 45 e7             	mov    %al,-0x19(%ebp)
    name[2] = '0' + (i % 64);
    1e95:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e98:	99                   	cltd   
    1e99:	c1 ea 1a             	shr    $0x1a,%edx
    1e9c:	01 d0                	add    %edx,%eax
    1e9e:	83 e0 3f             	and    $0x3f,%eax
    1ea1:	29 d0                	sub    %edx,%eax
    1ea3:	83 c0 30             	add    $0x30,%eax
    1ea6:	88 45 e8             	mov    %al,-0x18(%ebp)
    name[3] = '\0';
    1ea9:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    if(link("bd", name) != 0){
    1ead:	83 ec 08             	sub    $0x8,%esp
    1eb0:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1eb3:	50                   	push   %eax
    1eb4:	68 4c a3 01 00       	push   $0x1a34c
    1eb9:	e8 71 20 00 00       	call   3f2f <link>
    1ebe:	83 c4 10             	add    $0x10,%esp
    1ec1:	85 c0                	test   %eax,%eax
    1ec3:	74 17                	je     1edc <bigdir+0xd3>
      printf(1, "bigdir link failed\n");
    1ec5:	83 ec 08             	sub    $0x8,%esp
    1ec8:	68 65 a3 01 00       	push   $0x1a365
    1ecd:	6a 01                	push   $0x1
    1ecf:	e8 a2 21 00 00       	call   4076 <printf>
    1ed4:	83 c4 10             	add    $0x10,%esp
      exit();
    1ed7:	e8 f3 1f 00 00       	call   3ecf <exit>
    printf(1, "bigdir create failed\n");
    exit();
  }
  close(fd);

  for(i = 0; i < 500; i++){
    1edc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1ee0:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
    1ee7:	7e 94                	jle    1e7d <bigdir+0x74>
      printf(1, "bigdir link failed\n");
      exit();
    }
  }

  unlink("bd");
    1ee9:	83 ec 0c             	sub    $0xc,%esp
    1eec:	68 4c a3 01 00       	push   $0x1a34c
    1ef1:	e8 29 20 00 00       	call   3f1f <unlink>
    1ef6:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < 500; i++){
    1ef9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1f00:	eb 5e                	jmp    1f60 <bigdir+0x157>
    name[0] = 'x';
    1f02:	c6 45 e6 78          	movb   $0x78,-0x1a(%ebp)
    name[1] = '0' + (i / 64);
    1f06:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1f09:	8d 50 3f             	lea    0x3f(%eax),%edx
    1f0c:	85 c0                	test   %eax,%eax
    1f0e:	0f 48 c2             	cmovs  %edx,%eax
    1f11:	c1 f8 06             	sar    $0x6,%eax
    1f14:	83 c0 30             	add    $0x30,%eax
    1f17:	88 45 e7             	mov    %al,-0x19(%ebp)
    name[2] = '0' + (i % 64);
    1f1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1f1d:	99                   	cltd   
    1f1e:	c1 ea 1a             	shr    $0x1a,%edx
    1f21:	01 d0                	add    %edx,%eax
    1f23:	83 e0 3f             	and    $0x3f,%eax
    1f26:	29 d0                	sub    %edx,%eax
    1f28:	83 c0 30             	add    $0x30,%eax
    1f2b:	88 45 e8             	mov    %al,-0x18(%ebp)
    name[3] = '\0';
    1f2e:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    if(unlink(name) != 0){
    1f32:	83 ec 0c             	sub    $0xc,%esp
    1f35:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1f38:	50                   	push   %eax
    1f39:	e8 e1 1f 00 00       	call   3f1f <unlink>
    1f3e:	83 c4 10             	add    $0x10,%esp
    1f41:	85 c0                	test   %eax,%eax
    1f43:	74 17                	je     1f5c <bigdir+0x153>
      printf(1, "bigdir unlink failed");
    1f45:	83 ec 08             	sub    $0x8,%esp
    1f48:	68 79 a3 01 00       	push   $0x1a379
    1f4d:	6a 01                	push   $0x1
    1f4f:	e8 22 21 00 00       	call   4076 <printf>
    1f54:	83 c4 10             	add    $0x10,%esp
      exit();
    1f57:	e8 73 1f 00 00       	call   3ecf <exit>
      exit();
    }
  }

  unlink("bd");
  for(i = 0; i < 500; i++){
    1f5c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1f60:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
    1f67:	7e 99                	jle    1f02 <bigdir+0xf9>
      printf(1, "bigdir unlink failed");
      exit();
    }
  }

  printf(1, "bigdir ok\n");
    1f69:	83 ec 08             	sub    $0x8,%esp
    1f6c:	68 8e a3 01 00       	push   $0x1a38e
    1f71:	6a 01                	push   $0x1
    1f73:	e8 fe 20 00 00       	call   4076 <printf>
    1f78:	83 c4 10             	add    $0x10,%esp
}
    1f7b:	90                   	nop
    1f7c:	c9                   	leave  
    1f7d:	c3                   	ret    

00001f7e <subdir>:

void
subdir(void)
{
    1f7e:	55                   	push   %ebp
    1f7f:	89 e5                	mov    %esp,%ebp
    1f81:	83 ec 18             	sub    $0x18,%esp
  int fd, cc;

  printf(1, "subdir test\n");
    1f84:	83 ec 08             	sub    $0x8,%esp
    1f87:	68 99 a3 01 00       	push   $0x1a399
    1f8c:	6a 01                	push   $0x1
    1f8e:	e8 e3 20 00 00       	call   4076 <printf>
    1f93:	83 c4 10             	add    $0x10,%esp

  unlink("ff");
    1f96:	83 ec 0c             	sub    $0xc,%esp
    1f99:	68 a6 a3 01 00       	push   $0x1a3a6
    1f9e:	e8 7c 1f 00 00       	call   3f1f <unlink>
    1fa3:	83 c4 10             	add    $0x10,%esp
  if(mkdir("dd") != 0){
    1fa6:	83 ec 0c             	sub    $0xc,%esp
    1fa9:	68 a9 a3 01 00       	push   $0x1a3a9
    1fae:	e8 84 1f 00 00       	call   3f37 <mkdir>
    1fb3:	83 c4 10             	add    $0x10,%esp
    1fb6:	85 c0                	test   %eax,%eax
    1fb8:	74 17                	je     1fd1 <subdir+0x53>
    printf(1, "subdir mkdir dd failed\n");
    1fba:	83 ec 08             	sub    $0x8,%esp
    1fbd:	68 ac a3 01 00       	push   $0x1a3ac
    1fc2:	6a 01                	push   $0x1
    1fc4:	e8 ad 20 00 00       	call   4076 <printf>
    1fc9:	83 c4 10             	add    $0x10,%esp
    exit();
    1fcc:	e8 fe 1e 00 00       	call   3ecf <exit>
  }

  fd = open("dd/ff", O_CREATE | O_RDWR);
    1fd1:	83 ec 08             	sub    $0x8,%esp
    1fd4:	68 02 02 00 00       	push   $0x202
    1fd9:	68 c4 a3 01 00       	push   $0x1a3c4
    1fde:	e8 2c 1f 00 00       	call   3f0f <open>
    1fe3:	83 c4 10             	add    $0x10,%esp
    1fe6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    1fe9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1fed:	79 17                	jns    2006 <subdir+0x88>
    printf(1, "create dd/ff failed\n");
    1fef:	83 ec 08             	sub    $0x8,%esp
    1ff2:	68 ca a3 01 00       	push   $0x1a3ca
    1ff7:	6a 01                	push   $0x1
    1ff9:	e8 78 20 00 00       	call   4076 <printf>
    1ffe:	83 c4 10             	add    $0x10,%esp
    exit();
    2001:	e8 c9 1e 00 00       	call   3ecf <exit>
  }
  write(fd, "ff", 2);
    2006:	83 ec 04             	sub    $0x4,%esp
    2009:	6a 02                	push   $0x2
    200b:	68 a6 a3 01 00       	push   $0x1a3a6
    2010:	ff 75 f4             	pushl  -0xc(%ebp)
    2013:	e8 d7 1e 00 00       	call   3eef <write>
    2018:	83 c4 10             	add    $0x10,%esp
  close(fd);
    201b:	83 ec 0c             	sub    $0xc,%esp
    201e:	ff 75 f4             	pushl  -0xc(%ebp)
    2021:	e8 d1 1e 00 00       	call   3ef7 <close>
    2026:	83 c4 10             	add    $0x10,%esp
  
  if(unlink("dd") >= 0){
    2029:	83 ec 0c             	sub    $0xc,%esp
    202c:	68 a9 a3 01 00       	push   $0x1a3a9
    2031:	e8 e9 1e 00 00       	call   3f1f <unlink>
    2036:	83 c4 10             	add    $0x10,%esp
    2039:	85 c0                	test   %eax,%eax
    203b:	78 17                	js     2054 <subdir+0xd6>
    printf(1, "unlink dd (non-empty dir) succeeded!\n");
    203d:	83 ec 08             	sub    $0x8,%esp
    2040:	68 e0 a3 01 00       	push   $0x1a3e0
    2045:	6a 01                	push   $0x1
    2047:	e8 2a 20 00 00       	call   4076 <printf>
    204c:	83 c4 10             	add    $0x10,%esp
    exit();
    204f:	e8 7b 1e 00 00       	call   3ecf <exit>
  }

  if(mkdir("/dd/dd") != 0){
    2054:	83 ec 0c             	sub    $0xc,%esp
    2057:	68 06 a4 01 00       	push   $0x1a406
    205c:	e8 d6 1e 00 00       	call   3f37 <mkdir>
    2061:	83 c4 10             	add    $0x10,%esp
    2064:	85 c0                	test   %eax,%eax
    2066:	74 17                	je     207f <subdir+0x101>
    printf(1, "subdir mkdir dd/dd failed\n");
    2068:	83 ec 08             	sub    $0x8,%esp
    206b:	68 0d a4 01 00       	push   $0x1a40d
    2070:	6a 01                	push   $0x1
    2072:	e8 ff 1f 00 00       	call   4076 <printf>
    2077:	83 c4 10             	add    $0x10,%esp
    exit();
    207a:	e8 50 1e 00 00       	call   3ecf <exit>
  }

  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
    207f:	83 ec 08             	sub    $0x8,%esp
    2082:	68 02 02 00 00       	push   $0x202
    2087:	68 28 a4 01 00       	push   $0x1a428
    208c:	e8 7e 1e 00 00       	call   3f0f <open>
    2091:	83 c4 10             	add    $0x10,%esp
    2094:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    2097:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    209b:	79 17                	jns    20b4 <subdir+0x136>
    printf(1, "create dd/dd/ff failed\n");
    209d:	83 ec 08             	sub    $0x8,%esp
    20a0:	68 31 a4 01 00       	push   $0x1a431
    20a5:	6a 01                	push   $0x1
    20a7:	e8 ca 1f 00 00       	call   4076 <printf>
    20ac:	83 c4 10             	add    $0x10,%esp
    exit();
    20af:	e8 1b 1e 00 00       	call   3ecf <exit>
  }
  write(fd, "FF", 2);
    20b4:	83 ec 04             	sub    $0x4,%esp
    20b7:	6a 02                	push   $0x2
    20b9:	68 49 a4 01 00       	push   $0x1a449
    20be:	ff 75 f4             	pushl  -0xc(%ebp)
    20c1:	e8 29 1e 00 00       	call   3eef <write>
    20c6:	83 c4 10             	add    $0x10,%esp
  close(fd);
    20c9:	83 ec 0c             	sub    $0xc,%esp
    20cc:	ff 75 f4             	pushl  -0xc(%ebp)
    20cf:	e8 23 1e 00 00       	call   3ef7 <close>
    20d4:	83 c4 10             	add    $0x10,%esp

  fd = open("dd/dd/../ff", 0);
    20d7:	83 ec 08             	sub    $0x8,%esp
    20da:	6a 00                	push   $0x0
    20dc:	68 4c a4 01 00       	push   $0x1a44c
    20e1:	e8 29 1e 00 00       	call   3f0f <open>
    20e6:	83 c4 10             	add    $0x10,%esp
    20e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    20ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    20f0:	79 17                	jns    2109 <subdir+0x18b>
    printf(1, "open dd/dd/../ff failed\n");
    20f2:	83 ec 08             	sub    $0x8,%esp
    20f5:	68 58 a4 01 00       	push   $0x1a458
    20fa:	6a 01                	push   $0x1
    20fc:	e8 75 1f 00 00       	call   4076 <printf>
    2101:	83 c4 10             	add    $0x10,%esp
    exit();
    2104:	e8 c6 1d 00 00       	call   3ecf <exit>
  }
  cc = read(fd, buf, sizeof(buf));
    2109:	83 ec 04             	sub    $0x4,%esp
    210c:	68 00 20 00 00       	push   $0x2000
    2111:	68 20 65 02 00       	push   $0x26520
    2116:	ff 75 f4             	pushl  -0xc(%ebp)
    2119:	e8 c9 1d 00 00       	call   3ee7 <read>
    211e:	83 c4 10             	add    $0x10,%esp
    2121:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(cc != 2 || buf[0] != 'f'){
    2124:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    2128:	75 0b                	jne    2135 <subdir+0x1b7>
    212a:	0f b6 05 20 65 02 00 	movzbl 0x26520,%eax
    2131:	3c 66                	cmp    $0x66,%al
    2133:	74 17                	je     214c <subdir+0x1ce>
    printf(1, "dd/dd/../ff wrong content\n");
    2135:	83 ec 08             	sub    $0x8,%esp
    2138:	68 71 a4 01 00       	push   $0x1a471
    213d:	6a 01                	push   $0x1
    213f:	e8 32 1f 00 00       	call   4076 <printf>
    2144:	83 c4 10             	add    $0x10,%esp
    exit();
    2147:	e8 83 1d 00 00       	call   3ecf <exit>
  }
  close(fd);
    214c:	83 ec 0c             	sub    $0xc,%esp
    214f:	ff 75 f4             	pushl  -0xc(%ebp)
    2152:	e8 a0 1d 00 00       	call   3ef7 <close>
    2157:	83 c4 10             	add    $0x10,%esp

  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
    215a:	83 ec 08             	sub    $0x8,%esp
    215d:	68 8c a4 01 00       	push   $0x1a48c
    2162:	68 28 a4 01 00       	push   $0x1a428
    2167:	e8 c3 1d 00 00       	call   3f2f <link>
    216c:	83 c4 10             	add    $0x10,%esp
    216f:	85 c0                	test   %eax,%eax
    2171:	74 17                	je     218a <subdir+0x20c>
    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
    2173:	83 ec 08             	sub    $0x8,%esp
    2176:	68 98 a4 01 00       	push   $0x1a498
    217b:	6a 01                	push   $0x1
    217d:	e8 f4 1e 00 00       	call   4076 <printf>
    2182:	83 c4 10             	add    $0x10,%esp
    exit();
    2185:	e8 45 1d 00 00       	call   3ecf <exit>
  }

  if(unlink("dd/dd/ff") != 0){
    218a:	83 ec 0c             	sub    $0xc,%esp
    218d:	68 28 a4 01 00       	push   $0x1a428
    2192:	e8 88 1d 00 00       	call   3f1f <unlink>
    2197:	83 c4 10             	add    $0x10,%esp
    219a:	85 c0                	test   %eax,%eax
    219c:	74 17                	je     21b5 <subdir+0x237>
    printf(1, "unlink dd/dd/ff failed\n");
    219e:	83 ec 08             	sub    $0x8,%esp
    21a1:	68 b9 a4 01 00       	push   $0x1a4b9
    21a6:	6a 01                	push   $0x1
    21a8:	e8 c9 1e 00 00       	call   4076 <printf>
    21ad:	83 c4 10             	add    $0x10,%esp
    exit();
    21b0:	e8 1a 1d 00 00       	call   3ecf <exit>
  }
  if(open("dd/dd/ff", O_RDONLY) >= 0){
    21b5:	83 ec 08             	sub    $0x8,%esp
    21b8:	6a 00                	push   $0x0
    21ba:	68 28 a4 01 00       	push   $0x1a428
    21bf:	e8 4b 1d 00 00       	call   3f0f <open>
    21c4:	83 c4 10             	add    $0x10,%esp
    21c7:	85 c0                	test   %eax,%eax
    21c9:	78 17                	js     21e2 <subdir+0x264>
    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
    21cb:	83 ec 08             	sub    $0x8,%esp
    21ce:	68 d4 a4 01 00       	push   $0x1a4d4
    21d3:	6a 01                	push   $0x1
    21d5:	e8 9c 1e 00 00       	call   4076 <printf>
    21da:	83 c4 10             	add    $0x10,%esp
    exit();
    21dd:	e8 ed 1c 00 00       	call   3ecf <exit>
  }

  if(chdir("dd") != 0){
    21e2:	83 ec 0c             	sub    $0xc,%esp
    21e5:	68 a9 a3 01 00       	push   $0x1a3a9
    21ea:	e8 50 1d 00 00       	call   3f3f <chdir>
    21ef:	83 c4 10             	add    $0x10,%esp
    21f2:	85 c0                	test   %eax,%eax
    21f4:	74 17                	je     220d <subdir+0x28f>
    printf(1, "chdir dd failed\n");
    21f6:	83 ec 08             	sub    $0x8,%esp
    21f9:	68 f8 a4 01 00       	push   $0x1a4f8
    21fe:	6a 01                	push   $0x1
    2200:	e8 71 1e 00 00       	call   4076 <printf>
    2205:	83 c4 10             	add    $0x10,%esp
    exit();
    2208:	e8 c2 1c 00 00       	call   3ecf <exit>
  }
  if(chdir("dd/../../dd") != 0){
    220d:	83 ec 0c             	sub    $0xc,%esp
    2210:	68 09 a5 01 00       	push   $0x1a509
    2215:	e8 25 1d 00 00       	call   3f3f <chdir>
    221a:	83 c4 10             	add    $0x10,%esp
    221d:	85 c0                	test   %eax,%eax
    221f:	74 17                	je     2238 <subdir+0x2ba>
    printf(1, "chdir dd/../../dd failed\n");
    2221:	83 ec 08             	sub    $0x8,%esp
    2224:	68 15 a5 01 00       	push   $0x1a515
    2229:	6a 01                	push   $0x1
    222b:	e8 46 1e 00 00       	call   4076 <printf>
    2230:	83 c4 10             	add    $0x10,%esp
    exit();
    2233:	e8 97 1c 00 00       	call   3ecf <exit>
  }
  if(chdir("dd/../../../dd") != 0){
    2238:	83 ec 0c             	sub    $0xc,%esp
    223b:	68 2f a5 01 00       	push   $0x1a52f
    2240:	e8 fa 1c 00 00       	call   3f3f <chdir>
    2245:	83 c4 10             	add    $0x10,%esp
    2248:	85 c0                	test   %eax,%eax
    224a:	74 17                	je     2263 <subdir+0x2e5>
    printf(1, "chdir dd/../../dd failed\n");
    224c:	83 ec 08             	sub    $0x8,%esp
    224f:	68 15 a5 01 00       	push   $0x1a515
    2254:	6a 01                	push   $0x1
    2256:	e8 1b 1e 00 00       	call   4076 <printf>
    225b:	83 c4 10             	add    $0x10,%esp
    exit();
    225e:	e8 6c 1c 00 00       	call   3ecf <exit>
  }
  if(chdir("./..") != 0){
    2263:	83 ec 0c             	sub    $0xc,%esp
    2266:	68 3e a5 01 00       	push   $0x1a53e
    226b:	e8 cf 1c 00 00       	call   3f3f <chdir>
    2270:	83 c4 10             	add    $0x10,%esp
    2273:	85 c0                	test   %eax,%eax
    2275:	74 17                	je     228e <subdir+0x310>
    printf(1, "chdir ./.. failed\n");
    2277:	83 ec 08             	sub    $0x8,%esp
    227a:	68 43 a5 01 00       	push   $0x1a543
    227f:	6a 01                	push   $0x1
    2281:	e8 f0 1d 00 00       	call   4076 <printf>
    2286:	83 c4 10             	add    $0x10,%esp
    exit();
    2289:	e8 41 1c 00 00       	call   3ecf <exit>
  }

  fd = open("dd/dd/ffff", 0);
    228e:	83 ec 08             	sub    $0x8,%esp
    2291:	6a 00                	push   $0x0
    2293:	68 8c a4 01 00       	push   $0x1a48c
    2298:	e8 72 1c 00 00       	call   3f0f <open>
    229d:	83 c4 10             	add    $0x10,%esp
    22a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    22a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    22a7:	79 17                	jns    22c0 <subdir+0x342>
    printf(1, "open dd/dd/ffff failed\n");
    22a9:	83 ec 08             	sub    $0x8,%esp
    22ac:	68 56 a5 01 00       	push   $0x1a556
    22b1:	6a 01                	push   $0x1
    22b3:	e8 be 1d 00 00       	call   4076 <printf>
    22b8:	83 c4 10             	add    $0x10,%esp
    exit();
    22bb:	e8 0f 1c 00 00       	call   3ecf <exit>
  }
  if(read(fd, buf, sizeof(buf)) != 2){
    22c0:	83 ec 04             	sub    $0x4,%esp
    22c3:	68 00 20 00 00       	push   $0x2000
    22c8:	68 20 65 02 00       	push   $0x26520
    22cd:	ff 75 f4             	pushl  -0xc(%ebp)
    22d0:	e8 12 1c 00 00       	call   3ee7 <read>
    22d5:	83 c4 10             	add    $0x10,%esp
    22d8:	83 f8 02             	cmp    $0x2,%eax
    22db:	74 17                	je     22f4 <subdir+0x376>
    printf(1, "read dd/dd/ffff wrong len\n");
    22dd:	83 ec 08             	sub    $0x8,%esp
    22e0:	68 6e a5 01 00       	push   $0x1a56e
    22e5:	6a 01                	push   $0x1
    22e7:	e8 8a 1d 00 00       	call   4076 <printf>
    22ec:	83 c4 10             	add    $0x10,%esp
    exit();
    22ef:	e8 db 1b 00 00       	call   3ecf <exit>
  }
  close(fd);
    22f4:	83 ec 0c             	sub    $0xc,%esp
    22f7:	ff 75 f4             	pushl  -0xc(%ebp)
    22fa:	e8 f8 1b 00 00       	call   3ef7 <close>
    22ff:	83 c4 10             	add    $0x10,%esp

  if(open("dd/dd/ff", O_RDONLY) >= 0){
    2302:	83 ec 08             	sub    $0x8,%esp
    2305:	6a 00                	push   $0x0
    2307:	68 28 a4 01 00       	push   $0x1a428
    230c:	e8 fe 1b 00 00       	call   3f0f <open>
    2311:	83 c4 10             	add    $0x10,%esp
    2314:	85 c0                	test   %eax,%eax
    2316:	78 17                	js     232f <subdir+0x3b1>
    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
    2318:	83 ec 08             	sub    $0x8,%esp
    231b:	68 8c a5 01 00       	push   $0x1a58c
    2320:	6a 01                	push   $0x1
    2322:	e8 4f 1d 00 00       	call   4076 <printf>
    2327:	83 c4 10             	add    $0x10,%esp
    exit();
    232a:	e8 a0 1b 00 00       	call   3ecf <exit>
  }

  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
    232f:	83 ec 08             	sub    $0x8,%esp
    2332:	68 02 02 00 00       	push   $0x202
    2337:	68 b1 a5 01 00       	push   $0x1a5b1
    233c:	e8 ce 1b 00 00       	call   3f0f <open>
    2341:	83 c4 10             	add    $0x10,%esp
    2344:	85 c0                	test   %eax,%eax
    2346:	78 17                	js     235f <subdir+0x3e1>
    printf(1, "create dd/ff/ff succeeded!\n");
    2348:	83 ec 08             	sub    $0x8,%esp
    234b:	68 ba a5 01 00       	push   $0x1a5ba
    2350:	6a 01                	push   $0x1
    2352:	e8 1f 1d 00 00       	call   4076 <printf>
    2357:	83 c4 10             	add    $0x10,%esp
    exit();
    235a:	e8 70 1b 00 00       	call   3ecf <exit>
  }
  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
    235f:	83 ec 08             	sub    $0x8,%esp
    2362:	68 02 02 00 00       	push   $0x202
    2367:	68 d6 a5 01 00       	push   $0x1a5d6
    236c:	e8 9e 1b 00 00       	call   3f0f <open>
    2371:	83 c4 10             	add    $0x10,%esp
    2374:	85 c0                	test   %eax,%eax
    2376:	78 17                	js     238f <subdir+0x411>
    printf(1, "create dd/xx/ff succeeded!\n");
    2378:	83 ec 08             	sub    $0x8,%esp
    237b:	68 df a5 01 00       	push   $0x1a5df
    2380:	6a 01                	push   $0x1
    2382:	e8 ef 1c 00 00       	call   4076 <printf>
    2387:	83 c4 10             	add    $0x10,%esp
    exit();
    238a:	e8 40 1b 00 00       	call   3ecf <exit>
  }
  if(open("dd", O_CREATE) >= 0){
    238f:	83 ec 08             	sub    $0x8,%esp
    2392:	68 00 02 00 00       	push   $0x200
    2397:	68 a9 a3 01 00       	push   $0x1a3a9
    239c:	e8 6e 1b 00 00       	call   3f0f <open>
    23a1:	83 c4 10             	add    $0x10,%esp
    23a4:	85 c0                	test   %eax,%eax
    23a6:	78 17                	js     23bf <subdir+0x441>
    printf(1, "create dd succeeded!\n");
    23a8:	83 ec 08             	sub    $0x8,%esp
    23ab:	68 fb a5 01 00       	push   $0x1a5fb
    23b0:	6a 01                	push   $0x1
    23b2:	e8 bf 1c 00 00       	call   4076 <printf>
    23b7:	83 c4 10             	add    $0x10,%esp
    exit();
    23ba:	e8 10 1b 00 00       	call   3ecf <exit>
  }
  if(open("dd", O_RDWR) >= 0){
    23bf:	83 ec 08             	sub    $0x8,%esp
    23c2:	6a 02                	push   $0x2
    23c4:	68 a9 a3 01 00       	push   $0x1a3a9
    23c9:	e8 41 1b 00 00       	call   3f0f <open>
    23ce:	83 c4 10             	add    $0x10,%esp
    23d1:	85 c0                	test   %eax,%eax
    23d3:	78 17                	js     23ec <subdir+0x46e>
    printf(1, "open dd rdwr succeeded!\n");
    23d5:	83 ec 08             	sub    $0x8,%esp
    23d8:	68 11 a6 01 00       	push   $0x1a611
    23dd:	6a 01                	push   $0x1
    23df:	e8 92 1c 00 00       	call   4076 <printf>
    23e4:	83 c4 10             	add    $0x10,%esp
    exit();
    23e7:	e8 e3 1a 00 00       	call   3ecf <exit>
  }
  if(open("dd", O_WRONLY) >= 0){
    23ec:	83 ec 08             	sub    $0x8,%esp
    23ef:	6a 01                	push   $0x1
    23f1:	68 a9 a3 01 00       	push   $0x1a3a9
    23f6:	e8 14 1b 00 00       	call   3f0f <open>
    23fb:	83 c4 10             	add    $0x10,%esp
    23fe:	85 c0                	test   %eax,%eax
    2400:	78 17                	js     2419 <subdir+0x49b>
    printf(1, "open dd wronly succeeded!\n");
    2402:	83 ec 08             	sub    $0x8,%esp
    2405:	68 2a a6 01 00       	push   $0x1a62a
    240a:	6a 01                	push   $0x1
    240c:	e8 65 1c 00 00       	call   4076 <printf>
    2411:	83 c4 10             	add    $0x10,%esp
    exit();
    2414:	e8 b6 1a 00 00       	call   3ecf <exit>
  }
  if(link("dd/ff/ff", "dd/dd/xx") == 0){
    2419:	83 ec 08             	sub    $0x8,%esp
    241c:	68 45 a6 01 00       	push   $0x1a645
    2421:	68 b1 a5 01 00       	push   $0x1a5b1
    2426:	e8 04 1b 00 00       	call   3f2f <link>
    242b:	83 c4 10             	add    $0x10,%esp
    242e:	85 c0                	test   %eax,%eax
    2430:	75 17                	jne    2449 <subdir+0x4cb>
    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
    2432:	83 ec 08             	sub    $0x8,%esp
    2435:	68 50 a6 01 00       	push   $0x1a650
    243a:	6a 01                	push   $0x1
    243c:	e8 35 1c 00 00       	call   4076 <printf>
    2441:	83 c4 10             	add    $0x10,%esp
    exit();
    2444:	e8 86 1a 00 00       	call   3ecf <exit>
  }
  if(link("dd/xx/ff", "dd/dd/xx") == 0){
    2449:	83 ec 08             	sub    $0x8,%esp
    244c:	68 45 a6 01 00       	push   $0x1a645
    2451:	68 d6 a5 01 00       	push   $0x1a5d6
    2456:	e8 d4 1a 00 00       	call   3f2f <link>
    245b:	83 c4 10             	add    $0x10,%esp
    245e:	85 c0                	test   %eax,%eax
    2460:	75 17                	jne    2479 <subdir+0x4fb>
    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
    2462:	83 ec 08             	sub    $0x8,%esp
    2465:	68 74 a6 01 00       	push   $0x1a674
    246a:	6a 01                	push   $0x1
    246c:	e8 05 1c 00 00       	call   4076 <printf>
    2471:	83 c4 10             	add    $0x10,%esp
    exit();
    2474:	e8 56 1a 00 00       	call   3ecf <exit>
  }
  if(link("dd/ff", "dd/dd/ffff") == 0){
    2479:	83 ec 08             	sub    $0x8,%esp
    247c:	68 8c a4 01 00       	push   $0x1a48c
    2481:	68 c4 a3 01 00       	push   $0x1a3c4
    2486:	e8 a4 1a 00 00       	call   3f2f <link>
    248b:	83 c4 10             	add    $0x10,%esp
    248e:	85 c0                	test   %eax,%eax
    2490:	75 17                	jne    24a9 <subdir+0x52b>
    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
    2492:	83 ec 08             	sub    $0x8,%esp
    2495:	68 98 a6 01 00       	push   $0x1a698
    249a:	6a 01                	push   $0x1
    249c:	e8 d5 1b 00 00       	call   4076 <printf>
    24a1:	83 c4 10             	add    $0x10,%esp
    exit();
    24a4:	e8 26 1a 00 00       	call   3ecf <exit>
  }
  if(mkdir("dd/ff/ff") == 0){
    24a9:	83 ec 0c             	sub    $0xc,%esp
    24ac:	68 b1 a5 01 00       	push   $0x1a5b1
    24b1:	e8 81 1a 00 00       	call   3f37 <mkdir>
    24b6:	83 c4 10             	add    $0x10,%esp
    24b9:	85 c0                	test   %eax,%eax
    24bb:	75 17                	jne    24d4 <subdir+0x556>
    printf(1, "mkdir dd/ff/ff succeeded!\n");
    24bd:	83 ec 08             	sub    $0x8,%esp
    24c0:	68 ba a6 01 00       	push   $0x1a6ba
    24c5:	6a 01                	push   $0x1
    24c7:	e8 aa 1b 00 00       	call   4076 <printf>
    24cc:	83 c4 10             	add    $0x10,%esp
    exit();
    24cf:	e8 fb 19 00 00       	call   3ecf <exit>
  }
  if(mkdir("dd/xx/ff") == 0){
    24d4:	83 ec 0c             	sub    $0xc,%esp
    24d7:	68 d6 a5 01 00       	push   $0x1a5d6
    24dc:	e8 56 1a 00 00       	call   3f37 <mkdir>
    24e1:	83 c4 10             	add    $0x10,%esp
    24e4:	85 c0                	test   %eax,%eax
    24e6:	75 17                	jne    24ff <subdir+0x581>
    printf(1, "mkdir dd/xx/ff succeeded!\n");
    24e8:	83 ec 08             	sub    $0x8,%esp
    24eb:	68 d5 a6 01 00       	push   $0x1a6d5
    24f0:	6a 01                	push   $0x1
    24f2:	e8 7f 1b 00 00       	call   4076 <printf>
    24f7:	83 c4 10             	add    $0x10,%esp
    exit();
    24fa:	e8 d0 19 00 00       	call   3ecf <exit>
  }
  if(mkdir("dd/dd/ffff") == 0){
    24ff:	83 ec 0c             	sub    $0xc,%esp
    2502:	68 8c a4 01 00       	push   $0x1a48c
    2507:	e8 2b 1a 00 00       	call   3f37 <mkdir>
    250c:	83 c4 10             	add    $0x10,%esp
    250f:	85 c0                	test   %eax,%eax
    2511:	75 17                	jne    252a <subdir+0x5ac>
    printf(1, "mkdir dd/dd/ffff succeeded!\n");
    2513:	83 ec 08             	sub    $0x8,%esp
    2516:	68 f0 a6 01 00       	push   $0x1a6f0
    251b:	6a 01                	push   $0x1
    251d:	e8 54 1b 00 00       	call   4076 <printf>
    2522:	83 c4 10             	add    $0x10,%esp
    exit();
    2525:	e8 a5 19 00 00       	call   3ecf <exit>
  }
  if(unlink("dd/xx/ff") == 0){
    252a:	83 ec 0c             	sub    $0xc,%esp
    252d:	68 d6 a5 01 00       	push   $0x1a5d6
    2532:	e8 e8 19 00 00       	call   3f1f <unlink>
    2537:	83 c4 10             	add    $0x10,%esp
    253a:	85 c0                	test   %eax,%eax
    253c:	75 17                	jne    2555 <subdir+0x5d7>
    printf(1, "unlink dd/xx/ff succeeded!\n");
    253e:	83 ec 08             	sub    $0x8,%esp
    2541:	68 0d a7 01 00       	push   $0x1a70d
    2546:	6a 01                	push   $0x1
    2548:	e8 29 1b 00 00       	call   4076 <printf>
    254d:	83 c4 10             	add    $0x10,%esp
    exit();
    2550:	e8 7a 19 00 00       	call   3ecf <exit>
  }
  if(unlink("dd/ff/ff") == 0){
    2555:	83 ec 0c             	sub    $0xc,%esp
    2558:	68 b1 a5 01 00       	push   $0x1a5b1
    255d:	e8 bd 19 00 00       	call   3f1f <unlink>
    2562:	83 c4 10             	add    $0x10,%esp
    2565:	85 c0                	test   %eax,%eax
    2567:	75 17                	jne    2580 <subdir+0x602>
    printf(1, "unlink dd/ff/ff succeeded!\n");
    2569:	83 ec 08             	sub    $0x8,%esp
    256c:	68 29 a7 01 00       	push   $0x1a729
    2571:	6a 01                	push   $0x1
    2573:	e8 fe 1a 00 00       	call   4076 <printf>
    2578:	83 c4 10             	add    $0x10,%esp
    exit();
    257b:	e8 4f 19 00 00       	call   3ecf <exit>
  }
  if(chdir("dd/ff") == 0){
    2580:	83 ec 0c             	sub    $0xc,%esp
    2583:	68 c4 a3 01 00       	push   $0x1a3c4
    2588:	e8 b2 19 00 00       	call   3f3f <chdir>
    258d:	83 c4 10             	add    $0x10,%esp
    2590:	85 c0                	test   %eax,%eax
    2592:	75 17                	jne    25ab <subdir+0x62d>
    printf(1, "chdir dd/ff succeeded!\n");
    2594:	83 ec 08             	sub    $0x8,%esp
    2597:	68 45 a7 01 00       	push   $0x1a745
    259c:	6a 01                	push   $0x1
    259e:	e8 d3 1a 00 00       	call   4076 <printf>
    25a3:	83 c4 10             	add    $0x10,%esp
    exit();
    25a6:	e8 24 19 00 00       	call   3ecf <exit>
  }
  if(chdir("dd/xx") == 0){
    25ab:	83 ec 0c             	sub    $0xc,%esp
    25ae:	68 5d a7 01 00       	push   $0x1a75d
    25b3:	e8 87 19 00 00       	call   3f3f <chdir>
    25b8:	83 c4 10             	add    $0x10,%esp
    25bb:	85 c0                	test   %eax,%eax
    25bd:	75 17                	jne    25d6 <subdir+0x658>
    printf(1, "chdir dd/xx succeeded!\n");
    25bf:	83 ec 08             	sub    $0x8,%esp
    25c2:	68 63 a7 01 00       	push   $0x1a763
    25c7:	6a 01                	push   $0x1
    25c9:	e8 a8 1a 00 00       	call   4076 <printf>
    25ce:	83 c4 10             	add    $0x10,%esp
    exit();
    25d1:	e8 f9 18 00 00       	call   3ecf <exit>
  }

  if(unlink("dd/dd/ffff") != 0){
    25d6:	83 ec 0c             	sub    $0xc,%esp
    25d9:	68 8c a4 01 00       	push   $0x1a48c
    25de:	e8 3c 19 00 00       	call   3f1f <unlink>
    25e3:	83 c4 10             	add    $0x10,%esp
    25e6:	85 c0                	test   %eax,%eax
    25e8:	74 17                	je     2601 <subdir+0x683>
    printf(1, "unlink dd/dd/ff failed\n");
    25ea:	83 ec 08             	sub    $0x8,%esp
    25ed:	68 b9 a4 01 00       	push   $0x1a4b9
    25f2:	6a 01                	push   $0x1
    25f4:	e8 7d 1a 00 00       	call   4076 <printf>
    25f9:	83 c4 10             	add    $0x10,%esp
    exit();
    25fc:	e8 ce 18 00 00       	call   3ecf <exit>
  }
  if(unlink("dd/ff") != 0){
    2601:	83 ec 0c             	sub    $0xc,%esp
    2604:	68 c4 a3 01 00       	push   $0x1a3c4
    2609:	e8 11 19 00 00       	call   3f1f <unlink>
    260e:	83 c4 10             	add    $0x10,%esp
    2611:	85 c0                	test   %eax,%eax
    2613:	74 17                	je     262c <subdir+0x6ae>
    printf(1, "unlink dd/ff failed\n");
    2615:	83 ec 08             	sub    $0x8,%esp
    2618:	68 7b a7 01 00       	push   $0x1a77b
    261d:	6a 01                	push   $0x1
    261f:	e8 52 1a 00 00       	call   4076 <printf>
    2624:	83 c4 10             	add    $0x10,%esp
    exit();
    2627:	e8 a3 18 00 00       	call   3ecf <exit>
  }
  if(unlink("dd") == 0){
    262c:	83 ec 0c             	sub    $0xc,%esp
    262f:	68 a9 a3 01 00       	push   $0x1a3a9
    2634:	e8 e6 18 00 00       	call   3f1f <unlink>
    2639:	83 c4 10             	add    $0x10,%esp
    263c:	85 c0                	test   %eax,%eax
    263e:	75 17                	jne    2657 <subdir+0x6d9>
    printf(1, "unlink non-empty dd succeeded!\n");
    2640:	83 ec 08             	sub    $0x8,%esp
    2643:	68 90 a7 01 00       	push   $0x1a790
    2648:	6a 01                	push   $0x1
    264a:	e8 27 1a 00 00       	call   4076 <printf>
    264f:	83 c4 10             	add    $0x10,%esp
    exit();
    2652:	e8 78 18 00 00       	call   3ecf <exit>
  }
  if(unlink("dd/dd") < 0){
    2657:	83 ec 0c             	sub    $0xc,%esp
    265a:	68 b0 a7 01 00       	push   $0x1a7b0
    265f:	e8 bb 18 00 00       	call   3f1f <unlink>
    2664:	83 c4 10             	add    $0x10,%esp
    2667:	85 c0                	test   %eax,%eax
    2669:	79 17                	jns    2682 <subdir+0x704>
    printf(1, "unlink dd/dd failed\n");
    266b:	83 ec 08             	sub    $0x8,%esp
    266e:	68 b6 a7 01 00       	push   $0x1a7b6
    2673:	6a 01                	push   $0x1
    2675:	e8 fc 19 00 00       	call   4076 <printf>
    267a:	83 c4 10             	add    $0x10,%esp
    exit();
    267d:	e8 4d 18 00 00       	call   3ecf <exit>
  }
  if(unlink("dd") < 0){
    2682:	83 ec 0c             	sub    $0xc,%esp
    2685:	68 a9 a3 01 00       	push   $0x1a3a9
    268a:	e8 90 18 00 00       	call   3f1f <unlink>
    268f:	83 c4 10             	add    $0x10,%esp
    2692:	85 c0                	test   %eax,%eax
    2694:	79 17                	jns    26ad <subdir+0x72f>
    printf(1, "unlink dd failed\n");
    2696:	83 ec 08             	sub    $0x8,%esp
    2699:	68 cb a7 01 00       	push   $0x1a7cb
    269e:	6a 01                	push   $0x1
    26a0:	e8 d1 19 00 00       	call   4076 <printf>
    26a5:	83 c4 10             	add    $0x10,%esp
    exit();
    26a8:	e8 22 18 00 00       	call   3ecf <exit>
  }

  printf(1, "subdir ok\n");
    26ad:	83 ec 08             	sub    $0x8,%esp
    26b0:	68 dd a7 01 00       	push   $0x1a7dd
    26b5:	6a 01                	push   $0x1
    26b7:	e8 ba 19 00 00       	call   4076 <printf>
    26bc:	83 c4 10             	add    $0x10,%esp
}
    26bf:	90                   	nop
    26c0:	c9                   	leave  
    26c1:	c3                   	ret    

000026c2 <bigwrite>:

// test writes that are larger than the log.
void
bigwrite(void)
{
    26c2:	55                   	push   %ebp
    26c3:	89 e5                	mov    %esp,%ebp
    26c5:	83 ec 18             	sub    $0x18,%esp
  int fd, sz;

  printf(1, "bigwrite test\n");
    26c8:	83 ec 08             	sub    $0x8,%esp
    26cb:	68 e8 a7 01 00       	push   $0x1a7e8
    26d0:	6a 01                	push   $0x1
    26d2:	e8 9f 19 00 00       	call   4076 <printf>
    26d7:	83 c4 10             	add    $0x10,%esp

  unlink("bigwrite");
    26da:	83 ec 0c             	sub    $0xc,%esp
    26dd:	68 f7 a7 01 00       	push   $0x1a7f7
    26e2:	e8 38 18 00 00       	call   3f1f <unlink>
    26e7:	83 c4 10             	add    $0x10,%esp
  for(sz = 499; sz < 12*512; sz += 471){
    26ea:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%ebp)
    26f1:	e9 a8 00 00 00       	jmp    279e <bigwrite+0xdc>
    fd = open("bigwrite", O_CREATE | O_RDWR);
    26f6:	83 ec 08             	sub    $0x8,%esp
    26f9:	68 02 02 00 00       	push   $0x202
    26fe:	68 f7 a7 01 00       	push   $0x1a7f7
    2703:	e8 07 18 00 00       	call   3f0f <open>
    2708:	83 c4 10             	add    $0x10,%esp
    270b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(fd < 0){
    270e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2712:	79 17                	jns    272b <bigwrite+0x69>
      printf(1, "cannot create bigwrite\n");
    2714:	83 ec 08             	sub    $0x8,%esp
    2717:	68 00 a8 01 00       	push   $0x1a800
    271c:	6a 01                	push   $0x1
    271e:	e8 53 19 00 00       	call   4076 <printf>
    2723:	83 c4 10             	add    $0x10,%esp
      exit();
    2726:	e8 a4 17 00 00       	call   3ecf <exit>
    }
    int i;
    for(i = 0; i < 2; i++){
    272b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2732:	eb 3f                	jmp    2773 <bigwrite+0xb1>
      int cc = write(fd, buf, sz);
    2734:	83 ec 04             	sub    $0x4,%esp
    2737:	ff 75 f4             	pushl  -0xc(%ebp)
    273a:	68 20 65 02 00       	push   $0x26520
    273f:	ff 75 ec             	pushl  -0x14(%ebp)
    2742:	e8 a8 17 00 00       	call   3eef <write>
    2747:	83 c4 10             	add    $0x10,%esp
    274a:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if(cc != sz){
    274d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2750:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2753:	74 1a                	je     276f <bigwrite+0xad>
        printf(1, "write(%d) ret %d\n", sz, cc);
    2755:	ff 75 e8             	pushl  -0x18(%ebp)
    2758:	ff 75 f4             	pushl  -0xc(%ebp)
    275b:	68 18 a8 01 00       	push   $0x1a818
    2760:	6a 01                	push   $0x1
    2762:	e8 0f 19 00 00       	call   4076 <printf>
    2767:	83 c4 10             	add    $0x10,%esp
        exit();
    276a:	e8 60 17 00 00       	call   3ecf <exit>
    if(fd < 0){
      printf(1, "cannot create bigwrite\n");
      exit();
    }
    int i;
    for(i = 0; i < 2; i++){
    276f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2773:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    2777:	7e bb                	jle    2734 <bigwrite+0x72>
      if(cc != sz){
        printf(1, "write(%d) ret %d\n", sz, cc);
        exit();
      }
    }
    close(fd);
    2779:	83 ec 0c             	sub    $0xc,%esp
    277c:	ff 75 ec             	pushl  -0x14(%ebp)
    277f:	e8 73 17 00 00       	call   3ef7 <close>
    2784:	83 c4 10             	add    $0x10,%esp
    unlink("bigwrite");
    2787:	83 ec 0c             	sub    $0xc,%esp
    278a:	68 f7 a7 01 00       	push   $0x1a7f7
    278f:	e8 8b 17 00 00       	call   3f1f <unlink>
    2794:	83 c4 10             	add    $0x10,%esp
  int fd, sz;

  printf(1, "bigwrite test\n");

  unlink("bigwrite");
  for(sz = 499; sz < 12*512; sz += 471){
    2797:	81 45 f4 d7 01 00 00 	addl   $0x1d7,-0xc(%ebp)
    279e:	81 7d f4 ff 17 00 00 	cmpl   $0x17ff,-0xc(%ebp)
    27a5:	0f 8e 4b ff ff ff    	jle    26f6 <bigwrite+0x34>
    }
    close(fd);
    unlink("bigwrite");
  }

  printf(1, "bigwrite ok\n");
    27ab:	83 ec 08             	sub    $0x8,%esp
    27ae:	68 2a a8 01 00       	push   $0x1a82a
    27b3:	6a 01                	push   $0x1
    27b5:	e8 bc 18 00 00       	call   4076 <printf>
    27ba:	83 c4 10             	add    $0x10,%esp
}
    27bd:	90                   	nop
    27be:	c9                   	leave  
    27bf:	c3                   	ret    

000027c0 <bigfile>:

void
bigfile(void)
{
    27c0:	55                   	push   %ebp
    27c1:	89 e5                	mov    %esp,%ebp
    27c3:	83 ec 18             	sub    $0x18,%esp
  int fd, i, total, cc;

  printf(1, "bigfile test\n");
    27c6:	83 ec 08             	sub    $0x8,%esp
    27c9:	68 37 a8 01 00       	push   $0x1a837
    27ce:	6a 01                	push   $0x1
    27d0:	e8 a1 18 00 00       	call   4076 <printf>
    27d5:	83 c4 10             	add    $0x10,%esp

  unlink("bigfile");
    27d8:	83 ec 0c             	sub    $0xc,%esp
    27db:	68 45 a8 01 00       	push   $0x1a845
    27e0:	e8 3a 17 00 00       	call   3f1f <unlink>
    27e5:	83 c4 10             	add    $0x10,%esp
  fd = open("bigfile", O_CREATE | O_RDWR);
    27e8:	83 ec 08             	sub    $0x8,%esp
    27eb:	68 02 02 00 00       	push   $0x202
    27f0:	68 45 a8 01 00       	push   $0x1a845
    27f5:	e8 15 17 00 00       	call   3f0f <open>
    27fa:	83 c4 10             	add    $0x10,%esp
    27fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(fd < 0){
    2800:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2804:	79 17                	jns    281d <bigfile+0x5d>
    printf(1, "cannot create bigfile");
    2806:	83 ec 08             	sub    $0x8,%esp
    2809:	68 4d a8 01 00       	push   $0x1a84d
    280e:	6a 01                	push   $0x1
    2810:	e8 61 18 00 00       	call   4076 <printf>
    2815:	83 c4 10             	add    $0x10,%esp
    exit();
    2818:	e8 b2 16 00 00       	call   3ecf <exit>
  }
  for(i = 0; i < 20; i++){
    281d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2824:	eb 52                	jmp    2878 <bigfile+0xb8>
    memset(buf, i, 600);
    2826:	83 ec 04             	sub    $0x4,%esp
    2829:	68 58 02 00 00       	push   $0x258
    282e:	ff 75 f4             	pushl  -0xc(%ebp)
    2831:	68 20 65 02 00       	push   $0x26520
    2836:	e8 f9 14 00 00       	call   3d34 <memset>
    283b:	83 c4 10             	add    $0x10,%esp
    if(write(fd, buf, 600) != 600){
    283e:	83 ec 04             	sub    $0x4,%esp
    2841:	68 58 02 00 00       	push   $0x258
    2846:	68 20 65 02 00       	push   $0x26520
    284b:	ff 75 ec             	pushl  -0x14(%ebp)
    284e:	e8 9c 16 00 00       	call   3eef <write>
    2853:	83 c4 10             	add    $0x10,%esp
    2856:	3d 58 02 00 00       	cmp    $0x258,%eax
    285b:	74 17                	je     2874 <bigfile+0xb4>
      printf(1, "write bigfile failed\n");
    285d:	83 ec 08             	sub    $0x8,%esp
    2860:	68 63 a8 01 00       	push   $0x1a863
    2865:	6a 01                	push   $0x1
    2867:	e8 0a 18 00 00       	call   4076 <printf>
    286c:	83 c4 10             	add    $0x10,%esp
      exit();
    286f:	e8 5b 16 00 00       	call   3ecf <exit>
  fd = open("bigfile", O_CREATE | O_RDWR);
  if(fd < 0){
    printf(1, "cannot create bigfile");
    exit();
  }
  for(i = 0; i < 20; i++){
    2874:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2878:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
    287c:	7e a8                	jle    2826 <bigfile+0x66>
    if(write(fd, buf, 600) != 600){
      printf(1, "write bigfile failed\n");
      exit();
    }
  }
  close(fd);
    287e:	83 ec 0c             	sub    $0xc,%esp
    2881:	ff 75 ec             	pushl  -0x14(%ebp)
    2884:	e8 6e 16 00 00       	call   3ef7 <close>
    2889:	83 c4 10             	add    $0x10,%esp

  fd = open("bigfile", 0);
    288c:	83 ec 08             	sub    $0x8,%esp
    288f:	6a 00                	push   $0x0
    2891:	68 45 a8 01 00       	push   $0x1a845
    2896:	e8 74 16 00 00       	call   3f0f <open>
    289b:	83 c4 10             	add    $0x10,%esp
    289e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(fd < 0){
    28a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    28a5:	79 17                	jns    28be <bigfile+0xfe>
    printf(1, "cannot open bigfile\n");
    28a7:	83 ec 08             	sub    $0x8,%esp
    28aa:	68 79 a8 01 00       	push   $0x1a879
    28af:	6a 01                	push   $0x1
    28b1:	e8 c0 17 00 00       	call   4076 <printf>
    28b6:	83 c4 10             	add    $0x10,%esp
    exit();
    28b9:	e8 11 16 00 00       	call   3ecf <exit>
  }
  total = 0;
    28be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; ; i++){
    28c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cc = read(fd, buf, 300);
    28cc:	83 ec 04             	sub    $0x4,%esp
    28cf:	68 2c 01 00 00       	push   $0x12c
    28d4:	68 20 65 02 00       	push   $0x26520
    28d9:	ff 75 ec             	pushl  -0x14(%ebp)
    28dc:	e8 06 16 00 00       	call   3ee7 <read>
    28e1:	83 c4 10             	add    $0x10,%esp
    28e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(cc < 0){
    28e7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    28eb:	79 17                	jns    2904 <bigfile+0x144>
      printf(1, "read bigfile failed\n");
    28ed:	83 ec 08             	sub    $0x8,%esp
    28f0:	68 8e a8 01 00       	push   $0x1a88e
    28f5:	6a 01                	push   $0x1
    28f7:	e8 7a 17 00 00       	call   4076 <printf>
    28fc:	83 c4 10             	add    $0x10,%esp
      exit();
    28ff:	e8 cb 15 00 00       	call   3ecf <exit>
    }
    if(cc == 0)
    2904:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    2908:	74 7a                	je     2984 <bigfile+0x1c4>
      break;
    if(cc != 300){
    290a:	81 7d e8 2c 01 00 00 	cmpl   $0x12c,-0x18(%ebp)
    2911:	74 17                	je     292a <bigfile+0x16a>
      printf(1, "short read bigfile\n");
    2913:	83 ec 08             	sub    $0x8,%esp
    2916:	68 a3 a8 01 00       	push   $0x1a8a3
    291b:	6a 01                	push   $0x1
    291d:	e8 54 17 00 00       	call   4076 <printf>
    2922:	83 c4 10             	add    $0x10,%esp
      exit();
    2925:	e8 a5 15 00 00       	call   3ecf <exit>
    }
    if(buf[0] != i/2 || buf[299] != i/2){
    292a:	0f b6 05 20 65 02 00 	movzbl 0x26520,%eax
    2931:	0f be d0             	movsbl %al,%edx
    2934:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2937:	89 c1                	mov    %eax,%ecx
    2939:	c1 e9 1f             	shr    $0x1f,%ecx
    293c:	01 c8                	add    %ecx,%eax
    293e:	d1 f8                	sar    %eax
    2940:	39 c2                	cmp    %eax,%edx
    2942:	75 1a                	jne    295e <bigfile+0x19e>
    2944:	0f b6 05 4b 66 02 00 	movzbl 0x2664b,%eax
    294b:	0f be d0             	movsbl %al,%edx
    294e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2951:	89 c1                	mov    %eax,%ecx
    2953:	c1 e9 1f             	shr    $0x1f,%ecx
    2956:	01 c8                	add    %ecx,%eax
    2958:	d1 f8                	sar    %eax
    295a:	39 c2                	cmp    %eax,%edx
    295c:	74 17                	je     2975 <bigfile+0x1b5>
      printf(1, "read bigfile wrong data\n");
    295e:	83 ec 08             	sub    $0x8,%esp
    2961:	68 b7 a8 01 00       	push   $0x1a8b7
    2966:	6a 01                	push   $0x1
    2968:	e8 09 17 00 00       	call   4076 <printf>
    296d:	83 c4 10             	add    $0x10,%esp
      exit();
    2970:	e8 5a 15 00 00       	call   3ecf <exit>
    }
    total += cc;
    2975:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2978:	01 45 f0             	add    %eax,-0x10(%ebp)
  if(fd < 0){
    printf(1, "cannot open bigfile\n");
    exit();
  }
  total = 0;
  for(i = 0; ; i++){
    297b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    if(buf[0] != i/2 || buf[299] != i/2){
      printf(1, "read bigfile wrong data\n");
      exit();
    }
    total += cc;
  }
    297f:	e9 48 ff ff ff       	jmp    28cc <bigfile+0x10c>
    if(cc < 0){
      printf(1, "read bigfile failed\n");
      exit();
    }
    if(cc == 0)
      break;
    2984:	90                   	nop
      printf(1, "read bigfile wrong data\n");
      exit();
    }
    total += cc;
  }
  close(fd);
    2985:	83 ec 0c             	sub    $0xc,%esp
    2988:	ff 75 ec             	pushl  -0x14(%ebp)
    298b:	e8 67 15 00 00       	call   3ef7 <close>
    2990:	83 c4 10             	add    $0x10,%esp
  if(total != 20*600){
    2993:	81 7d f0 e0 2e 00 00 	cmpl   $0x2ee0,-0x10(%ebp)
    299a:	74 17                	je     29b3 <bigfile+0x1f3>
    printf(1, "read bigfile wrong total\n");
    299c:	83 ec 08             	sub    $0x8,%esp
    299f:	68 d0 a8 01 00       	push   $0x1a8d0
    29a4:	6a 01                	push   $0x1
    29a6:	e8 cb 16 00 00       	call   4076 <printf>
    29ab:	83 c4 10             	add    $0x10,%esp
    exit();
    29ae:	e8 1c 15 00 00       	call   3ecf <exit>
  }
  unlink("bigfile");
    29b3:	83 ec 0c             	sub    $0xc,%esp
    29b6:	68 45 a8 01 00       	push   $0x1a845
    29bb:	e8 5f 15 00 00       	call   3f1f <unlink>
    29c0:	83 c4 10             	add    $0x10,%esp

  printf(1, "bigfile test ok\n");
    29c3:	83 ec 08             	sub    $0x8,%esp
    29c6:	68 ea a8 01 00       	push   $0x1a8ea
    29cb:	6a 01                	push   $0x1
    29cd:	e8 a4 16 00 00       	call   4076 <printf>
    29d2:	83 c4 10             	add    $0x10,%esp
}
    29d5:	90                   	nop
    29d6:	c9                   	leave  
    29d7:	c3                   	ret    

000029d8 <fourteen>:

void
fourteen(void)
{
    29d8:	55                   	push   %ebp
    29d9:	89 e5                	mov    %esp,%ebp
    29db:	83 ec 18             	sub    $0x18,%esp
  int fd;

  // DIRSIZ is 14.
  printf(1, "fourteen test\n");
    29de:	83 ec 08             	sub    $0x8,%esp
    29e1:	68 fb a8 01 00       	push   $0x1a8fb
    29e6:	6a 01                	push   $0x1
    29e8:	e8 89 16 00 00       	call   4076 <printf>
    29ed:	83 c4 10             	add    $0x10,%esp

  if(mkdir("12345678901234") != 0){
    29f0:	83 ec 0c             	sub    $0xc,%esp
    29f3:	68 0a a9 01 00       	push   $0x1a90a
    29f8:	e8 3a 15 00 00       	call   3f37 <mkdir>
    29fd:	83 c4 10             	add    $0x10,%esp
    2a00:	85 c0                	test   %eax,%eax
    2a02:	74 17                	je     2a1b <fourteen+0x43>
    printf(1, "mkdir 12345678901234 failed\n");
    2a04:	83 ec 08             	sub    $0x8,%esp
    2a07:	68 19 a9 01 00       	push   $0x1a919
    2a0c:	6a 01                	push   $0x1
    2a0e:	e8 63 16 00 00       	call   4076 <printf>
    2a13:	83 c4 10             	add    $0x10,%esp
    exit();
    2a16:	e8 b4 14 00 00       	call   3ecf <exit>
  }
  if(mkdir("12345678901234/123456789012345") != 0){
    2a1b:	83 ec 0c             	sub    $0xc,%esp
    2a1e:	68 38 a9 01 00       	push   $0x1a938
    2a23:	e8 0f 15 00 00       	call   3f37 <mkdir>
    2a28:	83 c4 10             	add    $0x10,%esp
    2a2b:	85 c0                	test   %eax,%eax
    2a2d:	74 17                	je     2a46 <fourteen+0x6e>
    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
    2a2f:	83 ec 08             	sub    $0x8,%esp
    2a32:	68 58 a9 01 00       	push   $0x1a958
    2a37:	6a 01                	push   $0x1
    2a39:	e8 38 16 00 00       	call   4076 <printf>
    2a3e:	83 c4 10             	add    $0x10,%esp
    exit();
    2a41:	e8 89 14 00 00       	call   3ecf <exit>
  }
  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
    2a46:	83 ec 08             	sub    $0x8,%esp
    2a49:	68 00 02 00 00       	push   $0x200
    2a4e:	68 88 a9 01 00       	push   $0x1a988
    2a53:	e8 b7 14 00 00       	call   3f0f <open>
    2a58:	83 c4 10             	add    $0x10,%esp
    2a5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    2a5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2a62:	79 17                	jns    2a7b <fourteen+0xa3>
    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
    2a64:	83 ec 08             	sub    $0x8,%esp
    2a67:	68 b8 a9 01 00       	push   $0x1a9b8
    2a6c:	6a 01                	push   $0x1
    2a6e:	e8 03 16 00 00       	call   4076 <printf>
    2a73:	83 c4 10             	add    $0x10,%esp
    exit();
    2a76:	e8 54 14 00 00       	call   3ecf <exit>
  }
  close(fd);
    2a7b:	83 ec 0c             	sub    $0xc,%esp
    2a7e:	ff 75 f4             	pushl  -0xc(%ebp)
    2a81:	e8 71 14 00 00       	call   3ef7 <close>
    2a86:	83 c4 10             	add    $0x10,%esp
  fd = open("12345678901234/12345678901234/12345678901234", 0);
    2a89:	83 ec 08             	sub    $0x8,%esp
    2a8c:	6a 00                	push   $0x0
    2a8e:	68 f8 a9 01 00       	push   $0x1a9f8
    2a93:	e8 77 14 00 00       	call   3f0f <open>
    2a98:	83 c4 10             	add    $0x10,%esp
    2a9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    2a9e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2aa2:	79 17                	jns    2abb <fourteen+0xe3>
    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
    2aa4:	83 ec 08             	sub    $0x8,%esp
    2aa7:	68 28 aa 01 00       	push   $0x1aa28
    2aac:	6a 01                	push   $0x1
    2aae:	e8 c3 15 00 00       	call   4076 <printf>
    2ab3:	83 c4 10             	add    $0x10,%esp
    exit();
    2ab6:	e8 14 14 00 00       	call   3ecf <exit>
  }
  close(fd);
    2abb:	83 ec 0c             	sub    $0xc,%esp
    2abe:	ff 75 f4             	pushl  -0xc(%ebp)
    2ac1:	e8 31 14 00 00       	call   3ef7 <close>
    2ac6:	83 c4 10             	add    $0x10,%esp

  if(mkdir("12345678901234/12345678901234") == 0){
    2ac9:	83 ec 0c             	sub    $0xc,%esp
    2acc:	68 62 aa 01 00       	push   $0x1aa62
    2ad1:	e8 61 14 00 00       	call   3f37 <mkdir>
    2ad6:	83 c4 10             	add    $0x10,%esp
    2ad9:	85 c0                	test   %eax,%eax
    2adb:	75 17                	jne    2af4 <fourteen+0x11c>
    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
    2add:	83 ec 08             	sub    $0x8,%esp
    2ae0:	68 80 aa 01 00       	push   $0x1aa80
    2ae5:	6a 01                	push   $0x1
    2ae7:	e8 8a 15 00 00       	call   4076 <printf>
    2aec:	83 c4 10             	add    $0x10,%esp
    exit();
    2aef:	e8 db 13 00 00       	call   3ecf <exit>
  }
  if(mkdir("123456789012345/12345678901234") == 0){
    2af4:	83 ec 0c             	sub    $0xc,%esp
    2af7:	68 b0 aa 01 00       	push   $0x1aab0
    2afc:	e8 36 14 00 00       	call   3f37 <mkdir>
    2b01:	83 c4 10             	add    $0x10,%esp
    2b04:	85 c0                	test   %eax,%eax
    2b06:	75 17                	jne    2b1f <fourteen+0x147>
    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
    2b08:	83 ec 08             	sub    $0x8,%esp
    2b0b:	68 d0 aa 01 00       	push   $0x1aad0
    2b10:	6a 01                	push   $0x1
    2b12:	e8 5f 15 00 00       	call   4076 <printf>
    2b17:	83 c4 10             	add    $0x10,%esp
    exit();
    2b1a:	e8 b0 13 00 00       	call   3ecf <exit>
  }

  printf(1, "fourteen ok\n");
    2b1f:	83 ec 08             	sub    $0x8,%esp
    2b22:	68 01 ab 01 00       	push   $0x1ab01
    2b27:	6a 01                	push   $0x1
    2b29:	e8 48 15 00 00       	call   4076 <printf>
    2b2e:	83 c4 10             	add    $0x10,%esp
}
    2b31:	90                   	nop
    2b32:	c9                   	leave  
    2b33:	c3                   	ret    

00002b34 <rmdot>:

void
rmdot(void)
{
    2b34:	55                   	push   %ebp
    2b35:	89 e5                	mov    %esp,%ebp
    2b37:	83 ec 08             	sub    $0x8,%esp
  printf(1, "rmdot test\n");
    2b3a:	83 ec 08             	sub    $0x8,%esp
    2b3d:	68 0e ab 01 00       	push   $0x1ab0e
    2b42:	6a 01                	push   $0x1
    2b44:	e8 2d 15 00 00       	call   4076 <printf>
    2b49:	83 c4 10             	add    $0x10,%esp
  if(mkdir("dots") != 0){
    2b4c:	83 ec 0c             	sub    $0xc,%esp
    2b4f:	68 1a ab 01 00       	push   $0x1ab1a
    2b54:	e8 de 13 00 00       	call   3f37 <mkdir>
    2b59:	83 c4 10             	add    $0x10,%esp
    2b5c:	85 c0                	test   %eax,%eax
    2b5e:	74 17                	je     2b77 <rmdot+0x43>
    printf(1, "mkdir dots failed\n");
    2b60:	83 ec 08             	sub    $0x8,%esp
    2b63:	68 1f ab 01 00       	push   $0x1ab1f
    2b68:	6a 01                	push   $0x1
    2b6a:	e8 07 15 00 00       	call   4076 <printf>
    2b6f:	83 c4 10             	add    $0x10,%esp
    exit();
    2b72:	e8 58 13 00 00       	call   3ecf <exit>
  }
  if(chdir("dots") != 0){
    2b77:	83 ec 0c             	sub    $0xc,%esp
    2b7a:	68 1a ab 01 00       	push   $0x1ab1a
    2b7f:	e8 bb 13 00 00       	call   3f3f <chdir>
    2b84:	83 c4 10             	add    $0x10,%esp
    2b87:	85 c0                	test   %eax,%eax
    2b89:	74 17                	je     2ba2 <rmdot+0x6e>
    printf(1, "chdir dots failed\n");
    2b8b:	83 ec 08             	sub    $0x8,%esp
    2b8e:	68 32 ab 01 00       	push   $0x1ab32
    2b93:	6a 01                	push   $0x1
    2b95:	e8 dc 14 00 00       	call   4076 <printf>
    2b9a:	83 c4 10             	add    $0x10,%esp
    exit();
    2b9d:	e8 2d 13 00 00       	call   3ecf <exit>
  }
  if(unlink(".") == 0){
    2ba2:	83 ec 0c             	sub    $0xc,%esp
    2ba5:	68 4b a2 01 00       	push   $0x1a24b
    2baa:	e8 70 13 00 00       	call   3f1f <unlink>
    2baf:	83 c4 10             	add    $0x10,%esp
    2bb2:	85 c0                	test   %eax,%eax
    2bb4:	75 17                	jne    2bcd <rmdot+0x99>
    printf(1, "rm . worked!\n");
    2bb6:	83 ec 08             	sub    $0x8,%esp
    2bb9:	68 45 ab 01 00       	push   $0x1ab45
    2bbe:	6a 01                	push   $0x1
    2bc0:	e8 b1 14 00 00       	call   4076 <printf>
    2bc5:	83 c4 10             	add    $0x10,%esp
    exit();
    2bc8:	e8 02 13 00 00       	call   3ecf <exit>
  }
  if(unlink("..") == 0){
    2bcd:	83 ec 0c             	sub    $0xc,%esp
    2bd0:	68 de 9d 01 00       	push   $0x19dde
    2bd5:	e8 45 13 00 00       	call   3f1f <unlink>
    2bda:	83 c4 10             	add    $0x10,%esp
    2bdd:	85 c0                	test   %eax,%eax
    2bdf:	75 17                	jne    2bf8 <rmdot+0xc4>
    printf(1, "rm .. worked!\n");
    2be1:	83 ec 08             	sub    $0x8,%esp
    2be4:	68 53 ab 01 00       	push   $0x1ab53
    2be9:	6a 01                	push   $0x1
    2beb:	e8 86 14 00 00       	call   4076 <printf>
    2bf0:	83 c4 10             	add    $0x10,%esp
    exit();
    2bf3:	e8 d7 12 00 00       	call   3ecf <exit>
  }
  if(chdir("/") != 0){
    2bf8:	83 ec 0c             	sub    $0xc,%esp
    2bfb:	68 32 9a 01 00       	push   $0x19a32
    2c00:	e8 3a 13 00 00       	call   3f3f <chdir>
    2c05:	83 c4 10             	add    $0x10,%esp
    2c08:	85 c0                	test   %eax,%eax
    2c0a:	74 17                	je     2c23 <rmdot+0xef>
    printf(1, "chdir / failed\n");
    2c0c:	83 ec 08             	sub    $0x8,%esp
    2c0f:	68 34 9a 01 00       	push   $0x19a34
    2c14:	6a 01                	push   $0x1
    2c16:	e8 5b 14 00 00       	call   4076 <printf>
    2c1b:	83 c4 10             	add    $0x10,%esp
    exit();
    2c1e:	e8 ac 12 00 00       	call   3ecf <exit>
  }
  if(unlink("dots/.") == 0){
    2c23:	83 ec 0c             	sub    $0xc,%esp
    2c26:	68 62 ab 01 00       	push   $0x1ab62
    2c2b:	e8 ef 12 00 00       	call   3f1f <unlink>
    2c30:	83 c4 10             	add    $0x10,%esp
    2c33:	85 c0                	test   %eax,%eax
    2c35:	75 17                	jne    2c4e <rmdot+0x11a>
    printf(1, "unlink dots/. worked!\n");
    2c37:	83 ec 08             	sub    $0x8,%esp
    2c3a:	68 69 ab 01 00       	push   $0x1ab69
    2c3f:	6a 01                	push   $0x1
    2c41:	e8 30 14 00 00       	call   4076 <printf>
    2c46:	83 c4 10             	add    $0x10,%esp
    exit();
    2c49:	e8 81 12 00 00       	call   3ecf <exit>
  }
  if(unlink("dots/..") == 0){
    2c4e:	83 ec 0c             	sub    $0xc,%esp
    2c51:	68 80 ab 01 00       	push   $0x1ab80
    2c56:	e8 c4 12 00 00       	call   3f1f <unlink>
    2c5b:	83 c4 10             	add    $0x10,%esp
    2c5e:	85 c0                	test   %eax,%eax
    2c60:	75 17                	jne    2c79 <rmdot+0x145>
    printf(1, "unlink dots/.. worked!\n");
    2c62:	83 ec 08             	sub    $0x8,%esp
    2c65:	68 88 ab 01 00       	push   $0x1ab88
    2c6a:	6a 01                	push   $0x1
    2c6c:	e8 05 14 00 00       	call   4076 <printf>
    2c71:	83 c4 10             	add    $0x10,%esp
    exit();
    2c74:	e8 56 12 00 00       	call   3ecf <exit>
  }
  if(unlink("dots") != 0){
    2c79:	83 ec 0c             	sub    $0xc,%esp
    2c7c:	68 1a ab 01 00       	push   $0x1ab1a
    2c81:	e8 99 12 00 00       	call   3f1f <unlink>
    2c86:	83 c4 10             	add    $0x10,%esp
    2c89:	85 c0                	test   %eax,%eax
    2c8b:	74 17                	je     2ca4 <rmdot+0x170>
    printf(1, "unlink dots failed!\n");
    2c8d:	83 ec 08             	sub    $0x8,%esp
    2c90:	68 a0 ab 01 00       	push   $0x1aba0
    2c95:	6a 01                	push   $0x1
    2c97:	e8 da 13 00 00       	call   4076 <printf>
    2c9c:	83 c4 10             	add    $0x10,%esp
    exit();
    2c9f:	e8 2b 12 00 00       	call   3ecf <exit>
  }
  printf(1, "rmdot ok\n");
    2ca4:	83 ec 08             	sub    $0x8,%esp
    2ca7:	68 b5 ab 01 00       	push   $0x1abb5
    2cac:	6a 01                	push   $0x1
    2cae:	e8 c3 13 00 00       	call   4076 <printf>
    2cb3:	83 c4 10             	add    $0x10,%esp
}
    2cb6:	90                   	nop
    2cb7:	c9                   	leave  
    2cb8:	c3                   	ret    

00002cb9 <dirfile>:

void
dirfile(void)
{
    2cb9:	55                   	push   %ebp
    2cba:	89 e5                	mov    %esp,%ebp
    2cbc:	83 ec 18             	sub    $0x18,%esp
  int fd;

  printf(1, "dir vs file\n");
    2cbf:	83 ec 08             	sub    $0x8,%esp
    2cc2:	68 bf ab 01 00       	push   $0x1abbf
    2cc7:	6a 01                	push   $0x1
    2cc9:	e8 a8 13 00 00       	call   4076 <printf>
    2cce:	83 c4 10             	add    $0x10,%esp

  fd = open("dirfile", O_CREATE);
    2cd1:	83 ec 08             	sub    $0x8,%esp
    2cd4:	68 00 02 00 00       	push   $0x200
    2cd9:	68 cc ab 01 00       	push   $0x1abcc
    2cde:	e8 2c 12 00 00       	call   3f0f <open>
    2ce3:	83 c4 10             	add    $0x10,%esp
    2ce6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0){
    2ce9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2ced:	79 17                	jns    2d06 <dirfile+0x4d>
    printf(1, "create dirfile failed\n");
    2cef:	83 ec 08             	sub    $0x8,%esp
    2cf2:	68 d4 ab 01 00       	push   $0x1abd4
    2cf7:	6a 01                	push   $0x1
    2cf9:	e8 78 13 00 00       	call   4076 <printf>
    2cfe:	83 c4 10             	add    $0x10,%esp
    exit();
    2d01:	e8 c9 11 00 00       	call   3ecf <exit>
  }
  close(fd);
    2d06:	83 ec 0c             	sub    $0xc,%esp
    2d09:	ff 75 f4             	pushl  -0xc(%ebp)
    2d0c:	e8 e6 11 00 00       	call   3ef7 <close>
    2d11:	83 c4 10             	add    $0x10,%esp
  if(chdir("dirfile") == 0){
    2d14:	83 ec 0c             	sub    $0xc,%esp
    2d17:	68 cc ab 01 00       	push   $0x1abcc
    2d1c:	e8 1e 12 00 00       	call   3f3f <chdir>
    2d21:	83 c4 10             	add    $0x10,%esp
    2d24:	85 c0                	test   %eax,%eax
    2d26:	75 17                	jne    2d3f <dirfile+0x86>
    printf(1, "chdir dirfile succeeded!\n");
    2d28:	83 ec 08             	sub    $0x8,%esp
    2d2b:	68 eb ab 01 00       	push   $0x1abeb
    2d30:	6a 01                	push   $0x1
    2d32:	e8 3f 13 00 00       	call   4076 <printf>
    2d37:	83 c4 10             	add    $0x10,%esp
    exit();
    2d3a:	e8 90 11 00 00       	call   3ecf <exit>
  }
  fd = open("dirfile/xx", 0);
    2d3f:	83 ec 08             	sub    $0x8,%esp
    2d42:	6a 00                	push   $0x0
    2d44:	68 05 ac 01 00       	push   $0x1ac05
    2d49:	e8 c1 11 00 00       	call   3f0f <open>
    2d4e:	83 c4 10             	add    $0x10,%esp
    2d51:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd >= 0){
    2d54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2d58:	78 17                	js     2d71 <dirfile+0xb8>
    printf(1, "create dirfile/xx succeeded!\n");
    2d5a:	83 ec 08             	sub    $0x8,%esp
    2d5d:	68 10 ac 01 00       	push   $0x1ac10
    2d62:	6a 01                	push   $0x1
    2d64:	e8 0d 13 00 00       	call   4076 <printf>
    2d69:	83 c4 10             	add    $0x10,%esp
    exit();
    2d6c:	e8 5e 11 00 00       	call   3ecf <exit>
  }
  fd = open("dirfile/xx", O_CREATE);
    2d71:	83 ec 08             	sub    $0x8,%esp
    2d74:	68 00 02 00 00       	push   $0x200
    2d79:	68 05 ac 01 00       	push   $0x1ac05
    2d7e:	e8 8c 11 00 00       	call   3f0f <open>
    2d83:	83 c4 10             	add    $0x10,%esp
    2d86:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd >= 0){
    2d89:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2d8d:	78 17                	js     2da6 <dirfile+0xed>
    printf(1, "create dirfile/xx succeeded!\n");
    2d8f:	83 ec 08             	sub    $0x8,%esp
    2d92:	68 10 ac 01 00       	push   $0x1ac10
    2d97:	6a 01                	push   $0x1
    2d99:	e8 d8 12 00 00       	call   4076 <printf>
    2d9e:	83 c4 10             	add    $0x10,%esp
    exit();
    2da1:	e8 29 11 00 00       	call   3ecf <exit>
  }
  if(mkdir("dirfile/xx") == 0){
    2da6:	83 ec 0c             	sub    $0xc,%esp
    2da9:	68 05 ac 01 00       	push   $0x1ac05
    2dae:	e8 84 11 00 00       	call   3f37 <mkdir>
    2db3:	83 c4 10             	add    $0x10,%esp
    2db6:	85 c0                	test   %eax,%eax
    2db8:	75 17                	jne    2dd1 <dirfile+0x118>
    printf(1, "mkdir dirfile/xx succeeded!\n");
    2dba:	83 ec 08             	sub    $0x8,%esp
    2dbd:	68 2e ac 01 00       	push   $0x1ac2e
    2dc2:	6a 01                	push   $0x1
    2dc4:	e8 ad 12 00 00       	call   4076 <printf>
    2dc9:	83 c4 10             	add    $0x10,%esp
    exit();
    2dcc:	e8 fe 10 00 00       	call   3ecf <exit>
  }
  if(unlink("dirfile/xx") == 0){
    2dd1:	83 ec 0c             	sub    $0xc,%esp
    2dd4:	68 05 ac 01 00       	push   $0x1ac05
    2dd9:	e8 41 11 00 00       	call   3f1f <unlink>
    2dde:	83 c4 10             	add    $0x10,%esp
    2de1:	85 c0                	test   %eax,%eax
    2de3:	75 17                	jne    2dfc <dirfile+0x143>
    printf(1, "unlink dirfile/xx succeeded!\n");
    2de5:	83 ec 08             	sub    $0x8,%esp
    2de8:	68 4b ac 01 00       	push   $0x1ac4b
    2ded:	6a 01                	push   $0x1
    2def:	e8 82 12 00 00       	call   4076 <printf>
    2df4:	83 c4 10             	add    $0x10,%esp
    exit();
    2df7:	e8 d3 10 00 00       	call   3ecf <exit>
  }
  if(link("README", "dirfile/xx") == 0){
    2dfc:	83 ec 08             	sub    $0x8,%esp
    2dff:	68 05 ac 01 00       	push   $0x1ac05
    2e04:	68 69 ac 01 00       	push   $0x1ac69
    2e09:	e8 21 11 00 00       	call   3f2f <link>
    2e0e:	83 c4 10             	add    $0x10,%esp
    2e11:	85 c0                	test   %eax,%eax
    2e13:	75 17                	jne    2e2c <dirfile+0x173>
    printf(1, "link to dirfile/xx succeeded!\n");
    2e15:	83 ec 08             	sub    $0x8,%esp
    2e18:	68 70 ac 01 00       	push   $0x1ac70
    2e1d:	6a 01                	push   $0x1
    2e1f:	e8 52 12 00 00       	call   4076 <printf>
    2e24:	83 c4 10             	add    $0x10,%esp
    exit();
    2e27:	e8 a3 10 00 00       	call   3ecf <exit>
  }
  if(unlink("dirfile") != 0){
    2e2c:	83 ec 0c             	sub    $0xc,%esp
    2e2f:	68 cc ab 01 00       	push   $0x1abcc
    2e34:	e8 e6 10 00 00       	call   3f1f <unlink>
    2e39:	83 c4 10             	add    $0x10,%esp
    2e3c:	85 c0                	test   %eax,%eax
    2e3e:	74 17                	je     2e57 <dirfile+0x19e>
    printf(1, "unlink dirfile failed!\n");
    2e40:	83 ec 08             	sub    $0x8,%esp
    2e43:	68 8f ac 01 00       	push   $0x1ac8f
    2e48:	6a 01                	push   $0x1
    2e4a:	e8 27 12 00 00       	call   4076 <printf>
    2e4f:	83 c4 10             	add    $0x10,%esp
    exit();
    2e52:	e8 78 10 00 00       	call   3ecf <exit>
  }

  fd = open(".", O_RDWR);
    2e57:	83 ec 08             	sub    $0x8,%esp
    2e5a:	6a 02                	push   $0x2
    2e5c:	68 4b a2 01 00       	push   $0x1a24b
    2e61:	e8 a9 10 00 00       	call   3f0f <open>
    2e66:	83 c4 10             	add    $0x10,%esp
    2e69:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd >= 0){
    2e6c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    2e70:	78 17                	js     2e89 <dirfile+0x1d0>
    printf(1, "open . for writing succeeded!\n");
    2e72:	83 ec 08             	sub    $0x8,%esp
    2e75:	68 a8 ac 01 00       	push   $0x1aca8
    2e7a:	6a 01                	push   $0x1
    2e7c:	e8 f5 11 00 00       	call   4076 <printf>
    2e81:	83 c4 10             	add    $0x10,%esp
    exit();
    2e84:	e8 46 10 00 00       	call   3ecf <exit>
  }
  fd = open(".", 0);
    2e89:	83 ec 08             	sub    $0x8,%esp
    2e8c:	6a 00                	push   $0x0
    2e8e:	68 4b a2 01 00       	push   $0x1a24b
    2e93:	e8 77 10 00 00       	call   3f0f <open>
    2e98:	83 c4 10             	add    $0x10,%esp
    2e9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(write(fd, "x", 1) > 0){
    2e9e:	83 ec 04             	sub    $0x4,%esp
    2ea1:	6a 01                	push   $0x1
    2ea3:	68 97 9e 01 00       	push   $0x19e97
    2ea8:	ff 75 f4             	pushl  -0xc(%ebp)
    2eab:	e8 3f 10 00 00       	call   3eef <write>
    2eb0:	83 c4 10             	add    $0x10,%esp
    2eb3:	85 c0                	test   %eax,%eax
    2eb5:	7e 17                	jle    2ece <dirfile+0x215>
    printf(1, "write . succeeded!\n");
    2eb7:	83 ec 08             	sub    $0x8,%esp
    2eba:	68 c7 ac 01 00       	push   $0x1acc7
    2ebf:	6a 01                	push   $0x1
    2ec1:	e8 b0 11 00 00       	call   4076 <printf>
    2ec6:	83 c4 10             	add    $0x10,%esp
    exit();
    2ec9:	e8 01 10 00 00       	call   3ecf <exit>
  }
  close(fd);
    2ece:	83 ec 0c             	sub    $0xc,%esp
    2ed1:	ff 75 f4             	pushl  -0xc(%ebp)
    2ed4:	e8 1e 10 00 00       	call   3ef7 <close>
    2ed9:	83 c4 10             	add    $0x10,%esp

  printf(1, "dir vs file OK\n");
    2edc:	83 ec 08             	sub    $0x8,%esp
    2edf:	68 db ac 01 00       	push   $0x1acdb
    2ee4:	6a 01                	push   $0x1
    2ee6:	e8 8b 11 00 00       	call   4076 <printf>
    2eeb:	83 c4 10             	add    $0x10,%esp
}
    2eee:	90                   	nop
    2eef:	c9                   	leave  
    2ef0:	c3                   	ret    

00002ef1 <iref>:

// test that iput() is called at the end of _namei()
void
iref(void)
{
    2ef1:	55                   	push   %ebp
    2ef2:	89 e5                	mov    %esp,%ebp
    2ef4:	83 ec 18             	sub    $0x18,%esp
  int i, fd;

  printf(1, "empty file name\n");
    2ef7:	83 ec 08             	sub    $0x8,%esp
    2efa:	68 eb ac 01 00       	push   $0x1aceb
    2eff:	6a 01                	push   $0x1
    2f01:	e8 70 11 00 00       	call   4076 <printf>
    2f06:	83 c4 10             	add    $0x10,%esp

  // the 50 is NINODE
  for(i = 0; i < 50 + 1; i++){
    2f09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2f10:	e9 e7 00 00 00       	jmp    2ffc <iref+0x10b>
    if(mkdir("irefd") != 0){
    2f15:	83 ec 0c             	sub    $0xc,%esp
    2f18:	68 fc ac 01 00       	push   $0x1acfc
    2f1d:	e8 15 10 00 00       	call   3f37 <mkdir>
    2f22:	83 c4 10             	add    $0x10,%esp
    2f25:	85 c0                	test   %eax,%eax
    2f27:	74 17                	je     2f40 <iref+0x4f>
      printf(1, "mkdir irefd failed\n");
    2f29:	83 ec 08             	sub    $0x8,%esp
    2f2c:	68 02 ad 01 00       	push   $0x1ad02
    2f31:	6a 01                	push   $0x1
    2f33:	e8 3e 11 00 00       	call   4076 <printf>
    2f38:	83 c4 10             	add    $0x10,%esp
      exit();
    2f3b:	e8 8f 0f 00 00       	call   3ecf <exit>
    }
    if(chdir("irefd") != 0){
    2f40:	83 ec 0c             	sub    $0xc,%esp
    2f43:	68 fc ac 01 00       	push   $0x1acfc
    2f48:	e8 f2 0f 00 00       	call   3f3f <chdir>
    2f4d:	83 c4 10             	add    $0x10,%esp
    2f50:	85 c0                	test   %eax,%eax
    2f52:	74 17                	je     2f6b <iref+0x7a>
      printf(1, "chdir irefd failed\n");
    2f54:	83 ec 08             	sub    $0x8,%esp
    2f57:	68 16 ad 01 00       	push   $0x1ad16
    2f5c:	6a 01                	push   $0x1
    2f5e:	e8 13 11 00 00       	call   4076 <printf>
    2f63:	83 c4 10             	add    $0x10,%esp
      exit();
    2f66:	e8 64 0f 00 00       	call   3ecf <exit>
    }

    mkdir("");
    2f6b:	83 ec 0c             	sub    $0xc,%esp
    2f6e:	68 2a ad 01 00       	push   $0x1ad2a
    2f73:	e8 bf 0f 00 00       	call   3f37 <mkdir>
    2f78:	83 c4 10             	add    $0x10,%esp
    link("README", "");
    2f7b:	83 ec 08             	sub    $0x8,%esp
    2f7e:	68 2a ad 01 00       	push   $0x1ad2a
    2f83:	68 69 ac 01 00       	push   $0x1ac69
    2f88:	e8 a2 0f 00 00       	call   3f2f <link>
    2f8d:	83 c4 10             	add    $0x10,%esp
    fd = open("", O_CREATE);
    2f90:	83 ec 08             	sub    $0x8,%esp
    2f93:	68 00 02 00 00       	push   $0x200
    2f98:	68 2a ad 01 00       	push   $0x1ad2a
    2f9d:	e8 6d 0f 00 00       	call   3f0f <open>
    2fa2:	83 c4 10             	add    $0x10,%esp
    2fa5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(fd >= 0)
    2fa8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    2fac:	78 0e                	js     2fbc <iref+0xcb>
      close(fd);
    2fae:	83 ec 0c             	sub    $0xc,%esp
    2fb1:	ff 75 f0             	pushl  -0x10(%ebp)
    2fb4:	e8 3e 0f 00 00       	call   3ef7 <close>
    2fb9:	83 c4 10             	add    $0x10,%esp
    fd = open("xx", O_CREATE);
    2fbc:	83 ec 08             	sub    $0x8,%esp
    2fbf:	68 00 02 00 00       	push   $0x200
    2fc4:	68 2b ad 01 00       	push   $0x1ad2b
    2fc9:	e8 41 0f 00 00       	call   3f0f <open>
    2fce:	83 c4 10             	add    $0x10,%esp
    2fd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(fd >= 0)
    2fd4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    2fd8:	78 0e                	js     2fe8 <iref+0xf7>
      close(fd);
    2fda:	83 ec 0c             	sub    $0xc,%esp
    2fdd:	ff 75 f0             	pushl  -0x10(%ebp)
    2fe0:	e8 12 0f 00 00       	call   3ef7 <close>
    2fe5:	83 c4 10             	add    $0x10,%esp
    unlink("xx");
    2fe8:	83 ec 0c             	sub    $0xc,%esp
    2feb:	68 2b ad 01 00       	push   $0x1ad2b
    2ff0:	e8 2a 0f 00 00       	call   3f1f <unlink>
    2ff5:	83 c4 10             	add    $0x10,%esp
  int i, fd;

  printf(1, "empty file name\n");

  // the 50 is NINODE
  for(i = 0; i < 50 + 1; i++){
    2ff8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2ffc:	83 7d f4 32          	cmpl   $0x32,-0xc(%ebp)
    3000:	0f 8e 0f ff ff ff    	jle    2f15 <iref+0x24>
    if(fd >= 0)
      close(fd);
    unlink("xx");
  }

  chdir("/");
    3006:	83 ec 0c             	sub    $0xc,%esp
    3009:	68 32 9a 01 00       	push   $0x19a32
    300e:	e8 2c 0f 00 00       	call   3f3f <chdir>
    3013:	83 c4 10             	add    $0x10,%esp
  printf(1, "empty file name OK\n");
    3016:	83 ec 08             	sub    $0x8,%esp
    3019:	68 2e ad 01 00       	push   $0x1ad2e
    301e:	6a 01                	push   $0x1
    3020:	e8 51 10 00 00       	call   4076 <printf>
    3025:	83 c4 10             	add    $0x10,%esp
}
    3028:	90                   	nop
    3029:	c9                   	leave  
    302a:	c3                   	ret    

0000302b <forktest>:
// test that fork fails gracefully
// the forktest binary also does this, but it runs out of proc entries first.
// inside the bigger usertests binary, we run out of memory first.
void
forktest(void)
{
    302b:	55                   	push   %ebp
    302c:	89 e5                	mov    %esp,%ebp
    302e:	83 ec 18             	sub    $0x18,%esp
  int n, pid;

  printf(1, "fork test\n");
    3031:	83 ec 08             	sub    $0x8,%esp
    3034:	68 42 ad 01 00       	push   $0x1ad42
    3039:	6a 01                	push   $0x1
    303b:	e8 36 10 00 00       	call   4076 <printf>
    3040:	83 c4 10             	add    $0x10,%esp

  for(n=0; n<1000; n++){
    3043:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    304a:	eb 1d                	jmp    3069 <forktest+0x3e>
    pid = fork();
    304c:	e8 76 0e 00 00       	call   3ec7 <fork>
    3051:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(pid < 0)
    3054:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    3058:	78 1a                	js     3074 <forktest+0x49>
      break;
    if(pid == 0)
    305a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    305e:	75 05                	jne    3065 <forktest+0x3a>
      exit();
    3060:	e8 6a 0e 00 00       	call   3ecf <exit>
{
  int n, pid;

  printf(1, "fork test\n");

  for(n=0; n<1000; n++){
    3065:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3069:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
    3070:	7e da                	jle    304c <forktest+0x21>
    3072:	eb 01                	jmp    3075 <forktest+0x4a>
    pid = fork();
    if(pid < 0)
      break;
    3074:	90                   	nop
    if(pid == 0)
      exit();
  }
  
  if(n == 1000){
    3075:	81 7d f4 e8 03 00 00 	cmpl   $0x3e8,-0xc(%ebp)
    307c:	75 3b                	jne    30b9 <forktest+0x8e>
    printf(1, "fork claimed to work 1000 times!\n");
    307e:	83 ec 08             	sub    $0x8,%esp
    3081:	68 50 ad 01 00       	push   $0x1ad50
    3086:	6a 01                	push   $0x1
    3088:	e8 e9 0f 00 00       	call   4076 <printf>
    308d:	83 c4 10             	add    $0x10,%esp
    exit();
    3090:	e8 3a 0e 00 00       	call   3ecf <exit>
  }
  
  for(; n > 0; n--){
    if(wait() < 0){
    3095:	e8 3d 0e 00 00       	call   3ed7 <wait>
    309a:	85 c0                	test   %eax,%eax
    309c:	79 17                	jns    30b5 <forktest+0x8a>
      printf(1, "wait stopped early\n");
    309e:	83 ec 08             	sub    $0x8,%esp
    30a1:	68 72 ad 01 00       	push   $0x1ad72
    30a6:	6a 01                	push   $0x1
    30a8:	e8 c9 0f 00 00       	call   4076 <printf>
    30ad:	83 c4 10             	add    $0x10,%esp
      exit();
    30b0:	e8 1a 0e 00 00       	call   3ecf <exit>
  if(n == 1000){
    printf(1, "fork claimed to work 1000 times!\n");
    exit();
  }
  
  for(; n > 0; n--){
    30b5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    30b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    30bd:	7f d6                	jg     3095 <forktest+0x6a>
      printf(1, "wait stopped early\n");
      exit();
    }
  }
  
  if(wait() != -1){
    30bf:	e8 13 0e 00 00       	call   3ed7 <wait>
    30c4:	83 f8 ff             	cmp    $0xffffffff,%eax
    30c7:	74 17                	je     30e0 <forktest+0xb5>
    printf(1, "wait got too many\n");
    30c9:	83 ec 08             	sub    $0x8,%esp
    30cc:	68 86 ad 01 00       	push   $0x1ad86
    30d1:	6a 01                	push   $0x1
    30d3:	e8 9e 0f 00 00       	call   4076 <printf>
    30d8:	83 c4 10             	add    $0x10,%esp
    exit();
    30db:	e8 ef 0d 00 00       	call   3ecf <exit>
  }
  
  printf(1, "fork test OK\n");
    30e0:	83 ec 08             	sub    $0x8,%esp
    30e3:	68 99 ad 01 00       	push   $0x1ad99
    30e8:	6a 01                	push   $0x1
    30ea:	e8 87 0f 00 00       	call   4076 <printf>
    30ef:	83 c4 10             	add    $0x10,%esp
}
    30f2:	90                   	nop
    30f3:	c9                   	leave  
    30f4:	c3                   	ret    

000030f5 <sbrktest>:

void
sbrktest(void)
{
    30f5:	55                   	push   %ebp
    30f6:	89 e5                	mov    %esp,%ebp
    30f8:	53                   	push   %ebx
    30f9:	83 ec 64             	sub    $0x64,%esp
  int fds[2], pid, pids[10], ppid;
  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
  uint amt;

  printf(stdout, "sbrk test\n");
    30fc:	a1 14 39 02 00       	mov    0x23914,%eax
    3101:	83 ec 08             	sub    $0x8,%esp
    3104:	68 a7 ad 01 00       	push   $0x1ada7
    3109:	50                   	push   %eax
    310a:	e8 67 0f 00 00       	call   4076 <printf>
    310f:	83 c4 10             	add    $0x10,%esp
  oldbrk = sbrk(0);
    3112:	83 ec 0c             	sub    $0xc,%esp
    3115:	6a 00                	push   $0x0
    3117:	e8 3b 0e 00 00       	call   3f57 <sbrk>
    311c:	83 c4 10             	add    $0x10,%esp
    311f:	89 45 ec             	mov    %eax,-0x14(%ebp)

  // can one sbrk() less than a page?
  a = sbrk(0);
    3122:	83 ec 0c             	sub    $0xc,%esp
    3125:	6a 00                	push   $0x0
    3127:	e8 2b 0e 00 00       	call   3f57 <sbrk>
    312c:	83 c4 10             	add    $0x10,%esp
    312f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  for(i = 0; i < 5000; i++){ 
    3132:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    3139:	eb 4f                	jmp    318a <sbrktest+0x95>
    b = sbrk(1);
    313b:	83 ec 0c             	sub    $0xc,%esp
    313e:	6a 01                	push   $0x1
    3140:	e8 12 0e 00 00       	call   3f57 <sbrk>
    3145:	83 c4 10             	add    $0x10,%esp
    3148:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(b != a){
    314b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    314e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3151:	74 24                	je     3177 <sbrktest+0x82>
      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
    3153:	a1 14 39 02 00       	mov    0x23914,%eax
    3158:	83 ec 0c             	sub    $0xc,%esp
    315b:	ff 75 e8             	pushl  -0x18(%ebp)
    315e:	ff 75 f4             	pushl  -0xc(%ebp)
    3161:	ff 75 f0             	pushl  -0x10(%ebp)
    3164:	68 b2 ad 01 00       	push   $0x1adb2
    3169:	50                   	push   %eax
    316a:	e8 07 0f 00 00       	call   4076 <printf>
    316f:	83 c4 20             	add    $0x20,%esp
      exit();
    3172:	e8 58 0d 00 00       	call   3ecf <exit>
    }
    *b = 1;
    3177:	8b 45 e8             	mov    -0x18(%ebp),%eax
    317a:	c6 00 01             	movb   $0x1,(%eax)
    a = b + 1;
    317d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3180:	83 c0 01             	add    $0x1,%eax
    3183:	89 45 f4             	mov    %eax,-0xc(%ebp)
  oldbrk = sbrk(0);

  // can one sbrk() less than a page?
  a = sbrk(0);
  int i;
  for(i = 0; i < 5000; i++){ 
    3186:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    318a:	81 7d f0 87 13 00 00 	cmpl   $0x1387,-0x10(%ebp)
    3191:	7e a8                	jle    313b <sbrktest+0x46>
      exit();
    }
    *b = 1;
    a = b + 1;
  }
  pid = fork();
    3193:	e8 2f 0d 00 00       	call   3ec7 <fork>
    3198:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(pid < 0){
    319b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    319f:	79 1b                	jns    31bc <sbrktest+0xc7>
    printf(stdout, "sbrk test fork failed\n");
    31a1:	a1 14 39 02 00       	mov    0x23914,%eax
    31a6:	83 ec 08             	sub    $0x8,%esp
    31a9:	68 cd ad 01 00       	push   $0x1adcd
    31ae:	50                   	push   %eax
    31af:	e8 c2 0e 00 00       	call   4076 <printf>
    31b4:	83 c4 10             	add    $0x10,%esp
    exit();
    31b7:	e8 13 0d 00 00       	call   3ecf <exit>
  }
  c = sbrk(1);
    31bc:	83 ec 0c             	sub    $0xc,%esp
    31bf:	6a 01                	push   $0x1
    31c1:	e8 91 0d 00 00       	call   3f57 <sbrk>
    31c6:	83 c4 10             	add    $0x10,%esp
    31c9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  c = sbrk(1);
    31cc:	83 ec 0c             	sub    $0xc,%esp
    31cf:	6a 01                	push   $0x1
    31d1:	e8 81 0d 00 00       	call   3f57 <sbrk>
    31d6:	83 c4 10             	add    $0x10,%esp
    31d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if(c != a + 1){
    31dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    31df:	83 c0 01             	add    $0x1,%eax
    31e2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    31e5:	74 1b                	je     3202 <sbrktest+0x10d>
    printf(stdout, "sbrk test failed post-fork\n");
    31e7:	a1 14 39 02 00       	mov    0x23914,%eax
    31ec:	83 ec 08             	sub    $0x8,%esp
    31ef:	68 e4 ad 01 00       	push   $0x1ade4
    31f4:	50                   	push   %eax
    31f5:	e8 7c 0e 00 00       	call   4076 <printf>
    31fa:	83 c4 10             	add    $0x10,%esp
    exit();
    31fd:	e8 cd 0c 00 00       	call   3ecf <exit>
  }
  if(pid == 0)
    3202:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    3206:	75 05                	jne    320d <sbrktest+0x118>
    exit();
    3208:	e8 c2 0c 00 00       	call   3ecf <exit>
  wait();
    320d:	e8 c5 0c 00 00       	call   3ed7 <wait>

  // can one grow address space to something big?
#define BIG (100*1024*1024)
  a = sbrk(0);
    3212:	83 ec 0c             	sub    $0xc,%esp
    3215:	6a 00                	push   $0x0
    3217:	e8 3b 0d 00 00       	call   3f57 <sbrk>
    321c:	83 c4 10             	add    $0x10,%esp
    321f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  amt = (BIG) - (uint)a;
    3222:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3225:	ba 00 00 40 06       	mov    $0x6400000,%edx
    322a:	29 c2                	sub    %eax,%edx
    322c:	89 d0                	mov    %edx,%eax
    322e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  p = sbrk(amt);
    3231:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3234:	83 ec 0c             	sub    $0xc,%esp
    3237:	50                   	push   %eax
    3238:	e8 1a 0d 00 00       	call   3f57 <sbrk>
    323d:	83 c4 10             	add    $0x10,%esp
    3240:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (p != a) { 
    3243:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3246:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3249:	74 1b                	je     3266 <sbrktest+0x171>
    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
    324b:	a1 14 39 02 00       	mov    0x23914,%eax
    3250:	83 ec 08             	sub    $0x8,%esp
    3253:	68 00 ae 01 00       	push   $0x1ae00
    3258:	50                   	push   %eax
    3259:	e8 18 0e 00 00       	call   4076 <printf>
    325e:	83 c4 10             	add    $0x10,%esp
    exit();
    3261:	e8 69 0c 00 00       	call   3ecf <exit>
  }
  lastaddr = (char*) (BIG-1);
    3266:	c7 45 d4 ff ff 3f 06 	movl   $0x63fffff,-0x2c(%ebp)
  *lastaddr = 99;
    326d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3270:	c6 00 63             	movb   $0x63,(%eax)

  // can one de-allocate?
  a = sbrk(0);
    3273:	83 ec 0c             	sub    $0xc,%esp
    3276:	6a 00                	push   $0x0
    3278:	e8 da 0c 00 00       	call   3f57 <sbrk>
    327d:	83 c4 10             	add    $0x10,%esp
    3280:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c = sbrk(-4096);
    3283:	83 ec 0c             	sub    $0xc,%esp
    3286:	68 00 f0 ff ff       	push   $0xfffff000
    328b:	e8 c7 0c 00 00       	call   3f57 <sbrk>
    3290:	83 c4 10             	add    $0x10,%esp
    3293:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if(c == (char*)0xffffffff){
    3296:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
    329a:	75 1b                	jne    32b7 <sbrktest+0x1c2>
    printf(stdout, "sbrk could not deallocate\n");
    329c:	a1 14 39 02 00       	mov    0x23914,%eax
    32a1:	83 ec 08             	sub    $0x8,%esp
    32a4:	68 3e ae 01 00       	push   $0x1ae3e
    32a9:	50                   	push   %eax
    32aa:	e8 c7 0d 00 00       	call   4076 <printf>
    32af:	83 c4 10             	add    $0x10,%esp
    exit();
    32b2:	e8 18 0c 00 00       	call   3ecf <exit>
  }
  c = sbrk(0);
    32b7:	83 ec 0c             	sub    $0xc,%esp
    32ba:	6a 00                	push   $0x0
    32bc:	e8 96 0c 00 00       	call   3f57 <sbrk>
    32c1:	83 c4 10             	add    $0x10,%esp
    32c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if(c != a - 4096){
    32c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32ca:	2d 00 10 00 00       	sub    $0x1000,%eax
    32cf:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    32d2:	74 1e                	je     32f2 <sbrktest+0x1fd>
    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
    32d4:	a1 14 39 02 00       	mov    0x23914,%eax
    32d9:	ff 75 e0             	pushl  -0x20(%ebp)
    32dc:	ff 75 f4             	pushl  -0xc(%ebp)
    32df:	68 5c ae 01 00       	push   $0x1ae5c
    32e4:	50                   	push   %eax
    32e5:	e8 8c 0d 00 00       	call   4076 <printf>
    32ea:	83 c4 10             	add    $0x10,%esp
    exit();
    32ed:	e8 dd 0b 00 00       	call   3ecf <exit>
  }

  // can one re-allocate that page?
  a = sbrk(0);
    32f2:	83 ec 0c             	sub    $0xc,%esp
    32f5:	6a 00                	push   $0x0
    32f7:	e8 5b 0c 00 00       	call   3f57 <sbrk>
    32fc:	83 c4 10             	add    $0x10,%esp
    32ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c = sbrk(4096);
    3302:	83 ec 0c             	sub    $0xc,%esp
    3305:	68 00 10 00 00       	push   $0x1000
    330a:	e8 48 0c 00 00       	call   3f57 <sbrk>
    330f:	83 c4 10             	add    $0x10,%esp
    3312:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if(c != a || sbrk(0) != a + 4096){
    3315:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3318:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    331b:	75 1b                	jne    3338 <sbrktest+0x243>
    331d:	83 ec 0c             	sub    $0xc,%esp
    3320:	6a 00                	push   $0x0
    3322:	e8 30 0c 00 00       	call   3f57 <sbrk>
    3327:	83 c4 10             	add    $0x10,%esp
    332a:	89 c2                	mov    %eax,%edx
    332c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    332f:	05 00 10 00 00       	add    $0x1000,%eax
    3334:	39 c2                	cmp    %eax,%edx
    3336:	74 1e                	je     3356 <sbrktest+0x261>
    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
    3338:	a1 14 39 02 00       	mov    0x23914,%eax
    333d:	ff 75 e0             	pushl  -0x20(%ebp)
    3340:	ff 75 f4             	pushl  -0xc(%ebp)
    3343:	68 94 ae 01 00       	push   $0x1ae94
    3348:	50                   	push   %eax
    3349:	e8 28 0d 00 00       	call   4076 <printf>
    334e:	83 c4 10             	add    $0x10,%esp
    exit();
    3351:	e8 79 0b 00 00       	call   3ecf <exit>
  }
  if(*lastaddr == 99){
    3356:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3359:	0f b6 00             	movzbl (%eax),%eax
    335c:	3c 63                	cmp    $0x63,%al
    335e:	75 1b                	jne    337b <sbrktest+0x286>
    // should be zero
    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
    3360:	a1 14 39 02 00       	mov    0x23914,%eax
    3365:	83 ec 08             	sub    $0x8,%esp
    3368:	68 bc ae 01 00       	push   $0x1aebc
    336d:	50                   	push   %eax
    336e:	e8 03 0d 00 00       	call   4076 <printf>
    3373:	83 c4 10             	add    $0x10,%esp
    exit();
    3376:	e8 54 0b 00 00       	call   3ecf <exit>
  }

  a = sbrk(0);
    337b:	83 ec 0c             	sub    $0xc,%esp
    337e:	6a 00                	push   $0x0
    3380:	e8 d2 0b 00 00       	call   3f57 <sbrk>
    3385:	83 c4 10             	add    $0x10,%esp
    3388:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c = sbrk(-(sbrk(0) - oldbrk));
    338b:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    338e:	83 ec 0c             	sub    $0xc,%esp
    3391:	6a 00                	push   $0x0
    3393:	e8 bf 0b 00 00       	call   3f57 <sbrk>
    3398:	83 c4 10             	add    $0x10,%esp
    339b:	29 c3                	sub    %eax,%ebx
    339d:	89 d8                	mov    %ebx,%eax
    339f:	83 ec 0c             	sub    $0xc,%esp
    33a2:	50                   	push   %eax
    33a3:	e8 af 0b 00 00       	call   3f57 <sbrk>
    33a8:	83 c4 10             	add    $0x10,%esp
    33ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if(c != a){
    33ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
    33b1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    33b4:	74 1e                	je     33d4 <sbrktest+0x2df>
    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
    33b6:	a1 14 39 02 00       	mov    0x23914,%eax
    33bb:	ff 75 e0             	pushl  -0x20(%ebp)
    33be:	ff 75 f4             	pushl  -0xc(%ebp)
    33c1:	68 ec ae 01 00       	push   $0x1aeec
    33c6:	50                   	push   %eax
    33c7:	e8 aa 0c 00 00       	call   4076 <printf>
    33cc:	83 c4 10             	add    $0x10,%esp
    exit();
    33cf:	e8 fb 0a 00 00       	call   3ecf <exit>
  }
  
  // can we read the kernel's memory?
  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
    33d4:	c7 45 f4 00 00 00 80 	movl   $0x80000000,-0xc(%ebp)
    33db:	eb 76                	jmp    3453 <sbrktest+0x35e>
    ppid = getpid();
    33dd:	e8 6d 0b 00 00       	call   3f4f <getpid>
    33e2:	89 45 d0             	mov    %eax,-0x30(%ebp)
    pid = fork();
    33e5:	e8 dd 0a 00 00       	call   3ec7 <fork>
    33ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(pid < 0){
    33ed:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    33f1:	79 1b                	jns    340e <sbrktest+0x319>
      printf(stdout, "fork failed\n");
    33f3:	a1 14 39 02 00       	mov    0x23914,%eax
    33f8:	83 ec 08             	sub    $0x8,%esp
    33fb:	68 61 9a 01 00       	push   $0x19a61
    3400:	50                   	push   %eax
    3401:	e8 70 0c 00 00       	call   4076 <printf>
    3406:	83 c4 10             	add    $0x10,%esp
      exit();
    3409:	e8 c1 0a 00 00       	call   3ecf <exit>
    }
    if(pid == 0){
    340e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    3412:	75 33                	jne    3447 <sbrktest+0x352>
      printf(stdout, "oops could read %x = %x\n", a, *a);
    3414:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3417:	0f b6 00             	movzbl (%eax),%eax
    341a:	0f be d0             	movsbl %al,%edx
    341d:	a1 14 39 02 00       	mov    0x23914,%eax
    3422:	52                   	push   %edx
    3423:	ff 75 f4             	pushl  -0xc(%ebp)
    3426:	68 0d af 01 00       	push   $0x1af0d
    342b:	50                   	push   %eax
    342c:	e8 45 0c 00 00       	call   4076 <printf>
    3431:	83 c4 10             	add    $0x10,%esp
      kill(ppid);
    3434:	83 ec 0c             	sub    $0xc,%esp
    3437:	ff 75 d0             	pushl  -0x30(%ebp)
    343a:	e8 c0 0a 00 00       	call   3eff <kill>
    343f:	83 c4 10             	add    $0x10,%esp
      exit();
    3442:	e8 88 0a 00 00       	call   3ecf <exit>
    }
    wait();
    3447:	e8 8b 0a 00 00       	call   3ed7 <wait>
    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
    exit();
  }
  
  // can we read the kernel's memory?
  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
    344c:	81 45 f4 50 c3 00 00 	addl   $0xc350,-0xc(%ebp)
    3453:	81 7d f4 7f 84 1e 80 	cmpl   $0x801e847f,-0xc(%ebp)
    345a:	76 81                	jbe    33dd <sbrktest+0x2e8>
    wait();
  }

  // if we run the system out of memory, does it clean up the last
  // failed allocation?
  if(pipe(fds) != 0){
    345c:	83 ec 0c             	sub    $0xc,%esp
    345f:	8d 45 c8             	lea    -0x38(%ebp),%eax
    3462:	50                   	push   %eax
    3463:	e8 77 0a 00 00       	call   3edf <pipe>
    3468:	83 c4 10             	add    $0x10,%esp
    346b:	85 c0                	test   %eax,%eax
    346d:	74 17                	je     3486 <sbrktest+0x391>
    printf(1, "pipe() failed\n");
    346f:	83 ec 08             	sub    $0x8,%esp
    3472:	68 32 9e 01 00       	push   $0x19e32
    3477:	6a 01                	push   $0x1
    3479:	e8 f8 0b 00 00       	call   4076 <printf>
    347e:	83 c4 10             	add    $0x10,%esp
    exit();
    3481:	e8 49 0a 00 00       	call   3ecf <exit>
  }
  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
    3486:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    348d:	e9 88 00 00 00       	jmp    351a <sbrktest+0x425>
    if((pids[i] = fork()) == 0){
    3492:	e8 30 0a 00 00       	call   3ec7 <fork>
    3497:	89 c2                	mov    %eax,%edx
    3499:	8b 45 f0             	mov    -0x10(%ebp),%eax
    349c:	89 54 85 a0          	mov    %edx,-0x60(%ebp,%eax,4)
    34a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    34a3:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
    34a7:	85 c0                	test   %eax,%eax
    34a9:	75 4a                	jne    34f5 <sbrktest+0x400>
      // allocate a lot of memory
      sbrk(BIG - (uint)sbrk(0));
    34ab:	83 ec 0c             	sub    $0xc,%esp
    34ae:	6a 00                	push   $0x0
    34b0:	e8 a2 0a 00 00       	call   3f57 <sbrk>
    34b5:	83 c4 10             	add    $0x10,%esp
    34b8:	ba 00 00 40 06       	mov    $0x6400000,%edx
    34bd:	29 c2                	sub    %eax,%edx
    34bf:	89 d0                	mov    %edx,%eax
    34c1:	83 ec 0c             	sub    $0xc,%esp
    34c4:	50                   	push   %eax
    34c5:	e8 8d 0a 00 00       	call   3f57 <sbrk>
    34ca:	83 c4 10             	add    $0x10,%esp
      write(fds[1], "x", 1);
    34cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
    34d0:	83 ec 04             	sub    $0x4,%esp
    34d3:	6a 01                	push   $0x1
    34d5:	68 97 9e 01 00       	push   $0x19e97
    34da:	50                   	push   %eax
    34db:	e8 0f 0a 00 00       	call   3eef <write>
    34e0:	83 c4 10             	add    $0x10,%esp
      // sit around until killed
      for(;;) sleep(1000);
    34e3:	83 ec 0c             	sub    $0xc,%esp
    34e6:	68 e8 03 00 00       	push   $0x3e8
    34eb:	e8 6f 0a 00 00       	call   3f5f <sleep>
    34f0:	83 c4 10             	add    $0x10,%esp
    34f3:	eb ee                	jmp    34e3 <sbrktest+0x3ee>
    }
    if(pids[i] != -1)
    34f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    34f8:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
    34fc:	83 f8 ff             	cmp    $0xffffffff,%eax
    34ff:	74 15                	je     3516 <sbrktest+0x421>
      read(fds[0], &scratch, 1);
    3501:	8b 45 c8             	mov    -0x38(%ebp),%eax
    3504:	83 ec 04             	sub    $0x4,%esp
    3507:	6a 01                	push   $0x1
    3509:	8d 55 9f             	lea    -0x61(%ebp),%edx
    350c:	52                   	push   %edx
    350d:	50                   	push   %eax
    350e:	e8 d4 09 00 00       	call   3ee7 <read>
    3513:	83 c4 10             	add    $0x10,%esp
  // failed allocation?
  if(pipe(fds) != 0){
    printf(1, "pipe() failed\n");
    exit();
  }
  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
    3516:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    351a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    351d:	83 f8 09             	cmp    $0x9,%eax
    3520:	0f 86 6c ff ff ff    	jbe    3492 <sbrktest+0x39d>
    if(pids[i] != -1)
      read(fds[0], &scratch, 1);
  }
  // if those failed allocations freed up the pages they did allocate,
  // we'll be able to allocate here
  c = sbrk(4096);
    3526:	83 ec 0c             	sub    $0xc,%esp
    3529:	68 00 10 00 00       	push   $0x1000
    352e:	e8 24 0a 00 00       	call   3f57 <sbrk>
    3533:	83 c4 10             	add    $0x10,%esp
    3536:	89 45 e0             	mov    %eax,-0x20(%ebp)
  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
    3539:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    3540:	eb 2b                	jmp    356d <sbrktest+0x478>
    if(pids[i] == -1)
    3542:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3545:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
    3549:	83 f8 ff             	cmp    $0xffffffff,%eax
    354c:	74 1a                	je     3568 <sbrktest+0x473>
      continue;
    kill(pids[i]);
    354e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3551:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
    3555:	83 ec 0c             	sub    $0xc,%esp
    3558:	50                   	push   %eax
    3559:	e8 a1 09 00 00       	call   3eff <kill>
    355e:	83 c4 10             	add    $0x10,%esp
    wait();
    3561:	e8 71 09 00 00       	call   3ed7 <wait>
    3566:	eb 01                	jmp    3569 <sbrktest+0x474>
  // if those failed allocations freed up the pages they did allocate,
  // we'll be able to allocate here
  c = sbrk(4096);
  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
    if(pids[i] == -1)
      continue;
    3568:	90                   	nop
      read(fds[0], &scratch, 1);
  }
  // if those failed allocations freed up the pages they did allocate,
  // we'll be able to allocate here
  c = sbrk(4096);
  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
    3569:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    356d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3570:	83 f8 09             	cmp    $0x9,%eax
    3573:	76 cd                	jbe    3542 <sbrktest+0x44d>
    if(pids[i] == -1)
      continue;
    kill(pids[i]);
    wait();
  }
  if(c == (char*)0xffffffff){
    3575:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
    3579:	75 1b                	jne    3596 <sbrktest+0x4a1>
    printf(stdout, "failed sbrk leaked memory\n");
    357b:	a1 14 39 02 00       	mov    0x23914,%eax
    3580:	83 ec 08             	sub    $0x8,%esp
    3583:	68 26 af 01 00       	push   $0x1af26
    3588:	50                   	push   %eax
    3589:	e8 e8 0a 00 00       	call   4076 <printf>
    358e:	83 c4 10             	add    $0x10,%esp
    exit();
    3591:	e8 39 09 00 00       	call   3ecf <exit>
  }

  if(sbrk(0) > oldbrk)
    3596:	83 ec 0c             	sub    $0xc,%esp
    3599:	6a 00                	push   $0x0
    359b:	e8 b7 09 00 00       	call   3f57 <sbrk>
    35a0:	83 c4 10             	add    $0x10,%esp
    35a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    35a6:	76 20                	jbe    35c8 <sbrktest+0x4d3>
    sbrk(-(sbrk(0) - oldbrk));
    35a8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    35ab:	83 ec 0c             	sub    $0xc,%esp
    35ae:	6a 00                	push   $0x0
    35b0:	e8 a2 09 00 00       	call   3f57 <sbrk>
    35b5:	83 c4 10             	add    $0x10,%esp
    35b8:	29 c3                	sub    %eax,%ebx
    35ba:	89 d8                	mov    %ebx,%eax
    35bc:	83 ec 0c             	sub    $0xc,%esp
    35bf:	50                   	push   %eax
    35c0:	e8 92 09 00 00       	call   3f57 <sbrk>
    35c5:	83 c4 10             	add    $0x10,%esp

  printf(stdout, "sbrk test OK\n");
    35c8:	a1 14 39 02 00       	mov    0x23914,%eax
    35cd:	83 ec 08             	sub    $0x8,%esp
    35d0:	68 41 af 01 00       	push   $0x1af41
    35d5:	50                   	push   %eax
    35d6:	e8 9b 0a 00 00       	call   4076 <printf>
    35db:	83 c4 10             	add    $0x10,%esp
}
    35de:	90                   	nop
    35df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    35e2:	c9                   	leave  
    35e3:	c3                   	ret    

000035e4 <validateint>:

void
validateint(int *p)
{
    35e4:	55                   	push   %ebp
    35e5:	89 e5                	mov    %esp,%ebp
    35e7:	53                   	push   %ebx
    35e8:	83 ec 10             	sub    $0x10,%esp
  int res;
  asm("mov %%esp, %%ebx\n\t"
    35eb:	b8 0d 00 00 00       	mov    $0xd,%eax
    35f0:	8b 55 08             	mov    0x8(%ebp),%edx
    35f3:	89 d1                	mov    %edx,%ecx
    35f5:	89 e3                	mov    %esp,%ebx
    35f7:	89 cc                	mov    %ecx,%esp
    35f9:	cd 40                	int    $0x40
    35fb:	89 dc                	mov    %ebx,%esp
    35fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
      "int %2\n\t"
      "mov %%ebx, %%esp" :
      "=a" (res) :
      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
      "ebx");
}
    3600:	90                   	nop
    3601:	83 c4 10             	add    $0x10,%esp
    3604:	5b                   	pop    %ebx
    3605:	5d                   	pop    %ebp
    3606:	c3                   	ret    

00003607 <validatetest>:

void
validatetest(void)
{
    3607:	55                   	push   %ebp
    3608:	89 e5                	mov    %esp,%ebp
    360a:	83 ec 18             	sub    $0x18,%esp
  int hi, pid;
  uint p;

  printf(stdout, "validate test\n");
    360d:	a1 14 39 02 00       	mov    0x23914,%eax
    3612:	83 ec 08             	sub    $0x8,%esp
    3615:	68 4f af 01 00       	push   $0x1af4f
    361a:	50                   	push   %eax
    361b:	e8 56 0a 00 00       	call   4076 <printf>
    3620:	83 c4 10             	add    $0x10,%esp
  hi = 1100*1024;
    3623:	c7 45 f0 00 30 11 00 	movl   $0x113000,-0x10(%ebp)

  for(p = 0; p <= (uint)hi; p += 4096){
    362a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3631:	e9 8a 00 00 00       	jmp    36c0 <validatetest+0xb9>
    if((pid = fork()) == 0){
    3636:	e8 8c 08 00 00       	call   3ec7 <fork>
    363b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    363e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    3642:	75 14                	jne    3658 <validatetest+0x51>
      // try to crash the kernel by passing in a badly placed integer
      validateint((int*)p);
    3644:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3647:	83 ec 0c             	sub    $0xc,%esp
    364a:	50                   	push   %eax
    364b:	e8 94 ff ff ff       	call   35e4 <validateint>
    3650:	83 c4 10             	add    $0x10,%esp
      exit();
    3653:	e8 77 08 00 00       	call   3ecf <exit>
    }
    sleep(0);
    3658:	83 ec 0c             	sub    $0xc,%esp
    365b:	6a 00                	push   $0x0
    365d:	e8 fd 08 00 00       	call   3f5f <sleep>
    3662:	83 c4 10             	add    $0x10,%esp
    sleep(0);
    3665:	83 ec 0c             	sub    $0xc,%esp
    3668:	6a 00                	push   $0x0
    366a:	e8 f0 08 00 00       	call   3f5f <sleep>
    366f:	83 c4 10             	add    $0x10,%esp
    kill(pid);
    3672:	83 ec 0c             	sub    $0xc,%esp
    3675:	ff 75 ec             	pushl  -0x14(%ebp)
    3678:	e8 82 08 00 00       	call   3eff <kill>
    367d:	83 c4 10             	add    $0x10,%esp
    wait();
    3680:	e8 52 08 00 00       	call   3ed7 <wait>

    // try to crash the kernel by passing in a bad string pointer
    if(link("nosuchfile", (char*)p) != -1){
    3685:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3688:	83 ec 08             	sub    $0x8,%esp
    368b:	50                   	push   %eax
    368c:	68 5e af 01 00       	push   $0x1af5e
    3691:	e8 99 08 00 00       	call   3f2f <link>
    3696:	83 c4 10             	add    $0x10,%esp
    3699:	83 f8 ff             	cmp    $0xffffffff,%eax
    369c:	74 1b                	je     36b9 <validatetest+0xb2>
      printf(stdout, "link should not succeed\n");
    369e:	a1 14 39 02 00       	mov    0x23914,%eax
    36a3:	83 ec 08             	sub    $0x8,%esp
    36a6:	68 69 af 01 00       	push   $0x1af69
    36ab:	50                   	push   %eax
    36ac:	e8 c5 09 00 00       	call   4076 <printf>
    36b1:	83 c4 10             	add    $0x10,%esp
      exit();
    36b4:	e8 16 08 00 00       	call   3ecf <exit>
  uint p;

  printf(stdout, "validate test\n");
  hi = 1100*1024;

  for(p = 0; p <= (uint)hi; p += 4096){
    36b9:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    36c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    36c3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    36c6:	0f 86 6a ff ff ff    	jbe    3636 <validatetest+0x2f>
      printf(stdout, "link should not succeed\n");
      exit();
    }
  }

  printf(stdout, "validate ok\n");
    36cc:	a1 14 39 02 00       	mov    0x23914,%eax
    36d1:	83 ec 08             	sub    $0x8,%esp
    36d4:	68 82 af 01 00       	push   $0x1af82
    36d9:	50                   	push   %eax
    36da:	e8 97 09 00 00       	call   4076 <printf>
    36df:	83 c4 10             	add    $0x10,%esp
}
    36e2:	90                   	nop
    36e3:	c9                   	leave  
    36e4:	c3                   	ret    

000036e5 <bsstest>:

// does unintialized data start out zero?
char uninit[10000];
void
bsstest(void)
{
    36e5:	55                   	push   %ebp
    36e6:	89 e5                	mov    %esp,%ebp
    36e8:	83 ec 18             	sub    $0x18,%esp
  int i;

  printf(stdout, "bss test\n");
    36eb:	a1 14 39 02 00       	mov    0x23914,%eax
    36f0:	83 ec 08             	sub    $0x8,%esp
    36f3:	68 8f af 01 00       	push   $0x1af8f
    36f8:	50                   	push   %eax
    36f9:	e8 78 09 00 00       	call   4076 <printf>
    36fe:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < sizeof(uninit); i++){
    3701:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3708:	eb 2e                	jmp    3738 <bsstest+0x53>
    if(uninit[i] != '\0'){
    370a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    370d:	05 00 3e 02 00       	add    $0x23e00,%eax
    3712:	0f b6 00             	movzbl (%eax),%eax
    3715:	84 c0                	test   %al,%al
    3717:	74 1b                	je     3734 <bsstest+0x4f>
      printf(stdout, "bss test failed\n");
    3719:	a1 14 39 02 00       	mov    0x23914,%eax
    371e:	83 ec 08             	sub    $0x8,%esp
    3721:	68 99 af 01 00       	push   $0x1af99
    3726:	50                   	push   %eax
    3727:	e8 4a 09 00 00       	call   4076 <printf>
    372c:	83 c4 10             	add    $0x10,%esp
      exit();
    372f:	e8 9b 07 00 00       	call   3ecf <exit>
bsstest(void)
{
  int i;

  printf(stdout, "bss test\n");
  for(i = 0; i < sizeof(uninit); i++){
    3734:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3738:	8b 45 f4             	mov    -0xc(%ebp),%eax
    373b:	3d 0f 27 00 00       	cmp    $0x270f,%eax
    3740:	76 c8                	jbe    370a <bsstest+0x25>
    if(uninit[i] != '\0'){
      printf(stdout, "bss test failed\n");
      exit();
    }
  }
  printf(stdout, "bss test ok\n");
    3742:	a1 14 39 02 00       	mov    0x23914,%eax
    3747:	83 ec 08             	sub    $0x8,%esp
    374a:	68 aa af 01 00       	push   $0x1afaa
    374f:	50                   	push   %eax
    3750:	e8 21 09 00 00       	call   4076 <printf>
    3755:	83 c4 10             	add    $0x10,%esp
}
    3758:	90                   	nop
    3759:	c9                   	leave  
    375a:	c3                   	ret    

0000375b <bigargtest>:
// does exec return an error if the arguments
// are larger than a page? or does it write
// below the stack and wreck the instructions/data?
void
bigargtest(void)
{
    375b:	55                   	push   %ebp
    375c:	89 e5                	mov    %esp,%ebp
    375e:	83 ec 18             	sub    $0x18,%esp
  int pid, fd;

  unlink("bigarg-ok");
    3761:	83 ec 0c             	sub    $0xc,%esp
    3764:	68 b7 af 01 00       	push   $0x1afb7
    3769:	e8 b1 07 00 00       	call   3f1f <unlink>
    376e:	83 c4 10             	add    $0x10,%esp
  pid = fork();
    3771:	e8 51 07 00 00       	call   3ec7 <fork>
    3776:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(pid == 0){
    3779:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    377d:	0f 85 97 00 00 00    	jne    381a <bigargtest+0xbf>
    static char *args[MAXARG];
    int i;
    for(i = 0; i < MAXARG-1; i++)
    3783:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    378a:	eb 12                	jmp    379e <bigargtest+0x43>
      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
    378c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    378f:	c7 04 85 60 3d 02 00 	movl   $0x1afc4,0x23d60(,%eax,4)
    3796:	c4 af 01 00 
  unlink("bigarg-ok");
  pid = fork();
  if(pid == 0){
    static char *args[MAXARG];
    int i;
    for(i = 0; i < MAXARG-1; i++)
    379a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    379e:	83 7d f4 1e          	cmpl   $0x1e,-0xc(%ebp)
    37a2:	7e e8                	jle    378c <bigargtest+0x31>
      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
    args[MAXARG-1] = 0;
    37a4:	c7 05 dc 3d 02 00 00 	movl   $0x0,0x23ddc
    37ab:	00 00 00 
    printf(stdout, "bigarg test\n");
    37ae:	a1 14 39 02 00       	mov    0x23914,%eax
    37b3:	83 ec 08             	sub    $0x8,%esp
    37b6:	68 a1 b0 01 00       	push   $0x1b0a1
    37bb:	50                   	push   %eax
    37bc:	e8 b5 08 00 00       	call   4076 <printf>
    37c1:	83 c4 10             	add    $0x10,%esp
    exec("echo", args);
    37c4:	83 ec 08             	sub    $0x8,%esp
    37c7:	68 60 3d 02 00       	push   $0x23d60
    37cc:	68 c0 99 01 00       	push   $0x199c0
    37d1:	e8 31 07 00 00       	call   3f07 <exec>
    37d6:	83 c4 10             	add    $0x10,%esp
    printf(stdout, "bigarg test ok\n");
    37d9:	a1 14 39 02 00       	mov    0x23914,%eax
    37de:	83 ec 08             	sub    $0x8,%esp
    37e1:	68 ae b0 01 00       	push   $0x1b0ae
    37e6:	50                   	push   %eax
    37e7:	e8 8a 08 00 00       	call   4076 <printf>
    37ec:	83 c4 10             	add    $0x10,%esp
    fd = open("bigarg-ok", O_CREATE);
    37ef:	83 ec 08             	sub    $0x8,%esp
    37f2:	68 00 02 00 00       	push   $0x200
    37f7:	68 b7 af 01 00       	push   $0x1afb7
    37fc:	e8 0e 07 00 00       	call   3f0f <open>
    3801:	83 c4 10             	add    $0x10,%esp
    3804:	89 45 ec             	mov    %eax,-0x14(%ebp)
    close(fd);
    3807:	83 ec 0c             	sub    $0xc,%esp
    380a:	ff 75 ec             	pushl  -0x14(%ebp)
    380d:	e8 e5 06 00 00       	call   3ef7 <close>
    3812:	83 c4 10             	add    $0x10,%esp
    exit();
    3815:	e8 b5 06 00 00       	call   3ecf <exit>
  } else if(pid < 0){
    381a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    381e:	79 1b                	jns    383b <bigargtest+0xe0>
    printf(stdout, "bigargtest: fork failed\n");
    3820:	a1 14 39 02 00       	mov    0x23914,%eax
    3825:	83 ec 08             	sub    $0x8,%esp
    3828:	68 be b0 01 00       	push   $0x1b0be
    382d:	50                   	push   %eax
    382e:	e8 43 08 00 00       	call   4076 <printf>
    3833:	83 c4 10             	add    $0x10,%esp
    exit();
    3836:	e8 94 06 00 00       	call   3ecf <exit>
  }
  wait();
    383b:	e8 97 06 00 00       	call   3ed7 <wait>
  fd = open("bigarg-ok", 0);
    3840:	83 ec 08             	sub    $0x8,%esp
    3843:	6a 00                	push   $0x0
    3845:	68 b7 af 01 00       	push   $0x1afb7
    384a:	e8 c0 06 00 00       	call   3f0f <open>
    384f:	83 c4 10             	add    $0x10,%esp
    3852:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(fd < 0){
    3855:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    3859:	79 1b                	jns    3876 <bigargtest+0x11b>
    printf(stdout, "bigarg test failed!\n");
    385b:	a1 14 39 02 00       	mov    0x23914,%eax
    3860:	83 ec 08             	sub    $0x8,%esp
    3863:	68 d7 b0 01 00       	push   $0x1b0d7
    3868:	50                   	push   %eax
    3869:	e8 08 08 00 00       	call   4076 <printf>
    386e:	83 c4 10             	add    $0x10,%esp
    exit();
    3871:	e8 59 06 00 00       	call   3ecf <exit>
  }
  close(fd);
    3876:	83 ec 0c             	sub    $0xc,%esp
    3879:	ff 75 ec             	pushl  -0x14(%ebp)
    387c:	e8 76 06 00 00       	call   3ef7 <close>
    3881:	83 c4 10             	add    $0x10,%esp
  unlink("bigarg-ok");
    3884:	83 ec 0c             	sub    $0xc,%esp
    3887:	68 b7 af 01 00       	push   $0x1afb7
    388c:	e8 8e 06 00 00       	call   3f1f <unlink>
    3891:	83 c4 10             	add    $0x10,%esp
}
    3894:	90                   	nop
    3895:	c9                   	leave  
    3896:	c3                   	ret    

00003897 <fsfull>:

// what happens when the file system runs out of blocks?
// answer: balloc panics, so this test is not useful.
void
fsfull()
{
    3897:	55                   	push   %ebp
    3898:	89 e5                	mov    %esp,%ebp
    389a:	53                   	push   %ebx
    389b:	83 ec 64             	sub    $0x64,%esp
  int nfiles;
  int fsblocks = 0;
    389e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  printf(1, "fsfull test\n");
    38a5:	83 ec 08             	sub    $0x8,%esp
    38a8:	68 ec b0 01 00       	push   $0x1b0ec
    38ad:	6a 01                	push   $0x1
    38af:	e8 c2 07 00 00       	call   4076 <printf>
    38b4:	83 c4 10             	add    $0x10,%esp

  for(nfiles = 0; ; nfiles++){
    38b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    char name[64];
    name[0] = 'f';
    38be:	c6 45 a4 66          	movb   $0x66,-0x5c(%ebp)
    name[1] = '0' + nfiles / 1000;
    38c2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    38c5:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
    38ca:	89 c8                	mov    %ecx,%eax
    38cc:	f7 ea                	imul   %edx
    38ce:	c1 fa 06             	sar    $0x6,%edx
    38d1:	89 c8                	mov    %ecx,%eax
    38d3:	c1 f8 1f             	sar    $0x1f,%eax
    38d6:	29 c2                	sub    %eax,%edx
    38d8:	89 d0                	mov    %edx,%eax
    38da:	83 c0 30             	add    $0x30,%eax
    38dd:	88 45 a5             	mov    %al,-0x5b(%ebp)
    name[2] = '0' + (nfiles % 1000) / 100;
    38e0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    38e3:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
    38e8:	89 d8                	mov    %ebx,%eax
    38ea:	f7 ea                	imul   %edx
    38ec:	c1 fa 06             	sar    $0x6,%edx
    38ef:	89 d8                	mov    %ebx,%eax
    38f1:	c1 f8 1f             	sar    $0x1f,%eax
    38f4:	89 d1                	mov    %edx,%ecx
    38f6:	29 c1                	sub    %eax,%ecx
    38f8:	69 c1 e8 03 00 00    	imul   $0x3e8,%ecx,%eax
    38fe:	29 c3                	sub    %eax,%ebx
    3900:	89 d9                	mov    %ebx,%ecx
    3902:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    3907:	89 c8                	mov    %ecx,%eax
    3909:	f7 ea                	imul   %edx
    390b:	c1 fa 05             	sar    $0x5,%edx
    390e:	89 c8                	mov    %ecx,%eax
    3910:	c1 f8 1f             	sar    $0x1f,%eax
    3913:	29 c2                	sub    %eax,%edx
    3915:	89 d0                	mov    %edx,%eax
    3917:	83 c0 30             	add    $0x30,%eax
    391a:	88 45 a6             	mov    %al,-0x5a(%ebp)
    name[3] = '0' + (nfiles % 100) / 10;
    391d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    3920:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    3925:	89 d8                	mov    %ebx,%eax
    3927:	f7 ea                	imul   %edx
    3929:	c1 fa 05             	sar    $0x5,%edx
    392c:	89 d8                	mov    %ebx,%eax
    392e:	c1 f8 1f             	sar    $0x1f,%eax
    3931:	89 d1                	mov    %edx,%ecx
    3933:	29 c1                	sub    %eax,%ecx
    3935:	6b c1 64             	imul   $0x64,%ecx,%eax
    3938:	29 c3                	sub    %eax,%ebx
    393a:	89 d9                	mov    %ebx,%ecx
    393c:	ba 67 66 66 66       	mov    $0x66666667,%edx
    3941:	89 c8                	mov    %ecx,%eax
    3943:	f7 ea                	imul   %edx
    3945:	c1 fa 02             	sar    $0x2,%edx
    3948:	89 c8                	mov    %ecx,%eax
    394a:	c1 f8 1f             	sar    $0x1f,%eax
    394d:	29 c2                	sub    %eax,%edx
    394f:	89 d0                	mov    %edx,%eax
    3951:	83 c0 30             	add    $0x30,%eax
    3954:	88 45 a7             	mov    %al,-0x59(%ebp)
    name[4] = '0' + (nfiles % 10);
    3957:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    395a:	ba 67 66 66 66       	mov    $0x66666667,%edx
    395f:	89 c8                	mov    %ecx,%eax
    3961:	f7 ea                	imul   %edx
    3963:	c1 fa 02             	sar    $0x2,%edx
    3966:	89 c8                	mov    %ecx,%eax
    3968:	c1 f8 1f             	sar    $0x1f,%eax
    396b:	29 c2                	sub    %eax,%edx
    396d:	89 d0                	mov    %edx,%eax
    396f:	c1 e0 02             	shl    $0x2,%eax
    3972:	01 d0                	add    %edx,%eax
    3974:	01 c0                	add    %eax,%eax
    3976:	29 c1                	sub    %eax,%ecx
    3978:	89 ca                	mov    %ecx,%edx
    397a:	89 d0                	mov    %edx,%eax
    397c:	83 c0 30             	add    $0x30,%eax
    397f:	88 45 a8             	mov    %al,-0x58(%ebp)
    name[5] = '\0';
    3982:	c6 45 a9 00          	movb   $0x0,-0x57(%ebp)
    printf(1, "writing %s\n", name);
    3986:	83 ec 04             	sub    $0x4,%esp
    3989:	8d 45 a4             	lea    -0x5c(%ebp),%eax
    398c:	50                   	push   %eax
    398d:	68 f9 b0 01 00       	push   $0x1b0f9
    3992:	6a 01                	push   $0x1
    3994:	e8 dd 06 00 00       	call   4076 <printf>
    3999:	83 c4 10             	add    $0x10,%esp
    int fd = open(name, O_CREATE|O_RDWR);
    399c:	83 ec 08             	sub    $0x8,%esp
    399f:	68 02 02 00 00       	push   $0x202
    39a4:	8d 45 a4             	lea    -0x5c(%ebp),%eax
    39a7:	50                   	push   %eax
    39a8:	e8 62 05 00 00       	call   3f0f <open>
    39ad:	83 c4 10             	add    $0x10,%esp
    39b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(fd < 0){
    39b3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    39b7:	79 18                	jns    39d1 <fsfull+0x13a>
      printf(1, "open %s failed\n", name);
    39b9:	83 ec 04             	sub    $0x4,%esp
    39bc:	8d 45 a4             	lea    -0x5c(%ebp),%eax
    39bf:	50                   	push   %eax
    39c0:	68 05 b1 01 00       	push   $0x1b105
    39c5:	6a 01                	push   $0x1
    39c7:	e8 aa 06 00 00       	call   4076 <printf>
    39cc:	83 c4 10             	add    $0x10,%esp
      break;
    39cf:	eb 6b                	jmp    3a3c <fsfull+0x1a5>
    }
    int total = 0;
    39d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(1){
      int cc = write(fd, buf, 512);
    39d8:	83 ec 04             	sub    $0x4,%esp
    39db:	68 00 02 00 00       	push   $0x200
    39e0:	68 20 65 02 00       	push   $0x26520
    39e5:	ff 75 e8             	pushl  -0x18(%ebp)
    39e8:	e8 02 05 00 00       	call   3eef <write>
    39ed:	83 c4 10             	add    $0x10,%esp
    39f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(cc < 512)
    39f3:	81 7d e4 ff 01 00 00 	cmpl   $0x1ff,-0x1c(%ebp)
    39fa:	7e 0c                	jle    3a08 <fsfull+0x171>
        break;
      total += cc;
    39fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    39ff:	01 45 ec             	add    %eax,-0x14(%ebp)
      fsblocks++;
    3a02:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    }
    3a06:	eb d0                	jmp    39d8 <fsfull+0x141>
    }
    int total = 0;
    while(1){
      int cc = write(fd, buf, 512);
      if(cc < 512)
        break;
    3a08:	90                   	nop
      total += cc;
      fsblocks++;
    }
    printf(1, "wrote %d bytes\n", total);
    3a09:	83 ec 04             	sub    $0x4,%esp
    3a0c:	ff 75 ec             	pushl  -0x14(%ebp)
    3a0f:	68 15 b1 01 00       	push   $0x1b115
    3a14:	6a 01                	push   $0x1
    3a16:	e8 5b 06 00 00       	call   4076 <printf>
    3a1b:	83 c4 10             	add    $0x10,%esp
    close(fd);
    3a1e:	83 ec 0c             	sub    $0xc,%esp
    3a21:	ff 75 e8             	pushl  -0x18(%ebp)
    3a24:	e8 ce 04 00 00       	call   3ef7 <close>
    3a29:	83 c4 10             	add    $0x10,%esp
    if(total == 0)
    3a2c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    3a30:	74 09                	je     3a3b <fsfull+0x1a4>
  int nfiles;
  int fsblocks = 0;

  printf(1, "fsfull test\n");

  for(nfiles = 0; ; nfiles++){
    3a32:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    }
    printf(1, "wrote %d bytes\n", total);
    close(fd);
    if(total == 0)
      break;
  }
    3a36:	e9 83 fe ff ff       	jmp    38be <fsfull+0x27>
      fsblocks++;
    }
    printf(1, "wrote %d bytes\n", total);
    close(fd);
    if(total == 0)
      break;
    3a3b:	90                   	nop
  }

  while(nfiles >= 0){
    3a3c:	e9 db 00 00 00       	jmp    3b1c <fsfull+0x285>
    char name[64];
    name[0] = 'f';
    3a41:	c6 45 a4 66          	movb   $0x66,-0x5c(%ebp)
    name[1] = '0' + nfiles / 1000;
    3a45:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3a48:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
    3a4d:	89 c8                	mov    %ecx,%eax
    3a4f:	f7 ea                	imul   %edx
    3a51:	c1 fa 06             	sar    $0x6,%edx
    3a54:	89 c8                	mov    %ecx,%eax
    3a56:	c1 f8 1f             	sar    $0x1f,%eax
    3a59:	29 c2                	sub    %eax,%edx
    3a5b:	89 d0                	mov    %edx,%eax
    3a5d:	83 c0 30             	add    $0x30,%eax
    3a60:	88 45 a5             	mov    %al,-0x5b(%ebp)
    name[2] = '0' + (nfiles % 1000) / 100;
    3a63:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    3a66:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
    3a6b:	89 d8                	mov    %ebx,%eax
    3a6d:	f7 ea                	imul   %edx
    3a6f:	c1 fa 06             	sar    $0x6,%edx
    3a72:	89 d8                	mov    %ebx,%eax
    3a74:	c1 f8 1f             	sar    $0x1f,%eax
    3a77:	89 d1                	mov    %edx,%ecx
    3a79:	29 c1                	sub    %eax,%ecx
    3a7b:	69 c1 e8 03 00 00    	imul   $0x3e8,%ecx,%eax
    3a81:	29 c3                	sub    %eax,%ebx
    3a83:	89 d9                	mov    %ebx,%ecx
    3a85:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    3a8a:	89 c8                	mov    %ecx,%eax
    3a8c:	f7 ea                	imul   %edx
    3a8e:	c1 fa 05             	sar    $0x5,%edx
    3a91:	89 c8                	mov    %ecx,%eax
    3a93:	c1 f8 1f             	sar    $0x1f,%eax
    3a96:	29 c2                	sub    %eax,%edx
    3a98:	89 d0                	mov    %edx,%eax
    3a9a:	83 c0 30             	add    $0x30,%eax
    3a9d:	88 45 a6             	mov    %al,-0x5a(%ebp)
    name[3] = '0' + (nfiles % 100) / 10;
    3aa0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    3aa3:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
    3aa8:	89 d8                	mov    %ebx,%eax
    3aaa:	f7 ea                	imul   %edx
    3aac:	c1 fa 05             	sar    $0x5,%edx
    3aaf:	89 d8                	mov    %ebx,%eax
    3ab1:	c1 f8 1f             	sar    $0x1f,%eax
    3ab4:	89 d1                	mov    %edx,%ecx
    3ab6:	29 c1                	sub    %eax,%ecx
    3ab8:	6b c1 64             	imul   $0x64,%ecx,%eax
    3abb:	29 c3                	sub    %eax,%ebx
    3abd:	89 d9                	mov    %ebx,%ecx
    3abf:	ba 67 66 66 66       	mov    $0x66666667,%edx
    3ac4:	89 c8                	mov    %ecx,%eax
    3ac6:	f7 ea                	imul   %edx
    3ac8:	c1 fa 02             	sar    $0x2,%edx
    3acb:	89 c8                	mov    %ecx,%eax
    3acd:	c1 f8 1f             	sar    $0x1f,%eax
    3ad0:	29 c2                	sub    %eax,%edx
    3ad2:	89 d0                	mov    %edx,%eax
    3ad4:	83 c0 30             	add    $0x30,%eax
    3ad7:	88 45 a7             	mov    %al,-0x59(%ebp)
    name[4] = '0' + (nfiles % 10);
    3ada:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3add:	ba 67 66 66 66       	mov    $0x66666667,%edx
    3ae2:	89 c8                	mov    %ecx,%eax
    3ae4:	f7 ea                	imul   %edx
    3ae6:	c1 fa 02             	sar    $0x2,%edx
    3ae9:	89 c8                	mov    %ecx,%eax
    3aeb:	c1 f8 1f             	sar    $0x1f,%eax
    3aee:	29 c2                	sub    %eax,%edx
    3af0:	89 d0                	mov    %edx,%eax
    3af2:	c1 e0 02             	shl    $0x2,%eax
    3af5:	01 d0                	add    %edx,%eax
    3af7:	01 c0                	add    %eax,%eax
    3af9:	29 c1                	sub    %eax,%ecx
    3afb:	89 ca                	mov    %ecx,%edx
    3afd:	89 d0                	mov    %edx,%eax
    3aff:	83 c0 30             	add    $0x30,%eax
    3b02:	88 45 a8             	mov    %al,-0x58(%ebp)
    name[5] = '\0';
    3b05:	c6 45 a9 00          	movb   $0x0,-0x57(%ebp)
    unlink(name);
    3b09:	83 ec 0c             	sub    $0xc,%esp
    3b0c:	8d 45 a4             	lea    -0x5c(%ebp),%eax
    3b0f:	50                   	push   %eax
    3b10:	e8 0a 04 00 00       	call   3f1f <unlink>
    3b15:	83 c4 10             	add    $0x10,%esp
    nfiles--;
    3b18:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    close(fd);
    if(total == 0)
      break;
  }

  while(nfiles >= 0){
    3b1c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3b20:	0f 89 1b ff ff ff    	jns    3a41 <fsfull+0x1aa>
    name[5] = '\0';
    unlink(name);
    nfiles--;
  }

  printf(1, "fsfull test finished\n");
    3b26:	83 ec 08             	sub    $0x8,%esp
    3b29:	68 25 b1 01 00       	push   $0x1b125
    3b2e:	6a 01                	push   $0x1
    3b30:	e8 41 05 00 00       	call   4076 <printf>
    3b35:	83 c4 10             	add    $0x10,%esp
}
    3b38:	90                   	nop
    3b39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3b3c:	c9                   	leave  
    3b3d:	c3                   	ret    

00003b3e <rand>:

unsigned long randstate = 1;
unsigned int
rand()
{
    3b3e:	55                   	push   %ebp
    3b3f:	89 e5                	mov    %esp,%ebp
  randstate = randstate * 1664525 + 1013904223;
    3b41:	a1 18 39 02 00       	mov    0x23918,%eax
    3b46:	69 c0 0d 66 19 00    	imul   $0x19660d,%eax,%eax
    3b4c:	05 5f f3 6e 3c       	add    $0x3c6ef35f,%eax
    3b51:	a3 18 39 02 00       	mov    %eax,0x23918
  return randstate;
    3b56:	a1 18 39 02 00       	mov    0x23918,%eax
}
    3b5b:	5d                   	pop    %ebp
    3b5c:	c3                   	ret    

00003b5d <main>:

int
main(int argc, char *argv[])
{
    3b5d:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    3b61:	83 e4 f0             	and    $0xfffffff0,%esp
    3b64:	ff 71 fc             	pushl  -0x4(%ecx)
    3b67:	55                   	push   %ebp
    3b68:	89 e5                	mov    %esp,%ebp
    3b6a:	51                   	push   %ecx
    3b6b:	83 ec 04             	sub    $0x4,%esp
  printf(1, "usertests starting\n");
    3b6e:	83 ec 08             	sub    $0x8,%esp
    3b71:	68 3b b1 01 00       	push   $0x1b13b
    3b76:	6a 01                	push   $0x1
    3b78:	e8 f9 04 00 00       	call   4076 <printf>
    3b7d:	83 c4 10             	add    $0x10,%esp

  if(open("usertests.ran", 0) >= 0){
    3b80:	83 ec 08             	sub    $0x8,%esp
    3b83:	6a 00                	push   $0x0
    3b85:	68 4f b1 01 00       	push   $0x1b14f
    3b8a:	e8 80 03 00 00       	call   3f0f <open>
    3b8f:	83 c4 10             	add    $0x10,%esp
    3b92:	85 c0                	test   %eax,%eax
    3b94:	78 17                	js     3bad <main+0x50>
    printf(1, "already ran user tests -- rebuild fs.img\n");
    3b96:	83 ec 08             	sub    $0x8,%esp
    3b99:	68 60 b1 01 00       	push   $0x1b160
    3b9e:	6a 01                	push   $0x1
    3ba0:	e8 d1 04 00 00       	call   4076 <printf>
    3ba5:	83 c4 10             	add    $0x10,%esp
    exit();
    3ba8:	e8 22 03 00 00       	call   3ecf <exit>
  }
  close(open("usertests.ran", O_CREATE));
    3bad:	83 ec 08             	sub    $0x8,%esp
    3bb0:	68 00 02 00 00       	push   $0x200
    3bb5:	68 4f b1 01 00       	push   $0x1b14f
    3bba:	e8 50 03 00 00       	call   3f0f <open>
    3bbf:	83 c4 10             	add    $0x10,%esp
    3bc2:	83 ec 0c             	sub    $0xc,%esp
    3bc5:	50                   	push   %eax
    3bc6:	e8 2c 03 00 00       	call   3ef7 <close>
    3bcb:	83 c4 10             	add    $0x10,%esp

  createdelete();
    3bce:	e8 d7 d6 ff ff       	call   12aa <createdelete>
  linkunlink();
    3bd3:	e8 f8 e0 ff ff       	call   1cd0 <linkunlink>
  concreate();
    3bd8:	e8 43 dd ff ff       	call   1920 <concreate>
  fourfiles();
    3bdd:	e8 77 d4 ff ff       	call   1059 <fourfiles>
  sharedfd();
    3be2:	e8 8f d2 ff ff       	call   e76 <sharedfd>

  bigargtest();
    3be7:	e8 6f fb ff ff       	call   375b <bigargtest>
  bigwrite();
    3bec:	e8 d1 ea ff ff       	call   26c2 <bigwrite>
  bigargtest();
    3bf1:	e8 65 fb ff ff       	call   375b <bigargtest>
  bsstest();
    3bf6:	e8 ea fa ff ff       	call   36e5 <bsstest>
  sbrktest();
    3bfb:	e8 f5 f4 ff ff       	call   30f5 <sbrktest>
  validatetest();
    3c00:	e8 02 fa ff ff       	call   3607 <validatetest>

  opentest();
    3c05:	e8 f5 c6 ff ff       	call   2ff <opentest>
  writetest();
    3c0a:	e8 9f c7 ff ff       	call   3ae <writetest>
  writetest1();
    3c0f:	e8 aa c9 ff ff       	call   5be <writetest1>
  createtest();
    3c14:	e8 a1 cb ff ff       	call   7ba <createtest>

  openiputtest();
    3c19:	e8 d2 c5 ff ff       	call   1f0 <openiputtest>
  exitiputtest();
    3c1e:	e8 ce c4 ff ff       	call   f1 <exitiputtest>
  iputtest();
    3c23:	e8 d8 c3 ff ff       	call   0 <iputtest>

  mem();
    3c28:	e8 58 d1 ff ff       	call   d85 <mem>
  pipe1();
    3c2d:	e8 8f cd ff ff       	call   9c1 <pipe1>
  preempt();
    3c32:	e8 73 cf ff ff       	call   baa <preempt>
  exitwait();
    3c37:	e8 d1 d0 ff ff       	call   d0d <exitwait>

  rmdot();
    3c3c:	e8 f3 ee ff ff       	call   2b34 <rmdot>
  fourteen();
    3c41:	e8 92 ed ff ff       	call   29d8 <fourteen>
  bigfile();
    3c46:	e8 75 eb ff ff       	call   27c0 <bigfile>
  subdir();
    3c4b:	e8 2e e3 ff ff       	call   1f7e <subdir>
  linktest();
    3c50:	e8 89 da ff ff       	call   16de <linktest>
  unlinkread();
    3c55:	e8 c2 d8 ff ff       	call   151c <unlinkread>
  dirfile();
    3c5a:	e8 5a f0 ff ff       	call   2cb9 <dirfile>
  iref();
    3c5f:	e8 8d f2 ff ff       	call   2ef1 <iref>
  forktest();
    3c64:	e8 c2 f3 ff ff       	call   302b <forktest>
  bigdir(); // slow
    3c69:	e8 9b e1 ff ff       	call   1e09 <bigdir>
  exectest();
    3c6e:	e8 fb cc ff ff       	call   96e <exectest>

  exit();
    3c73:	e8 57 02 00 00       	call   3ecf <exit>

00003c78 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
    3c78:	55                   	push   %ebp
    3c79:	89 e5                	mov    %esp,%ebp
    3c7b:	57                   	push   %edi
    3c7c:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
    3c7d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    3c80:	8b 55 10             	mov    0x10(%ebp),%edx
    3c83:	8b 45 0c             	mov    0xc(%ebp),%eax
    3c86:	89 cb                	mov    %ecx,%ebx
    3c88:	89 df                	mov    %ebx,%edi
    3c8a:	89 d1                	mov    %edx,%ecx
    3c8c:	fc                   	cld    
    3c8d:	f3 aa                	rep stos %al,%es:(%edi)
    3c8f:	89 ca                	mov    %ecx,%edx
    3c91:	89 fb                	mov    %edi,%ebx
    3c93:	89 5d 08             	mov    %ebx,0x8(%ebp)
    3c96:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
    3c99:	90                   	nop
    3c9a:	5b                   	pop    %ebx
    3c9b:	5f                   	pop    %edi
    3c9c:	5d                   	pop    %ebp
    3c9d:	c3                   	ret    

00003c9e <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
    3c9e:	55                   	push   %ebp
    3c9f:	89 e5                	mov    %esp,%ebp
    3ca1:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
    3ca4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
    3caa:	90                   	nop
    3cab:	8b 45 08             	mov    0x8(%ebp),%eax
    3cae:	8d 50 01             	lea    0x1(%eax),%edx
    3cb1:	89 55 08             	mov    %edx,0x8(%ebp)
    3cb4:	8b 55 0c             	mov    0xc(%ebp),%edx
    3cb7:	8d 4a 01             	lea    0x1(%edx),%ecx
    3cba:	89 4d 0c             	mov    %ecx,0xc(%ebp)
    3cbd:	0f b6 12             	movzbl (%edx),%edx
    3cc0:	88 10                	mov    %dl,(%eax)
    3cc2:	0f b6 00             	movzbl (%eax),%eax
    3cc5:	84 c0                	test   %al,%al
    3cc7:	75 e2                	jne    3cab <strcpy+0xd>
    ;
  return os;
    3cc9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    3ccc:	c9                   	leave  
    3ccd:	c3                   	ret    

00003cce <strcmp>:

int
strcmp(const char *p, const char *q)
{
    3cce:	55                   	push   %ebp
    3ccf:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
    3cd1:	eb 08                	jmp    3cdb <strcmp+0xd>
    p++, q++;
    3cd3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    3cd7:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
    3cdb:	8b 45 08             	mov    0x8(%ebp),%eax
    3cde:	0f b6 00             	movzbl (%eax),%eax
    3ce1:	84 c0                	test   %al,%al
    3ce3:	74 10                	je     3cf5 <strcmp+0x27>
    3ce5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce8:	0f b6 10             	movzbl (%eax),%edx
    3ceb:	8b 45 0c             	mov    0xc(%ebp),%eax
    3cee:	0f b6 00             	movzbl (%eax),%eax
    3cf1:	38 c2                	cmp    %al,%dl
    3cf3:	74 de                	je     3cd3 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
    3cf5:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf8:	0f b6 00             	movzbl (%eax),%eax
    3cfb:	0f b6 d0             	movzbl %al,%edx
    3cfe:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d01:	0f b6 00             	movzbl (%eax),%eax
    3d04:	0f b6 c0             	movzbl %al,%eax
    3d07:	29 c2                	sub    %eax,%edx
    3d09:	89 d0                	mov    %edx,%eax
}
    3d0b:	5d                   	pop    %ebp
    3d0c:	c3                   	ret    

00003d0d <strlen>:

uint
strlen(char *s)
{
    3d0d:	55                   	push   %ebp
    3d0e:	89 e5                	mov    %esp,%ebp
    3d10:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
    3d13:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3d1a:	eb 04                	jmp    3d20 <strlen+0x13>
    3d1c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3d20:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d23:	8b 45 08             	mov    0x8(%ebp),%eax
    3d26:	01 d0                	add    %edx,%eax
    3d28:	0f b6 00             	movzbl (%eax),%eax
    3d2b:	84 c0                	test   %al,%al
    3d2d:	75 ed                	jne    3d1c <strlen+0xf>
    ;
  return n;
    3d2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    3d32:	c9                   	leave  
    3d33:	c3                   	ret    

00003d34 <memset>:

void*
memset(void *dst, int c, uint n)
{
    3d34:	55                   	push   %ebp
    3d35:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
    3d37:	8b 45 10             	mov    0x10(%ebp),%eax
    3d3a:	50                   	push   %eax
    3d3b:	ff 75 0c             	pushl  0xc(%ebp)
    3d3e:	ff 75 08             	pushl  0x8(%ebp)
    3d41:	e8 32 ff ff ff       	call   3c78 <stosb>
    3d46:	83 c4 0c             	add    $0xc,%esp
  return dst;
    3d49:	8b 45 08             	mov    0x8(%ebp),%eax
}
    3d4c:	c9                   	leave  
    3d4d:	c3                   	ret    

00003d4e <strchr>:

char*
strchr(const char *s, char c)
{
    3d4e:	55                   	push   %ebp
    3d4f:	89 e5                	mov    %esp,%ebp
    3d51:	83 ec 04             	sub    $0x4,%esp
    3d54:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d57:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
    3d5a:	eb 14                	jmp    3d70 <strchr+0x22>
    if(*s == c)
    3d5c:	8b 45 08             	mov    0x8(%ebp),%eax
    3d5f:	0f b6 00             	movzbl (%eax),%eax
    3d62:	3a 45 fc             	cmp    -0x4(%ebp),%al
    3d65:	75 05                	jne    3d6c <strchr+0x1e>
      return (char*)s;
    3d67:	8b 45 08             	mov    0x8(%ebp),%eax
    3d6a:	eb 13                	jmp    3d7f <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
    3d6c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    3d70:	8b 45 08             	mov    0x8(%ebp),%eax
    3d73:	0f b6 00             	movzbl (%eax),%eax
    3d76:	84 c0                	test   %al,%al
    3d78:	75 e2                	jne    3d5c <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
    3d7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3d7f:	c9                   	leave  
    3d80:	c3                   	ret    

00003d81 <gets>:

char*
gets(char *buf, int max)
{
    3d81:	55                   	push   %ebp
    3d82:	89 e5                	mov    %esp,%ebp
    3d84:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
    3d87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3d8e:	eb 42                	jmp    3dd2 <gets+0x51>
    cc = read(0, &c, 1);
    3d90:	83 ec 04             	sub    $0x4,%esp
    3d93:	6a 01                	push   $0x1
    3d95:	8d 45 ef             	lea    -0x11(%ebp),%eax
    3d98:	50                   	push   %eax
    3d99:	6a 00                	push   $0x0
    3d9b:	e8 47 01 00 00       	call   3ee7 <read>
    3da0:	83 c4 10             	add    $0x10,%esp
    3da3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
    3da6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    3daa:	7e 33                	jle    3ddf <gets+0x5e>
      break;
    buf[i++] = c;
    3dac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3daf:	8d 50 01             	lea    0x1(%eax),%edx
    3db2:	89 55 f4             	mov    %edx,-0xc(%ebp)
    3db5:	89 c2                	mov    %eax,%edx
    3db7:	8b 45 08             	mov    0x8(%ebp),%eax
    3dba:	01 c2                	add    %eax,%edx
    3dbc:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    3dc0:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
    3dc2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    3dc6:	3c 0a                	cmp    $0xa,%al
    3dc8:	74 16                	je     3de0 <gets+0x5f>
    3dca:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    3dce:	3c 0d                	cmp    $0xd,%al
    3dd0:	74 0e                	je     3de0 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
    3dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3dd5:	83 c0 01             	add    $0x1,%eax
    3dd8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3ddb:	7c b3                	jl     3d90 <gets+0xf>
    3ddd:	eb 01                	jmp    3de0 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
    3ddf:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
    3de0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3de3:	8b 45 08             	mov    0x8(%ebp),%eax
    3de6:	01 d0                	add    %edx,%eax
    3de8:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
    3deb:	8b 45 08             	mov    0x8(%ebp),%eax
}
    3dee:	c9                   	leave  
    3def:	c3                   	ret    

00003df0 <stat>:

int
stat(char *n, struct stat *st)
{
    3df0:	55                   	push   %ebp
    3df1:	89 e5                	mov    %esp,%ebp
    3df3:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
    3df6:	83 ec 08             	sub    $0x8,%esp
    3df9:	6a 00                	push   $0x0
    3dfb:	ff 75 08             	pushl  0x8(%ebp)
    3dfe:	e8 0c 01 00 00       	call   3f0f <open>
    3e03:	83 c4 10             	add    $0x10,%esp
    3e06:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
    3e09:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3e0d:	79 07                	jns    3e16 <stat+0x26>
    return -1;
    3e0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3e14:	eb 25                	jmp    3e3b <stat+0x4b>
  r = fstat(fd, st);
    3e16:	83 ec 08             	sub    $0x8,%esp
    3e19:	ff 75 0c             	pushl  0xc(%ebp)
    3e1c:	ff 75 f4             	pushl  -0xc(%ebp)
    3e1f:	e8 03 01 00 00       	call   3f27 <fstat>
    3e24:	83 c4 10             	add    $0x10,%esp
    3e27:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
    3e2a:	83 ec 0c             	sub    $0xc,%esp
    3e2d:	ff 75 f4             	pushl  -0xc(%ebp)
    3e30:	e8 c2 00 00 00       	call   3ef7 <close>
    3e35:	83 c4 10             	add    $0x10,%esp
  return r;
    3e38:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    3e3b:	c9                   	leave  
    3e3c:	c3                   	ret    

00003e3d <atoi>:

int
atoi(const char *s)
{
    3e3d:	55                   	push   %ebp
    3e3e:	89 e5                	mov    %esp,%ebp
    3e40:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
    3e43:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
    3e4a:	eb 25                	jmp    3e71 <atoi+0x34>
    n = n*10 + *s++ - '0';
    3e4c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e4f:	89 d0                	mov    %edx,%eax
    3e51:	c1 e0 02             	shl    $0x2,%eax
    3e54:	01 d0                	add    %edx,%eax
    3e56:	01 c0                	add    %eax,%eax
    3e58:	89 c1                	mov    %eax,%ecx
    3e5a:	8b 45 08             	mov    0x8(%ebp),%eax
    3e5d:	8d 50 01             	lea    0x1(%eax),%edx
    3e60:	89 55 08             	mov    %edx,0x8(%ebp)
    3e63:	0f b6 00             	movzbl (%eax),%eax
    3e66:	0f be c0             	movsbl %al,%eax
    3e69:	01 c8                	add    %ecx,%eax
    3e6b:	83 e8 30             	sub    $0x30,%eax
    3e6e:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
    3e71:	8b 45 08             	mov    0x8(%ebp),%eax
    3e74:	0f b6 00             	movzbl (%eax),%eax
    3e77:	3c 2f                	cmp    $0x2f,%al
    3e79:	7e 0a                	jle    3e85 <atoi+0x48>
    3e7b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e7e:	0f b6 00             	movzbl (%eax),%eax
    3e81:	3c 39                	cmp    $0x39,%al
    3e83:	7e c7                	jle    3e4c <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
    3e85:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    3e88:	c9                   	leave  
    3e89:	c3                   	ret    

00003e8a <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
    3e8a:	55                   	push   %ebp
    3e8b:	89 e5                	mov    %esp,%ebp
    3e8d:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
    3e90:	8b 45 08             	mov    0x8(%ebp),%eax
    3e93:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
    3e96:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e99:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
    3e9c:	eb 17                	jmp    3eb5 <memmove+0x2b>
    *dst++ = *src++;
    3e9e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ea1:	8d 50 01             	lea    0x1(%eax),%edx
    3ea4:	89 55 fc             	mov    %edx,-0x4(%ebp)
    3ea7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3eaa:	8d 4a 01             	lea    0x1(%edx),%ecx
    3ead:	89 4d f8             	mov    %ecx,-0x8(%ebp)
    3eb0:	0f b6 12             	movzbl (%edx),%edx
    3eb3:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
    3eb5:	8b 45 10             	mov    0x10(%ebp),%eax
    3eb8:	8d 50 ff             	lea    -0x1(%eax),%edx
    3ebb:	89 55 10             	mov    %edx,0x10(%ebp)
    3ebe:	85 c0                	test   %eax,%eax
    3ec0:	7f dc                	jg     3e9e <memmove+0x14>
    *dst++ = *src++;
  return vdst;
    3ec2:	8b 45 08             	mov    0x8(%ebp),%eax
}
    3ec5:	c9                   	leave  
    3ec6:	c3                   	ret    

00003ec7 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
    3ec7:	b8 01 00 00 00       	mov    $0x1,%eax
    3ecc:	cd 40                	int    $0x40
    3ece:	c3                   	ret    

00003ecf <exit>:
SYSCALL(exit)
    3ecf:	b8 02 00 00 00       	mov    $0x2,%eax
    3ed4:	cd 40                	int    $0x40
    3ed6:	c3                   	ret    

00003ed7 <wait>:
SYSCALL(wait)
    3ed7:	b8 03 00 00 00       	mov    $0x3,%eax
    3edc:	cd 40                	int    $0x40
    3ede:	c3                   	ret    

00003edf <pipe>:
SYSCALL(pipe)
    3edf:	b8 04 00 00 00       	mov    $0x4,%eax
    3ee4:	cd 40                	int    $0x40
    3ee6:	c3                   	ret    

00003ee7 <read>:
SYSCALL(read)
    3ee7:	b8 05 00 00 00       	mov    $0x5,%eax
    3eec:	cd 40                	int    $0x40
    3eee:	c3                   	ret    

00003eef <write>:
SYSCALL(write)
    3eef:	b8 10 00 00 00       	mov    $0x10,%eax
    3ef4:	cd 40                	int    $0x40
    3ef6:	c3                   	ret    

00003ef7 <close>:
SYSCALL(close)
    3ef7:	b8 15 00 00 00       	mov    $0x15,%eax
    3efc:	cd 40                	int    $0x40
    3efe:	c3                   	ret    

00003eff <kill>:
SYSCALL(kill)
    3eff:	b8 06 00 00 00       	mov    $0x6,%eax
    3f04:	cd 40                	int    $0x40
    3f06:	c3                   	ret    

00003f07 <exec>:
SYSCALL(exec)
    3f07:	b8 07 00 00 00       	mov    $0x7,%eax
    3f0c:	cd 40                	int    $0x40
    3f0e:	c3                   	ret    

00003f0f <open>:
SYSCALL(open)
    3f0f:	b8 0f 00 00 00       	mov    $0xf,%eax
    3f14:	cd 40                	int    $0x40
    3f16:	c3                   	ret    

00003f17 <mknod>:
SYSCALL(mknod)
    3f17:	b8 11 00 00 00       	mov    $0x11,%eax
    3f1c:	cd 40                	int    $0x40
    3f1e:	c3                   	ret    

00003f1f <unlink>:
SYSCALL(unlink)
    3f1f:	b8 12 00 00 00       	mov    $0x12,%eax
    3f24:	cd 40                	int    $0x40
    3f26:	c3                   	ret    

00003f27 <fstat>:
SYSCALL(fstat)
    3f27:	b8 08 00 00 00       	mov    $0x8,%eax
    3f2c:	cd 40                	int    $0x40
    3f2e:	c3                   	ret    

00003f2f <link>:
SYSCALL(link)
    3f2f:	b8 13 00 00 00       	mov    $0x13,%eax
    3f34:	cd 40                	int    $0x40
    3f36:	c3                   	ret    

00003f37 <mkdir>:
SYSCALL(mkdir)
    3f37:	b8 14 00 00 00       	mov    $0x14,%eax
    3f3c:	cd 40                	int    $0x40
    3f3e:	c3                   	ret    

00003f3f <chdir>:
SYSCALL(chdir)
    3f3f:	b8 09 00 00 00       	mov    $0x9,%eax
    3f44:	cd 40                	int    $0x40
    3f46:	c3                   	ret    

00003f47 <dup>:
SYSCALL(dup)
    3f47:	b8 0a 00 00 00       	mov    $0xa,%eax
    3f4c:	cd 40                	int    $0x40
    3f4e:	c3                   	ret    

00003f4f <getpid>:
SYSCALL(getpid)
    3f4f:	b8 0b 00 00 00       	mov    $0xb,%eax
    3f54:	cd 40                	int    $0x40
    3f56:	c3                   	ret    

00003f57 <sbrk>:
SYSCALL(sbrk)
    3f57:	b8 0c 00 00 00       	mov    $0xc,%eax
    3f5c:	cd 40                	int    $0x40
    3f5e:	c3                   	ret    

00003f5f <sleep>:
SYSCALL(sleep)
    3f5f:	b8 0d 00 00 00       	mov    $0xd,%eax
    3f64:	cd 40                	int    $0x40
    3f66:	c3                   	ret    

00003f67 <uptime>:
SYSCALL(uptime)
    3f67:	b8 0e 00 00 00       	mov    $0xe,%eax
    3f6c:	cd 40                	int    $0x40
    3f6e:	c3                   	ret    

00003f6f <createwindow>:
SYSCALL(createwindow)
    3f6f:	b8 16 00 00 00       	mov    $0x16,%eax
    3f74:	cd 40                	int    $0x40
    3f76:	c3                   	ret    

00003f77 <repaintwindow>:
SYSCALL(repaintwindow)
    3f77:	b8 17 00 00 00       	mov    $0x17,%eax
    3f7c:	cd 40                	int    $0x40
    3f7e:	c3                   	ret    

00003f7f <getmessage>:
SYSCALL(getmessage)
    3f7f:	b8 18 00 00 00       	mov    $0x18,%eax
    3f84:	cd 40                	int    $0x40
    3f86:	c3                   	ret    

00003f87 <settimer>:
SYSCALL(settimer)
    3f87:	b8 19 00 00 00       	mov    $0x19,%eax
    3f8c:	cd 40                	int    $0x40
    3f8e:	c3                   	ret    

00003f8f <updatewindow>:
SYSCALL(updatewindow)
    3f8f:	b8 1a 00 00 00       	mov    $0x1a,%eax
    3f94:	cd 40                	int    $0x40
    3f96:	c3                   	ret    

00003f97 <destroywindow>:
SYSCALL(destroywindow)
    3f97:	b8 1b 00 00 00       	mov    $0x1b,%eax
    3f9c:	cd 40                	int    $0x40
    3f9e:	c3                   	ret    

00003f9f <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
    3f9f:	55                   	push   %ebp
    3fa0:	89 e5                	mov    %esp,%ebp
    3fa2:	83 ec 18             	sub    $0x18,%esp
    3fa5:	8b 45 0c             	mov    0xc(%ebp),%eax
    3fa8:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
    3fab:	83 ec 04             	sub    $0x4,%esp
    3fae:	6a 01                	push   $0x1
    3fb0:	8d 45 f4             	lea    -0xc(%ebp),%eax
    3fb3:	50                   	push   %eax
    3fb4:	ff 75 08             	pushl  0x8(%ebp)
    3fb7:	e8 33 ff ff ff       	call   3eef <write>
    3fbc:	83 c4 10             	add    $0x10,%esp
}
    3fbf:	90                   	nop
    3fc0:	c9                   	leave  
    3fc1:	c3                   	ret    

00003fc2 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
    3fc2:	55                   	push   %ebp
    3fc3:	89 e5                	mov    %esp,%ebp
    3fc5:	53                   	push   %ebx
    3fc6:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
    3fc9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
    3fd0:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    3fd4:	74 17                	je     3fed <printint+0x2b>
    3fd6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    3fda:	79 11                	jns    3fed <printint+0x2b>
    neg = 1;
    3fdc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
    3fe3:	8b 45 0c             	mov    0xc(%ebp),%eax
    3fe6:	f7 d8                	neg    %eax
    3fe8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    3feb:	eb 06                	jmp    3ff3 <printint+0x31>
  } else {
    x = xx;
    3fed:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ff0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
    3ff3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
    3ffa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3ffd:	8d 41 01             	lea    0x1(%ecx),%eax
    4000:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4003:	8b 5d 10             	mov    0x10(%ebp),%ebx
    4006:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4009:	ba 00 00 00 00       	mov    $0x0,%edx
    400e:	f7 f3                	div    %ebx
    4010:	89 d0                	mov    %edx,%eax
    4012:	0f b6 80 1c 39 02 00 	movzbl 0x2391c(%eax),%eax
    4019:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
    401d:	8b 5d 10             	mov    0x10(%ebp),%ebx
    4020:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4023:	ba 00 00 00 00       	mov    $0x0,%edx
    4028:	f7 f3                	div    %ebx
    402a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    402d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    4031:	75 c7                	jne    3ffa <printint+0x38>
  if(neg)
    4033:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    4037:	74 2d                	je     4066 <printint+0xa4>
    buf[i++] = '-';
    4039:	8b 45 f4             	mov    -0xc(%ebp),%eax
    403c:	8d 50 01             	lea    0x1(%eax),%edx
    403f:	89 55 f4             	mov    %edx,-0xc(%ebp)
    4042:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
    4047:	eb 1d                	jmp    4066 <printint+0xa4>
    putc(fd, buf[i]);
    4049:	8d 55 dc             	lea    -0x24(%ebp),%edx
    404c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    404f:	01 d0                	add    %edx,%eax
    4051:	0f b6 00             	movzbl (%eax),%eax
    4054:	0f be c0             	movsbl %al,%eax
    4057:	83 ec 08             	sub    $0x8,%esp
    405a:	50                   	push   %eax
    405b:	ff 75 08             	pushl  0x8(%ebp)
    405e:	e8 3c ff ff ff       	call   3f9f <putc>
    4063:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
    4066:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    406a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    406e:	79 d9                	jns    4049 <printint+0x87>
    putc(fd, buf[i]);
}
    4070:	90                   	nop
    4071:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4074:	c9                   	leave  
    4075:	c3                   	ret    

00004076 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
    4076:	55                   	push   %ebp
    4077:	89 e5                	mov    %esp,%ebp
    4079:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
    407c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
    4083:	8d 45 0c             	lea    0xc(%ebp),%eax
    4086:	83 c0 04             	add    $0x4,%eax
    4089:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
    408c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4093:	e9 59 01 00 00       	jmp    41f1 <printf+0x17b>
    c = fmt[i] & 0xff;
    4098:	8b 55 0c             	mov    0xc(%ebp),%edx
    409b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    409e:	01 d0                	add    %edx,%eax
    40a0:	0f b6 00             	movzbl (%eax),%eax
    40a3:	0f be c0             	movsbl %al,%eax
    40a6:	25 ff 00 00 00       	and    $0xff,%eax
    40ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
    40ae:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    40b2:	75 2c                	jne    40e0 <printf+0x6a>
      if(c == '%'){
    40b4:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    40b8:	75 0c                	jne    40c6 <printf+0x50>
        state = '%';
    40ba:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
    40c1:	e9 27 01 00 00       	jmp    41ed <printf+0x177>
      } else {
        putc(fd, c);
    40c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    40c9:	0f be c0             	movsbl %al,%eax
    40cc:	83 ec 08             	sub    $0x8,%esp
    40cf:	50                   	push   %eax
    40d0:	ff 75 08             	pushl  0x8(%ebp)
    40d3:	e8 c7 fe ff ff       	call   3f9f <putc>
    40d8:	83 c4 10             	add    $0x10,%esp
    40db:	e9 0d 01 00 00       	jmp    41ed <printf+0x177>
      }
    } else if(state == '%'){
    40e0:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
    40e4:	0f 85 03 01 00 00    	jne    41ed <printf+0x177>
      if(c == 'd'){
    40ea:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
    40ee:	75 1e                	jne    410e <printf+0x98>
        printint(fd, *ap, 10, 1);
    40f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    40f3:	8b 00                	mov    (%eax),%eax
    40f5:	6a 01                	push   $0x1
    40f7:	6a 0a                	push   $0xa
    40f9:	50                   	push   %eax
    40fa:	ff 75 08             	pushl  0x8(%ebp)
    40fd:	e8 c0 fe ff ff       	call   3fc2 <printint>
    4102:	83 c4 10             	add    $0x10,%esp
        ap++;
    4105:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    4109:	e9 d8 00 00 00       	jmp    41e6 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
    410e:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
    4112:	74 06                	je     411a <printf+0xa4>
    4114:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
    4118:	75 1e                	jne    4138 <printf+0xc2>
        printint(fd, *ap, 16, 0);
    411a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    411d:	8b 00                	mov    (%eax),%eax
    411f:	6a 00                	push   $0x0
    4121:	6a 10                	push   $0x10
    4123:	50                   	push   %eax
    4124:	ff 75 08             	pushl  0x8(%ebp)
    4127:	e8 96 fe ff ff       	call   3fc2 <printint>
    412c:	83 c4 10             	add    $0x10,%esp
        ap++;
    412f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    4133:	e9 ae 00 00 00       	jmp    41e6 <printf+0x170>
      } else if(c == 's'){
    4138:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
    413c:	75 43                	jne    4181 <printf+0x10b>
        s = (char*)*ap;
    413e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4141:	8b 00                	mov    (%eax),%eax
    4143:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
    4146:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
    414a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    414e:	75 25                	jne    4175 <printf+0xff>
          s = "(null)";
    4150:	c7 45 f4 8a b1 01 00 	movl   $0x1b18a,-0xc(%ebp)
        while(*s != 0){
    4157:	eb 1c                	jmp    4175 <printf+0xff>
          putc(fd, *s);
    4159:	8b 45 f4             	mov    -0xc(%ebp),%eax
    415c:	0f b6 00             	movzbl (%eax),%eax
    415f:	0f be c0             	movsbl %al,%eax
    4162:	83 ec 08             	sub    $0x8,%esp
    4165:	50                   	push   %eax
    4166:	ff 75 08             	pushl  0x8(%ebp)
    4169:	e8 31 fe ff ff       	call   3f9f <putc>
    416e:	83 c4 10             	add    $0x10,%esp
          s++;
    4171:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
    4175:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4178:	0f b6 00             	movzbl (%eax),%eax
    417b:	84 c0                	test   %al,%al
    417d:	75 da                	jne    4159 <printf+0xe3>
    417f:	eb 65                	jmp    41e6 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
    4181:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
    4185:	75 1d                	jne    41a4 <printf+0x12e>
        putc(fd, *ap);
    4187:	8b 45 e8             	mov    -0x18(%ebp),%eax
    418a:	8b 00                	mov    (%eax),%eax
    418c:	0f be c0             	movsbl %al,%eax
    418f:	83 ec 08             	sub    $0x8,%esp
    4192:	50                   	push   %eax
    4193:	ff 75 08             	pushl  0x8(%ebp)
    4196:	e8 04 fe ff ff       	call   3f9f <putc>
    419b:	83 c4 10             	add    $0x10,%esp
        ap++;
    419e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
    41a2:	eb 42                	jmp    41e6 <printf+0x170>
      } else if(c == '%'){
    41a4:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
    41a8:	75 17                	jne    41c1 <printf+0x14b>
        putc(fd, c);
    41aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    41ad:	0f be c0             	movsbl %al,%eax
    41b0:	83 ec 08             	sub    $0x8,%esp
    41b3:	50                   	push   %eax
    41b4:	ff 75 08             	pushl  0x8(%ebp)
    41b7:	e8 e3 fd ff ff       	call   3f9f <putc>
    41bc:	83 c4 10             	add    $0x10,%esp
    41bf:	eb 25                	jmp    41e6 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
    41c1:	83 ec 08             	sub    $0x8,%esp
    41c4:	6a 25                	push   $0x25
    41c6:	ff 75 08             	pushl  0x8(%ebp)
    41c9:	e8 d1 fd ff ff       	call   3f9f <putc>
    41ce:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
    41d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    41d4:	0f be c0             	movsbl %al,%eax
    41d7:	83 ec 08             	sub    $0x8,%esp
    41da:	50                   	push   %eax
    41db:	ff 75 08             	pushl  0x8(%ebp)
    41de:	e8 bc fd ff ff       	call   3f9f <putc>
    41e3:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
    41e6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
    41ed:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    41f1:	8b 55 0c             	mov    0xc(%ebp),%edx
    41f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    41f7:	01 d0                	add    %edx,%eax
    41f9:	0f b6 00             	movzbl (%eax),%eax
    41fc:	84 c0                	test   %al,%al
    41fe:	0f 85 94 fe ff ff    	jne    4098 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
    4204:	90                   	nop
    4205:	c9                   	leave  
    4206:	c3                   	ret    

00004207 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
    4207:	55                   	push   %ebp
    4208:	89 e5                	mov    %esp,%ebp
    420a:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
    420d:	8b 45 08             	mov    0x8(%ebp),%eax
    4210:	83 e8 08             	sub    $0x8,%eax
    4213:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    4216:	a1 e8 3d 02 00       	mov    0x23de8,%eax
    421b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    421e:	eb 24                	jmp    4244 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
    4220:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4223:	8b 00                	mov    (%eax),%eax
    4225:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    4228:	77 12                	ja     423c <free+0x35>
    422a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    422d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    4230:	77 24                	ja     4256 <free+0x4f>
    4232:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4235:	8b 00                	mov    (%eax),%eax
    4237:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    423a:	77 1a                	ja     4256 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
    423c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    423f:	8b 00                	mov    (%eax),%eax
    4241:	89 45 fc             	mov    %eax,-0x4(%ebp)
    4244:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4247:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    424a:	76 d4                	jbe    4220 <free+0x19>
    424c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    424f:	8b 00                	mov    (%eax),%eax
    4251:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4254:	76 ca                	jbe    4220 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
    4256:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4259:	8b 40 04             	mov    0x4(%eax),%eax
    425c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    4263:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4266:	01 c2                	add    %eax,%edx
    4268:	8b 45 fc             	mov    -0x4(%ebp),%eax
    426b:	8b 00                	mov    (%eax),%eax
    426d:	39 c2                	cmp    %eax,%edx
    426f:	75 24                	jne    4295 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
    4271:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4274:	8b 50 04             	mov    0x4(%eax),%edx
    4277:	8b 45 fc             	mov    -0x4(%ebp),%eax
    427a:	8b 00                	mov    (%eax),%eax
    427c:	8b 40 04             	mov    0x4(%eax),%eax
    427f:	01 c2                	add    %eax,%edx
    4281:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4284:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
    4287:	8b 45 fc             	mov    -0x4(%ebp),%eax
    428a:	8b 00                	mov    (%eax),%eax
    428c:	8b 10                	mov    (%eax),%edx
    428e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4291:	89 10                	mov    %edx,(%eax)
    4293:	eb 0a                	jmp    429f <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
    4295:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4298:	8b 10                	mov    (%eax),%edx
    429a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    429d:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
    429f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42a2:	8b 40 04             	mov    0x4(%eax),%eax
    42a5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    42ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42af:	01 d0                	add    %edx,%eax
    42b1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    42b4:	75 20                	jne    42d6 <free+0xcf>
    p->s.size += bp->s.size;
    42b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42b9:	8b 50 04             	mov    0x4(%eax),%edx
    42bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    42bf:	8b 40 04             	mov    0x4(%eax),%eax
    42c2:	01 c2                	add    %eax,%edx
    42c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42c7:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
    42ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    42cd:	8b 10                	mov    (%eax),%edx
    42cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42d2:	89 10                	mov    %edx,(%eax)
    42d4:	eb 08                	jmp    42de <free+0xd7>
  } else
    p->s.ptr = bp;
    42d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42d9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    42dc:	89 10                	mov    %edx,(%eax)
  freep = p;
    42de:	8b 45 fc             	mov    -0x4(%ebp),%eax
    42e1:	a3 e8 3d 02 00       	mov    %eax,0x23de8
}
    42e6:	90                   	nop
    42e7:	c9                   	leave  
    42e8:	c3                   	ret    

000042e9 <morecore>:

static Header*
morecore(uint nu)
{
    42e9:	55                   	push   %ebp
    42ea:	89 e5                	mov    %esp,%ebp
    42ec:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
    42ef:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
    42f6:	77 07                	ja     42ff <morecore+0x16>
    nu = 4096;
    42f8:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
    42ff:	8b 45 08             	mov    0x8(%ebp),%eax
    4302:	c1 e0 03             	shl    $0x3,%eax
    4305:	83 ec 0c             	sub    $0xc,%esp
    4308:	50                   	push   %eax
    4309:	e8 49 fc ff ff       	call   3f57 <sbrk>
    430e:	83 c4 10             	add    $0x10,%esp
    4311:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
    4314:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
    4318:	75 07                	jne    4321 <morecore+0x38>
    return 0;
    431a:	b8 00 00 00 00       	mov    $0x0,%eax
    431f:	eb 26                	jmp    4347 <morecore+0x5e>
  hp = (Header*)p;
    4321:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4324:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
    4327:	8b 45 f0             	mov    -0x10(%ebp),%eax
    432a:	8b 55 08             	mov    0x8(%ebp),%edx
    432d:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
    4330:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4333:	83 c0 08             	add    $0x8,%eax
    4336:	83 ec 0c             	sub    $0xc,%esp
    4339:	50                   	push   %eax
    433a:	e8 c8 fe ff ff       	call   4207 <free>
    433f:	83 c4 10             	add    $0x10,%esp
  return freep;
    4342:	a1 e8 3d 02 00       	mov    0x23de8,%eax
}
    4347:	c9                   	leave  
    4348:	c3                   	ret    

00004349 <malloc>:

void*
malloc(uint nbytes)
{
    4349:	55                   	push   %ebp
    434a:	89 e5                	mov    %esp,%ebp
    434c:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
    434f:	8b 45 08             	mov    0x8(%ebp),%eax
    4352:	83 c0 07             	add    $0x7,%eax
    4355:	c1 e8 03             	shr    $0x3,%eax
    4358:	83 c0 01             	add    $0x1,%eax
    435b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
    435e:	a1 e8 3d 02 00       	mov    0x23de8,%eax
    4363:	89 45 f0             	mov    %eax,-0x10(%ebp)
    4366:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    436a:	75 23                	jne    438f <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
    436c:	c7 45 f0 e0 3d 02 00 	movl   $0x23de0,-0x10(%ebp)
    4373:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4376:	a3 e8 3d 02 00       	mov    %eax,0x23de8
    437b:	a1 e8 3d 02 00       	mov    0x23de8,%eax
    4380:	a3 e0 3d 02 00       	mov    %eax,0x23de0
    base.s.size = 0;
    4385:	c7 05 e4 3d 02 00 00 	movl   $0x0,0x23de4
    438c:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    438f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4392:	8b 00                	mov    (%eax),%eax
    4394:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
    4397:	8b 45 f4             	mov    -0xc(%ebp),%eax
    439a:	8b 40 04             	mov    0x4(%eax),%eax
    439d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    43a0:	72 4d                	jb     43ef <malloc+0xa6>
      if(p->s.size == nunits)
    43a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43a5:	8b 40 04             	mov    0x4(%eax),%eax
    43a8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    43ab:	75 0c                	jne    43b9 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
    43ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43b0:	8b 10                	mov    (%eax),%edx
    43b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    43b5:	89 10                	mov    %edx,(%eax)
    43b7:	eb 26                	jmp    43df <malloc+0x96>
      else {
        p->s.size -= nunits;
    43b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43bc:	8b 40 04             	mov    0x4(%eax),%eax
    43bf:	2b 45 ec             	sub    -0x14(%ebp),%eax
    43c2:	89 c2                	mov    %eax,%edx
    43c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43c7:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
    43ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43cd:	8b 40 04             	mov    0x4(%eax),%eax
    43d0:	c1 e0 03             	shl    $0x3,%eax
    43d3:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
    43d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43d9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    43dc:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
    43df:	8b 45 f0             	mov    -0x10(%ebp),%eax
    43e2:	a3 e8 3d 02 00       	mov    %eax,0x23de8
      return (void*)(p + 1);
    43e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43ea:	83 c0 08             	add    $0x8,%eax
    43ed:	eb 3b                	jmp    442a <malloc+0xe1>
    }
    if(p == freep)
    43ef:	a1 e8 3d 02 00       	mov    0x23de8,%eax
    43f4:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    43f7:	75 1e                	jne    4417 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
    43f9:	83 ec 0c             	sub    $0xc,%esp
    43fc:	ff 75 ec             	pushl  -0x14(%ebp)
    43ff:	e8 e5 fe ff ff       	call   42e9 <morecore>
    4404:	83 c4 10             	add    $0x10,%esp
    4407:	89 45 f4             	mov    %eax,-0xc(%ebp)
    440a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    440e:	75 07                	jne    4417 <malloc+0xce>
        return 0;
    4410:	b8 00 00 00 00       	mov    $0x0,%eax
    4415:	eb 13                	jmp    442a <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
    4417:	8b 45 f4             	mov    -0xc(%ebp),%eax
    441a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    441d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4420:	8b 00                	mov    (%eax),%eax
    4422:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
    4425:	e9 6d ff ff ff       	jmp    4397 <malloc+0x4e>
}
    442a:	c9                   	leave  
    442b:	c3                   	ret    

0000442c <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
    442c:	55                   	push   %ebp
    442d:	89 e5                	mov    %esp,%ebp
    ++g_seed;
    442f:	a1 ec 3d 02 00       	mov    0x23dec,%eax
    4434:	83 c0 01             	add    $0x1,%eax
    4437:	a3 ec 3d 02 00       	mov    %eax,0x23dec
    g_seed = (214013*g_seed+2531011);
    443c:	a1 ec 3d 02 00       	mov    0x23dec,%eax
    4441:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
    4447:	05 c3 9e 26 00       	add    $0x269ec3,%eax
    444c:	a3 ec 3d 02 00       	mov    %eax,0x23dec
    return (g_seed>>16)&0x7FFF;
    4451:	a1 ec 3d 02 00       	mov    0x23dec,%eax
    4456:	c1 e8 10             	shr    $0x10,%eax
    4459:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
    445e:	5d                   	pop    %ebp
    445f:	c3                   	ret    

00004460 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
    4460:	55                   	push   %ebp
    4461:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
    4463:	d9 45 08             	flds   0x8(%ebp)
    4466:	d9 ee                	fldz   
    4468:	d9 c9                	fxch   %st(1)
    446a:	df e9                	fucomip %st(1),%st
    446c:	dd d8                	fstp   %st(0)
    446e:	76 05                	jbe    4475 <abs+0x15>
    4470:	d9 45 08             	flds   0x8(%ebp)
    4473:	eb 05                	jmp    447a <abs+0x1a>
	return -x;
    4475:	d9 45 08             	flds   0x8(%ebp)
    4478:	d9 e0                	fchs   
}
    447a:	5d                   	pop    %ebp
    447b:	c3                   	ret    

0000447c <pow>:

float pow(float a, int b)
{
    447c:	55                   	push   %ebp
    447d:	89 e5                	mov    %esp,%ebp
    447f:	83 ec 10             	sub    $0x10,%esp
	float r = a;
    4482:	d9 45 08             	flds   0x8(%ebp)
    4485:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
    4488:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    448c:	7e 17                	jle    44a5 <pow+0x29>
		while (--b)
    448e:	eb 09                	jmp    4499 <pow+0x1d>
			r *= a;
    4490:	d9 45 fc             	flds   -0x4(%ebp)
    4493:	d8 4d 08             	fmuls  0x8(%ebp)
    4496:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
    4499:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    449d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    44a1:	75 ed                	jne    4490 <pow+0x14>
    44a3:	eb 2a                	jmp    44cf <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
    44a5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    44a9:	79 1f                	jns    44ca <pow+0x4e>
		while (++b)
    44ab:	eb 09                	jmp    44b6 <pow+0x3a>
			r *= a;
    44ad:	d9 45 fc             	flds   -0x4(%ebp)
    44b0:	d8 4d 08             	fmuls  0x8(%ebp)
    44b3:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
    44b6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    44ba:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    44be:	75 ed                	jne    44ad <pow+0x31>
			r *= a;
		r = 1.0 / r;
    44c0:	d9 e8                	fld1   
    44c2:	d8 75 fc             	fdivs  -0x4(%ebp)
    44c5:	d9 5d fc             	fstps  -0x4(%ebp)
    44c8:	eb 05                	jmp    44cf <pow+0x53>
	}
	else r = 0;
    44ca:	d9 ee                	fldz   
    44cc:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
    44cf:	d9 45 fc             	flds   -0x4(%ebp)
}
    44d2:	c9                   	leave  
    44d3:	c3                   	ret    

000044d4 <sqrt>:

float sqrt(float number) {
    44d4:	55                   	push   %ebp
    44d5:	89 e5                	mov    %esp,%ebp
    44d7:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
    44da:	d9 ee                	fldz   
    44dc:	d9 45 08             	flds   0x8(%ebp)
    44df:	d9 c9                	fxch   %st(1)
    44e1:	df e9                	fucomip %st(1),%st
    44e3:	dd d8                	fstp   %st(0)
    44e5:	76 06                	jbe    44ed <sqrt+0x19>
		return -1;
    44e7:	d9 e8                	fld1   
    44e9:	d9 e0                	fchs   
    44eb:	eb 3a                	jmp    4527 <sqrt+0x53>
	}

	new_guess = 1;
    44ed:	d9 e8                	fld1   
    44ef:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
    44f2:	d9 45 fc             	flds   -0x4(%ebp)
    44f5:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
    44f8:	d9 45 08             	flds   0x8(%ebp)
    44fb:	d8 75 f8             	fdivs  -0x8(%ebp)
    44fe:	d8 45 f8             	fadds  -0x8(%ebp)
    4501:	d9 05 98 b1 01 00    	flds   0x1b198
    4507:	de f9                	fdivrp %st,%st(1)
    4509:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
    450c:	d9 45 fc             	flds   -0x4(%ebp)
    450f:	d9 45 f8             	flds   -0x8(%ebp)
    4512:	df e9                	fucomip %st(1),%st
    4514:	dd d8                	fstp   %st(0)
    4516:	7a da                	jp     44f2 <sqrt+0x1e>
    4518:	d9 45 fc             	flds   -0x4(%ebp)
    451b:	d9 45 f8             	flds   -0x8(%ebp)
    451e:	df e9                	fucomip %st(1),%st
    4520:	dd d8                	fstp   %st(0)
    4522:	75 ce                	jne    44f2 <sqrt+0x1e>

	return new_guess;
    4524:	d9 45 fc             	flds   -0x4(%ebp)
}
    4527:	c9                   	leave  
    4528:	c3                   	ret    

00004529 <cos>:

float cos(float x)
{
    4529:	55                   	push   %ebp
    452a:	89 e5                	mov    %esp,%ebp
    452c:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    452f:	d9 e8                	fld1   
    4531:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    4534:	d9 45 08             	flds   0x8(%ebp)
    4537:	dd 05 a0 b1 01 00    	fldl   0x1b1a0
    453d:	d9 c9                	fxch   %st(1)
    453f:	df e9                	fucomip %st(1),%st
    4541:	dd d8                	fstp   %st(0)
    4543:	77 0f                	ja     4554 <cos+0x2b>
    4545:	d9 45 08             	flds   0x8(%ebp)
    4548:	dd 05 a8 b1 01 00    	fldl   0x1b1a8
    454e:	df e9                	fucomip %st(1),%st
    4550:	dd d8                	fstp   %st(0)
    4552:	76 3c                	jbe    4590 <cos+0x67>
    4554:	d9 45 08             	flds   0x8(%ebp)
    4557:	d9 45 08             	flds   0x8(%ebp)
    455a:	dd 05 a0 b1 01 00    	fldl   0x1b1a0
    4560:	de f9                	fdivrp %st,%st(1)
    4562:	d9 7d e2             	fnstcw -0x1e(%ebp)
    4565:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    4569:	b4 0c                	mov    $0xc,%ah
    456b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    456f:	d9 6d e0             	fldcw  -0x20(%ebp)
    4572:	db 5d dc             	fistpl -0x24(%ebp)
    4575:	d9 6d e2             	fldcw  -0x1e(%ebp)
    4578:	8b 45 dc             	mov    -0x24(%ebp),%eax
    457b:	01 c0                	add    %eax,%eax
    457d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    4580:	db 45 d8             	fildl  -0x28(%ebp)
    4583:	dd 05 b0 b1 01 00    	fldl   0x1b1b0
    4589:	de c9                	fmulp  %st,%st(1)
    458b:	de e9                	fsubrp %st,%st(1)
    458d:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    4590:	d9 45 08             	flds   0x8(%ebp)
    4593:	dd 05 b0 b1 01 00    	fldl   0x1b1b0
    4599:	d9 c9                	fxch   %st(1)
    459b:	df e9                	fucomip %st(1),%st
    459d:	dd d8                	fstp   %st(0)
    459f:	76 0e                	jbe    45af <cos+0x86>
    45a1:	d9 45 08             	flds   0x8(%ebp)
    45a4:	dd 05 a0 b1 01 00    	fldl   0x1b1a0
    45aa:	de e9                	fsubrp %st,%st(1)
    45ac:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    45af:	d9 45 08             	flds   0x8(%ebp)
    45b2:	dd 05 b8 b1 01 00    	fldl   0x1b1b8
    45b8:	df e9                	fucomip %st(1),%st
    45ba:	dd d8                	fstp   %st(0)
    45bc:	76 0e                	jbe    45cc <cos+0xa3>
    45be:	d9 45 08             	flds   0x8(%ebp)
    45c1:	dd 05 a0 b1 01 00    	fldl   0x1b1a0
    45c7:	de c1                	faddp  %st,%st(1)
    45c9:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    45cc:	d9 45 08             	flds   0x8(%ebp)
    45cf:	dd 05 c0 b1 01 00    	fldl   0x1b1c0
    45d5:	d9 c9                	fxch   %st(1)
    45d7:	df e9                	fucomip %st(1),%st
    45d9:	dd d8                	fstp   %st(0)
    45db:	76 16                	jbe    45f3 <cos+0xca>
    {
        x -= PI;
    45dd:	d9 45 08             	flds   0x8(%ebp)
    45e0:	dd 05 b0 b1 01 00    	fldl   0x1b1b0
    45e6:	de e9                	fsubrp %st,%st(1)
    45e8:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    45eb:	d9 45 f4             	flds   -0xc(%ebp)
    45ee:	d9 e0                	fchs   
    45f0:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    45f3:	d9 45 08             	flds   0x8(%ebp)
    45f6:	dd 05 c8 b1 01 00    	fldl   0x1b1c8
    45fc:	df e9                	fucomip %st(1),%st
    45fe:	dd d8                	fstp   %st(0)
    4600:	76 16                	jbe    4618 <cos+0xef>
    {
        x += PI;
    4602:	d9 45 08             	flds   0x8(%ebp)
    4605:	dd 05 b0 b1 01 00    	fldl   0x1b1b0
    460b:	de c1                	faddp  %st,%st(1)
    460d:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    4610:	d9 45 f4             	flds   -0xc(%ebp)
    4613:	d9 e0                	fchs   
    4615:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
    4618:	d9 45 08             	flds   0x8(%ebp)
    461b:	dd 05 d0 b1 01 00    	fldl   0x1b1d0
    4621:	d9 c9                	fxch   %st(1)
    4623:	df e9                	fucomip %st(1),%st
    4625:	dd d8                	fstp   %st(0)
    4627:	76 28                	jbe    4651 <cos+0x128>
    4629:	d9 45 08             	flds   0x8(%ebp)
    462c:	dd 05 c0 b1 01 00    	fldl   0x1b1c0
    4632:	de e1                	fsubp  %st,%st(1)
    4634:	d9 5d e4             	fstps  -0x1c(%ebp)
    4637:	d9 45 e4             	flds   -0x1c(%ebp)
    463a:	83 ec 0c             	sub    $0xc,%esp
    463d:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    4641:	d9 1c 24             	fstps  (%esp)
    4644:	e8 83 00 00 00       	call   46cc <sin>
    4649:	83 c4 10             	add    $0x10,%esp
    464c:	d8 4d f4             	fmuls  -0xc(%ebp)
    464f:	eb 79                	jmp    46ca <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
    4651:	83 ec 08             	sub    $0x8,%esp
    4654:	6a 02                	push   $0x2
    4656:	ff 75 08             	pushl  0x8(%ebp)
    4659:	e8 1e fe ff ff       	call   447c <pow>
    465e:	83 c4 10             	add    $0x10,%esp
    4661:	d9 05 98 b1 01 00    	flds   0x1b198
    4667:	de f9                	fdivrp %st,%st(1)
    4669:	d9 e8                	fld1   
    466b:	de e1                	fsubp  %st,%st(1)
    466d:	d9 5d d8             	fstps  -0x28(%ebp)
    4670:	83 ec 08             	sub    $0x8,%esp
    4673:	6a 04                	push   $0x4
    4675:	ff 75 08             	pushl  0x8(%ebp)
    4678:	e8 ff fd ff ff       	call   447c <pow>
    467d:	83 c4 10             	add    $0x10,%esp
    4680:	d9 05 d8 b1 01 00    	flds   0x1b1d8
    4686:	de f9                	fdivrp %st,%st(1)
    4688:	d8 45 d8             	fadds  -0x28(%ebp)
    468b:	d9 5d d8             	fstps  -0x28(%ebp)
    468e:	83 ec 08             	sub    $0x8,%esp
    4691:	6a 06                	push   $0x6
    4693:	ff 75 08             	pushl  0x8(%ebp)
    4696:	e8 e1 fd ff ff       	call   447c <pow>
    469b:	83 c4 10             	add    $0x10,%esp
    469e:	d9 05 dc b1 01 00    	flds   0x1b1dc
    46a4:	de f9                	fdivrp %st,%st(1)
    46a6:	d8 6d d8             	fsubrs -0x28(%ebp)
    46a9:	d9 5d d8             	fstps  -0x28(%ebp)
    46ac:	83 ec 08             	sub    $0x8,%esp
    46af:	6a 08                	push   $0x8
    46b1:	ff 75 08             	pushl  0x8(%ebp)
    46b4:	e8 c3 fd ff ff       	call   447c <pow>
    46b9:	83 c4 10             	add    $0x10,%esp
    46bc:	d9 05 e0 b1 01 00    	flds   0x1b1e0
    46c2:	de f9                	fdivrp %st,%st(1)
    46c4:	d8 45 d8             	fadds  -0x28(%ebp)
    46c7:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    46ca:	c9                   	leave  
    46cb:	c3                   	ret    

000046cc <sin>:

float sin(float x)
{
    46cc:	55                   	push   %ebp
    46cd:	89 e5                	mov    %esp,%ebp
    46cf:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
    46d2:	d9 e8                	fld1   
    46d4:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
    46d7:	d9 45 08             	flds   0x8(%ebp)
    46da:	dd 05 a0 b1 01 00    	fldl   0x1b1a0
    46e0:	d9 c9                	fxch   %st(1)
    46e2:	df e9                	fucomip %st(1),%st
    46e4:	dd d8                	fstp   %st(0)
    46e6:	77 0f                	ja     46f7 <sin+0x2b>
    46e8:	d9 45 08             	flds   0x8(%ebp)
    46eb:	dd 05 a8 b1 01 00    	fldl   0x1b1a8
    46f1:	df e9                	fucomip %st(1),%st
    46f3:	dd d8                	fstp   %st(0)
    46f5:	76 3c                	jbe    4733 <sin+0x67>
    46f7:	d9 45 08             	flds   0x8(%ebp)
    46fa:	d9 45 08             	flds   0x8(%ebp)
    46fd:	dd 05 a0 b1 01 00    	fldl   0x1b1a0
    4703:	de f9                	fdivrp %st,%st(1)
    4705:	d9 7d e2             	fnstcw -0x1e(%ebp)
    4708:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
    470c:	b4 0c                	mov    $0xc,%ah
    470e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    4712:	d9 6d e0             	fldcw  -0x20(%ebp)
    4715:	db 5d dc             	fistpl -0x24(%ebp)
    4718:	d9 6d e2             	fldcw  -0x1e(%ebp)
    471b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    471e:	01 c0                	add    %eax,%eax
    4720:	89 45 d8             	mov    %eax,-0x28(%ebp)
    4723:	db 45 d8             	fildl  -0x28(%ebp)
    4726:	dd 05 b0 b1 01 00    	fldl   0x1b1b0
    472c:	de c9                	fmulp  %st,%st(1)
    472e:	de e9                	fsubrp %st,%st(1)
    4730:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
    4733:	d9 45 08             	flds   0x8(%ebp)
    4736:	dd 05 b0 b1 01 00    	fldl   0x1b1b0
    473c:	d9 c9                	fxch   %st(1)
    473e:	df e9                	fucomip %st(1),%st
    4740:	dd d8                	fstp   %st(0)
    4742:	76 0e                	jbe    4752 <sin+0x86>
    4744:	d9 45 08             	flds   0x8(%ebp)
    4747:	dd 05 a0 b1 01 00    	fldl   0x1b1a0
    474d:	de e9                	fsubrp %st,%st(1)
    474f:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
    4752:	d9 45 08             	flds   0x8(%ebp)
    4755:	dd 05 b8 b1 01 00    	fldl   0x1b1b8
    475b:	df e9                	fucomip %st(1),%st
    475d:	dd d8                	fstp   %st(0)
    475f:	76 0e                	jbe    476f <sin+0xa3>
    4761:	d9 45 08             	flds   0x8(%ebp)
    4764:	dd 05 a0 b1 01 00    	fldl   0x1b1a0
    476a:	de c1                	faddp  %st,%st(1)
    476c:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
    476f:	d9 45 08             	flds   0x8(%ebp)
    4772:	dd 05 c0 b1 01 00    	fldl   0x1b1c0
    4778:	d9 c9                	fxch   %st(1)
    477a:	df e9                	fucomip %st(1),%st
    477c:	dd d8                	fstp   %st(0)
    477e:	76 16                	jbe    4796 <sin+0xca>
    {
        x -= PI;
    4780:	d9 45 08             	flds   0x8(%ebp)
    4783:	dd 05 b0 b1 01 00    	fldl   0x1b1b0
    4789:	de e9                	fsubrp %st,%st(1)
    478b:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    478e:	d9 45 f4             	flds   -0xc(%ebp)
    4791:	d9 e0                	fchs   
    4793:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
    4796:	d9 45 08             	flds   0x8(%ebp)
    4799:	dd 05 c8 b1 01 00    	fldl   0x1b1c8
    479f:	df e9                	fucomip %st(1),%st
    47a1:	dd d8                	fstp   %st(0)
    47a3:	76 16                	jbe    47bb <sin+0xef>
    {
        x += PI;
    47a5:	d9 45 08             	flds   0x8(%ebp)
    47a8:	dd 05 b0 b1 01 00    	fldl   0x1b1b0
    47ae:	de c1                	faddp  %st,%st(1)
    47b0:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    47b3:	d9 45 f4             	flds   -0xc(%ebp)
    47b6:	d9 e0                	fchs   
    47b8:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
    47bb:	d9 ee                	fldz   
    47bd:	d9 45 08             	flds   0x8(%ebp)
    47c0:	d9 c9                	fxch   %st(1)
    47c2:	df e9                	fucomip %st(1),%st
    47c4:	dd d8                	fstp   %st(0)
    47c6:	76 10                	jbe    47d8 <sin+0x10c>
    {
        x *= -1;
    47c8:	d9 45 08             	flds   0x8(%ebp)
    47cb:	d9 e0                	fchs   
    47cd:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
    47d0:	d9 45 f4             	flds   -0xc(%ebp)
    47d3:	d9 e0                	fchs   
    47d5:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
    47d8:	d9 45 08             	flds   0x8(%ebp)
    47db:	dd 05 d0 b1 01 00    	fldl   0x1b1d0
    47e1:	d9 c9                	fxch   %st(1)
    47e3:	df e9                	fucomip %st(1),%st
    47e5:	dd d8                	fstp   %st(0)
    47e7:	76 28                	jbe    4811 <sin+0x145>
    47e9:	d9 45 08             	flds   0x8(%ebp)
    47ec:	dd 05 c0 b1 01 00    	fldl   0x1b1c0
    47f2:	de e1                	fsubp  %st,%st(1)
    47f4:	d9 5d e4             	fstps  -0x1c(%ebp)
    47f7:	d9 45 e4             	flds   -0x1c(%ebp)
    47fa:	83 ec 0c             	sub    $0xc,%esp
    47fd:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    4801:	d9 1c 24             	fstps  (%esp)
    4804:	e8 20 fd ff ff       	call   4529 <cos>
    4809:	83 c4 10             	add    $0x10,%esp
    480c:	d8 4d f4             	fmuls  -0xc(%ebp)
    480f:	eb 7a                	jmp    488b <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
    4811:	83 ec 08             	sub    $0x8,%esp
    4814:	6a 03                	push   $0x3
    4816:	ff 75 08             	pushl  0x8(%ebp)
    4819:	e8 5e fc ff ff       	call   447c <pow>
    481e:	83 c4 10             	add    $0x10,%esp
    4821:	d9 05 e4 b1 01 00    	flds   0x1b1e4
    4827:	de f9                	fdivrp %st,%st(1)
    4829:	d9 45 08             	flds   0x8(%ebp)
    482c:	de e1                	fsubp  %st,%st(1)
    482e:	d9 5d d8             	fstps  -0x28(%ebp)
    4831:	83 ec 08             	sub    $0x8,%esp
    4834:	6a 05                	push   $0x5
    4836:	ff 75 08             	pushl  0x8(%ebp)
    4839:	e8 3e fc ff ff       	call   447c <pow>
    483e:	83 c4 10             	add    $0x10,%esp
    4841:	d9 05 e8 b1 01 00    	flds   0x1b1e8
    4847:	de f9                	fdivrp %st,%st(1)
    4849:	d8 45 d8             	fadds  -0x28(%ebp)
    484c:	d9 5d d8             	fstps  -0x28(%ebp)
    484f:	83 ec 08             	sub    $0x8,%esp
    4852:	6a 07                	push   $0x7
    4854:	ff 75 08             	pushl  0x8(%ebp)
    4857:	e8 20 fc ff ff       	call   447c <pow>
    485c:	83 c4 10             	add    $0x10,%esp
    485f:	d9 05 ec b1 01 00    	flds   0x1b1ec
    4865:	de f9                	fdivrp %st,%st(1)
    4867:	d8 6d d8             	fsubrs -0x28(%ebp)
    486a:	d9 5d d8             	fstps  -0x28(%ebp)
    486d:	83 ec 08             	sub    $0x8,%esp
    4870:	6a 09                	push   $0x9
    4872:	ff 75 08             	pushl  0x8(%ebp)
    4875:	e8 02 fc ff ff       	call   447c <pow>
    487a:	83 c4 10             	add    $0x10,%esp
    487d:	d9 05 f0 b1 01 00    	flds   0x1b1f0
    4883:	de f9                	fdivrp %st,%st(1)
    4885:	d8 45 d8             	fadds  -0x28(%ebp)
    4888:	d8 4d f4             	fmuls  -0xc(%ebp)
}
    488b:	c9                   	leave  
    488c:	c3                   	ret    

0000488d <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
    488d:	55                   	push   %ebp
    488e:	89 e5                	mov    %esp,%ebp
    4890:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    4893:	83 ec 04             	sub    $0x4,%esp
    4896:	6a 0e                	push   $0xe
    4898:	ff 75 0c             	pushl  0xc(%ebp)
    489b:	ff 75 08             	pushl  0x8(%ebp)
    489e:	e8 44 f6 ff ff       	call   3ee7 <read>
    48a3:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    48a6:	83 ec 04             	sub    $0x4,%esp
    48a9:	6a 28                	push   $0x28
    48ab:	ff 75 10             	pushl  0x10(%ebp)
    48ae:	ff 75 08             	pushl  0x8(%ebp)
    48b1:	e8 31 f6 ff ff       	call   3ee7 <read>
    48b6:	83 c4 10             	add    $0x10,%esp
}
    48b9:	90                   	nop
    48ba:	c9                   	leave  
    48bb:	c3                   	ret    

000048bc <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
    48bc:	55                   	push   %ebp
    48bd:	89 e5                	mov    %esp,%ebp
    48bf:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    48c5:	83 ec 08             	sub    $0x8,%esp
    48c8:	6a 00                	push   $0x0
    48ca:	ff 75 08             	pushl  0x8(%ebp)
    48cd:	e8 3d f6 ff ff       	call   3f0f <open>
    48d2:	83 c4 10             	add    $0x10,%esp
    48d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    48d8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    48dc:	79 0a                	jns    48e8 <readBitmapFile+0x2c>
        return -1;
    48de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    48e3:	e9 6e 01 00 00       	jmp    4a56 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    48e8:	83 ec 04             	sub    $0x4,%esp
    48eb:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    48ee:	50                   	push   %eax
    48ef:	8d 45 ca             	lea    -0x36(%ebp),%eax
    48f2:	50                   	push   %eax
    48f3:	ff 75 ec             	pushl  -0x14(%ebp)
    48f6:	e8 92 ff ff ff       	call   488d <readBitmapHeader>
    48fb:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    48fe:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4901:	83 e8 36             	sub    $0x36,%eax
    4904:	83 ec 04             	sub    $0x4,%esp
    4907:	50                   	push   %eax
    4908:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    490e:	50                   	push   %eax
    490f:	ff 75 ec             	pushl  -0x14(%ebp)
    4912:	e8 d0 f5 ff ff       	call   3ee7 <read>
    4917:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    491a:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    491d:	8b 45 14             	mov    0x14(%ebp),%eax
    4920:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    4922:	8b 55 aa             	mov    -0x56(%ebp),%edx
    4925:	8b 45 10             	mov    0x10(%ebp),%eax
    4928:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    492a:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    492d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    4930:	8b 45 aa             	mov    -0x56(%ebp),%eax
    4933:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    4936:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    493a:	0f b7 c0             	movzwl %ax,%eax
    493d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    4940:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4943:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    4947:	8d 50 07             	lea    0x7(%eax),%edx
    494a:	85 c0                	test   %eax,%eax
    494c:	0f 48 c2             	cmovs  %edx,%eax
    494f:	c1 f8 03             	sar    $0x3,%eax
    4952:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    4955:	8b 45 0c             	mov    0xc(%ebp),%eax
    4958:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    495b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    495e:	83 e8 01             	sub    $0x1,%eax
    4961:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4964:	e9 d0 00 00 00       	jmp    4a39 <readBitmapFile+0x17d>
        if (bits == 32) {
    4969:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    496d:	75 22                	jne    4991 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    496f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4972:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    4976:	89 c2                	mov    %eax,%edx
    4978:	8b 45 d8             	mov    -0x28(%ebp),%eax
    497b:	01 d0                	add    %edx,%eax
    497d:	83 ec 04             	sub    $0x4,%esp
    4980:	ff 75 dc             	pushl  -0x24(%ebp)
    4983:	50                   	push   %eax
    4984:	ff 75 ec             	pushl  -0x14(%ebp)
    4987:	e8 5b f5 ff ff       	call   3ee7 <read>
    498c:	83 c4 10             	add    $0x10,%esp
    498f:	eb 65                	jmp    49f6 <readBitmapFile+0x13a>
        } else {
            int j = 0;
    4991:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    4998:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    499f:	eb 4d                	jmp    49ee <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    49a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49a4:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    49a8:	c1 e0 02             	shl    $0x2,%eax
    49ab:	89 c2                	mov    %eax,%edx
    49ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
    49b0:	c1 e0 02             	shl    $0x2,%eax
    49b3:	01 c2                	add    %eax,%edx
    49b5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    49b8:	01 d0                	add    %edx,%eax
    49ba:	83 ec 04             	sub    $0x4,%esp
    49bd:	6a 03                	push   $0x3
    49bf:	50                   	push   %eax
    49c0:	ff 75 ec             	pushl  -0x14(%ebp)
    49c3:	e8 1f f5 ff ff       	call   3ee7 <read>
    49c8:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    49cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49ce:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    49d2:	c1 e0 02             	shl    $0x2,%eax
    49d5:	89 c2                	mov    %eax,%edx
    49d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    49da:	c1 e0 02             	shl    $0x2,%eax
    49dd:	01 d0                	add    %edx,%eax
    49df:	8d 50 03             	lea    0x3(%eax),%edx
    49e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    49e5:	01 d0                	add    %edx,%eax
    49e7:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    49ea:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    49ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    49f1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    49f4:	7c ab                	jl     49a1 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    49f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    49f9:	99                   	cltd   
    49fa:	c1 ea 1e             	shr    $0x1e,%edx
    49fd:	01 d0                	add    %edx,%eax
    49ff:	83 e0 03             	and    $0x3,%eax
    4a02:	29 d0                	sub    %edx,%eax
    4a04:	85 c0                	test   %eax,%eax
    4a06:	7e 2d                	jle    4a35 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    4a08:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4a0b:	99                   	cltd   
    4a0c:	c1 ea 1e             	shr    $0x1e,%edx
    4a0f:	01 d0                	add    %edx,%eax
    4a11:	83 e0 03             	and    $0x3,%eax
    4a14:	29 d0                	sub    %edx,%eax
    4a16:	ba 04 00 00 00       	mov    $0x4,%edx
    4a1b:	29 c2                	sub    %eax,%edx
    4a1d:	89 d0                	mov    %edx,%eax
    4a1f:	83 ec 04             	sub    $0x4,%esp
    4a22:	50                   	push   %eax
    4a23:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    4a29:	50                   	push   %eax
    4a2a:	ff 75 ec             	pushl  -0x14(%ebp)
    4a2d:	e8 b5 f4 ff ff       	call   3ee7 <read>
    4a32:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    4a35:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    4a39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a3d:	0f 89 26 ff ff ff    	jns    4969 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    4a43:	83 ec 0c             	sub    $0xc,%esp
    4a46:	ff 75 ec             	pushl  -0x14(%ebp)
    4a49:	e8 a9 f4 ff ff       	call   3ef7 <close>
    4a4e:	83 c4 10             	add    $0x10,%esp
    return 0;
    4a51:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4a56:	c9                   	leave  
    4a57:	c3                   	ret    

00004a58 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    4a58:	55                   	push   %ebp
    4a59:	89 e5                	mov    %esp,%ebp
    4a5b:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    4a61:	83 ec 08             	sub    $0x8,%esp
    4a64:	6a 00                	push   $0x0
    4a66:	ff 75 08             	pushl  0x8(%ebp)
    4a69:	e8 a1 f4 ff ff       	call   3f0f <open>
    4a6e:	83 c4 10             	add    $0x10,%esp
    4a71:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    4a74:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    4a78:	79 0a                	jns    4a84 <read24BitmapFile+0x2c>
        return -1;
    4a7a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    4a7f:	e9 66 01 00 00       	jmp    4bea <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    4a84:	83 ec 04             	sub    $0x4,%esp
    4a87:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    4a8a:	50                   	push   %eax
    4a8b:	8d 45 ca             	lea    -0x36(%ebp),%eax
    4a8e:	50                   	push   %eax
    4a8f:	ff 75 ec             	pushl  -0x14(%ebp)
    4a92:	e8 f6 fd ff ff       	call   488d <readBitmapHeader>
    4a97:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    4a9a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4a9d:	83 e8 36             	sub    $0x36,%eax
    4aa0:	83 ec 04             	sub    $0x4,%esp
    4aa3:	50                   	push   %eax
    4aa4:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    4aaa:	50                   	push   %eax
    4aab:	ff 75 ec             	pushl  -0x14(%ebp)
    4aae:	e8 34 f4 ff ff       	call   3ee7 <read>
    4ab3:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    4ab6:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    4ab9:	8b 45 14             	mov    0x14(%ebp),%eax
    4abc:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    4abe:	8b 55 aa             	mov    -0x56(%ebp),%edx
    4ac1:	8b 45 10             	mov    0x10(%ebp),%eax
    4ac4:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    4ac6:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    4ac9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    4acc:	8b 45 aa             	mov    -0x56(%ebp),%eax
    4acf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    4ad2:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    4ad6:	0f b7 c0             	movzwl %ax,%eax
    4ad9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    4adc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4adf:	89 d0                	mov    %edx,%eax
    4ae1:	01 c0                	add    %eax,%eax
    4ae3:	01 d0                	add    %edx,%eax
    4ae5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    4ae8:	8b 45 0c             	mov    0xc(%ebp),%eax
    4aeb:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    4aee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4af1:	83 e8 01             	sub    $0x1,%eax
    4af4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4af7:	e9 d1 00 00 00       	jmp    4bcd <read24BitmapFile+0x175>
        if (bits == 24) {
    4afc:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    4b00:	75 22                	jne    4b24 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    4b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b05:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    4b09:	89 c2                	mov    %eax,%edx
    4b0b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4b0e:	01 d0                	add    %edx,%eax
    4b10:	83 ec 04             	sub    $0x4,%esp
    4b13:	ff 75 dc             	pushl  -0x24(%ebp)
    4b16:	50                   	push   %eax
    4b17:	ff 75 ec             	pushl  -0x14(%ebp)
    4b1a:	e8 c8 f3 ff ff       	call   3ee7 <read>
    4b1f:	83 c4 10             	add    $0x10,%esp
    4b22:	eb 66                	jmp    4b8a <read24BitmapFile+0x132>
        } else {
            int j = 0;
    4b24:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    4b2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4b32:	eb 4e                	jmp    4b82 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    4b34:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b37:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    4b3b:	89 c2                	mov    %eax,%edx
    4b3d:	89 d0                	mov    %edx,%eax
    4b3f:	01 c0                	add    %eax,%eax
    4b41:	01 d0                	add    %edx,%eax
    4b43:	89 c1                	mov    %eax,%ecx
    4b45:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4b48:	89 d0                	mov    %edx,%eax
    4b4a:	01 c0                	add    %eax,%eax
    4b4c:	01 d0                	add    %edx,%eax
    4b4e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    4b51:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4b54:	01 d0                	add    %edx,%eax
    4b56:	83 ec 04             	sub    $0x4,%esp
    4b59:	6a 03                	push   $0x3
    4b5b:	50                   	push   %eax
    4b5c:	ff 75 ec             	pushl  -0x14(%ebp)
    4b5f:	e8 83 f3 ff ff       	call   3ee7 <read>
    4b64:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    4b67:	83 ec 04             	sub    $0x4,%esp
    4b6a:	6a 01                	push   $0x1
    4b6c:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    4b72:	50                   	push   %eax
    4b73:	ff 75 ec             	pushl  -0x14(%ebp)
    4b76:	e8 6c f3 ff ff       	call   3ee7 <read>
    4b7b:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    4b7e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4b82:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b85:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4b88:	7c aa                	jl     4b34 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    4b8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b8d:	99                   	cltd   
    4b8e:	c1 ea 1e             	shr    $0x1e,%edx
    4b91:	01 d0                	add    %edx,%eax
    4b93:	83 e0 03             	and    $0x3,%eax
    4b96:	29 d0                	sub    %edx,%eax
    4b98:	85 c0                	test   %eax,%eax
    4b9a:	7e 2d                	jle    4bc9 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    4b9c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b9f:	99                   	cltd   
    4ba0:	c1 ea 1e             	shr    $0x1e,%edx
    4ba3:	01 d0                	add    %edx,%eax
    4ba5:	83 e0 03             	and    $0x3,%eax
    4ba8:	29 d0                	sub    %edx,%eax
    4baa:	ba 04 00 00 00       	mov    $0x4,%edx
    4baf:	29 c2                	sub    %eax,%edx
    4bb1:	89 d0                	mov    %edx,%eax
    4bb3:	83 ec 04             	sub    $0x4,%esp
    4bb6:	50                   	push   %eax
    4bb7:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    4bbd:	50                   	push   %eax
    4bbe:	ff 75 ec             	pushl  -0x14(%ebp)
    4bc1:	e8 21 f3 ff ff       	call   3ee7 <read>
    4bc6:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    4bc9:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    4bcd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4bd1:	0f 89 25 ff ff ff    	jns    4afc <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    4bd7:	83 ec 0c             	sub    $0xc,%esp
    4bda:	ff 75 ec             	pushl  -0x14(%ebp)
    4bdd:	e8 15 f3 ff ff       	call   3ef7 <close>
    4be2:	83 c4 10             	add    $0x10,%esp
    return 0;
    4be5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4bea:	c9                   	leave  
    4beb:	c3                   	ret    

00004bec <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    4bec:	55                   	push   %ebp
    4bed:	89 e5                	mov    %esp,%ebp
    4bef:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    4bf2:	8b 55 10             	mov    0x10(%ebp),%edx
    4bf5:	89 d0                	mov    %edx,%eax
    4bf7:	01 c0                	add    %eax,%eax
    4bf9:	01 d0                	add    %edx,%eax
    4bfb:	c1 e0 03             	shl    $0x3,%eax
    4bfe:	83 c0 1f             	add    $0x1f,%eax
    4c01:	8d 50 1f             	lea    0x1f(%eax),%edx
    4c04:	85 c0                	test   %eax,%eax
    4c06:	0f 48 c2             	cmovs  %edx,%eax
    4c09:	c1 f8 05             	sar    $0x5,%eax
    4c0c:	c1 e0 02             	shl    $0x2,%eax
    4c0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    4c12:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    4c18:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c1b:	0f af 45 0c          	imul   0xc(%ebp),%eax
    4c1f:	83 c0 36             	add    $0x36,%eax
    4c22:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    4c25:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    4c2b:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    4c31:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    4c38:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    4c3f:	8b 45 10             	mov    0x10(%ebp),%eax
    4c42:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    4c45:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c48:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    4c4b:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    4c51:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    4c57:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    4c5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c61:	0f af 45 0c          	imul   0xc(%ebp),%eax
    4c65:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    4c68:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    4c6f:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    4c76:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    4c7d:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    4c84:	83 ec 04             	sub    $0x4,%esp
    4c87:	6a 0e                	push   $0xe
    4c89:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    4c8c:	50                   	push   %eax
    4c8d:	ff 75 08             	pushl  0x8(%ebp)
    4c90:	e8 5a f2 ff ff       	call   3eef <write>
    4c95:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    4c98:	83 ec 04             	sub    $0x4,%esp
    4c9b:	6a 28                	push   $0x28
    4c9d:	8d 45 be             	lea    -0x42(%ebp),%eax
    4ca0:	50                   	push   %eax
    4ca1:	ff 75 08             	pushl  0x8(%ebp)
    4ca4:	e8 46 f2 ff ff       	call   3eef <write>
    4ca9:	83 c4 10             	add    $0x10,%esp
}
    4cac:	90                   	nop
    4cad:	c9                   	leave  
    4cae:	c3                   	ret    

00004caf <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    4caf:	55                   	push   %ebp
    4cb0:	89 e5                	mov    %esp,%ebp
    4cb2:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    4cb5:	83 ec 08             	sub    $0x8,%esp
    4cb8:	68 02 02 00 00       	push   $0x202
    4cbd:	ff 75 08             	pushl  0x8(%ebp)
    4cc0:	e8 4a f2 ff ff       	call   3f0f <open>
    4cc5:	83 c4 10             	add    $0x10,%esp
    4cc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    4ccb:	8b 55 14             	mov    0x14(%ebp),%edx
    4cce:	89 d0                	mov    %edx,%eax
    4cd0:	01 c0                	add    %eax,%eax
    4cd2:	01 d0                	add    %edx,%eax
    4cd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    4cd7:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    4cdb:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    4cdf:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    4ce3:	83 ec 04             	sub    $0x4,%esp
    4ce6:	ff 75 14             	pushl  0x14(%ebp)
    4ce9:	ff 75 10             	pushl  0x10(%ebp)
    4cec:	ff 75 f0             	pushl  -0x10(%ebp)
    4cef:	e8 f8 fe ff ff       	call   4bec <write24BitmapFileHeader>
    4cf4:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    4cf7:	8b 45 10             	mov    0x10(%ebp),%eax
    4cfa:	83 e8 01             	sub    $0x1,%eax
    4cfd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d00:	eb 66                	jmp    4d68 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    4d02:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d05:	0f af 45 14          	imul   0x14(%ebp),%eax
    4d09:	89 c2                	mov    %eax,%edx
    4d0b:	89 d0                	mov    %edx,%eax
    4d0d:	01 c0                	add    %eax,%eax
    4d0f:	01 c2                	add    %eax,%edx
    4d11:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d14:	01 d0                	add    %edx,%eax
    4d16:	83 ec 04             	sub    $0x4,%esp
    4d19:	ff 75 ec             	pushl  -0x14(%ebp)
    4d1c:	50                   	push   %eax
    4d1d:	ff 75 f0             	pushl  -0x10(%ebp)
    4d20:	e8 ca f1 ff ff       	call   3eef <write>
    4d25:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    4d28:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d2b:	99                   	cltd   
    4d2c:	c1 ea 1e             	shr    $0x1e,%edx
    4d2f:	01 d0                	add    %edx,%eax
    4d31:	83 e0 03             	and    $0x3,%eax
    4d34:	29 d0                	sub    %edx,%eax
    4d36:	85 c0                	test   %eax,%eax
    4d38:	7e 2a                	jle    4d64 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    4d3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d3d:	99                   	cltd   
    4d3e:	c1 ea 1e             	shr    $0x1e,%edx
    4d41:	01 d0                	add    %edx,%eax
    4d43:	83 e0 03             	and    $0x3,%eax
    4d46:	29 d0                	sub    %edx,%eax
    4d48:	ba 04 00 00 00       	mov    $0x4,%edx
    4d4d:	29 c2                	sub    %eax,%edx
    4d4f:	89 d0                	mov    %edx,%eax
    4d51:	83 ec 04             	sub    $0x4,%esp
    4d54:	50                   	push   %eax
    4d55:	8d 45 e9             	lea    -0x17(%ebp),%eax
    4d58:	50                   	push   %eax
    4d59:	ff 75 f0             	pushl  -0x10(%ebp)
    4d5c:	e8 8e f1 ff ff       	call   3eef <write>
    4d61:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    4d64:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    4d68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4d6c:	79 94                	jns    4d02 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    4d6e:	83 ec 0c             	sub    $0xc,%esp
    4d71:	ff 75 f0             	pushl  -0x10(%ebp)
    4d74:	e8 7e f1 ff ff       	call   3ef7 <close>
    4d79:	83 c4 10             	add    $0x10,%esp
    return 0;
    4d7c:	b8 00 00 00 00       	mov    $0x0,%eax
    4d81:	c9                   	leave  
    4d82:	c3                   	ret    

00004d83 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    4d83:	55                   	push   %ebp
    4d84:	89 e5                	mov    %esp,%ebp
    4d86:	57                   	push   %edi
    4d87:	56                   	push   %esi
    4d88:	53                   	push   %ebx
    4d89:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    4d8c:	8b 45 08             	mov    0x8(%ebp),%eax
    4d8f:	8b 50 10             	mov    0x10(%eax),%edx
    4d92:	8b 40 0c             	mov    0xc(%eax),%eax
    4d95:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4d98:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    4d9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4d9e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4da1:	83 c2 1e             	add    $0x1e,%edx
    4da4:	0f af d0             	imul   %eax,%edx
    4da7:	89 d0                	mov    %edx,%eax
    4da9:	01 c0                	add    %eax,%eax
    4dab:	01 d0                	add    %edx,%eax
    4dad:	83 ec 0c             	sub    $0xc,%esp
    4db0:	50                   	push   %eax
    4db1:	e8 93 f5 ff ff       	call   4349 <malloc>
    4db6:	83 c4 10             	add    $0x10,%esp
    4db9:	89 c2                	mov    %eax,%edx
    4dbb:	8b 45 08             	mov    0x8(%ebp),%eax
    4dbe:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    4dc1:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc4:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dc7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4dca:	6b d2 5a             	imul   $0x5a,%edx,%edx
    4dcd:	01 c2                	add    %eax,%edx
    4dcf:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd2:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    4dd5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4dd8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4ddb:	0f af d0             	imul   %eax,%edx
    4dde:	89 d0                	mov    %edx,%eax
    4de0:	01 c0                	add    %eax,%eax
    4de2:	01 d0                	add    %edx,%eax
    4de4:	89 c2                	mov    %eax,%edx
    4de6:	8b 45 08             	mov    0x8(%ebp),%eax
    4de9:	8b 40 18             	mov    0x18(%eax),%eax
    4dec:	83 ec 04             	sub    $0x4,%esp
    4def:	52                   	push   %edx
    4df0:	68 ff 00 00 00       	push   $0xff
    4df5:	50                   	push   %eax
    4df6:	e8 39 ef ff ff       	call   3d34 <memset>
    4dfb:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    4dfe:	8b 45 08             	mov    0x8(%ebp),%eax
    4e01:	8b 78 1c             	mov    0x1c(%eax),%edi
    4e04:	8b 45 08             	mov    0x8(%ebp),%eax
    4e07:	8b 70 14             	mov    0x14(%eax),%esi
    4e0a:	8b 45 08             	mov    0x8(%ebp),%eax
    4e0d:	8b 58 0c             	mov    0xc(%eax),%ebx
    4e10:	8b 45 08             	mov    0x8(%ebp),%eax
    4e13:	8b 48 10             	mov    0x10(%eax),%ecx
    4e16:	8b 45 08             	mov    0x8(%ebp),%eax
    4e19:	8b 50 08             	mov    0x8(%eax),%edx
    4e1c:	8b 45 08             	mov    0x8(%ebp),%eax
    4e1f:	8b 40 04             	mov    0x4(%eax),%eax
    4e22:	83 ec 08             	sub    $0x8,%esp
    4e25:	57                   	push   %edi
    4e26:	56                   	push   %esi
    4e27:	53                   	push   %ebx
    4e28:	51                   	push   %ecx
    4e29:	52                   	push   %edx
    4e2a:	50                   	push   %eax
    4e2b:	e8 3f f1 ff ff       	call   3f6f <createwindow>
    4e30:	83 c4 20             	add    $0x20,%esp
    4e33:	89 c2                	mov    %eax,%edx
    4e35:	8b 45 08             	mov    0x8(%ebp),%eax
    4e38:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    4e3a:	8b 45 08             	mov    0x8(%ebp),%eax
    4e3d:	8b 00                	mov    (%eax),%eax
}
    4e3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
    4e42:	5b                   	pop    %ebx
    4e43:	5e                   	pop    %esi
    4e44:	5f                   	pop    %edi
    4e45:	5d                   	pop    %ebp
    4e46:	c3                   	ret    

00004e47 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    4e47:	55                   	push   %ebp
    4e48:	89 e5                	mov    %esp,%ebp
    4e4a:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    4e4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4e54:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4e5b:	8b 45 08             	mov    0x8(%ebp),%eax
    4e5e:	8b 40 18             	mov    0x18(%eax),%eax
    4e61:	ff 75 1c             	pushl  0x1c(%ebp)
    4e64:	ff 75 18             	pushl  0x18(%ebp)
    4e67:	ff 75 1c             	pushl  0x1c(%ebp)
    4e6a:	ff 75 18             	pushl  0x18(%ebp)
    4e6d:	8b 55 08             	mov    0x8(%ebp),%edx
    4e70:	ff 72 10             	pushl  0x10(%edx)
    4e73:	ff 72 0c             	pushl  0xc(%edx)
    4e76:	ff 75 f4             	pushl  -0xc(%ebp)
    4e79:	ff 75 f0             	pushl  -0x10(%ebp)
    4e7c:	ff 75 14             	pushl  0x14(%ebp)
    4e7f:	ff 75 10             	pushl  0x10(%ebp)
    4e82:	ff 75 0c             	pushl  0xc(%ebp)
    4e85:	50                   	push   %eax
    4e86:	e8 d5 07 00 00       	call   5660 <drawBitmap>
    4e8b:	83 c4 30             	add    $0x30,%esp
    return 0;
    4e8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4e93:	c9                   	leave  
    4e94:	c3                   	ret    

00004e95 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    4e95:	55                   	push   %ebp
    4e96:	89 e5                	mov    %esp,%ebp
    4e98:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    4e9b:	8b 45 08             	mov    0x8(%ebp),%eax
    4e9e:	8b 40 18             	mov    0x18(%eax),%eax
    4ea1:	ff 75 2c             	pushl  0x2c(%ebp)
    4ea4:	ff 75 28             	pushl  0x28(%ebp)
    4ea7:	ff 75 24             	pushl  0x24(%ebp)
    4eaa:	ff 75 20             	pushl  0x20(%ebp)
    4ead:	8b 55 08             	mov    0x8(%ebp),%edx
    4eb0:	ff 72 10             	pushl  0x10(%edx)
    4eb3:	ff 72 0c             	pushl  0xc(%edx)
    4eb6:	ff 75 1c             	pushl  0x1c(%ebp)
    4eb9:	ff 75 18             	pushl  0x18(%ebp)
    4ebc:	ff 75 14             	pushl  0x14(%ebp)
    4ebf:	ff 75 10             	pushl  0x10(%ebp)
    4ec2:	ff 75 0c             	pushl  0xc(%ebp)
    4ec5:	50                   	push   %eax
    4ec6:	e8 95 07 00 00       	call   5660 <drawBitmap>
    4ecb:	83 c4 30             	add    $0x30,%esp
    return 0;
    4ece:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4ed3:	c9                   	leave  
    4ed4:	c3                   	ret    

00004ed5 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    4ed5:	55                   	push   %ebp
    4ed6:	89 e5                	mov    %esp,%ebp
    4ed8:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    4edb:	8b 45 08             	mov    0x8(%ebp),%eax
    4ede:	8b 40 18             	mov    0x18(%eax),%eax
    4ee1:	ff 75 2c             	pushl  0x2c(%ebp)
    4ee4:	ff 75 28             	pushl  0x28(%ebp)
    4ee7:	ff 75 24             	pushl  0x24(%ebp)
    4eea:	ff 75 20             	pushl  0x20(%ebp)
    4eed:	8b 55 08             	mov    0x8(%ebp),%edx
    4ef0:	ff 72 10             	pushl  0x10(%edx)
    4ef3:	ff 72 0c             	pushl  0xc(%edx)
    4ef6:	ff 75 1c             	pushl  0x1c(%ebp)
    4ef9:	ff 75 18             	pushl  0x18(%ebp)
    4efc:	ff 75 14             	pushl  0x14(%ebp)
    4eff:	ff 75 10             	pushl  0x10(%ebp)
    4f02:	ff 75 0c             	pushl  0xc(%ebp)
    4f05:	50                   	push   %eax
    4f06:	e8 75 08 00 00       	call   5780 <drawTransparentBitmap>
    4f0b:	83 c4 30             	add    $0x30,%esp
    return 0;
    4f0e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4f13:	c9                   	leave  
    4f14:	c3                   	ret    

00004f15 <api_repaint>:

int api_repaint(Window* wnd)
{
    4f15:	55                   	push   %ebp
    4f16:	89 e5                	mov    %esp,%ebp
    4f18:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    4f1b:	8b 45 08             	mov    0x8(%ebp),%eax
    4f1e:	8b 00                	mov    (%eax),%eax
    4f20:	83 ec 0c             	sub    $0xc,%esp
    4f23:	50                   	push   %eax
    4f24:	e8 4e f0 ff ff       	call   3f77 <repaintwindow>
    4f29:	83 c4 10             	add    $0x10,%esp
    return 0;
    4f2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4f31:	c9                   	leave  
    4f32:	c3                   	ret    

00004f33 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    4f33:	55                   	push   %ebp
    4f34:	89 e5                	mov    %esp,%ebp
    4f36:	56                   	push   %esi
    4f37:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    4f38:	8b 75 18             	mov    0x18(%ebp),%esi
    4f3b:	8b 5d 14             	mov    0x14(%ebp),%ebx
    4f3e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    4f41:	8b 55 0c             	mov    0xc(%ebp),%edx
    4f44:	8b 45 08             	mov    0x8(%ebp),%eax
    4f47:	8b 00                	mov    (%eax),%eax
    4f49:	83 ec 0c             	sub    $0xc,%esp
    4f4c:	56                   	push   %esi
    4f4d:	53                   	push   %ebx
    4f4e:	51                   	push   %ecx
    4f4f:	52                   	push   %edx
    4f50:	50                   	push   %eax
    4f51:	e8 39 f0 ff ff       	call   3f8f <updatewindow>
    4f56:	83 c4 20             	add    $0x20,%esp
    return 0;
    4f59:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4f5e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4f61:	5b                   	pop    %ebx
    4f62:	5e                   	pop    %esi
    4f63:	5d                   	pop    %ebp
    4f64:	c3                   	ret    

00004f65 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    4f65:	55                   	push   %ebp
    4f66:	89 e5                	mov    %esp,%ebp
    4f68:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    4f6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    4f72:	8b 45 08             	mov    0x8(%ebp),%eax
    4f75:	8b 00                	mov    (%eax),%eax
    4f77:	83 ec 08             	sub    $0x8,%esp
    4f7a:	8d 55 c8             	lea    -0x38(%ebp),%edx
    4f7d:	52                   	push   %edx
    4f7e:	50                   	push   %eax
    4f7f:	e8 fb ef ff ff       	call   3f7f <getmessage>
    4f84:	83 c4 10             	add    $0x10,%esp
    4f87:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    4f8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4f8e:	74 e2                	je     4f72 <api_exec+0xd>
        {
            pf(&msg);
    4f90:	83 ec 0c             	sub    $0xc,%esp
    4f93:	8d 45 c8             	lea    -0x38(%ebp),%eax
    4f96:	50                   	push   %eax
    4f97:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f9a:	ff d0                	call   *%eax
    4f9c:	83 c4 10             	add    $0x10,%esp
        }
    }
    4f9f:	eb d1                	jmp    4f72 <api_exec+0xd>

00004fa1 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    4fa1:	55                   	push   %ebp
    4fa2:	89 e5                	mov    %esp,%ebp
    4fa4:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    4fa7:	8b 45 08             	mov    0x8(%ebp),%eax
    4faa:	8b 00                	mov    (%eax),%eax
    4fac:	83 ec 08             	sub    $0x8,%esp
    4faf:	ff 75 0c             	pushl  0xc(%ebp)
    4fb2:	50                   	push   %eax
    4fb3:	e8 cf ef ff ff       	call   3f87 <settimer>
    4fb8:	83 c4 10             	add    $0x10,%esp
    return 0;
    4fbb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4fc0:	c9                   	leave  
    4fc1:	c3                   	ret    

00004fc2 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    4fc2:	55                   	push   %ebp
    4fc3:	89 e5                	mov    %esp,%ebp
    4fc5:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    4fc8:	8b 45 08             	mov    0x8(%ebp),%eax
    4fcb:	8b 50 18             	mov    0x18(%eax),%edx
    4fce:	ff 75 18             	pushl  0x18(%ebp)
    4fd1:	ff 75 14             	pushl  0x14(%ebp)
    4fd4:	83 ec 04             	sub    $0x4,%esp
    4fd7:	89 e0                	mov    %esp,%eax
    4fd9:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    4fdd:	66 89 08             	mov    %cx,(%eax)
    4fe0:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    4fe4:	88 48 02             	mov    %cl,0x2(%eax)
    4fe7:	8b 45 08             	mov    0x8(%ebp),%eax
    4fea:	ff 70 10             	pushl  0x10(%eax)
    4fed:	ff 70 0c             	pushl  0xc(%eax)
    4ff0:	ff 75 10             	pushl  0x10(%ebp)
    4ff3:	ff 75 0c             	pushl  0xc(%ebp)
    4ff6:	52                   	push   %edx
    4ff7:	e8 6f 04 00 00       	call   546b <drawRect>
    4ffc:	83 c4 20             	add    $0x20,%esp
    return 0;
    4fff:	b8 00 00 00 00       	mov    $0x0,%eax
}
    5004:	c9                   	leave  
    5005:	c3                   	ret    

00005006 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    5006:	55                   	push   %ebp
    5007:	89 e5                	mov    %esp,%ebp
    5009:	83 ec 28             	sub    $0x28,%esp
    500c:	8b 45 14             	mov    0x14(%ebp),%eax
    500f:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    5012:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    5016:	8b 45 0c             	mov    0xc(%ebp),%eax
    5019:	89 45 f0             	mov    %eax,-0x10(%ebp)
    501c:	8b 45 10             	mov    0x10(%ebp),%eax
    501f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5022:	8b 45 08             	mov    0x8(%ebp),%eax
    5025:	8b 40 18             	mov    0x18(%eax),%eax
    5028:	83 ec 04             	sub    $0x4,%esp
    502b:	ff 75 18             	pushl  0x18(%ebp)
    502e:	52                   	push   %edx
    502f:	8b 55 08             	mov    0x8(%ebp),%edx
    5032:	ff 72 10             	pushl  0x10(%edx)
    5035:	ff 72 0c             	pushl  0xc(%edx)
    5038:	ff 75 f4             	pushl  -0xc(%ebp)
    503b:	ff 75 f0             	pushl  -0x10(%ebp)
    503e:	50                   	push   %eax
    503f:	e8 d4 02 00 00       	call   5318 <drawCharacter>
    5044:	83 c4 20             	add    $0x20,%esp
    return 0;
    5047:	b8 00 00 00 00       	mov    $0x0,%eax
}
    504c:	c9                   	leave  
    504d:	c3                   	ret    

0000504e <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    504e:	55                   	push   %ebp
    504f:	89 e5                	mov    %esp,%ebp
    5051:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    5054:	8b 45 0c             	mov    0xc(%ebp),%eax
    5057:	89 45 f0             	mov    %eax,-0x10(%ebp)
    505a:	8b 45 10             	mov    0x10(%ebp),%eax
    505d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5060:	8b 45 08             	mov    0x8(%ebp),%eax
    5063:	8b 40 18             	mov    0x18(%eax),%eax
    5066:	83 ec 04             	sub    $0x4,%esp
    5069:	ff 75 18             	pushl  0x18(%ebp)
    506c:	ff 75 14             	pushl  0x14(%ebp)
    506f:	8b 55 08             	mov    0x8(%ebp),%edx
    5072:	ff 72 10             	pushl  0x10(%edx)
    5075:	ff 72 0c             	pushl  0xc(%edx)
    5078:	ff 75 f4             	pushl  -0xc(%ebp)
    507b:	ff 75 f0             	pushl  -0x10(%ebp)
    507e:	50                   	push   %eax
    507f:	e8 8e 03 00 00       	call   5412 <drawString>
    5084:	83 c4 20             	add    $0x20,%esp
    return 0;
    5087:	b8 00 00 00 00       	mov    $0x0,%eax
}
    508c:	c9                   	leave  
    508d:	c3                   	ret    

0000508e <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    508e:	55                   	push   %ebp
    508f:	89 e5                	mov    %esp,%ebp
    5091:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    5094:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    5098:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    509c:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    50a0:	83 ec 08             	sub    $0x8,%esp
    50a3:	83 ec 04             	sub    $0x4,%esp
    50a6:	89 e0                	mov    %esp,%eax
    50a8:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    50ac:	66 89 10             	mov    %dx,(%eax)
    50af:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    50b3:	88 50 02             	mov    %dl,0x2(%eax)
    50b6:	ff 75 18             	pushl  0x18(%ebp)
    50b9:	ff 75 14             	pushl  0x14(%ebp)
    50bc:	ff 75 10             	pushl  0x10(%ebp)
    50bf:	ff 75 0c             	pushl  0xc(%ebp)
    50c2:	ff 75 08             	pushl  0x8(%ebp)
    50c5:	e8 f8 fe ff ff       	call   4fc2 <api_drawRect>
    50ca:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    50cd:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    50d1:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    50d5:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    50d9:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    50dd:	8b 45 10             	mov    0x10(%ebp),%eax
    50e0:	8d 50 0a             	lea    0xa(%eax),%edx
    50e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    50e6:	83 c0 0a             	add    $0xa,%eax
    50e9:	83 ec 0c             	sub    $0xc,%esp
    50ec:	ff 75 f4             	pushl  -0xc(%ebp)
    50ef:	ff 75 1c             	pushl  0x1c(%ebp)
    50f2:	52                   	push   %edx
    50f3:	50                   	push   %eax
    50f4:	ff 75 08             	pushl  0x8(%ebp)
    50f7:	e8 52 ff ff ff       	call   504e <api_drawString>
    50fc:	83 c4 20             	add    $0x20,%esp
    return 0;
    50ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
    5104:	c9                   	leave  
    5105:	c3                   	ret    

00005106 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    5106:	55                   	push   %ebp
    5107:	89 e5                	mov    %esp,%ebp
    5109:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    510c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5113:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    511a:	8b 45 08             	mov    0x8(%ebp),%eax
    511d:	8b 40 18             	mov    0x18(%eax),%eax
    5120:	ff 75 1c             	pushl  0x1c(%ebp)
    5123:	ff 75 18             	pushl  0x18(%ebp)
    5126:	ff 75 1c             	pushl  0x1c(%ebp)
    5129:	ff 75 18             	pushl  0x18(%ebp)
    512c:	8b 55 08             	mov    0x8(%ebp),%edx
    512f:	ff 72 10             	pushl  0x10(%edx)
    5132:	ff 72 0c             	pushl  0xc(%edx)
    5135:	ff 75 f4             	pushl  -0xc(%ebp)
    5138:	ff 75 f0             	pushl  -0x10(%ebp)
    513b:	ff 75 14             	pushl  0x14(%ebp)
    513e:	ff 75 10             	pushl  0x10(%ebp)
    5141:	ff 75 0c             	pushl  0xc(%ebp)
    5144:	50                   	push   %eax
    5145:	e8 16 05 00 00       	call   5660 <drawBitmap>
    514a:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    514d:	8b 45 08             	mov    0x8(%ebp),%eax
    5150:	8b 40 18             	mov    0x18(%eax),%eax
    5153:	ff 75 28             	pushl  0x28(%ebp)
    5156:	ff 75 1c             	pushl  0x1c(%ebp)
    5159:	ff 75 18             	pushl  0x18(%ebp)
    515c:	8b 55 08             	mov    0x8(%ebp),%edx
    515f:	ff 72 10             	pushl  0x10(%edx)
    5162:	ff 72 0c             	pushl  0xc(%edx)
    5165:	ff 75 14             	pushl  0x14(%ebp)
    5168:	ff 75 10             	pushl  0x10(%ebp)
    516b:	50                   	push   %eax
    516c:	e8 99 07 00 00       	call   590a <colorShift>
    5171:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    5174:	8b 45 08             	mov    0x8(%ebp),%eax
    5177:	8b 50 18             	mov    0x18(%eax),%edx
    517a:	83 ec 0c             	sub    $0xc,%esp
    517d:	ff 75 20             	pushl  0x20(%ebp)
    5180:	ff 75 1c             	pushl  0x1c(%ebp)
    5183:	ff 75 18             	pushl  0x18(%ebp)
    5186:	83 ec 04             	sub    $0x4,%esp
    5189:	89 e0                	mov    %esp,%eax
    518b:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    518f:	66 89 08             	mov    %cx,(%eax)
    5192:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    5196:	88 48 02             	mov    %cl,0x2(%eax)
    5199:	8b 45 08             	mov    0x8(%ebp),%eax
    519c:	ff 70 10             	pushl  0x10(%eax)
    519f:	ff 70 0c             	pushl  0xc(%eax)
    51a2:	ff 75 14             	pushl  0x14(%ebp)
    51a5:	ff 75 10             	pushl  0x10(%ebp)
    51a8:	52                   	push   %edx
    51a9:	e8 6d 03 00 00       	call   551b <drawBorder>
    51ae:	83 c4 30             	add    $0x30,%esp
    return 0;
    51b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    51b6:	c9                   	leave  
    51b7:	c3                   	ret    

000051b8 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    51b8:	55                   	push   %ebp
    51b9:	89 e5                	mov    %esp,%ebp
    51bb:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    51be:	8b 45 08             	mov    0x8(%ebp),%eax
    51c1:	8b 00                	mov    (%eax),%eax
    51c3:	83 ec 0c             	sub    $0xc,%esp
    51c6:	50                   	push   %eax
    51c7:	e8 cb ed ff ff       	call   3f97 <destroywindow>
    51cc:	83 c4 10             	add    $0x10,%esp
    return 0;
    51cf:	b8 00 00 00 00       	mov    $0x0,%eax
    51d4:	c9                   	leave  
    51d5:	c3                   	ret    

000051d6 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    51d6:	55                   	push   %ebp
    51d7:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    51d9:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    51dd:	8b 45 08             	mov    0x8(%ebp),%eax
    51e0:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    51e3:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    51e7:	8b 45 08             	mov    0x8(%ebp),%eax
    51ea:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    51ed:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    51f1:	8b 45 08             	mov    0x8(%ebp),%eax
    51f4:	88 10                	mov    %dl,(%eax)
}
    51f6:	90                   	nop
    51f7:	5d                   	pop    %ebp
    51f8:	c3                   	ret    

000051f9 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    51f9:	55                   	push   %ebp
    51fa:	89 e5                	mov    %esp,%ebp
    51fc:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    51ff:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    5203:	3c ff                	cmp    $0xff,%al
    5205:	75 22                	jne    5229 <drawPointAlpha+0x30>
        color->R = origin.R;
    5207:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    520b:	8b 45 08             	mov    0x8(%ebp),%eax
    520e:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    5211:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    5215:	8b 45 08             	mov    0x8(%ebp),%eax
    5218:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    521b:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    521f:	8b 45 08             	mov    0x8(%ebp),%eax
    5222:	88 10                	mov    %dl,(%eax)
        return;
    5224:	e9 ed 00 00 00       	jmp    5316 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    5229:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    522d:	84 c0                	test   %al,%al
    522f:	0f 84 e0 00 00 00    	je     5315 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    5235:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    5239:	0f b6 c0             	movzbl %al,%eax
    523c:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    5240:	df 45 e4             	fild   -0x1c(%ebp)
    5243:	d9 05 40 f0 01 00    	flds   0x1f040
    5249:	de f9                	fdivrp %st,%st(1)
    524b:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    524e:	8b 45 08             	mov    0x8(%ebp),%eax
    5251:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5255:	0f b6 c0             	movzbl %al,%eax
    5258:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    525b:	db 45 e4             	fildl  -0x1c(%ebp)
    525e:	d9 e8                	fld1   
    5260:	d8 65 fc             	fsubs  -0x4(%ebp)
    5263:	de c9                	fmulp  %st,%st(1)
    5265:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    5269:	0f b6 c0             	movzbl %al,%eax
    526c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    526f:	db 45 e4             	fildl  -0x1c(%ebp)
    5272:	d8 4d fc             	fmuls  -0x4(%ebp)
    5275:	de c1                	faddp  %st,%st(1)
    5277:	d9 7d ee             	fnstcw -0x12(%ebp)
    527a:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    527e:	b4 0c                	mov    $0xc,%ah
    5280:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    5284:	d9 6d ec             	fldcw  -0x14(%ebp)
    5287:	df 5d ea             	fistp  -0x16(%ebp)
    528a:	d9 6d ee             	fldcw  -0x12(%ebp)
    528d:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    5291:	89 c2                	mov    %eax,%edx
    5293:	8b 45 08             	mov    0x8(%ebp),%eax
    5296:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    5299:	8b 45 08             	mov    0x8(%ebp),%eax
    529c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    52a0:	0f b6 c0             	movzbl %al,%eax
    52a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    52a6:	db 45 e4             	fildl  -0x1c(%ebp)
    52a9:	d9 e8                	fld1   
    52ab:	d8 65 fc             	fsubs  -0x4(%ebp)
    52ae:	de c9                	fmulp  %st,%st(1)
    52b0:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    52b4:	0f b6 c0             	movzbl %al,%eax
    52b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    52ba:	db 45 e4             	fildl  -0x1c(%ebp)
    52bd:	d8 4d fc             	fmuls  -0x4(%ebp)
    52c0:	de c1                	faddp  %st,%st(1)
    52c2:	d9 6d ec             	fldcw  -0x14(%ebp)
    52c5:	df 5d ea             	fistp  -0x16(%ebp)
    52c8:	d9 6d ee             	fldcw  -0x12(%ebp)
    52cb:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    52cf:	89 c2                	mov    %eax,%edx
    52d1:	8b 45 08             	mov    0x8(%ebp),%eax
    52d4:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    52d7:	8b 45 08             	mov    0x8(%ebp),%eax
    52da:	0f b6 00             	movzbl (%eax),%eax
    52dd:	0f b6 c0             	movzbl %al,%eax
    52e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    52e3:	db 45 e4             	fildl  -0x1c(%ebp)
    52e6:	d9 e8                	fld1   
    52e8:	d8 65 fc             	fsubs  -0x4(%ebp)
    52eb:	de c9                	fmulp  %st,%st(1)
    52ed:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    52f1:	0f b6 c0             	movzbl %al,%eax
    52f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    52f7:	db 45 e4             	fildl  -0x1c(%ebp)
    52fa:	d8 4d fc             	fmuls  -0x4(%ebp)
    52fd:	de c1                	faddp  %st,%st(1)
    52ff:	d9 6d ec             	fldcw  -0x14(%ebp)
    5302:	df 5d ea             	fistp  -0x16(%ebp)
    5305:	d9 6d ee             	fldcw  -0x12(%ebp)
    5308:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    530c:	89 c2                	mov    %eax,%edx
    530e:	8b 45 08             	mov    0x8(%ebp),%eax
    5311:	88 10                	mov    %dl,(%eax)
    5313:	eb 01                	jmp    5316 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    5315:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    5316:	c9                   	leave  
    5317:	c3                   	ret    

00005318 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    5318:	55                   	push   %ebp
    5319:	89 e5                	mov    %esp,%ebp
    531b:	83 ec 14             	sub    $0x14,%esp
    531e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    5321:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    5324:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    5328:	83 e8 20             	sub    $0x20,%eax
    532b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    532e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5332:	0f 88 d7 00 00 00    	js     540f <drawCharacter+0xf7>
    5338:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    533c:	0f 8f cd 00 00 00    	jg     540f <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    5342:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    5349:	e9 b5 00 00 00       	jmp    5403 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    534e:	8b 55 10             	mov    0x10(%ebp),%edx
    5351:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5354:	01 c2                	add    %eax,%edx
    5356:	8b 45 14             	mov    0x14(%ebp),%eax
    5359:	39 c2                	cmp    %eax,%edx
    535b:	0f 8f af 00 00 00    	jg     5410 <drawCharacter+0xf8>
    5361:	8b 55 10             	mov    0x10(%ebp),%edx
    5364:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5367:	01 d0                	add    %edx,%eax
    5369:	85 c0                	test   %eax,%eax
    536b:	0f 88 9f 00 00 00    	js     5410 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    5371:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5378:	eb 7b                	jmp    53f5 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    537a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    537d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    5380:	89 d0                	mov    %edx,%eax
    5382:	c1 e0 03             	shl    $0x3,%eax
    5385:	01 d0                	add    %edx,%eax
    5387:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    538d:	01 c2                	add    %eax,%edx
    538f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5392:	01 d0                	add    %edx,%eax
    5394:	05 20 b4 01 00       	add    $0x1b420,%eax
    5399:	0f b6 00             	movzbl (%eax),%eax
    539c:	3c 01                	cmp    $0x1,%al
    539e:	75 51                	jne    53f1 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    53a0:	8b 55 0c             	mov    0xc(%ebp),%edx
    53a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    53a6:	01 c2                	add    %eax,%edx
    53a8:	8b 45 18             	mov    0x18(%ebp),%eax
    53ab:	39 c2                	cmp    %eax,%edx
    53ad:	7f 50                	jg     53ff <drawCharacter+0xe7>
    53af:	8b 55 0c             	mov    0xc(%ebp),%edx
    53b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    53b5:	01 d0                	add    %edx,%eax
    53b7:	85 c0                	test   %eax,%eax
    53b9:	78 44                	js     53ff <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    53bb:	8b 55 10             	mov    0x10(%ebp),%edx
    53be:	8b 45 fc             	mov    -0x4(%ebp),%eax
    53c1:	01 c2                	add    %eax,%edx
    53c3:	8b 45 18             	mov    0x18(%ebp),%eax
    53c6:	0f af c2             	imul   %edx,%eax
    53c9:	89 c2                	mov    %eax,%edx
    53cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    53ce:	01 c2                	add    %eax,%edx
    53d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    53d3:	01 c2                	add    %eax,%edx
    53d5:	89 d0                	mov    %edx,%eax
    53d7:	01 c0                	add    %eax,%eax
    53d9:	01 c2                	add    %eax,%edx
    53db:	8b 45 08             	mov    0x8(%ebp),%eax
    53de:	01 d0                	add    %edx,%eax
    53e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    53e3:	ff 75 20             	pushl  0x20(%ebp)
    53e6:	ff 75 f0             	pushl  -0x10(%ebp)
    53e9:	e8 0b fe ff ff       	call   51f9 <drawPointAlpha>
    53ee:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    53f1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    53f5:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    53f9:	0f 8e 7b ff ff ff    	jle    537a <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    53ff:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    5403:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    5407:	0f 8e 41 ff ff ff    	jle    534e <drawCharacter+0x36>
    540d:	eb 01                	jmp    5410 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    540f:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    5410:	c9                   	leave  
    5411:	c3                   	ret    

00005412 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    5412:	55                   	push   %ebp
    5413:	89 e5                	mov    %esp,%ebp
    5415:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    5418:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    541f:	eb 3d                	jmp    545e <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    5421:	8b 45 1c             	mov    0x1c(%ebp),%eax
    5424:	0f b6 00             	movzbl (%eax),%eax
    5427:	0f be c0             	movsbl %al,%eax
    542a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    542d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    5430:	01 ca                	add    %ecx,%edx
    5432:	89 55 f4             	mov    %edx,-0xc(%ebp)
    5435:	8b 55 10             	mov    0x10(%ebp),%edx
    5438:	89 55 f8             	mov    %edx,-0x8(%ebp)
    543b:	ff 75 20             	pushl  0x20(%ebp)
    543e:	50                   	push   %eax
    543f:	ff 75 18             	pushl  0x18(%ebp)
    5442:	ff 75 14             	pushl  0x14(%ebp)
    5445:	ff 75 f8             	pushl  -0x8(%ebp)
    5448:	ff 75 f4             	pushl  -0xc(%ebp)
    544b:	ff 75 08             	pushl  0x8(%ebp)
    544e:	e8 c5 fe ff ff       	call   5318 <drawCharacter>
    5453:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    5456:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    545a:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    545e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    5461:	0f b6 00             	movzbl (%eax),%eax
    5464:	84 c0                	test   %al,%al
    5466:	75 b9                	jne    5421 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    5468:	90                   	nop
    5469:	c9                   	leave  
    546a:	c3                   	ret    

0000546b <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    546b:	55                   	push   %ebp
    546c:	89 e5                	mov    %esp,%ebp
    546e:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    5471:	8b 45 20             	mov    0x20(%ebp),%eax
    5474:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    5477:	8b 45 24             	mov    0x24(%ebp),%eax
    547a:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    547d:	8b 55 14             	mov    0x14(%ebp),%edx
    5480:	8b 45 10             	mov    0x10(%ebp),%eax
    5483:	29 c2                	sub    %eax,%edx
    5485:	89 d0                	mov    %edx,%eax
    5487:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    548a:	7d 0d                	jge    5499 <drawRect+0x2e>
        draw_h = s.h - p.y;
    548c:	8b 55 14             	mov    0x14(%ebp),%edx
    548f:	8b 45 10             	mov    0x10(%ebp),%eax
    5492:	29 c2                	sub    %eax,%edx
    5494:	89 d0                	mov    %edx,%eax
    5496:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    5499:	8b 55 18             	mov    0x18(%ebp),%edx
    549c:	8b 45 0c             	mov    0xc(%ebp),%eax
    549f:	29 c2                	sub    %eax,%edx
    54a1:	89 d0                	mov    %edx,%eax
    54a3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    54a6:	7d 0d                	jge    54b5 <drawRect+0x4a>
        draw_w = s.w - p.x;
    54a8:	8b 55 18             	mov    0x18(%ebp),%edx
    54ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    54ae:	29 c2                	sub    %eax,%edx
    54b0:	89 d0                	mov    %edx,%eax
    54b2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    54b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    54bc:	eb 52                	jmp    5510 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    54be:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    54c5:	eb 3d                	jmp    5504 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    54c7:	8b 55 10             	mov    0x10(%ebp),%edx
    54ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    54cd:	01 c2                	add    %eax,%edx
    54cf:	8b 45 18             	mov    0x18(%ebp),%eax
    54d2:	0f af c2             	imul   %edx,%eax
    54d5:	89 c2                	mov    %eax,%edx
    54d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    54da:	01 c2                	add    %eax,%edx
    54dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    54df:	01 c2                	add    %eax,%edx
    54e1:	89 d0                	mov    %edx,%eax
    54e3:	01 c0                	add    %eax,%eax
    54e5:	01 c2                	add    %eax,%edx
    54e7:	8b 45 08             	mov    0x8(%ebp),%eax
    54ea:	01 d0                	add    %edx,%eax
    54ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    54ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
    54f2:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    54f6:	66 89 10             	mov    %dx,(%eax)
    54f9:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    54fd:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    5500:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5504:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5507:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    550a:	7c bb                	jl     54c7 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    550c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5510:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5513:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    5516:	7c a6                	jl     54be <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    5518:	90                   	nop
    5519:	c9                   	leave  
    551a:	c3                   	ret    

0000551b <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    551b:	55                   	push   %ebp
    551c:	89 e5                	mov    %esp,%ebp
    551e:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    5521:	8b 45 28             	mov    0x28(%ebp),%eax
    5524:	89 45 c8             	mov    %eax,-0x38(%ebp)
    5527:	8b 45 24             	mov    0x24(%ebp),%eax
    552a:	89 45 cc             	mov    %eax,-0x34(%ebp)
    552d:	ff 75 cc             	pushl  -0x34(%ebp)
    5530:	ff 75 c8             	pushl  -0x38(%ebp)
    5533:	83 ec 04             	sub    $0x4,%esp
    5536:	89 e0                	mov    %esp,%eax
    5538:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    553c:	66 89 10             	mov    %dx,(%eax)
    553f:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    5543:	88 50 02             	mov    %dl,0x2(%eax)
    5546:	ff 75 18             	pushl  0x18(%ebp)
    5549:	ff 75 14             	pushl  0x14(%ebp)
    554c:	ff 75 10             	pushl  0x10(%ebp)
    554f:	ff 75 0c             	pushl  0xc(%ebp)
    5552:	ff 75 08             	pushl  0x8(%ebp)
    5555:	e8 11 ff ff ff       	call   546b <drawRect>
    555a:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    555d:	8b 45 28             	mov    0x28(%ebp),%eax
    5560:	89 45 d0             	mov    %eax,-0x30(%ebp)
    5563:	8b 45 24             	mov    0x24(%ebp),%eax
    5566:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    5569:	8b 45 0c             	mov    0xc(%ebp),%eax
    556c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    556f:	8b 55 10             	mov    0x10(%ebp),%edx
    5572:	8b 45 20             	mov    0x20(%ebp),%eax
    5575:	01 d0                	add    %edx,%eax
    5577:	2b 45 28             	sub    0x28(%ebp),%eax
    557a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    557d:	ff 75 d4             	pushl  -0x2c(%ebp)
    5580:	ff 75 d0             	pushl  -0x30(%ebp)
    5583:	83 ec 04             	sub    $0x4,%esp
    5586:	89 e0                	mov    %esp,%eax
    5588:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    558c:	66 89 10             	mov    %dx,(%eax)
    558f:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    5593:	88 50 02             	mov    %dl,0x2(%eax)
    5596:	ff 75 18             	pushl  0x18(%ebp)
    5599:	ff 75 14             	pushl  0x14(%ebp)
    559c:	ff 75 dc             	pushl  -0x24(%ebp)
    559f:	ff 75 d8             	pushl  -0x28(%ebp)
    55a2:	ff 75 08             	pushl  0x8(%ebp)
    55a5:	e8 c1 fe ff ff       	call   546b <drawRect>
    55aa:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    55ad:	8b 45 20             	mov    0x20(%ebp),%eax
    55b0:	8b 55 28             	mov    0x28(%ebp),%edx
    55b3:	01 d2                	add    %edx,%edx
    55b5:	29 d0                	sub    %edx,%eax
    55b7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    55ba:	8b 45 28             	mov    0x28(%ebp),%eax
    55bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    55c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    55c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    55c6:	8b 55 10             	mov    0x10(%ebp),%edx
    55c9:	8b 45 28             	mov    0x28(%ebp),%eax
    55cc:	01 d0                	add    %edx,%eax
    55ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
    55d1:	ff 75 e4             	pushl  -0x1c(%ebp)
    55d4:	ff 75 e0             	pushl  -0x20(%ebp)
    55d7:	83 ec 04             	sub    $0x4,%esp
    55da:	89 e0                	mov    %esp,%eax
    55dc:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    55e0:	66 89 10             	mov    %dx,(%eax)
    55e3:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    55e7:	88 50 02             	mov    %dl,0x2(%eax)
    55ea:	ff 75 18             	pushl  0x18(%ebp)
    55ed:	ff 75 14             	pushl  0x14(%ebp)
    55f0:	ff 75 ec             	pushl  -0x14(%ebp)
    55f3:	ff 75 e8             	pushl  -0x18(%ebp)
    55f6:	ff 75 08             	pushl  0x8(%ebp)
    55f9:	e8 6d fe ff ff       	call   546b <drawRect>
    55fe:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    5601:	8b 45 20             	mov    0x20(%ebp),%eax
    5604:	8b 55 28             	mov    0x28(%ebp),%edx
    5607:	01 d2                	add    %edx,%edx
    5609:	29 d0                	sub    %edx,%eax
    560b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    560e:	8b 45 28             	mov    0x28(%ebp),%eax
    5611:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5614:	8b 55 0c             	mov    0xc(%ebp),%edx
    5617:	8b 45 24             	mov    0x24(%ebp),%eax
    561a:	01 d0                	add    %edx,%eax
    561c:	2b 45 28             	sub    0x28(%ebp),%eax
    561f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    5622:	8b 55 10             	mov    0x10(%ebp),%edx
    5625:	8b 45 28             	mov    0x28(%ebp),%eax
    5628:	01 d0                	add    %edx,%eax
    562a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    562d:	ff 75 f4             	pushl  -0xc(%ebp)
    5630:	ff 75 f0             	pushl  -0x10(%ebp)
    5633:	83 ec 04             	sub    $0x4,%esp
    5636:	89 e0                	mov    %esp,%eax
    5638:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    563c:	66 89 10             	mov    %dx,(%eax)
    563f:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    5643:	88 50 02             	mov    %dl,0x2(%eax)
    5646:	ff 75 18             	pushl  0x18(%ebp)
    5649:	ff 75 14             	pushl  0x14(%ebp)
    564c:	ff 75 fc             	pushl  -0x4(%ebp)
    564f:	ff 75 f8             	pushl  -0x8(%ebp)
    5652:	ff 75 08             	pushl  0x8(%ebp)
    5655:	e8 11 fe ff ff       	call   546b <drawRect>
    565a:	83 c4 20             	add    $0x20,%esp
}
    565d:	90                   	nop
    565e:	c9                   	leave  
    565f:	c3                   	ret    

00005660 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    5660:	55                   	push   %ebp
    5661:	89 e5                	mov    %esp,%ebp
    5663:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    5666:	8b 45 30             	mov    0x30(%ebp),%eax
    5669:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    566c:	8b 45 34             	mov    0x34(%ebp),%eax
    566f:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    5672:	8b 55 20             	mov    0x20(%ebp),%edx
    5675:	8b 45 14             	mov    0x14(%ebp),%eax
    5678:	29 c2                	sub    %eax,%edx
    567a:	89 d0                	mov    %edx,%eax
    567c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    567f:	7d 0d                	jge    568e <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    5681:	8b 55 20             	mov    0x20(%ebp),%edx
    5684:	8b 45 14             	mov    0x14(%ebp),%eax
    5687:	29 c2                	sub    %eax,%edx
    5689:	89 d0                	mov    %edx,%eax
    568b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    568e:	8b 55 28             	mov    0x28(%ebp),%edx
    5691:	8b 45 1c             	mov    0x1c(%ebp),%eax
    5694:	29 c2                	sub    %eax,%edx
    5696:	89 d0                	mov    %edx,%eax
    5698:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    569b:	7d 0d                	jge    56aa <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    569d:	8b 55 28             	mov    0x28(%ebp),%edx
    56a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    56a3:	29 c2                	sub    %eax,%edx
    56a5:	89 d0                	mov    %edx,%eax
    56a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    56aa:	8b 55 24             	mov    0x24(%ebp),%edx
    56ad:	8b 45 10             	mov    0x10(%ebp),%eax
    56b0:	29 c2                	sub    %eax,%edx
    56b2:	89 d0                	mov    %edx,%eax
    56b4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    56b7:	7d 0d                	jge    56c6 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    56b9:	8b 55 24             	mov    0x24(%ebp),%edx
    56bc:	8b 45 10             	mov    0x10(%ebp),%eax
    56bf:	29 c2                	sub    %eax,%edx
    56c1:	89 d0                	mov    %edx,%eax
    56c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    56c6:	8b 55 2c             	mov    0x2c(%ebp),%edx
    56c9:	8b 45 18             	mov    0x18(%ebp),%eax
    56cc:	29 c2                	sub    %eax,%edx
    56ce:	89 d0                	mov    %edx,%eax
    56d0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    56d3:	7d 0d                	jge    56e2 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    56d5:	8b 55 2c             	mov    0x2c(%ebp),%edx
    56d8:	8b 45 18             	mov    0x18(%ebp),%eax
    56db:	29 c2                	sub    %eax,%edx
    56dd:	89 d0                	mov    %edx,%eax
    56df:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    56e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    56e9:	e9 83 00 00 00       	jmp    5771 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    56ee:	8b 55 14             	mov    0x14(%ebp),%edx
    56f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    56f4:	01 d0                	add    %edx,%eax
    56f6:	85 c0                	test   %eax,%eax
    56f8:	78 72                	js     576c <drawBitmap+0x10c>
    56fa:	8b 55 14             	mov    0x14(%ebp),%edx
    56fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5700:	01 c2                	add    %eax,%edx
    5702:	8b 45 20             	mov    0x20(%ebp),%eax
    5705:	39 c2                	cmp    %eax,%edx
    5707:	7d 63                	jge    576c <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    5709:	8b 55 14             	mov    0x14(%ebp),%edx
    570c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    570f:	01 c2                	add    %eax,%edx
    5711:	8b 45 24             	mov    0x24(%ebp),%eax
    5714:	0f af c2             	imul   %edx,%eax
    5717:	89 c2                	mov    %eax,%edx
    5719:	8b 45 10             	mov    0x10(%ebp),%eax
    571c:	01 c2                	add    %eax,%edx
    571e:	89 d0                	mov    %edx,%eax
    5720:	01 c0                	add    %eax,%eax
    5722:	01 c2                	add    %eax,%edx
    5724:	8b 45 08             	mov    0x8(%ebp),%eax
    5727:	01 d0                	add    %edx,%eax
    5729:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    572c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    572f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5732:	01 c2                	add    %eax,%edx
    5734:	8b 45 2c             	mov    0x2c(%ebp),%eax
    5737:	0f af c2             	imul   %edx,%eax
    573a:	89 c2                	mov    %eax,%edx
    573c:	8b 45 18             	mov    0x18(%ebp),%eax
    573f:	01 c2                	add    %eax,%edx
    5741:	89 d0                	mov    %edx,%eax
    5743:	01 c0                	add    %eax,%eax
    5745:	01 c2                	add    %eax,%edx
    5747:	8b 45 0c             	mov    0xc(%ebp),%eax
    574a:	01 d0                	add    %edx,%eax
    574c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    574f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5752:	89 d0                	mov    %edx,%eax
    5754:	01 c0                	add    %eax,%eax
    5756:	01 d0                	add    %edx,%eax
    5758:	83 ec 04             	sub    $0x4,%esp
    575b:	50                   	push   %eax
    575c:	ff 75 e4             	pushl  -0x1c(%ebp)
    575f:	ff 75 e8             	pushl  -0x18(%ebp)
    5762:	e8 23 e7 ff ff       	call   3e8a <memmove>
    5767:	83 c4 10             	add    $0x10,%esp
    576a:	eb 01                	jmp    576d <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    576c:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    576d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5771:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5774:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    5777:	0f 8c 71 ff ff ff    	jl     56ee <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    577d:	90                   	nop
    577e:	c9                   	leave  
    577f:	c3                   	ret    

00005780 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    5780:	55                   	push   %ebp
    5781:	89 e5                	mov    %esp,%ebp
    5783:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    5786:	8b 45 30             	mov    0x30(%ebp),%eax
    5789:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    578c:	8b 45 34             	mov    0x34(%ebp),%eax
    578f:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    5792:	8b 55 20             	mov    0x20(%ebp),%edx
    5795:	8b 45 14             	mov    0x14(%ebp),%eax
    5798:	29 c2                	sub    %eax,%edx
    579a:	89 d0                	mov    %edx,%eax
    579c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    579f:	7d 0d                	jge    57ae <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    57a1:	8b 55 20             	mov    0x20(%ebp),%edx
    57a4:	8b 45 14             	mov    0x14(%ebp),%eax
    57a7:	29 c2                	sub    %eax,%edx
    57a9:	89 d0                	mov    %edx,%eax
    57ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    57ae:	8b 55 28             	mov    0x28(%ebp),%edx
    57b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    57b4:	29 c2                	sub    %eax,%edx
    57b6:	89 d0                	mov    %edx,%eax
    57b8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    57bb:	7d 0d                	jge    57ca <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    57bd:	8b 55 28             	mov    0x28(%ebp),%edx
    57c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    57c3:	29 c2                	sub    %eax,%edx
    57c5:	89 d0                	mov    %edx,%eax
    57c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    57ca:	8b 55 24             	mov    0x24(%ebp),%edx
    57cd:	8b 45 10             	mov    0x10(%ebp),%eax
    57d0:	29 c2                	sub    %eax,%edx
    57d2:	89 d0                	mov    %edx,%eax
    57d4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    57d7:	7d 0d                	jge    57e6 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    57d9:	8b 55 24             	mov    0x24(%ebp),%edx
    57dc:	8b 45 10             	mov    0x10(%ebp),%eax
    57df:	29 c2                	sub    %eax,%edx
    57e1:	89 d0                	mov    %edx,%eax
    57e3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    57e6:	8b 55 2c             	mov    0x2c(%ebp),%edx
    57e9:	8b 45 18             	mov    0x18(%ebp),%eax
    57ec:	29 c2                	sub    %eax,%edx
    57ee:	89 d0                	mov    %edx,%eax
    57f0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    57f3:	7d 0d                	jge    5802 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    57f5:	8b 55 2c             	mov    0x2c(%ebp),%edx
    57f8:	8b 45 18             	mov    0x18(%ebp),%eax
    57fb:	29 c2                	sub    %eax,%edx
    57fd:	89 d0                	mov    %edx,%eax
    57ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    5802:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5809:	e9 b8 00 00 00       	jmp    58c6 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    580e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5815:	e9 9c 00 00 00       	jmp    58b6 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    581a:	8b 55 14             	mov    0x14(%ebp),%edx
    581d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5820:	01 c2                	add    %eax,%edx
    5822:	8b 45 24             	mov    0x24(%ebp),%eax
    5825:	0f af c2             	imul   %edx,%eax
    5828:	89 c2                	mov    %eax,%edx
    582a:	8b 45 10             	mov    0x10(%ebp),%eax
    582d:	01 c2                	add    %eax,%edx
    582f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5832:	01 c2                	add    %eax,%edx
    5834:	89 d0                	mov    %edx,%eax
    5836:	01 c0                	add    %eax,%eax
    5838:	01 c2                	add    %eax,%edx
    583a:	8b 45 08             	mov    0x8(%ebp),%eax
    583d:	01 d0                	add    %edx,%eax
    583f:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    5842:	8b 55 1c             	mov    0x1c(%ebp),%edx
    5845:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5848:	01 c2                	add    %eax,%edx
    584a:	8b 45 2c             	mov    0x2c(%ebp),%eax
    584d:	0f af c2             	imul   %edx,%eax
    5850:	89 c2                	mov    %eax,%edx
    5852:	8b 45 18             	mov    0x18(%ebp),%eax
    5855:	01 c2                	add    %eax,%edx
    5857:	8b 45 f0             	mov    -0x10(%ebp),%eax
    585a:	01 c2                	add    %eax,%edx
    585c:	89 d0                	mov    %edx,%eax
    585e:	01 c0                	add    %eax,%eax
    5860:	01 c2                	add    %eax,%edx
    5862:	8b 45 0c             	mov    0xc(%ebp),%eax
    5865:	01 d0                	add    %edx,%eax
    5867:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    586a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    586d:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5871:	3c ff                	cmp    $0xff,%al
    5873:	75 15                	jne    588a <drawTransparentBitmap+0x10a>
    5875:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5878:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    587c:	3c ff                	cmp    $0xff,%al
    587e:	75 0a                	jne    588a <drawTransparentBitmap+0x10a>
    5880:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5883:	0f b6 00             	movzbl (%eax),%eax
    5886:	3c ff                	cmp    $0xff,%al
    5888:	74 27                	je     58b1 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    588a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    588d:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    5891:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5894:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    5897:	8b 45 e8             	mov    -0x18(%ebp),%eax
    589a:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    589e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58a1:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    58a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    58a7:	0f b6 10             	movzbl (%eax),%edx
    58aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58ad:	88 10                	mov    %dl,(%eax)
    58af:	eb 01                	jmp    58b2 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    58b1:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    58b2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    58b6:	8b 45 34             	mov    0x34(%ebp),%eax
    58b9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    58bc:	0f 8f 58 ff ff ff    	jg     581a <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    58c2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    58c6:	8b 45 30             	mov    0x30(%ebp),%eax
    58c9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    58cc:	0f 8f 3c ff ff ff    	jg     580e <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    58d2:	90                   	nop
    58d3:	c9                   	leave  
    58d4:	c3                   	ret    

000058d5 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    58d5:	55                   	push   %ebp
    58d6:	89 e5                	mov    %esp,%ebp
    58d8:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    58db:	ff 75 24             	pushl  0x24(%ebp)
    58de:	ff 75 20             	pushl  0x20(%ebp)
    58e1:	ff 75 1c             	pushl  0x1c(%ebp)
    58e4:	ff 75 18             	pushl  0x18(%ebp)
    58e7:	ff 75 1c             	pushl  0x1c(%ebp)
    58ea:	ff 75 18             	pushl  0x18(%ebp)
    58ed:	ff 75 14             	pushl  0x14(%ebp)
    58f0:	ff 75 10             	pushl  0x10(%ebp)
    58f3:	ff 75 14             	pushl  0x14(%ebp)
    58f6:	ff 75 10             	pushl  0x10(%ebp)
    58f9:	ff 75 0c             	pushl  0xc(%ebp)
    58fc:	ff 75 08             	pushl  0x8(%ebp)
    58ff:	e8 5c fd ff ff       	call   5660 <drawBitmap>
    5904:	83 c4 30             	add    $0x30,%esp
}
    5907:	90                   	nop
    5908:	c9                   	leave  
    5909:	c3                   	ret    

0000590a <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    590a:	55                   	push   %ebp
    590b:	89 e5                	mov    %esp,%ebp
    590d:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    5910:	8b 45 1c             	mov    0x1c(%ebp),%eax
    5913:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    5916:	8b 45 20             	mov    0x20(%ebp),%eax
    5919:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    591c:	8b 55 14             	mov    0x14(%ebp),%edx
    591f:	8b 45 10             	mov    0x10(%ebp),%eax
    5922:	29 c2                	sub    %eax,%edx
    5924:	89 d0                	mov    %edx,%eax
    5926:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    5929:	7d 0d                	jge    5938 <colorShift+0x2e>
        draw_h = s.h - p.y;
    592b:	8b 55 14             	mov    0x14(%ebp),%edx
    592e:	8b 45 10             	mov    0x10(%ebp),%eax
    5931:	29 c2                	sub    %eax,%edx
    5933:	89 d0                	mov    %edx,%eax
    5935:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    5938:	8b 55 18             	mov    0x18(%ebp),%edx
    593b:	8b 45 0c             	mov    0xc(%ebp),%eax
    593e:	29 c2                	sub    %eax,%edx
    5940:	89 d0                	mov    %edx,%eax
    5942:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5945:	7d 0d                	jge    5954 <colorShift+0x4a>
        draw_w = s.w - p.x;
    5947:	8b 55 18             	mov    0x18(%ebp),%edx
    594a:	8b 45 0c             	mov    0xc(%ebp),%eax
    594d:	29 c2                	sub    %eax,%edx
    594f:	89 d0                	mov    %edx,%eax
    5951:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    5954:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    595b:	e9 fc 00 00 00       	jmp    5a5c <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    5960:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5967:	e9 e0 00 00 00       	jmp    5a4c <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    596c:	8b 55 10             	mov    0x10(%ebp),%edx
    596f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5972:	01 c2                	add    %eax,%edx
    5974:	8b 45 18             	mov    0x18(%ebp),%eax
    5977:	0f af c2             	imul   %edx,%eax
    597a:	89 c2                	mov    %eax,%edx
    597c:	8b 45 0c             	mov    0xc(%ebp),%eax
    597f:	01 c2                	add    %eax,%edx
    5981:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5984:	01 c2                	add    %eax,%edx
    5986:	89 d0                	mov    %edx,%eax
    5988:	01 c0                	add    %eax,%eax
    598a:	01 c2                	add    %eax,%edx
    598c:	8b 45 08             	mov    0x8(%ebp),%eax
    598f:	01 d0                	add    %edx,%eax
    5991:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    5994:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5997:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    599b:	3c c8                	cmp    $0xc8,%al
    599d:	0f 86 a5 00 00 00    	jbe    5a48 <colorShift+0x13e>
    59a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59a6:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    59aa:	3c c8                	cmp    $0xc8,%al
    59ac:	0f 86 96 00 00 00    	jbe    5a48 <colorShift+0x13e>
    59b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59b5:	0f b6 00             	movzbl (%eax),%eax
    59b8:	3c c8                	cmp    $0xc8,%al
    59ba:	0f 86 88 00 00 00    	jbe    5a48 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    59c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59c3:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    59c7:	0f b6 d0             	movzbl %al,%edx
    59ca:	8b 45 24             	mov    0x24(%ebp),%eax
    59cd:	01 d0                	add    %edx,%eax
    59cf:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    59d5:	89 d0                	mov    %edx,%eax
    59d7:	c1 f8 1f             	sar    $0x1f,%eax
    59da:	c1 e8 18             	shr    $0x18,%eax
    59dd:	01 c2                	add    %eax,%edx
    59df:	0f b6 d2             	movzbl %dl,%edx
    59e2:	29 c2                	sub    %eax,%edx
    59e4:	89 d0                	mov    %edx,%eax
    59e6:	89 c2                	mov    %eax,%edx
    59e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59eb:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    59ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59f1:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    59f5:	0f b6 d0             	movzbl %al,%edx
    59f8:	8b 45 24             	mov    0x24(%ebp),%eax
    59fb:	01 d0                	add    %edx,%eax
    59fd:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    5a03:	89 d0                	mov    %edx,%eax
    5a05:	c1 f8 1f             	sar    $0x1f,%eax
    5a08:	c1 e8 18             	shr    $0x18,%eax
    5a0b:	01 c2                	add    %eax,%edx
    5a0d:	0f b6 d2             	movzbl %dl,%edx
    5a10:	29 c2                	sub    %eax,%edx
    5a12:	89 d0                	mov    %edx,%eax
    5a14:	89 c2                	mov    %eax,%edx
    5a16:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a19:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    5a1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a1f:	0f b6 00             	movzbl (%eax),%eax
    5a22:	0f b6 d0             	movzbl %al,%edx
    5a25:	8b 45 24             	mov    0x24(%ebp),%eax
    5a28:	01 d0                	add    %edx,%eax
    5a2a:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    5a30:	89 d0                	mov    %edx,%eax
    5a32:	c1 f8 1f             	sar    $0x1f,%eax
    5a35:	c1 e8 18             	shr    $0x18,%eax
    5a38:	01 c2                	add    %eax,%edx
    5a3a:	0f b6 d2             	movzbl %dl,%edx
    5a3d:	29 c2                	sub    %eax,%edx
    5a3f:	89 d0                	mov    %edx,%eax
    5a41:	89 c2                	mov    %eax,%edx
    5a43:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a46:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    5a48:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5a4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5a4f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5a52:	0f 8c 14 ff ff ff    	jl     596c <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    5a58:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5a5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5a5f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    5a62:	0f 8c f8 fe ff ff    	jl     5960 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    5a68:	90                   	nop
    5a69:	c9                   	leave  
    5a6a:	c3                   	ret    

00005a6b <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    5a6b:	55                   	push   %ebp
    5a6c:	89 e5                	mov    %esp,%ebp
    5a6e:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    5a71:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    5a78:	e9 fb 00 00 00       	jmp    5b78 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    5a7d:	8b 55 14             	mov    0x14(%ebp),%edx
    5a80:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5a83:	01 c2                	add    %eax,%edx
    5a85:	0f b7 05 26 85 02 00 	movzwl 0x28526,%eax
    5a8c:	0f b7 c0             	movzwl %ax,%eax
    5a8f:	39 c2                	cmp    %eax,%edx
    5a91:	0f 8f eb 00 00 00    	jg     5b82 <drawMouse+0x117>
    5a97:	8b 55 14             	mov    0x14(%ebp),%edx
    5a9a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5a9d:	01 d0                	add    %edx,%eax
    5a9f:	85 c0                	test   %eax,%eax
    5aa1:	0f 88 db 00 00 00    	js     5b82 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    5aa7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    5aae:	e9 b7 00 00 00       	jmp    5b6a <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    5ab3:	8b 55 10             	mov    0x10(%ebp),%edx
    5ab6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5ab9:	01 c2                	add    %eax,%edx
    5abb:	0f b7 05 24 85 02 00 	movzwl 0x28524,%eax
    5ac2:	0f b7 c0             	movzwl %ax,%eax
    5ac5:	39 c2                	cmp    %eax,%edx
    5ac7:	0f 8f a7 00 00 00    	jg     5b74 <drawMouse+0x109>
    5acd:	8b 55 10             	mov    0x10(%ebp),%edx
    5ad0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5ad3:	01 d0                	add    %edx,%eax
    5ad5:	85 c0                	test   %eax,%eax
    5ad7:	0f 88 97 00 00 00    	js     5b74 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    5add:	8b 55 fc             	mov    -0x4(%ebp),%edx
    5ae0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    5ae3:	89 d0                	mov    %edx,%eax
    5ae5:	c1 e0 04             	shl    $0x4,%eax
    5ae8:	29 d0                	sub    %edx,%eax
    5aea:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    5af0:	01 c2                	add    %eax,%edx
    5af2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5af5:	01 d0                	add    %edx,%eax
    5af7:	05 00 b2 01 00       	add    $0x1b200,%eax
    5afc:	0f b6 00             	movzbl (%eax),%eax
    5aff:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    5b02:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    5b06:	74 5e                	je     5b66 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    5b08:	8b 55 14             	mov    0x14(%ebp),%edx
    5b0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5b0e:	01 c2                	add    %eax,%edx
    5b10:	0f b7 05 24 85 02 00 	movzwl 0x28524,%eax
    5b17:	0f b7 c0             	movzwl %ax,%eax
    5b1a:	0f af c2             	imul   %edx,%eax
    5b1d:	89 c2                	mov    %eax,%edx
    5b1f:	8b 45 10             	mov    0x10(%ebp),%eax
    5b22:	01 c2                	add    %eax,%edx
    5b24:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5b27:	01 c2                	add    %eax,%edx
    5b29:	89 d0                	mov    %edx,%eax
    5b2b:	01 c0                	add    %eax,%eax
    5b2d:	01 c2                	add    %eax,%edx
    5b2f:	8b 45 08             	mov    0x8(%ebp),%eax
    5b32:	01 d0                	add    %edx,%eax
    5b34:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    5b37:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    5b3b:	8d 50 ff             	lea    -0x1(%eax),%edx
    5b3e:	89 d0                	mov    %edx,%eax
    5b40:	01 c0                	add    %eax,%eax
    5b42:	01 d0                	add    %edx,%eax
    5b44:	05 2c 85 02 00       	add    $0x2852c,%eax
    5b49:	83 ec 04             	sub    $0x4,%esp
    5b4c:	89 e2                	mov    %esp,%edx
    5b4e:	0f b7 08             	movzwl (%eax),%ecx
    5b51:	66 89 0a             	mov    %cx,(%edx)
    5b54:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5b58:	88 42 02             	mov    %al,0x2(%edx)
    5b5b:	ff 75 f0             	pushl  -0x10(%ebp)
    5b5e:	e8 73 f6 ff ff       	call   51d6 <drawPoint>
    5b63:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    5b66:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    5b6a:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    5b6e:	0f 8e 3f ff ff ff    	jle    5ab3 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    5b74:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    5b78:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    5b7c:	0f 8e fb fe ff ff    	jle    5a7d <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    5b82:	90                   	nop
    5b83:	c9                   	leave  
    5b84:	c3                   	ret    

00005b85 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    5b85:	55                   	push   %ebp
    5b86:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    5b88:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    5b8c:	78 1b                	js     5ba9 <getColor+0x24>
    5b8e:	8b 45 08             	mov    0x8(%ebp),%eax
    5b91:	8b 40 04             	mov    0x4(%eax),%eax
    5b94:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5b97:	7c 10                	jl     5ba9 <getColor+0x24>
    5b99:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    5b9d:	78 0a                	js     5ba9 <getColor+0x24>
    5b9f:	8b 45 08             	mov    0x8(%ebp),%eax
    5ba2:	8b 00                	mov    (%eax),%eax
    5ba4:	3b 45 10             	cmp    0x10(%ebp),%eax
    5ba7:	7d 10                	jge    5bb9 <getColor+0x34>
    {
        *isInPic = 1;
    5ba9:	8b 45 14             	mov    0x14(%ebp),%eax
    5bac:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    5bb2:	b8 2d 39 02 00       	mov    $0x2392d,%eax
    5bb7:	eb 44                	jmp    5bfd <getColor+0x78>
    }

    if (y == pic->height)
    5bb9:	8b 45 08             	mov    0x8(%ebp),%eax
    5bbc:	8b 40 04             	mov    0x4(%eax),%eax
    5bbf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    5bc2:	75 04                	jne    5bc8 <getColor+0x43>
        y--;
    5bc4:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    5bc8:	8b 45 08             	mov    0x8(%ebp),%eax
    5bcb:	8b 00                	mov    (%eax),%eax
    5bcd:	3b 45 10             	cmp    0x10(%ebp),%eax
    5bd0:	75 04                	jne    5bd6 <getColor+0x51>
        x--;
    5bd2:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    5bd6:	8b 45 14             	mov    0x14(%ebp),%eax
    5bd9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    5bdf:	8b 45 08             	mov    0x8(%ebp),%eax
    5be2:	8b 48 08             	mov    0x8(%eax),%ecx
    5be5:	8b 45 08             	mov    0x8(%ebp),%eax
    5be8:	8b 00                	mov    (%eax),%eax
    5bea:	0f af 45 0c          	imul   0xc(%ebp),%eax
    5bee:	89 c2                	mov    %eax,%edx
    5bf0:	8b 45 10             	mov    0x10(%ebp),%eax
    5bf3:	01 c2                	add    %eax,%edx
    5bf5:	89 d0                	mov    %edx,%eax
    5bf7:	01 c0                	add    %eax,%eax
    5bf9:	01 d0                	add    %edx,%eax
    5bfb:	01 c8                	add    %ecx,%eax
}
    5bfd:	5d                   	pop    %ebp
    5bfe:	c3                   	ret    

00005bff <setColor>:

int setColor(RGB *src, RGB *dst)
{
    5bff:	55                   	push   %ebp
    5c00:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    5c02:	8b 45 08             	mov    0x8(%ebp),%eax
    5c05:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    5c09:	8b 45 0c             	mov    0xc(%ebp),%eax
    5c0c:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    5c0f:	8b 45 08             	mov    0x8(%ebp),%eax
    5c12:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    5c16:	8b 45 0c             	mov    0xc(%ebp),%eax
    5c19:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    5c1c:	8b 45 08             	mov    0x8(%ebp),%eax
    5c1f:	0f b6 10             	movzbl (%eax),%edx
    5c22:	8b 45 0c             	mov    0xc(%ebp),%eax
    5c25:	88 10                	mov    %dl,(%eax)

    return 1;
    5c27:	b8 01 00 00 00       	mov    $0x1,%eax
}
    5c2c:	5d                   	pop    %ebp
    5c2d:	c3                   	ret    

00005c2e <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    5c2e:	55                   	push   %ebp
    5c2f:	89 e5                	mov    %esp,%ebp
    5c31:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    5c34:	d9 45 10             	flds   0x10(%ebp)
    5c37:	d9 7d be             	fnstcw -0x42(%ebp)
    5c3a:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    5c3e:	b4 0c                	mov    $0xc,%ah
    5c40:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    5c44:	d9 6d bc             	fldcw  -0x44(%ebp)
    5c47:	db 5d fc             	fistpl -0x4(%ebp)
    5c4a:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    5c4d:	d9 45 0c             	flds   0xc(%ebp)
    5c50:	d9 6d bc             	fldcw  -0x44(%ebp)
    5c53:	db 5d f8             	fistpl -0x8(%ebp)
    5c56:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    5c59:	db 45 fc             	fildl  -0x4(%ebp)
    5c5c:	d9 45 10             	flds   0x10(%ebp)
    5c5f:	d9 c9                	fxch   %st(1)
    5c61:	df e9                	fucomip %st(1),%st
    5c63:	dd d8                	fstp   %st(0)
    5c65:	76 04                	jbe    5c6b <mixColor+0x3d>
        x--;
    5c67:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    5c6b:	db 45 f8             	fildl  -0x8(%ebp)
    5c6e:	d9 45 0c             	flds   0xc(%ebp)
    5c71:	d9 c9                	fxch   %st(1)
    5c73:	df e9                	fucomip %st(1),%st
    5c75:	dd d8                	fstp   %st(0)
    5c77:	76 04                	jbe    5c7d <mixColor+0x4f>
        y--;
    5c79:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    5c7d:	8d 45 c0             	lea    -0x40(%ebp),%eax
    5c80:	50                   	push   %eax
    5c81:	ff 75 fc             	pushl  -0x4(%ebp)
    5c84:	ff 75 f8             	pushl  -0x8(%ebp)
    5c87:	ff 75 08             	pushl  0x8(%ebp)
    5c8a:	e8 f6 fe ff ff       	call   5b85 <getColor>
    5c8f:	83 c4 10             	add    $0x10,%esp
    5c92:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    5c95:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5c98:	83 c0 01             	add    $0x1,%eax
    5c9b:	8d 55 c0             	lea    -0x40(%ebp),%edx
    5c9e:	83 c2 04             	add    $0x4,%edx
    5ca1:	52                   	push   %edx
    5ca2:	ff 75 fc             	pushl  -0x4(%ebp)
    5ca5:	50                   	push   %eax
    5ca6:	ff 75 08             	pushl  0x8(%ebp)
    5ca9:	e8 d7 fe ff ff       	call   5b85 <getColor>
    5cae:	83 c4 10             	add    $0x10,%esp
    5cb1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    5cb4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5cb7:	83 c0 01             	add    $0x1,%eax
    5cba:	8d 55 c0             	lea    -0x40(%ebp),%edx
    5cbd:	83 c2 08             	add    $0x8,%edx
    5cc0:	52                   	push   %edx
    5cc1:	50                   	push   %eax
    5cc2:	ff 75 f8             	pushl  -0x8(%ebp)
    5cc5:	ff 75 08             	pushl  0x8(%ebp)
    5cc8:	e8 b8 fe ff ff       	call   5b85 <getColor>
    5ccd:	83 c4 10             	add    $0x10,%esp
    5cd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    5cd3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    5cd6:	8d 50 01             	lea    0x1(%eax),%edx
    5cd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5cdc:	83 c0 01             	add    $0x1,%eax
    5cdf:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    5ce2:	83 c1 0c             	add    $0xc,%ecx
    5ce5:	51                   	push   %ecx
    5ce6:	52                   	push   %edx
    5ce7:	50                   	push   %eax
    5ce8:	ff 75 08             	pushl  0x8(%ebp)
    5ceb:	e8 95 fe ff ff       	call   5b85 <getColor>
    5cf0:	83 c4 10             	add    $0x10,%esp
    5cf3:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    5cf6:	db 45 fc             	fildl  -0x4(%ebp)
    5cf9:	d9 45 10             	flds   0x10(%ebp)
    5cfc:	de e1                	fsubp  %st,%st(1)
    5cfe:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    5d01:	db 45 f8             	fildl  -0x8(%ebp)
    5d04:	d9 45 0c             	flds   0xc(%ebp)
    5d07:	de e1                	fsubp  %st,%st(1)
    5d09:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    5d0c:	d9 45 e4             	flds   -0x1c(%ebp)
    5d0f:	d8 4d e0             	fmuls  -0x20(%ebp)
    5d12:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    5d15:	d9 e8                	fld1   
    5d17:	d8 65 e0             	fsubs  -0x20(%ebp)
    5d1a:	d8 4d e4             	fmuls  -0x1c(%ebp)
    5d1d:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    5d20:	d9 e8                	fld1   
    5d22:	d8 65 e4             	fsubs  -0x1c(%ebp)
    5d25:	d8 4d e0             	fmuls  -0x20(%ebp)
    5d28:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    5d2b:	d9 e8                	fld1   
    5d2d:	d8 65 e4             	fsubs  -0x1c(%ebp)
    5d30:	d9 e8                	fld1   
    5d32:	d8 65 e0             	fsubs  -0x20(%ebp)
    5d35:	de c9                	fmulp  %st,%st(1)
    5d37:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    5d3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5d3d:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5d41:	0f b6 c0             	movzbl %al,%eax
    5d44:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5d47:	db 45 b4             	fildl  -0x4c(%ebp)
    5d4a:	d8 4d d0             	fmuls  -0x30(%ebp)
    5d4d:	8b 45 c0             	mov    -0x40(%ebp),%eax
    5d50:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5d53:	db 45 b4             	fildl  -0x4c(%ebp)
    5d56:	de c9                	fmulp  %st,%st(1)
    5d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d5b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5d5f:	0f b6 c0             	movzbl %al,%eax
    5d62:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5d65:	db 45 b4             	fildl  -0x4c(%ebp)
    5d68:	d8 4d d4             	fmuls  -0x2c(%ebp)
    5d6b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5d6e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5d71:	db 45 b4             	fildl  -0x4c(%ebp)
    5d74:	de c9                	fmulp  %st,%st(1)
    5d76:	de c1                	faddp  %st,%st(1)
    5d78:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d7b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5d7f:	0f b6 c0             	movzbl %al,%eax
    5d82:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5d85:	db 45 b4             	fildl  -0x4c(%ebp)
    5d88:	d8 4d d8             	fmuls  -0x28(%ebp)
    5d8b:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5d8e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5d91:	db 45 b4             	fildl  -0x4c(%ebp)
    5d94:	de c9                	fmulp  %st,%st(1)
    5d96:	de c1                	faddp  %st,%st(1)
    5d98:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d9b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5d9f:	0f b6 c0             	movzbl %al,%eax
    5da2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5da5:	db 45 b4             	fildl  -0x4c(%ebp)
    5da8:	d8 4d dc             	fmuls  -0x24(%ebp)
    5dab:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5dae:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5db1:	db 45 b4             	fildl  -0x4c(%ebp)
    5db4:	de c9                	fmulp  %st,%st(1)
    5db6:	de c1                	faddp  %st,%st(1)
    5db8:	d9 7d be             	fnstcw -0x42(%ebp)
    5dbb:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    5dbf:	b4 0c                	mov    $0xc,%ah
    5dc1:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    5dc5:	d9 6d bc             	fldcw  -0x44(%ebp)
    5dc8:	db 5d b8             	fistpl -0x48(%ebp)
    5dcb:	d9 6d be             	fldcw  -0x42(%ebp)
    5dce:	8b 45 b8             	mov    -0x48(%ebp),%eax
    5dd1:	89 c2                	mov    %eax,%edx
    5dd3:	8b 45 14             	mov    0x14(%ebp),%eax
    5dd6:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    5dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5ddc:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    5de0:	0f b6 c0             	movzbl %al,%eax
    5de3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5de6:	db 45 b4             	fildl  -0x4c(%ebp)
    5de9:	d8 4d d0             	fmuls  -0x30(%ebp)
    5dec:	8b 45 c0             	mov    -0x40(%ebp),%eax
    5def:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5df2:	db 45 b4             	fildl  -0x4c(%ebp)
    5df5:	de c9                	fmulp  %st,%st(1)
    5df7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5dfa:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    5dfe:	0f b6 c0             	movzbl %al,%eax
    5e01:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e04:	db 45 b4             	fildl  -0x4c(%ebp)
    5e07:	d8 4d d4             	fmuls  -0x2c(%ebp)
    5e0a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5e0d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e10:	db 45 b4             	fildl  -0x4c(%ebp)
    5e13:	de c9                	fmulp  %st,%st(1)
    5e15:	de c1                	faddp  %st,%st(1)
    5e17:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e1a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    5e1e:	0f b6 c0             	movzbl %al,%eax
    5e21:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e24:	db 45 b4             	fildl  -0x4c(%ebp)
    5e27:	d8 4d d8             	fmuls  -0x28(%ebp)
    5e2a:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5e2d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e30:	db 45 b4             	fildl  -0x4c(%ebp)
    5e33:	de c9                	fmulp  %st,%st(1)
    5e35:	de c1                	faddp  %st,%st(1)
    5e37:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e3a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    5e3e:	0f b6 c0             	movzbl %al,%eax
    5e41:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e44:	db 45 b4             	fildl  -0x4c(%ebp)
    5e47:	d8 4d dc             	fmuls  -0x24(%ebp)
    5e4a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5e4d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e50:	db 45 b4             	fildl  -0x4c(%ebp)
    5e53:	de c9                	fmulp  %st,%st(1)
    5e55:	de c1                	faddp  %st,%st(1)
    5e57:	d9 6d bc             	fldcw  -0x44(%ebp)
    5e5a:	db 5d b8             	fistpl -0x48(%ebp)
    5e5d:	d9 6d be             	fldcw  -0x42(%ebp)
    5e60:	8b 45 b8             	mov    -0x48(%ebp),%eax
    5e63:	89 c2                	mov    %eax,%edx
    5e65:	8b 45 14             	mov    0x14(%ebp),%eax
    5e68:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    5e6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5e6e:	0f b6 00             	movzbl (%eax),%eax
    5e71:	0f b6 c0             	movzbl %al,%eax
    5e74:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e77:	db 45 b4             	fildl  -0x4c(%ebp)
    5e7a:	d8 4d d0             	fmuls  -0x30(%ebp)
    5e7d:	8b 45 c0             	mov    -0x40(%ebp),%eax
    5e80:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e83:	db 45 b4             	fildl  -0x4c(%ebp)
    5e86:	de c9                	fmulp  %st,%st(1)
    5e88:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e8b:	0f b6 00             	movzbl (%eax),%eax
    5e8e:	0f b6 c0             	movzbl %al,%eax
    5e91:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5e94:	db 45 b4             	fildl  -0x4c(%ebp)
    5e97:	d8 4d d4             	fmuls  -0x2c(%ebp)
    5e9a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5e9d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5ea0:	db 45 b4             	fildl  -0x4c(%ebp)
    5ea3:	de c9                	fmulp  %st,%st(1)
    5ea5:	de c1                	faddp  %st,%st(1)
    5ea7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5eaa:	0f b6 00             	movzbl (%eax),%eax
    5ead:	0f b6 c0             	movzbl %al,%eax
    5eb0:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5eb3:	db 45 b4             	fildl  -0x4c(%ebp)
    5eb6:	d8 4d d8             	fmuls  -0x28(%ebp)
    5eb9:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5ebc:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5ebf:	db 45 b4             	fildl  -0x4c(%ebp)
    5ec2:	de c9                	fmulp  %st,%st(1)
    5ec4:	de c1                	faddp  %st,%st(1)
    5ec6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5ec9:	0f b6 00             	movzbl (%eax),%eax
    5ecc:	0f b6 c0             	movzbl %al,%eax
    5ecf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5ed2:	db 45 b4             	fildl  -0x4c(%ebp)
    5ed5:	d8 4d dc             	fmuls  -0x24(%ebp)
    5ed8:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5edb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    5ede:	db 45 b4             	fildl  -0x4c(%ebp)
    5ee1:	de c9                	fmulp  %st,%st(1)
    5ee3:	de c1                	faddp  %st,%st(1)
    5ee5:	d9 6d bc             	fldcw  -0x44(%ebp)
    5ee8:	db 5d b8             	fistpl -0x48(%ebp)
    5eeb:	d9 6d be             	fldcw  -0x42(%ebp)
    5eee:	8b 45 b8             	mov    -0x48(%ebp),%eax
    5ef1:	89 c2                	mov    %eax,%edx
    5ef3:	8b 45 14             	mov    0x14(%ebp),%eax
    5ef6:	88 10                	mov    %dl,(%eax)

    return 1;
    5ef8:	b8 01 00 00 00       	mov    $0x1,%eax
}
    5efd:	c9                   	leave  
    5efe:	c3                   	ret    

00005eff <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    5eff:	55                   	push   %ebp
    5f00:	89 e5                	mov    %esp,%ebp
    5f02:	53                   	push   %ebx
    5f03:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    5f06:	8b 45 10             	mov    0x10(%ebp),%eax
    5f09:	c1 f8 10             	sar    $0x10,%eax
    5f0c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    5f0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f12:	c1 f8 10             	sar    $0x10,%eax
    5f15:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    5f18:	8d 45 bc             	lea    -0x44(%ebp),%eax
    5f1b:	50                   	push   %eax
    5f1c:	ff 75 f8             	pushl  -0x8(%ebp)
    5f1f:	ff 75 f4             	pushl  -0xc(%ebp)
    5f22:	ff 75 08             	pushl  0x8(%ebp)
    5f25:	e8 5b fc ff ff       	call   5b85 <getColor>
    5f2a:	83 c4 10             	add    $0x10,%esp
    5f2d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    5f30:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5f33:	83 c0 01             	add    $0x1,%eax
    5f36:	8d 55 bc             	lea    -0x44(%ebp),%edx
    5f39:	83 c2 04             	add    $0x4,%edx
    5f3c:	52                   	push   %edx
    5f3d:	ff 75 f8             	pushl  -0x8(%ebp)
    5f40:	50                   	push   %eax
    5f41:	ff 75 08             	pushl  0x8(%ebp)
    5f44:	e8 3c fc ff ff       	call   5b85 <getColor>
    5f49:	83 c4 10             	add    $0x10,%esp
    5f4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    5f4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5f52:	83 c0 01             	add    $0x1,%eax
    5f55:	8d 55 bc             	lea    -0x44(%ebp),%edx
    5f58:	83 c2 08             	add    $0x8,%edx
    5f5b:	52                   	push   %edx
    5f5c:	50                   	push   %eax
    5f5d:	ff 75 f4             	pushl  -0xc(%ebp)
    5f60:	ff 75 08             	pushl  0x8(%ebp)
    5f63:	e8 1d fc ff ff       	call   5b85 <getColor>
    5f68:	83 c4 10             	add    $0x10,%esp
    5f6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    5f6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5f71:	8d 50 01             	lea    0x1(%eax),%edx
    5f74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5f77:	83 c0 01             	add    $0x1,%eax
    5f7a:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    5f7d:	83 c1 0c             	add    $0xc,%ecx
    5f80:	51                   	push   %ecx
    5f81:	52                   	push   %edx
    5f82:	50                   	push   %eax
    5f83:	ff 75 08             	pushl  0x8(%ebp)
    5f86:	e8 fa fb ff ff       	call   5b85 <getColor>
    5f8b:	83 c4 10             	add    $0x10,%esp
    5f8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    5f91:	8b 45 10             	mov    0x10(%ebp),%eax
    5f94:	0f b7 c0             	movzwl %ax,%eax
    5f97:	c1 f8 08             	sar    $0x8,%eax
    5f9a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    5f9d:	8b 45 0c             	mov    0xc(%ebp),%eax
    5fa0:	0f b7 c0             	movzwl %ax,%eax
    5fa3:	c1 f8 08             	sar    $0x8,%eax
    5fa6:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    5fa9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5fac:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    5fb0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    5fb3:	b8 ff 00 00 00       	mov    $0xff,%eax
    5fb8:	2b 45 dc             	sub    -0x24(%ebp),%eax
    5fbb:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    5fbf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    5fc2:	b8 ff 00 00 00       	mov    $0xff,%eax
    5fc7:	2b 45 e0             	sub    -0x20(%ebp),%eax
    5fca:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    5fce:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    5fd1:	b8 ff 00 00 00       	mov    $0xff,%eax
    5fd6:	2b 45 e0             	sub    -0x20(%ebp),%eax
    5fd9:	89 c2                	mov    %eax,%edx
    5fdb:	b8 ff 00 00 00       	mov    $0xff,%eax
    5fe0:	2b 45 dc             	sub    -0x24(%ebp),%eax
    5fe3:	0f af c2             	imul   %edx,%eax
    5fe6:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    5fe9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5fec:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5ff0:	0f b6 c0             	movzbl %al,%eax
    5ff3:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    5ff7:	8b 55 bc             	mov    -0x44(%ebp),%edx
    5ffa:	0f af d0             	imul   %eax,%edx
    5ffd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6000:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    6004:	0f b6 c0             	movzbl %al,%eax
    6007:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    600b:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    600e:	0f af c1             	imul   %ecx,%eax
    6011:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    6014:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6017:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    601b:	0f b6 c0             	movzbl %al,%eax
    601e:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    6022:	8b 55 c8             	mov    -0x38(%ebp),%edx
    6025:	0f af d0             	imul   %eax,%edx
    6028:	8b 45 e8             	mov    -0x18(%ebp),%eax
    602b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    602f:	0f b6 c0             	movzbl %al,%eax
    6032:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    6036:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    6039:	0f af c1             	imul   %ecx,%eax
    603c:	01 d0                	add    %edx,%eax
    603e:	01 d8                	add    %ebx,%eax
    6040:	c1 e8 10             	shr    $0x10,%eax
    6043:	89 c2                	mov    %eax,%edx
    6045:	8b 45 14             	mov    0x14(%ebp),%eax
    6048:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    604b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    604e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    6052:	0f b6 c0             	movzbl %al,%eax
    6055:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    6059:	8b 55 bc             	mov    -0x44(%ebp),%edx
    605c:	0f af d0             	imul   %eax,%edx
    605f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6062:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    6066:	0f b6 c0             	movzbl %al,%eax
    6069:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    606d:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    6070:	0f af c1             	imul   %ecx,%eax
    6073:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    6076:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6079:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    607d:	0f b6 c0             	movzbl %al,%eax
    6080:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    6084:	8b 55 c8             	mov    -0x38(%ebp),%edx
    6087:	0f af d0             	imul   %eax,%edx
    608a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    608d:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    6091:	0f b6 c0             	movzbl %al,%eax
    6094:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    6098:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    609b:	0f af c1             	imul   %ecx,%eax
    609e:	01 d0                	add    %edx,%eax
    60a0:	01 d8                	add    %ebx,%eax
    60a2:	c1 e8 10             	shr    $0x10,%eax
    60a5:	89 c2                	mov    %eax,%edx
    60a7:	8b 45 14             	mov    0x14(%ebp),%eax
    60aa:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    60ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
    60b0:	0f b6 00             	movzbl (%eax),%eax
    60b3:	0f b6 c0             	movzbl %al,%eax
    60b6:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    60ba:	8b 55 bc             	mov    -0x44(%ebp),%edx
    60bd:	0f af d0             	imul   %eax,%edx
    60c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    60c3:	0f b6 00             	movzbl (%eax),%eax
    60c6:	0f b6 c0             	movzbl %al,%eax
    60c9:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    60cd:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    60d0:	0f af c1             	imul   %ecx,%eax
    60d3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    60d6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    60d9:	0f b6 00             	movzbl (%eax),%eax
    60dc:	0f b6 c0             	movzbl %al,%eax
    60df:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    60e3:	8b 55 c8             	mov    -0x38(%ebp),%edx
    60e6:	0f af d0             	imul   %eax,%edx
    60e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    60ec:	0f b6 00             	movzbl (%eax),%eax
    60ef:	0f b6 c0             	movzbl %al,%eax
    60f2:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    60f6:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    60f9:	0f af c1             	imul   %ecx,%eax
    60fc:	01 d0                	add    %edx,%eax
    60fe:	01 d8                	add    %ebx,%eax
    6100:	c1 e8 10             	shr    $0x10,%eax
    6103:	89 c2                	mov    %eax,%edx
    6105:	8b 45 14             	mov    0x14(%ebp),%eax
    6108:	88 10                	mov    %dl,(%eax)
}
    610a:	90                   	nop
    610b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    610e:	c9                   	leave  
    610f:	c3                   	ret    

00006110 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    6110:	55                   	push   %ebp
    6111:	89 e5                	mov    %esp,%ebp
    6113:	53                   	push   %ebx
    6114:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    6117:	8b 45 08             	mov    0x8(%ebp),%eax
    611a:	8b 00                	mov    (%eax),%eax
    611c:	c1 e0 10             	shl    $0x10,%eax
    611f:	89 c1                	mov    %eax,%ecx
    6121:	8b 45 0c             	mov    0xc(%ebp),%eax
    6124:	8b 18                	mov    (%eax),%ebx
    6126:	89 c8                	mov    %ecx,%eax
    6128:	99                   	cltd   
    6129:	f7 fb                	idiv   %ebx
    612b:	83 c0 01             	add    $0x1,%eax
    612e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    6131:	8b 45 08             	mov    0x8(%ebp),%eax
    6134:	8b 40 04             	mov    0x4(%eax),%eax
    6137:	c1 e0 10             	shl    $0x10,%eax
    613a:	89 c1                	mov    %eax,%ecx
    613c:	8b 45 0c             	mov    0xc(%ebp),%eax
    613f:	8b 58 04             	mov    0x4(%eax),%ebx
    6142:	89 c8                	mov    %ecx,%eax
    6144:	99                   	cltd   
    6145:	f7 fb                	idiv   %ebx
    6147:	83 c0 01             	add    $0x1,%eax
    614a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    614d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6150:	d1 f8                	sar    %eax
    6152:	2d 00 80 00 00       	sub    $0x8000,%eax
    6157:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    615a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    615d:	d1 f8                	sar    %eax
    615f:	2d 00 80 00 00       	sub    $0x8000,%eax
    6164:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    6167:	8b 45 dc             	mov    -0x24(%ebp),%eax
    616a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    616d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6174:	eb 5d                	jmp    61d3 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    6176:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6179:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    617c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    6183:	eb 3a                	jmp    61bf <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    6185:	8b 45 0c             	mov    0xc(%ebp),%eax
    6188:	8b 48 08             	mov    0x8(%eax),%ecx
    618b:	8b 45 0c             	mov    0xc(%ebp),%eax
    618e:	8b 00                	mov    (%eax),%eax
    6190:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    6194:	89 c2                	mov    %eax,%edx
    6196:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6199:	01 c2                	add    %eax,%edx
    619b:	89 d0                	mov    %edx,%eax
    619d:	01 c0                	add    %eax,%eax
    619f:	01 d0                	add    %edx,%eax
    61a1:	01 c8                	add    %ecx,%eax
    61a3:	50                   	push   %eax
    61a4:	ff 75 f0             	pushl  -0x10(%ebp)
    61a7:	ff 75 f8             	pushl  -0x8(%ebp)
    61aa:	ff 75 08             	pushl  0x8(%ebp)
    61ad:	e8 4d fd ff ff       	call   5eff <mixColorInt>
    61b2:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    61b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    61b8:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    61bb:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    61bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    61c2:	8b 00                	mov    (%eax),%eax
    61c4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    61c7:	7f bc                	jg     6185 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    61c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    61cc:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    61cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    61d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    61d6:	8b 40 04             	mov    0x4(%eax),%eax
    61d9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    61dc:	7f 98                	jg     6176 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    61de:	b8 01 00 00 00       	mov    $0x1,%eax
}
    61e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    61e6:	c9                   	leave  
    61e7:	c3                   	ret    

000061e8 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    61e8:	55                   	push   %ebp
    61e9:	89 e5                	mov    %esp,%ebp
    61eb:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    61ee:	8b 45 08             	mov    0x8(%ebp),%eax
    61f1:	8b 00                	mov    (%eax),%eax
    61f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    61f6:	db 45 e4             	fildl  -0x1c(%ebp)
    61f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    61fc:	8b 00                	mov    (%eax),%eax
    61fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    6201:	db 45 e4             	fildl  -0x1c(%ebp)
    6204:	de f9                	fdivrp %st,%st(1)
    6206:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    6209:	8b 45 08             	mov    0x8(%ebp),%eax
    620c:	8b 40 04             	mov    0x4(%eax),%eax
    620f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    6212:	db 45 e4             	fildl  -0x1c(%ebp)
    6215:	8b 45 0c             	mov    0xc(%ebp),%eax
    6218:	8b 40 04             	mov    0x4(%eax),%eax
    621b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    621e:	db 45 e4             	fildl  -0x1c(%ebp)
    6221:	de f9                	fdivrp %st,%st(1)
    6223:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    6226:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    622d:	eb 5e                	jmp    628d <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    622f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6236:	eb 47                	jmp    627f <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    6238:	db 45 f8             	fildl  -0x8(%ebp)
    623b:	d8 4d f4             	fmuls  -0xc(%ebp)
    623e:	d9 7d ee             	fnstcw -0x12(%ebp)
    6241:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    6245:	b4 0c                	mov    $0xc,%ah
    6247:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    624b:	d9 6d ec             	fldcw  -0x14(%ebp)
    624e:	db 5d e8             	fistpl -0x18(%ebp)
    6251:	d9 6d ee             	fldcw  -0x12(%ebp)
    6254:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6257:	db 45 fc             	fildl  -0x4(%ebp)
    625a:	d8 4d f0             	fmuls  -0x10(%ebp)
    625d:	d9 6d ec             	fldcw  -0x14(%ebp)
    6260:	db 5d e8             	fistpl -0x18(%ebp)
    6263:	d9 6d ee             	fldcw  -0x12(%ebp)
    6266:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6269:	6a 00                	push   $0x0
    626b:	52                   	push   %edx
    626c:	50                   	push   %eax
    626d:	ff 75 08             	pushl  0x8(%ebp)
    6270:	e8 10 f9 ff ff       	call   5b85 <getColor>
    6275:	83 c4 10             	add    $0x10,%esp
    6278:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    627b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    627f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6282:	8b 00                	mov    (%eax),%eax
    6284:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6287:	7f af                	jg     6238 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    6289:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    628d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6290:	8b 40 04             	mov    0x4(%eax),%eax
    6293:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6296:	7f 97                	jg     622f <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    6298:	b8 01 00 00 00       	mov    $0x1,%eax
}
    629d:	c9                   	leave  
    629e:	c3                   	ret    

0000629f <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    629f:	55                   	push   %ebp
    62a0:	89 e5                	mov    %esp,%ebp
    62a2:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    62a5:	8b 45 08             	mov    0x8(%ebp),%eax
    62a8:	8b 00                	mov    (%eax),%eax
    62aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
    62ad:	db 45 e0             	fildl  -0x20(%ebp)
    62b0:	d9 5d e0             	fstps  -0x20(%ebp)
    62b3:	83 ec 0c             	sub    $0xc,%esp
    62b6:	ff 75 10             	pushl  0x10(%ebp)
    62b9:	e8 6b e2 ff ff       	call   4529 <cos>
    62be:	83 c4 10             	add    $0x10,%esp
    62c1:	d9 5d dc             	fstps  -0x24(%ebp)
    62c4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    62c7:	83 ec 0c             	sub    $0xc,%esp
    62ca:	50                   	push   %eax
    62cb:	e8 90 e1 ff ff       	call   4460 <abs>
    62d0:	83 c4 10             	add    $0x10,%esp
    62d3:	d8 4d e0             	fmuls  -0x20(%ebp)
    62d6:	d9 5d e0             	fstps  -0x20(%ebp)
    62d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    62dc:	8b 00                	mov    (%eax),%eax
    62de:	89 45 dc             	mov    %eax,-0x24(%ebp)
    62e1:	db 45 dc             	fildl  -0x24(%ebp)
    62e4:	d9 5d dc             	fstps  -0x24(%ebp)
    62e7:	83 ec 0c             	sub    $0xc,%esp
    62ea:	ff 75 10             	pushl  0x10(%ebp)
    62ed:	e8 da e3 ff ff       	call   46cc <sin>
    62f2:	83 c4 10             	add    $0x10,%esp
    62f5:	d9 5d d8             	fstps  -0x28(%ebp)
    62f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    62fb:	83 ec 0c             	sub    $0xc,%esp
    62fe:	50                   	push   %eax
    62ff:	e8 5c e1 ff ff       	call   4460 <abs>
    6304:	83 c4 10             	add    $0x10,%esp
    6307:	d8 4d dc             	fmuls  -0x24(%ebp)
    630a:	d8 45 e0             	fadds  -0x20(%ebp)
    630d:	d9 7d e6             	fnstcw -0x1a(%ebp)
    6310:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    6314:	b4 0c                	mov    $0xc,%ah
    6316:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    631a:	d9 6d e4             	fldcw  -0x1c(%ebp)
    631d:	db 5d f4             	fistpl -0xc(%ebp)
    6320:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    6323:	8b 45 08             	mov    0x8(%ebp),%eax
    6326:	8b 00                	mov    (%eax),%eax
    6328:	89 45 e0             	mov    %eax,-0x20(%ebp)
    632b:	db 45 e0             	fildl  -0x20(%ebp)
    632e:	d9 5d e0             	fstps  -0x20(%ebp)
    6331:	83 ec 0c             	sub    $0xc,%esp
    6334:	ff 75 10             	pushl  0x10(%ebp)
    6337:	e8 90 e3 ff ff       	call   46cc <sin>
    633c:	83 c4 10             	add    $0x10,%esp
    633f:	d9 5d dc             	fstps  -0x24(%ebp)
    6342:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6345:	83 ec 0c             	sub    $0xc,%esp
    6348:	50                   	push   %eax
    6349:	e8 12 e1 ff ff       	call   4460 <abs>
    634e:	83 c4 10             	add    $0x10,%esp
    6351:	d8 4d e0             	fmuls  -0x20(%ebp)
    6354:	d9 5d e0             	fstps  -0x20(%ebp)
    6357:	8b 45 0c             	mov    0xc(%ebp),%eax
    635a:	8b 00                	mov    (%eax),%eax
    635c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    635f:	db 45 dc             	fildl  -0x24(%ebp)
    6362:	d9 5d dc             	fstps  -0x24(%ebp)
    6365:	83 ec 0c             	sub    $0xc,%esp
    6368:	ff 75 10             	pushl  0x10(%ebp)
    636b:	e8 b9 e1 ff ff       	call   4529 <cos>
    6370:	83 c4 10             	add    $0x10,%esp
    6373:	d9 5d d8             	fstps  -0x28(%ebp)
    6376:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6379:	83 ec 0c             	sub    $0xc,%esp
    637c:	50                   	push   %eax
    637d:	e8 de e0 ff ff       	call   4460 <abs>
    6382:	83 c4 10             	add    $0x10,%esp
    6385:	d8 4d dc             	fmuls  -0x24(%ebp)
    6388:	d8 45 e0             	fadds  -0x20(%ebp)
    638b:	d9 7d e6             	fnstcw -0x1a(%ebp)
    638e:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    6392:	b4 0c                	mov    $0xc,%ah
    6394:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    6398:	d9 6d e4             	fldcw  -0x1c(%ebp)
    639b:	db 5d f0             	fistpl -0x10(%ebp)
    639e:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    63a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    63a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    63a7:	89 10                	mov    %edx,(%eax)
    *width = w;
    63a9:	8b 45 08             	mov    0x8(%ebp),%eax
    63ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63af:	89 10                	mov    %edx,(%eax)
    return 1;
    63b1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    63b6:	c9                   	leave  
    63b7:	c3                   	ret    

000063b8 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    63b8:	55                   	push   %ebp
    63b9:	89 e5                	mov    %esp,%ebp
    63bb:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    63be:	8b 45 08             	mov    0x8(%ebp),%eax
    63c1:	8b 40 04             	mov    0x4(%eax),%eax
    63c4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    63c7:	db 45 c4             	fildl  -0x3c(%ebp)
    63ca:	d9 05 44 f0 01 00    	flds   0x1f044
    63d0:	de f9                	fdivrp %st,%st(1)
    63d2:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    63d5:	8b 45 08             	mov    0x8(%ebp),%eax
    63d8:	8b 00                	mov    (%eax),%eax
    63da:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    63dd:	db 45 c4             	fildl  -0x3c(%ebp)
    63e0:	d9 05 44 f0 01 00    	flds   0x1f044
    63e6:	de f9                	fdivrp %st,%st(1)
    63e8:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    63eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    63ee:	8b 50 04             	mov    0x4(%eax),%edx
    63f1:	8b 45 08             	mov    0x8(%ebp),%eax
    63f4:	8b 40 04             	mov    0x4(%eax),%eax
    63f7:	29 c2                	sub    %eax,%edx
    63f9:	89 d0                	mov    %edx,%eax
    63fb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    63fe:	db 45 c4             	fildl  -0x3c(%ebp)
    6401:	d9 05 44 f0 01 00    	flds   0x1f044
    6407:	de f9                	fdivrp %st,%st(1)
    6409:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    640c:	8b 45 0c             	mov    0xc(%ebp),%eax
    640f:	8b 10                	mov    (%eax),%edx
    6411:	8b 45 08             	mov    0x8(%ebp),%eax
    6414:	8b 00                	mov    (%eax),%eax
    6416:	29 c2                	sub    %eax,%edx
    6418:	89 d0                	mov    %edx,%eax
    641a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    641d:	db 45 c4             	fildl  -0x3c(%ebp)
    6420:	d9 05 44 f0 01 00    	flds   0x1f044
    6426:	de f9                	fdivrp %st,%st(1)
    6428:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    642b:	d9 45 10             	flds   0x10(%ebp)
    642e:	d9 e0                	fchs   
    6430:	83 ec 0c             	sub    $0xc,%esp
    6433:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    6437:	d9 1c 24             	fstps  (%esp)
    643a:	e8 ea e0 ff ff       	call   4529 <cos>
    643f:	83 c4 10             	add    $0x10,%esp
    6442:	d9 5d c4             	fstps  -0x3c(%ebp)
    6445:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6448:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    644b:	d9 45 10             	flds   0x10(%ebp)
    644e:	d9 e0                	fchs   
    6450:	83 ec 0c             	sub    $0xc,%esp
    6453:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    6457:	d9 1c 24             	fstps  (%esp)
    645a:	e8 6d e2 ff ff       	call   46cc <sin>
    645f:	83 c4 10             	add    $0x10,%esp
    6462:	d9 5d c4             	fstps  -0x3c(%ebp)
    6465:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6468:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    646b:	d9 ee                	fldz   
    646d:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    6470:	d9 ee                	fldz   
    6472:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    6475:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    647c:	e9 28 01 00 00       	jmp    65a9 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    6481:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6488:	e9 0a 01 00 00       	jmp    6597 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    648d:	db 45 f4             	fildl  -0xc(%ebp)
    6490:	d8 65 e4             	fsubs  -0x1c(%ebp)
    6493:	d8 65 ec             	fsubs  -0x14(%ebp)
    6496:	d8 4d dc             	fmuls  -0x24(%ebp)
    6499:	db 45 f0             	fildl  -0x10(%ebp)
    649c:	d8 65 e0             	fsubs  -0x20(%ebp)
    649f:	d8 65 e8             	fsubs  -0x18(%ebp)
    64a2:	d8 4d d8             	fmuls  -0x28(%ebp)
    64a5:	de c1                	faddp  %st,%st(1)
    64a7:	d8 45 ec             	fadds  -0x14(%ebp)
    64aa:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    64ad:	db 45 f0             	fildl  -0x10(%ebp)
    64b0:	d8 65 e0             	fsubs  -0x20(%ebp)
    64b3:	d8 65 e8             	fsubs  -0x18(%ebp)
    64b6:	d8 4d dc             	fmuls  -0x24(%ebp)
    64b9:	db 45 f4             	fildl  -0xc(%ebp)
    64bc:	d8 65 e4             	fsubs  -0x1c(%ebp)
    64bf:	d8 65 ec             	fsubs  -0x14(%ebp)
    64c2:	d8 4d d8             	fmuls  -0x28(%ebp)
    64c5:	de e9                	fsubrp %st,%st(1)
    64c7:	d8 45 e8             	fadds  -0x18(%ebp)
    64ca:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    64cd:	d9 45 d4             	flds   -0x2c(%ebp)
    64d0:	d9 ee                	fldz   
    64d2:	d9 c9                	fxch   %st(1)
    64d4:	df e9                	fucomip %st(1),%st
    64d6:	dd d8                	fstp   %st(0)
    64d8:	0f 93 c0             	setae  %al
    64db:	83 f0 01             	xor    $0x1,%eax
    64de:	84 c0                	test   %al,%al
    64e0:	75 52                	jne    6534 <picTurn+0x17c>
    64e2:	8b 45 08             	mov    0x8(%ebp),%eax
    64e5:	8b 40 04             	mov    0x4(%eax),%eax
    64e8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    64eb:	db 45 c4             	fildl  -0x3c(%ebp)
    64ee:	d9 45 d4             	flds   -0x2c(%ebp)
    64f1:	d9 c9                	fxch   %st(1)
    64f3:	df e9                	fucomip %st(1),%st
    64f5:	dd d8                	fstp   %st(0)
    64f7:	0f 97 c0             	seta   %al
    64fa:	83 f0 01             	xor    $0x1,%eax
    64fd:	84 c0                	test   %al,%al
    64ff:	75 33                	jne    6534 <picTurn+0x17c>
    6501:	d9 45 d0             	flds   -0x30(%ebp)
    6504:	d9 ee                	fldz   
    6506:	d9 c9                	fxch   %st(1)
    6508:	df e9                	fucomip %st(1),%st
    650a:	dd d8                	fstp   %st(0)
    650c:	0f 93 c0             	setae  %al
    650f:	83 f0 01             	xor    $0x1,%eax
    6512:	84 c0                	test   %al,%al
    6514:	75 1e                	jne    6534 <picTurn+0x17c>
    6516:	8b 45 08             	mov    0x8(%ebp),%eax
    6519:	8b 00                	mov    (%eax),%eax
    651b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    651e:	db 45 c4             	fildl  -0x3c(%ebp)
    6521:	d9 45 d0             	flds   -0x30(%ebp)
    6524:	d9 c9                	fxch   %st(1)
    6526:	df e9                	fucomip %st(1),%st
    6528:	dd d8                	fstp   %st(0)
    652a:	0f 97 c0             	seta   %al
    652d:	83 f0 01             	xor    $0x1,%eax
    6530:	84 c0                	test   %al,%al
    6532:	74 2f                	je     6563 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    6534:	8b 45 0c             	mov    0xc(%ebp),%eax
    6537:	8b 48 08             	mov    0x8(%eax),%ecx
    653a:	8b 45 0c             	mov    0xc(%ebp),%eax
    653d:	8b 00                	mov    (%eax),%eax
    653f:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    6543:	89 c2                	mov    %eax,%edx
    6545:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6548:	01 c2                	add    %eax,%edx
    654a:	89 d0                	mov    %edx,%eax
    654c:	01 c0                	add    %eax,%eax
    654e:	01 d0                	add    %edx,%eax
    6550:	01 c8                	add    %ecx,%eax
    6552:	83 ec 08             	sub    $0x8,%esp
    6555:	50                   	push   %eax
    6556:	68 2d 39 02 00       	push   $0x2392d
    655b:	e8 9f f6 ff ff       	call   5bff <setColor>
    6560:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    6563:	8b 45 0c             	mov    0xc(%ebp),%eax
    6566:	8b 48 08             	mov    0x8(%eax),%ecx
    6569:	8b 45 0c             	mov    0xc(%ebp),%eax
    656c:	8b 00                	mov    (%eax),%eax
    656e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    6572:	89 c2                	mov    %eax,%edx
    6574:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6577:	01 c2                	add    %eax,%edx
    6579:	89 d0                	mov    %edx,%eax
    657b:	01 c0                	add    %eax,%eax
    657d:	01 d0                	add    %edx,%eax
    657f:	01 c8                	add    %ecx,%eax
    6581:	50                   	push   %eax
    6582:	ff 75 d0             	pushl  -0x30(%ebp)
    6585:	ff 75 d4             	pushl  -0x2c(%ebp)
    6588:	ff 75 08             	pushl  0x8(%ebp)
    658b:	e8 9e f6 ff ff       	call   5c2e <mixColor>
    6590:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    6593:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6597:	8b 45 0c             	mov    0xc(%ebp),%eax
    659a:	8b 00                	mov    (%eax),%eax
    659c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    659f:	0f 8f e8 fe ff ff    	jg     648d <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    65a5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    65a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    65ac:	8b 40 04             	mov    0x4(%eax),%eax
    65af:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    65b2:	0f 8f c9 fe ff ff    	jg     6481 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    65b8:	b8 01 00 00 00       	mov    $0x1,%eax
}
    65bd:	c9                   	leave  
    65be:	c3                   	ret    

000065bf <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    65bf:	55                   	push   %ebp
    65c0:	89 e5                	mov    %esp,%ebp
    65c2:	53                   	push   %ebx
    65c3:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    65c6:	8b 45 08             	mov    0x8(%ebp),%eax
    65c9:	8b 10                	mov    (%eax),%edx
    65cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    65ce:	8b 00                	mov    (%eax),%eax
    65d0:	39 c2                	cmp    %eax,%edx
    65d2:	75 10                	jne    65e4 <picRollingOver+0x25>
    65d4:	8b 45 08             	mov    0x8(%ebp),%eax
    65d7:	8b 50 04             	mov    0x4(%eax),%edx
    65da:	8b 45 0c             	mov    0xc(%ebp),%eax
    65dd:	8b 40 04             	mov    0x4(%eax),%eax
    65e0:	39 c2                	cmp    %eax,%edx
    65e2:	74 0a                	je     65ee <picRollingOver+0x2f>
        return 0;
    65e4:	b8 00 00 00 00       	mov    $0x0,%eax
    65e9:	e9 88 00 00 00       	jmp    6676 <picRollingOver+0xb7>

    int h = src->height;
    65ee:	8b 45 08             	mov    0x8(%ebp),%eax
    65f1:	8b 40 04             	mov    0x4(%eax),%eax
    65f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    65f7:	8b 45 08             	mov    0x8(%ebp),%eax
    65fa:	8b 00                	mov    (%eax),%eax
    65fc:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    65ff:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6606:	eb 61                	jmp    6669 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    6608:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    660f:	eb 4c                	jmp    665d <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    6611:	8b 45 0c             	mov    0xc(%ebp),%eax
    6614:	8b 48 08             	mov    0x8(%eax),%ecx
    6617:	8b 45 f0             	mov    -0x10(%ebp),%eax
    661a:	2b 45 f8             	sub    -0x8(%ebp),%eax
    661d:	83 e8 01             	sub    $0x1,%eax
    6620:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    6624:	89 c2                	mov    %eax,%edx
    6626:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6629:	01 c2                	add    %eax,%edx
    662b:	89 d0                	mov    %edx,%eax
    662d:	01 c0                	add    %eax,%eax
    662f:	01 d0                	add    %edx,%eax
    6631:	01 c1                	add    %eax,%ecx
    6633:	8b 45 08             	mov    0x8(%ebp),%eax
    6636:	8b 58 08             	mov    0x8(%eax),%ebx
    6639:	8b 45 f8             	mov    -0x8(%ebp),%eax
    663c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    6640:	89 c2                	mov    %eax,%edx
    6642:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6645:	01 c2                	add    %eax,%edx
    6647:	89 d0                	mov    %edx,%eax
    6649:	01 c0                	add    %eax,%eax
    664b:	01 d0                	add    %edx,%eax
    664d:	01 d8                	add    %ebx,%eax
    664f:	51                   	push   %ecx
    6650:	50                   	push   %eax
    6651:	e8 a9 f5 ff ff       	call   5bff <setColor>
    6656:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    6659:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    665d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6660:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6663:	7c ac                	jl     6611 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    6665:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6669:	8b 45 f8             	mov    -0x8(%ebp),%eax
    666c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    666f:	7c 97                	jl     6608 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    6671:	b8 01 00 00 00       	mov    $0x1,%eax
}
    6676:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6679:	c9                   	leave  
    667a:	c3                   	ret    

0000667b <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    667b:	55                   	push   %ebp
    667c:	89 e5                	mov    %esp,%ebp
    667e:	53                   	push   %ebx
    667f:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    6682:	8b 45 08             	mov    0x8(%ebp),%eax
    6685:	8b 10                	mov    (%eax),%edx
    6687:	8b 45 0c             	mov    0xc(%ebp),%eax
    668a:	8b 00                	mov    (%eax),%eax
    668c:	39 c2                	cmp    %eax,%edx
    668e:	75 10                	jne    66a0 <picTurnAround+0x25>
    6690:	8b 45 08             	mov    0x8(%ebp),%eax
    6693:	8b 50 04             	mov    0x4(%eax),%edx
    6696:	8b 45 0c             	mov    0xc(%ebp),%eax
    6699:	8b 40 04             	mov    0x4(%eax),%eax
    669c:	39 c2                	cmp    %eax,%edx
    669e:	74 0a                	je     66aa <picTurnAround+0x2f>
        return 0;
    66a0:	b8 00 00 00 00       	mov    $0x0,%eax
    66a5:	e9 88 00 00 00       	jmp    6732 <picTurnAround+0xb7>

    int h = src->height;
    66aa:	8b 45 08             	mov    0x8(%ebp),%eax
    66ad:	8b 40 04             	mov    0x4(%eax),%eax
    66b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    66b3:	8b 45 08             	mov    0x8(%ebp),%eax
    66b6:	8b 00                	mov    (%eax),%eax
    66b8:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    66bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    66c2:	eb 61                	jmp    6725 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    66c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    66cb:	eb 4c                	jmp    6719 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    66cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    66d0:	8b 48 08             	mov    0x8(%eax),%ecx
    66d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    66d6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    66da:	89 c2                	mov    %eax,%edx
    66dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    66df:	2b 45 f4             	sub    -0xc(%ebp),%eax
    66e2:	01 c2                	add    %eax,%edx
    66e4:	89 d0                	mov    %edx,%eax
    66e6:	01 c0                	add    %eax,%eax
    66e8:	01 d0                	add    %edx,%eax
    66ea:	83 e8 03             	sub    $0x3,%eax
    66ed:	01 c1                	add    %eax,%ecx
    66ef:	8b 45 08             	mov    0x8(%ebp),%eax
    66f2:	8b 58 08             	mov    0x8(%eax),%ebx
    66f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    66f8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    66fc:	89 c2                	mov    %eax,%edx
    66fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6701:	01 c2                	add    %eax,%edx
    6703:	89 d0                	mov    %edx,%eax
    6705:	01 c0                	add    %eax,%eax
    6707:	01 d0                	add    %edx,%eax
    6709:	01 d8                	add    %ebx,%eax
    670b:	51                   	push   %ecx
    670c:	50                   	push   %eax
    670d:	e8 ed f4 ff ff       	call   5bff <setColor>
    6712:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    6715:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6719:	8b 45 f4             	mov    -0xc(%ebp),%eax
    671c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    671f:	7c ac                	jl     66cd <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    6721:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6725:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6728:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    672b:	7c 97                	jl     66c4 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    672d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    6732:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6735:	c9                   	leave  
    6736:	c3                   	ret    

00006737 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    6737:	55                   	push   %ebp
    6738:	89 e5                	mov    %esp,%ebp
    673a:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    673d:	83 ec 0c             	sub    $0xc,%esp
    6740:	ff 75 08             	pushl  0x8(%ebp)
    6743:	e8 c5 d5 ff ff       	call   3d0d <strlen>
    6748:	83 c4 10             	add    $0x10,%esp
    674b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    674e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6751:	8d 50 ff             	lea    -0x1(%eax),%edx
    6754:	8b 45 08             	mov    0x8(%ebp),%eax
    6757:	01 d0                	add    %edx,%eax
    6759:	0f b6 00             	movzbl (%eax),%eax
    675c:	3c 67                	cmp    $0x67,%al
    675e:	75 2b                	jne    678b <type+0x54>
    6760:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6763:	8d 50 fe             	lea    -0x2(%eax),%edx
    6766:	8b 45 08             	mov    0x8(%ebp),%eax
    6769:	01 d0                	add    %edx,%eax
    676b:	0f b6 00             	movzbl (%eax),%eax
    676e:	3c 70                	cmp    $0x70,%al
    6770:	75 19                	jne    678b <type+0x54>
    6772:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6775:	8d 50 fd             	lea    -0x3(%eax),%edx
    6778:	8b 45 08             	mov    0x8(%ebp),%eax
    677b:	01 d0                	add    %edx,%eax
    677d:	0f b6 00             	movzbl (%eax),%eax
    6780:	3c 6a                	cmp    $0x6a,%al
    6782:	75 07                	jne    678b <type+0x54>
    6784:	b8 00 00 00 00       	mov    $0x0,%eax
    6789:	eb 7f                	jmp    680a <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    678b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    678e:	8d 50 ff             	lea    -0x1(%eax),%edx
    6791:	8b 45 08             	mov    0x8(%ebp),%eax
    6794:	01 d0                	add    %edx,%eax
    6796:	0f b6 00             	movzbl (%eax),%eax
    6799:	3c 70                	cmp    $0x70,%al
    679b:	75 2b                	jne    67c8 <type+0x91>
    679d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    67a0:	8d 50 fe             	lea    -0x2(%eax),%edx
    67a3:	8b 45 08             	mov    0x8(%ebp),%eax
    67a6:	01 d0                	add    %edx,%eax
    67a8:	0f b6 00             	movzbl (%eax),%eax
    67ab:	3c 6d                	cmp    $0x6d,%al
    67ad:	75 19                	jne    67c8 <type+0x91>
    67af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    67b2:	8d 50 fd             	lea    -0x3(%eax),%edx
    67b5:	8b 45 08             	mov    0x8(%ebp),%eax
    67b8:	01 d0                	add    %edx,%eax
    67ba:	0f b6 00             	movzbl (%eax),%eax
    67bd:	3c 62                	cmp    $0x62,%al
    67bf:	75 07                	jne    67c8 <type+0x91>
    67c1:	b8 01 00 00 00       	mov    $0x1,%eax
    67c6:	eb 42                	jmp    680a <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    67c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    67cb:	8d 50 ff             	lea    -0x1(%eax),%edx
    67ce:	8b 45 08             	mov    0x8(%ebp),%eax
    67d1:	01 d0                	add    %edx,%eax
    67d3:	0f b6 00             	movzbl (%eax),%eax
    67d6:	3c 67                	cmp    $0x67,%al
    67d8:	75 2b                	jne    6805 <type+0xce>
    67da:	8b 45 f4             	mov    -0xc(%ebp),%eax
    67dd:	8d 50 fe             	lea    -0x2(%eax),%edx
    67e0:	8b 45 08             	mov    0x8(%ebp),%eax
    67e3:	01 d0                	add    %edx,%eax
    67e5:	0f b6 00             	movzbl (%eax),%eax
    67e8:	3c 6e                	cmp    $0x6e,%al
    67ea:	75 19                	jne    6805 <type+0xce>
    67ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    67ef:	8d 50 fd             	lea    -0x3(%eax),%edx
    67f2:	8b 45 08             	mov    0x8(%ebp),%eax
    67f5:	01 d0                	add    %edx,%eax
    67f7:	0f b6 00             	movzbl (%eax),%eax
    67fa:	3c 70                	cmp    $0x70,%al
    67fc:	75 07                	jne    6805 <type+0xce>
    67fe:	b8 02 00 00 00       	mov    $0x2,%eax
    6803:	eb 05                	jmp    680a <type+0xd3>
    else return NONE;
    6805:	b8 03 00 00 00       	mov    $0x3,%eax
}
    680a:	c9                   	leave  
    680b:	c3                   	ret    

0000680c <LoadBmp>:

PBitmap LoadBmp(char* filename){
    680c:	55                   	push   %ebp
    680d:	89 e5                	mov    %esp,%ebp
    680f:	56                   	push   %esi
    6810:	53                   	push   %ebx
    6811:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    6814:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    681b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    6822:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    6829:	83 ec 08             	sub    $0x8,%esp
    682c:	6a 00                	push   $0x0
    682e:	ff 75 0c             	pushl  0xc(%ebp)
    6831:	e8 d9 d6 ff ff       	call   3f0f <open>
    6836:	83 c4 10             	add    $0x10,%esp
    6839:	89 45 ec             	mov    %eax,-0x14(%ebp)
    683c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    6840:	79 2c                	jns    686e <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    6842:	83 ec 08             	sub    $0x8,%esp
    6845:	ff 75 0c             	pushl  0xc(%ebp)
    6848:	68 48 f0 01 00       	push   $0x1f048
    684d:	e8 24 d8 ff ff       	call   4076 <printf>
    6852:	83 c4 10             	add    $0x10,%esp
        return bmp;
    6855:	8b 45 08             	mov    0x8(%ebp),%eax
    6858:	8b 55 b8             	mov    -0x48(%ebp),%edx
    685b:	89 10                	mov    %edx,(%eax)
    685d:	8b 55 bc             	mov    -0x44(%ebp),%edx
    6860:	89 50 04             	mov    %edx,0x4(%eax)
    6863:	8b 55 c0             	mov    -0x40(%ebp),%edx
    6866:	89 50 08             	mov    %edx,0x8(%eax)
    6869:	e9 2d 02 00 00       	jmp    6a9b <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    686e:	83 ec 04             	sub    $0x4,%esp
    6871:	6a 0e                	push   $0xe
    6873:	8d 45 aa             	lea    -0x56(%ebp),%eax
    6876:	50                   	push   %eax
    6877:	ff 75 ec             	pushl  -0x14(%ebp)
    687a:	e8 68 d6 ff ff       	call   3ee7 <read>
    687f:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    6882:	83 ec 04             	sub    $0x4,%esp
    6885:	6a 28                	push   $0x28
    6887:	8d 45 82             	lea    -0x7e(%ebp),%eax
    688a:	50                   	push   %eax
    688b:	ff 75 ec             	pushl  -0x14(%ebp)
    688e:	e8 54 d6 ff ff       	call   3ee7 <read>
    6893:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    6896:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    689a:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    689d:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    68a1:	0f b7 d8             	movzwl %ax,%ebx
    68a4:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    68a7:	8b 55 ac             	mov    -0x54(%ebp),%edx
    68aa:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    68ae:	0f b7 c0             	movzwl %ax,%eax
    68b1:	83 ec 04             	sub    $0x4,%esp
    68b4:	6a 36                	push   $0x36
    68b6:	56                   	push   %esi
    68b7:	53                   	push   %ebx
    68b8:	51                   	push   %ecx
    68b9:	52                   	push   %edx
    68ba:	50                   	push   %eax
    68bb:	68 58 f0 01 00       	push   $0x1f058
    68c0:	e8 b1 d7 ff ff       	call   4076 <printf>
    68c5:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    68c8:	8b 45 86             	mov    -0x7a(%ebp),%eax
    68cb:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    68ce:	8b 45 8a             	mov    -0x76(%ebp),%eax
    68d1:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    68d4:	8b 55 b8             	mov    -0x48(%ebp),%edx
    68d7:	8b 45 bc             	mov    -0x44(%ebp),%eax
    68da:	0f af c2             	imul   %edx,%eax
    68dd:	89 c2                	mov    %eax,%edx
    68df:	89 d0                	mov    %edx,%eax
    68e1:	01 c0                	add    %eax,%eax
    68e3:	01 d0                	add    %edx,%eax
    68e5:	83 ec 0c             	sub    $0xc,%esp
    68e8:	50                   	push   %eax
    68e9:	e8 5b da ff ff       	call   4349 <malloc>
    68ee:	83 c4 10             	add    $0x10,%esp
    68f1:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    68f4:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    68f8:	0f b7 c0             	movzwl %ax,%eax
    68fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    68fe:	8b 45 b8             	mov    -0x48(%ebp),%eax
    6901:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    6905:	83 c0 1f             	add    $0x1f,%eax
    6908:	c1 f8 05             	sar    $0x5,%eax
    690b:	c1 e0 02             	shl    $0x2,%eax
    690e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    6911:	8b 45 bc             	mov    -0x44(%ebp),%eax
    6914:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    6918:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    691b:	8b 55 bc             	mov    -0x44(%ebp),%edx
    691e:	8b 45 b8             	mov    -0x48(%ebp),%eax
    6921:	83 ec 08             	sub    $0x8,%esp
    6924:	52                   	push   %edx
    6925:	50                   	push   %eax
    6926:	ff 75 e8             	pushl  -0x18(%ebp)
    6929:	ff 75 e0             	pushl  -0x20(%ebp)
    692c:	ff 75 e4             	pushl  -0x1c(%ebp)
    692f:	68 80 f0 01 00       	push   $0x1f080
    6934:	e8 3d d7 ff ff       	call   4076 <printf>
    6939:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    693c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    693f:	83 e8 36             	sub    $0x36,%eax
    6942:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    6945:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6948:	83 ec 0c             	sub    $0xc,%esp
    694b:	50                   	push   %eax
    694c:	e8 f8 d9 ff ff       	call   4349 <malloc>
    6951:	83 c4 10             	add    $0x10,%esp
    6954:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    6957:	83 ec 04             	sub    $0x4,%esp
    695a:	ff 75 dc             	pushl  -0x24(%ebp)
    695d:	ff 75 d8             	pushl  -0x28(%ebp)
    6960:	ff 75 ec             	pushl  -0x14(%ebp)
    6963:	e8 7f d5 ff ff       	call   3ee7 <read>
    6968:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    696b:	8b 45 ac             	mov    -0x54(%ebp),%eax
    696e:	83 ec 0c             	sub    $0xc,%esp
    6971:	50                   	push   %eax
    6972:	e8 d2 d9 ff ff       	call   4349 <malloc>
    6977:	83 c4 10             	add    $0x10,%esp
    697a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    697d:	8b 45 ac             	mov    -0x54(%ebp),%eax
    6980:	83 ec 04             	sub    $0x4,%esp
    6983:	50                   	push   %eax
    6984:	ff 75 d4             	pushl  -0x2c(%ebp)
    6987:	ff 75 ec             	pushl  -0x14(%ebp)
    698a:	e8 58 d5 ff ff       	call   3ee7 <read>
    698f:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    6992:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    6996:	66 c1 e8 03          	shr    $0x3,%ax
    699a:	0f b7 c0             	movzwl %ax,%eax
    699d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    69a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    69a7:	e9 c1 00 00 00       	jmp    6a6d <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    69ac:	8b 45 bc             	mov    -0x44(%ebp),%eax
    69af:	2b 45 f4             	sub    -0xc(%ebp),%eax
    69b2:	8d 50 ff             	lea    -0x1(%eax),%edx
    69b5:	8b 45 b8             	mov    -0x48(%ebp),%eax
    69b8:	0f af c2             	imul   %edx,%eax
    69bb:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    69be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    69c1:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    69c5:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    69c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    69cf:	e9 89 00 00 00       	jmp    6a5d <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    69d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    69d7:	83 c0 01             	add    $0x1,%eax
    69da:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    69de:	89 c2                	mov    %eax,%edx
    69e0:	8b 45 c8             	mov    -0x38(%ebp),%eax
    69e3:	01 d0                	add    %edx,%eax
    69e5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    69e8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    69eb:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    69ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    69f1:	01 c8                	add    %ecx,%eax
    69f3:	89 c1                	mov    %eax,%ecx
    69f5:	89 c8                	mov    %ecx,%eax
    69f7:	01 c0                	add    %eax,%eax
    69f9:	01 c8                	add    %ecx,%eax
    69fb:	01 c2                	add    %eax,%edx
    69fd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6a00:	8d 48 ff             	lea    -0x1(%eax),%ecx
    6a03:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6a06:	01 c8                	add    %ecx,%eax
    6a08:	0f b6 00             	movzbl (%eax),%eax
    6a0b:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    6a0e:	8b 55 c0             	mov    -0x40(%ebp),%edx
    6a11:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    6a14:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a17:	01 c8                	add    %ecx,%eax
    6a19:	89 c1                	mov    %eax,%ecx
    6a1b:	89 c8                	mov    %ecx,%eax
    6a1d:	01 c0                	add    %eax,%eax
    6a1f:	01 c8                	add    %ecx,%eax
    6a21:	01 c2                	add    %eax,%edx
    6a23:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6a26:	8d 48 fe             	lea    -0x2(%eax),%ecx
    6a29:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6a2c:	01 c8                	add    %ecx,%eax
    6a2e:	0f b6 00             	movzbl (%eax),%eax
    6a31:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    6a34:	8b 55 c0             	mov    -0x40(%ebp),%edx
    6a37:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    6a3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a3d:	01 c8                	add    %ecx,%eax
    6a3f:	89 c1                	mov    %eax,%ecx
    6a41:	89 c8                	mov    %ecx,%eax
    6a43:	01 c0                	add    %eax,%eax
    6a45:	01 c8                	add    %ecx,%eax
    6a47:	01 c2                	add    %eax,%edx
    6a49:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6a4c:	8d 48 fd             	lea    -0x3(%eax),%ecx
    6a4f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6a52:	01 c8                	add    %ecx,%eax
    6a54:	0f b6 00             	movzbl (%eax),%eax
    6a57:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    6a59:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    6a5d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    6a60:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6a63:	0f 8f 6b ff ff ff    	jg     69d4 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    6a69:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6a6d:	8b 45 bc             	mov    -0x44(%ebp),%eax
    6a70:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    6a73:	0f 8f 33 ff ff ff    	jg     69ac <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    6a79:	83 ec 0c             	sub    $0xc,%esp
    6a7c:	ff 75 ec             	pushl  -0x14(%ebp)
    6a7f:	e8 73 d4 ff ff       	call   3ef7 <close>
    6a84:	83 c4 10             	add    $0x10,%esp
    return bmp;
    6a87:	8b 45 08             	mov    0x8(%ebp),%eax
    6a8a:	8b 55 b8             	mov    -0x48(%ebp),%edx
    6a8d:	89 10                	mov    %edx,(%eax)
    6a8f:	8b 55 bc             	mov    -0x44(%ebp),%edx
    6a92:	89 50 04             	mov    %edx,0x4(%eax)
    6a95:	8b 55 c0             	mov    -0x40(%ebp),%edx
    6a98:	89 50 08             	mov    %edx,0x8(%eax)
}
    6a9b:	8b 45 08             	mov    0x8(%ebp),%eax
    6a9e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    6aa1:	5b                   	pop    %ebx
    6aa2:	5e                   	pop    %esi
    6aa3:	5d                   	pop    %ebp
    6aa4:	c2 04 00             	ret    $0x4

00006aa7 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    6aa7:	55                   	push   %ebp
    6aa8:	89 e5                	mov    %esp,%ebp
    6aaa:	53                   	push   %ebx
    6aab:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    6aae:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    6ab2:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    6ab6:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    6aba:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    6abe:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    6ac2:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    6ac6:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    6aca:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    6ace:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    6ad2:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    6ad6:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    6ada:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    6ade:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    6ae2:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    6ae6:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    6aea:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    6aee:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    6af2:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    6af6:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    6afa:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    6afe:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    6b02:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    6b06:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    6b0a:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    6b0e:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    6b12:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    6b16:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    6b1a:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    6b1e:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    6b22:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    6b26:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    6b2a:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    6b2e:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    6b32:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    6b36:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    6b3a:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    6b3e:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    6b42:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    6b46:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    6b4a:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    6b4e:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    6b52:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    6b56:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    6b5a:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    6b5e:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    6b62:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    6b66:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    6b6a:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    6b6e:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    6b72:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    6b76:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    6b7a:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    6b7e:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    6b82:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    6b86:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    6b8a:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    6b8e:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    6b92:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    6b96:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    6b9a:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    6b9e:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    6ba2:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    6ba6:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    6baa:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    6bae:	83 ec 0c             	sub    $0xc,%esp
    6bb1:	68 c8 02 08 00       	push   $0x802c8
    6bb6:	e8 8e d7 ff ff       	call   4349 <malloc>
    6bbb:	83 c4 10             	add    $0x10,%esp
    6bbe:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    6bc1:	83 ec 04             	sub    $0x4,%esp
    6bc4:	68 c8 02 08 00       	push   $0x802c8
    6bc9:	6a 00                	push   $0x0
    6bcb:	ff 75 f0             	pushl  -0x10(%ebp)
    6bce:	e8 61 d1 ff ff       	call   3d34 <memset>
    6bd3:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    6bd6:	83 ec 08             	sub    $0x8,%esp
    6bd9:	6a 00                	push   $0x0
    6bdb:	ff 75 0c             	pushl  0xc(%ebp)
    6bde:	e8 2c d3 ff ff       	call   3f0f <open>
    6be3:	83 c4 10             	add    $0x10,%esp
    6be6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    6be9:	83 ec 0c             	sub    $0xc,%esp
    6bec:	68 40 42 0f 00       	push   $0xf4240
    6bf1:	e8 53 d7 ff ff       	call   4349 <malloc>
    6bf6:	83 c4 10             	add    $0x10,%esp
    6bf9:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    6bfc:	83 ec 04             	sub    $0x4,%esp
    6bff:	68 40 42 0f 00       	push   $0xf4240
    6c04:	ff 75 e8             	pushl  -0x18(%ebp)
    6c07:	ff 75 ec             	pushl  -0x14(%ebp)
    6c0a:	e8 d8 d2 ff ff       	call   3ee7 <read>
    6c0f:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    6c12:	83 ec 0c             	sub    $0xc,%esp
    6c15:	ff 75 ec             	pushl  -0x14(%ebp)
    6c18:	e8 da d2 ff ff       	call   3ef7 <close>
    6c1d:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    6c20:	68 40 42 0f 00       	push   $0xf4240
    6c25:	ff 75 e8             	pushl  -0x18(%ebp)
    6c28:	8d 45 9c             	lea    -0x64(%ebp),%eax
    6c2b:	50                   	push   %eax
    6c2c:	ff 75 f0             	pushl  -0x10(%ebp)
    6c2f:	e8 5e 0c 01 00       	call   17892 <_DecodeJPEG>
    6c34:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    6c37:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    6c3e:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    6c45:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    6c4c:	83 ec 0c             	sub    $0xc,%esp
    6c4f:	ff 75 f0             	pushl  -0x10(%ebp)
    6c52:	e8 29 0b 01 00       	call   17780 <GetImageSize>
    6c57:	83 c4 10             	add    $0x10,%esp
    6c5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    6c5d:	83 ec 0c             	sub    $0xc,%esp
    6c60:	ff 75 f0             	pushl  -0x10(%ebp)
    6c63:	e8 e1 0a 01 00       	call   17749 <GetImage>
    6c68:	83 c4 10             	add    $0x10,%esp
    6c6b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    6c6e:	83 ec 0c             	sub    $0xc,%esp
    6c71:	ff 75 f0             	pushl  -0x10(%ebp)
    6c74:	e8 f1 0a 01 00       	call   1776a <GetWidth>
    6c79:	83 c4 10             	add    $0x10,%esp
    6c7c:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    6c7f:	83 ec 0c             	sub    $0xc,%esp
    6c82:	ff 75 f0             	pushl  -0x10(%ebp)
    6c85:	e8 eb 0a 01 00       	call   17775 <GetHeight>
    6c8a:	83 c4 10             	add    $0x10,%esp
    6c8d:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    6c90:	8b 55 90             	mov    -0x70(%ebp),%edx
    6c93:	8b 45 94             	mov    -0x6c(%ebp),%eax
    6c96:	0f af c2             	imul   %edx,%eax
    6c99:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    6c9c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6c9f:	89 d0                	mov    %edx,%eax
    6ca1:	01 c0                	add    %eax,%eax
    6ca3:	01 d0                	add    %edx,%eax
    6ca5:	83 ec 0c             	sub    $0xc,%esp
    6ca8:	50                   	push   %eax
    6ca9:	e8 9b d6 ff ff       	call   4349 <malloc>
    6cae:	83 c4 10             	add    $0x10,%esp
    6cb1:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    6cb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6cbb:	e9 9c 00 00 00       	jmp    6d5c <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    6cc0:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    6cc3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    6cc6:	ba 56 55 55 55       	mov    $0x55555556,%edx
    6ccb:	89 c8                	mov    %ecx,%eax
    6ccd:	f7 ea                	imul   %edx
    6ccf:	89 c8                	mov    %ecx,%eax
    6cd1:	c1 f8 1f             	sar    $0x1f,%eax
    6cd4:	29 c2                	sub    %eax,%edx
    6cd6:	89 d0                	mov    %edx,%eax
    6cd8:	89 c2                	mov    %eax,%edx
    6cda:	89 d0                	mov    %edx,%eax
    6cdc:	01 c0                	add    %eax,%eax
    6cde:	01 d0                	add    %edx,%eax
    6ce0:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    6ce3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    6ce6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6ce9:	01 c8                	add    %ecx,%eax
    6ceb:	0f b6 00             	movzbl (%eax),%eax
    6cee:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    6cf1:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    6cf4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    6cf7:	ba 56 55 55 55       	mov    $0x55555556,%edx
    6cfc:	89 c8                	mov    %ecx,%eax
    6cfe:	f7 ea                	imul   %edx
    6d00:	89 c8                	mov    %ecx,%eax
    6d02:	c1 f8 1f             	sar    $0x1f,%eax
    6d05:	29 c2                	sub    %eax,%edx
    6d07:	89 d0                	mov    %edx,%eax
    6d09:	89 c2                	mov    %eax,%edx
    6d0b:	89 d0                	mov    %edx,%eax
    6d0d:	01 c0                	add    %eax,%eax
    6d0f:	01 d0                	add    %edx,%eax
    6d11:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    6d14:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d17:	8d 48 01             	lea    0x1(%eax),%ecx
    6d1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6d1d:	01 c8                	add    %ecx,%eax
    6d1f:	0f b6 00             	movzbl (%eax),%eax
    6d22:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    6d25:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    6d28:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    6d2b:	ba 56 55 55 55       	mov    $0x55555556,%edx
    6d30:	89 c8                	mov    %ecx,%eax
    6d32:	f7 ea                	imul   %edx
    6d34:	89 c8                	mov    %ecx,%eax
    6d36:	c1 f8 1f             	sar    $0x1f,%eax
    6d39:	29 c2                	sub    %eax,%edx
    6d3b:	89 d0                	mov    %edx,%eax
    6d3d:	89 c2                	mov    %eax,%edx
    6d3f:	89 d0                	mov    %edx,%eax
    6d41:	01 c0                	add    %eax,%eax
    6d43:	01 d0                	add    %edx,%eax
    6d45:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    6d48:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d4b:	8d 48 02             	lea    0x2(%eax),%ecx
    6d4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6d51:	01 c8                	add    %ecx,%eax
    6d53:	0f b6 00             	movzbl (%eax),%eax
    6d56:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    6d58:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    6d5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d5f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    6d62:	0f 8c 58 ff ff ff    	jl     6cc0 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    6d68:	8b 45 08             	mov    0x8(%ebp),%eax
    6d6b:	8b 55 90             	mov    -0x70(%ebp),%edx
    6d6e:	89 10                	mov    %edx,(%eax)
    6d70:	8b 55 94             	mov    -0x6c(%ebp),%edx
    6d73:	89 50 04             	mov    %edx,0x4(%eax)
    6d76:	8b 55 98             	mov    -0x68(%ebp),%edx
    6d79:	89 50 08             	mov    %edx,0x8(%eax)
}
    6d7c:	8b 45 08             	mov    0x8(%ebp),%eax
    6d7f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6d82:	c9                   	leave  
    6d83:	c2 04 00             	ret    $0x4

00006d86 <LoadPng>:

PBitmap LoadPng(char* filename){
    6d86:	55                   	push   %ebp
    6d87:	89 e5                	mov    %esp,%ebp
    6d89:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    6d8c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    6d93:	ff 75 0c             	pushl  0xc(%ebp)
    6d96:	8d 45 e0             	lea    -0x20(%ebp),%eax
    6d99:	50                   	push   %eax
    6d9a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    6d9d:	50                   	push   %eax
    6d9e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6da1:	50                   	push   %eax
    6da2:	e8 d3 d3 00 00       	call   1417a <lodepng_decode24_file>
    6da7:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    6daa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6dad:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    6db0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6db3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    6db6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    6dbd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    6dc0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6dc3:	0f af c2             	imul   %edx,%eax
    6dc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    6dc9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6dcc:	89 d0                	mov    %edx,%eax
    6dce:	01 c0                	add    %eax,%eax
    6dd0:	01 d0                	add    %edx,%eax
    6dd2:	83 ec 0c             	sub    $0xc,%esp
    6dd5:	50                   	push   %eax
    6dd6:	e8 6e d5 ff ff       	call   4349 <malloc>
    6ddb:	83 c4 10             	add    $0x10,%esp
    6dde:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    6de1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6de8:	e9 87 00 00 00       	jmp    6e74 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    6ded:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6df0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6df3:	89 d0                	mov    %edx,%eax
    6df5:	01 c0                	add    %eax,%eax
    6df7:	01 d0                	add    %edx,%eax
    6df9:	01 c8                	add    %ecx,%eax
    6dfb:	0f b6 00             	movzbl (%eax),%eax
    6dfe:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    6e01:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6e04:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6e07:	89 d0                	mov    %edx,%eax
    6e09:	01 c0                	add    %eax,%eax
    6e0b:	01 d0                	add    %edx,%eax
    6e0d:	83 c0 01             	add    $0x1,%eax
    6e10:	01 c8                	add    %ecx,%eax
    6e12:	0f b6 00             	movzbl (%eax),%eax
    6e15:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    6e18:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6e1b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6e1e:	89 d0                	mov    %edx,%eax
    6e20:	01 c0                	add    %eax,%eax
    6e22:	01 d0                	add    %edx,%eax
    6e24:	83 c0 02             	add    $0x2,%eax
    6e27:	01 c8                	add    %ecx,%eax
    6e29:	0f b6 00             	movzbl (%eax),%eax
    6e2c:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    6e2f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    6e32:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6e35:	89 d0                	mov    %edx,%eax
    6e37:	01 c0                	add    %eax,%eax
    6e39:	01 d0                	add    %edx,%eax
    6e3b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    6e3e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    6e42:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    6e45:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    6e48:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6e4b:	89 d0                	mov    %edx,%eax
    6e4d:	01 c0                	add    %eax,%eax
    6e4f:	01 d0                	add    %edx,%eax
    6e51:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    6e54:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    6e58:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    6e5b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    6e5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6e61:	89 d0                	mov    %edx,%eax
    6e63:	01 c0                	add    %eax,%eax
    6e65:	01 d0                	add    %edx,%eax
    6e67:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    6e6a:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    6e6e:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    6e70:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6e77:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6e7a:	0f 8c 6d ff ff ff    	jl     6ded <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    6e80:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6e83:	83 ec 0c             	sub    $0xc,%esp
    6e86:	50                   	push   %eax
    6e87:	e8 7b d3 ff ff       	call   4207 <free>
    6e8c:	83 c4 10             	add    $0x10,%esp
    return bmp;
    6e8f:	8b 45 08             	mov    0x8(%ebp),%eax
    6e92:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    6e95:	89 10                	mov    %edx,(%eax)
    6e97:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6e9a:	89 50 04             	mov    %edx,0x4(%eax)
    6e9d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6ea0:	89 50 08             	mov    %edx,0x8(%eax)

}
    6ea3:	8b 45 08             	mov    0x8(%ebp),%eax
    6ea6:	c9                   	leave  
    6ea7:	c2 04 00             	ret    $0x4

00006eaa <LoadImg>:

PBitmap LoadImg(char* filename){
    6eaa:	55                   	push   %ebp
    6eab:	89 e5                	mov    %esp,%ebp
    6ead:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    6eb0:	83 ec 0c             	sub    $0xc,%esp
    6eb3:	ff 75 0c             	pushl  0xc(%ebp)
    6eb6:	e8 7c f8 ff ff       	call   6737 <type>
    6ebb:	83 c4 10             	add    $0x10,%esp
    6ebe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    6ec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6ec4:	83 f8 01             	cmp    $0x1,%eax
    6ec7:	74 1d                	je     6ee6 <LoadImg+0x3c>
    6ec9:	83 f8 02             	cmp    $0x2,%eax
    6ecc:	74 2c                	je     6efa <LoadImg+0x50>
    6ece:	85 c0                	test   %eax,%eax
    6ed0:	75 3c                	jne    6f0e <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    6ed2:	8b 45 08             	mov    0x8(%ebp),%eax
    6ed5:	83 ec 08             	sub    $0x8,%esp
    6ed8:	ff 75 0c             	pushl  0xc(%ebp)
    6edb:	50                   	push   %eax
    6edc:	e8 c6 fb ff ff       	call   6aa7 <LoadJpeg>
    6ee1:	83 c4 0c             	add    $0xc,%esp
    6ee4:	eb 3c                	jmp    6f22 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    6ee6:	8b 45 08             	mov    0x8(%ebp),%eax
    6ee9:	83 ec 08             	sub    $0x8,%esp
    6eec:	ff 75 0c             	pushl  0xc(%ebp)
    6eef:	50                   	push   %eax
    6ef0:	e8 17 f9 ff ff       	call   680c <LoadBmp>
    6ef5:	83 c4 0c             	add    $0xc,%esp
    6ef8:	eb 28                	jmp    6f22 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    6efa:	8b 45 08             	mov    0x8(%ebp),%eax
    6efd:	83 ec 08             	sub    $0x8,%esp
    6f00:	ff 75 0c             	pushl  0xc(%ebp)
    6f03:	50                   	push   %eax
    6f04:	e8 7d fe ff ff       	call   6d86 <LoadPng>
    6f09:	83 c4 0c             	add    $0xc,%esp
    6f0c:	eb 14                	jmp    6f22 <LoadImg+0x78>

        default: return bmp;
    6f0e:	8b 45 08             	mov    0x8(%ebp),%eax
    6f11:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f14:	89 10                	mov    %edx,(%eax)
    6f16:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6f19:	89 50 04             	mov    %edx,0x4(%eax)
    6f1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6f1f:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    6f22:	8b 45 08             	mov    0x8(%ebp),%eax
    6f25:	c9                   	leave  
    6f26:	c2 04 00             	ret    $0x4

00006f29 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    6f29:	55                   	push   %ebp
    6f2a:	89 e5                	mov    %esp,%ebp
    6f2c:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    6f2f:	8b 45 08             	mov    0x8(%ebp),%eax
    6f32:	83 ec 0c             	sub    $0xc,%esp
    6f35:	50                   	push   %eax
    6f36:	e8 0e d4 ff ff       	call   4349 <malloc>
    6f3b:	83 c4 10             	add    $0x10,%esp
}
    6f3e:	c9                   	leave  
    6f3f:	c3                   	ret    

00006f40 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    6f40:	55                   	push   %ebp
    6f41:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    6f43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    6f48:	5d                   	pop    %ebp
    6f49:	c3                   	ret    

00006f4a <lodepng_free>:

static void lodepng_free(void* ptr) {
    6f4a:	55                   	push   %ebp
    6f4b:	89 e5                	mov    %esp,%ebp
    6f4d:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    6f50:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    6f54:	74 0e                	je     6f64 <lodepng_free+0x1a>
    free(ptr);
    6f56:	83 ec 0c             	sub    $0xc,%esp
    6f59:	ff 75 08             	pushl  0x8(%ebp)
    6f5c:	e8 a6 d2 ff ff       	call   4207 <free>
    6f61:	83 c4 10             	add    $0x10,%esp
}
    6f64:	90                   	nop
    6f65:	c9                   	leave  
    6f66:	c3                   	ret    

00006f67 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    6f67:	55                   	push   %ebp
    6f68:	89 e5                	mov    %esp,%ebp
    6f6a:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    6f6d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6f74:	eb 19                	jmp    6f8f <lodepng_memcpy+0x28>
    6f76:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6f79:	8b 45 08             	mov    0x8(%ebp),%eax
    6f7c:	01 c2                	add    %eax,%edx
    6f7e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6f81:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f84:	01 c8                	add    %ecx,%eax
    6f86:	0f b6 00             	movzbl (%eax),%eax
    6f89:	88 02                	mov    %al,(%edx)
    6f8b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6f8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6f92:	3b 45 10             	cmp    0x10(%ebp),%eax
    6f95:	7c df                	jl     6f76 <lodepng_memcpy+0xf>
}
    6f97:	90                   	nop
    6f98:	c9                   	leave  
    6f99:	c3                   	ret    

00006f9a <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    6f9a:	55                   	push   %ebp
    6f9b:	89 e5                	mov    %esp,%ebp
    6f9d:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    6fa0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6fa7:	eb 11                	jmp    6fba <lodepng_memset+0x20>
    6fa9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6fac:	8b 45 08             	mov    0x8(%ebp),%eax
    6faf:	01 d0                	add    %edx,%eax
    6fb1:	8b 55 0c             	mov    0xc(%ebp),%edx
    6fb4:	88 10                	mov    %dl,(%eax)
    6fb6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6fba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6fbd:	3b 45 10             	cmp    0x10(%ebp),%eax
    6fc0:	7c e7                	jl     6fa9 <lodepng_memset+0xf>
}
    6fc2:	90                   	nop
    6fc3:	c9                   	leave  
    6fc4:	c3                   	ret    

00006fc5 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    6fc5:	55                   	push   %ebp
    6fc6:	89 e5                	mov    %esp,%ebp
    6fc8:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    6fcb:	8b 45 08             	mov    0x8(%ebp),%eax
    6fce:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    6fd1:	eb 04                	jmp    6fd7 <lodepng_strlen+0x12>
    6fd3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6fd7:	8b 45 08             	mov    0x8(%ebp),%eax
    6fda:	0f b6 00             	movzbl (%eax),%eax
    6fdd:	84 c0                	test   %al,%al
    6fdf:	75 f2                	jne    6fd3 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    6fe1:	8b 55 08             	mov    0x8(%ebp),%edx
    6fe4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6fe7:	29 c2                	sub    %eax,%edx
    6fe9:	89 d0                	mov    %edx,%eax
}
    6feb:	c9                   	leave  
    6fec:	c3                   	ret    

00006fed <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    6fed:	55                   	push   %ebp
    6fee:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    6ff0:	8b 55 08             	mov    0x8(%ebp),%edx
    6ff3:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ff6:	01 c2                	add    %eax,%edx
    6ff8:	8b 45 10             	mov    0x10(%ebp),%eax
    6ffb:	89 10                	mov    %edx,(%eax)
  return *result < a;
    6ffd:	8b 45 10             	mov    0x10(%ebp),%eax
    7000:	8b 00                	mov    (%eax),%eax
    7002:	3b 45 08             	cmp    0x8(%ebp),%eax
    7005:	0f 9c c0             	setl   %al
    7008:	0f b6 c0             	movzbl %al,%eax
}
    700b:	5d                   	pop    %ebp
    700c:	c3                   	ret    

0000700d <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    700d:	55                   	push   %ebp
    700e:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    7010:	8b 45 08             	mov    0x8(%ebp),%eax
    7013:	0f af 45 0c          	imul   0xc(%ebp),%eax
    7017:	89 c2                	mov    %eax,%edx
    7019:	8b 45 10             	mov    0x10(%ebp),%eax
    701c:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    701e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    7022:	74 15                	je     7039 <lodepng_mulofl+0x2c>
    7024:	8b 45 10             	mov    0x10(%ebp),%eax
    7027:	8b 00                	mov    (%eax),%eax
    7029:	99                   	cltd   
    702a:	f7 7d 08             	idivl  0x8(%ebp)
    702d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7030:	74 07                	je     7039 <lodepng_mulofl+0x2c>
    7032:	b8 01 00 00 00       	mov    $0x1,%eax
    7037:	eb 05                	jmp    703e <lodepng_mulofl+0x31>
    7039:	b8 00 00 00 00       	mov    $0x0,%eax
}
    703e:	5d                   	pop    %ebp
    703f:	c3                   	ret    

00007040 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    7040:	55                   	push   %ebp
    7041:	89 e5                	mov    %esp,%ebp
    7043:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    7046:	8d 45 fc             	lea    -0x4(%ebp),%eax
    7049:	50                   	push   %eax
    704a:	ff 75 0c             	pushl  0xc(%ebp)
    704d:	ff 75 08             	pushl  0x8(%ebp)
    7050:	e8 98 ff ff ff       	call   6fed <lodepng_addofl>
    7055:	83 c4 0c             	add    $0xc,%esp
    7058:	85 c0                	test   %eax,%eax
    705a:	74 07                	je     7063 <lodepng_gtofl+0x23>
    705c:	b8 01 00 00 00       	mov    $0x1,%eax
    7061:	eb 0c                	jmp    706f <lodepng_gtofl+0x2f>
  return d > c;
    7063:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7066:	3b 45 10             	cmp    0x10(%ebp),%eax
    7069:	0f 9f c0             	setg   %al
    706c:	0f b6 c0             	movzbl %al,%eax
}
    706f:	c9                   	leave  
    7070:	c3                   	ret    

00007071 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    7071:	55                   	push   %ebp
    7072:	89 e5                	mov    %esp,%ebp
    7074:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    7077:	8b 45 08             	mov    0x8(%ebp),%eax
    707a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    7081:	8b 45 08             	mov    0x8(%ebp),%eax
    7084:	8b 50 08             	mov    0x8(%eax),%edx
    7087:	8b 45 08             	mov    0x8(%ebp),%eax
    708a:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    708d:	8b 45 08             	mov    0x8(%ebp),%eax
    7090:	8b 00                	mov    (%eax),%eax
    7092:	83 ec 0c             	sub    $0xc,%esp
    7095:	50                   	push   %eax
    7096:	e8 af fe ff ff       	call   6f4a <lodepng_free>
    709b:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    709e:	8b 45 08             	mov    0x8(%ebp),%eax
    70a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    70a7:	90                   	nop
    70a8:	c9                   	leave  
    70a9:	c3                   	ret    

000070aa <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    70aa:	55                   	push   %ebp
    70ab:	89 e5                	mov    %esp,%ebp
    70ad:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    70b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    70b3:	c1 e0 02             	shl    $0x2,%eax
    70b6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    70b9:	8b 45 08             	mov    0x8(%ebp),%eax
    70bc:	8b 40 08             	mov    0x8(%eax),%eax
    70bf:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    70c2:	7d 46                	jge    710a <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    70c4:	8b 45 08             	mov    0x8(%ebp),%eax
    70c7:	8b 40 08             	mov    0x8(%eax),%eax
    70ca:	d1 f8                	sar    %eax
    70cc:	89 c2                	mov    %eax,%edx
    70ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
    70d1:	01 d0                	add    %edx,%eax
    70d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    70d6:	8b 45 08             	mov    0x8(%ebp),%eax
    70d9:	8b 00                	mov    (%eax),%eax
    70db:	ff 75 f8             	pushl  -0x8(%ebp)
    70de:	50                   	push   %eax
    70df:	e8 5c fe ff ff       	call   6f40 <lodepng_realloc>
    70e4:	83 c4 08             	add    $0x8,%esp
    70e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    70ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    70ee:	74 13                	je     7103 <uivector_resize+0x59>
      p->allocsize = newsize;
    70f0:	8b 45 08             	mov    0x8(%ebp),%eax
    70f3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    70f6:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    70f9:	8b 45 08             	mov    0x8(%ebp),%eax
    70fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    70ff:	89 10                	mov    %edx,(%eax)
    7101:	eb 07                	jmp    710a <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    7103:	b8 00 00 00 00       	mov    $0x0,%eax
    7108:	eb 0e                	jmp    7118 <uivector_resize+0x6e>
  }
  p->size = size;
    710a:	8b 45 08             	mov    0x8(%ebp),%eax
    710d:	8b 55 0c             	mov    0xc(%ebp),%edx
    7110:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    7113:	b8 01 00 00 00       	mov    $0x1,%eax
}
    7118:	c9                   	leave  
    7119:	c3                   	ret    

0000711a <uivector_init>:

static void uivector_init(uivector* p) {
    711a:	55                   	push   %ebp
    711b:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    711d:	8b 45 08             	mov    0x8(%ebp),%eax
    7120:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    7126:	8b 45 08             	mov    0x8(%ebp),%eax
    7129:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    7130:	8b 45 08             	mov    0x8(%ebp),%eax
    7133:	8b 50 08             	mov    0x8(%eax),%edx
    7136:	8b 45 08             	mov    0x8(%ebp),%eax
    7139:	89 50 04             	mov    %edx,0x4(%eax)
}
    713c:	90                   	nop
    713d:	5d                   	pop    %ebp
    713e:	c3                   	ret    

0000713f <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    713f:	55                   	push   %ebp
    7140:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    7142:	8b 45 08             	mov    0x8(%ebp),%eax
    7145:	8b 40 04             	mov    0x4(%eax),%eax
    7148:	83 c0 01             	add    $0x1,%eax
    714b:	50                   	push   %eax
    714c:	ff 75 08             	pushl  0x8(%ebp)
    714f:	e8 56 ff ff ff       	call   70aa <uivector_resize>
    7154:	83 c4 08             	add    $0x8,%esp
    7157:	85 c0                	test   %eax,%eax
    7159:	75 07                	jne    7162 <uivector_push_back+0x23>
    715b:	b8 00 00 00 00       	mov    $0x0,%eax
    7160:	eb 1f                	jmp    7181 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    7162:	8b 45 08             	mov    0x8(%ebp),%eax
    7165:	8b 10                	mov    (%eax),%edx
    7167:	8b 45 08             	mov    0x8(%ebp),%eax
    716a:	8b 40 04             	mov    0x4(%eax),%eax
    716d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    7172:	c1 e0 02             	shl    $0x2,%eax
    7175:	01 c2                	add    %eax,%edx
    7177:	8b 45 0c             	mov    0xc(%ebp),%eax
    717a:	89 02                	mov    %eax,(%edx)
  return 1;
    717c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    7181:	c9                   	leave  
    7182:	c3                   	ret    

00007183 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    7183:	55                   	push   %ebp
    7184:	89 e5                	mov    %esp,%ebp
    7186:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    7189:	8b 45 08             	mov    0x8(%ebp),%eax
    718c:	8b 40 08             	mov    0x8(%eax),%eax
    718f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7192:	7d 46                	jge    71da <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    7194:	8b 45 08             	mov    0x8(%ebp),%eax
    7197:	8b 40 08             	mov    0x8(%eax),%eax
    719a:	d1 f8                	sar    %eax
    719c:	89 c2                	mov    %eax,%edx
    719e:	8b 45 0c             	mov    0xc(%ebp),%eax
    71a1:	01 d0                	add    %edx,%eax
    71a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    71a6:	8b 45 08             	mov    0x8(%ebp),%eax
    71a9:	8b 00                	mov    (%eax),%eax
    71ab:	ff 75 fc             	pushl  -0x4(%ebp)
    71ae:	50                   	push   %eax
    71af:	e8 8c fd ff ff       	call   6f40 <lodepng_realloc>
    71b4:	83 c4 08             	add    $0x8,%esp
    71b7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    71ba:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    71be:	74 13                	je     71d3 <ucvector_resize+0x50>
      p->allocsize = newsize;
    71c0:	8b 45 08             	mov    0x8(%ebp),%eax
    71c3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    71c6:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    71c9:	8b 45 08             	mov    0x8(%ebp),%eax
    71cc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    71cf:	89 10                	mov    %edx,(%eax)
    71d1:	eb 07                	jmp    71da <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    71d3:	b8 00 00 00 00       	mov    $0x0,%eax
    71d8:	eb 0e                	jmp    71e8 <ucvector_resize+0x65>
  }
  p->size = size;
    71da:	8b 45 08             	mov    0x8(%ebp),%eax
    71dd:	8b 55 0c             	mov    0xc(%ebp),%edx
    71e0:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    71e3:	b8 01 00 00 00       	mov    $0x1,%eax
}
    71e8:	c9                   	leave  
    71e9:	c3                   	ret    

000071ea <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    71ea:	55                   	push   %ebp
    71eb:	89 e5                	mov    %esp,%ebp
    71ed:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    71f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    71f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    71f6:	8b 45 10             	mov    0x10(%ebp),%eax
    71f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    71fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    71ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    7202:	8b 45 08             	mov    0x8(%ebp),%eax
    7205:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7208:	89 10                	mov    %edx,(%eax)
    720a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    720d:	89 50 04             	mov    %edx,0x4(%eax)
    7210:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7213:	89 50 08             	mov    %edx,0x8(%eax)
}
    7216:	8b 45 08             	mov    0x8(%ebp),%eax
    7219:	c9                   	leave  
    721a:	c2 04 00             	ret    $0x4

0000721d <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    721d:	55                   	push   %ebp
    721e:	89 e5                	mov    %esp,%ebp
    7220:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    7223:	8b 45 08             	mov    0x8(%ebp),%eax
    7226:	8b 00                	mov    (%eax),%eax
    7228:	83 ec 0c             	sub    $0xc,%esp
    722b:	50                   	push   %eax
    722c:	e8 19 fd ff ff       	call   6f4a <lodepng_free>
    7231:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    7234:	8b 45 08             	mov    0x8(%ebp),%eax
    7237:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    723d:	90                   	nop
    723e:	c9                   	leave  
    723f:	c3                   	ret    

00007240 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    7240:	55                   	push   %ebp
    7241:	89 e5                	mov    %esp,%ebp
    7243:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    7246:	8b 45 0c             	mov    0xc(%ebp),%eax
    7249:	83 c0 01             	add    $0x1,%eax
    724c:	83 ec 0c             	sub    $0xc,%esp
    724f:	50                   	push   %eax
    7250:	e8 d4 fc ff ff       	call   6f29 <lodepng_malloc>
    7255:	83 c4 10             	add    $0x10,%esp
    7258:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    725b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    725f:	74 1f                	je     7280 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    7261:	83 ec 04             	sub    $0x4,%esp
    7264:	ff 75 0c             	pushl  0xc(%ebp)
    7267:	ff 75 08             	pushl  0x8(%ebp)
    726a:	ff 75 f4             	pushl  -0xc(%ebp)
    726d:	e8 f5 fc ff ff       	call   6f67 <lodepng_memcpy>
    7272:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    7275:	8b 55 0c             	mov    0xc(%ebp),%edx
    7278:	8b 45 f4             	mov    -0xc(%ebp),%eax
    727b:	01 d0                	add    %edx,%eax
    727d:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    7280:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7283:	c9                   	leave  
    7284:	c3                   	ret    

00007285 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    7285:	55                   	push   %ebp
    7286:	89 e5                	mov    %esp,%ebp
    7288:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    728b:	ff 75 08             	pushl  0x8(%ebp)
    728e:	e8 32 fd ff ff       	call   6fc5 <lodepng_strlen>
    7293:	83 c4 04             	add    $0x4,%esp
    7296:	83 ec 08             	sub    $0x8,%esp
    7299:	50                   	push   %eax
    729a:	ff 75 08             	pushl  0x8(%ebp)
    729d:	e8 9e ff ff ff       	call   7240 <alloc_string_sized>
    72a2:	83 c4 10             	add    $0x10,%esp
}
    72a5:	c9                   	leave  
    72a6:	c3                   	ret    

000072a7 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    72a7:	55                   	push   %ebp
    72a8:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    72aa:	8b 45 08             	mov    0x8(%ebp),%eax
    72ad:	0f b6 00             	movzbl (%eax),%eax
    72b0:	0f b6 c0             	movzbl %al,%eax
    72b3:	c1 e0 18             	shl    $0x18,%eax
    72b6:	89 c2                	mov    %eax,%edx
    72b8:	8b 45 08             	mov    0x8(%ebp),%eax
    72bb:	83 c0 01             	add    $0x1,%eax
    72be:	0f b6 00             	movzbl (%eax),%eax
    72c1:	0f b6 c0             	movzbl %al,%eax
    72c4:	c1 e0 10             	shl    $0x10,%eax
    72c7:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    72c9:	8b 45 08             	mov    0x8(%ebp),%eax
    72cc:	83 c0 02             	add    $0x2,%eax
    72cf:	0f b6 00             	movzbl (%eax),%eax
    72d2:	0f b6 c0             	movzbl %al,%eax
    72d5:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    72d8:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    72da:	8b 45 08             	mov    0x8(%ebp),%eax
    72dd:	83 c0 03             	add    $0x3,%eax
    72e0:	0f b6 00             	movzbl (%eax),%eax
    72e3:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    72e6:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    72e8:	5d                   	pop    %ebp
    72e9:	c3                   	ret    

000072ea <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    72ea:	55                   	push   %ebp
    72eb:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    72ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    72f0:	c1 e8 18             	shr    $0x18,%eax
    72f3:	89 c2                	mov    %eax,%edx
    72f5:	8b 45 08             	mov    0x8(%ebp),%eax
    72f8:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    72fa:	8b 45 08             	mov    0x8(%ebp),%eax
    72fd:	83 c0 01             	add    $0x1,%eax
    7300:	8b 55 0c             	mov    0xc(%ebp),%edx
    7303:	c1 ea 10             	shr    $0x10,%edx
    7306:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    7308:	8b 45 08             	mov    0x8(%ebp),%eax
    730b:	83 c0 02             	add    $0x2,%eax
    730e:	8b 55 0c             	mov    0xc(%ebp),%edx
    7311:	c1 ea 08             	shr    $0x8,%edx
    7314:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    7316:	8b 45 08             	mov    0x8(%ebp),%eax
    7319:	83 c0 03             	add    $0x3,%eax
    731c:	8b 55 0c             	mov    0xc(%ebp),%edx
    731f:	88 10                	mov    %dl,(%eax)
}
    7321:	90                   	nop
    7322:	5d                   	pop    %ebp
    7323:	c3                   	ret    

00007324 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    7324:	55                   	push   %ebp
    7325:	89 e5                	mov    %esp,%ebp
    7327:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    732a:	83 ec 08             	sub    $0x8,%esp
    732d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    7330:	50                   	push   %eax
    7331:	ff 75 08             	pushl  0x8(%ebp)
    7334:	e8 b7 ca ff ff       	call   3df0 <stat>
    7339:	83 c4 10             	add    $0x10,%esp
  return s.size;
    733c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    733f:	c9                   	leave  
    7340:	c3                   	ret    

00007341 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    7341:	55                   	push   %ebp
    7342:	89 e5                	mov    %esp,%ebp
    7344:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    7347:	83 ec 08             	sub    $0x8,%esp
    734a:	6a 00                	push   $0x0
    734c:	ff 75 10             	pushl  0x10(%ebp)
    734f:	e8 bb cb ff ff       	call   3f0f <open>
    7354:	83 c4 10             	add    $0x10,%esp
    7357:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    735a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    735e:	79 07                	jns    7367 <lodepng_buffer_file+0x26>
  {
      return -1;
    7360:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    7365:	eb 19                	jmp    7380 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    7367:	83 ec 04             	sub    $0x4,%esp
    736a:	ff 75 0c             	pushl  0xc(%ebp)
    736d:	ff 75 08             	pushl  0x8(%ebp)
    7370:	ff 75 f4             	pushl  -0xc(%ebp)
    7373:	e8 6f cb ff ff       	call   3ee7 <read>
    7378:	83 c4 10             	add    $0x10,%esp
  return 0;
    737b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7380:	c9                   	leave  
    7381:	c3                   	ret    

00007382 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    7382:	55                   	push   %ebp
    7383:	89 e5                	mov    %esp,%ebp
    7385:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    7388:	83 ec 0c             	sub    $0xc,%esp
    738b:	ff 75 10             	pushl  0x10(%ebp)
    738e:	e8 91 ff ff ff       	call   7324 <lodepng_filesize>
    7393:	83 c4 10             	add    $0x10,%esp
    7396:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    7399:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    739d:	79 07                	jns    73a6 <lodepng_load_file+0x24>
    739f:	b8 4e 00 00 00       	mov    $0x4e,%eax
    73a4:	eb 4a                	jmp    73f0 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    73a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    73a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    73ac:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    73ae:	83 ec 0c             	sub    $0xc,%esp
    73b1:	ff 75 f4             	pushl  -0xc(%ebp)
    73b4:	e8 70 fb ff ff       	call   6f29 <lodepng_malloc>
    73b9:	83 c4 10             	add    $0x10,%esp
    73bc:	89 c2                	mov    %eax,%edx
    73be:	8b 45 08             	mov    0x8(%ebp),%eax
    73c1:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    73c3:	8b 45 08             	mov    0x8(%ebp),%eax
    73c6:	8b 00                	mov    (%eax),%eax
    73c8:	85 c0                	test   %eax,%eax
    73ca:	75 0d                	jne    73d9 <lodepng_load_file+0x57>
    73cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    73d0:	7e 07                	jle    73d9 <lodepng_load_file+0x57>
    73d2:	b8 53 00 00 00       	mov    $0x53,%eax
    73d7:	eb 17                	jmp    73f0 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    73d9:	8b 45 08             	mov    0x8(%ebp),%eax
    73dc:	8b 00                	mov    (%eax),%eax
    73de:	83 ec 04             	sub    $0x4,%esp
    73e1:	ff 75 10             	pushl  0x10(%ebp)
    73e4:	ff 75 f4             	pushl  -0xc(%ebp)
    73e7:	50                   	push   %eax
    73e8:	e8 54 ff ff ff       	call   7341 <lodepng_buffer_file>
    73ed:	83 c4 10             	add    $0x10,%esp
}
    73f0:	c9                   	leave  
    73f1:	c3                   	ret    

000073f2 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    73f2:	55                   	push   %ebp
    73f3:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    73f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    73fa:	5d                   	pop    %ebp
    73fb:	c3                   	ret    

000073fc <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    73fc:	55                   	push   %ebp
    73fd:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    73ff:	8b 45 08             	mov    0x8(%ebp),%eax
    7402:	8b 55 0c             	mov    0xc(%ebp),%edx
    7405:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    7407:	8b 45 08             	mov    0x8(%ebp),%eax
    740a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    740e:	90                   	nop
    740f:	5d                   	pop    %ebp
    7410:	c3                   	ret    

00007411 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    7411:	55                   	push   %ebp
    7412:	89 e5                	mov    %esp,%ebp
    7414:	56                   	push   %esi
    7415:	53                   	push   %ebx
    7416:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    7419:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    741d:	0f 85 aa 00 00 00    	jne    74cd <writeBits+0xbc>
    WRITEBIT(writer, value);
    7423:	8b 45 08             	mov    0x8(%ebp),%eax
    7426:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    742a:	0f b6 c0             	movzbl %al,%eax
    742d:	83 e0 07             	and    $0x7,%eax
    7430:	85 c0                	test   %eax,%eax
    7432:	75 39                	jne    746d <writeBits+0x5c>
    7434:	8b 45 08             	mov    0x8(%ebp),%eax
    7437:	8b 00                	mov    (%eax),%eax
    7439:	8b 40 04             	mov    0x4(%eax),%eax
    743c:	8d 50 01             	lea    0x1(%eax),%edx
    743f:	8b 45 08             	mov    0x8(%ebp),%eax
    7442:	8b 00                	mov    (%eax),%eax
    7444:	52                   	push   %edx
    7445:	50                   	push   %eax
    7446:	e8 38 fd ff ff       	call   7183 <ucvector_resize>
    744b:	83 c4 08             	add    $0x8,%esp
    744e:	85 c0                	test   %eax,%eax
    7450:	0f 84 44 01 00 00    	je     759a <writeBits+0x189>
    7456:	8b 45 08             	mov    0x8(%ebp),%eax
    7459:	8b 00                	mov    (%eax),%eax
    745b:	8b 10                	mov    (%eax),%edx
    745d:	8b 45 08             	mov    0x8(%ebp),%eax
    7460:	8b 00                	mov    (%eax),%eax
    7462:	8b 40 04             	mov    0x4(%eax),%eax
    7465:	83 e8 01             	sub    $0x1,%eax
    7468:	01 d0                	add    %edx,%eax
    746a:	c6 00 00             	movb   $0x0,(%eax)
    746d:	8b 45 08             	mov    0x8(%ebp),%eax
    7470:	8b 00                	mov    (%eax),%eax
    7472:	8b 10                	mov    (%eax),%edx
    7474:	8b 45 08             	mov    0x8(%ebp),%eax
    7477:	8b 00                	mov    (%eax),%eax
    7479:	8b 40 04             	mov    0x4(%eax),%eax
    747c:	83 e8 01             	sub    $0x1,%eax
    747f:	01 c2                	add    %eax,%edx
    7481:	8b 45 08             	mov    0x8(%ebp),%eax
    7484:	8b 00                	mov    (%eax),%eax
    7486:	8b 08                	mov    (%eax),%ecx
    7488:	8b 45 08             	mov    0x8(%ebp),%eax
    748b:	8b 00                	mov    (%eax),%eax
    748d:	8b 40 04             	mov    0x4(%eax),%eax
    7490:	83 e8 01             	sub    $0x1,%eax
    7493:	01 c8                	add    %ecx,%eax
    7495:	0f b6 00             	movzbl (%eax),%eax
    7498:	88 45 e7             	mov    %al,-0x19(%ebp)
    749b:	8b 45 08             	mov    0x8(%ebp),%eax
    749e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    74a2:	0f b6 c0             	movzbl %al,%eax
    74a5:	83 e0 07             	and    $0x7,%eax
    74a8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    74ab:	89 de                	mov    %ebx,%esi
    74ad:	89 c1                	mov    %eax,%ecx
    74af:	d3 e6                	shl    %cl,%esi
    74b1:	89 f0                	mov    %esi,%eax
    74b3:	0a 45 e7             	or     -0x19(%ebp),%al
    74b6:	88 02                	mov    %al,(%edx)
    74b8:	8b 45 08             	mov    0x8(%ebp),%eax
    74bb:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    74bf:	8d 50 01             	lea    0x1(%eax),%edx
    74c2:	8b 45 08             	mov    0x8(%ebp),%eax
    74c5:	88 50 04             	mov    %dl,0x4(%eax)
    74c8:	e9 d1 00 00 00       	jmp    759e <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    74cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    74d4:	e9 b3 00 00 00       	jmp    758c <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    74d9:	8b 45 08             	mov    0x8(%ebp),%eax
    74dc:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    74e0:	0f b6 c0             	movzbl %al,%eax
    74e3:	83 e0 07             	and    $0x7,%eax
    74e6:	85 c0                	test   %eax,%eax
    74e8:	75 39                	jne    7523 <writeBits+0x112>
    74ea:	8b 45 08             	mov    0x8(%ebp),%eax
    74ed:	8b 00                	mov    (%eax),%eax
    74ef:	8b 40 04             	mov    0x4(%eax),%eax
    74f2:	8d 50 01             	lea    0x1(%eax),%edx
    74f5:	8b 45 08             	mov    0x8(%ebp),%eax
    74f8:	8b 00                	mov    (%eax),%eax
    74fa:	52                   	push   %edx
    74fb:	50                   	push   %eax
    74fc:	e8 82 fc ff ff       	call   7183 <ucvector_resize>
    7501:	83 c4 08             	add    $0x8,%esp
    7504:	85 c0                	test   %eax,%eax
    7506:	0f 84 91 00 00 00    	je     759d <writeBits+0x18c>
    750c:	8b 45 08             	mov    0x8(%ebp),%eax
    750f:	8b 00                	mov    (%eax),%eax
    7511:	8b 10                	mov    (%eax),%edx
    7513:	8b 45 08             	mov    0x8(%ebp),%eax
    7516:	8b 00                	mov    (%eax),%eax
    7518:	8b 40 04             	mov    0x4(%eax),%eax
    751b:	83 e8 01             	sub    $0x1,%eax
    751e:	01 d0                	add    %edx,%eax
    7520:	c6 00 00             	movb   $0x0,(%eax)
    7523:	8b 45 08             	mov    0x8(%ebp),%eax
    7526:	8b 00                	mov    (%eax),%eax
    7528:	8b 10                	mov    (%eax),%edx
    752a:	8b 45 08             	mov    0x8(%ebp),%eax
    752d:	8b 00                	mov    (%eax),%eax
    752f:	8b 40 04             	mov    0x4(%eax),%eax
    7532:	83 e8 01             	sub    $0x1,%eax
    7535:	01 c2                	add    %eax,%edx
    7537:	8b 45 08             	mov    0x8(%ebp),%eax
    753a:	8b 00                	mov    (%eax),%eax
    753c:	8b 08                	mov    (%eax),%ecx
    753e:	8b 45 08             	mov    0x8(%ebp),%eax
    7541:	8b 00                	mov    (%eax),%eax
    7543:	8b 40 04             	mov    0x4(%eax),%eax
    7546:	83 e8 01             	sub    $0x1,%eax
    7549:	01 c8                	add    %ecx,%eax
    754b:	0f b6 00             	movzbl (%eax),%eax
    754e:	89 c6                	mov    %eax,%esi
    7550:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7553:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    7556:	89 c1                	mov    %eax,%ecx
    7558:	d3 eb                	shr    %cl,%ebx
    755a:	89 d8                	mov    %ebx,%eax
    755c:	83 e0 01             	and    $0x1,%eax
    755f:	89 c3                	mov    %eax,%ebx
    7561:	8b 45 08             	mov    0x8(%ebp),%eax
    7564:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    7568:	0f b6 c0             	movzbl %al,%eax
    756b:	83 e0 07             	and    $0x7,%eax
    756e:	89 c1                	mov    %eax,%ecx
    7570:	d3 e3                	shl    %cl,%ebx
    7572:	89 d8                	mov    %ebx,%eax
    7574:	09 f0                	or     %esi,%eax
    7576:	88 02                	mov    %al,(%edx)
    7578:	8b 45 08             	mov    0x8(%ebp),%eax
    757b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    757f:	8d 50 01             	lea    0x1(%eax),%edx
    7582:	8b 45 08             	mov    0x8(%ebp),%eax
    7585:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    7588:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    758c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    758f:	3b 45 10             	cmp    0x10(%ebp),%eax
    7592:	0f 85 41 ff ff ff    	jne    74d9 <writeBits+0xc8>
    7598:	eb 04                	jmp    759e <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    759a:	90                   	nop
    759b:	eb 01                	jmp    759e <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    759d:	90                   	nop
    }
  }
}
    759e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    75a1:	5b                   	pop    %ebx
    75a2:	5e                   	pop    %esi
    75a3:	5d                   	pop    %ebp
    75a4:	c3                   	ret    

000075a5 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    75a5:	55                   	push   %ebp
    75a6:	89 e5                	mov    %esp,%ebp
    75a8:	56                   	push   %esi
    75a9:	53                   	push   %ebx
    75aa:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    75ad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    75b4:	e9 bd 00 00 00       	jmp    7676 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    75b9:	8b 45 08             	mov    0x8(%ebp),%eax
    75bc:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    75c0:	0f b6 c0             	movzbl %al,%eax
    75c3:	83 e0 07             	and    $0x7,%eax
    75c6:	85 c0                	test   %eax,%eax
    75c8:	75 39                	jne    7603 <writeBitsReversed+0x5e>
    75ca:	8b 45 08             	mov    0x8(%ebp),%eax
    75cd:	8b 00                	mov    (%eax),%eax
    75cf:	8b 40 04             	mov    0x4(%eax),%eax
    75d2:	8d 50 01             	lea    0x1(%eax),%edx
    75d5:	8b 45 08             	mov    0x8(%ebp),%eax
    75d8:	8b 00                	mov    (%eax),%eax
    75da:	52                   	push   %edx
    75db:	50                   	push   %eax
    75dc:	e8 a2 fb ff ff       	call   7183 <ucvector_resize>
    75e1:	83 c4 08             	add    $0x8,%esp
    75e4:	85 c0                	test   %eax,%eax
    75e6:	0f 84 98 00 00 00    	je     7684 <writeBitsReversed+0xdf>
    75ec:	8b 45 08             	mov    0x8(%ebp),%eax
    75ef:	8b 00                	mov    (%eax),%eax
    75f1:	8b 10                	mov    (%eax),%edx
    75f3:	8b 45 08             	mov    0x8(%ebp),%eax
    75f6:	8b 00                	mov    (%eax),%eax
    75f8:	8b 40 04             	mov    0x4(%eax),%eax
    75fb:	83 e8 01             	sub    $0x1,%eax
    75fe:	01 d0                	add    %edx,%eax
    7600:	c6 00 00             	movb   $0x0,(%eax)
    7603:	8b 45 08             	mov    0x8(%ebp),%eax
    7606:	8b 00                	mov    (%eax),%eax
    7608:	8b 10                	mov    (%eax),%edx
    760a:	8b 45 08             	mov    0x8(%ebp),%eax
    760d:	8b 00                	mov    (%eax),%eax
    760f:	8b 40 04             	mov    0x4(%eax),%eax
    7612:	83 e8 01             	sub    $0x1,%eax
    7615:	01 c2                	add    %eax,%edx
    7617:	8b 45 08             	mov    0x8(%ebp),%eax
    761a:	8b 00                	mov    (%eax),%eax
    761c:	8b 08                	mov    (%eax),%ecx
    761e:	8b 45 08             	mov    0x8(%ebp),%eax
    7621:	8b 00                	mov    (%eax),%eax
    7623:	8b 40 04             	mov    0x4(%eax),%eax
    7626:	83 e8 01             	sub    $0x1,%eax
    7629:	01 c8                	add    %ecx,%eax
    762b:	0f b6 00             	movzbl (%eax),%eax
    762e:	89 c6                	mov    %eax,%esi
    7630:	8b 4d 10             	mov    0x10(%ebp),%ecx
    7633:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7636:	29 c1                	sub    %eax,%ecx
    7638:	89 c8                	mov    %ecx,%eax
    763a:	83 e8 01             	sub    $0x1,%eax
    763d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    7640:	89 c1                	mov    %eax,%ecx
    7642:	d3 eb                	shr    %cl,%ebx
    7644:	89 d8                	mov    %ebx,%eax
    7646:	83 e0 01             	and    $0x1,%eax
    7649:	89 c3                	mov    %eax,%ebx
    764b:	8b 45 08             	mov    0x8(%ebp),%eax
    764e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    7652:	0f b6 c0             	movzbl %al,%eax
    7655:	83 e0 07             	and    $0x7,%eax
    7658:	89 c1                	mov    %eax,%ecx
    765a:	d3 e3                	shl    %cl,%ebx
    765c:	89 d8                	mov    %ebx,%eax
    765e:	09 f0                	or     %esi,%eax
    7660:	88 02                	mov    %al,(%edx)
    7662:	8b 45 08             	mov    0x8(%ebp),%eax
    7665:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    7669:	8d 50 01             	lea    0x1(%eax),%edx
    766c:	8b 45 08             	mov    0x8(%ebp),%eax
    766f:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    7672:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7676:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7679:	3b 45 10             	cmp    0x10(%ebp),%eax
    767c:	0f 85 37 ff ff ff    	jne    75b9 <writeBitsReversed+0x14>
    7682:	eb 01                	jmp    7685 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    7684:	90                   	nop
  }
}
    7685:	8d 65 f8             	lea    -0x8(%ebp),%esp
    7688:	5b                   	pop    %ebx
    7689:	5e                   	pop    %esi
    768a:	5d                   	pop    %ebp
    768b:	c3                   	ret    

0000768c <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    768c:	55                   	push   %ebp
    768d:	89 e5                	mov    %esp,%ebp
    768f:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    7692:	8b 45 08             	mov    0x8(%ebp),%eax
    7695:	8b 55 0c             	mov    0xc(%ebp),%edx
    7698:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    769a:	8b 45 08             	mov    0x8(%ebp),%eax
    769d:	8b 55 10             	mov    0x10(%ebp),%edx
    76a0:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    76a3:	8b 45 08             	mov    0x8(%ebp),%eax
    76a6:	83 c0 08             	add    $0x8,%eax
    76a9:	50                   	push   %eax
    76aa:	6a 08                	push   $0x8
    76ac:	ff 75 10             	pushl  0x10(%ebp)
    76af:	e8 59 f9 ff ff       	call   700d <lodepng_mulofl>
    76b4:	83 c4 0c             	add    $0xc,%esp
    76b7:	85 c0                	test   %eax,%eax
    76b9:	74 07                	je     76c2 <LodePNGBitReader_init+0x36>
    76bb:	b8 69 00 00 00       	mov    $0x69,%eax
    76c0:	eb 39                	jmp    76fb <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    76c2:	8b 45 08             	mov    0x8(%ebp),%eax
    76c5:	8b 40 08             	mov    0x8(%eax),%eax
    76c8:	8d 55 fc             	lea    -0x4(%ebp),%edx
    76cb:	52                   	push   %edx
    76cc:	6a 40                	push   $0x40
    76ce:	50                   	push   %eax
    76cf:	e8 19 f9 ff ff       	call   6fed <lodepng_addofl>
    76d4:	83 c4 0c             	add    $0xc,%esp
    76d7:	85 c0                	test   %eax,%eax
    76d9:	74 07                	je     76e2 <LodePNGBitReader_init+0x56>
    76db:	b8 69 00 00 00       	mov    $0x69,%eax
    76e0:	eb 19                	jmp    76fb <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    76e2:	8b 45 08             	mov    0x8(%ebp),%eax
    76e5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    76ec:	8b 45 08             	mov    0x8(%ebp),%eax
    76ef:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    76f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    76fb:	c9                   	leave  
    76fc:	c3                   	ret    

000076fd <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    76fd:	55                   	push   %ebp
    76fe:	89 e5                	mov    %esp,%ebp
    7700:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    7703:	8b 45 08             	mov    0x8(%ebp),%eax
    7706:	8b 40 0c             	mov    0xc(%eax),%eax
    7709:	c1 f8 03             	sar    $0x3,%eax
    770c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    770f:	8b 45 08             	mov    0x8(%ebp),%eax
    7712:	8b 40 04             	mov    0x4(%eax),%eax
    7715:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    7718:	8b 45 fc             	mov    -0x4(%ebp),%eax
    771b:	8d 50 01             	lea    0x1(%eax),%edx
    771e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7721:	39 c2                	cmp    %eax,%edx
    7723:	73 4e                	jae    7773 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    7725:	8b 45 08             	mov    0x8(%ebp),%eax
    7728:	8b 10                	mov    (%eax),%edx
    772a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    772d:	01 d0                	add    %edx,%eax
    772f:	0f b6 00             	movzbl (%eax),%eax
    7732:	0f b6 d0             	movzbl %al,%edx
    7735:	8b 45 08             	mov    0x8(%ebp),%eax
    7738:	8b 00                	mov    (%eax),%eax
    773a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    773d:	83 c1 01             	add    $0x1,%ecx
    7740:	01 c8                	add    %ecx,%eax
    7742:	0f b6 00             	movzbl (%eax),%eax
    7745:	0f b6 c0             	movzbl %al,%eax
    7748:	c1 e0 08             	shl    $0x8,%eax
    774b:	09 c2                	or     %eax,%edx
    774d:	8b 45 08             	mov    0x8(%ebp),%eax
    7750:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    7753:	8b 45 08             	mov    0x8(%ebp),%eax
    7756:	8b 50 10             	mov    0x10(%eax),%edx
    7759:	8b 45 08             	mov    0x8(%ebp),%eax
    775c:	8b 40 0c             	mov    0xc(%eax),%eax
    775f:	83 e0 07             	and    $0x7,%eax
    7762:	89 c1                	mov    %eax,%ecx
    7764:	d3 ea                	shr    %cl,%edx
    7766:	8b 45 08             	mov    0x8(%ebp),%eax
    7769:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    776c:	b8 01 00 00 00       	mov    $0x1,%eax
    7771:	eb 64                	jmp    77d7 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    7773:	8b 45 08             	mov    0x8(%ebp),%eax
    7776:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    777d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7780:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7783:	39 c2                	cmp    %eax,%edx
    7785:	73 1e                	jae    77a5 <ensureBits9+0xa8>
    7787:	8b 45 08             	mov    0x8(%ebp),%eax
    778a:	8b 50 10             	mov    0x10(%eax),%edx
    778d:	8b 45 08             	mov    0x8(%ebp),%eax
    7790:	8b 08                	mov    (%eax),%ecx
    7792:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7795:	01 c8                	add    %ecx,%eax
    7797:	0f b6 00             	movzbl (%eax),%eax
    779a:	0f b6 c0             	movzbl %al,%eax
    779d:	09 c2                	or     %eax,%edx
    779f:	8b 45 08             	mov    0x8(%ebp),%eax
    77a2:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    77a5:	8b 45 08             	mov    0x8(%ebp),%eax
    77a8:	8b 50 10             	mov    0x10(%eax),%edx
    77ab:	8b 45 08             	mov    0x8(%ebp),%eax
    77ae:	8b 40 0c             	mov    0xc(%eax),%eax
    77b1:	83 e0 07             	and    $0x7,%eax
    77b4:	89 c1                	mov    %eax,%ecx
    77b6:	d3 ea                	shr    %cl,%edx
    77b8:	8b 45 08             	mov    0x8(%ebp),%eax
    77bb:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    77be:	8b 45 08             	mov    0x8(%ebp),%eax
    77c1:	8b 50 0c             	mov    0xc(%eax),%edx
    77c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    77c7:	01 c2                	add    %eax,%edx
    77c9:	8b 45 08             	mov    0x8(%ebp),%eax
    77cc:	8b 40 08             	mov    0x8(%eax),%eax
    77cf:	39 c2                	cmp    %eax,%edx
    77d1:	0f 9e c0             	setle  %al
    77d4:	0f b6 c0             	movzbl %al,%eax
  }
}
    77d7:	c9                   	leave  
    77d8:	c3                   	ret    

000077d9 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    77d9:	55                   	push   %ebp
    77da:	89 e5                	mov    %esp,%ebp
    77dc:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    77df:	8b 45 08             	mov    0x8(%ebp),%eax
    77e2:	8b 40 0c             	mov    0xc(%eax),%eax
    77e5:	c1 f8 03             	sar    $0x3,%eax
    77e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    77eb:	8b 45 08             	mov    0x8(%ebp),%eax
    77ee:	8b 40 04             	mov    0x4(%eax),%eax
    77f1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    77f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    77f7:	8d 50 02             	lea    0x2(%eax),%edx
    77fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    77fd:	39 c2                	cmp    %eax,%edx
    77ff:	73 6d                	jae    786e <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    7801:	8b 45 08             	mov    0x8(%ebp),%eax
    7804:	8b 10                	mov    (%eax),%edx
    7806:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7809:	01 d0                	add    %edx,%eax
    780b:	0f b6 00             	movzbl (%eax),%eax
    780e:	0f b6 d0             	movzbl %al,%edx
    7811:	8b 45 08             	mov    0x8(%ebp),%eax
    7814:	8b 00                	mov    (%eax),%eax
    7816:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7819:	83 c1 01             	add    $0x1,%ecx
    781c:	01 c8                	add    %ecx,%eax
    781e:	0f b6 00             	movzbl (%eax),%eax
    7821:	0f b6 c0             	movzbl %al,%eax
    7824:	c1 e0 08             	shl    $0x8,%eax
    7827:	89 d1                	mov    %edx,%ecx
    7829:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    782b:	8b 45 08             	mov    0x8(%ebp),%eax
    782e:	8b 00                	mov    (%eax),%eax
    7830:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7833:	83 c2 02             	add    $0x2,%edx
    7836:	01 d0                	add    %edx,%eax
    7838:	0f b6 00             	movzbl (%eax),%eax
    783b:	0f b6 c0             	movzbl %al,%eax
    783e:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    7841:	09 c1                	or     %eax,%ecx
    7843:	89 ca                	mov    %ecx,%edx
    7845:	8b 45 08             	mov    0x8(%ebp),%eax
    7848:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    784b:	8b 45 08             	mov    0x8(%ebp),%eax
    784e:	8b 50 10             	mov    0x10(%eax),%edx
    7851:	8b 45 08             	mov    0x8(%ebp),%eax
    7854:	8b 40 0c             	mov    0xc(%eax),%eax
    7857:	83 e0 07             	and    $0x7,%eax
    785a:	89 c1                	mov    %eax,%ecx
    785c:	d3 ea                	shr    %cl,%edx
    785e:	8b 45 08             	mov    0x8(%ebp),%eax
    7861:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    7864:	b8 01 00 00 00       	mov    $0x1,%eax
    7869:	e9 95 00 00 00       	jmp    7903 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    786e:	8b 45 08             	mov    0x8(%ebp),%eax
    7871:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    7878:	8b 55 fc             	mov    -0x4(%ebp),%edx
    787b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    787e:	39 c2                	cmp    %eax,%edx
    7880:	73 1e                	jae    78a0 <ensureBits17+0xc7>
    7882:	8b 45 08             	mov    0x8(%ebp),%eax
    7885:	8b 50 10             	mov    0x10(%eax),%edx
    7888:	8b 45 08             	mov    0x8(%ebp),%eax
    788b:	8b 08                	mov    (%eax),%ecx
    788d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7890:	01 c8                	add    %ecx,%eax
    7892:	0f b6 00             	movzbl (%eax),%eax
    7895:	0f b6 c0             	movzbl %al,%eax
    7898:	09 c2                	or     %eax,%edx
    789a:	8b 45 08             	mov    0x8(%ebp),%eax
    789d:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    78a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    78a3:	8d 50 01             	lea    0x1(%eax),%edx
    78a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    78a9:	39 c2                	cmp    %eax,%edx
    78ab:	73 24                	jae    78d1 <ensureBits17+0xf8>
    78ad:	8b 45 08             	mov    0x8(%ebp),%eax
    78b0:	8b 50 10             	mov    0x10(%eax),%edx
    78b3:	8b 45 08             	mov    0x8(%ebp),%eax
    78b6:	8b 00                	mov    (%eax),%eax
    78b8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    78bb:	83 c1 01             	add    $0x1,%ecx
    78be:	01 c8                	add    %ecx,%eax
    78c0:	0f b6 00             	movzbl (%eax),%eax
    78c3:	0f b6 c0             	movzbl %al,%eax
    78c6:	c1 e0 08             	shl    $0x8,%eax
    78c9:	09 c2                	or     %eax,%edx
    78cb:	8b 45 08             	mov    0x8(%ebp),%eax
    78ce:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    78d1:	8b 45 08             	mov    0x8(%ebp),%eax
    78d4:	8b 50 10             	mov    0x10(%eax),%edx
    78d7:	8b 45 08             	mov    0x8(%ebp),%eax
    78da:	8b 40 0c             	mov    0xc(%eax),%eax
    78dd:	83 e0 07             	and    $0x7,%eax
    78e0:	89 c1                	mov    %eax,%ecx
    78e2:	d3 ea                	shr    %cl,%edx
    78e4:	8b 45 08             	mov    0x8(%ebp),%eax
    78e7:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    78ea:	8b 45 08             	mov    0x8(%ebp),%eax
    78ed:	8b 50 0c             	mov    0xc(%eax),%edx
    78f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    78f3:	01 c2                	add    %eax,%edx
    78f5:	8b 45 08             	mov    0x8(%ebp),%eax
    78f8:	8b 40 08             	mov    0x8(%eax),%eax
    78fb:	39 c2                	cmp    %eax,%edx
    78fd:	0f 9e c0             	setle  %al
    7900:	0f b6 c0             	movzbl %al,%eax
  }
}
    7903:	c9                   	leave  
    7904:	c3                   	ret    

00007905 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    7905:	55                   	push   %ebp
    7906:	89 e5                	mov    %esp,%ebp
    7908:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    790b:	8b 45 08             	mov    0x8(%ebp),%eax
    790e:	8b 40 0c             	mov    0xc(%eax),%eax
    7911:	c1 f8 03             	sar    $0x3,%eax
    7914:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    7917:	8b 45 08             	mov    0x8(%ebp),%eax
    791a:	8b 40 04             	mov    0x4(%eax),%eax
    791d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    7920:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7923:	8d 50 03             	lea    0x3(%eax),%edx
    7926:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7929:	39 c2                	cmp    %eax,%edx
    792b:	0f 83 85 00 00 00    	jae    79b6 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    7931:	8b 45 08             	mov    0x8(%ebp),%eax
    7934:	8b 10                	mov    (%eax),%edx
    7936:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7939:	01 d0                	add    %edx,%eax
    793b:	0f b6 00             	movzbl (%eax),%eax
    793e:	0f b6 d0             	movzbl %al,%edx
    7941:	8b 45 08             	mov    0x8(%ebp),%eax
    7944:	8b 00                	mov    (%eax),%eax
    7946:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7949:	83 c1 01             	add    $0x1,%ecx
    794c:	01 c8                	add    %ecx,%eax
    794e:	0f b6 00             	movzbl (%eax),%eax
    7951:	0f b6 c0             	movzbl %al,%eax
    7954:	c1 e0 08             	shl    $0x8,%eax
    7957:	89 d1                	mov    %edx,%ecx
    7959:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    795b:	8b 45 08             	mov    0x8(%ebp),%eax
    795e:	8b 00                	mov    (%eax),%eax
    7960:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7963:	83 c2 02             	add    $0x2,%edx
    7966:	01 d0                	add    %edx,%eax
    7968:	0f b6 00             	movzbl (%eax),%eax
    796b:	0f b6 c0             	movzbl %al,%eax
    796e:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    7971:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    7973:	8b 45 08             	mov    0x8(%ebp),%eax
    7976:	8b 00                	mov    (%eax),%eax
    7978:	8b 55 fc             	mov    -0x4(%ebp),%edx
    797b:	83 c2 03             	add    $0x3,%edx
    797e:	01 d0                	add    %edx,%eax
    7980:	0f b6 00             	movzbl (%eax),%eax
    7983:	0f b6 c0             	movzbl %al,%eax
    7986:	c1 e0 18             	shl    $0x18,%eax
    7989:	09 c1                	or     %eax,%ecx
    798b:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    798d:	8b 45 08             	mov    0x8(%ebp),%eax
    7990:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    7993:	8b 45 08             	mov    0x8(%ebp),%eax
    7996:	8b 50 10             	mov    0x10(%eax),%edx
    7999:	8b 45 08             	mov    0x8(%ebp),%eax
    799c:	8b 40 0c             	mov    0xc(%eax),%eax
    799f:	83 e0 07             	and    $0x7,%eax
    79a2:	89 c1                	mov    %eax,%ecx
    79a4:	d3 ea                	shr    %cl,%edx
    79a6:	8b 45 08             	mov    0x8(%ebp),%eax
    79a9:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    79ac:	b8 01 00 00 00       	mov    $0x1,%eax
    79b1:	e9 c6 00 00 00       	jmp    7a7c <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    79b6:	8b 45 08             	mov    0x8(%ebp),%eax
    79b9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    79c0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    79c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    79c6:	39 c2                	cmp    %eax,%edx
    79c8:	73 1e                	jae    79e8 <ensureBits25+0xe3>
    79ca:	8b 45 08             	mov    0x8(%ebp),%eax
    79cd:	8b 50 10             	mov    0x10(%eax),%edx
    79d0:	8b 45 08             	mov    0x8(%ebp),%eax
    79d3:	8b 08                	mov    (%eax),%ecx
    79d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    79d8:	01 c8                	add    %ecx,%eax
    79da:	0f b6 00             	movzbl (%eax),%eax
    79dd:	0f b6 c0             	movzbl %al,%eax
    79e0:	09 c2                	or     %eax,%edx
    79e2:	8b 45 08             	mov    0x8(%ebp),%eax
    79e5:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    79e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    79eb:	8d 50 01             	lea    0x1(%eax),%edx
    79ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    79f1:	39 c2                	cmp    %eax,%edx
    79f3:	73 24                	jae    7a19 <ensureBits25+0x114>
    79f5:	8b 45 08             	mov    0x8(%ebp),%eax
    79f8:	8b 50 10             	mov    0x10(%eax),%edx
    79fb:	8b 45 08             	mov    0x8(%ebp),%eax
    79fe:	8b 00                	mov    (%eax),%eax
    7a00:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7a03:	83 c1 01             	add    $0x1,%ecx
    7a06:	01 c8                	add    %ecx,%eax
    7a08:	0f b6 00             	movzbl (%eax),%eax
    7a0b:	0f b6 c0             	movzbl %al,%eax
    7a0e:	c1 e0 08             	shl    $0x8,%eax
    7a11:	09 c2                	or     %eax,%edx
    7a13:	8b 45 08             	mov    0x8(%ebp),%eax
    7a16:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    7a19:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7a1c:	8d 50 02             	lea    0x2(%eax),%edx
    7a1f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7a22:	39 c2                	cmp    %eax,%edx
    7a24:	73 24                	jae    7a4a <ensureBits25+0x145>
    7a26:	8b 45 08             	mov    0x8(%ebp),%eax
    7a29:	8b 50 10             	mov    0x10(%eax),%edx
    7a2c:	8b 45 08             	mov    0x8(%ebp),%eax
    7a2f:	8b 00                	mov    (%eax),%eax
    7a31:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7a34:	83 c1 02             	add    $0x2,%ecx
    7a37:	01 c8                	add    %ecx,%eax
    7a39:	0f b6 00             	movzbl (%eax),%eax
    7a3c:	0f b6 c0             	movzbl %al,%eax
    7a3f:	c1 e0 10             	shl    $0x10,%eax
    7a42:	09 c2                	or     %eax,%edx
    7a44:	8b 45 08             	mov    0x8(%ebp),%eax
    7a47:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    7a4a:	8b 45 08             	mov    0x8(%ebp),%eax
    7a4d:	8b 50 10             	mov    0x10(%eax),%edx
    7a50:	8b 45 08             	mov    0x8(%ebp),%eax
    7a53:	8b 40 0c             	mov    0xc(%eax),%eax
    7a56:	83 e0 07             	and    $0x7,%eax
    7a59:	89 c1                	mov    %eax,%ecx
    7a5b:	d3 ea                	shr    %cl,%edx
    7a5d:	8b 45 08             	mov    0x8(%ebp),%eax
    7a60:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    7a63:	8b 45 08             	mov    0x8(%ebp),%eax
    7a66:	8b 50 0c             	mov    0xc(%eax),%edx
    7a69:	8b 45 0c             	mov    0xc(%ebp),%eax
    7a6c:	01 c2                	add    %eax,%edx
    7a6e:	8b 45 08             	mov    0x8(%ebp),%eax
    7a71:	8b 40 08             	mov    0x8(%eax),%eax
    7a74:	39 c2                	cmp    %eax,%edx
    7a76:	0f 9e c0             	setle  %al
    7a79:	0f b6 c0             	movzbl %al,%eax
  }
}
    7a7c:	c9                   	leave  
    7a7d:	c3                   	ret    

00007a7e <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    7a7e:	55                   	push   %ebp
    7a7f:	89 e5                	mov    %esp,%ebp
    7a81:	53                   	push   %ebx
    7a82:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    7a85:	8b 45 08             	mov    0x8(%ebp),%eax
    7a88:	8b 40 0c             	mov    0xc(%eax),%eax
    7a8b:	c1 f8 03             	sar    $0x3,%eax
    7a8e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    7a91:	8b 45 08             	mov    0x8(%ebp),%eax
    7a94:	8b 40 04             	mov    0x4(%eax),%eax
    7a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    7a9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7a9d:	8d 50 04             	lea    0x4(%eax),%edx
    7aa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7aa3:	39 c2                	cmp    %eax,%edx
    7aa5:	0f 83 c3 00 00 00    	jae    7b6e <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    7aab:	8b 45 08             	mov    0x8(%ebp),%eax
    7aae:	8b 10                	mov    (%eax),%edx
    7ab0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7ab3:	01 d0                	add    %edx,%eax
    7ab5:	0f b6 00             	movzbl (%eax),%eax
    7ab8:	0f b6 d0             	movzbl %al,%edx
    7abb:	8b 45 08             	mov    0x8(%ebp),%eax
    7abe:	8b 00                	mov    (%eax),%eax
    7ac0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7ac3:	83 c1 01             	add    $0x1,%ecx
    7ac6:	01 c8                	add    %ecx,%eax
    7ac8:	0f b6 00             	movzbl (%eax),%eax
    7acb:	0f b6 c0             	movzbl %al,%eax
    7ace:	c1 e0 08             	shl    $0x8,%eax
    7ad1:	89 d1                	mov    %edx,%ecx
    7ad3:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    7ad5:	8b 45 08             	mov    0x8(%ebp),%eax
    7ad8:	8b 00                	mov    (%eax),%eax
    7ada:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7add:	83 c2 02             	add    $0x2,%edx
    7ae0:	01 d0                	add    %edx,%eax
    7ae2:	0f b6 00             	movzbl (%eax),%eax
    7ae5:	0f b6 c0             	movzbl %al,%eax
    7ae8:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    7aeb:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    7aed:	8b 45 08             	mov    0x8(%ebp),%eax
    7af0:	8b 00                	mov    (%eax),%eax
    7af2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7af5:	83 c2 03             	add    $0x3,%edx
    7af8:	01 d0                	add    %edx,%eax
    7afa:	0f b6 00             	movzbl (%eax),%eax
    7afd:	0f b6 c0             	movzbl %al,%eax
    7b00:	c1 e0 18             	shl    $0x18,%eax
    7b03:	09 c1                	or     %eax,%ecx
    7b05:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    7b07:	8b 45 08             	mov    0x8(%ebp),%eax
    7b0a:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    7b0d:	8b 45 08             	mov    0x8(%ebp),%eax
    7b10:	8b 50 10             	mov    0x10(%eax),%edx
    7b13:	8b 45 08             	mov    0x8(%ebp),%eax
    7b16:	8b 40 0c             	mov    0xc(%eax),%eax
    7b19:	83 e0 07             	and    $0x7,%eax
    7b1c:	89 c1                	mov    %eax,%ecx
    7b1e:	d3 ea                	shr    %cl,%edx
    7b20:	8b 45 08             	mov    0x8(%ebp),%eax
    7b23:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    7b26:	8b 45 08             	mov    0x8(%ebp),%eax
    7b29:	8b 50 10             	mov    0x10(%eax),%edx
    7b2c:	8b 45 08             	mov    0x8(%ebp),%eax
    7b2f:	8b 00                	mov    (%eax),%eax
    7b31:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7b34:	83 c1 04             	add    $0x4,%ecx
    7b37:	01 c8                	add    %ecx,%eax
    7b39:	0f b6 00             	movzbl (%eax),%eax
    7b3c:	0f b6 c0             	movzbl %al,%eax
    7b3f:	c1 e0 18             	shl    $0x18,%eax
    7b42:	89 c3                	mov    %eax,%ebx
    7b44:	8b 45 08             	mov    0x8(%ebp),%eax
    7b47:	8b 40 0c             	mov    0xc(%eax),%eax
    7b4a:	83 e0 07             	and    $0x7,%eax
    7b4d:	b9 08 00 00 00       	mov    $0x8,%ecx
    7b52:	29 c1                	sub    %eax,%ecx
    7b54:	89 c8                	mov    %ecx,%eax
    7b56:	89 c1                	mov    %eax,%ecx
    7b58:	d3 e3                	shl    %cl,%ebx
    7b5a:	89 d8                	mov    %ebx,%eax
    7b5c:	09 c2                	or     %eax,%edx
    7b5e:	8b 45 08             	mov    0x8(%ebp),%eax
    7b61:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    7b64:	b8 01 00 00 00       	mov    $0x1,%eax
    7b69:	e9 f7 00 00 00       	jmp    7c65 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    7b6e:	8b 45 08             	mov    0x8(%ebp),%eax
    7b71:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    7b78:	8b 55 f8             	mov    -0x8(%ebp),%edx
    7b7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7b7e:	39 c2                	cmp    %eax,%edx
    7b80:	73 1e                	jae    7ba0 <ensureBits32+0x122>
    7b82:	8b 45 08             	mov    0x8(%ebp),%eax
    7b85:	8b 50 10             	mov    0x10(%eax),%edx
    7b88:	8b 45 08             	mov    0x8(%ebp),%eax
    7b8b:	8b 08                	mov    (%eax),%ecx
    7b8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7b90:	01 c8                	add    %ecx,%eax
    7b92:	0f b6 00             	movzbl (%eax),%eax
    7b95:	0f b6 c0             	movzbl %al,%eax
    7b98:	09 c2                	or     %eax,%edx
    7b9a:	8b 45 08             	mov    0x8(%ebp),%eax
    7b9d:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    7ba0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7ba3:	8d 50 01             	lea    0x1(%eax),%edx
    7ba6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7ba9:	39 c2                	cmp    %eax,%edx
    7bab:	73 24                	jae    7bd1 <ensureBits32+0x153>
    7bad:	8b 45 08             	mov    0x8(%ebp),%eax
    7bb0:	8b 50 10             	mov    0x10(%eax),%edx
    7bb3:	8b 45 08             	mov    0x8(%ebp),%eax
    7bb6:	8b 00                	mov    (%eax),%eax
    7bb8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7bbb:	83 c1 01             	add    $0x1,%ecx
    7bbe:	01 c8                	add    %ecx,%eax
    7bc0:	0f b6 00             	movzbl (%eax),%eax
    7bc3:	0f b6 c0             	movzbl %al,%eax
    7bc6:	c1 e0 08             	shl    $0x8,%eax
    7bc9:	09 c2                	or     %eax,%edx
    7bcb:	8b 45 08             	mov    0x8(%ebp),%eax
    7bce:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    7bd1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7bd4:	8d 50 02             	lea    0x2(%eax),%edx
    7bd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7bda:	39 c2                	cmp    %eax,%edx
    7bdc:	73 24                	jae    7c02 <ensureBits32+0x184>
    7bde:	8b 45 08             	mov    0x8(%ebp),%eax
    7be1:	8b 50 10             	mov    0x10(%eax),%edx
    7be4:	8b 45 08             	mov    0x8(%ebp),%eax
    7be7:	8b 00                	mov    (%eax),%eax
    7be9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7bec:	83 c1 02             	add    $0x2,%ecx
    7bef:	01 c8                	add    %ecx,%eax
    7bf1:	0f b6 00             	movzbl (%eax),%eax
    7bf4:	0f b6 c0             	movzbl %al,%eax
    7bf7:	c1 e0 10             	shl    $0x10,%eax
    7bfa:	09 c2                	or     %eax,%edx
    7bfc:	8b 45 08             	mov    0x8(%ebp),%eax
    7bff:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    7c02:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c05:	8d 50 03             	lea    0x3(%eax),%edx
    7c08:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7c0b:	39 c2                	cmp    %eax,%edx
    7c0d:	73 24                	jae    7c33 <ensureBits32+0x1b5>
    7c0f:	8b 45 08             	mov    0x8(%ebp),%eax
    7c12:	8b 50 10             	mov    0x10(%eax),%edx
    7c15:	8b 45 08             	mov    0x8(%ebp),%eax
    7c18:	8b 00                	mov    (%eax),%eax
    7c1a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7c1d:	83 c1 03             	add    $0x3,%ecx
    7c20:	01 c8                	add    %ecx,%eax
    7c22:	0f b6 00             	movzbl (%eax),%eax
    7c25:	0f b6 c0             	movzbl %al,%eax
    7c28:	c1 e0 18             	shl    $0x18,%eax
    7c2b:	09 c2                	or     %eax,%edx
    7c2d:	8b 45 08             	mov    0x8(%ebp),%eax
    7c30:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    7c33:	8b 45 08             	mov    0x8(%ebp),%eax
    7c36:	8b 50 10             	mov    0x10(%eax),%edx
    7c39:	8b 45 08             	mov    0x8(%ebp),%eax
    7c3c:	8b 40 0c             	mov    0xc(%eax),%eax
    7c3f:	83 e0 07             	and    $0x7,%eax
    7c42:	89 c1                	mov    %eax,%ecx
    7c44:	d3 ea                	shr    %cl,%edx
    7c46:	8b 45 08             	mov    0x8(%ebp),%eax
    7c49:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    7c4c:	8b 45 08             	mov    0x8(%ebp),%eax
    7c4f:	8b 50 0c             	mov    0xc(%eax),%edx
    7c52:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c55:	01 c2                	add    %eax,%edx
    7c57:	8b 45 08             	mov    0x8(%ebp),%eax
    7c5a:	8b 40 08             	mov    0x8(%eax),%eax
    7c5d:	39 c2                	cmp    %eax,%edx
    7c5f:	0f 9e c0             	setle  %al
    7c62:	0f b6 c0             	movzbl %al,%eax
  }
}
    7c65:	83 c4 10             	add    $0x10,%esp
    7c68:	5b                   	pop    %ebx
    7c69:	5d                   	pop    %ebp
    7c6a:	c3                   	ret    

00007c6b <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    7c6b:	55                   	push   %ebp
    7c6c:	89 e5                	mov    %esp,%ebp
    7c6e:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    7c6f:	8b 45 08             	mov    0x8(%ebp),%eax
    7c72:	8b 50 10             	mov    0x10(%eax),%edx
    7c75:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c78:	bb 01 00 00 00       	mov    $0x1,%ebx
    7c7d:	89 c1                	mov    %eax,%ecx
    7c7f:	d3 e3                	shl    %cl,%ebx
    7c81:	89 d8                	mov    %ebx,%eax
    7c83:	83 e8 01             	sub    $0x1,%eax
    7c86:	21 d0                	and    %edx,%eax
}
    7c88:	5b                   	pop    %ebx
    7c89:	5d                   	pop    %ebp
    7c8a:	c3                   	ret    

00007c8b <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    7c8b:	55                   	push   %ebp
    7c8c:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    7c8e:	8b 45 08             	mov    0x8(%ebp),%eax
    7c91:	8b 50 10             	mov    0x10(%eax),%edx
    7c94:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c97:	89 c1                	mov    %eax,%ecx
    7c99:	d3 ea                	shr    %cl,%edx
    7c9b:	8b 45 08             	mov    0x8(%ebp),%eax
    7c9e:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    7ca1:	8b 45 08             	mov    0x8(%ebp),%eax
    7ca4:	8b 50 0c             	mov    0xc(%eax),%edx
    7ca7:	8b 45 0c             	mov    0xc(%ebp),%eax
    7caa:	01 c2                	add    %eax,%edx
    7cac:	8b 45 08             	mov    0x8(%ebp),%eax
    7caf:	89 50 0c             	mov    %edx,0xc(%eax)
}
    7cb2:	90                   	nop
    7cb3:	5d                   	pop    %ebp
    7cb4:	c3                   	ret    

00007cb5 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    7cb5:	55                   	push   %ebp
    7cb6:	89 e5                	mov    %esp,%ebp
    7cb8:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    7cbb:	ff 75 0c             	pushl  0xc(%ebp)
    7cbe:	ff 75 08             	pushl  0x8(%ebp)
    7cc1:	e8 a5 ff ff ff       	call   7c6b <peekBits>
    7cc6:	83 c4 08             	add    $0x8,%esp
    7cc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    7ccc:	ff 75 0c             	pushl  0xc(%ebp)
    7ccf:	ff 75 08             	pushl  0x8(%ebp)
    7cd2:	e8 b4 ff ff ff       	call   7c8b <advanceBits>
    7cd7:	83 c4 08             	add    $0x8,%esp
  return result;
    7cda:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    7cdd:	c9                   	leave  
    7cde:	c3                   	ret    

00007cdf <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    7cdf:	55                   	push   %ebp
    7ce0:	89 e5                	mov    %esp,%ebp
    7ce2:	53                   	push   %ebx
    7ce3:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    7ce6:	ff 75 0c             	pushl  0xc(%ebp)
    7ce9:	ff 75 08             	pushl  0x8(%ebp)
    7cec:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7cef:	50                   	push   %eax
    7cf0:	e8 97 f9 ff ff       	call   768c <LodePNGBitReader_init>
    7cf5:	83 c4 0c             	add    $0xc,%esp
    7cf8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    7cfb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7cff:	74 0a                	je     7d0b <lode_png_test_bitreader+0x2c>
    7d01:	b8 00 00 00 00       	mov    $0x0,%eax
    7d06:	e9 c3 00 00 00       	jmp    7dce <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    7d0b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    7d12:	e9 a6 00 00 00       	jmp    7dbd <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    7d17:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7d1a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7d21:	8b 45 14             	mov    0x14(%ebp),%eax
    7d24:	01 d0                	add    %edx,%eax
    7d26:	8b 00                	mov    (%eax),%eax
    7d28:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    7d2b:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    7d2f:	7e 14                	jle    7d45 <lode_png_test_bitreader+0x66>
    7d31:	ff 75 ec             	pushl  -0x14(%ebp)
    7d34:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7d37:	50                   	push   %eax
    7d38:	e8 41 fd ff ff       	call   7a7e <ensureBits32>
    7d3d:	83 c4 08             	add    $0x8,%esp
    7d40:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7d43:	eb 46                	jmp    7d8b <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    7d45:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    7d49:	7e 14                	jle    7d5f <lode_png_test_bitreader+0x80>
    7d4b:	ff 75 ec             	pushl  -0x14(%ebp)
    7d4e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7d51:	50                   	push   %eax
    7d52:	e8 ae fb ff ff       	call   7905 <ensureBits25>
    7d57:	83 c4 08             	add    $0x8,%esp
    7d5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7d5d:	eb 2c                	jmp    7d8b <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    7d5f:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    7d63:	7e 14                	jle    7d79 <lode_png_test_bitreader+0x9a>
    7d65:	ff 75 ec             	pushl  -0x14(%ebp)
    7d68:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7d6b:	50                   	push   %eax
    7d6c:	e8 68 fa ff ff       	call   77d9 <ensureBits17>
    7d71:	83 c4 08             	add    $0x8,%esp
    7d74:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7d77:	eb 12                	jmp    7d8b <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    7d79:	ff 75 ec             	pushl  -0x14(%ebp)
    7d7c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7d7f:	50                   	push   %eax
    7d80:	e8 78 f9 ff ff       	call   76fd <ensureBits9>
    7d85:	83 c4 08             	add    $0x8,%esp
    7d88:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    7d8b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d8f:	75 07                	jne    7d98 <lode_png_test_bitreader+0xb9>
    7d91:	b8 00 00 00 00       	mov    $0x0,%eax
    7d96:	eb 36                	jmp    7dce <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    7d98:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7d9b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7da2:	8b 45 18             	mov    0x18(%ebp),%eax
    7da5:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    7da8:	ff 75 ec             	pushl  -0x14(%ebp)
    7dab:	8d 45 d8             	lea    -0x28(%ebp),%eax
    7dae:	50                   	push   %eax
    7daf:	e8 01 ff ff ff       	call   7cb5 <readBits>
    7db4:	83 c4 08             	add    $0x8,%esp
    7db7:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    7db9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    7dbd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7dc0:	3b 45 10             	cmp    0x10(%ebp),%eax
    7dc3:	0f 8c 4e ff ff ff    	jl     7d17 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    7dc9:	b8 01 00 00 00       	mov    $0x1,%eax
}
    7dce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7dd1:	c9                   	leave  
    7dd2:	c3                   	ret    

00007dd3 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    7dd3:	55                   	push   %ebp
    7dd4:	89 e5                	mov    %esp,%ebp
    7dd6:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    7dd9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    7de0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    7de7:	eb 27                	jmp    7e10 <reverseBits+0x3d>
    7de9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dec:	2b 45 fc             	sub    -0x4(%ebp),%eax
    7def:	83 e8 01             	sub    $0x1,%eax
    7df2:	8b 55 08             	mov    0x8(%ebp),%edx
    7df5:	89 c1                	mov    %eax,%ecx
    7df7:	d3 ea                	shr    %cl,%edx
    7df9:	89 d0                	mov    %edx,%eax
    7dfb:	83 e0 01             	and    $0x1,%eax
    7dfe:	89 c2                	mov    %eax,%edx
    7e00:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7e03:	89 c1                	mov    %eax,%ecx
    7e05:	d3 e2                	shl    %cl,%edx
    7e07:	89 d0                	mov    %edx,%eax
    7e09:	09 45 f8             	or     %eax,-0x8(%ebp)
    7e0c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7e10:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7e13:	3b 45 0c             	cmp    0xc(%ebp),%eax
    7e16:	72 d1                	jb     7de9 <reverseBits+0x16>
  return result;
    7e18:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    7e1b:	c9                   	leave  
    7e1c:	c3                   	ret    

00007e1d <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    7e1d:	55                   	push   %ebp
    7e1e:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    7e20:	8b 45 08             	mov    0x8(%ebp),%eax
    7e23:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    7e29:	8b 45 08             	mov    0x8(%ebp),%eax
    7e2c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    7e33:	8b 45 08             	mov    0x8(%ebp),%eax
    7e36:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    7e3d:	8b 45 08             	mov    0x8(%ebp),%eax
    7e40:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    7e47:	90                   	nop
    7e48:	5d                   	pop    %ebp
    7e49:	c3                   	ret    

00007e4a <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    7e4a:	55                   	push   %ebp
    7e4b:	89 e5                	mov    %esp,%ebp
    7e4d:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    7e50:	8b 45 08             	mov    0x8(%ebp),%eax
    7e53:	8b 00                	mov    (%eax),%eax
    7e55:	83 ec 0c             	sub    $0xc,%esp
    7e58:	50                   	push   %eax
    7e59:	e8 ec f0 ff ff       	call   6f4a <lodepng_free>
    7e5e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    7e61:	8b 45 08             	mov    0x8(%ebp),%eax
    7e64:	8b 40 04             	mov    0x4(%eax),%eax
    7e67:	83 ec 0c             	sub    $0xc,%esp
    7e6a:	50                   	push   %eax
    7e6b:	e8 da f0 ff ff       	call   6f4a <lodepng_free>
    7e70:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    7e73:	8b 45 08             	mov    0x8(%ebp),%eax
    7e76:	8b 40 10             	mov    0x10(%eax),%eax
    7e79:	83 ec 0c             	sub    $0xc,%esp
    7e7c:	50                   	push   %eax
    7e7d:	e8 c8 f0 ff ff       	call   6f4a <lodepng_free>
    7e82:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    7e85:	8b 45 08             	mov    0x8(%ebp),%eax
    7e88:	8b 40 14             	mov    0x14(%eax),%eax
    7e8b:	83 ec 0c             	sub    $0xc,%esp
    7e8e:	50                   	push   %eax
    7e8f:	e8 b6 f0 ff ff       	call   6f4a <lodepng_free>
    7e94:	83 c4 10             	add    $0x10,%esp
}
    7e97:	90                   	nop
    7e98:	c9                   	leave  
    7e99:	c3                   	ret    

00007e9a <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    7e9a:	55                   	push   %ebp
    7e9b:	89 e5                	mov    %esp,%ebp
    7e9d:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    7ea0:	a1 68 09 02 00       	mov    0x20968,%eax
    7ea5:	c1 e0 02             	shl    $0x2,%eax
    7ea8:	83 ec 0c             	sub    $0xc,%esp
    7eab:	50                   	push   %eax
    7eac:	e8 78 f0 ff ff       	call   6f29 <lodepng_malloc>
    7eb1:	83 c4 10             	add    $0x10,%esp
    7eb4:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    7eb7:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    7ebb:	75 0a                	jne    7ec7 <HuffmanTree_makeTable+0x2d>
    7ebd:	b8 53 00 00 00       	mov    $0x53,%eax
    7ec2:	e9 61 04 00 00       	jmp    8328 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    7ec7:	a1 68 09 02 00       	mov    0x20968,%eax
    7ecc:	c1 e0 02             	shl    $0x2,%eax
    7ecf:	83 ec 04             	sub    $0x4,%esp
    7ed2:	50                   	push   %eax
    7ed3:	6a 00                	push   $0x0
    7ed5:	ff 75 dc             	pushl  -0x24(%ebp)
    7ed8:	e8 bd f0 ff ff       	call   6f9a <lodepng_memset>
    7edd:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    7ee0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7ee7:	eb 7d                	jmp    7f66 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    7ee9:	8b 45 08             	mov    0x8(%ebp),%eax
    7eec:	8b 00                	mov    (%eax),%eax
    7eee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7ef1:	c1 e2 02             	shl    $0x2,%edx
    7ef4:	01 d0                	add    %edx,%eax
    7ef6:	8b 00                	mov    (%eax),%eax
    7ef8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    7efb:	8b 45 08             	mov    0x8(%ebp),%eax
    7efe:	8b 40 04             	mov    0x4(%eax),%eax
    7f01:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7f04:	c1 e2 02             	shl    $0x2,%edx
    7f07:	01 d0                	add    %edx,%eax
    7f09:	8b 00                	mov    (%eax),%eax
    7f0b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    7f0e:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    7f12:	76 4d                	jbe    7f61 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    7f14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7f17:	83 e8 09             	sub    $0x9,%eax
    7f1a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    7f1d:	89 c1                	mov    %eax,%ecx
    7f1f:	d3 ea                	shr    %cl,%edx
    7f21:	89 d0                	mov    %edx,%eax
    7f23:	83 ec 08             	sub    $0x8,%esp
    7f26:	6a 09                	push   $0x9
    7f28:	50                   	push   %eax
    7f29:	e8 a5 fe ff ff       	call   7dd3 <reverseBits>
    7f2e:	83 c4 10             	add    $0x10,%esp
    7f31:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    7f34:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7f37:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7f41:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7f44:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7f47:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7f51:	01 d0                	add    %edx,%eax
    7f53:	8b 10                	mov    (%eax),%edx
    7f55:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7f58:	39 c2                	cmp    %eax,%edx
    7f5a:	0f 43 c2             	cmovae %edx,%eax
    7f5d:	89 01                	mov    %eax,(%ecx)
    7f5f:	eb 01                	jmp    7f62 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    7f61:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    7f62:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7f66:	8b 45 08             	mov    0x8(%ebp),%eax
    7f69:	8b 50 0c             	mov    0xc(%eax),%edx
    7f6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7f6f:	39 c2                	cmp    %eax,%edx
    7f71:	0f 87 72 ff ff ff    	ja     7ee9 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    7f77:	a1 68 09 02 00       	mov    0x20968,%eax
    7f7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    7f7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7f86:	eb 35                	jmp    7fbd <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    7f88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7f8b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f92:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7f95:	01 d0                	add    %edx,%eax
    7f97:	8b 00                	mov    (%eax),%eax
    7f99:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    7f9c:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    7fa0:	76 17                	jbe    7fb9 <HuffmanTree_makeTable+0x11f>
    7fa2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7fa5:	83 e8 09             	sub    $0x9,%eax
    7fa8:	ba 01 00 00 00       	mov    $0x1,%edx
    7fad:	89 c1                	mov    %eax,%ecx
    7faf:	d3 e2                	shl    %cl,%edx
    7fb1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7fb4:	01 d0                	add    %edx,%eax
    7fb6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    7fb9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7fbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7fc0:	a1 68 09 02 00       	mov    0x20968,%eax
    7fc5:	39 c2                	cmp    %eax,%edx
    7fc7:	72 bf                	jb     7f88 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    7fc9:	83 ec 0c             	sub    $0xc,%esp
    7fcc:	ff 75 e8             	pushl  -0x18(%ebp)
    7fcf:	e8 55 ef ff ff       	call   6f29 <lodepng_malloc>
    7fd4:	83 c4 10             	add    $0x10,%esp
    7fd7:	89 c2                	mov    %eax,%edx
    7fd9:	8b 45 08             	mov    0x8(%ebp),%eax
    7fdc:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    7fdf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7fe2:	01 c0                	add    %eax,%eax
    7fe4:	83 ec 0c             	sub    $0xc,%esp
    7fe7:	50                   	push   %eax
    7fe8:	e8 3c ef ff ff       	call   6f29 <lodepng_malloc>
    7fed:	83 c4 10             	add    $0x10,%esp
    7ff0:	89 c2                	mov    %eax,%edx
    7ff2:	8b 45 08             	mov    0x8(%ebp),%eax
    7ff5:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    7ff8:	8b 45 08             	mov    0x8(%ebp),%eax
    7ffb:	8b 40 10             	mov    0x10(%eax),%eax
    7ffe:	85 c0                	test   %eax,%eax
    8000:	74 0a                	je     800c <HuffmanTree_makeTable+0x172>
    8002:	8b 45 08             	mov    0x8(%ebp),%eax
    8005:	8b 40 14             	mov    0x14(%eax),%eax
    8008:	85 c0                	test   %eax,%eax
    800a:	75 18                	jne    8024 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    800c:	83 ec 0c             	sub    $0xc,%esp
    800f:	ff 75 dc             	pushl  -0x24(%ebp)
    8012:	e8 33 ef ff ff       	call   6f4a <lodepng_free>
    8017:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    801a:	b8 53 00 00 00       	mov    $0x53,%eax
    801f:	e9 04 03 00 00       	jmp    8328 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    8024:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    802b:	eb 12                	jmp    803f <HuffmanTree_makeTable+0x1a5>
    802d:	8b 45 08             	mov    0x8(%ebp),%eax
    8030:	8b 50 10             	mov    0x10(%eax),%edx
    8033:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8036:	01 d0                	add    %edx,%eax
    8038:	c6 00 10             	movb   $0x10,(%eax)
    803b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    803f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8042:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    8045:	7c e6                	jl     802d <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    8047:	a1 68 09 02 00       	mov    0x20968,%eax
    804c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    804f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8056:	eb 5b                	jmp    80b3 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    8058:	8b 45 f4             	mov    -0xc(%ebp),%eax
    805b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8062:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8065:	01 d0                	add    %edx,%eax
    8067:	8b 00                	mov    (%eax),%eax
    8069:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    806c:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    8070:	76 3c                	jbe    80ae <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    8072:	8b 45 08             	mov    0x8(%ebp),%eax
    8075:	8b 50 10             	mov    0x10(%eax),%edx
    8078:	8b 45 f4             	mov    -0xc(%ebp),%eax
    807b:	01 d0                	add    %edx,%eax
    807d:	8b 55 c8             	mov    -0x38(%ebp),%edx
    8080:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    8082:	8b 45 08             	mov    0x8(%ebp),%eax
    8085:	8b 40 14             	mov    0x14(%eax),%eax
    8088:	8b 55 f4             	mov    -0xc(%ebp),%edx
    808b:	01 d2                	add    %edx,%edx
    808d:	01 d0                	add    %edx,%eax
    808f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8092:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    8095:	8b 45 c8             	mov    -0x38(%ebp),%eax
    8098:	83 e8 09             	sub    $0x9,%eax
    809b:	ba 01 00 00 00       	mov    $0x1,%edx
    80a0:	89 c1                	mov    %eax,%ecx
    80a2:	d3 e2                	shl    %cl,%edx
    80a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    80a7:	01 d0                	add    %edx,%eax
    80a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    80ac:	eb 01                	jmp    80af <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    80ae:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    80af:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    80b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    80b6:	a1 68 09 02 00       	mov    0x20968,%eax
    80bb:	39 c2                	cmp    %eax,%edx
    80bd:	72 99                	jb     8058 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    80bf:	83 ec 0c             	sub    $0xc,%esp
    80c2:	ff 75 dc             	pushl  -0x24(%ebp)
    80c5:	e8 80 ee ff ff       	call   6f4a <lodepng_free>
    80ca:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    80cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    80d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    80db:	e9 9d 01 00 00       	jmp    827d <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    80e0:	8b 45 08             	mov    0x8(%ebp),%eax
    80e3:	8b 40 04             	mov    0x4(%eax),%eax
    80e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    80e9:	c1 e2 02             	shl    $0x2,%edx
    80ec:	01 d0                	add    %edx,%eax
    80ee:	8b 00                	mov    (%eax),%eax
    80f0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    80f3:	8b 45 08             	mov    0x8(%ebp),%eax
    80f6:	8b 00                	mov    (%eax),%eax
    80f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    80fb:	c1 e2 02             	shl    $0x2,%edx
    80fe:	01 d0                	add    %edx,%eax
    8100:	8b 00                	mov    (%eax),%eax
    8102:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    8105:	83 ec 08             	sub    $0x8,%esp
    8108:	ff 75 c4             	pushl  -0x3c(%ebp)
    810b:	ff 75 c0             	pushl  -0x40(%ebp)
    810e:	e8 c0 fc ff ff       	call   7dd3 <reverseBits>
    8113:	83 c4 10             	add    $0x10,%esp
    8116:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    8119:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    811d:	0f 84 55 01 00 00    	je     8278 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    8123:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    8127:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    812b:	0f 87 81 00 00 00    	ja     81b2 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    8131:	b8 09 00 00 00       	mov    $0x9,%eax
    8136:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    8139:	ba 01 00 00 00       	mov    $0x1,%edx
    813e:	89 c1                	mov    %eax,%ecx
    8140:	d3 e2                	shl    %cl,%edx
    8142:	89 d0                	mov    %edx,%eax
    8144:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    8147:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    814e:	eb 55                	jmp    81a5 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    8150:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    8153:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8156:	89 c1                	mov    %eax,%ecx
    8158:	d3 e2                	shl    %cl,%edx
    815a:	89 d0                	mov    %edx,%eax
    815c:	0b 45 bc             	or     -0x44(%ebp),%eax
    815f:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    8162:	8b 45 08             	mov    0x8(%ebp),%eax
    8165:	8b 50 10             	mov    0x10(%eax),%edx
    8168:	8b 45 98             	mov    -0x68(%ebp),%eax
    816b:	01 d0                	add    %edx,%eax
    816d:	0f b6 00             	movzbl (%eax),%eax
    8170:	3c 10                	cmp    $0x10,%al
    8172:	74 0a                	je     817e <HuffmanTree_makeTable+0x2e4>
    8174:	b8 37 00 00 00       	mov    $0x37,%eax
    8179:	e9 aa 01 00 00       	jmp    8328 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    817e:	8b 45 08             	mov    0x8(%ebp),%eax
    8181:	8b 50 10             	mov    0x10(%eax),%edx
    8184:	8b 45 98             	mov    -0x68(%ebp),%eax
    8187:	01 d0                	add    %edx,%eax
    8189:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    818c:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    818e:	8b 45 08             	mov    0x8(%ebp),%eax
    8191:	8b 40 14             	mov    0x14(%eax),%eax
    8194:	8b 55 98             	mov    -0x68(%ebp),%edx
    8197:	01 d2                	add    %edx,%edx
    8199:	01 d0                	add    %edx,%eax
    819b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    819e:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    81a1:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    81a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    81a8:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    81ab:	72 a3                	jb     8150 <HuffmanTree_makeTable+0x2b6>
    81ad:	e9 c7 00 00 00       	jmp    8279 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    81b2:	a1 6c 09 02 00       	mov    0x2096c,%eax
    81b7:	23 45 bc             	and    -0x44(%ebp),%eax
    81ba:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    81bd:	8b 45 08             	mov    0x8(%ebp),%eax
    81c0:	8b 50 10             	mov    0x10(%eax),%edx
    81c3:	8b 45 b8             	mov    -0x48(%ebp),%eax
    81c6:	01 d0                	add    %edx,%eax
    81c8:	0f b6 00             	movzbl (%eax),%eax
    81cb:	0f b6 c0             	movzbl %al,%eax
    81ce:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    81d1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    81d4:	83 e8 09             	sub    $0x9,%eax
    81d7:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    81da:	8b 45 08             	mov    0x8(%ebp),%eax
    81dd:	8b 40 14             	mov    0x14(%eax),%eax
    81e0:	8b 55 b8             	mov    -0x48(%ebp),%edx
    81e3:	01 d2                	add    %edx,%edx
    81e5:	01 d0                	add    %edx,%eax
    81e7:	0f b7 00             	movzwl (%eax),%eax
    81ea:	0f b7 c0             	movzwl %ax,%eax
    81ed:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    81f0:	8b 45 b0             	mov    -0x50(%ebp),%eax
    81f3:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    81f6:	83 c0 09             	add    $0x9,%eax
    81f9:	ba 01 00 00 00       	mov    $0x1,%edx
    81fe:	89 c1                	mov    %eax,%ecx
    8200:	d3 e2                	shl    %cl,%edx
    8202:	89 d0                	mov    %edx,%eax
    8204:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    8207:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    820a:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    820d:	73 0a                	jae    8219 <HuffmanTree_makeTable+0x37f>
    820f:	b8 37 00 00 00       	mov    $0x37,%eax
    8214:	e9 0f 01 00 00       	jmp    8328 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    8219:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    8220:	eb 4c                	jmp    826e <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    8222:	8b 45 bc             	mov    -0x44(%ebp),%eax
    8225:	c1 e8 09             	shr    $0x9,%eax
    8228:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    822b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    822e:	83 e8 09             	sub    $0x9,%eax
    8231:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8234:	89 c1                	mov    %eax,%ecx
    8236:	d3 e2                	shl    %cl,%edx
    8238:	89 d0                	mov    %edx,%eax
    823a:	0b 45 a4             	or     -0x5c(%ebp),%eax
    823d:	89 c2                	mov    %eax,%edx
    823f:	8b 45 ac             	mov    -0x54(%ebp),%eax
    8242:	01 d0                	add    %edx,%eax
    8244:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    8247:	8b 45 08             	mov    0x8(%ebp),%eax
    824a:	8b 50 10             	mov    0x10(%eax),%edx
    824d:	8b 45 a0             	mov    -0x60(%ebp),%eax
    8250:	01 d0                	add    %edx,%eax
    8252:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    8255:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    8257:	8b 45 08             	mov    0x8(%ebp),%eax
    825a:	8b 40 14             	mov    0x14(%eax),%eax
    825d:	8b 55 a0             	mov    -0x60(%ebp),%edx
    8260:	01 d2                	add    %edx,%edx
    8262:	01 d0                	add    %edx,%eax
    8264:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8267:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    826a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    826e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8271:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    8274:	72 ac                	jb     8222 <HuffmanTree_makeTable+0x388>
    8276:	eb 01                	jmp    8279 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    8278:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    8279:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    827d:	8b 45 08             	mov    0x8(%ebp),%eax
    8280:	8b 50 0c             	mov    0xc(%eax),%edx
    8283:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8286:	39 c2                	cmp    %eax,%edx
    8288:	0f 87 52 fe ff ff    	ja     80e0 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    828e:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    8292:	7f 61                	jg     82f5 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    8294:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    829b:	eb 4e                	jmp    82eb <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    829d:	8b 45 08             	mov    0x8(%ebp),%eax
    82a0:	8b 50 10             	mov    0x10(%eax),%edx
    82a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    82a6:	01 d0                	add    %edx,%eax
    82a8:	0f b6 00             	movzbl (%eax),%eax
    82ab:	3c 10                	cmp    $0x10,%al
    82ad:	75 38                	jne    82e7 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    82af:	8b 45 08             	mov    0x8(%ebp),%eax
    82b2:	8b 50 10             	mov    0x10(%eax),%edx
    82b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    82b8:	01 d0                	add    %edx,%eax
    82ba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    82bd:	8b 15 68 09 02 00    	mov    0x20968,%edx
    82c3:	39 d1                	cmp    %edx,%ecx
    82c5:	73 07                	jae    82ce <HuffmanTree_makeTable+0x434>
    82c7:	ba 01 00 00 00       	mov    $0x1,%edx
    82cc:	eb 05                	jmp    82d3 <HuffmanTree_makeTable+0x439>
    82ce:	ba 0a 00 00 00       	mov    $0xa,%edx
    82d3:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    82d5:	8b 45 08             	mov    0x8(%ebp),%eax
    82d8:	8b 40 14             	mov    0x14(%eax),%eax
    82db:	8b 55 f4             	mov    -0xc(%ebp),%edx
    82de:	01 d2                	add    %edx,%edx
    82e0:	01 d0                	add    %edx,%eax
    82e2:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    82e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    82eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    82ee:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    82f1:	7c aa                	jl     829d <HuffmanTree_makeTable+0x403>
    82f3:	eb 2e                	jmp    8323 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    82f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    82fc:	eb 1d                	jmp    831b <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    82fe:	8b 45 08             	mov    0x8(%ebp),%eax
    8301:	8b 50 10             	mov    0x10(%eax),%edx
    8304:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8307:	01 d0                	add    %edx,%eax
    8309:	0f b6 00             	movzbl (%eax),%eax
    830c:	3c 10                	cmp    $0x10,%al
    830e:	75 07                	jne    8317 <HuffmanTree_makeTable+0x47d>
    8310:	b8 37 00 00 00       	mov    $0x37,%eax
    8315:	eb 11                	jmp    8328 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    8317:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    831b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    831e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    8321:	7c db                	jl     82fe <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    8323:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8328:	c9                   	leave  
    8329:	c3                   	ret    

0000832a <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    832a:	55                   	push   %ebp
    832b:	89 e5                	mov    %esp,%ebp
    832d:	56                   	push   %esi
    832e:	53                   	push   %ebx
    832f:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    8332:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    8339:	8b 45 08             	mov    0x8(%ebp),%eax
    833c:	8b 40 0c             	mov    0xc(%eax),%eax
    833f:	c1 e0 02             	shl    $0x2,%eax
    8342:	83 ec 0c             	sub    $0xc,%esp
    8345:	50                   	push   %eax
    8346:	e8 de eb ff ff       	call   6f29 <lodepng_malloc>
    834b:	83 c4 10             	add    $0x10,%esp
    834e:	89 c2                	mov    %eax,%edx
    8350:	8b 45 08             	mov    0x8(%ebp),%eax
    8353:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    8355:	8b 45 08             	mov    0x8(%ebp),%eax
    8358:	8b 40 08             	mov    0x8(%eax),%eax
    835b:	83 c0 01             	add    $0x1,%eax
    835e:	c1 e0 02             	shl    $0x2,%eax
    8361:	83 ec 0c             	sub    $0xc,%esp
    8364:	50                   	push   %eax
    8365:	e8 bf eb ff ff       	call   6f29 <lodepng_malloc>
    836a:	83 c4 10             	add    $0x10,%esp
    836d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    8370:	8b 45 08             	mov    0x8(%ebp),%eax
    8373:	8b 40 08             	mov    0x8(%eax),%eax
    8376:	83 c0 01             	add    $0x1,%eax
    8379:	c1 e0 02             	shl    $0x2,%eax
    837c:	83 ec 0c             	sub    $0xc,%esp
    837f:	50                   	push   %eax
    8380:	e8 a4 eb ff ff       	call   6f29 <lodepng_malloc>
    8385:	83 c4 10             	add    $0x10,%esp
    8388:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    838b:	8b 45 08             	mov    0x8(%ebp),%eax
    838e:	8b 00                	mov    (%eax),%eax
    8390:	85 c0                	test   %eax,%eax
    8392:	74 0c                	je     83a0 <HuffmanTree_makeFromLengths2+0x76>
    8394:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    8398:	74 06                	je     83a0 <HuffmanTree_makeFromLengths2+0x76>
    839a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    839e:	75 07                	jne    83a7 <HuffmanTree_makeFromLengths2+0x7d>
    83a0:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    83a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    83ab:	0f 85 7d 01 00 00    	jne    852e <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    83b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    83b8:	eb 2c                	jmp    83e6 <HuffmanTree_makeFromLengths2+0xbc>
    83ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    83bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    83c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    83c7:	01 c2                	add    %eax,%edx
    83c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    83cc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    83d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    83d6:	01 c8                	add    %ecx,%eax
    83d8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    83de:	8b 00                	mov    (%eax),%eax
    83e0:	89 02                	mov    %eax,(%edx)
    83e2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    83e6:	8b 45 08             	mov    0x8(%ebp),%eax
    83e9:	8b 40 08             	mov    0x8(%eax),%eax
    83ec:	83 c0 01             	add    $0x1,%eax
    83ef:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    83f2:	75 c6                	jne    83ba <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    83f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    83fb:	eb 27                	jmp    8424 <HuffmanTree_makeFromLengths2+0xfa>
    83fd:	8b 45 08             	mov    0x8(%ebp),%eax
    8400:	8b 40 04             	mov    0x4(%eax),%eax
    8403:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8406:	c1 e2 02             	shl    $0x2,%edx
    8409:	01 d0                	add    %edx,%eax
    840b:	8b 00                	mov    (%eax),%eax
    840d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8414:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8417:	01 d0                	add    %edx,%eax
    8419:	8b 10                	mov    (%eax),%edx
    841b:	83 c2 01             	add    $0x1,%edx
    841e:	89 10                	mov    %edx,(%eax)
    8420:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8424:	8b 45 08             	mov    0x8(%ebp),%eax
    8427:	8b 40 0c             	mov    0xc(%eax),%eax
    842a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    842d:	75 ce                	jne    83fd <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    842f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    8436:	eb 47                	jmp    847f <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    8438:	8b 45 f0             	mov    -0x10(%ebp),%eax
    843b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8442:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8445:	01 d0                	add    %edx,%eax
    8447:	8b 55 f0             	mov    -0x10(%ebp),%edx
    844a:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    8450:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    8457:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    845a:	01 ca                	add    %ecx,%edx
    845c:	8b 0a                	mov    (%edx),%ecx
    845e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8461:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    8467:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    846e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8471:	01 da                	add    %ebx,%edx
    8473:	8b 12                	mov    (%edx),%edx
    8475:	01 ca                	add    %ecx,%edx
    8477:	01 d2                	add    %edx,%edx
    8479:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    847b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    847f:	8b 45 08             	mov    0x8(%ebp),%eax
    8482:	8b 40 08             	mov    0x8(%eax),%eax
    8485:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8488:	73 ae                	jae    8438 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    848a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    8491:	e9 89 00 00 00       	jmp    851f <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    8496:	8b 45 08             	mov    0x8(%ebp),%eax
    8499:	8b 40 04             	mov    0x4(%eax),%eax
    849c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    849f:	c1 e2 02             	shl    $0x2,%edx
    84a2:	01 d0                	add    %edx,%eax
    84a4:	8b 00                	mov    (%eax),%eax
    84a6:	85 c0                	test   %eax,%eax
    84a8:	74 71                	je     851b <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    84aa:	8b 45 08             	mov    0x8(%ebp),%eax
    84ad:	8b 00                	mov    (%eax),%eax
    84af:	8b 55 ec             	mov    -0x14(%ebp),%edx
    84b2:	c1 e2 02             	shl    $0x2,%edx
    84b5:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    84b8:	8b 45 08             	mov    0x8(%ebp),%eax
    84bb:	8b 40 04             	mov    0x4(%eax),%eax
    84be:	8b 55 ec             	mov    -0x14(%ebp),%edx
    84c1:	c1 e2 02             	shl    $0x2,%edx
    84c4:	01 d0                	add    %edx,%eax
    84c6:	8b 00                	mov    (%eax),%eax
    84c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    84cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    84d2:	01 c2                	add    %eax,%edx
    84d4:	8b 02                	mov    (%edx),%eax
    84d6:	8d 48 01             	lea    0x1(%eax),%ecx
    84d9:	89 0a                	mov    %ecx,(%edx)
    84db:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    84dd:	8b 45 08             	mov    0x8(%ebp),%eax
    84e0:	8b 00                	mov    (%eax),%eax
    84e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    84e5:	c1 e2 02             	shl    $0x2,%edx
    84e8:	01 c2                	add    %eax,%edx
    84ea:	8b 45 08             	mov    0x8(%ebp),%eax
    84ed:	8b 00                	mov    (%eax),%eax
    84ef:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    84f2:	c1 e1 02             	shl    $0x2,%ecx
    84f5:	01 c8                	add    %ecx,%eax
    84f7:	8b 18                	mov    (%eax),%ebx
    84f9:	8b 45 08             	mov    0x8(%ebp),%eax
    84fc:	8b 40 04             	mov    0x4(%eax),%eax
    84ff:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8502:	c1 e1 02             	shl    $0x2,%ecx
    8505:	01 c8                	add    %ecx,%eax
    8507:	8b 00                	mov    (%eax),%eax
    8509:	be 01 00 00 00       	mov    $0x1,%esi
    850e:	89 c1                	mov    %eax,%ecx
    8510:	d3 e6                	shl    %cl,%esi
    8512:	89 f0                	mov    %esi,%eax
    8514:	83 e8 01             	sub    $0x1,%eax
    8517:	21 d8                	and    %ebx,%eax
    8519:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    851b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    851f:	8b 45 08             	mov    0x8(%ebp),%eax
    8522:	8b 40 0c             	mov    0xc(%eax),%eax
    8525:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    8528:	0f 85 68 ff ff ff    	jne    8496 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    852e:	83 ec 0c             	sub    $0xc,%esp
    8531:	ff 75 e8             	pushl  -0x18(%ebp)
    8534:	e8 11 ea ff ff       	call   6f4a <lodepng_free>
    8539:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    853c:	83 ec 0c             	sub    $0xc,%esp
    853f:	ff 75 e4             	pushl  -0x1c(%ebp)
    8542:	e8 03 ea ff ff       	call   6f4a <lodepng_free>
    8547:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    854a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    854e:	75 11                	jne    8561 <HuffmanTree_makeFromLengths2+0x237>
    8550:	83 ec 0c             	sub    $0xc,%esp
    8553:	ff 75 08             	pushl  0x8(%ebp)
    8556:	e8 3f f9 ff ff       	call   7e9a <HuffmanTree_makeTable>
    855b:	83 c4 10             	add    $0x10,%esp
    855e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    8561:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8564:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8567:	5b                   	pop    %ebx
    8568:	5e                   	pop    %esi
    8569:	5d                   	pop    %ebp
    856a:	c3                   	ret    

0000856b <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    856b:	55                   	push   %ebp
    856c:	89 e5                	mov    %esp,%ebp
    856e:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    8571:	8b 45 10             	mov    0x10(%ebp),%eax
    8574:	c1 e0 02             	shl    $0x2,%eax
    8577:	83 ec 0c             	sub    $0xc,%esp
    857a:	50                   	push   %eax
    857b:	e8 a9 e9 ff ff       	call   6f29 <lodepng_malloc>
    8580:	83 c4 10             	add    $0x10,%esp
    8583:	89 c2                	mov    %eax,%edx
    8585:	8b 45 08             	mov    0x8(%ebp),%eax
    8588:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    858b:	8b 45 08             	mov    0x8(%ebp),%eax
    858e:	8b 40 04             	mov    0x4(%eax),%eax
    8591:	85 c0                	test   %eax,%eax
    8593:	75 07                	jne    859c <HuffmanTree_makeFromLengths+0x31>
    8595:	b8 53 00 00 00       	mov    $0x53,%eax
    859a:	eb 56                	jmp    85f2 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    859c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    85a3:	eb 25                	jmp    85ca <HuffmanTree_makeFromLengths+0x5f>
    85a5:	8b 45 08             	mov    0x8(%ebp),%eax
    85a8:	8b 40 04             	mov    0x4(%eax),%eax
    85ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    85ae:	c1 e2 02             	shl    $0x2,%edx
    85b1:	01 c2                	add    %eax,%edx
    85b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    85b6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    85bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    85c0:	01 c8                	add    %ecx,%eax
    85c2:	8b 00                	mov    (%eax),%eax
    85c4:	89 02                	mov    %eax,(%edx)
    85c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    85ca:	8b 45 10             	mov    0x10(%ebp),%eax
    85cd:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    85d0:	75 d3                	jne    85a5 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    85d2:	8b 55 10             	mov    0x10(%ebp),%edx
    85d5:	8b 45 08             	mov    0x8(%ebp),%eax
    85d8:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    85db:	8b 45 08             	mov    0x8(%ebp),%eax
    85de:	8b 55 14             	mov    0x14(%ebp),%edx
    85e1:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    85e4:	83 ec 0c             	sub    $0xc,%esp
    85e7:	ff 75 08             	pushl  0x8(%ebp)
    85ea:	e8 3b fd ff ff       	call   832a <HuffmanTree_makeFromLengths2>
    85ef:	83 c4 10             	add    $0x10,%esp
}
    85f2:	c9                   	leave  
    85f3:	c3                   	ret    

000085f4 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    85f4:	55                   	push   %ebp
    85f5:	89 e5                	mov    %esp,%ebp
    85f7:	53                   	push   %ebx
    85f8:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    85fb:	8b 45 08             	mov    0x8(%ebp),%eax
    85fe:	8b 50 0c             	mov    0xc(%eax),%edx
    8601:	8b 45 08             	mov    0x8(%ebp),%eax
    8604:	8b 40 08             	mov    0x8(%eax),%eax
    8607:	39 c2                	cmp    %eax,%edx
    8609:	0f 82 0b 01 00 00    	jb     871a <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    860f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8616:	eb 19                	jmp    8631 <bpmnode_create+0x3d>
    8618:	8b 45 08             	mov    0x8(%ebp),%eax
    861b:	8b 40 04             	mov    0x4(%eax),%eax
    861e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8621:	c1 e2 04             	shl    $0x4,%edx
    8624:	01 d0                	add    %edx,%eax
    8626:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    862d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8631:	8b 45 08             	mov    0x8(%ebp),%eax
    8634:	8b 00                	mov    (%eax),%eax
    8636:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    8639:	75 dd                	jne    8618 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    863b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8642:	eb 60                	jmp    86a4 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    8644:	8b 45 08             	mov    0x8(%ebp),%eax
    8647:	8b 40 18             	mov    0x18(%eax),%eax
    864a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    864d:	c1 e2 02             	shl    $0x2,%edx
    8650:	01 d0                	add    %edx,%eax
    8652:	8b 00                	mov    (%eax),%eax
    8654:	89 45 f4             	mov    %eax,-0xc(%ebp)
    8657:	eb 13                	jmp    866c <bpmnode_create+0x78>
    8659:	8b 45 f4             	mov    -0xc(%ebp),%eax
    865c:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    8663:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8666:	8b 40 08             	mov    0x8(%eax),%eax
    8669:	89 45 f4             	mov    %eax,-0xc(%ebp)
    866c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8670:	75 e7                	jne    8659 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    8672:	8b 45 08             	mov    0x8(%ebp),%eax
    8675:	8b 40 1c             	mov    0x1c(%eax),%eax
    8678:	8b 55 f8             	mov    -0x8(%ebp),%edx
    867b:	c1 e2 02             	shl    $0x2,%edx
    867e:	01 d0                	add    %edx,%eax
    8680:	8b 00                	mov    (%eax),%eax
    8682:	89 45 f4             	mov    %eax,-0xc(%ebp)
    8685:	eb 13                	jmp    869a <bpmnode_create+0xa6>
    8687:	8b 45 f4             	mov    -0xc(%ebp),%eax
    868a:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    8691:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8694:	8b 40 08             	mov    0x8(%eax),%eax
    8697:	89 45 f4             	mov    %eax,-0xc(%ebp)
    869a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    869e:	75 e7                	jne    8687 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    86a0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    86a4:	8b 45 08             	mov    0x8(%ebp),%eax
    86a7:	8b 40 14             	mov    0x14(%eax),%eax
    86aa:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    86ad:	75 95                	jne    8644 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    86af:	8b 45 08             	mov    0x8(%ebp),%eax
    86b2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    86b9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    86c0:	eb 44                	jmp    8706 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    86c2:	8b 45 08             	mov    0x8(%ebp),%eax
    86c5:	8b 40 04             	mov    0x4(%eax),%eax
    86c8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    86cb:	c1 e2 04             	shl    $0x4,%edx
    86ce:	01 d0                	add    %edx,%eax
    86d0:	8b 40 0c             	mov    0xc(%eax),%eax
    86d3:	85 c0                	test   %eax,%eax
    86d5:	75 2b                	jne    8702 <bpmnode_create+0x10e>
    86d7:	8b 45 08             	mov    0x8(%ebp),%eax
    86da:	8b 58 10             	mov    0x10(%eax),%ebx
    86dd:	8b 45 08             	mov    0x8(%ebp),%eax
    86e0:	8b 40 08             	mov    0x8(%eax),%eax
    86e3:	8d 48 01             	lea    0x1(%eax),%ecx
    86e6:	8b 55 08             	mov    0x8(%ebp),%edx
    86e9:	89 4a 08             	mov    %ecx,0x8(%edx)
    86ec:	c1 e0 02             	shl    $0x2,%eax
    86ef:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    86f2:	8b 45 08             	mov    0x8(%ebp),%eax
    86f5:	8b 40 04             	mov    0x4(%eax),%eax
    86f8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    86fb:	c1 e1 04             	shl    $0x4,%ecx
    86fe:	01 c8                	add    %ecx,%eax
    8700:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    8702:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8706:	8b 45 08             	mov    0x8(%ebp),%eax
    8709:	8b 00                	mov    (%eax),%eax
    870b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    870e:	75 b2                	jne    86c2 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    8710:	8b 45 08             	mov    0x8(%ebp),%eax
    8713:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    871a:	8b 45 08             	mov    0x8(%ebp),%eax
    871d:	8b 58 10             	mov    0x10(%eax),%ebx
    8720:	8b 45 08             	mov    0x8(%ebp),%eax
    8723:	8b 40 0c             	mov    0xc(%eax),%eax
    8726:	8d 48 01             	lea    0x1(%eax),%ecx
    8729:	8b 55 08             	mov    0x8(%ebp),%edx
    872c:	89 4a 0c             	mov    %ecx,0xc(%edx)
    872f:	c1 e0 02             	shl    $0x2,%eax
    8732:	01 d8                	add    %ebx,%eax
    8734:	8b 00                	mov    (%eax),%eax
    8736:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    8739:	8b 45 f0             	mov    -0x10(%ebp),%eax
    873c:	8b 55 0c             	mov    0xc(%ebp),%edx
    873f:	89 10                	mov    %edx,(%eax)
  result->index = index;
    8741:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8744:	8b 55 10             	mov    0x10(%ebp),%edx
    8747:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    874a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    874d:	8b 55 14             	mov    0x14(%ebp),%edx
    8750:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    8753:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    8756:	83 c4 10             	add    $0x10,%esp
    8759:	5b                   	pop    %ebx
    875a:	5d                   	pop    %ebp
    875b:	c3                   	ret    

0000875c <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    875c:	55                   	push   %ebp
    875d:	89 e5                	mov    %esp,%ebp
    875f:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    8762:	8b 45 0c             	mov    0xc(%ebp),%eax
    8765:	c1 e0 04             	shl    $0x4,%eax
    8768:	83 ec 0c             	sub    $0xc,%esp
    876b:	50                   	push   %eax
    876c:	e8 b8 e7 ff ff       	call   6f29 <lodepng_malloc>
    8771:	83 c4 10             	add    $0x10,%esp
    8774:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    8777:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    877e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    8785:	e9 41 01 00 00       	jmp    88cb <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    878a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    878d:	83 e0 01             	and    $0x1,%eax
    8790:	85 c0                	test   %eax,%eax
    8792:	74 05                	je     8799 <bpmnode_sort+0x3d>
    8794:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8797:	eb 03                	jmp    879c <bpmnode_sort+0x40>
    8799:	8b 45 08             	mov    0x8(%ebp),%eax
    879c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    879f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    87a2:	83 e0 01             	and    $0x1,%eax
    87a5:	85 c0                	test   %eax,%eax
    87a7:	74 05                	je     87ae <bpmnode_sort+0x52>
    87a9:	8b 45 08             	mov    0x8(%ebp),%eax
    87ac:	eb 03                	jmp    87b1 <bpmnode_sort+0x55>
    87ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
    87b1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    87b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    87bb:	e9 f8 00 00 00       	jmp    88b8 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    87c0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    87c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    87c6:	01 c2                	add    %eax,%edx
    87c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    87cb:	39 c2                	cmp    %eax,%edx
    87cd:	0f 4e c2             	cmovle %edx,%eax
    87d0:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    87d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    87d6:	8d 14 00             	lea    (%eax,%eax,1),%edx
    87d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    87dc:	01 c2                	add    %eax,%edx
    87de:	8b 45 0c             	mov    0xc(%ebp),%eax
    87e1:	39 c2                	cmp    %eax,%edx
    87e3:	0f 4e c2             	cmovle %edx,%eax
    87e6:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    87e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    87ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
    87ef:	8b 45 d0             	mov    -0x30(%ebp),%eax
    87f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    87f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    87f8:	89 45 e0             	mov    %eax,-0x20(%ebp)
    87fb:	e9 a4 00 00 00       	jmp    88a4 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    8800:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8803:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    8806:	7d 62                	jge    886a <bpmnode_sort+0x10e>
    8808:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    880b:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    880e:	7d 22                	jge    8832 <bpmnode_sort+0xd6>
    8810:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8813:	c1 e0 04             	shl    $0x4,%eax
    8816:	89 c2                	mov    %eax,%edx
    8818:	8b 45 d8             	mov    -0x28(%ebp),%eax
    881b:	01 d0                	add    %edx,%eax
    881d:	8b 10                	mov    (%eax),%edx
    881f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8822:	c1 e0 04             	shl    $0x4,%eax
    8825:	89 c1                	mov    %eax,%ecx
    8827:	8b 45 d8             	mov    -0x28(%ebp),%eax
    882a:	01 c8                	add    %ecx,%eax
    882c:	8b 00                	mov    (%eax),%eax
    882e:	39 c2                	cmp    %eax,%edx
    8830:	7f 38                	jg     886a <bpmnode_sort+0x10e>
    8832:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8835:	c1 e0 04             	shl    $0x4,%eax
    8838:	89 c2                	mov    %eax,%edx
    883a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    883d:	01 d0                	add    %edx,%eax
    883f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8842:	8d 4a 01             	lea    0x1(%edx),%ecx
    8845:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    8848:	89 d1                	mov    %edx,%ecx
    884a:	c1 e1 04             	shl    $0x4,%ecx
    884d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    8850:	01 ca                	add    %ecx,%edx
    8852:	8b 0a                	mov    (%edx),%ecx
    8854:	89 08                	mov    %ecx,(%eax)
    8856:	8b 4a 04             	mov    0x4(%edx),%ecx
    8859:	89 48 04             	mov    %ecx,0x4(%eax)
    885c:	8b 4a 08             	mov    0x8(%edx),%ecx
    885f:	89 48 08             	mov    %ecx,0x8(%eax)
    8862:	8b 52 0c             	mov    0xc(%edx),%edx
    8865:	89 50 0c             	mov    %edx,0xc(%eax)
    8868:	eb 36                	jmp    88a0 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    886a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    886d:	c1 e0 04             	shl    $0x4,%eax
    8870:	89 c2                	mov    %eax,%edx
    8872:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8875:	01 d0                	add    %edx,%eax
    8877:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    887a:	8d 4a 01             	lea    0x1(%edx),%ecx
    887d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    8880:	89 d1                	mov    %edx,%ecx
    8882:	c1 e1 04             	shl    $0x4,%ecx
    8885:	8b 55 d8             	mov    -0x28(%ebp),%edx
    8888:	01 ca                	add    %ecx,%edx
    888a:	8b 0a                	mov    (%edx),%ecx
    888c:	89 08                	mov    %ecx,(%eax)
    888e:	8b 4a 04             	mov    0x4(%edx),%ecx
    8891:	89 48 04             	mov    %ecx,0x4(%eax)
    8894:	8b 4a 08             	mov    0x8(%edx),%ecx
    8897:	89 48 08             	mov    %ecx,0x8(%eax)
    889a:	8b 52 0c             	mov    0xc(%edx),%edx
    889d:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    88a0:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    88a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    88a7:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    88aa:	0f 8c 50 ff ff ff    	jl     8800 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    88b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    88b3:	01 c0                	add    %eax,%eax
    88b5:	01 45 ec             	add    %eax,-0x14(%ebp)
    88b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    88bb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    88be:	0f 8c fc fe ff ff    	jl     87c0 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    88c4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    88c8:	d1 65 f4             	shll   -0xc(%ebp)
    88cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    88ce:	3b 45 0c             	cmp    0xc(%ebp),%eax
    88d1:	0f 8c b3 fe ff ff    	jl     878a <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    88d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    88da:	83 e0 01             	and    $0x1,%eax
    88dd:	85 c0                	test   %eax,%eax
    88df:	74 18                	je     88f9 <bpmnode_sort+0x19d>
    88e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    88e4:	c1 e0 04             	shl    $0x4,%eax
    88e7:	83 ec 04             	sub    $0x4,%esp
    88ea:	50                   	push   %eax
    88eb:	ff 75 dc             	pushl  -0x24(%ebp)
    88ee:	ff 75 08             	pushl  0x8(%ebp)
    88f1:	e8 71 e6 ff ff       	call   6f67 <lodepng_memcpy>
    88f6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    88f9:	83 ec 0c             	sub    $0xc,%esp
    88fc:	ff 75 dc             	pushl  -0x24(%ebp)
    88ff:	e8 46 e6 ff ff       	call   6f4a <lodepng_free>
    8904:	83 c4 10             	add    $0x10,%esp
}
    8907:	90                   	nop
    8908:	c9                   	leave  
    8909:	c3                   	ret    

0000890a <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    890a:	55                   	push   %ebp
    890b:	89 e5                	mov    %esp,%ebp
    890d:	56                   	push   %esi
    890e:	53                   	push   %ebx
    890f:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    8912:	8b 45 08             	mov    0x8(%ebp),%eax
    8915:	8b 40 1c             	mov    0x1c(%eax),%eax
    8918:	8b 55 14             	mov    0x14(%ebp),%edx
    891b:	c1 e2 02             	shl    $0x2,%edx
    891e:	01 d0                	add    %edx,%eax
    8920:	8b 00                	mov    (%eax),%eax
    8922:	8b 40 04             	mov    0x4(%eax),%eax
    8925:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    8928:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    892c:	75 66                	jne    8994 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    892e:	8b 45 10             	mov    0x10(%ebp),%eax
    8931:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    8934:	0f 83 a0 01 00 00    	jae    8ada <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    893a:	8b 45 08             	mov    0x8(%ebp),%eax
    893d:	8b 40 18             	mov    0x18(%eax),%eax
    8940:	8b 55 14             	mov    0x14(%ebp),%edx
    8943:	c1 e2 02             	shl    $0x2,%edx
    8946:	01 c2                	add    %eax,%edx
    8948:	8b 45 08             	mov    0x8(%ebp),%eax
    894b:	8b 40 1c             	mov    0x1c(%eax),%eax
    894e:	8b 4d 14             	mov    0x14(%ebp),%ecx
    8951:	c1 e1 02             	shl    $0x2,%ecx
    8954:	01 c8                	add    %ecx,%eax
    8956:	8b 00                	mov    (%eax),%eax
    8958:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    895a:	8b 45 08             	mov    0x8(%ebp),%eax
    895d:	8b 40 1c             	mov    0x1c(%eax),%eax
    8960:	8b 55 14             	mov    0x14(%ebp),%edx
    8963:	c1 e2 02             	shl    $0x2,%edx
    8966:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    8969:	8b 45 f4             	mov    -0xc(%ebp),%eax
    896c:	8d 50 01             	lea    0x1(%eax),%edx
    896f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8972:	c1 e0 04             	shl    $0x4,%eax
    8975:	89 c1                	mov    %eax,%ecx
    8977:	8b 45 0c             	mov    0xc(%ebp),%eax
    897a:	01 c8                	add    %ecx,%eax
    897c:	8b 00                	mov    (%eax),%eax
    897e:	6a 00                	push   $0x0
    8980:	52                   	push   %edx
    8981:	50                   	push   %eax
    8982:	ff 75 08             	pushl  0x8(%ebp)
    8985:	e8 6a fc ff ff       	call   85f4 <bpmnode_create>
    898a:	83 c4 10             	add    $0x10,%esp
    898d:	89 03                	mov    %eax,(%ebx)
    898f:	e9 47 01 00 00       	jmp    8adb <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    8994:	8b 45 08             	mov    0x8(%ebp),%eax
    8997:	8b 40 18             	mov    0x18(%eax),%eax
    899a:	8b 55 14             	mov    0x14(%ebp),%edx
    899d:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    89a3:	c1 e2 02             	shl    $0x2,%edx
    89a6:	01 d0                	add    %edx,%eax
    89a8:	8b 00                	mov    (%eax),%eax
    89aa:	8b 10                	mov    (%eax),%edx
    89ac:	8b 45 08             	mov    0x8(%ebp),%eax
    89af:	8b 40 1c             	mov    0x1c(%eax),%eax
    89b2:	8b 4d 14             	mov    0x14(%ebp),%ecx
    89b5:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    89bb:	c1 e1 02             	shl    $0x2,%ecx
    89be:	01 c8                	add    %ecx,%eax
    89c0:	8b 00                	mov    (%eax),%eax
    89c2:	8b 00                	mov    (%eax),%eax
    89c4:	01 d0                	add    %edx,%eax
    89c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    89c9:	8b 45 08             	mov    0x8(%ebp),%eax
    89cc:	8b 40 18             	mov    0x18(%eax),%eax
    89cf:	8b 55 14             	mov    0x14(%ebp),%edx
    89d2:	c1 e2 02             	shl    $0x2,%edx
    89d5:	01 c2                	add    %eax,%edx
    89d7:	8b 45 08             	mov    0x8(%ebp),%eax
    89da:	8b 40 1c             	mov    0x1c(%eax),%eax
    89dd:	8b 4d 14             	mov    0x14(%ebp),%ecx
    89e0:	c1 e1 02             	shl    $0x2,%ecx
    89e3:	01 c8                	add    %ecx,%eax
    89e5:	8b 00                	mov    (%eax),%eax
    89e7:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    89e9:	8b 45 10             	mov    0x10(%ebp),%eax
    89ec:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    89ef:	73 60                	jae    8a51 <boundaryPM+0x147>
    89f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    89f4:	c1 e0 04             	shl    $0x4,%eax
    89f7:	89 c2                	mov    %eax,%edx
    89f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    89fc:	01 d0                	add    %edx,%eax
    89fe:	8b 00                	mov    (%eax),%eax
    8a00:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8a03:	7d 4c                	jge    8a51 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    8a05:	8b 45 08             	mov    0x8(%ebp),%eax
    8a08:	8b 40 1c             	mov    0x1c(%eax),%eax
    8a0b:	8b 55 14             	mov    0x14(%ebp),%edx
    8a0e:	c1 e2 02             	shl    $0x2,%edx
    8a11:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    8a14:	8b 45 08             	mov    0x8(%ebp),%eax
    8a17:	8b 40 1c             	mov    0x1c(%eax),%eax
    8a1a:	8b 55 14             	mov    0x14(%ebp),%edx
    8a1d:	c1 e2 02             	shl    $0x2,%edx
    8a20:	01 d0                	add    %edx,%eax
    8a22:	8b 00                	mov    (%eax),%eax
    8a24:	8b 50 08             	mov    0x8(%eax),%edx
    8a27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8a2a:	8d 48 01             	lea    0x1(%eax),%ecx
    8a2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8a30:	c1 e0 04             	shl    $0x4,%eax
    8a33:	89 c6                	mov    %eax,%esi
    8a35:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a38:	01 f0                	add    %esi,%eax
    8a3a:	8b 00                	mov    (%eax),%eax
    8a3c:	52                   	push   %edx
    8a3d:	51                   	push   %ecx
    8a3e:	50                   	push   %eax
    8a3f:	ff 75 08             	pushl  0x8(%ebp)
    8a42:	e8 ad fb ff ff       	call   85f4 <bpmnode_create>
    8a47:	83 c4 10             	add    $0x10,%esp
    8a4a:	89 03                	mov    %eax,(%ebx)
      return;
    8a4c:	e9 8a 00 00 00       	jmp    8adb <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    8a51:	8b 45 08             	mov    0x8(%ebp),%eax
    8a54:	8b 40 1c             	mov    0x1c(%eax),%eax
    8a57:	8b 55 14             	mov    0x14(%ebp),%edx
    8a5a:	c1 e2 02             	shl    $0x2,%edx
    8a5d:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    8a60:	8b 45 08             	mov    0x8(%ebp),%eax
    8a63:	8b 40 1c             	mov    0x1c(%eax),%eax
    8a66:	8b 55 14             	mov    0x14(%ebp),%edx
    8a69:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    8a6f:	c1 e2 02             	shl    $0x2,%edx
    8a72:	01 d0                	add    %edx,%eax
    8a74:	8b 00                	mov    (%eax),%eax
    8a76:	50                   	push   %eax
    8a77:	ff 75 f4             	pushl  -0xc(%ebp)
    8a7a:	ff 75 f0             	pushl  -0x10(%ebp)
    8a7d:	ff 75 08             	pushl  0x8(%ebp)
    8a80:	e8 6f fb ff ff       	call   85f4 <bpmnode_create>
    8a85:	83 c4 10             	add    $0x10,%esp
    8a88:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    8a8a:	8b 45 18             	mov    0x18(%ebp),%eax
    8a8d:	8d 50 01             	lea    0x1(%eax),%edx
    8a90:	8b 45 10             	mov    0x10(%ebp),%eax
    8a93:	83 e8 01             	sub    $0x1,%eax
    8a96:	01 c0                	add    %eax,%eax
    8a98:	39 c2                	cmp    %eax,%edx
    8a9a:	7d 3f                	jge    8adb <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    8a9c:	8b 45 14             	mov    0x14(%ebp),%eax
    8a9f:	83 e8 01             	sub    $0x1,%eax
    8aa2:	83 ec 0c             	sub    $0xc,%esp
    8aa5:	ff 75 18             	pushl  0x18(%ebp)
    8aa8:	50                   	push   %eax
    8aa9:	ff 75 10             	pushl  0x10(%ebp)
    8aac:	ff 75 0c             	pushl  0xc(%ebp)
    8aaf:	ff 75 08             	pushl  0x8(%ebp)
    8ab2:	e8 53 fe ff ff       	call   890a <boundaryPM>
    8ab7:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    8aba:	8b 45 14             	mov    0x14(%ebp),%eax
    8abd:	83 e8 01             	sub    $0x1,%eax
    8ac0:	83 ec 0c             	sub    $0xc,%esp
    8ac3:	ff 75 18             	pushl  0x18(%ebp)
    8ac6:	50                   	push   %eax
    8ac7:	ff 75 10             	pushl  0x10(%ebp)
    8aca:	ff 75 0c             	pushl  0xc(%ebp)
    8acd:	ff 75 08             	pushl  0x8(%ebp)
    8ad0:	e8 35 fe ff ff       	call   890a <boundaryPM>
    8ad5:	83 c4 20             	add    $0x20,%esp
    8ad8:	eb 01                	jmp    8adb <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    8ada:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    8adb:	8d 65 f8             	lea    -0x8(%ebp),%esp
    8ade:	5b                   	pop    %ebx
    8adf:	5e                   	pop    %esi
    8ae0:	5d                   	pop    %ebp
    8ae1:	c3                   	ret    

00008ae2 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    8ae2:	55                   	push   %ebp
    8ae3:	89 e5                	mov    %esp,%ebp
    8ae5:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    8ae8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    8aef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    8af6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8afa:	75 0a                	jne    8b06 <lodepng_huffman_code_lengths+0x24>
    8afc:	b8 50 00 00 00       	mov    $0x50,%eax
    8b01:	e9 4d 03 00 00       	jmp    8e53 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    8b06:	8b 45 14             	mov    0x14(%ebp),%eax
    8b09:	ba 01 00 00 00       	mov    $0x1,%edx
    8b0e:	89 c1                	mov    %eax,%ecx
    8b10:	d3 e2                	shl    %cl,%edx
    8b12:	8b 45 10             	mov    0x10(%ebp),%eax
    8b15:	39 c2                	cmp    %eax,%edx
    8b17:	73 0a                	jae    8b23 <lodepng_huffman_code_lengths+0x41>
    8b19:	b8 50 00 00 00       	mov    $0x50,%eax
    8b1e:	e9 30 03 00 00       	jmp    8e53 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    8b23:	8b 45 10             	mov    0x10(%ebp),%eax
    8b26:	c1 e0 04             	shl    $0x4,%eax
    8b29:	83 ec 0c             	sub    $0xc,%esp
    8b2c:	50                   	push   %eax
    8b2d:	e8 f7 e3 ff ff       	call   6f29 <lodepng_malloc>
    8b32:	83 c4 10             	add    $0x10,%esp
    8b35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    8b38:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    8b3c:	75 0a                	jne    8b48 <lodepng_huffman_code_lengths+0x66>
    8b3e:	b8 53 00 00 00       	mov    $0x53,%eax
    8b43:	e9 0b 03 00 00       	jmp    8e53 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    8b48:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    8b4f:	eb 50                	jmp    8ba1 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    8b51:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8b54:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8b5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b5e:	01 d0                	add    %edx,%eax
    8b60:	8b 00                	mov    (%eax),%eax
    8b62:	85 c0                	test   %eax,%eax
    8b64:	74 37                	je     8b9d <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    8b66:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8b69:	c1 e0 04             	shl    $0x4,%eax
    8b6c:	89 c2                	mov    %eax,%edx
    8b6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8b71:	01 d0                	add    %edx,%eax
    8b73:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8b76:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    8b7d:	8b 55 0c             	mov    0xc(%ebp),%edx
    8b80:	01 ca                	add    %ecx,%edx
    8b82:	8b 12                	mov    (%edx),%edx
    8b84:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    8b86:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8b89:	c1 e0 04             	shl    $0x4,%eax
    8b8c:	89 c2                	mov    %eax,%edx
    8b8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8b91:	01 c2                	add    %eax,%edx
    8b93:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8b96:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    8b99:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    8b9d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8ba1:	8b 45 10             	mov    0x10(%ebp),%eax
    8ba4:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    8ba7:	75 a8                	jne    8b51 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    8ba9:	8b 45 10             	mov    0x10(%ebp),%eax
    8bac:	c1 e0 02             	shl    $0x2,%eax
    8baf:	83 ec 04             	sub    $0x4,%esp
    8bb2:	50                   	push   %eax
    8bb3:	6a 00                	push   $0x0
    8bb5:	ff 75 08             	pushl  0x8(%ebp)
    8bb8:	e8 dd e3 ff ff       	call   6f9a <lodepng_memset>
    8bbd:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    8bc0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    8bc4:	75 18                	jne    8bde <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    8bc6:	8b 45 08             	mov    0x8(%ebp),%eax
    8bc9:	83 c0 04             	add    $0x4,%eax
    8bcc:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    8bd2:	8b 10                	mov    (%eax),%edx
    8bd4:	8b 45 08             	mov    0x8(%ebp),%eax
    8bd7:	89 10                	mov    %edx,(%eax)
    8bd9:	e9 64 02 00 00       	jmp    8e42 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    8bde:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    8be2:	75 3e                	jne    8c22 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    8be4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8be7:	8b 40 04             	mov    0x4(%eax),%eax
    8bea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8bf1:	8b 45 08             	mov    0x8(%ebp),%eax
    8bf4:	01 d0                	add    %edx,%eax
    8bf6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    8bfc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8bff:	8b 40 04             	mov    0x4(%eax),%eax
    8c02:	85 c0                	test   %eax,%eax
    8c04:	75 07                	jne    8c0d <lodepng_huffman_code_lengths+0x12b>
    8c06:	ba 04 00 00 00       	mov    $0x4,%edx
    8c0b:	eb 05                	jmp    8c12 <lodepng_huffman_code_lengths+0x130>
    8c0d:	ba 00 00 00 00       	mov    $0x0,%edx
    8c12:	8b 45 08             	mov    0x8(%ebp),%eax
    8c15:	01 d0                	add    %edx,%eax
    8c17:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    8c1d:	e9 20 02 00 00       	jmp    8e42 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    8c22:	83 ec 08             	sub    $0x8,%esp
    8c25:	ff 75 ec             	pushl  -0x14(%ebp)
    8c28:	ff 75 e4             	pushl  -0x1c(%ebp)
    8c2b:	e8 2c fb ff ff       	call   875c <bpmnode_sort>
    8c30:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    8c33:	8b 45 14             	mov    0x14(%ebp),%eax
    8c36:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    8c39:	8b 45 14             	mov    0x14(%ebp),%eax
    8c3c:	83 c0 01             	add    $0x1,%eax
    8c3f:	0f af 45 14          	imul   0x14(%ebp),%eax
    8c43:	01 c0                	add    %eax,%eax
    8c45:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    8c48:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    8c4f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    8c52:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    8c55:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    8c58:	c1 e0 04             	shl    $0x4,%eax
    8c5b:	83 ec 0c             	sub    $0xc,%esp
    8c5e:	50                   	push   %eax
    8c5f:	e8 c5 e2 ff ff       	call   6f29 <lodepng_malloc>
    8c64:	83 c4 10             	add    $0x10,%esp
    8c67:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    8c6a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    8c6d:	c1 e0 02             	shl    $0x2,%eax
    8c70:	83 ec 0c             	sub    $0xc,%esp
    8c73:	50                   	push   %eax
    8c74:	e8 b0 e2 ff ff       	call   6f29 <lodepng_malloc>
    8c79:	83 c4 10             	add    $0x10,%esp
    8c7c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    8c7f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8c82:	c1 e0 02             	shl    $0x2,%eax
    8c85:	83 ec 0c             	sub    $0xc,%esp
    8c88:	50                   	push   %eax
    8c89:	e8 9b e2 ff ff       	call   6f29 <lodepng_malloc>
    8c8e:	83 c4 10             	add    $0x10,%esp
    8c91:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    8c94:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8c97:	c1 e0 02             	shl    $0x2,%eax
    8c9a:	83 ec 0c             	sub    $0xc,%esp
    8c9d:	50                   	push   %eax
    8c9e:	e8 86 e2 ff ff       	call   6f29 <lodepng_malloc>
    8ca3:	83 c4 10             	add    $0x10,%esp
    8ca6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    8ca9:	8b 45 c8             	mov    -0x38(%ebp),%eax
    8cac:	85 c0                	test   %eax,%eax
    8cae:	74 15                	je     8cc5 <lodepng_huffman_code_lengths+0x1e3>
    8cb0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8cb3:	85 c0                	test   %eax,%eax
    8cb5:	74 0e                	je     8cc5 <lodepng_huffman_code_lengths+0x1e3>
    8cb7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8cba:	85 c0                	test   %eax,%eax
    8cbc:	74 07                	je     8cc5 <lodepng_huffman_code_lengths+0x1e3>
    8cbe:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8cc1:	85 c0                	test   %eax,%eax
    8cc3:	75 07                	jne    8ccc <lodepng_huffman_code_lengths+0x1ea>
    8cc5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    8ccc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8cd0:	0f 85 30 01 00 00    	jne    8e06 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    8cd6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    8cdd:	eb 1c                	jmp    8cfb <lodepng_huffman_code_lengths+0x219>
    8cdf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8ce2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8ce5:	c1 e2 02             	shl    $0x2,%edx
    8ce8:	01 d0                	add    %edx,%eax
    8cea:	8b 55 c8             	mov    -0x38(%ebp),%edx
    8ced:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    8cf0:	c1 e1 04             	shl    $0x4,%ecx
    8cf3:	01 ca                	add    %ecx,%edx
    8cf5:	89 10                	mov    %edx,(%eax)
    8cf7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8cfb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    8cfe:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8d01:	75 dc                	jne    8cdf <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    8d03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8d06:	8b 00                	mov    (%eax),%eax
    8d08:	6a 00                	push   $0x0
    8d0a:	6a 01                	push   $0x1
    8d0c:	50                   	push   %eax
    8d0d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8d10:	50                   	push   %eax
    8d11:	e8 de f8 ff ff       	call   85f4 <bpmnode_create>
    8d16:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    8d19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8d1c:	83 c0 10             	add    $0x10,%eax
    8d1f:	8b 00                	mov    (%eax),%eax
    8d21:	6a 00                	push   $0x0
    8d23:	6a 02                	push   $0x2
    8d25:	50                   	push   %eax
    8d26:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8d29:	50                   	push   %eax
    8d2a:	e8 c5 f8 ff ff       	call   85f4 <bpmnode_create>
    8d2f:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    8d32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    8d39:	eb 27                	jmp    8d62 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    8d3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8d3e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8d41:	c1 e2 02             	shl    $0x2,%edx
    8d44:	01 c2                	add    %eax,%edx
    8d46:	8b 45 c8             	mov    -0x38(%ebp),%eax
    8d49:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    8d4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8d4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8d51:	c1 e2 02             	shl    $0x2,%edx
    8d54:	01 d0                	add    %edx,%eax
    8d56:	8b 55 c8             	mov    -0x38(%ebp),%edx
    8d59:	83 c2 10             	add    $0x10,%edx
    8d5c:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    8d5e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8d62:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8d65:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8d68:	75 d1                	jne    8d3b <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    8d6a:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    8d71:	eb 24                	jmp    8d97 <lodepng_huffman_code_lengths+0x2b5>
    8d73:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8d76:	8b 55 14             	mov    0x14(%ebp),%edx
    8d79:	83 ea 01             	sub    $0x1,%edx
    8d7c:	83 ec 0c             	sub    $0xc,%esp
    8d7f:	50                   	push   %eax
    8d80:	52                   	push   %edx
    8d81:	ff 75 ec             	pushl  -0x14(%ebp)
    8d84:	ff 75 e4             	pushl  -0x1c(%ebp)
    8d87:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    8d8a:	50                   	push   %eax
    8d8b:	e8 7a fb ff ff       	call   890a <boundaryPM>
    8d90:	83 c4 20             	add    $0x20,%esp
    8d93:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8d97:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8d9a:	83 e8 01             	sub    $0x1,%eax
    8d9d:	01 c0                	add    %eax,%eax
    8d9f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8da2:	75 cf                	jne    8d73 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    8da4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8da7:	8b 55 14             	mov    0x14(%ebp),%edx
    8daa:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    8db0:	c1 e2 02             	shl    $0x2,%edx
    8db3:	01 d0                	add    %edx,%eax
    8db5:	8b 00                	mov    (%eax),%eax
    8db7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    8dba:	eb 44                	jmp    8e00 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    8dbc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    8dc3:	eb 27                	jmp    8dec <lodepng_huffman_code_lengths+0x30a>
    8dc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8dc8:	c1 e0 04             	shl    $0x4,%eax
    8dcb:	89 c2                	mov    %eax,%edx
    8dcd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8dd0:	01 d0                	add    %edx,%eax
    8dd2:	8b 40 04             	mov    0x4(%eax),%eax
    8dd5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8ddc:	8b 45 08             	mov    0x8(%ebp),%eax
    8ddf:	01 d0                	add    %edx,%eax
    8de1:	8b 10                	mov    (%eax),%edx
    8de3:	83 c2 01             	add    $0x1,%edx
    8de6:	89 10                	mov    %edx,(%eax)
    8de8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    8dec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8def:	8b 40 04             	mov    0x4(%eax),%eax
    8df2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    8df5:	75 ce                	jne    8dc5 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    8df7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8dfa:	8b 40 08             	mov    0x8(%eax),%eax
    8dfd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    8e00:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    8e04:	75 b6                	jne    8dbc <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    8e06:	8b 45 c8             	mov    -0x38(%ebp),%eax
    8e09:	83 ec 0c             	sub    $0xc,%esp
    8e0c:	50                   	push   %eax
    8e0d:	e8 38 e1 ff ff       	call   6f4a <lodepng_free>
    8e12:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    8e15:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8e18:	83 ec 0c             	sub    $0xc,%esp
    8e1b:	50                   	push   %eax
    8e1c:	e8 29 e1 ff ff       	call   6f4a <lodepng_free>
    8e21:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    8e24:	8b 45 dc             	mov    -0x24(%ebp),%eax
    8e27:	83 ec 0c             	sub    $0xc,%esp
    8e2a:	50                   	push   %eax
    8e2b:	e8 1a e1 ff ff       	call   6f4a <lodepng_free>
    8e30:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    8e33:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8e36:	83 ec 0c             	sub    $0xc,%esp
    8e39:	50                   	push   %eax
    8e3a:	e8 0b e1 ff ff       	call   6f4a <lodepng_free>
    8e3f:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    8e42:	83 ec 0c             	sub    $0xc,%esp
    8e45:	ff 75 e4             	pushl  -0x1c(%ebp)
    8e48:	e8 fd e0 ff ff       	call   6f4a <lodepng_free>
    8e4d:	83 c4 10             	add    $0x10,%esp
  return error;
    8e50:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8e53:	c9                   	leave  
    8e54:	c3                   	ret    

00008e55 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    8e55:	55                   	push   %ebp
    8e56:	89 e5                	mov    %esp,%ebp
    8e58:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    8e5b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    8e62:	eb 04                	jmp    8e68 <HuffmanTree_makeFromFrequencies+0x13>
    8e64:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    8e68:	8b 45 14             	mov    0x14(%ebp),%eax
    8e6b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    8e70:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8e77:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e7a:	01 d0                	add    %edx,%eax
    8e7c:	8b 00                	mov    (%eax),%eax
    8e7e:	85 c0                	test   %eax,%eax
    8e80:	75 08                	jne    8e8a <HuffmanTree_makeFromFrequencies+0x35>
    8e82:	8b 45 14             	mov    0x14(%ebp),%eax
    8e85:	3b 45 10             	cmp    0x10(%ebp),%eax
    8e88:	7f da                	jg     8e64 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    8e8a:	8b 45 14             	mov    0x14(%ebp),%eax
    8e8d:	c1 e0 02             	shl    $0x2,%eax
    8e90:	83 ec 0c             	sub    $0xc,%esp
    8e93:	50                   	push   %eax
    8e94:	e8 90 e0 ff ff       	call   6f29 <lodepng_malloc>
    8e99:	83 c4 10             	add    $0x10,%esp
    8e9c:	89 c2                	mov    %eax,%edx
    8e9e:	8b 45 08             	mov    0x8(%ebp),%eax
    8ea1:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    8ea4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ea7:	8b 40 04             	mov    0x4(%eax),%eax
    8eaa:	85 c0                	test   %eax,%eax
    8eac:	75 07                	jne    8eb5 <HuffmanTree_makeFromFrequencies+0x60>
    8eae:	b8 53 00 00 00       	mov    $0x53,%eax
    8eb3:	eb 47                	jmp    8efc <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    8eb5:	8b 45 08             	mov    0x8(%ebp),%eax
    8eb8:	8b 55 18             	mov    0x18(%ebp),%edx
    8ebb:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    8ebe:	8b 55 14             	mov    0x14(%ebp),%edx
    8ec1:	8b 45 08             	mov    0x8(%ebp),%eax
    8ec4:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    8ec7:	8b 45 08             	mov    0x8(%ebp),%eax
    8eca:	8b 40 04             	mov    0x4(%eax),%eax
    8ecd:	ff 75 18             	pushl  0x18(%ebp)
    8ed0:	ff 75 14             	pushl  0x14(%ebp)
    8ed3:	ff 75 0c             	pushl  0xc(%ebp)
    8ed6:	50                   	push   %eax
    8ed7:	e8 06 fc ff ff       	call   8ae2 <lodepng_huffman_code_lengths>
    8edc:	83 c4 10             	add    $0x10,%esp
    8edf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    8ee2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8ee6:	75 11                	jne    8ef9 <HuffmanTree_makeFromFrequencies+0xa4>
    8ee8:	83 ec 0c             	sub    $0xc,%esp
    8eeb:	ff 75 08             	pushl  0x8(%ebp)
    8eee:	e8 37 f4 ff ff       	call   832a <HuffmanTree_makeFromLengths2>
    8ef3:	83 c4 10             	add    $0x10,%esp
    8ef6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    8ef9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8efc:	c9                   	leave  
    8efd:	c3                   	ret    

00008efe <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    8efe:	55                   	push   %ebp
    8eff:	89 e5                	mov    %esp,%ebp
    8f01:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    8f04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    8f0b:	83 ec 0c             	sub    $0xc,%esp
    8f0e:	68 80 04 00 00       	push   $0x480
    8f13:	e8 11 e0 ff ff       	call   6f29 <lodepng_malloc>
    8f18:	83 c4 10             	add    $0x10,%esp
    8f1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    8f1e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    8f22:	75 0a                	jne    8f2e <generateFixedLitLenTree+0x30>
    8f24:	b8 53 00 00 00       	mov    $0x53,%eax
    8f29:	e9 d5 00 00 00       	jmp    9003 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    8f2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8f35:	eb 19                	jmp    8f50 <generateFixedLitLenTree+0x52>
    8f37:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8f3a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8f41:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8f44:	01 d0                	add    %edx,%eax
    8f46:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    8f4c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8f50:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    8f57:	76 de                	jbe    8f37 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    8f59:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    8f60:	eb 19                	jmp    8f7b <generateFixedLitLenTree+0x7d>
    8f62:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8f65:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8f6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8f6f:	01 d0                	add    %edx,%eax
    8f71:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    8f77:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8f7b:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    8f82:	76 de                	jbe    8f62 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    8f84:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    8f8b:	eb 19                	jmp    8fa6 <generateFixedLitLenTree+0xa8>
    8f8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8f90:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8f97:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8f9a:	01 d0                	add    %edx,%eax
    8f9c:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    8fa2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8fa6:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    8fad:	76 de                	jbe    8f8d <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    8faf:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    8fb6:	eb 19                	jmp    8fd1 <generateFixedLitLenTree+0xd3>
    8fb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8fbb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8fc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8fc5:	01 d0                	add    %edx,%eax
    8fc7:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    8fcd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8fd1:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    8fd8:	76 de                	jbe    8fb8 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    8fda:	6a 0f                	push   $0xf
    8fdc:	68 20 01 00 00       	push   $0x120
    8fe1:	ff 75 ec             	pushl  -0x14(%ebp)
    8fe4:	ff 75 08             	pushl  0x8(%ebp)
    8fe7:	e8 7f f5 ff ff       	call   856b <HuffmanTree_makeFromLengths>
    8fec:	83 c4 10             	add    $0x10,%esp
    8fef:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    8ff2:	83 ec 0c             	sub    $0xc,%esp
    8ff5:	ff 75 ec             	pushl  -0x14(%ebp)
    8ff8:	e8 4d df ff ff       	call   6f4a <lodepng_free>
    8ffd:	83 c4 10             	add    $0x10,%esp
  return error;
    9000:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    9003:	c9                   	leave  
    9004:	c3                   	ret    

00009005 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    9005:	55                   	push   %ebp
    9006:	89 e5                	mov    %esp,%ebp
    9008:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    900b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    9012:	83 ec 0c             	sub    $0xc,%esp
    9015:	68 80 00 00 00       	push   $0x80
    901a:	e8 0a df ff ff       	call   6f29 <lodepng_malloc>
    901f:	83 c4 10             	add    $0x10,%esp
    9022:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    9025:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9029:	75 07                	jne    9032 <generateFixedDistanceTree+0x2d>
    902b:	b8 53 00 00 00       	mov    $0x53,%eax
    9030:	eb 4e                	jmp    9080 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    9032:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9039:	eb 19                	jmp    9054 <generateFixedDistanceTree+0x4f>
    903b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    903e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9045:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9048:	01 d0                	add    %edx,%eax
    904a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    9050:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9054:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    9058:	75 e1                	jne    903b <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    905a:	6a 0f                	push   $0xf
    905c:	6a 20                	push   $0x20
    905e:	ff 75 ec             	pushl  -0x14(%ebp)
    9061:	ff 75 08             	pushl  0x8(%ebp)
    9064:	e8 02 f5 ff ff       	call   856b <HuffmanTree_makeFromLengths>
    9069:	83 c4 10             	add    $0x10,%esp
    906c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    906f:	83 ec 0c             	sub    $0xc,%esp
    9072:	ff 75 ec             	pushl  -0x14(%ebp)
    9075:	e8 d0 de ff ff       	call   6f4a <lodepng_free>
    907a:	83 c4 10             	add    $0x10,%esp
  return error;
    907d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    9080:	c9                   	leave  
    9081:	c3                   	ret    

00009082 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    9082:	55                   	push   %ebp
    9083:	89 e5                	mov    %esp,%ebp
    9085:	53                   	push   %ebx
    9086:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    9089:	6a 09                	push   $0x9
    908b:	ff 75 08             	pushl  0x8(%ebp)
    908e:	e8 d8 eb ff ff       	call   7c6b <peekBits>
    9093:	83 c4 08             	add    $0x8,%esp
    9096:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    909a:	8b 45 0c             	mov    0xc(%ebp),%eax
    909d:	8b 50 10             	mov    0x10(%eax),%edx
    90a0:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    90a4:	01 d0                	add    %edx,%eax
    90a6:	0f b6 00             	movzbl (%eax),%eax
    90a9:	0f b6 c0             	movzbl %al,%eax
    90ac:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    90b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    90b3:	8b 40 14             	mov    0x14(%eax),%eax
    90b6:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    90ba:	01 d2                	add    %edx,%edx
    90bc:	01 d0                	add    %edx,%eax
    90be:	0f b7 00             	movzwl (%eax),%eax
    90c1:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    90c5:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    90ca:	77 16                	ja     90e2 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    90cc:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    90d0:	50                   	push   %eax
    90d1:	ff 75 08             	pushl  0x8(%ebp)
    90d4:	e8 b2 eb ff ff       	call   7c8b <advanceBits>
    90d9:	83 c4 08             	add    $0x8,%esp
    return value;
    90dc:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    90e0:	eb 5c                	jmp    913e <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    90e2:	6a 09                	push   $0x9
    90e4:	ff 75 08             	pushl  0x8(%ebp)
    90e7:	e8 9f eb ff ff       	call   7c8b <advanceBits>
    90ec:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    90ef:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    90f3:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    90f7:	83 e8 09             	sub    $0x9,%eax
    90fa:	50                   	push   %eax
    90fb:	ff 75 08             	pushl  0x8(%ebp)
    90fe:	e8 68 eb ff ff       	call   7c6b <peekBits>
    9103:	83 c4 08             	add    $0x8,%esp
    9106:	01 d8                	add    %ebx,%eax
    9108:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    910b:	8b 45 0c             	mov    0xc(%ebp),%eax
    910e:	8b 50 10             	mov    0x10(%eax),%edx
    9111:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9114:	01 d0                	add    %edx,%eax
    9116:	0f b6 00             	movzbl (%eax),%eax
    9119:	0f b6 c0             	movzbl %al,%eax
    911c:	83 e8 09             	sub    $0x9,%eax
    911f:	50                   	push   %eax
    9120:	ff 75 08             	pushl  0x8(%ebp)
    9123:	e8 63 eb ff ff       	call   7c8b <advanceBits>
    9128:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    912b:	8b 45 0c             	mov    0xc(%ebp),%eax
    912e:	8b 40 14             	mov    0x14(%eax),%eax
    9131:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9134:	01 d2                	add    %edx,%edx
    9136:	01 d0                	add    %edx,%eax
    9138:	0f b7 00             	movzwl (%eax),%eax
    913b:	0f b7 c0             	movzwl %ax,%eax
  }
}
    913e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9141:	c9                   	leave  
    9142:	c3                   	ret    

00009143 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    9143:	55                   	push   %ebp
    9144:	89 e5                	mov    %esp,%ebp
    9146:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    9149:	83 ec 0c             	sub    $0xc,%esp
    914c:	ff 75 08             	pushl  0x8(%ebp)
    914f:	e8 aa fd ff ff       	call   8efe <generateFixedLitLenTree>
    9154:	83 c4 10             	add    $0x10,%esp
    9157:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    915a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    915e:	74 05                	je     9165 <getTreeInflateFixed+0x22>
    9160:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9163:	eb 0e                	jmp    9173 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    9165:	83 ec 0c             	sub    $0xc,%esp
    9168:	ff 75 0c             	pushl  0xc(%ebp)
    916b:	e8 95 fe ff ff       	call   9005 <generateFixedDistanceTree>
    9170:	83 c4 10             	add    $0x10,%esp
}
    9173:	c9                   	leave  
    9174:	c3                   	ret    

00009175 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    9175:	55                   	push   %ebp
    9176:	89 e5                	mov    %esp,%ebp
    9178:	53                   	push   %ebx
    9179:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    917c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    9183:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    918a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    9191:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    9198:	6a 0e                	push   $0xe
    919a:	ff 75 10             	pushl  0x10(%ebp)
    919d:	e8 37 e6 ff ff       	call   77d9 <ensureBits17>
    91a2:	83 c4 08             	add    $0x8,%esp
    91a5:	85 c0                	test   %eax,%eax
    91a7:	75 0a                	jne    91b3 <getTreeInflateDynamic+0x3e>
    91a9:	b8 31 00 00 00       	mov    $0x31,%eax
    91ae:	e9 ec 04 00 00       	jmp    969f <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    91b3:	6a 05                	push   $0x5
    91b5:	ff 75 10             	pushl  0x10(%ebp)
    91b8:	e8 f8 ea ff ff       	call   7cb5 <readBits>
    91bd:	83 c4 08             	add    $0x8,%esp
    91c0:	05 01 01 00 00       	add    $0x101,%eax
    91c5:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    91c8:	6a 05                	push   $0x5
    91ca:	ff 75 10             	pushl  0x10(%ebp)
    91cd:	e8 e3 ea ff ff       	call   7cb5 <readBits>
    91d2:	83 c4 08             	add    $0x8,%esp
    91d5:	83 c0 01             	add    $0x1,%eax
    91d8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    91db:	6a 04                	push   $0x4
    91dd:	ff 75 10             	pushl  0x10(%ebp)
    91e0:	e8 d0 ea ff ff       	call   7cb5 <readBits>
    91e5:	83 c4 08             	add    $0x8,%esp
    91e8:	83 c0 04             	add    $0x4,%eax
    91eb:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    91ee:	83 ec 0c             	sub    $0xc,%esp
    91f1:	6a 4c                	push   $0x4c
    91f3:	e8 31 dd ff ff       	call   6f29 <lodepng_malloc>
    91f8:	83 c4 10             	add    $0x10,%esp
    91fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    91fe:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    9202:	75 0a                	jne    920e <getTreeInflateDynamic+0x99>
    9204:	b8 53 00 00 00       	mov    $0x53,%eax
    9209:	e9 91 04 00 00       	jmp    969f <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    920e:	83 ec 0c             	sub    $0xc,%esp
    9211:	8d 45 a8             	lea    -0x58(%ebp),%eax
    9214:	50                   	push   %eax
    9215:	e8 03 ec ff ff       	call   7e1d <HuffmanTree_init>
    921a:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    921d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9221:	0f 85 3c 04 00 00    	jne    9663 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    9227:	8b 45 10             	mov    0x10(%ebp),%eax
    922a:	8b 48 08             	mov    0x8(%eax),%ecx
    922d:	8b 55 d0             	mov    -0x30(%ebp),%edx
    9230:	89 d0                	mov    %edx,%eax
    9232:	01 c0                	add    %eax,%eax
    9234:	01 d0                	add    %edx,%eax
    9236:	89 c2                	mov    %eax,%edx
    9238:	8b 45 10             	mov    0x10(%ebp),%eax
    923b:	8b 40 0c             	mov    0xc(%eax),%eax
    923e:	83 ec 04             	sub    $0x4,%esp
    9241:	51                   	push   %ecx
    9242:	52                   	push   %edx
    9243:	50                   	push   %eax
    9244:	e8 f7 dd ff ff       	call   7040 <lodepng_gtofl>
    9249:	83 c4 10             	add    $0x10,%esp
    924c:	85 c0                	test   %eax,%eax
    924e:	74 0c                	je     925c <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    9250:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    9257:	e9 07 04 00 00       	jmp    9663 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    925c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    9263:	eb 3d                	jmp    92a2 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    9265:	83 ec 08             	sub    $0x8,%esp
    9268:	6a 03                	push   $0x3
    926a:	ff 75 10             	pushl  0x10(%ebp)
    926d:	e8 8b e4 ff ff       	call   76fd <ensureBits9>
    9272:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    9275:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9278:	8b 04 85 e0 f2 01 00 	mov    0x1f2e0(,%eax,4),%eax
    927f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9286:	8b 45 dc             	mov    -0x24(%ebp),%eax
    9289:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    928c:	83 ec 08             	sub    $0x8,%esp
    928f:	6a 03                	push   $0x3
    9291:	ff 75 10             	pushl  0x10(%ebp)
    9294:	e8 1c ea ff ff       	call   7cb5 <readBits>
    9299:	83 c4 10             	add    $0x10,%esp
    929c:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    929e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    92a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    92a5:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    92a8:	75 bb                	jne    9265 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    92aa:	8b 45 d0             	mov    -0x30(%ebp),%eax
    92ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
    92b0:	eb 20                	jmp    92d2 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    92b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    92b5:	8b 04 85 e0 f2 01 00 	mov    0x1f2e0(,%eax,4),%eax
    92bc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    92c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    92c6:	01 d0                	add    %edx,%eax
    92c8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    92ce:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    92d2:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    92d6:	75 da                	jne    92b2 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    92d8:	6a 07                	push   $0x7
    92da:	6a 13                	push   $0x13
    92dc:	ff 75 dc             	pushl  -0x24(%ebp)
    92df:	8d 45 a8             	lea    -0x58(%ebp),%eax
    92e2:	50                   	push   %eax
    92e3:	e8 83 f2 ff ff       	call   856b <HuffmanTree_makeFromLengths>
    92e8:	83 c4 10             	add    $0x10,%esp
    92eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    92ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    92f2:	0f 85 64 03 00 00    	jne    965c <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    92f8:	83 ec 0c             	sub    $0xc,%esp
    92fb:	68 80 04 00 00       	push   $0x480
    9300:	e8 24 dc ff ff       	call   6f29 <lodepng_malloc>
    9305:	83 c4 10             	add    $0x10,%esp
    9308:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    930b:	83 ec 0c             	sub    $0xc,%esp
    930e:	68 80 00 00 00       	push   $0x80
    9313:	e8 11 dc ff ff       	call   6f29 <lodepng_malloc>
    9318:	83 c4 10             	add    $0x10,%esp
    931b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    931e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9322:	74 06                	je     932a <getTreeInflateDynamic+0x1b5>
    9324:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9328:	75 0c                	jne    9336 <getTreeInflateDynamic+0x1c1>
    932a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    9331:	e9 2d 03 00 00       	jmp    9663 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    9336:	83 ec 04             	sub    $0x4,%esp
    9339:	68 80 04 00 00       	push   $0x480
    933e:	6a 00                	push   $0x0
    9340:	ff 75 e8             	pushl  -0x18(%ebp)
    9343:	e8 52 dc ff ff       	call   6f9a <lodepng_memset>
    9348:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    934b:	83 ec 04             	sub    $0x4,%esp
    934e:	68 80 00 00 00       	push   $0x80
    9353:	6a 00                	push   $0x0
    9355:	ff 75 e4             	pushl  -0x1c(%ebp)
    9358:	e8 3d dc ff ff       	call   6f9a <lodepng_memset>
    935d:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    9360:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    9367:	e9 8d 02 00 00       	jmp    95f9 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    936c:	83 ec 08             	sub    $0x8,%esp
    936f:	6a 16                	push   $0x16
    9371:	ff 75 10             	pushl  0x10(%ebp)
    9374:	e8 8c e5 ff ff       	call   7905 <ensureBits25>
    9379:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    937c:	83 ec 08             	sub    $0x8,%esp
    937f:	8d 45 a8             	lea    -0x58(%ebp),%eax
    9382:	50                   	push   %eax
    9383:	ff 75 10             	pushl  0x10(%ebp)
    9386:	e8 f7 fc ff ff       	call   9082 <huffmanDecodeSymbol>
    938b:	83 c4 10             	add    $0x10,%esp
    938e:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    9391:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    9395:	77 3e                	ja     93d5 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    9397:	8b 45 ec             	mov    -0x14(%ebp),%eax
    939a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    939d:	73 16                	jae    93b5 <getTreeInflateDynamic+0x240>
    939f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    93a2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    93a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    93ac:	01 c2                	add    %eax,%edx
    93ae:	8b 45 cc             	mov    -0x34(%ebp),%eax
    93b1:	89 02                	mov    %eax,(%edx)
    93b3:	eb 17                	jmp    93cc <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    93b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    93b8:	2b 45 d8             	sub    -0x28(%ebp),%eax
    93bb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    93c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    93c5:	01 c2                	add    %eax,%edx
    93c7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    93ca:	89 02                	mov    %eax,(%edx)
        ++i;
    93cc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    93d0:	e9 0b 02 00 00       	jmp    95e0 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    93d5:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    93d9:	0f 85 da 00 00 00    	jne    94b9 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    93df:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    93e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    93ea:	75 0c                	jne    93f8 <getTreeInflateDynamic+0x283>
    93ec:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    93f3:	e9 12 02 00 00       	jmp    960a <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    93f8:	83 ec 08             	sub    $0x8,%esp
    93fb:	6a 02                	push   $0x2
    93fd:	ff 75 10             	pushl  0x10(%ebp)
    9400:	e8 b0 e8 ff ff       	call   7cb5 <readBits>
    9405:	83 c4 10             	add    $0x10,%esp
    9408:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    940b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    940e:	83 c0 01             	add    $0x1,%eax
    9411:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    9414:	76 1b                	jbe    9431 <getTreeInflateDynamic+0x2bc>
    9416:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9419:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    941e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9425:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9428:	01 d0                	add    %edx,%eax
    942a:	8b 00                	mov    (%eax),%eax
    942c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    942f:	eb 1c                	jmp    944d <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    9431:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9434:	2b 45 d8             	sub    -0x28(%ebp),%eax
    9437:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    943c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9443:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9446:	01 d0                	add    %edx,%eax
    9448:	8b 00                	mov    (%eax),%eax
    944a:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    944d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9454:	eb 56                	jmp    94ac <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    9456:	8b 55 d8             	mov    -0x28(%ebp),%edx
    9459:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    945c:	01 d0                	add    %edx,%eax
    945e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    9461:	77 0c                	ja     946f <getTreeInflateDynamic+0x2fa>
    9463:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    946a:	e9 71 01 00 00       	jmp    95e0 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    946f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9472:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    9475:	73 16                	jae    948d <getTreeInflateDynamic+0x318>
    9477:	8b 45 ec             	mov    -0x14(%ebp),%eax
    947a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9481:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9484:	01 c2                	add    %eax,%edx
    9486:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9489:	89 02                	mov    %eax,(%edx)
    948b:	eb 17                	jmp    94a4 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    948d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9490:	2b 45 d8             	sub    -0x28(%ebp),%eax
    9493:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    949a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    949d:	01 c2                	add    %eax,%edx
    949f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    94a2:	89 02                	mov    %eax,(%edx)
          ++i;
    94a4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    94a8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    94ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    94af:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    94b2:	72 a2                	jb     9456 <getTreeInflateDynamic+0x2e1>
    94b4:	e9 27 01 00 00       	jmp    95e0 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    94b9:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    94bd:	0f 85 88 00 00 00    	jne    954b <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    94c3:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    94ca:	83 ec 08             	sub    $0x8,%esp
    94cd:	6a 03                	push   $0x3
    94cf:	ff 75 10             	pushl  0x10(%ebp)
    94d2:	e8 de e7 ff ff       	call   7cb5 <readBits>
    94d7:	83 c4 10             	add    $0x10,%esp
    94da:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    94dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    94e4:	eb 58                	jmp    953e <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    94e6:	8b 55 d8             	mov    -0x28(%ebp),%edx
    94e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    94ec:	01 d0                	add    %edx,%eax
    94ee:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    94f1:	77 0c                	ja     94ff <getTreeInflateDynamic+0x38a>
    94f3:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    94fa:	e9 e1 00 00 00       	jmp    95e0 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    94ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9502:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    9505:	73 17                	jae    951e <getTreeInflateDynamic+0x3a9>
    9507:	8b 45 ec             	mov    -0x14(%ebp),%eax
    950a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9511:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9514:	01 d0                	add    %edx,%eax
    9516:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    951c:	eb 18                	jmp    9536 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    951e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9521:	2b 45 d8             	sub    -0x28(%ebp),%eax
    9524:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    952b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    952e:	01 d0                	add    %edx,%eax
    9530:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    9536:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    953a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    953e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9541:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    9544:	72 a0                	jb     94e6 <getTreeInflateDynamic+0x371>
    9546:	e9 95 00 00 00       	jmp    95e0 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    954b:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    954f:	0f 85 82 00 00 00    	jne    95d7 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    9555:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    955c:	83 ec 08             	sub    $0x8,%esp
    955f:	6a 07                	push   $0x7
    9561:	ff 75 10             	pushl  0x10(%ebp)
    9564:	e8 4c e7 ff ff       	call   7cb5 <readBits>
    9569:	83 c4 10             	add    $0x10,%esp
    956c:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    956f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9576:	eb 55                	jmp    95cd <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    9578:	8b 55 d8             	mov    -0x28(%ebp),%edx
    957b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    957e:	01 d0                	add    %edx,%eax
    9580:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    9583:	77 09                	ja     958e <getTreeInflateDynamic+0x419>
    9585:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    958c:	eb 52                	jmp    95e0 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    958e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9591:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    9594:	73 17                	jae    95ad <getTreeInflateDynamic+0x438>
    9596:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9599:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    95a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    95a3:	01 d0                	add    %edx,%eax
    95a5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    95ab:	eb 18                	jmp    95c5 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    95ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
    95b0:	2b 45 d8             	sub    -0x28(%ebp),%eax
    95b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    95ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    95bd:	01 d0                	add    %edx,%eax
    95bf:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    95c5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    95c9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    95cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    95d0:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    95d3:	72 a3                	jb     9578 <getTreeInflateDynamic+0x403>
    95d5:	eb 09                	jmp    95e0 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    95d7:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    95de:	eb 2a                	jmp    960a <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    95e0:	8b 45 10             	mov    0x10(%ebp),%eax
    95e3:	8b 50 0c             	mov    0xc(%eax),%edx
    95e6:	8b 45 10             	mov    0x10(%ebp),%eax
    95e9:	8b 40 08             	mov    0x8(%eax),%eax
    95ec:	39 c2                	cmp    %eax,%edx
    95ee:	7e 09                	jle    95f9 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    95f0:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    95f7:	eb 11                	jmp    960a <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    95f9:	8b 55 d8             	mov    -0x28(%ebp),%edx
    95fc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    95ff:	01 d0                	add    %edx,%eax
    9601:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    9604:	0f 87 62 fd ff ff    	ja     936c <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    960a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    960e:	75 4f                	jne    965f <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    9610:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9613:	05 00 04 00 00       	add    $0x400,%eax
    9618:	8b 00                	mov    (%eax),%eax
    961a:	85 c0                	test   %eax,%eax
    961c:	75 09                	jne    9627 <getTreeInflateDynamic+0x4b2>
    961e:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    9625:	eb 3c                	jmp    9663 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    9627:	6a 0f                	push   $0xf
    9629:	68 20 01 00 00       	push   $0x120
    962e:	ff 75 e8             	pushl  -0x18(%ebp)
    9631:	ff 75 08             	pushl  0x8(%ebp)
    9634:	e8 32 ef ff ff       	call   856b <HuffmanTree_makeFromLengths>
    9639:	83 c4 10             	add    $0x10,%esp
    963c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    963f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9643:	75 1d                	jne    9662 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    9645:	6a 0f                	push   $0xf
    9647:	6a 20                	push   $0x20
    9649:	ff 75 e4             	pushl  -0x1c(%ebp)
    964c:	ff 75 0c             	pushl  0xc(%ebp)
    964f:	e8 17 ef ff ff       	call   856b <HuffmanTree_makeFromLengths>
    9654:	83 c4 10             	add    $0x10,%esp
    9657:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    965a:	eb 07                	jmp    9663 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    965c:	90                   	nop
    965d:	eb 04                	jmp    9663 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    965f:	90                   	nop
    9660:	eb 01                	jmp    9663 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    9662:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    9663:	83 ec 0c             	sub    $0xc,%esp
    9666:	ff 75 dc             	pushl  -0x24(%ebp)
    9669:	e8 dc d8 ff ff       	call   6f4a <lodepng_free>
    966e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    9671:	83 ec 0c             	sub    $0xc,%esp
    9674:	ff 75 e8             	pushl  -0x18(%ebp)
    9677:	e8 ce d8 ff ff       	call   6f4a <lodepng_free>
    967c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    967f:	83 ec 0c             	sub    $0xc,%esp
    9682:	ff 75 e4             	pushl  -0x1c(%ebp)
    9685:	e8 c0 d8 ff ff       	call   6f4a <lodepng_free>
    968a:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    968d:	83 ec 0c             	sub    $0xc,%esp
    9690:	8d 45 a8             	lea    -0x58(%ebp),%eax
    9693:	50                   	push   %eax
    9694:	e8 b1 e7 ff ff       	call   7e4a <HuffmanTree_cleanup>
    9699:	83 c4 10             	add    $0x10,%esp

  return error;
    969c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    969f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    96a2:	c9                   	leave  
    96a3:	c3                   	ret    

000096a4 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    96a4:	55                   	push   %ebp
    96a5:	89 e5                	mov    %esp,%ebp
    96a7:	53                   	push   %ebx
    96a8:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    96ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    96b2:	8d 45 b8             	lea    -0x48(%ebp),%eax
    96b5:	50                   	push   %eax
    96b6:	e8 62 e7 ff ff       	call   7e1d <HuffmanTree_init>
    96bb:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    96be:	8d 45 a0             	lea    -0x60(%ebp),%eax
    96c1:	50                   	push   %eax
    96c2:	e8 56 e7 ff ff       	call   7e1d <HuffmanTree_init>
    96c7:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    96ca:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    96ce:	75 1b                	jne    96eb <inflateHuffmanBlock+0x47>
    96d0:	83 ec 08             	sub    $0x8,%esp
    96d3:	8d 45 a0             	lea    -0x60(%ebp),%eax
    96d6:	50                   	push   %eax
    96d7:	8d 45 b8             	lea    -0x48(%ebp),%eax
    96da:	50                   	push   %eax
    96db:	e8 63 fa ff ff       	call   9143 <getTreeInflateFixed>
    96e0:	83 c4 10             	add    $0x10,%esp
    96e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    96e6:	e9 9a 02 00 00       	jmp    9985 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    96eb:	83 ec 04             	sub    $0x4,%esp
    96ee:	ff 75 0c             	pushl  0xc(%ebp)
    96f1:	8d 45 a0             	lea    -0x60(%ebp),%eax
    96f4:	50                   	push   %eax
    96f5:	8d 45 b8             	lea    -0x48(%ebp),%eax
    96f8:	50                   	push   %eax
    96f9:	e8 77 fa ff ff       	call   9175 <getTreeInflateDynamic>
    96fe:	83 c4 10             	add    $0x10,%esp
    9701:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    9704:	e9 7c 02 00 00       	jmp    9985 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    9709:	83 ec 08             	sub    $0x8,%esp
    970c:	6a 14                	push   $0x14
    970e:	ff 75 0c             	pushl  0xc(%ebp)
    9711:	e8 ef e1 ff ff       	call   7905 <ensureBits25>
    9716:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    9719:	83 ec 08             	sub    $0x8,%esp
    971c:	8d 45 b8             	lea    -0x48(%ebp),%eax
    971f:	50                   	push   %eax
    9720:	ff 75 0c             	pushl  0xc(%ebp)
    9723:	e8 5a f9 ff ff       	call   9082 <huffmanDecodeSymbol>
    9728:	83 c4 10             	add    $0x10,%esp
    972b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    972e:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    9735:	77 42                	ja     9779 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    9737:	8b 45 08             	mov    0x8(%ebp),%eax
    973a:	8b 40 04             	mov    0x4(%eax),%eax
    973d:	83 c0 01             	add    $0x1,%eax
    9740:	83 ec 08             	sub    $0x8,%esp
    9743:	50                   	push   %eax
    9744:	ff 75 08             	pushl  0x8(%ebp)
    9747:	e8 37 da ff ff       	call   7183 <ucvector_resize>
    974c:	83 c4 10             	add    $0x10,%esp
    974f:	85 c0                	test   %eax,%eax
    9751:	75 0c                	jne    975f <inflateHuffmanBlock+0xbb>
    9753:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    975a:	e9 33 02 00 00       	jmp    9992 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    975f:	8b 45 08             	mov    0x8(%ebp),%eax
    9762:	8b 10                	mov    (%eax),%edx
    9764:	8b 45 08             	mov    0x8(%ebp),%eax
    9767:	8b 40 04             	mov    0x4(%eax),%eax
    976a:	83 e8 01             	sub    $0x1,%eax
    976d:	01 d0                	add    %edx,%eax
    976f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    9772:	88 10                	mov    %dl,(%eax)
    9774:	e9 d9 01 00 00       	jmp    9952 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    9779:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    9780:	0f 86 ba 01 00 00    	jbe    9940 <inflateHuffmanBlock+0x29c>
    9786:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    978d:	0f 87 ad 01 00 00    	ja     9940 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    9793:	8b 45 dc             	mov    -0x24(%ebp),%eax
    9796:	2d 01 01 00 00       	sub    $0x101,%eax
    979b:	8b 04 85 e0 f0 01 00 	mov    0x1f0e0(,%eax,4),%eax
    97a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    97a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    97a8:	2d 01 01 00 00       	sub    $0x101,%eax
    97ad:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    97b4:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    97b7:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    97bb:	74 1c                	je     97d9 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    97bd:	8b 45 d8             	mov    -0x28(%ebp),%eax
    97c0:	83 ec 08             	sub    $0x8,%esp
    97c3:	50                   	push   %eax
    97c4:	ff 75 0c             	pushl  0xc(%ebp)
    97c7:	e8 e9 e4 ff ff       	call   7cb5 <readBits>
    97cc:	83 c4 10             	add    $0x10,%esp
    97cf:	89 c2                	mov    %eax,%edx
    97d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    97d4:	01 d0                	add    %edx,%eax
    97d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    97d9:	83 ec 08             	sub    $0x8,%esp
    97dc:	6a 1c                	push   $0x1c
    97de:	ff 75 0c             	pushl  0xc(%ebp)
    97e1:	e8 98 e2 ff ff       	call   7a7e <ensureBits32>
    97e6:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    97e9:	83 ec 08             	sub    $0x8,%esp
    97ec:	8d 45 a0             	lea    -0x60(%ebp),%eax
    97ef:	50                   	push   %eax
    97f0:	ff 75 0c             	pushl  0xc(%ebp)
    97f3:	e8 8a f8 ff ff       	call   9082 <huffmanDecodeSymbol>
    97f8:	83 c4 10             	add    $0x10,%esp
    97fb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    97fe:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    9802:	76 1e                	jbe    9822 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    9804:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    9808:	77 0c                	ja     9816 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    980a:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    9811:	e9 7c 01 00 00       	jmp    9992 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    9816:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    981d:	e9 70 01 00 00       	jmp    9992 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    9822:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    9825:	8b 04 85 e0 f1 01 00 	mov    0x1f1e0(,%eax,4),%eax
    982c:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    982f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    9832:	8b 04 85 60 f2 01 00 	mov    0x1f260(,%eax,4),%eax
    9839:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    983c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    9840:	74 15                	je     9857 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    9842:	8b 45 d0             	mov    -0x30(%ebp),%eax
    9845:	83 ec 08             	sub    $0x8,%esp
    9848:	50                   	push   %eax
    9849:	ff 75 0c             	pushl  0xc(%ebp)
    984c:	e8 64 e4 ff ff       	call   7cb5 <readBits>
    9851:	83 c4 10             	add    $0x10,%esp
    9854:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    9857:	8b 45 08             	mov    0x8(%ebp),%eax
    985a:	8b 40 04             	mov    0x4(%eax),%eax
    985d:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    9860:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9863:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    9866:	76 0c                	jbe    9874 <inflateHuffmanBlock+0x1d0>
    9868:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    986f:	e9 1e 01 00 00       	jmp    9992 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    9874:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9877:	2b 45 f0             	sub    -0x10(%ebp),%eax
    987a:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    987d:	8b 45 08             	mov    0x8(%ebp),%eax
    9880:	8b 50 04             	mov    0x4(%eax),%edx
    9883:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9886:	01 d0                	add    %edx,%eax
    9888:	83 ec 08             	sub    $0x8,%esp
    988b:	50                   	push   %eax
    988c:	ff 75 08             	pushl  0x8(%ebp)
    988f:	e8 ef d8 ff ff       	call   7183 <ucvector_resize>
    9894:	83 c4 10             	add    $0x10,%esp
    9897:	85 c0                	test   %eax,%eax
    9899:	75 0c                	jne    98a7 <inflateHuffmanBlock+0x203>
    989b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    98a2:	e9 eb 00 00 00       	jmp    9992 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    98a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    98aa:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    98ad:	73 6b                	jae    991a <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    98af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    98b2:	8b 55 08             	mov    0x8(%ebp),%edx
    98b5:	8b 0a                	mov    (%edx),%ecx
    98b7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    98ba:	01 d1                	add    %edx,%ecx
    98bc:	8b 55 08             	mov    0x8(%ebp),%edx
    98bf:	8b 1a                	mov    (%edx),%ebx
    98c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    98c4:	01 da                	add    %ebx,%edx
    98c6:	83 ec 04             	sub    $0x4,%esp
    98c9:	50                   	push   %eax
    98ca:	51                   	push   %ecx
    98cb:	52                   	push   %edx
    98cc:	e8 96 d6 ff ff       	call   6f67 <lodepng_memcpy>
    98d1:	83 c4 10             	add    $0x10,%esp
        start += distance;
    98d4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    98d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    98da:	01 d0                	add    %edx,%eax
    98dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    98df:	8b 45 f0             	mov    -0x10(%ebp),%eax
    98e2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    98e5:	eb 29                	jmp    9910 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    98e7:	8b 45 08             	mov    0x8(%ebp),%eax
    98ea:	8b 08                	mov    (%eax),%ecx
    98ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    98ef:	8d 50 01             	lea    0x1(%eax),%edx
    98f2:	89 55 ec             	mov    %edx,-0x14(%ebp)
    98f5:	01 c1                	add    %eax,%ecx
    98f7:	8b 45 08             	mov    0x8(%ebp),%eax
    98fa:	8b 18                	mov    (%eax),%ebx
    98fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    98ff:	8d 50 01             	lea    0x1(%eax),%edx
    9902:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9905:	01 d8                	add    %ebx,%eax
    9907:	0f b6 00             	movzbl (%eax),%eax
    990a:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    990c:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    9910:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9913:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    9916:	7c cf                	jl     98e7 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    9918:	eb 38                	jmp    9952 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    991a:	8b 45 08             	mov    0x8(%ebp),%eax
    991d:	8b 10                	mov    (%eax),%edx
    991f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9922:	01 c2                	add    %eax,%edx
    9924:	8b 45 08             	mov    0x8(%ebp),%eax
    9927:	8b 08                	mov    (%eax),%ecx
    9929:	8b 45 ec             	mov    -0x14(%ebp),%eax
    992c:	01 c8                	add    %ecx,%eax
    992e:	83 ec 04             	sub    $0x4,%esp
    9931:	ff 75 e4             	pushl  -0x1c(%ebp)
    9934:	52                   	push   %edx
    9935:	50                   	push   %eax
    9936:	e8 2c d6 ff ff       	call   6f67 <lodepng_memcpy>
    993b:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    993e:	eb 12                	jmp    9952 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    9940:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    9947:	74 48                	je     9991 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    9949:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    9950:	eb 40                	jmp    9992 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    9952:	8b 45 0c             	mov    0xc(%ebp),%eax
    9955:	8b 50 0c             	mov    0xc(%eax),%edx
    9958:	8b 45 0c             	mov    0xc(%ebp),%eax
    995b:	8b 40 08             	mov    0x8(%eax),%eax
    995e:	39 c2                	cmp    %eax,%edx
    9960:	7e 09                	jle    996b <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    9962:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    9969:	eb 27                	jmp    9992 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    996b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    996f:	74 14                	je     9985 <inflateHuffmanBlock+0x2e1>
    9971:	8b 45 08             	mov    0x8(%ebp),%eax
    9974:	8b 40 04             	mov    0x4(%eax),%eax
    9977:	3b 45 14             	cmp    0x14(%ebp),%eax
    997a:	7e 09                	jle    9985 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    997c:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    9983:	eb 0d                	jmp    9992 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    9985:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9989:	0f 84 7a fd ff ff    	je     9709 <inflateHuffmanBlock+0x65>
    998f:	eb 01                	jmp    9992 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    9991:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    9992:	83 ec 0c             	sub    $0xc,%esp
    9995:	8d 45 b8             	lea    -0x48(%ebp),%eax
    9998:	50                   	push   %eax
    9999:	e8 ac e4 ff ff       	call   7e4a <HuffmanTree_cleanup>
    999e:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    99a1:	83 ec 0c             	sub    $0xc,%esp
    99a4:	8d 45 a0             	lea    -0x60(%ebp),%eax
    99a7:	50                   	push   %eax
    99a8:	e8 9d e4 ff ff       	call   7e4a <HuffmanTree_cleanup>
    99ad:	83 c4 10             	add    $0x10,%esp

  return error;
    99b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    99b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    99b6:	c9                   	leave  
    99b7:	c3                   	ret    

000099b8 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    99b8:	55                   	push   %ebp
    99b9:	89 e5                	mov    %esp,%ebp
    99bb:	53                   	push   %ebx
    99bc:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    99bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    99c2:	8b 40 04             	mov    0x4(%eax),%eax
    99c5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    99c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    99cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    99d2:	8b 40 0c             	mov    0xc(%eax),%eax
    99d5:	83 c0 07             	add    $0x7,%eax
    99d8:	c1 e8 03             	shr    $0x3,%eax
    99db:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    99de:	8b 45 f0             	mov    -0x10(%ebp),%eax
    99e1:	83 c0 04             	add    $0x4,%eax
    99e4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    99e7:	7c 0a                	jl     99f3 <inflateNoCompression+0x3b>
    99e9:	b8 34 00 00 00       	mov    $0x34,%eax
    99ee:	e9 01 01 00 00       	jmp    9af4 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    99f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    99f6:	8b 10                	mov    (%eax),%edx
    99f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    99fb:	01 d0                	add    %edx,%eax
    99fd:	0f b6 00             	movzbl (%eax),%eax
    9a00:	0f b6 d0             	movzbl %al,%edx
    9a03:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a06:	8b 00                	mov    (%eax),%eax
    9a08:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    9a0b:	83 c1 01             	add    $0x1,%ecx
    9a0e:	01 c8                	add    %ecx,%eax
    9a10:	0f b6 00             	movzbl (%eax),%eax
    9a13:	0f b6 c0             	movzbl %al,%eax
    9a16:	c1 e0 08             	shl    $0x8,%eax
    9a19:	01 d0                	add    %edx,%eax
    9a1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9a1e:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    9a22:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a25:	8b 10                	mov    (%eax),%edx
    9a27:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9a2a:	01 d0                	add    %edx,%eax
    9a2c:	0f b6 00             	movzbl (%eax),%eax
    9a2f:	0f b6 d0             	movzbl %al,%edx
    9a32:	8b 45 0c             	mov    0xc(%ebp),%eax
    9a35:	8b 00                	mov    (%eax),%eax
    9a37:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    9a3a:	83 c1 01             	add    $0x1,%ecx
    9a3d:	01 c8                	add    %ecx,%eax
    9a3f:	0f b6 00             	movzbl (%eax),%eax
    9a42:	0f b6 c0             	movzbl %al,%eax
    9a45:	c1 e0 08             	shl    $0x8,%eax
    9a48:	01 d0                	add    %edx,%eax
    9a4a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9a4d:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    9a51:	8b 45 10             	mov    0x10(%ebp),%eax
    9a54:	8b 40 04             	mov    0x4(%eax),%eax
    9a57:	85 c0                	test   %eax,%eax
    9a59:	75 19                	jne    9a74 <inflateNoCompression+0xbc>
    9a5b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9a5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9a61:	01 d0                	add    %edx,%eax
    9a63:	3d ff ff 00 00       	cmp    $0xffff,%eax
    9a68:	74 0a                	je     9a74 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    9a6a:	b8 15 00 00 00       	mov    $0x15,%eax
    9a6f:	e9 80 00 00 00       	jmp    9af4 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    9a74:	8b 45 08             	mov    0x8(%ebp),%eax
    9a77:	8b 40 04             	mov    0x4(%eax),%eax
    9a7a:	89 c2                	mov    %eax,%edx
    9a7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9a7f:	01 d0                	add    %edx,%eax
    9a81:	50                   	push   %eax
    9a82:	ff 75 08             	pushl  0x8(%ebp)
    9a85:	e8 f9 d6 ff ff       	call   7183 <ucvector_resize>
    9a8a:	83 c4 08             	add    $0x8,%esp
    9a8d:	85 c0                	test   %eax,%eax
    9a8f:	75 07                	jne    9a98 <inflateNoCompression+0xe0>
    9a91:	b8 53 00 00 00       	mov    $0x53,%eax
    9a96:	eb 5c                	jmp    9af4 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    9a98:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9a9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9a9e:	01 c2                	add    %eax,%edx
    9aa0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9aa3:	39 c2                	cmp    %eax,%edx
    9aa5:	76 07                	jbe    9aae <inflateNoCompression+0xf6>
    9aa7:	b8 17 00 00 00       	mov    $0x17,%eax
    9aac:	eb 46                	jmp    9af4 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    9aae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9ab1:	8b 55 0c             	mov    0xc(%ebp),%edx
    9ab4:	8b 0a                	mov    (%edx),%ecx
    9ab6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ab9:	01 d1                	add    %edx,%ecx
    9abb:	8b 55 08             	mov    0x8(%ebp),%edx
    9abe:	8b 1a                	mov    (%edx),%ebx
    9ac0:	8b 55 08             	mov    0x8(%ebp),%edx
    9ac3:	8b 52 04             	mov    0x4(%edx),%edx
    9ac6:	2b 55 ec             	sub    -0x14(%ebp),%edx
    9ac9:	01 da                	add    %ebx,%edx
    9acb:	50                   	push   %eax
    9acc:	51                   	push   %ecx
    9acd:	52                   	push   %edx
    9ace:	e8 94 d4 ff ff       	call   6f67 <lodepng_memcpy>
    9ad3:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    9ad6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ad9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9adc:	01 d0                	add    %edx,%eax
    9ade:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    9ae1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9ae4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    9aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
    9aee:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    9af1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    9af4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9af7:	c9                   	leave  
    9af8:	c3                   	ret    

00009af9 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    9af9:	55                   	push   %ebp
    9afa:	89 e5                	mov    %esp,%ebp
    9afc:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    9aff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    9b06:	ff 75 10             	pushl  0x10(%ebp)
    9b09:	ff 75 0c             	pushl  0xc(%ebp)
    9b0c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    9b0f:	50                   	push   %eax
    9b10:	e8 77 db ff ff       	call   768c <LodePNGBitReader_init>
    9b15:	83 c4 0c             	add    $0xc,%esp
    9b18:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    9b1b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b1f:	0f 84 b9 00 00 00    	je     9bde <lodepng_inflatev+0xe5>
    9b25:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9b28:	e9 c1 00 00 00       	jmp    9bee <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    9b2d:	6a 03                	push   $0x3
    9b2f:	8d 45 d8             	lea    -0x28(%ebp),%eax
    9b32:	50                   	push   %eax
    9b33:	e8 c5 db ff ff       	call   76fd <ensureBits9>
    9b38:	83 c4 08             	add    $0x8,%esp
    9b3b:	85 c0                	test   %eax,%eax
    9b3d:	75 0a                	jne    9b49 <lodepng_inflatev+0x50>
    9b3f:	b8 34 00 00 00       	mov    $0x34,%eax
    9b44:	e9 a5 00 00 00       	jmp    9bee <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    9b49:	6a 01                	push   $0x1
    9b4b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    9b4e:	50                   	push   %eax
    9b4f:	e8 61 e1 ff ff       	call   7cb5 <readBits>
    9b54:	83 c4 08             	add    $0x8,%esp
    9b57:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    9b5a:	6a 02                	push   $0x2
    9b5c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    9b5f:	50                   	push   %eax
    9b60:	e8 50 e1 ff ff       	call   7cb5 <readBits>
    9b65:	83 c4 08             	add    $0x8,%esp
    9b68:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    9b6b:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    9b6f:	75 07                	jne    9b78 <lodepng_inflatev+0x7f>
    9b71:	b8 14 00 00 00       	mov    $0x14,%eax
    9b76:	eb 76                	jmp    9bee <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    9b78:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9b7c:	75 17                	jne    9b95 <lodepng_inflatev+0x9c>
    9b7e:	ff 75 14             	pushl  0x14(%ebp)
    9b81:	8d 45 d8             	lea    -0x28(%ebp),%eax
    9b84:	50                   	push   %eax
    9b85:	ff 75 08             	pushl  0x8(%ebp)
    9b88:	e8 2b fe ff ff       	call   99b8 <inflateNoCompression>
    9b8d:	83 c4 0c             	add    $0xc,%esp
    9b90:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9b93:	eb 1c                	jmp    9bb1 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    9b95:	8b 45 14             	mov    0x14(%ebp),%eax
    9b98:	8b 40 08             	mov    0x8(%eax),%eax
    9b9b:	50                   	push   %eax
    9b9c:	ff 75 ec             	pushl  -0x14(%ebp)
    9b9f:	8d 45 d8             	lea    -0x28(%ebp),%eax
    9ba2:	50                   	push   %eax
    9ba3:	ff 75 08             	pushl  0x8(%ebp)
    9ba6:	e8 f9 fa ff ff       	call   96a4 <inflateHuffmanBlock>
    9bab:	83 c4 10             	add    $0x10,%esp
    9bae:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    9bb1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9bb5:	75 21                	jne    9bd8 <lodepng_inflatev+0xdf>
    9bb7:	8b 45 14             	mov    0x14(%ebp),%eax
    9bba:	8b 40 08             	mov    0x8(%eax),%eax
    9bbd:	85 c0                	test   %eax,%eax
    9bbf:	74 17                	je     9bd8 <lodepng_inflatev+0xdf>
    9bc1:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc4:	8b 50 04             	mov    0x4(%eax),%edx
    9bc7:	8b 45 14             	mov    0x14(%ebp),%eax
    9bca:	8b 40 08             	mov    0x8(%eax),%eax
    9bcd:	39 c2                	cmp    %eax,%edx
    9bcf:	7e 07                	jle    9bd8 <lodepng_inflatev+0xdf>
    9bd1:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    9bd8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9bdc:	75 0c                	jne    9bea <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    9bde:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9be2:	0f 84 45 ff ff ff    	je     9b2d <lodepng_inflatev+0x34>
    9be8:	eb 01                	jmp    9beb <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    9bea:	90                   	nop
  }

  return error;
    9beb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    9bee:	c9                   	leave  
    9bef:	c3                   	ret    

00009bf0 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    9bf0:	55                   	push   %ebp
    9bf1:	89 e5                	mov    %esp,%ebp
    9bf3:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    9bf6:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bf9:	8b 08                	mov    (%eax),%ecx
    9bfb:	8b 45 08             	mov    0x8(%ebp),%eax
    9bfe:	8b 10                	mov    (%eax),%edx
    9c00:	8d 45 e8             	lea    -0x18(%ebp),%eax
    9c03:	51                   	push   %ecx
    9c04:	52                   	push   %edx
    9c05:	50                   	push   %eax
    9c06:	e8 df d5 ff ff       	call   71ea <ucvector_init>
    9c0b:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    9c0e:	ff 75 18             	pushl  0x18(%ebp)
    9c11:	ff 75 14             	pushl  0x14(%ebp)
    9c14:	ff 75 10             	pushl  0x10(%ebp)
    9c17:	8d 45 e8             	lea    -0x18(%ebp),%eax
    9c1a:	50                   	push   %eax
    9c1b:	e8 d9 fe ff ff       	call   9af9 <lodepng_inflatev>
    9c20:	83 c4 10             	add    $0x10,%esp
    9c23:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    9c26:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9c29:	8b 45 08             	mov    0x8(%ebp),%eax
    9c2c:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    9c2e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9c31:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c34:	89 10                	mov    %edx,(%eax)
  return error;
    9c36:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    9c39:	c9                   	leave  
    9c3a:	c3                   	ret    

00009c3b <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    9c3b:	55                   	push   %ebp
    9c3c:	89 e5                	mov    %esp,%ebp
    9c3e:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    9c41:	8b 45 14             	mov    0x14(%ebp),%eax
    9c44:	8b 40 10             	mov    0x10(%eax),%eax
    9c47:	85 c0                	test   %eax,%eax
    9c49:	74 64                	je     9caf <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    9c4b:	8b 45 14             	mov    0x14(%ebp),%eax
    9c4e:	8b 40 10             	mov    0x10(%eax),%eax
    9c51:	8b 55 08             	mov    0x8(%ebp),%edx
    9c54:	8d 4a 04             	lea    0x4(%edx),%ecx
    9c57:	8b 55 08             	mov    0x8(%ebp),%edx
    9c5a:	83 ec 0c             	sub    $0xc,%esp
    9c5d:	ff 75 14             	pushl  0x14(%ebp)
    9c60:	ff 75 10             	pushl  0x10(%ebp)
    9c63:	ff 75 0c             	pushl  0xc(%ebp)
    9c66:	51                   	push   %ecx
    9c67:	52                   	push   %edx
    9c68:	ff d0                	call   *%eax
    9c6a:	83 c4 20             	add    $0x20,%esp
    9c6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    9c70:	8b 45 08             	mov    0x8(%ebp),%eax
    9c73:	8b 50 04             	mov    0x4(%eax),%edx
    9c76:	8b 45 08             	mov    0x8(%ebp),%eax
    9c79:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    9c7c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9c80:	74 28                	je     9caa <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    9c82:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    9c89:	8b 45 14             	mov    0x14(%ebp),%eax
    9c8c:	8b 40 08             	mov    0x8(%eax),%eax
    9c8f:	85 c0                	test   %eax,%eax
    9c91:	74 17                	je     9caa <inflatev+0x6f>
    9c93:	8b 45 08             	mov    0x8(%ebp),%eax
    9c96:	8b 50 04             	mov    0x4(%eax),%edx
    9c99:	8b 45 14             	mov    0x14(%ebp),%eax
    9c9c:	8b 40 08             	mov    0x8(%eax),%eax
    9c9f:	39 c2                	cmp    %eax,%edx
    9ca1:	7e 07                	jle    9caa <inflatev+0x6f>
    9ca3:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    9caa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9cad:	eb 14                	jmp    9cc3 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    9caf:	ff 75 14             	pushl  0x14(%ebp)
    9cb2:	ff 75 10             	pushl  0x10(%ebp)
    9cb5:	ff 75 0c             	pushl  0xc(%ebp)
    9cb8:	ff 75 08             	pushl  0x8(%ebp)
    9cbb:	e8 39 fe ff ff       	call   9af9 <lodepng_inflatev>
    9cc0:	83 c4 10             	add    $0x10,%esp
  }
}
    9cc3:	c9                   	leave  
    9cc4:	c3                   	ret    

00009cc5 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    9cc5:	55                   	push   %ebp
    9cc6:	89 e5                	mov    %esp,%ebp
    9cc8:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    9ccb:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    9cd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    9cd5:	83 e8 01             	sub    $0x1,%eax
    9cd8:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    9cdb:	eb 39                	jmp    9d16 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    9cdd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9ce0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9ce3:	01 d0                	add    %edx,%eax
    9ce5:	d1 f8                	sar    %eax
    9ce7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    9cea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9ced:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9cf4:	8b 45 08             	mov    0x8(%ebp),%eax
    9cf7:	01 d0                	add    %edx,%eax
    9cf9:	8b 10                	mov    (%eax),%edx
    9cfb:	8b 45 10             	mov    0x10(%ebp),%eax
    9cfe:	39 c2                	cmp    %eax,%edx
    9d00:	72 0b                	jb     9d0d <searchCodeIndex+0x48>
    9d02:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9d05:	83 e8 01             	sub    $0x1,%eax
    9d08:	89 45 f8             	mov    %eax,-0x8(%ebp)
    9d0b:	eb 09                	jmp    9d16 <searchCodeIndex+0x51>
    else left = mid + 1;
    9d0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9d10:	83 c0 01             	add    $0x1,%eax
    9d13:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    9d16:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d19:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    9d1c:	7e bf                	jle    9cdd <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    9d1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d21:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9d24:	7d 18                	jge    9d3e <searchCodeIndex+0x79>
    9d26:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d29:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    9d30:	8b 45 08             	mov    0x8(%ebp),%eax
    9d33:	01 d0                	add    %edx,%eax
    9d35:	8b 10                	mov    (%eax),%edx
    9d37:	8b 45 10             	mov    0x10(%ebp),%eax
    9d3a:	39 c2                	cmp    %eax,%edx
    9d3c:	76 04                	jbe    9d42 <searchCodeIndex+0x7d>
    9d3e:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    9d42:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    9d45:	c9                   	leave  
    9d46:	c3                   	ret    

00009d47 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    9d47:	55                   	push   %ebp
    9d48:	89 e5                	mov    %esp,%ebp
    9d4a:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    9d4d:	ff 75 0c             	pushl  0xc(%ebp)
    9d50:	6a 1d                	push   $0x1d
    9d52:	68 e0 f0 01 00       	push   $0x1f0e0
    9d57:	e8 69 ff ff ff       	call   9cc5 <searchCodeIndex>
    9d5c:	83 c4 0c             	add    $0xc,%esp
    9d5f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    9d62:	8b 55 0c             	mov    0xc(%ebp),%edx
    9d65:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9d68:	8b 04 85 e0 f0 01 00 	mov    0x1f0e0(,%eax,4),%eax
    9d6f:	29 c2                	sub    %eax,%edx
    9d71:	89 d0                	mov    %edx,%eax
    9d73:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    9d76:	ff 75 10             	pushl  0x10(%ebp)
    9d79:	6a 1e                	push   $0x1e
    9d7b:	68 e0 f1 01 00       	push   $0x1f1e0
    9d80:	e8 40 ff ff ff       	call   9cc5 <searchCodeIndex>
    9d85:	83 c4 0c             	add    $0xc,%esp
    9d88:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    9d8b:	8b 55 10             	mov    0x10(%ebp),%edx
    9d8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9d91:	8b 04 85 e0 f1 01 00 	mov    0x1f1e0(,%eax,4),%eax
    9d98:	29 c2                	sub    %eax,%edx
    9d9a:	89 d0                	mov    %edx,%eax
    9d9c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    9d9f:	8b 45 08             	mov    0x8(%ebp),%eax
    9da2:	8b 40 04             	mov    0x4(%eax),%eax
    9da5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    9da8:	8b 45 08             	mov    0x8(%ebp),%eax
    9dab:	8b 40 04             	mov    0x4(%eax),%eax
    9dae:	83 c0 04             	add    $0x4,%eax
    9db1:	50                   	push   %eax
    9db2:	ff 75 08             	pushl  0x8(%ebp)
    9db5:	e8 f0 d2 ff ff       	call   70aa <uivector_resize>
    9dba:	83 c4 08             	add    $0x8,%esp
    9dbd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    9dc0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9dc4:	74 57                	je     9e1d <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    9dc6:	8b 45 08             	mov    0x8(%ebp),%eax
    9dc9:	8b 00                	mov    (%eax),%eax
    9dcb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9dce:	c1 e2 02             	shl    $0x2,%edx
    9dd1:	01 d0                	add    %edx,%eax
    9dd3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9dd6:	81 c2 01 01 00 00    	add    $0x101,%edx
    9ddc:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    9dde:	8b 45 08             	mov    0x8(%ebp),%eax
    9de1:	8b 00                	mov    (%eax),%eax
    9de3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9de6:	83 c2 01             	add    $0x1,%edx
    9de9:	c1 e2 02             	shl    $0x2,%edx
    9dec:	01 c2                	add    %eax,%edx
    9dee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9df1:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    9df3:	8b 45 08             	mov    0x8(%ebp),%eax
    9df6:	8b 00                	mov    (%eax),%eax
    9df8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9dfb:	83 c2 02             	add    $0x2,%edx
    9dfe:	c1 e2 02             	shl    $0x2,%edx
    9e01:	01 c2                	add    %eax,%edx
    9e03:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e06:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    9e08:	8b 45 08             	mov    0x8(%ebp),%eax
    9e0b:	8b 00                	mov    (%eax),%eax
    9e0d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9e10:	83 c2 03             	add    $0x3,%edx
    9e13:	c1 e2 02             	shl    $0x2,%edx
    9e16:	01 c2                	add    %eax,%edx
    9e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9e1b:	89 02                	mov    %eax,(%edx)
  }
}
    9e1d:	90                   	nop
    9e1e:	c9                   	leave  
    9e1f:	c3                   	ret    

00009e20 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    9e20:	55                   	push   %ebp
    9e21:	89 e5                	mov    %esp,%ebp
    9e23:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    9e26:	b8 00 00 01 00       	mov    $0x10000,%eax
    9e2b:	c1 e0 02             	shl    $0x2,%eax
    9e2e:	83 ec 0c             	sub    $0xc,%esp
    9e31:	50                   	push   %eax
    9e32:	e8 f2 d0 ff ff       	call   6f29 <lodepng_malloc>
    9e37:	83 c4 10             	add    $0x10,%esp
    9e3a:	89 c2                	mov    %eax,%edx
    9e3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9e3f:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    9e41:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e44:	c1 e0 02             	shl    $0x2,%eax
    9e47:	83 ec 0c             	sub    $0xc,%esp
    9e4a:	50                   	push   %eax
    9e4b:	e8 d9 d0 ff ff       	call   6f29 <lodepng_malloc>
    9e50:	83 c4 10             	add    $0x10,%esp
    9e53:	89 c2                	mov    %eax,%edx
    9e55:	8b 45 08             	mov    0x8(%ebp),%eax
    9e58:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    9e5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e5e:	01 c0                	add    %eax,%eax
    9e60:	83 ec 0c             	sub    $0xc,%esp
    9e63:	50                   	push   %eax
    9e64:	e8 c0 d0 ff ff       	call   6f29 <lodepng_malloc>
    9e69:	83 c4 10             	add    $0x10,%esp
    9e6c:	89 c2                	mov    %eax,%edx
    9e6e:	8b 45 08             	mov    0x8(%ebp),%eax
    9e71:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    9e74:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e77:	01 c0                	add    %eax,%eax
    9e79:	83 ec 0c             	sub    $0xc,%esp
    9e7c:	50                   	push   %eax
    9e7d:	e8 a7 d0 ff ff       	call   6f29 <lodepng_malloc>
    9e82:	83 c4 10             	add    $0x10,%esp
    9e85:	89 c2                	mov    %eax,%edx
    9e87:	8b 45 08             	mov    0x8(%ebp),%eax
    9e8a:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    9e8d:	b8 02 01 00 00       	mov    $0x102,%eax
    9e92:	83 c0 01             	add    $0x1,%eax
    9e95:	c1 e0 02             	shl    $0x2,%eax
    9e98:	83 ec 0c             	sub    $0xc,%esp
    9e9b:	50                   	push   %eax
    9e9c:	e8 88 d0 ff ff       	call   6f29 <lodepng_malloc>
    9ea1:	83 c4 10             	add    $0x10,%esp
    9ea4:	89 c2                	mov    %eax,%edx
    9ea6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ea9:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    9eac:	8b 45 0c             	mov    0xc(%ebp),%eax
    9eaf:	01 c0                	add    %eax,%eax
    9eb1:	83 ec 0c             	sub    $0xc,%esp
    9eb4:	50                   	push   %eax
    9eb5:	e8 6f d0 ff ff       	call   6f29 <lodepng_malloc>
    9eba:	83 c4 10             	add    $0x10,%esp
    9ebd:	89 c2                	mov    %eax,%edx
    9ebf:	8b 45 08             	mov    0x8(%ebp),%eax
    9ec2:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    9ec5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ec8:	8b 00                	mov    (%eax),%eax
    9eca:	85 c0                	test   %eax,%eax
    9ecc:	74 32                	je     9f00 <hash_init+0xe0>
    9ece:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed1:	8b 40 04             	mov    0x4(%eax),%eax
    9ed4:	85 c0                	test   %eax,%eax
    9ed6:	74 28                	je     9f00 <hash_init+0xe0>
    9ed8:	8b 45 08             	mov    0x8(%ebp),%eax
    9edb:	8b 40 08             	mov    0x8(%eax),%eax
    9ede:	85 c0                	test   %eax,%eax
    9ee0:	74 1e                	je     9f00 <hash_init+0xe0>
    9ee2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ee5:	8b 40 0c             	mov    0xc(%eax),%eax
    9ee8:	85 c0                	test   %eax,%eax
    9eea:	74 14                	je     9f00 <hash_init+0xe0>
    9eec:	8b 45 08             	mov    0x8(%ebp),%eax
    9eef:	8b 40 10             	mov    0x10(%eax),%eax
    9ef2:	85 c0                	test   %eax,%eax
    9ef4:	74 0a                	je     9f00 <hash_init+0xe0>
    9ef6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ef9:	8b 40 14             	mov    0x14(%eax),%eax
    9efc:	85 c0                	test   %eax,%eax
    9efe:	75 0a                	jne    9f0a <hash_init+0xea>
    return 83; /*alloc fail*/
    9f00:	b8 53 00 00 00       	mov    $0x53,%eax
    9f05:	e9 d3 00 00 00       	jmp    9fdd <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    9f0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9f11:	eb 17                	jmp    9f2a <hash_init+0x10a>
    9f13:	8b 45 08             	mov    0x8(%ebp),%eax
    9f16:	8b 00                	mov    (%eax),%eax
    9f18:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9f1b:	c1 e2 02             	shl    $0x2,%edx
    9f1e:	01 d0                	add    %edx,%eax
    9f20:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    9f26:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9f2a:	b8 00 00 01 00       	mov    $0x10000,%eax
    9f2f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    9f32:	75 df                	jne    9f13 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    9f34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9f3b:	eb 18                	jmp    9f55 <hash_init+0x135>
    9f3d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f40:	8b 40 08             	mov    0x8(%eax),%eax
    9f43:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9f46:	c1 e2 02             	shl    $0x2,%edx
    9f49:	01 d0                	add    %edx,%eax
    9f4b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    9f51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9f55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f58:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9f5b:	75 e0                	jne    9f3d <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    9f5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9f64:	eb 17                	jmp    9f7d <hash_init+0x15d>
    9f66:	8b 45 08             	mov    0x8(%ebp),%eax
    9f69:	8b 40 04             	mov    0x4(%eax),%eax
    9f6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9f6f:	01 d2                	add    %edx,%edx
    9f71:	01 d0                	add    %edx,%eax
    9f73:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9f76:	66 89 10             	mov    %dx,(%eax)
    9f79:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9f7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9f80:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9f83:	75 e1                	jne    9f66 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    9f85:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9f8c:	eb 18                	jmp    9fa6 <hash_init+0x186>
    9f8e:	8b 45 08             	mov    0x8(%ebp),%eax
    9f91:	8b 40 0c             	mov    0xc(%eax),%eax
    9f94:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9f97:	c1 e2 02             	shl    $0x2,%edx
    9f9a:	01 d0                	add    %edx,%eax
    9f9c:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    9fa2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9fa6:	b8 02 01 00 00       	mov    $0x102,%eax
    9fab:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    9fae:	76 de                	jbe    9f8e <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    9fb0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9fb7:	eb 17                	jmp    9fd0 <hash_init+0x1b0>
    9fb9:	8b 45 08             	mov    0x8(%ebp),%eax
    9fbc:	8b 40 10             	mov    0x10(%eax),%eax
    9fbf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fc2:	01 d2                	add    %edx,%edx
    9fc4:	01 d0                	add    %edx,%eax
    9fc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fc9:	66 89 10             	mov    %dx,(%eax)
    9fcc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9fd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9fd3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    9fd6:	75 e1                	jne    9fb9 <hash_init+0x199>

  return 0;
    9fd8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9fdd:	c9                   	leave  
    9fde:	c3                   	ret    

00009fdf <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    9fdf:	55                   	push   %ebp
    9fe0:	89 e5                	mov    %esp,%ebp
    9fe2:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    9fe5:	8b 45 08             	mov    0x8(%ebp),%eax
    9fe8:	8b 00                	mov    (%eax),%eax
    9fea:	83 ec 0c             	sub    $0xc,%esp
    9fed:	50                   	push   %eax
    9fee:	e8 57 cf ff ff       	call   6f4a <lodepng_free>
    9ff3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    9ff6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ff9:	8b 40 08             	mov    0x8(%eax),%eax
    9ffc:	83 ec 0c             	sub    $0xc,%esp
    9fff:	50                   	push   %eax
    a000:	e8 45 cf ff ff       	call   6f4a <lodepng_free>
    a005:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    a008:	8b 45 08             	mov    0x8(%ebp),%eax
    a00b:	8b 40 04             	mov    0x4(%eax),%eax
    a00e:	83 ec 0c             	sub    $0xc,%esp
    a011:	50                   	push   %eax
    a012:	e8 33 cf ff ff       	call   6f4a <lodepng_free>
    a017:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    a01a:	8b 45 08             	mov    0x8(%ebp),%eax
    a01d:	8b 40 14             	mov    0x14(%eax),%eax
    a020:	83 ec 0c             	sub    $0xc,%esp
    a023:	50                   	push   %eax
    a024:	e8 21 cf ff ff       	call   6f4a <lodepng_free>
    a029:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    a02c:	8b 45 08             	mov    0x8(%ebp),%eax
    a02f:	8b 40 0c             	mov    0xc(%eax),%eax
    a032:	83 ec 0c             	sub    $0xc,%esp
    a035:	50                   	push   %eax
    a036:	e8 0f cf ff ff       	call   6f4a <lodepng_free>
    a03b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    a03e:	8b 45 08             	mov    0x8(%ebp),%eax
    a041:	8b 40 10             	mov    0x10(%eax),%eax
    a044:	83 ec 0c             	sub    $0xc,%esp
    a047:	50                   	push   %eax
    a048:	e8 fd ce ff ff       	call   6f4a <lodepng_free>
    a04d:	83 c4 10             	add    $0x10,%esp
}
    a050:	90                   	nop
    a051:	c9                   	leave  
    a052:	c3                   	ret    

0000a053 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    a053:	55                   	push   %ebp
    a054:	89 e5                	mov    %esp,%ebp
    a056:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    a059:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    a060:	8b 45 10             	mov    0x10(%ebp),%eax
    a063:	83 c0 02             	add    $0x2,%eax
    a066:	3b 45 0c             	cmp    0xc(%ebp),%eax
    a069:	7d 41                	jge    a0ac <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    a06b:	8b 55 10             	mov    0x10(%ebp),%edx
    a06e:	8b 45 08             	mov    0x8(%ebp),%eax
    a071:	01 d0                	add    %edx,%eax
    a073:	0f b6 00             	movzbl (%eax),%eax
    a076:	0f b6 c0             	movzbl %al,%eax
    a079:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    a07c:	8b 45 10             	mov    0x10(%ebp),%eax
    a07f:	8d 50 01             	lea    0x1(%eax),%edx
    a082:	8b 45 08             	mov    0x8(%ebp),%eax
    a085:	01 d0                	add    %edx,%eax
    a087:	0f b6 00             	movzbl (%eax),%eax
    a08a:	0f b6 c0             	movzbl %al,%eax
    a08d:	c1 e0 04             	shl    $0x4,%eax
    a090:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    a093:	8b 45 10             	mov    0x10(%ebp),%eax
    a096:	8d 50 02             	lea    0x2(%eax),%edx
    a099:	8b 45 08             	mov    0x8(%ebp),%eax
    a09c:	01 d0                	add    %edx,%eax
    a09e:	0f b6 00             	movzbl (%eax),%eax
    a0a1:	0f b6 c0             	movzbl %al,%eax
    a0a4:	c1 e0 08             	shl    $0x8,%eax
    a0a7:	31 45 fc             	xor    %eax,-0x4(%ebp)
    a0aa:	eb 51                	jmp    a0fd <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    a0ac:	8b 45 10             	mov    0x10(%ebp),%eax
    a0af:	3b 45 0c             	cmp    0xc(%ebp),%eax
    a0b2:	7c 07                	jl     a0bb <getHash+0x68>
    a0b4:	b8 00 00 00 00       	mov    $0x0,%eax
    a0b9:	eb 4a                	jmp    a105 <getHash+0xb2>
    amount = size - pos;
    a0bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a0be:	2b 45 10             	sub    0x10(%ebp),%eax
    a0c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    a0c4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    a0cb:	eb 28                	jmp    a0f5 <getHash+0xa2>
    a0cd:	8b 55 10             	mov    0x10(%ebp),%edx
    a0d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a0d3:	01 d0                	add    %edx,%eax
    a0d5:	89 c2                	mov    %eax,%edx
    a0d7:	8b 45 08             	mov    0x8(%ebp),%eax
    a0da:	01 d0                	add    %edx,%eax
    a0dc:	0f b6 00             	movzbl (%eax),%eax
    a0df:	0f b6 d0             	movzbl %al,%edx
    a0e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a0e5:	c1 e0 03             	shl    $0x3,%eax
    a0e8:	89 c1                	mov    %eax,%ecx
    a0ea:	d3 e2                	shl    %cl,%edx
    a0ec:	89 d0                	mov    %edx,%eax
    a0ee:	31 45 fc             	xor    %eax,-0x4(%ebp)
    a0f1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a0f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a0f8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a0fb:	75 d0                	jne    a0cd <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    a0fd:	b8 ff ff 00 00       	mov    $0xffff,%eax
    a102:	23 45 fc             	and    -0x4(%ebp),%eax
}
    a105:	c9                   	leave  
    a106:	c3                   	ret    

0000a107 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    a107:	55                   	push   %ebp
    a108:	89 e5                	mov    %esp,%ebp
    a10a:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    a10d:	8b 55 10             	mov    0x10(%ebp),%edx
    a110:	8b 45 08             	mov    0x8(%ebp),%eax
    a113:	01 d0                	add    %edx,%eax
    a115:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    a118:	b8 02 01 00 00       	mov    $0x102,%eax
    a11d:	89 c2                	mov    %eax,%edx
    a11f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a122:	01 d0                	add    %edx,%eax
    a124:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    a127:	8b 55 0c             	mov    0xc(%ebp),%edx
    a12a:	8b 45 08             	mov    0x8(%ebp),%eax
    a12d:	01 d0                	add    %edx,%eax
    a12f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    a132:	73 0b                	jae    a13f <countZeros+0x38>
    a134:	8b 55 0c             	mov    0xc(%ebp),%edx
    a137:	8b 45 08             	mov    0x8(%ebp),%eax
    a13a:	01 d0                	add    %edx,%eax
    a13c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    a13f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a142:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    a145:	eb 04                	jmp    a14b <countZeros+0x44>
    a147:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    a14b:	8b 45 08             	mov    0x8(%ebp),%eax
    a14e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    a151:	74 0a                	je     a15d <countZeros+0x56>
    a153:	8b 45 08             	mov    0x8(%ebp),%eax
    a156:	0f b6 00             	movzbl (%eax),%eax
    a159:	84 c0                	test   %al,%al
    a15b:	74 ea                	je     a147 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    a15d:	8b 55 08             	mov    0x8(%ebp),%edx
    a160:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a163:	29 c2                	sub    %eax,%edx
    a165:	89 d0                	mov    %edx,%eax
}
    a167:	c9                   	leave  
    a168:	c3                   	ret    

0000a169 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    a169:	55                   	push   %ebp
    a16a:	89 e5                	mov    %esp,%ebp
    a16c:	83 ec 04             	sub    $0x4,%esp
    a16f:	8b 45 14             	mov    0x14(%ebp),%eax
    a172:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    a176:	8b 45 08             	mov    0x8(%ebp),%eax
    a179:	8b 40 08             	mov    0x8(%eax),%eax
    a17c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a17f:	c1 e2 02             	shl    $0x2,%edx
    a182:	01 c2                	add    %eax,%edx
    a184:	8b 45 10             	mov    0x10(%ebp),%eax
    a187:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    a189:	8b 45 08             	mov    0x8(%ebp),%eax
    a18c:	8b 00                	mov    (%eax),%eax
    a18e:	8b 55 10             	mov    0x10(%ebp),%edx
    a191:	c1 e2 02             	shl    $0x2,%edx
    a194:	01 d0                	add    %edx,%eax
    a196:	8b 00                	mov    (%eax),%eax
    a198:	83 f8 ff             	cmp    $0xffffffff,%eax
    a19b:	74 1f                	je     a1bc <updateHashChain+0x53>
    a19d:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a0:	8b 40 04             	mov    0x4(%eax),%eax
    a1a3:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1a6:	01 d2                	add    %edx,%edx
    a1a8:	01 c2                	add    %eax,%edx
    a1aa:	8b 45 08             	mov    0x8(%ebp),%eax
    a1ad:	8b 00                	mov    (%eax),%eax
    a1af:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a1b2:	c1 e1 02             	shl    $0x2,%ecx
    a1b5:	01 c8                	add    %ecx,%eax
    a1b7:	8b 00                	mov    (%eax),%eax
    a1b9:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    a1bc:	8b 45 08             	mov    0x8(%ebp),%eax
    a1bf:	8b 00                	mov    (%eax),%eax
    a1c1:	8b 55 10             	mov    0x10(%ebp),%edx
    a1c4:	c1 e2 02             	shl    $0x2,%edx
    a1c7:	01 c2                	add    %eax,%edx
    a1c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1cc:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    a1ce:	8b 45 08             	mov    0x8(%ebp),%eax
    a1d1:	8b 40 14             	mov    0x14(%eax),%eax
    a1d4:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1d7:	01 d2                	add    %edx,%edx
    a1d9:	01 c2                	add    %eax,%edx
    a1db:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    a1df:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    a1e2:	8b 45 08             	mov    0x8(%ebp),%eax
    a1e5:	8b 40 0c             	mov    0xc(%eax),%eax
    a1e8:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    a1ec:	c1 e2 02             	shl    $0x2,%edx
    a1ef:	01 d0                	add    %edx,%eax
    a1f1:	8b 00                	mov    (%eax),%eax
    a1f3:	83 f8 ff             	cmp    $0xffffffff,%eax
    a1f6:	74 21                	je     a219 <updateHashChain+0xb0>
    a1f8:	8b 45 08             	mov    0x8(%ebp),%eax
    a1fb:	8b 40 10             	mov    0x10(%eax),%eax
    a1fe:	8b 55 0c             	mov    0xc(%ebp),%edx
    a201:	01 d2                	add    %edx,%edx
    a203:	01 c2                	add    %eax,%edx
    a205:	8b 45 08             	mov    0x8(%ebp),%eax
    a208:	8b 40 0c             	mov    0xc(%eax),%eax
    a20b:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    a20f:	c1 e1 02             	shl    $0x2,%ecx
    a212:	01 c8                	add    %ecx,%eax
    a214:	8b 00                	mov    (%eax),%eax
    a216:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    a219:	8b 45 08             	mov    0x8(%ebp),%eax
    a21c:	8b 40 0c             	mov    0xc(%eax),%eax
    a21f:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    a223:	c1 e2 02             	shl    $0x2,%edx
    a226:	01 c2                	add    %eax,%edx
    a228:	8b 45 0c             	mov    0xc(%ebp),%eax
    a22b:	89 02                	mov    %eax,(%edx)
}
    a22d:	90                   	nop
    a22e:	c9                   	leave  
    a22f:	c3                   	ret    

0000a230 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    a230:	55                   	push   %ebp
    a231:	89 e5                	mov    %esp,%ebp
    a233:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    a236:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    a23d:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    a244:	77 08                	ja     a24e <encodeLZ77+0x1e>
    a246:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a249:	c1 e8 03             	shr    $0x3,%eax
    a24c:	eb 03                	jmp    a251 <encodeLZ77+0x21>
    a24e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a251:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    a254:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    a25b:	76 07                	jbe    a264 <encodeLZ77+0x34>
    a25d:	b8 02 01 00 00       	mov    $0x102,%eax
    a262:	eb 05                	jmp    a269 <encodeLZ77+0x39>
    a264:	b8 40 00 00 00       	mov    $0x40,%eax
    a269:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    a26c:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    a273:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    a27a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    a281:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    a288:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    a28f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    a293:	74 09                	je     a29e <encodeLZ77+0x6e>
    a295:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    a29c:	76 0a                	jbe    a2a8 <encodeLZ77+0x78>
    a29e:	b8 3c 00 00 00       	mov    $0x3c,%eax
    a2a3:	e9 e3 04 00 00       	jmp    a78b <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    a2a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a2ab:	83 e8 01             	sub    $0x1,%eax
    a2ae:	23 45 1c             	and    0x1c(%ebp),%eax
    a2b1:	85 c0                	test   %eax,%eax
    a2b3:	74 0a                	je     a2bf <encodeLZ77+0x8f>
    a2b5:	b8 5a 00 00 00       	mov    $0x5a,%eax
    a2ba:	e9 cc 04 00 00       	jmp    a78b <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    a2bf:	b8 02 01 00 00       	mov    $0x102,%eax
    a2c4:	39 45 24             	cmp    %eax,0x24(%ebp)
    a2c7:	76 08                	jbe    a2d1 <encodeLZ77+0xa1>
    a2c9:	b8 02 01 00 00       	mov    $0x102,%eax
    a2ce:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    a2d1:	8b 45 14             	mov    0x14(%ebp),%eax
    a2d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    a2d7:	e9 a0 04 00 00       	jmp    a77c <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    a2dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a2df:	8d 50 ff             	lea    -0x1(%eax),%edx
    a2e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a2e5:	21 d0                	and    %edx,%eax
    a2e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    a2ea:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    a2f1:	ff 75 fc             	pushl  -0x4(%ebp)
    a2f4:	ff 75 18             	pushl  0x18(%ebp)
    a2f7:	ff 75 10             	pushl  0x10(%ebp)
    a2fa:	e8 54 fd ff ff       	call   a053 <getHash>
    a2ff:	83 c4 0c             	add    $0xc,%esp
    a302:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    a305:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    a309:	74 4e                	je     a359 <encodeLZ77+0x129>
    a30b:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    a30f:	75 48                	jne    a359 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    a311:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a315:	75 16                	jne    a32d <encodeLZ77+0xfd>
    a317:	ff 75 fc             	pushl  -0x4(%ebp)
    a31a:	ff 75 18             	pushl  0x18(%ebp)
    a31d:	ff 75 10             	pushl  0x10(%ebp)
    a320:	e8 e2 fd ff ff       	call   a107 <countZeros>
    a325:	83 c4 0c             	add    $0xc,%esp
    a328:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a32b:	eb 35                	jmp    a362 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    a32d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a330:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a333:	01 c2                	add    %eax,%edx
    a335:	8b 45 18             	mov    0x18(%ebp),%eax
    a338:	39 c2                	cmp    %eax,%edx
    a33a:	77 17                	ja     a353 <encodeLZ77+0x123>
    a33c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a33f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a342:	01 d0                	add    %edx,%eax
    a344:	8d 50 ff             	lea    -0x1(%eax),%edx
    a347:	8b 45 10             	mov    0x10(%ebp),%eax
    a34a:	01 d0                	add    %edx,%eax
    a34c:	0f b6 00             	movzbl (%eax),%eax
    a34f:	84 c0                	test   %al,%al
    a351:	74 0f                	je     a362 <encodeLZ77+0x132>
    a353:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    a357:	eb 09                	jmp    a362 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    a359:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    a360:	eb 01                	jmp    a363 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    a362:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    a363:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a366:	0f b7 c0             	movzwl %ax,%eax
    a369:	50                   	push   %eax
    a36a:	ff 75 b0             	pushl  -0x50(%ebp)
    a36d:	ff 75 b4             	pushl  -0x4c(%ebp)
    a370:	ff 75 0c             	pushl  0xc(%ebp)
    a373:	e8 f1 fd ff ff       	call   a169 <updateHashChain>
    a378:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    a37b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    a382:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    a389:	8b 45 0c             	mov    0xc(%ebp),%eax
    a38c:	8b 40 04             	mov    0x4(%eax),%eax
    a38f:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    a392:	01 d2                	add    %edx,%edx
    a394:	01 d0                	add    %edx,%eax
    a396:	0f b7 00             	movzwl (%eax),%eax
    a399:	0f b7 c0             	movzwl %ax,%eax
    a39c:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    a39f:	ba 02 01 00 00       	mov    $0x102,%edx
    a3a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a3a7:	01 c2                	add    %eax,%edx
    a3a9:	8b 45 18             	mov    0x18(%ebp),%eax
    a3ac:	39 c2                	cmp    %eax,%edx
    a3ae:	0f 4e c2             	cmovle %edx,%eax
    a3b1:	89 c2                	mov    %eax,%edx
    a3b3:	8b 45 10             	mov    0x10(%ebp),%eax
    a3b6:	01 d0                	add    %edx,%eax
    a3b8:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    a3bb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    a3c2:	8b 45 c8             	mov    -0x38(%ebp),%eax
    a3c5:	8d 50 01             	lea    0x1(%eax),%edx
    a3c8:	89 55 c8             	mov    %edx,-0x38(%ebp)
    a3cb:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    a3ce:	0f 83 67 01 00 00    	jae    a53b <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    a3d4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    a3d7:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    a3da:	77 08                	ja     a3e4 <encodeLZ77+0x1b4>
    a3dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    a3df:	2b 45 cc             	sub    -0x34(%ebp),%eax
    a3e2:	eb 0d                	jmp    a3f1 <encodeLZ77+0x1c1>
    a3e4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    a3e7:	2b 45 cc             	sub    -0x34(%ebp),%eax
    a3ea:	89 c2                	mov    %eax,%edx
    a3ec:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a3ef:	01 d0                	add    %edx,%eax
    a3f1:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    a3f4:	8b 45 a8             	mov    -0x58(%ebp),%eax
    a3f7:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    a3fa:	0f 82 3e 01 00 00    	jb     a53e <encodeLZ77+0x30e>
      prev_offset = current_offset;
    a400:	8b 45 a8             	mov    -0x58(%ebp),%eax
    a403:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    a406:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    a40a:	0f 84 a3 00 00 00    	je     a4b3 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    a410:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a413:	8b 45 10             	mov    0x10(%ebp),%eax
    a416:	01 d0                	add    %edx,%eax
    a418:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    a41b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a41e:	2b 45 a8             	sub    -0x58(%ebp),%eax
    a421:	89 c2                	mov    %eax,%edx
    a423:	8b 45 10             	mov    0x10(%ebp),%eax
    a426:	01 d0                	add    %edx,%eax
    a428:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    a42b:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    a42f:	76 3a                	jbe    a46b <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    a431:	8b 45 0c             	mov    0xc(%ebp),%eax
    a434:	8b 40 14             	mov    0x14(%eax),%eax
    a437:	8b 55 cc             	mov    -0x34(%ebp),%edx
    a43a:	01 d2                	add    %edx,%edx
    a43c:	01 d0                	add    %edx,%eax
    a43e:	0f b7 00             	movzwl (%eax),%eax
    a441:	0f b7 c0             	movzwl %ax,%eax
    a444:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    a447:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    a44a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    a44d:	76 06                	jbe    a455 <encodeLZ77+0x225>
    a44f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a452:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    a455:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    a458:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    a45b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    a45e:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    a461:	eb 08                	jmp    a46b <encodeLZ77+0x23b>
          ++backptr;
    a463:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    a467:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    a46b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    a46e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    a471:	74 10                	je     a483 <encodeLZ77+0x253>
    a473:	8b 45 d0             	mov    -0x30(%ebp),%eax
    a476:	0f b6 10             	movzbl (%eax),%edx
    a479:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    a47c:	0f b6 00             	movzbl (%eax),%eax
    a47f:	38 c2                	cmp    %al,%dl
    a481:	74 e0                	je     a463 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    a483:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    a486:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    a489:	8b 55 10             	mov    0x10(%ebp),%edx
    a48c:	01 ca                	add    %ecx,%edx
    a48e:	29 d0                	sub    %edx,%eax
    a490:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    a493:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    a496:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    a499:	76 18                	jbe    a4b3 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    a49b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    a49e:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    a4a1:	8b 45 a8             	mov    -0x58(%ebp),%eax
    a4a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    a4a7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    a4aa:	3b 45 24             	cmp    0x24(%ebp),%eax
    a4ad:	0f 83 8e 00 00 00    	jae    a541 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    a4b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4b6:	8b 40 04             	mov    0x4(%eax),%eax
    a4b9:	8b 55 cc             	mov    -0x34(%ebp),%edx
    a4bc:	01 d2                	add    %edx,%edx
    a4be:	01 d0                	add    %edx,%eax
    a4c0:	0f b7 00             	movzwl (%eax),%eax
    a4c3:	0f b7 c0             	movzwl %ax,%eax
    a4c6:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    a4c9:	74 79                	je     a544 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    a4cb:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    a4cf:	76 38                	jbe    a509 <encodeLZ77+0x2d9>
    a4d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a4d4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    a4d7:	76 30                	jbe    a509 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    a4d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4dc:	8b 40 10             	mov    0x10(%eax),%eax
    a4df:	8b 55 cc             	mov    -0x34(%ebp),%edx
    a4e2:	01 d2                	add    %edx,%edx
    a4e4:	01 d0                	add    %edx,%eax
    a4e6:	0f b7 00             	movzwl (%eax),%eax
    a4e9:	0f b7 c0             	movzwl %ax,%eax
    a4ec:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    a4ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4f2:	8b 40 14             	mov    0x14(%eax),%eax
    a4f5:	8b 55 cc             	mov    -0x34(%ebp),%edx
    a4f8:	01 d2                	add    %edx,%edx
    a4fa:	01 d0                	add    %edx,%eax
    a4fc:	0f b7 00             	movzwl (%eax),%eax
    a4ff:	0f b7 c0             	movzwl %ax,%eax
    a502:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    a505:	74 2f                	je     a536 <encodeLZ77+0x306>
    a507:	eb 3f                	jmp    a548 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    a509:	8b 45 0c             	mov    0xc(%ebp),%eax
    a50c:	8b 40 04             	mov    0x4(%eax),%eax
    a50f:	8b 55 cc             	mov    -0x34(%ebp),%edx
    a512:	01 d2                	add    %edx,%edx
    a514:	01 d0                	add    %edx,%eax
    a516:	0f b7 00             	movzwl (%eax),%eax
    a519:	0f b7 c0             	movzwl %ax,%eax
    a51c:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    a51f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a522:	8b 40 08             	mov    0x8(%eax),%eax
    a525:	8b 55 cc             	mov    -0x34(%ebp),%edx
    a528:	c1 e2 02             	shl    $0x2,%edx
    a52b:	01 d0                	add    %edx,%eax
    a52d:	8b 10                	mov    (%eax),%edx
    a52f:	8b 45 b0             	mov    -0x50(%ebp),%eax
    a532:	39 c2                	cmp    %eax,%edx
    a534:	75 11                	jne    a547 <encodeLZ77+0x317>
      }
    }
    a536:	e9 87 fe ff ff       	jmp    a3c2 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    a53b:	90                   	nop
    a53c:	eb 0a                	jmp    a548 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    a53e:	90                   	nop
    a53f:	eb 07                	jmp    a548 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    a541:	90                   	nop
    a542:	eb 04                	jmp    a548 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    a544:	90                   	nop
    a545:	eb 01                	jmp    a548 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    a547:	90                   	nop
      }
    }

    if(lazymatching) {
    a548:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    a54c:	0f 84 c8 00 00 00    	je     a61a <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    a552:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    a556:	75 30                	jne    a588 <encodeLZ77+0x358>
    a558:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    a55c:	76 2a                	jbe    a588 <encodeLZ77+0x358>
    a55e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a561:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    a564:	77 22                	ja     a588 <encodeLZ77+0x358>
    a566:	b8 02 01 00 00       	mov    $0x102,%eax
    a56b:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    a56e:	73 18                	jae    a588 <encodeLZ77+0x358>
        lazy = 1;
    a570:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    a577:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a57a:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    a57d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a580:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    a583:	e9 f0 01 00 00       	jmp    a778 <encodeLZ77+0x548>
      }
      if(lazy) {
    a588:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    a58c:	0f 84 88 00 00 00    	je     a61a <encodeLZ77+0x3ea>
        lazy = 0;
    a592:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    a599:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    a59d:	75 0c                	jne    a5ab <encodeLZ77+0x37b>
    a59f:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    a5a6:	e9 dd 01 00 00       	jmp    a788 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    a5ab:	8b 45 e0             	mov    -0x20(%ebp),%eax
    a5ae:	83 c0 01             	add    $0x1,%eax
    a5b1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    a5b4:	73 2d                	jae    a5e3 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    a5b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a5b9:	8d 50 ff             	lea    -0x1(%eax),%edx
    a5bc:	8b 45 10             	mov    0x10(%ebp),%eax
    a5bf:	01 d0                	add    %edx,%eax
    a5c1:	0f b6 00             	movzbl (%eax),%eax
    a5c4:	0f b6 c0             	movzbl %al,%eax
    a5c7:	50                   	push   %eax
    a5c8:	ff 75 08             	pushl  0x8(%ebp)
    a5cb:	e8 6f cb ff ff       	call   713f <uivector_push_back>
    a5d0:	83 c4 08             	add    $0x8,%esp
    a5d3:	85 c0                	test   %eax,%eax
    a5d5:	75 43                	jne    a61a <encodeLZ77+0x3ea>
    a5d7:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    a5de:	e9 a5 01 00 00       	jmp    a788 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    a5e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    a5e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    a5e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    a5ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    a5ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5f2:	8b 00                	mov    (%eax),%eax
    a5f4:	8b 55 b0             	mov    -0x50(%ebp),%edx
    a5f7:	c1 e2 02             	shl    $0x2,%edx
    a5fa:	01 d0                	add    %edx,%eax
    a5fc:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    a602:	8b 45 0c             	mov    0xc(%ebp),%eax
    a605:	8b 40 0c             	mov    0xc(%eax),%eax
    a608:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a60b:	c1 e2 02             	shl    $0x2,%edx
    a60e:	01 d0                	add    %edx,%eax
    a610:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    a616:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    a61a:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    a61e:	76 14                	jbe    a634 <encodeLZ77+0x404>
    a620:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a623:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    a626:	76 0c                	jbe    a634 <encodeLZ77+0x404>
    a628:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    a62f:	e9 54 01 00 00       	jmp    a788 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    a634:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    a638:	77 2e                	ja     a668 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    a63a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a63d:	8b 45 10             	mov    0x10(%ebp),%eax
    a640:	01 d0                	add    %edx,%eax
    a642:	0f b6 00             	movzbl (%eax),%eax
    a645:	0f b6 c0             	movzbl %al,%eax
    a648:	50                   	push   %eax
    a649:	ff 75 08             	pushl  0x8(%ebp)
    a64c:	e8 ee ca ff ff       	call   713f <uivector_push_back>
    a651:	83 c4 08             	add    $0x8,%esp
    a654:	85 c0                	test   %eax,%eax
    a656:	0f 85 1c 01 00 00    	jne    a778 <encodeLZ77+0x548>
    a65c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    a663:	e9 20 01 00 00       	jmp    a788 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    a668:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a66b:	3b 45 20             	cmp    0x20(%ebp),%eax
    a66e:	72 0f                	jb     a67f <encodeLZ77+0x44f>
    a670:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    a674:	75 37                	jne    a6ad <encodeLZ77+0x47d>
    a676:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    a67d:	76 2e                	jbe    a6ad <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    a67f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a682:	8b 45 10             	mov    0x10(%ebp),%eax
    a685:	01 d0                	add    %edx,%eax
    a687:	0f b6 00             	movzbl (%eax),%eax
    a68a:	0f b6 c0             	movzbl %al,%eax
    a68d:	50                   	push   %eax
    a68e:	ff 75 08             	pushl  0x8(%ebp)
    a691:	e8 a9 ca ff ff       	call   713f <uivector_push_back>
    a696:	83 c4 08             	add    $0x8,%esp
    a699:	85 c0                	test   %eax,%eax
    a69b:	0f 85 d7 00 00 00    	jne    a778 <encodeLZ77+0x548>
    a6a1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    a6a8:	e9 db 00 00 00       	jmp    a788 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    a6ad:	8b 55 ec             	mov    -0x14(%ebp),%edx
    a6b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a6b3:	52                   	push   %edx
    a6b4:	50                   	push   %eax
    a6b5:	ff 75 08             	pushl  0x8(%ebp)
    a6b8:	e8 8a f6 ff ff       	call   9d47 <addLengthDistance>
    a6bd:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    a6c0:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    a6c7:	e9 a0 00 00 00       	jmp    a76c <encodeLZ77+0x53c>
        ++pos;
    a6cc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    a6d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6d3:	8d 50 ff             	lea    -0x1(%eax),%edx
    a6d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a6d9:	21 d0                	and    %edx,%eax
    a6db:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    a6de:	ff 75 fc             	pushl  -0x4(%ebp)
    a6e1:	ff 75 18             	pushl  0x18(%ebp)
    a6e4:	ff 75 10             	pushl  0x10(%ebp)
    a6e7:	e8 67 f9 ff ff       	call   a053 <getHash>
    a6ec:	83 c4 0c             	add    $0xc,%esp
    a6ef:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    a6f2:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    a6f6:	74 4e                	je     a746 <encodeLZ77+0x516>
    a6f8:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    a6fc:	75 48                	jne    a746 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    a6fe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    a702:	75 16                	jne    a71a <encodeLZ77+0x4ea>
    a704:	ff 75 fc             	pushl  -0x4(%ebp)
    a707:	ff 75 18             	pushl  0x18(%ebp)
    a70a:	ff 75 10             	pushl  0x10(%ebp)
    a70d:	e8 f5 f9 ff ff       	call   a107 <countZeros>
    a712:	83 c4 0c             	add    $0xc,%esp
    a715:	89 45 f0             	mov    %eax,-0x10(%ebp)
    a718:	eb 35                	jmp    a74f <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    a71a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a71d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a720:	01 c2                	add    %eax,%edx
    a722:	8b 45 18             	mov    0x18(%ebp),%eax
    a725:	39 c2                	cmp    %eax,%edx
    a727:	77 17                	ja     a740 <encodeLZ77+0x510>
    a729:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a72c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a72f:	01 d0                	add    %edx,%eax
    a731:	8d 50 ff             	lea    -0x1(%eax),%edx
    a734:	8b 45 10             	mov    0x10(%ebp),%eax
    a737:	01 d0                	add    %edx,%eax
    a739:	0f b6 00             	movzbl (%eax),%eax
    a73c:	84 c0                	test   %al,%al
    a73e:	74 0f                	je     a74f <encodeLZ77+0x51f>
    a740:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    a744:	eb 09                	jmp    a74f <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    a746:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    a74d:	eb 01                	jmp    a750 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    a74f:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    a750:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a753:	0f b7 c0             	movzwl %ax,%eax
    a756:	50                   	push   %eax
    a757:	ff 75 b0             	pushl  -0x50(%ebp)
    a75a:	ff 75 b4             	pushl  -0x4c(%ebp)
    a75d:	ff 75 0c             	pushl  0xc(%ebp)
    a760:	e8 04 fa ff ff       	call   a169 <updateHashChain>
    a765:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    a768:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a76c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a76f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    a772:	0f 82 54 ff ff ff    	jb     a6cc <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    a778:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a77c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    a77f:	3b 45 18             	cmp    0x18(%ebp),%eax
    a782:	0f 8c 54 fb ff ff    	jl     a2dc <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    a788:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    a78b:	c9                   	leave  
    a78c:	c3                   	ret    

0000a78d <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    a78d:	55                   	push   %ebp
    a78e:	89 e5                	mov    %esp,%ebp
    a790:	53                   	push   %ebx
    a791:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    a794:	8b 45 10             	mov    0x10(%ebp),%eax
    a797:	05 fe ff 00 00       	add    $0xfffe,%eax
    a79c:	ba 01 80 00 80       	mov    $0x80008001,%edx
    a7a1:	f7 e2                	mul    %edx
    a7a3:	89 d0                	mov    %edx,%eax
    a7a5:	c1 e8 0f             	shr    $0xf,%eax
    a7a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    a7ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    a7b2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    a7b9:	e9 1b 01 00 00       	jmp    a8d9 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    a7be:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c1:	8b 40 04             	mov    0x4(%eax),%eax
    a7c4:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    a7c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a7ca:	83 e8 01             	sub    $0x1,%eax
    a7cd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    a7d0:	0f 94 c0             	sete   %al
    a7d3:	0f b6 c0             	movzbl %al,%eax
    a7d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    a7d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    a7e0:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    a7e7:	8b 45 10             	mov    0x10(%ebp),%eax
    a7ea:	2b 45 f4             	sub    -0xc(%ebp),%eax
    a7ed:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    a7f2:	77 09                	ja     a7fd <deflateNoCompression+0x70>
    a7f4:	8b 45 10             	mov    0x10(%ebp),%eax
    a7f7:	2b 45 f4             	sub    -0xc(%ebp),%eax
    a7fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    a7fd:	b8 ff ff 00 00       	mov    $0xffff,%eax
    a802:	2b 45 f0             	sub    -0x10(%ebp),%eax
    a805:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    a808:	8b 45 08             	mov    0x8(%ebp),%eax
    a80b:	8b 40 04             	mov    0x4(%eax),%eax
    a80e:	89 c2                	mov    %eax,%edx
    a810:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a813:	01 d0                	add    %edx,%eax
    a815:	83 c0 05             	add    $0x5,%eax
    a818:	50                   	push   %eax
    a819:	ff 75 08             	pushl  0x8(%ebp)
    a81c:	e8 62 c9 ff ff       	call   7183 <ucvector_resize>
    a821:	83 c4 08             	add    $0x8,%esp
    a824:	85 c0                	test   %eax,%eax
    a826:	75 0a                	jne    a832 <deflateNoCompression+0xa5>
    a828:	b8 53 00 00 00       	mov    $0x53,%eax
    a82d:	e9 b8 00 00 00       	jmp    a8ea <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    a832:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a835:	89 c2                	mov    %eax,%edx
    a837:	8b 45 e0             	mov    -0x20(%ebp),%eax
    a83a:	83 e0 01             	and    $0x1,%eax
    a83d:	01 c0                	add    %eax,%eax
    a83f:	01 c2                	add    %eax,%edx
    a841:	8b 45 e0             	mov    -0x20(%ebp),%eax
    a844:	83 e0 02             	and    $0x2,%eax
    a847:	01 c0                	add    %eax,%eax
    a849:	01 d0                	add    %edx,%eax
    a84b:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    a84e:	8b 45 08             	mov    0x8(%ebp),%eax
    a851:	8b 10                	mov    (%eax),%edx
    a853:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a856:	01 c2                	add    %eax,%edx
    a858:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    a85c:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    a85e:	8b 45 08             	mov    0x8(%ebp),%eax
    a861:	8b 00                	mov    (%eax),%eax
    a863:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a866:	83 c2 01             	add    $0x1,%edx
    a869:	01 d0                	add    %edx,%eax
    a86b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a86e:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    a870:	8b 45 08             	mov    0x8(%ebp),%eax
    a873:	8b 00                	mov    (%eax),%eax
    a875:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a878:	83 c2 02             	add    $0x2,%edx
    a87b:	01 d0                	add    %edx,%eax
    a87d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a880:	c1 ea 08             	shr    $0x8,%edx
    a883:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    a885:	8b 45 08             	mov    0x8(%ebp),%eax
    a888:	8b 00                	mov    (%eax),%eax
    a88a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a88d:	83 c2 03             	add    $0x3,%edx
    a890:	01 d0                	add    %edx,%eax
    a892:	8b 55 dc             	mov    -0x24(%ebp),%edx
    a895:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    a897:	8b 45 08             	mov    0x8(%ebp),%eax
    a89a:	8b 00                	mov    (%eax),%eax
    a89c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a89f:	83 c2 04             	add    $0x4,%edx
    a8a2:	01 d0                	add    %edx,%eax
    a8a4:	8b 55 dc             	mov    -0x24(%ebp),%edx
    a8a7:	c1 ea 08             	shr    $0x8,%edx
    a8aa:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    a8ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a8af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    a8b2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a8b5:	01 d1                	add    %edx,%ecx
    a8b7:	8b 55 08             	mov    0x8(%ebp),%edx
    a8ba:	8b 12                	mov    (%edx),%edx
    a8bc:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    a8bf:	83 c3 05             	add    $0x5,%ebx
    a8c2:	01 da                	add    %ebx,%edx
    a8c4:	50                   	push   %eax
    a8c5:	51                   	push   %ecx
    a8c6:	52                   	push   %edx
    a8c7:	e8 9b c6 ff ff       	call   6f67 <lodepng_memcpy>
    a8cc:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    a8cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a8d2:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    a8d5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a8d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a8dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    a8df:	0f 85 d9 fe ff ff    	jne    a7be <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    a8e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a8ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a8ed:	c9                   	leave  
    a8ee:	c3                   	ret    

0000a8ef <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    a8ef:	55                   	push   %ebp
    a8f0:	89 e5                	mov    %esp,%ebp
    a8f2:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    a8f5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    a8fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    a903:	e9 10 01 00 00       	jmp    aa18 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    a908:	8b 45 0c             	mov    0xc(%ebp),%eax
    a90b:	8b 00                	mov    (%eax),%eax
    a90d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a910:	c1 e2 02             	shl    $0x2,%edx
    a913:	01 d0                	add    %edx,%eax
    a915:	8b 00                	mov    (%eax),%eax
    a917:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    a91a:	8b 45 10             	mov    0x10(%ebp),%eax
    a91d:	8b 40 04             	mov    0x4(%eax),%eax
    a920:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a923:	c1 e2 02             	shl    $0x2,%edx
    a926:	01 d0                	add    %edx,%eax
    a928:	8b 00                	mov    (%eax),%eax
    a92a:	89 c1                	mov    %eax,%ecx
    a92c:	8b 45 10             	mov    0x10(%ebp),%eax
    a92f:	8b 00                	mov    (%eax),%eax
    a931:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a934:	c1 e2 02             	shl    $0x2,%edx
    a937:	01 d0                	add    %edx,%eax
    a939:	8b 00                	mov    (%eax),%eax
    a93b:	51                   	push   %ecx
    a93c:	50                   	push   %eax
    a93d:	ff 75 08             	pushl  0x8(%ebp)
    a940:	e8 60 cc ff ff       	call   75a5 <writeBitsReversed>
    a945:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    a948:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    a94f:	0f 86 bf 00 00 00    	jbe    aa14 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    a955:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a958:	2d 01 01 00 00       	sub    $0x101,%eax
    a95d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    a960:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a963:	8b 04 85 60 f1 01 00 	mov    0x1f160(,%eax,4),%eax
    a96a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    a96d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a970:	8b 00                	mov    (%eax),%eax
    a972:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a976:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a979:	c1 e2 02             	shl    $0x2,%edx
    a97c:	01 d0                	add    %edx,%eax
    a97e:	8b 00                	mov    (%eax),%eax
    a980:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    a983:	8b 45 0c             	mov    0xc(%ebp),%eax
    a986:	8b 00                	mov    (%eax),%eax
    a988:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a98c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a98f:	c1 e2 02             	shl    $0x2,%edx
    a992:	01 d0                	add    %edx,%eax
    a994:	8b 00                	mov    (%eax),%eax
    a996:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    a999:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a99c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    a99f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a9a2:	8b 04 85 60 f2 01 00 	mov    0x1f260(,%eax,4),%eax
    a9a9:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    a9ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9af:	8b 00                	mov    (%eax),%eax
    a9b1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    a9b5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9b8:	c1 e2 02             	shl    $0x2,%edx
    a9bb:	01 d0                	add    %edx,%eax
    a9bd:	8b 00                	mov    (%eax),%eax
    a9bf:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    a9c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a9c5:	50                   	push   %eax
    a9c6:	ff 75 ec             	pushl  -0x14(%ebp)
    a9c9:	ff 75 08             	pushl  0x8(%ebp)
    a9cc:	e8 40 ca ff ff       	call   7411 <writeBits>
    a9d1:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    a9d4:	8b 45 14             	mov    0x14(%ebp),%eax
    a9d7:	8b 40 04             	mov    0x4(%eax),%eax
    a9da:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a9dd:	c1 e2 02             	shl    $0x2,%edx
    a9e0:	01 d0                	add    %edx,%eax
    a9e2:	8b 00                	mov    (%eax),%eax
    a9e4:	89 c1                	mov    %eax,%ecx
    a9e6:	8b 45 14             	mov    0x14(%ebp),%eax
    a9e9:	8b 00                	mov    (%eax),%eax
    a9eb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a9ee:	c1 e2 02             	shl    $0x2,%edx
    a9f1:	01 d0                	add    %edx,%eax
    a9f3:	8b 00                	mov    (%eax),%eax
    a9f5:	51                   	push   %ecx
    a9f6:	50                   	push   %eax
    a9f7:	ff 75 08             	pushl  0x8(%ebp)
    a9fa:	e8 a6 cb ff ff       	call   75a5 <writeBitsReversed>
    a9ff:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    aa02:	8b 45 e0             	mov    -0x20(%ebp),%eax
    aa05:	50                   	push   %eax
    aa06:	ff 75 dc             	pushl  -0x24(%ebp)
    aa09:	ff 75 08             	pushl  0x8(%ebp)
    aa0c:	e8 00 ca ff ff       	call   7411 <writeBits>
    aa11:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    aa14:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    aa18:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa1b:	8b 40 04             	mov    0x4(%eax),%eax
    aa1e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    aa21:	0f 85 e1 fe ff ff    	jne    a908 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    aa27:	90                   	nop
    aa28:	c9                   	leave  
    aa29:	c3                   	ret    

0000aa2a <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    aa2a:	55                   	push   %ebp
    aa2b:	89 e5                	mov    %esp,%ebp
    aa2d:	53                   	push   %ebx
    aa2e:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    aa34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    aa3b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    aa42:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    aa49:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    aa50:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    aa57:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    aa5e:	8b 45 18             	mov    0x18(%ebp),%eax
    aa61:	2b 45 14             	sub    0x14(%ebp),%eax
    aa64:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    aa67:	8b 45 20             	mov    0x20(%ebp),%eax
    aa6a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    aa6d:	8d 45 90             	lea    -0x70(%ebp),%eax
    aa70:	50                   	push   %eax
    aa71:	e8 a4 c6 ff ff       	call   711a <uivector_init>
    aa76:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    aa79:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    aa7f:	50                   	push   %eax
    aa80:	e8 98 d3 ff ff       	call   7e1d <HuffmanTree_init>
    aa85:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    aa88:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    aa8e:	50                   	push   %eax
    aa8f:	e8 89 d3 ff ff       	call   7e1d <HuffmanTree_init>
    aa94:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    aa97:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    aa9d:	50                   	push   %eax
    aa9e:	e8 7a d3 ff ff       	call   7e1d <HuffmanTree_init>
    aaa3:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    aaa6:	83 ec 0c             	sub    $0xc,%esp
    aaa9:	68 78 04 00 00       	push   $0x478
    aaae:	e8 76 c4 ff ff       	call   6f29 <lodepng_malloc>
    aab3:	83 c4 10             	add    $0x10,%esp
    aab6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    aab9:	83 ec 0c             	sub    $0xc,%esp
    aabc:	6a 78                	push   $0x78
    aabe:	e8 66 c4 ff ff       	call   6f29 <lodepng_malloc>
    aac3:	83 c4 10             	add    $0x10,%esp
    aac6:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    aac9:	83 ec 0c             	sub    $0xc,%esp
    aacc:	6a 4c                	push   $0x4c
    aace:	e8 56 c4 ff ff       	call   6f29 <lodepng_malloc>
    aad3:	83 c4 10             	add    $0x10,%esp
    aad6:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    aad9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    aadd:	74 0c                	je     aaeb <deflateDynamic+0xc1>
    aadf:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    aae3:	74 06                	je     aaeb <deflateDynamic+0xc1>
    aae5:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    aae9:	75 07                	jne    aaf2 <deflateDynamic+0xc8>
    aaeb:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    aaf2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    aaf6:	0f 85 f6 07 00 00    	jne    b2f2 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    aafc:	83 ec 04             	sub    $0x4,%esp
    aaff:	68 78 04 00 00       	push   $0x478
    ab04:	6a 00                	push   $0x0
    ab06:	ff 75 d4             	pushl  -0x2c(%ebp)
    ab09:	e8 8c c4 ff ff       	call   6f9a <lodepng_memset>
    ab0e:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    ab11:	83 ec 04             	sub    $0x4,%esp
    ab14:	6a 78                	push   $0x78
    ab16:	6a 00                	push   $0x0
    ab18:	ff 75 d0             	pushl  -0x30(%ebp)
    ab1b:	e8 7a c4 ff ff       	call   6f9a <lodepng_memset>
    ab20:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    ab23:	83 ec 04             	sub    $0x4,%esp
    ab26:	6a 4c                	push   $0x4c
    ab28:	6a 00                	push   $0x0
    ab2a:	ff 75 cc             	pushl  -0x34(%ebp)
    ab2d:	e8 68 c4 ff ff       	call   6f9a <lodepng_memset>
    ab32:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    ab35:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab38:	8b 40 04             	mov    0x4(%eax),%eax
    ab3b:	85 c0                	test   %eax,%eax
    ab3d:	74 45                	je     ab84 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    ab3f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab42:	8b 58 14             	mov    0x14(%eax),%ebx
    ab45:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab48:	8b 48 10             	mov    0x10(%eax),%ecx
    ab4b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab4e:	8b 50 0c             	mov    0xc(%eax),%edx
    ab51:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab54:	8b 40 08             	mov    0x8(%eax),%eax
    ab57:	83 ec 0c             	sub    $0xc,%esp
    ab5a:	53                   	push   %ebx
    ab5b:	51                   	push   %ecx
    ab5c:	52                   	push   %edx
    ab5d:	50                   	push   %eax
    ab5e:	ff 75 18             	pushl  0x18(%ebp)
    ab61:	ff 75 14             	pushl  0x14(%ebp)
    ab64:	ff 75 10             	pushl  0x10(%ebp)
    ab67:	ff 75 0c             	pushl  0xc(%ebp)
    ab6a:	8d 45 90             	lea    -0x70(%ebp),%eax
    ab6d:	50                   	push   %eax
    ab6e:	e8 bd f6 ff ff       	call   a230 <encodeLZ77>
    ab73:	83 c4 30             	add    $0x30,%esp
    ab76:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    ab79:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ab7d:	74 59                	je     abd8 <deflateDynamic+0x1ae>
    ab7f:	e9 6e 07 00 00       	jmp    b2f2 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    ab84:	83 ec 08             	sub    $0x8,%esp
    ab87:	ff 75 c8             	pushl  -0x38(%ebp)
    ab8a:	8d 45 90             	lea    -0x70(%ebp),%eax
    ab8d:	50                   	push   %eax
    ab8e:	e8 17 c5 ff ff       	call   70aa <uivector_resize>
    ab93:	83 c4 10             	add    $0x10,%esp
    ab96:	85 c0                	test   %eax,%eax
    ab98:	75 0c                	jne    aba6 <deflateDynamic+0x17c>
    ab9a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    aba1:	e9 4c 07 00 00       	jmp    b2f2 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    aba6:	8b 45 14             	mov    0x14(%ebp),%eax
    aba9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    abac:	eb 22                	jmp    abd0 <deflateDynamic+0x1a6>
    abae:	8b 55 90             	mov    -0x70(%ebp),%edx
    abb1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    abb4:	2b 45 14             	sub    0x14(%ebp),%eax
    abb7:	c1 e0 02             	shl    $0x2,%eax
    abba:	01 c2                	add    %eax,%edx
    abbc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    abbf:	8b 45 10             	mov    0x10(%ebp),%eax
    abc2:	01 c8                	add    %ecx,%eax
    abc4:	0f b6 00             	movzbl (%eax),%eax
    abc7:	0f b6 c0             	movzbl %al,%eax
    abca:	89 02                	mov    %eax,(%edx)
    abcc:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    abd0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    abd3:	3b 45 18             	cmp    0x18(%ebp),%eax
    abd6:	7c d6                	jl     abae <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    abd8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    abdf:	eb 60                	jmp    ac41 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    abe1:	8b 45 90             	mov    -0x70(%ebp),%eax
    abe4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    abe7:	c1 e2 02             	shl    $0x2,%edx
    abea:	01 d0                	add    %edx,%eax
    abec:	8b 00                	mov    (%eax),%eax
    abee:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    abf1:	8b 45 c0             	mov    -0x40(%ebp),%eax
    abf4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    abfb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    abfe:	01 d0                	add    %edx,%eax
    ac00:	8b 10                	mov    (%eax),%edx
    ac02:	83 c2 01             	add    $0x1,%edx
    ac05:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    ac07:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    ac0e:	76 2d                	jbe    ac3d <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    ac10:	8b 45 90             	mov    -0x70(%ebp),%eax
    ac13:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ac16:	83 c2 02             	add    $0x2,%edx
    ac19:	c1 e2 02             	shl    $0x2,%edx
    ac1c:	01 d0                	add    %edx,%eax
    ac1e:	8b 00                	mov    (%eax),%eax
    ac20:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    ac23:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ac26:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ac2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ac30:	01 d0                	add    %edx,%eax
    ac32:	8b 10                	mov    (%eax),%edx
    ac34:	83 c2 01             	add    $0x1,%edx
    ac37:	89 10                	mov    %edx,(%eax)
        i += 3;
    ac39:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    ac3d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ac41:	8b 45 94             	mov    -0x6c(%ebp),%eax
    ac44:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    ac47:	75 98                	jne    abe1 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    ac49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ac4c:	05 00 04 00 00       	add    $0x400,%eax
    ac51:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    ac57:	83 ec 0c             	sub    $0xc,%esp
    ac5a:	6a 0f                	push   $0xf
    ac5c:	68 1e 01 00 00       	push   $0x11e
    ac61:	68 01 01 00 00       	push   $0x101
    ac66:	ff 75 d4             	pushl  -0x2c(%ebp)
    ac69:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    ac6f:	50                   	push   %eax
    ac70:	e8 e0 e1 ff ff       	call   8e55 <HuffmanTree_makeFromFrequencies>
    ac75:	83 c4 20             	add    $0x20,%esp
    ac78:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    ac7b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ac7f:	0f 85 66 06 00 00    	jne    b2eb <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    ac85:	83 ec 0c             	sub    $0xc,%esp
    ac88:	6a 0f                	push   $0xf
    ac8a:	6a 1e                	push   $0x1e
    ac8c:	6a 02                	push   $0x2
    ac8e:	ff 75 d0             	pushl  -0x30(%ebp)
    ac91:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    ac97:	50                   	push   %eax
    ac98:	e8 b8 e1 ff ff       	call   8e55 <HuffmanTree_makeFromFrequencies>
    ac9d:	83 c4 20             	add    $0x20,%esp
    aca0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    aca3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    aca7:	0f 85 41 06 00 00    	jne    b2ee <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    acad:	8b 45 84             	mov    -0x7c(%ebp),%eax
    acb0:	ba 1e 01 00 00       	mov    $0x11e,%edx
    acb5:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    acba:	0f 47 c2             	cmova  %edx,%eax
    acbd:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    acc0:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    acc6:	ba 1e 00 00 00       	mov    $0x1e,%edx
    accb:	83 f8 1e             	cmp    $0x1e,%eax
    acce:	0f 47 c2             	cmova  %edx,%eax
    acd1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    acd4:	8b 55 b8             	mov    -0x48(%ebp),%edx
    acd7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    acda:	01 d0                	add    %edx,%eax
    acdc:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    acdf:	8b 45 b0             	mov    -0x50(%ebp),%eax
    ace2:	c1 e0 02             	shl    $0x2,%eax
    ace5:	83 ec 0c             	sub    $0xc,%esp
    ace8:	50                   	push   %eax
    ace9:	e8 3b c2 ff ff       	call   6f29 <lodepng_malloc>
    acee:	83 c4 10             	add    $0x10,%esp
    acf1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    acf4:	8b 45 b0             	mov    -0x50(%ebp),%eax
    acf7:	c1 e0 02             	shl    $0x2,%eax
    acfa:	83 ec 0c             	sub    $0xc,%esp
    acfd:	50                   	push   %eax
    acfe:	e8 26 c2 ff ff       	call   6f29 <lodepng_malloc>
    ad03:	83 c4 10             	add    $0x10,%esp
    ad06:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    ad09:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ad0d:	74 06                	je     ad15 <deflateDynamic+0x2eb>
    ad0f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ad13:	75 0c                	jne    ad21 <deflateDynamic+0x2f7>
    ad15:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ad1c:	e9 d1 05 00 00       	jmp    b2f2 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    ad21:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    ad28:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ad2f:	eb 25                	jmp    ad56 <deflateDynamic+0x32c>
    ad31:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ad34:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ad3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ad3e:	01 c2                	add    %eax,%edx
    ad40:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    ad46:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    ad49:	c1 e1 02             	shl    $0x2,%ecx
    ad4c:	01 c8                	add    %ecx,%eax
    ad4e:	8b 00                	mov    (%eax),%eax
    ad50:	89 02                	mov    %eax,(%edx)
    ad52:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ad56:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ad59:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    ad5c:	75 d3                	jne    ad31 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    ad5e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ad65:	eb 2a                	jmp    ad91 <deflateDynamic+0x367>
    ad67:	8b 55 b8             	mov    -0x48(%ebp),%edx
    ad6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ad6d:	01 d0                	add    %edx,%eax
    ad6f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ad76:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ad79:	01 c2                	add    %eax,%edx
    ad7b:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    ad81:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    ad84:	c1 e1 02             	shl    $0x2,%ecx
    ad87:	01 c8                	add    %ecx,%eax
    ad89:	8b 00                	mov    (%eax),%eax
    ad8b:	89 02                	mov    %eax,(%edx)
    ad8d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ad91:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ad94:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    ad97:	75 ce                	jne    ad67 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    ad99:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ada0:	e9 3b 02 00 00       	jmp    afe0 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    ada5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    adac:	eb 04                	jmp    adb2 <deflateDynamic+0x388>
    adae:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    adb2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    adb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    adb8:	01 d0                	add    %edx,%eax
    adba:	8d 50 01             	lea    0x1(%eax),%edx
    adbd:	8b 45 b0             	mov    -0x50(%ebp),%eax
    adc0:	39 c2                	cmp    %eax,%edx
    adc2:	73 2e                	jae    adf2 <deflateDynamic+0x3c8>
    adc4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    adc7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    adca:	01 d0                	add    %edx,%eax
    adcc:	83 c0 01             	add    $0x1,%eax
    adcf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    add6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    add9:	01 d0                	add    %edx,%eax
    addb:	8b 10                	mov    (%eax),%edx
    addd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ade0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    ade7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    adea:	01 c8                	add    %ecx,%eax
    adec:	8b 00                	mov    (%eax),%eax
    adee:	39 c2                	cmp    %eax,%edx
    adf0:	74 bc                	je     adae <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    adf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    adf5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    adfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    adff:	01 d0                	add    %edx,%eax
    ae01:	8b 00                	mov    (%eax),%eax
    ae03:	85 c0                	test   %eax,%eax
    ae05:	0f 85 a9 00 00 00    	jne    aeb4 <deflateDynamic+0x48a>
    ae0b:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    ae0f:	0f 86 9f 00 00 00    	jbe    aeb4 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    ae15:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    ae19:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    ae1d:	77 3a                	ja     ae59 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    ae1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ae22:	8d 50 01             	lea    0x1(%eax),%edx
    ae25:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    ae28:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ae2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ae32:	01 d0                	add    %edx,%eax
    ae34:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    ae3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ae3d:	8d 50 01             	lea    0x1(%eax),%edx
    ae40:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    ae43:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ae4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ae4d:	01 d0                	add    %edx,%eax
    ae4f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    ae52:	83 ea 03             	sub    $0x3,%edx
    ae55:	89 10                	mov    %edx,(%eax)
    ae57:	eb 48                	jmp    aea1 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    ae59:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    ae60:	76 07                	jbe    ae69 <deflateDynamic+0x43f>
    ae62:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    ae69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ae6c:	8d 50 01             	lea    0x1(%eax),%edx
    ae6f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    ae72:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ae79:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ae7c:	01 d0                	add    %edx,%eax
    ae7e:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    ae84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ae87:	8d 50 01             	lea    0x1(%eax),%edx
    ae8a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    ae8d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ae94:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ae97:	01 d0                	add    %edx,%eax
    ae99:	8b 55 dc             	mov    -0x24(%ebp),%edx
    ae9c:	83 ea 0b             	sub    $0xb,%edx
    ae9f:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    aea1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    aea4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    aea7:	01 d0                	add    %edx,%eax
    aea9:	83 e8 01             	sub    $0x1,%eax
    aeac:	89 45 e8             	mov    %eax,-0x18(%ebp)
    aeaf:	e9 28 01 00 00       	jmp    afdc <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    aeb4:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    aeb8:	0f 86 f6 00 00 00    	jbe    afb4 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    aebe:	8b 45 dc             	mov    -0x24(%ebp),%eax
    aec1:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    aec6:	f7 e2                	mul    %edx
    aec8:	89 d0                	mov    %edx,%eax
    aeca:	c1 e8 02             	shr    $0x2,%eax
    aecd:	89 45 ac             	mov    %eax,-0x54(%ebp)
    aed0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    aed3:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    aed8:	89 c8                	mov    %ecx,%eax
    aeda:	f7 e2                	mul    %edx
    aedc:	c1 ea 02             	shr    $0x2,%edx
    aedf:	89 d0                	mov    %edx,%eax
    aee1:	01 c0                	add    %eax,%eax
    aee3:	01 d0                	add    %edx,%eax
    aee5:	01 c0                	add    %eax,%eax
    aee7:	29 c1                	sub    %eax,%ecx
    aee9:	89 c8                	mov    %ecx,%eax
    aeeb:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    aeee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    aef1:	8d 50 01             	lea    0x1(%eax),%edx
    aef4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    aef7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    aefe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    af01:	01 c2                	add    %eax,%edx
    af03:	8b 45 e8             	mov    -0x18(%ebp),%eax
    af06:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    af0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    af10:	01 c8                	add    %ecx,%eax
    af12:	8b 00                	mov    (%eax),%eax
    af14:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    af16:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    af1d:	eb 3a                	jmp    af59 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    af1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    af22:	8d 50 01             	lea    0x1(%eax),%edx
    af25:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    af28:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    af2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    af32:	01 d0                	add    %edx,%eax
    af34:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    af3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    af3d:	8d 50 01             	lea    0x1(%eax),%edx
    af40:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    af43:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    af4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    af4d:	01 d0                	add    %edx,%eax
    af4f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    af55:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    af59:	8b 45 d8             	mov    -0x28(%ebp),%eax
    af5c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    af5f:	72 be                	jb     af1f <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    af61:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    af65:	76 3a                	jbe    afa1 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    af67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    af6a:	8d 50 01             	lea    0x1(%eax),%edx
    af6d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    af70:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    af77:	8b 45 ec             	mov    -0x14(%ebp),%eax
    af7a:	01 d0                	add    %edx,%eax
    af7c:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    af82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    af85:	8d 50 01             	lea    0x1(%eax),%edx
    af88:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    af8b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    af92:	8b 45 ec             	mov    -0x14(%ebp),%eax
    af95:	01 d0                	add    %edx,%eax
    af97:	8b 55 a8             	mov    -0x58(%ebp),%edx
    af9a:	83 ea 03             	sub    $0x3,%edx
    af9d:	89 10                	mov    %edx,(%eax)
    af9f:	eb 06                	jmp    afa7 <deflateDynamic+0x57d>
        }
        else j -= rest;
    afa1:	8b 45 a8             	mov    -0x58(%ebp),%eax
    afa4:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    afa7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    afaa:	8b 45 dc             	mov    -0x24(%ebp),%eax
    afad:	01 d0                	add    %edx,%eax
    afaf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    afb2:	eb 28                	jmp    afdc <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    afb4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    afb7:	8d 50 01             	lea    0x1(%eax),%edx
    afba:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    afbd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    afc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    afc7:	01 c2                	add    %eax,%edx
    afc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    afcc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    afd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    afd6:	01 c8                	add    %ecx,%eax
    afd8:	8b 00                	mov    (%eax),%eax
    afda:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    afdc:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    afe0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    afe3:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    afe6:	0f 85 b9 fd ff ff    	jne    ada5 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    afec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    aff3:	eb 42                	jmp    b037 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    aff5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    aff8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    afff:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b002:	01 d0                	add    %edx,%eax
    b004:	8b 00                	mov    (%eax),%eax
    b006:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b00d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    b010:	01 d0                	add    %edx,%eax
    b012:	8b 10                	mov    (%eax),%edx
    b014:	83 c2 01             	add    $0x1,%edx
    b017:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    b019:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b01c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b023:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b026:	01 d0                	add    %edx,%eax
    b028:	8b 00                	mov    (%eax),%eax
    b02a:	83 f8 0f             	cmp    $0xf,%eax
    b02d:	76 04                	jbe    b033 <deflateDynamic+0x609>
    b02f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    b033:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    b037:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b03a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    b03d:	75 b6                	jne    aff5 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    b03f:	83 ec 0c             	sub    $0xc,%esp
    b042:	6a 07                	push   $0x7
    b044:	6a 13                	push   $0x13
    b046:	6a 13                	push   $0x13
    b048:	ff 75 cc             	pushl  -0x34(%ebp)
    b04b:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    b051:	50                   	push   %eax
    b052:	e8 fe dd ff ff       	call   8e55 <HuffmanTree_makeFromFrequencies>
    b057:	83 c4 20             	add    $0x20,%esp
    b05a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    b05d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b061:	0f 85 8a 02 00 00    	jne    b2f1 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    b067:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    b06e:	eb 04                	jmp    b074 <deflateDynamic+0x64a>
      numcodes_cl--;
    b070:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    b074:	8b 45 e0             	mov    -0x20(%ebp),%eax
    b077:	83 f8 04             	cmp    $0x4,%eax
    b07a:	76 1e                	jbe    b09a <deflateDynamic+0x670>
    b07c:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    b082:	8b 55 e0             	mov    -0x20(%ebp),%edx
    b085:	83 ea 01             	sub    $0x1,%edx
    b088:	8b 14 95 e0 f2 01 00 	mov    0x1f2e0(,%edx,4),%edx
    b08f:	c1 e2 02             	shl    $0x2,%edx
    b092:	01 d0                	add    %edx,%eax
    b094:	8b 00                	mov    (%eax),%eax
    b096:	85 c0                	test   %eax,%eax
    b098:	74 d6                	je     b070 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    b09a:	83 ec 04             	sub    $0x4,%esp
    b09d:	6a 01                	push   $0x1
    b09f:	ff 75 c4             	pushl  -0x3c(%ebp)
    b0a2:	ff 75 08             	pushl  0x8(%ebp)
    b0a5:	e8 67 c3 ff ff       	call   7411 <writeBits>
    b0aa:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    b0ad:	83 ec 04             	sub    $0x4,%esp
    b0b0:	6a 01                	push   $0x1
    b0b2:	6a 00                	push   $0x0
    b0b4:	ff 75 08             	pushl  0x8(%ebp)
    b0b7:	e8 55 c3 ff ff       	call   7411 <writeBits>
    b0bc:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    b0bf:	83 ec 04             	sub    $0x4,%esp
    b0c2:	6a 01                	push   $0x1
    b0c4:	6a 01                	push   $0x1
    b0c6:	ff 75 08             	pushl  0x8(%ebp)
    b0c9:	e8 43 c3 ff ff       	call   7411 <writeBits>
    b0ce:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    b0d1:	8b 45 b8             	mov    -0x48(%ebp),%eax
    b0d4:	2d 01 01 00 00       	sub    $0x101,%eax
    b0d9:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    b0dc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    b0df:	83 e8 01             	sub    $0x1,%eax
    b0e2:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    b0e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    b0e8:	83 e8 04             	sub    $0x4,%eax
    b0eb:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    b0ee:	83 ec 04             	sub    $0x4,%esp
    b0f1:	6a 05                	push   $0x5
    b0f3:	ff 75 a4             	pushl  -0x5c(%ebp)
    b0f6:	ff 75 08             	pushl  0x8(%ebp)
    b0f9:	e8 13 c3 ff ff       	call   7411 <writeBits>
    b0fe:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    b101:	83 ec 04             	sub    $0x4,%esp
    b104:	6a 05                	push   $0x5
    b106:	ff 75 a0             	pushl  -0x60(%ebp)
    b109:	ff 75 08             	pushl  0x8(%ebp)
    b10c:	e8 00 c3 ff ff       	call   7411 <writeBits>
    b111:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    b114:	83 ec 04             	sub    $0x4,%esp
    b117:	6a 04                	push   $0x4
    b119:	ff 75 9c             	pushl  -0x64(%ebp)
    b11c:	ff 75 08             	pushl  0x8(%ebp)
    b11f:	e8 ed c2 ff ff       	call   7411 <writeBits>
    b124:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    b127:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    b12e:	eb 2c                	jmp    b15c <deflateDynamic+0x732>
    b130:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    b136:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b139:	8b 04 85 e0 f2 01 00 	mov    0x1f2e0(,%eax,4),%eax
    b140:	c1 e0 02             	shl    $0x2,%eax
    b143:	01 d0                	add    %edx,%eax
    b145:	8b 00                	mov    (%eax),%eax
    b147:	83 ec 04             	sub    $0x4,%esp
    b14a:	6a 03                	push   $0x3
    b14c:	50                   	push   %eax
    b14d:	ff 75 08             	pushl  0x8(%ebp)
    b150:	e8 bc c2 ff ff       	call   7411 <writeBits>
    b155:	83 c4 10             	add    $0x10,%esp
    b158:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    b15c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b15f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    b162:	75 cc                	jne    b130 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    b164:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    b16b:	e9 0a 01 00 00       	jmp    b27a <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    b170:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    b176:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b179:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    b180:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b183:	01 ca                	add    %ecx,%edx
    b185:	8b 12                	mov    (%edx),%edx
    b187:	c1 e2 02             	shl    $0x2,%edx
    b18a:	01 d0                	add    %edx,%eax
    b18c:	8b 00                	mov    (%eax),%eax
    b18e:	89 c3                	mov    %eax,%ebx
    b190:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    b196:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b199:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    b1a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b1a3:	01 ca                	add    %ecx,%edx
    b1a5:	8b 12                	mov    (%edx),%edx
    b1a7:	c1 e2 02             	shl    $0x2,%edx
    b1aa:	01 d0                	add    %edx,%eax
    b1ac:	8b 00                	mov    (%eax),%eax
    b1ae:	83 ec 04             	sub    $0x4,%esp
    b1b1:	53                   	push   %ebx
    b1b2:	50                   	push   %eax
    b1b3:	ff 75 08             	pushl  0x8(%ebp)
    b1b6:	e8 ea c3 ff ff       	call   75a5 <writeBitsReversed>
    b1bb:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    b1be:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b1c1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b1c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b1cb:	01 d0                	add    %edx,%eax
    b1cd:	8b 00                	mov    (%eax),%eax
    b1cf:	83 f8 10             	cmp    $0x10,%eax
    b1d2:	75 28                	jne    b1fc <deflateDynamic+0x7d2>
    b1d4:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    b1d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b1db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b1e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b1e5:	01 d0                	add    %edx,%eax
    b1e7:	8b 00                	mov    (%eax),%eax
    b1e9:	83 ec 04             	sub    $0x4,%esp
    b1ec:	6a 02                	push   $0x2
    b1ee:	50                   	push   %eax
    b1ef:	ff 75 08             	pushl  0x8(%ebp)
    b1f2:	e8 1a c2 ff ff       	call   7411 <writeBits>
    b1f7:	83 c4 10             	add    $0x10,%esp
    b1fa:	eb 7a                	jmp    b276 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    b1fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b1ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b206:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b209:	01 d0                	add    %edx,%eax
    b20b:	8b 00                	mov    (%eax),%eax
    b20d:	83 f8 11             	cmp    $0x11,%eax
    b210:	75 28                	jne    b23a <deflateDynamic+0x810>
    b212:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    b216:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b219:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b220:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b223:	01 d0                	add    %edx,%eax
    b225:	8b 00                	mov    (%eax),%eax
    b227:	83 ec 04             	sub    $0x4,%esp
    b22a:	6a 03                	push   $0x3
    b22c:	50                   	push   %eax
    b22d:	ff 75 08             	pushl  0x8(%ebp)
    b230:	e8 dc c1 ff ff       	call   7411 <writeBits>
    b235:	83 c4 10             	add    $0x10,%esp
    b238:	eb 3c                	jmp    b276 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    b23a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b23d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b244:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b247:	01 d0                	add    %edx,%eax
    b249:	8b 00                	mov    (%eax),%eax
    b24b:	83 f8 12             	cmp    $0x12,%eax
    b24e:	75 26                	jne    b276 <deflateDynamic+0x84c>
    b250:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    b254:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b257:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    b25e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b261:	01 d0                	add    %edx,%eax
    b263:	8b 00                	mov    (%eax),%eax
    b265:	83 ec 04             	sub    $0x4,%esp
    b268:	6a 07                	push   $0x7
    b26a:	50                   	push   %eax
    b26b:	ff 75 08             	pushl  0x8(%ebp)
    b26e:	e8 9e c1 ff ff       	call   7411 <writeBits>
    b273:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    b276:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    b27a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b27d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    b280:	0f 85 ea fe ff ff    	jne    b170 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    b286:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    b28c:	50                   	push   %eax
    b28d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    b293:	50                   	push   %eax
    b294:	8d 45 90             	lea    -0x70(%ebp),%eax
    b297:	50                   	push   %eax
    b298:	ff 75 08             	pushl  0x8(%ebp)
    b29b:	e8 4f f6 ff ff       	call   a8ef <writeLZ77data>
    b2a0:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    b2a3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    b2a9:	05 00 04 00 00       	add    $0x400,%eax
    b2ae:	8b 00                	mov    (%eax),%eax
    b2b0:	85 c0                	test   %eax,%eax
    b2b2:	75 09                	jne    b2bd <deflateDynamic+0x893>
    b2b4:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    b2bb:	eb 35                	jmp    b2f2 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    b2bd:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    b2c3:	05 00 04 00 00       	add    $0x400,%eax
    b2c8:	8b 00                	mov    (%eax),%eax
    b2ca:	89 c2                	mov    %eax,%edx
    b2cc:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    b2d2:	05 00 04 00 00       	add    $0x400,%eax
    b2d7:	8b 00                	mov    (%eax),%eax
    b2d9:	83 ec 04             	sub    $0x4,%esp
    b2dc:	52                   	push   %edx
    b2dd:	50                   	push   %eax
    b2de:	ff 75 08             	pushl  0x8(%ebp)
    b2e1:	e8 bf c2 ff ff       	call   75a5 <writeBitsReversed>
    b2e6:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    b2e9:	eb 07                	jmp    b2f2 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    b2eb:	90                   	nop
    b2ec:	eb 04                	jmp    b2f2 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    b2ee:	90                   	nop
    b2ef:	eb 01                	jmp    b2f2 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    b2f1:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    b2f2:	83 ec 0c             	sub    $0xc,%esp
    b2f5:	8d 45 90             	lea    -0x70(%ebp),%eax
    b2f8:	50                   	push   %eax
    b2f9:	e8 73 bd ff ff       	call   7071 <uivector_cleanup>
    b2fe:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    b301:	83 ec 0c             	sub    $0xc,%esp
    b304:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    b30a:	50                   	push   %eax
    b30b:	e8 3a cb ff ff       	call   7e4a <HuffmanTree_cleanup>
    b310:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    b313:	83 ec 0c             	sub    $0xc,%esp
    b316:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    b31c:	50                   	push   %eax
    b31d:	e8 28 cb ff ff       	call   7e4a <HuffmanTree_cleanup>
    b322:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    b325:	83 ec 0c             	sub    $0xc,%esp
    b328:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    b32e:	50                   	push   %eax
    b32f:	e8 16 cb ff ff       	call   7e4a <HuffmanTree_cleanup>
    b334:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    b337:	83 ec 0c             	sub    $0xc,%esp
    b33a:	ff 75 d4             	pushl  -0x2c(%ebp)
    b33d:	e8 08 bc ff ff       	call   6f4a <lodepng_free>
    b342:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    b345:	83 ec 0c             	sub    $0xc,%esp
    b348:	ff 75 d0             	pushl  -0x30(%ebp)
    b34b:	e8 fa bb ff ff       	call   6f4a <lodepng_free>
    b350:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    b353:	83 ec 0c             	sub    $0xc,%esp
    b356:	ff 75 cc             	pushl  -0x34(%ebp)
    b359:	e8 ec bb ff ff       	call   6f4a <lodepng_free>
    b35e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    b361:	83 ec 0c             	sub    $0xc,%esp
    b364:	ff 75 f0             	pushl  -0x10(%ebp)
    b367:	e8 de bb ff ff       	call   6f4a <lodepng_free>
    b36c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    b36f:	83 ec 0c             	sub    $0xc,%esp
    b372:	ff 75 ec             	pushl  -0x14(%ebp)
    b375:	e8 d0 bb ff ff       	call   6f4a <lodepng_free>
    b37a:	83 c4 10             	add    $0x10,%esp

  return error;
    b37d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    b380:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b383:	c9                   	leave  
    b384:	c3                   	ret    

0000b385 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    b385:	55                   	push   %ebp
    b386:	89 e5                	mov    %esp,%ebp
    b388:	53                   	push   %ebx
    b389:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    b38c:	8b 45 20             	mov    0x20(%ebp),%eax
    b38f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    b392:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    b399:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    b39c:	50                   	push   %eax
    b39d:	e8 7b ca ff ff       	call   7e1d <HuffmanTree_init>
    b3a2:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    b3a5:	8d 45 bc             	lea    -0x44(%ebp),%eax
    b3a8:	50                   	push   %eax
    b3a9:	e8 6f ca ff ff       	call   7e1d <HuffmanTree_init>
    b3ae:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    b3b1:	83 ec 0c             	sub    $0xc,%esp
    b3b4:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    b3b7:	50                   	push   %eax
    b3b8:	e8 41 db ff ff       	call   8efe <generateFixedLitLenTree>
    b3bd:	83 c4 10             	add    $0x10,%esp
    b3c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    b3c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b3c7:	75 12                	jne    b3db <deflateFixed+0x56>
    b3c9:	83 ec 0c             	sub    $0xc,%esp
    b3cc:	8d 45 bc             	lea    -0x44(%ebp),%eax
    b3cf:	50                   	push   %eax
    b3d0:	e8 30 dc ff ff       	call   9005 <generateFixedDistanceTree>
    b3d5:	83 c4 10             	add    $0x10,%esp
    b3d8:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    b3db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b3df:	0f 85 3a 01 00 00    	jne    b51f <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    b3e5:	83 ec 04             	sub    $0x4,%esp
    b3e8:	6a 01                	push   $0x1
    b3ea:	ff 75 ec             	pushl  -0x14(%ebp)
    b3ed:	ff 75 08             	pushl  0x8(%ebp)
    b3f0:	e8 1c c0 ff ff       	call   7411 <writeBits>
    b3f5:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    b3f8:	83 ec 04             	sub    $0x4,%esp
    b3fb:	6a 01                	push   $0x1
    b3fd:	6a 01                	push   $0x1
    b3ff:	ff 75 08             	pushl  0x8(%ebp)
    b402:	e8 0a c0 ff ff       	call   7411 <writeBits>
    b407:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    b40a:	83 ec 04             	sub    $0x4,%esp
    b40d:	6a 01                	push   $0x1
    b40f:	6a 00                	push   $0x0
    b411:	ff 75 08             	pushl  0x8(%ebp)
    b414:	e8 f8 bf ff ff       	call   7411 <writeBits>
    b419:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    b41c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b41f:	8b 40 04             	mov    0x4(%eax),%eax
    b422:	85 c0                	test   %eax,%eax
    b424:	74 77                	je     b49d <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    b426:	83 ec 0c             	sub    $0xc,%esp
    b429:	8d 45 b0             	lea    -0x50(%ebp),%eax
    b42c:	50                   	push   %eax
    b42d:	e8 e8 bc ff ff       	call   711a <uivector_init>
    b432:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    b435:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b438:	8b 58 14             	mov    0x14(%eax),%ebx
    b43b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b43e:	8b 48 10             	mov    0x10(%eax),%ecx
    b441:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b444:	8b 50 0c             	mov    0xc(%eax),%edx
    b447:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b44a:	8b 40 08             	mov    0x8(%eax),%eax
    b44d:	83 ec 0c             	sub    $0xc,%esp
    b450:	53                   	push   %ebx
    b451:	51                   	push   %ecx
    b452:	52                   	push   %edx
    b453:	50                   	push   %eax
    b454:	ff 75 18             	pushl  0x18(%ebp)
    b457:	ff 75 14             	pushl  0x14(%ebp)
    b45a:	ff 75 10             	pushl  0x10(%ebp)
    b45d:	ff 75 0c             	pushl  0xc(%ebp)
    b460:	8d 45 b0             	lea    -0x50(%ebp),%eax
    b463:	50                   	push   %eax
    b464:	e8 c7 ed ff ff       	call   a230 <encodeLZ77>
    b469:	83 c4 30             	add    $0x30,%esp
    b46c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    b46f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b473:	75 17                	jne    b48c <deflateFixed+0x107>
    b475:	8d 45 bc             	lea    -0x44(%ebp),%eax
    b478:	50                   	push   %eax
    b479:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    b47c:	50                   	push   %eax
    b47d:	8d 45 b0             	lea    -0x50(%ebp),%eax
    b480:	50                   	push   %eax
    b481:	ff 75 08             	pushl  0x8(%ebp)
    b484:	e8 66 f4 ff ff       	call   a8ef <writeLZ77data>
    b489:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    b48c:	83 ec 0c             	sub    $0xc,%esp
    b48f:	8d 45 b0             	lea    -0x50(%ebp),%eax
    b492:	50                   	push   %eax
    b493:	e8 d9 bb ff ff       	call   7071 <uivector_cleanup>
    b498:	83 c4 10             	add    $0x10,%esp
    b49b:	eb 56                	jmp    b4f3 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    b49d:	8b 45 14             	mov    0x14(%ebp),%eax
    b4a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    b4a3:	eb 46                	jmp    b4eb <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    b4a5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b4a8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    b4ab:	8b 55 10             	mov    0x10(%ebp),%edx
    b4ae:	01 ca                	add    %ecx,%edx
    b4b0:	0f b6 12             	movzbl (%edx),%edx
    b4b3:	0f b6 d2             	movzbl %dl,%edx
    b4b6:	c1 e2 02             	shl    $0x2,%edx
    b4b9:	01 d0                	add    %edx,%eax
    b4bb:	8b 00                	mov    (%eax),%eax
    b4bd:	89 c3                	mov    %eax,%ebx
    b4bf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    b4c2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    b4c5:	8b 55 10             	mov    0x10(%ebp),%edx
    b4c8:	01 ca                	add    %ecx,%edx
    b4ca:	0f b6 12             	movzbl (%edx),%edx
    b4cd:	0f b6 d2             	movzbl %dl,%edx
    b4d0:	c1 e2 02             	shl    $0x2,%edx
    b4d3:	01 d0                	add    %edx,%eax
    b4d5:	8b 00                	mov    (%eax),%eax
    b4d7:	83 ec 04             	sub    $0x4,%esp
    b4da:	53                   	push   %ebx
    b4db:	50                   	push   %eax
    b4dc:	ff 75 08             	pushl  0x8(%ebp)
    b4df:	e8 c1 c0 ff ff       	call   75a5 <writeBitsReversed>
    b4e4:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    b4e7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    b4eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b4ee:	3b 45 18             	cmp    0x18(%ebp),%eax
    b4f1:	7c b2                	jl     b4a5 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    b4f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b4f7:	75 26                	jne    b51f <deflateFixed+0x19a>
    b4f9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b4fc:	05 00 04 00 00       	add    $0x400,%eax
    b501:	8b 00                	mov    (%eax),%eax
    b503:	89 c2                	mov    %eax,%edx
    b505:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    b508:	05 00 04 00 00       	add    $0x400,%eax
    b50d:	8b 00                	mov    (%eax),%eax
    b50f:	83 ec 04             	sub    $0x4,%esp
    b512:	52                   	push   %edx
    b513:	50                   	push   %eax
    b514:	ff 75 08             	pushl  0x8(%ebp)
    b517:	e8 89 c0 ff ff       	call   75a5 <writeBitsReversed>
    b51c:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    b51f:	83 ec 0c             	sub    $0xc,%esp
    b522:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    b525:	50                   	push   %eax
    b526:	e8 1f c9 ff ff       	call   7e4a <HuffmanTree_cleanup>
    b52b:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    b52e:	83 ec 0c             	sub    $0xc,%esp
    b531:	8d 45 bc             	lea    -0x44(%ebp),%eax
    b534:	50                   	push   %eax
    b535:	e8 10 c9 ff ff       	call   7e4a <HuffmanTree_cleanup>
    b53a:	83 c4 10             	add    $0x10,%esp

  return error;
    b53d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    b540:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b543:	c9                   	leave  
    b544:	c3                   	ret    

0000b545 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    b545:	55                   	push   %ebp
    b546:	89 e5                	mov    %esp,%ebp
    b548:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    b54b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    b552:	ff 75 08             	pushl  0x8(%ebp)
    b555:	8d 45 bc             	lea    -0x44(%ebp),%eax
    b558:	50                   	push   %eax
    b559:	e8 9e be ff ff       	call   73fc <LodePNGBitWriter_init>
    b55e:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    b561:	8b 45 14             	mov    0x14(%ebp),%eax
    b564:	8b 00                	mov    (%eax),%eax
    b566:	83 f8 02             	cmp    $0x2,%eax
    b569:	76 0a                	jbe    b575 <lodepng_deflatev+0x30>
    b56b:	b8 3d 00 00 00       	mov    $0x3d,%eax
    b570:	e9 68 01 00 00       	jmp    b6dd <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    b575:	8b 45 14             	mov    0x14(%ebp),%eax
    b578:	8b 00                	mov    (%eax),%eax
    b57a:	85 c0                	test   %eax,%eax
    b57c:	75 16                	jne    b594 <lodepng_deflatev+0x4f>
    b57e:	ff 75 10             	pushl  0x10(%ebp)
    b581:	ff 75 0c             	pushl  0xc(%ebp)
    b584:	ff 75 08             	pushl  0x8(%ebp)
    b587:	e8 01 f2 ff ff       	call   a78d <deflateNoCompression>
    b58c:	83 c4 0c             	add    $0xc,%esp
    b58f:	e9 49 01 00 00       	jmp    b6dd <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    b594:	8b 45 14             	mov    0x14(%ebp),%eax
    b597:	8b 00                	mov    (%eax),%eax
    b599:	83 f8 01             	cmp    $0x1,%eax
    b59c:	75 08                	jne    b5a6 <lodepng_deflatev+0x61>
    b59e:	8b 45 10             	mov    0x10(%ebp),%eax
    b5a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    b5a4:	eb 2c                	jmp    b5d2 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    b5a6:	8b 45 10             	mov    0x10(%ebp),%eax
    b5a9:	c1 e8 03             	shr    $0x3,%eax
    b5ac:	83 c0 08             	add    $0x8,%eax
    b5af:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    b5b2:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    b5b9:	7f 07                	jg     b5c2 <lodepng_deflatev+0x7d>
    b5bb:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    b5c2:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    b5c9:	7e 07                	jle    b5d2 <lodepng_deflatev+0x8d>
    b5cb:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    b5d2:	8b 55 10             	mov    0x10(%ebp),%edx
    b5d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b5d8:	01 d0                	add    %edx,%eax
    b5da:	83 e8 01             	sub    $0x1,%eax
    b5dd:	99                   	cltd   
    b5de:	f7 7d ec             	idivl  -0x14(%ebp)
    b5e1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    b5e4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    b5e8:	75 07                	jne    b5f1 <lodepng_deflatev+0xac>
    b5ea:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    b5f1:	8b 45 14             	mov    0x14(%ebp),%eax
    b5f4:	8b 40 08             	mov    0x8(%eax),%eax
    b5f7:	83 ec 08             	sub    $0x8,%esp
    b5fa:	50                   	push   %eax
    b5fb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    b5fe:	50                   	push   %eax
    b5ff:	e8 1c e8 ff ff       	call   9e20 <hash_init>
    b604:	83 c4 10             	add    $0x10,%esp
    b607:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    b60a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b60e:	0f 85 b7 00 00 00    	jne    b6cb <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    b614:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    b61b:	e9 99 00 00 00       	jmp    b6b9 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    b620:	8b 45 e8             	mov    -0x18(%ebp),%eax
    b623:	83 e8 01             	sub    $0x1,%eax
    b626:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    b629:	0f 94 c0             	sete   %al
    b62c:	0f b6 c0             	movzbl %al,%eax
    b62f:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    b632:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b635:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    b639:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    b63c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    b63f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b642:	01 d0                	add    %edx,%eax
    b644:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    b647:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b64a:	3b 45 10             	cmp    0x10(%ebp),%eax
    b64d:	7e 06                	jle    b655 <lodepng_deflatev+0x110>
    b64f:	8b 45 10             	mov    0x10(%ebp),%eax
    b652:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    b655:	8b 45 14             	mov    0x14(%ebp),%eax
    b658:	8b 00                	mov    (%eax),%eax
    b65a:	83 f8 01             	cmp    $0x1,%eax
    b65d:	75 27                	jne    b686 <lodepng_deflatev+0x141>
    b65f:	83 ec 04             	sub    $0x4,%esp
    b662:	ff 75 e0             	pushl  -0x20(%ebp)
    b665:	ff 75 14             	pushl  0x14(%ebp)
    b668:	ff 75 e4             	pushl  -0x1c(%ebp)
    b66b:	ff 75 dc             	pushl  -0x24(%ebp)
    b66e:	ff 75 0c             	pushl  0xc(%ebp)
    b671:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    b674:	50                   	push   %eax
    b675:	8d 45 bc             	lea    -0x44(%ebp),%eax
    b678:	50                   	push   %eax
    b679:	e8 07 fd ff ff       	call   b385 <deflateFixed>
    b67e:	83 c4 20             	add    $0x20,%esp
    b681:	89 45 f4             	mov    %eax,-0xc(%ebp)
    b684:	eb 2f                	jmp    b6b5 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    b686:	8b 45 14             	mov    0x14(%ebp),%eax
    b689:	8b 00                	mov    (%eax),%eax
    b68b:	83 f8 02             	cmp    $0x2,%eax
    b68e:	75 25                	jne    b6b5 <lodepng_deflatev+0x170>
    b690:	83 ec 04             	sub    $0x4,%esp
    b693:	ff 75 e0             	pushl  -0x20(%ebp)
    b696:	ff 75 14             	pushl  0x14(%ebp)
    b699:	ff 75 e4             	pushl  -0x1c(%ebp)
    b69c:	ff 75 dc             	pushl  -0x24(%ebp)
    b69f:	ff 75 0c             	pushl  0xc(%ebp)
    b6a2:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    b6a5:	50                   	push   %eax
    b6a6:	8d 45 bc             	lea    -0x44(%ebp),%eax
    b6a9:	50                   	push   %eax
    b6aa:	e8 7b f3 ff ff       	call   aa2a <deflateDynamic>
    b6af:	83 c4 20             	add    $0x20,%esp
    b6b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    b6b5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    b6b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b6bc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    b6bf:	74 0a                	je     b6cb <lodepng_deflatev+0x186>
    b6c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b6c5:	0f 84 55 ff ff ff    	je     b620 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    b6cb:	83 ec 0c             	sub    $0xc,%esp
    b6ce:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    b6d1:	50                   	push   %eax
    b6d2:	e8 08 e9 ff ff       	call   9fdf <hash_cleanup>
    b6d7:	83 c4 10             	add    $0x10,%esp

  return error;
    b6da:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    b6dd:	c9                   	leave  
    b6de:	c3                   	ret    

0000b6df <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    b6df:	55                   	push   %ebp
    b6e0:	89 e5                	mov    %esp,%ebp
    b6e2:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    b6e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    b6e8:	8b 08                	mov    (%eax),%ecx
    b6ea:	8b 45 08             	mov    0x8(%ebp),%eax
    b6ed:	8b 10                	mov    (%eax),%edx
    b6ef:	8d 45 e8             	lea    -0x18(%ebp),%eax
    b6f2:	51                   	push   %ecx
    b6f3:	52                   	push   %edx
    b6f4:	50                   	push   %eax
    b6f5:	e8 f0 ba ff ff       	call   71ea <ucvector_init>
    b6fa:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    b6fd:	ff 75 18             	pushl  0x18(%ebp)
    b700:	ff 75 14             	pushl  0x14(%ebp)
    b703:	ff 75 10             	pushl  0x10(%ebp)
    b706:	8d 45 e8             	lea    -0x18(%ebp),%eax
    b709:	50                   	push   %eax
    b70a:	e8 36 fe ff ff       	call   b545 <lodepng_deflatev>
    b70f:	83 c4 10             	add    $0x10,%esp
    b712:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    b715:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b718:	8b 45 08             	mov    0x8(%ebp),%eax
    b71b:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    b71d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b720:	8b 45 0c             	mov    0xc(%ebp),%eax
    b723:	89 10                	mov    %edx,(%eax)
  return error;
    b725:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    b728:	c9                   	leave  
    b729:	c3                   	ret    

0000b72a <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    b72a:	55                   	push   %ebp
    b72b:	89 e5                	mov    %esp,%ebp
    b72d:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    b730:	8b 45 18             	mov    0x18(%ebp),%eax
    b733:	8b 40 1c             	mov    0x1c(%eax),%eax
    b736:	85 c0                	test   %eax,%eax
    b738:	74 34                	je     b76e <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    b73a:	8b 45 18             	mov    0x18(%ebp),%eax
    b73d:	8b 40 1c             	mov    0x1c(%eax),%eax
    b740:	83 ec 0c             	sub    $0xc,%esp
    b743:	ff 75 18             	pushl  0x18(%ebp)
    b746:	ff 75 14             	pushl  0x14(%ebp)
    b749:	ff 75 10             	pushl  0x10(%ebp)
    b74c:	ff 75 0c             	pushl  0xc(%ebp)
    b74f:	ff 75 08             	pushl  0x8(%ebp)
    b752:	ff d0                	call   *%eax
    b754:	83 c4 20             	add    $0x20,%esp
    b757:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    b75a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b75e:	74 07                	je     b767 <deflate+0x3d>
    b760:	b8 6f 00 00 00       	mov    $0x6f,%eax
    b765:	eb 21                	jmp    b788 <deflate+0x5e>
    b767:	b8 00 00 00 00       	mov    $0x0,%eax
    b76c:	eb 1a                	jmp    b788 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    b76e:	83 ec 0c             	sub    $0xc,%esp
    b771:	ff 75 18             	pushl  0x18(%ebp)
    b774:	ff 75 14             	pushl  0x14(%ebp)
    b777:	ff 75 10             	pushl  0x10(%ebp)
    b77a:	ff 75 0c             	pushl  0xc(%ebp)
    b77d:	ff 75 08             	pushl  0x8(%ebp)
    b780:	e8 5a ff ff ff       	call   b6df <lodepng_deflate>
    b785:	83 c4 20             	add    $0x20,%esp
  }
}
    b788:	c9                   	leave  
    b789:	c3                   	ret    

0000b78a <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    b78a:	55                   	push   %ebp
    b78b:	89 e5                	mov    %esp,%ebp
    b78d:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    b790:	8b 45 08             	mov    0x8(%ebp),%eax
    b793:	0f b7 c0             	movzwl %ax,%eax
    b796:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    b799:	8b 45 08             	mov    0x8(%ebp),%eax
    b79c:	c1 e8 10             	shr    $0x10,%eax
    b79f:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    b7a2:	e9 82 00 00 00       	jmp    b829 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    b7a7:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    b7ac:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    b7b3:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    b7b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    b7ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b7bd:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    b7c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    b7c7:	eb 1c                	jmp    b7e5 <update_adler32+0x5b>
      s1 += (*data++);
    b7c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    b7cc:	8d 50 01             	lea    0x1(%eax),%edx
    b7cf:	89 55 0c             	mov    %edx,0xc(%ebp)
    b7d2:	0f b6 00             	movzbl (%eax),%eax
    b7d5:	0f b6 c0             	movzbl %al,%eax
    b7d8:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    b7db:	8b 45 fc             	mov    -0x4(%ebp),%eax
    b7de:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    b7e1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    b7e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b7e8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    b7eb:	75 dc                	jne    b7c9 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    b7ed:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    b7f0:	ba 71 80 07 80       	mov    $0x80078071,%edx
    b7f5:	89 c8                	mov    %ecx,%eax
    b7f7:	f7 e2                	mul    %edx
    b7f9:	89 d0                	mov    %edx,%eax
    b7fb:	c1 e8 0f             	shr    $0xf,%eax
    b7fe:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    b804:	29 c1                	sub    %eax,%ecx
    b806:	89 c8                	mov    %ecx,%eax
    b808:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    b80b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b80e:	ba 71 80 07 80       	mov    $0x80078071,%edx
    b813:	89 c8                	mov    %ecx,%eax
    b815:	f7 e2                	mul    %edx
    b817:	89 d0                	mov    %edx,%eax
    b819:	c1 e8 0f             	shr    $0xf,%eax
    b81c:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    b822:	29 c1                	sub    %eax,%ecx
    b824:	89 c8                	mov    %ecx,%eax
    b826:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    b829:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    b82d:	0f 85 74 ff ff ff    	jne    b7a7 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    b833:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b836:	c1 e0 10             	shl    $0x10,%eax
    b839:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    b83c:	c9                   	leave  
    b83d:	c3                   	ret    

0000b83e <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    b83e:	55                   	push   %ebp
    b83f:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    b841:	ff 75 0c             	pushl  0xc(%ebp)
    b844:	ff 75 08             	pushl  0x8(%ebp)
    b847:	6a 01                	push   $0x1
    b849:	e8 3c ff ff ff       	call   b78a <update_adler32>
    b84e:	83 c4 0c             	add    $0xc,%esp
}
    b851:	c9                   	leave  
    b852:	c3                   	ret    

0000b853 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    b853:	55                   	push   %ebp
    b854:	89 e5                	mov    %esp,%ebp
    b856:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    b859:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    b860:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    b864:	7f 0a                	jg     b870 <lodepng_zlib_decompressv+0x1d>
    b866:	b8 35 00 00 00       	mov    $0x35,%eax
    b86b:	e9 27 01 00 00       	jmp    b997 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    b870:	8b 45 0c             	mov    0xc(%ebp),%eax
    b873:	0f b6 00             	movzbl (%eax),%eax
    b876:	0f b6 c0             	movzbl %al,%eax
    b879:	c1 e0 08             	shl    $0x8,%eax
    b87c:	89 c2                	mov    %eax,%edx
    b87e:	8b 45 0c             	mov    0xc(%ebp),%eax
    b881:	83 c0 01             	add    $0x1,%eax
    b884:	0f b6 00             	movzbl (%eax),%eax
    b887:	0f b6 c0             	movzbl %al,%eax
    b88a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    b88d:	ba 43 08 21 84       	mov    $0x84210843,%edx
    b892:	89 c8                	mov    %ecx,%eax
    b894:	f7 ea                	imul   %edx
    b896:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    b899:	c1 f8 04             	sar    $0x4,%eax
    b89c:	89 c2                	mov    %eax,%edx
    b89e:	89 c8                	mov    %ecx,%eax
    b8a0:	c1 f8 1f             	sar    $0x1f,%eax
    b8a3:	29 c2                	sub    %eax,%edx
    b8a5:	89 d0                	mov    %edx,%eax
    b8a7:	89 c2                	mov    %eax,%edx
    b8a9:	c1 e2 05             	shl    $0x5,%edx
    b8ac:	29 c2                	sub    %eax,%edx
    b8ae:	89 c8                	mov    %ecx,%eax
    b8b0:	29 d0                	sub    %edx,%eax
    b8b2:	85 c0                	test   %eax,%eax
    b8b4:	74 0a                	je     b8c0 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    b8b6:	b8 18 00 00 00       	mov    $0x18,%eax
    b8bb:	e9 d7 00 00 00       	jmp    b997 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    b8c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8c3:	0f b6 00             	movzbl (%eax),%eax
    b8c6:	0f b6 c0             	movzbl %al,%eax
    b8c9:	83 e0 0f             	and    $0xf,%eax
    b8cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    b8cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8d2:	0f b6 00             	movzbl (%eax),%eax
    b8d5:	c0 e8 04             	shr    $0x4,%al
    b8d8:	0f b6 c0             	movzbl %al,%eax
    b8db:	83 e0 0f             	and    $0xf,%eax
    b8de:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    b8e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8e4:	83 c0 01             	add    $0x1,%eax
    b8e7:	0f b6 00             	movzbl (%eax),%eax
    b8ea:	c0 e8 05             	shr    $0x5,%al
    b8ed:	0f b6 c0             	movzbl %al,%eax
    b8f0:	83 e0 01             	and    $0x1,%eax
    b8f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    b8f6:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    b8fa:	75 06                	jne    b902 <lodepng_zlib_decompressv+0xaf>
    b8fc:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    b900:	76 0a                	jbe    b90c <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    b902:	b8 19 00 00 00       	mov    $0x19,%eax
    b907:	e9 8b 00 00 00       	jmp    b997 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    b90c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    b910:	74 07                	je     b919 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    b912:	b8 1a 00 00 00       	mov    $0x1a,%eax
    b917:	eb 7e                	jmp    b997 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    b919:	8b 45 10             	mov    0x10(%ebp),%eax
    b91c:	8d 50 fe             	lea    -0x2(%eax),%edx
    b91f:	8b 45 0c             	mov    0xc(%ebp),%eax
    b922:	83 c0 02             	add    $0x2,%eax
    b925:	ff 75 14             	pushl  0x14(%ebp)
    b928:	52                   	push   %edx
    b929:	50                   	push   %eax
    b92a:	ff 75 08             	pushl  0x8(%ebp)
    b92d:	e8 09 e3 ff ff       	call   9c3b <inflatev>
    b932:	83 c4 10             	add    $0x10,%esp
    b935:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    b938:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    b93c:	74 05                	je     b943 <lodepng_zlib_decompressv+0xf0>
    b93e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b941:	eb 54                	jmp    b997 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    b943:	8b 45 14             	mov    0x14(%ebp),%eax
    b946:	8b 00                	mov    (%eax),%eax
    b948:	85 c0                	test   %eax,%eax
    b94a:	75 46                	jne    b992 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    b94c:	8b 45 10             	mov    0x10(%ebp),%eax
    b94f:	8d 50 fc             	lea    -0x4(%eax),%edx
    b952:	8b 45 0c             	mov    0xc(%ebp),%eax
    b955:	01 d0                	add    %edx,%eax
    b957:	83 ec 0c             	sub    $0xc,%esp
    b95a:	50                   	push   %eax
    b95b:	e8 47 b9 ff ff       	call   72a7 <lodepng_read32bitInt>
    b960:	83 c4 10             	add    $0x10,%esp
    b963:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    b966:	8b 45 08             	mov    0x8(%ebp),%eax
    b969:	8b 40 04             	mov    0x4(%eax),%eax
    b96c:	89 c2                	mov    %eax,%edx
    b96e:	8b 45 08             	mov    0x8(%ebp),%eax
    b971:	8b 00                	mov    (%eax),%eax
    b973:	83 ec 08             	sub    $0x8,%esp
    b976:	52                   	push   %edx
    b977:	50                   	push   %eax
    b978:	e8 c1 fe ff ff       	call   b83e <adler32>
    b97d:	83 c4 10             	add    $0x10,%esp
    b980:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    b983:	8b 45 e0             	mov    -0x20(%ebp),%eax
    b986:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    b989:	74 07                	je     b992 <lodepng_zlib_decompressv+0x13f>
    b98b:	b8 3a 00 00 00       	mov    $0x3a,%eax
    b990:	eb 05                	jmp    b997 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    b992:	b8 00 00 00 00       	mov    $0x0,%eax
}
    b997:	c9                   	leave  
    b998:	c3                   	ret    

0000b999 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    b999:	55                   	push   %ebp
    b99a:	89 e5                	mov    %esp,%ebp
    b99c:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    b99f:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9a2:	8b 08                	mov    (%eax),%ecx
    b9a4:	8b 45 08             	mov    0x8(%ebp),%eax
    b9a7:	8b 10                	mov    (%eax),%edx
    b9a9:	8d 45 e8             	lea    -0x18(%ebp),%eax
    b9ac:	51                   	push   %ecx
    b9ad:	52                   	push   %edx
    b9ae:	50                   	push   %eax
    b9af:	e8 36 b8 ff ff       	call   71ea <ucvector_init>
    b9b4:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    b9b7:	ff 75 18             	pushl  0x18(%ebp)
    b9ba:	ff 75 14             	pushl  0x14(%ebp)
    b9bd:	ff 75 10             	pushl  0x10(%ebp)
    b9c0:	8d 45 e8             	lea    -0x18(%ebp),%eax
    b9c3:	50                   	push   %eax
    b9c4:	e8 8a fe ff ff       	call   b853 <lodepng_zlib_decompressv>
    b9c9:	83 c4 10             	add    $0x10,%esp
    b9cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    b9cf:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b9d2:	8b 45 08             	mov    0x8(%ebp),%eax
    b9d5:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    b9d7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b9da:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9dd:	89 10                	mov    %edx,(%eax)
  return error;
    b9df:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    b9e2:	c9                   	leave  
    b9e3:	c3                   	ret    

0000b9e4 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    b9e4:	55                   	push   %ebp
    b9e5:	89 e5                	mov    %esp,%ebp
    b9e7:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    b9ea:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9ed:	8b 40 0c             	mov    0xc(%eax),%eax
    b9f0:	85 c0                	test   %eax,%eax
    b9f2:	74 57                	je     ba4b <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    b9f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9f7:	8b 40 0c             	mov    0xc(%eax),%eax
    b9fa:	83 ec 0c             	sub    $0xc,%esp
    b9fd:	ff 75 1c             	pushl  0x1c(%ebp)
    ba00:	ff 75 18             	pushl  0x18(%ebp)
    ba03:	ff 75 14             	pushl  0x14(%ebp)
    ba06:	ff 75 0c             	pushl  0xc(%ebp)
    ba09:	ff 75 08             	pushl  0x8(%ebp)
    ba0c:	ff d0                	call   *%eax
    ba0e:	83 c4 20             	add    $0x20,%esp
    ba11:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    ba14:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ba18:	0f 84 98 00 00 00    	je     bab6 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    ba1e:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    ba25:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba28:	8b 40 08             	mov    0x8(%eax),%eax
    ba2b:	85 c0                	test   %eax,%eax
    ba2d:	0f 84 83 00 00 00    	je     bab6 <zlib_decompress+0xd2>
    ba33:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba36:	8b 10                	mov    (%eax),%edx
    ba38:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba3b:	8b 40 08             	mov    0x8(%eax),%eax
    ba3e:	39 c2                	cmp    %eax,%edx
    ba40:	7e 74                	jle    bab6 <zlib_decompress+0xd2>
    ba42:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    ba49:	eb 6b                	jmp    bab6 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    ba4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba4e:	8b 08                	mov    (%eax),%ecx
    ba50:	8b 45 08             	mov    0x8(%ebp),%eax
    ba53:	8b 10                	mov    (%eax),%edx
    ba55:	8d 45 e8             	lea    -0x18(%ebp),%eax
    ba58:	83 ec 04             	sub    $0x4,%esp
    ba5b:	51                   	push   %ecx
    ba5c:	52                   	push   %edx
    ba5d:	50                   	push   %eax
    ba5e:	e8 87 b7 ff ff       	call   71ea <ucvector_init>
    ba63:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    ba66:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    ba6a:	74 22                	je     ba8e <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    ba6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba6f:	8b 10                	mov    (%eax),%edx
    ba71:	8b 45 10             	mov    0x10(%ebp),%eax
    ba74:	01 d0                	add    %edx,%eax
    ba76:	83 ec 08             	sub    $0x8,%esp
    ba79:	50                   	push   %eax
    ba7a:	8d 45 e8             	lea    -0x18(%ebp),%eax
    ba7d:	50                   	push   %eax
    ba7e:	e8 00 b7 ff ff       	call   7183 <ucvector_resize>
    ba83:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    ba86:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba89:	8b 00                	mov    (%eax),%eax
    ba8b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    ba8e:	ff 75 1c             	pushl  0x1c(%ebp)
    ba91:	ff 75 18             	pushl  0x18(%ebp)
    ba94:	ff 75 14             	pushl  0x14(%ebp)
    ba97:	8d 45 e8             	lea    -0x18(%ebp),%eax
    ba9a:	50                   	push   %eax
    ba9b:	e8 b3 fd ff ff       	call   b853 <lodepng_zlib_decompressv>
    baa0:	83 c4 10             	add    $0x10,%esp
    baa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    baa6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    baa9:	8b 45 08             	mov    0x8(%ebp),%eax
    baac:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    baae:	8b 55 ec             	mov    -0x14(%ebp),%edx
    bab1:	8b 45 0c             	mov    0xc(%ebp),%eax
    bab4:	89 10                	mov    %edx,(%eax)
  }
  return error;
    bab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    bab9:	c9                   	leave  
    baba:	c3                   	ret    

0000babb <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    babb:	55                   	push   %ebp
    babc:	89 e5                	mov    %esp,%ebp
    babe:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    bac1:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    bac8:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    bacf:	83 ec 0c             	sub    $0xc,%esp
    bad2:	ff 75 18             	pushl  0x18(%ebp)
    bad5:	ff 75 14             	pushl  0x14(%ebp)
    bad8:	ff 75 10             	pushl  0x10(%ebp)
    badb:	8d 45 d0             	lea    -0x30(%ebp),%eax
    bade:	50                   	push   %eax
    badf:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    bae2:	50                   	push   %eax
    bae3:	e8 42 fc ff ff       	call   b72a <deflate>
    bae8:	83 c4 20             	add    $0x20,%esp
    baeb:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    baee:	8b 45 08             	mov    0x8(%ebp),%eax
    baf1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    baf7:	8b 45 0c             	mov    0xc(%ebp),%eax
    bafa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    bb00:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bb04:	75 33                	jne    bb39 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    bb06:	8b 45 d0             	mov    -0x30(%ebp),%eax
    bb09:	8d 50 06             	lea    0x6(%eax),%edx
    bb0c:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb0f:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    bb11:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb14:	8b 00                	mov    (%eax),%eax
    bb16:	83 ec 0c             	sub    $0xc,%esp
    bb19:	50                   	push   %eax
    bb1a:	e8 0a b4 ff ff       	call   6f29 <lodepng_malloc>
    bb1f:	83 c4 10             	add    $0x10,%esp
    bb22:	89 c2                	mov    %eax,%edx
    bb24:	8b 45 08             	mov    0x8(%ebp),%eax
    bb27:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    bb29:	8b 45 08             	mov    0x8(%ebp),%eax
    bb2c:	8b 00                	mov    (%eax),%eax
    bb2e:	85 c0                	test   %eax,%eax
    bb30:	75 07                	jne    bb39 <lodepng_zlib_compress+0x7e>
    bb32:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    bb39:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bb3d:	0f 85 e2 00 00 00    	jne    bc25 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    bb43:	8b 45 14             	mov    0x14(%ebp),%eax
    bb46:	83 ec 08             	sub    $0x8,%esp
    bb49:	50                   	push   %eax
    bb4a:	ff 75 10             	pushl  0x10(%ebp)
    bb4d:	e8 ec fc ff ff       	call   b83e <adler32>
    bb52:	83 c4 10             	add    $0x10,%esp
    bb55:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    bb58:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    bb5f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    bb66:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    bb6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bb70:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    bb77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bb7a:	01 d0                	add    %edx,%eax
    bb7c:	8d 14 00             	lea    (%eax,%eax,1),%edx
    bb7f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    bb82:	01 d0                	add    %edx,%eax
    bb84:	c1 e0 05             	shl    $0x5,%eax
    bb87:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    bb8a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    bb8d:	ba 85 10 42 08       	mov    $0x8421085,%edx
    bb92:	89 c8                	mov    %ecx,%eax
    bb94:	f7 e2                	mul    %edx
    bb96:	89 c8                	mov    %ecx,%eax
    bb98:	29 d0                	sub    %edx,%eax
    bb9a:	d1 e8                	shr    %eax
    bb9c:	01 d0                	add    %edx,%eax
    bb9e:	c1 e8 04             	shr    $0x4,%eax
    bba1:	89 c2                	mov    %eax,%edx
    bba3:	c1 e2 05             	shl    $0x5,%edx
    bba6:	29 c2                	sub    %eax,%edx
    bba8:	89 c8                	mov    %ecx,%eax
    bbaa:	29 d0                	sub    %edx,%eax
    bbac:	ba 1f 00 00 00       	mov    $0x1f,%edx
    bbb1:	29 c2                	sub    %eax,%edx
    bbb3:	89 d0                	mov    %edx,%eax
    bbb5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    bbb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    bbbb:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    bbbe:	8b 45 08             	mov    0x8(%ebp),%eax
    bbc1:	8b 00                	mov    (%eax),%eax
    bbc3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    bbc6:	c1 ea 08             	shr    $0x8,%edx
    bbc9:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    bbcb:	8b 45 08             	mov    0x8(%ebp),%eax
    bbce:	8b 00                	mov    (%eax),%eax
    bbd0:	83 c0 01             	add    $0x1,%eax
    bbd3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    bbd6:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    bbd8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bbdf:	eb 1e                	jmp    bbff <lodepng_zlib_compress+0x144>
    bbe1:	8b 45 08             	mov    0x8(%ebp),%eax
    bbe4:	8b 00                	mov    (%eax),%eax
    bbe6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bbe9:	83 c2 02             	add    $0x2,%edx
    bbec:	01 c2                	add    %eax,%edx
    bbee:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    bbf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbf4:	01 c8                	add    %ecx,%eax
    bbf6:	0f b6 00             	movzbl (%eax),%eax
    bbf9:	88 02                	mov    %al,(%edx)
    bbfb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bbff:	8b 45 d0             	mov    -0x30(%ebp),%eax
    bc02:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    bc05:	75 da                	jne    bbe1 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    bc07:	8b 45 08             	mov    0x8(%ebp),%eax
    bc0a:	8b 10                	mov    (%eax),%edx
    bc0c:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc0f:	8b 00                	mov    (%eax),%eax
    bc11:	83 e8 04             	sub    $0x4,%eax
    bc14:	01 d0                	add    %edx,%eax
    bc16:	83 ec 08             	sub    $0x8,%esp
    bc19:	ff 75 ec             	pushl  -0x14(%ebp)
    bc1c:	50                   	push   %eax
    bc1d:	e8 c8 b6 ff ff       	call   72ea <lodepng_set32bitInt>
    bc22:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    bc25:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bc28:	83 ec 0c             	sub    $0xc,%esp
    bc2b:	50                   	push   %eax
    bc2c:	e8 19 b3 ff ff       	call   6f4a <lodepng_free>
    bc31:	83 c4 10             	add    $0x10,%esp
  return error;
    bc34:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bc37:	c9                   	leave  
    bc38:	c3                   	ret    

0000bc39 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    bc39:	55                   	push   %ebp
    bc3a:	89 e5                	mov    %esp,%ebp
    bc3c:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    bc3f:	8b 45 18             	mov    0x18(%ebp),%eax
    bc42:	8b 40 18             	mov    0x18(%eax),%eax
    bc45:	85 c0                	test   %eax,%eax
    bc47:	74 34                	je     bc7d <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    bc49:	8b 45 18             	mov    0x18(%ebp),%eax
    bc4c:	8b 40 18             	mov    0x18(%eax),%eax
    bc4f:	83 ec 0c             	sub    $0xc,%esp
    bc52:	ff 75 18             	pushl  0x18(%ebp)
    bc55:	ff 75 14             	pushl  0x14(%ebp)
    bc58:	ff 75 10             	pushl  0x10(%ebp)
    bc5b:	ff 75 0c             	pushl  0xc(%ebp)
    bc5e:	ff 75 08             	pushl  0x8(%ebp)
    bc61:	ff d0                	call   *%eax
    bc63:	83 c4 20             	add    $0x20,%esp
    bc66:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    bc69:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    bc6d:	74 07                	je     bc76 <zlib_compress+0x3d>
    bc6f:	b8 6f 00 00 00       	mov    $0x6f,%eax
    bc74:	eb 21                	jmp    bc97 <zlib_compress+0x5e>
    bc76:	b8 00 00 00 00       	mov    $0x0,%eax
    bc7b:	eb 1a                	jmp    bc97 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    bc7d:	83 ec 0c             	sub    $0xc,%esp
    bc80:	ff 75 18             	pushl  0x18(%ebp)
    bc83:	ff 75 14             	pushl  0x14(%ebp)
    bc86:	ff 75 10             	pushl  0x10(%ebp)
    bc89:	ff 75 0c             	pushl  0xc(%ebp)
    bc8c:	ff 75 08             	pushl  0x8(%ebp)
    bc8f:	e8 27 fe ff ff       	call   babb <lodepng_zlib_compress>
    bc94:	83 c4 20             	add    $0x20,%esp
  }
}
    bc97:	c9                   	leave  
    bc98:	c3                   	ret    

0000bc99 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    bc99:	55                   	push   %ebp
    bc9a:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    bc9c:	8b 45 08             	mov    0x8(%ebp),%eax
    bc9f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    bca5:	8b 45 08             	mov    0x8(%ebp),%eax
    bca8:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    bcaf:	8b 45 08             	mov    0x8(%ebp),%eax
    bcb2:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    bcb9:	8b 45 08             	mov    0x8(%ebp),%eax
    bcbc:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    bcc3:	8b 45 08             	mov    0x8(%ebp),%eax
    bcc6:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    bccd:	8b 45 08             	mov    0x8(%ebp),%eax
    bcd0:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    bcd7:	8b 45 08             	mov    0x8(%ebp),%eax
    bcda:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    bce1:	8b 45 08             	mov    0x8(%ebp),%eax
    bce4:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    bceb:	8b 45 08             	mov    0x8(%ebp),%eax
    bcee:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    bcf5:	90                   	nop
    bcf6:	5d                   	pop    %ebp
    bcf7:	c3                   	ret    

0000bcf8 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    bcf8:	55                   	push   %ebp
    bcf9:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    bcfb:	8b 45 08             	mov    0x8(%ebp),%eax
    bcfe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    bd04:	8b 45 08             	mov    0x8(%ebp),%eax
    bd07:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    bd0e:	8b 45 08             	mov    0x8(%ebp),%eax
    bd11:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    bd18:	8b 45 08             	mov    0x8(%ebp),%eax
    bd1b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    bd22:	8b 45 08             	mov    0x8(%ebp),%eax
    bd25:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    bd2c:	8b 45 08             	mov    0x8(%ebp),%eax
    bd2f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    bd36:	90                   	nop
    bd37:	5d                   	pop    %ebp
    bd38:	c3                   	ret    

0000bd39 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    bd39:	55                   	push   %ebp
    bd3a:	89 e5                	mov    %esp,%ebp
    bd3c:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    bd3f:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    bd46:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bd4d:	eb 2a                	jmp    bd79 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    bd4f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bd52:	8b 45 08             	mov    0x8(%ebp),%eax
    bd55:	01 d0                	add    %edx,%eax
    bd57:	0f b6 00             	movzbl (%eax),%eax
    bd5a:	0f b6 c0             	movzbl %al,%eax
    bd5d:	33 45 fc             	xor    -0x4(%ebp),%eax
    bd60:	0f b6 c0             	movzbl %al,%eax
    bd63:	8b 04 85 60 39 02 00 	mov    0x23960(,%eax,4),%eax
    bd6a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bd6d:	c1 ea 08             	shr    $0x8,%edx
    bd70:	31 d0                	xor    %edx,%eax
    bd72:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    bd75:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bd79:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bd7c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    bd7f:	7c ce                	jl     bd4f <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    bd81:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bd84:	f7 d0                	not    %eax
}
    bd86:	c9                   	leave  
    bd87:	c3                   	ret    

0000bd88 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    bd88:	55                   	push   %ebp
    bd89:	89 e5                	mov    %esp,%ebp
    bd8b:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    bd8e:	8b 45 08             	mov    0x8(%ebp),%eax
    bd91:	8b 00                	mov    (%eax),%eax
    bd93:	c1 f8 03             	sar    $0x3,%eax
    bd96:	89 c2                	mov    %eax,%edx
    bd98:	8b 45 0c             	mov    0xc(%ebp),%eax
    bd9b:	01 d0                	add    %edx,%eax
    bd9d:	0f b6 00             	movzbl (%eax),%eax
    bda0:	0f b6 d0             	movzbl %al,%edx
    bda3:	8b 45 08             	mov    0x8(%ebp),%eax
    bda6:	8b 00                	mov    (%eax),%eax
    bda8:	f7 d0                	not    %eax
    bdaa:	83 e0 07             	and    $0x7,%eax
    bdad:	89 c1                	mov    %eax,%ecx
    bdaf:	d3 fa                	sar    %cl,%edx
    bdb1:	89 d0                	mov    %edx,%eax
    bdb3:	83 e0 01             	and    $0x1,%eax
    bdb6:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    bdb9:	8b 45 08             	mov    0x8(%ebp),%eax
    bdbc:	8b 00                	mov    (%eax),%eax
    bdbe:	8d 50 01             	lea    0x1(%eax),%edx
    bdc1:	8b 45 08             	mov    0x8(%ebp),%eax
    bdc4:	89 10                	mov    %edx,(%eax)
  return result;
    bdc6:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    bdca:	c9                   	leave  
    bdcb:	c3                   	ret    

0000bdcc <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    bdcc:	55                   	push   %ebp
    bdcd:	89 e5                	mov    %esp,%ebp
    bdcf:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    bdd2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    bdd9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bde0:	eb 1b                	jmp    bdfd <readBitsFromReversedStream+0x31>
    result <<= 1u;
    bde2:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    bde5:	ff 75 0c             	pushl  0xc(%ebp)
    bde8:	ff 75 08             	pushl  0x8(%ebp)
    bdeb:	e8 98 ff ff ff       	call   bd88 <readBitFromReversedStream>
    bdf0:	83 c4 08             	add    $0x8,%esp
    bdf3:	0f b6 c0             	movzbl %al,%eax
    bdf6:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    bdf9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    bdfd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    be00:	3b 45 10             	cmp    0x10(%ebp),%eax
    be03:	7c dd                	jl     bde2 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    be05:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    be08:	c9                   	leave  
    be09:	c3                   	ret    

0000be0a <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    be0a:	55                   	push   %ebp
    be0b:	89 e5                	mov    %esp,%ebp
    be0d:	56                   	push   %esi
    be0e:	53                   	push   %ebx
    be0f:	83 ec 04             	sub    $0x4,%esp
    be12:	8b 45 10             	mov    0x10(%ebp),%eax
    be15:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    be18:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    be1c:	75 3e                	jne    be5c <setBitOfReversedStream+0x52>
    be1e:	8b 45 08             	mov    0x8(%ebp),%eax
    be21:	8b 00                	mov    (%eax),%eax
    be23:	c1 f8 03             	sar    $0x3,%eax
    be26:	89 c2                	mov    %eax,%edx
    be28:	8b 45 0c             	mov    0xc(%ebp),%eax
    be2b:	01 c2                	add    %eax,%edx
    be2d:	8b 45 08             	mov    0x8(%ebp),%eax
    be30:	8b 00                	mov    (%eax),%eax
    be32:	c1 f8 03             	sar    $0x3,%eax
    be35:	89 c1                	mov    %eax,%ecx
    be37:	8b 45 0c             	mov    0xc(%ebp),%eax
    be3a:	01 c8                	add    %ecx,%eax
    be3c:	0f b6 18             	movzbl (%eax),%ebx
    be3f:	8b 45 08             	mov    0x8(%ebp),%eax
    be42:	8b 00                	mov    (%eax),%eax
    be44:	f7 d0                	not    %eax
    be46:	83 e0 07             	and    $0x7,%eax
    be49:	be 01 00 00 00       	mov    $0x1,%esi
    be4e:	89 c1                	mov    %eax,%ecx
    be50:	d3 e6                	shl    %cl,%esi
    be52:	89 f0                	mov    %esi,%eax
    be54:	f7 d0                	not    %eax
    be56:	21 d8                	and    %ebx,%eax
    be58:	88 02                	mov    %al,(%edx)
    be5a:	eb 3a                	jmp    be96 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    be5c:	8b 45 08             	mov    0x8(%ebp),%eax
    be5f:	8b 00                	mov    (%eax),%eax
    be61:	c1 f8 03             	sar    $0x3,%eax
    be64:	89 c2                	mov    %eax,%edx
    be66:	8b 45 0c             	mov    0xc(%ebp),%eax
    be69:	01 c2                	add    %eax,%edx
    be6b:	8b 45 08             	mov    0x8(%ebp),%eax
    be6e:	8b 00                	mov    (%eax),%eax
    be70:	c1 f8 03             	sar    $0x3,%eax
    be73:	89 c1                	mov    %eax,%ecx
    be75:	8b 45 0c             	mov    0xc(%ebp),%eax
    be78:	01 c8                	add    %ecx,%eax
    be7a:	0f b6 18             	movzbl (%eax),%ebx
    be7d:	8b 45 08             	mov    0x8(%ebp),%eax
    be80:	8b 00                	mov    (%eax),%eax
    be82:	f7 d0                	not    %eax
    be84:	83 e0 07             	and    $0x7,%eax
    be87:	be 01 00 00 00       	mov    $0x1,%esi
    be8c:	89 c1                	mov    %eax,%ecx
    be8e:	d3 e6                	shl    %cl,%esi
    be90:	89 f0                	mov    %esi,%eax
    be92:	09 d8                	or     %ebx,%eax
    be94:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    be96:	8b 45 08             	mov    0x8(%ebp),%eax
    be99:	8b 00                	mov    (%eax),%eax
    be9b:	8d 50 01             	lea    0x1(%eax),%edx
    be9e:	8b 45 08             	mov    0x8(%ebp),%eax
    bea1:	89 10                	mov    %edx,(%eax)
}
    bea3:	90                   	nop
    bea4:	83 c4 04             	add    $0x4,%esp
    bea7:	5b                   	pop    %ebx
    bea8:	5e                   	pop    %esi
    bea9:	5d                   	pop    %ebp
    beaa:	c3                   	ret    

0000beab <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    beab:	55                   	push   %ebp
    beac:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    beae:	ff 75 08             	pushl  0x8(%ebp)
    beb1:	e8 f1 b3 ff ff       	call   72a7 <lodepng_read32bitInt>
    beb6:	83 c4 04             	add    $0x4,%esp
}
    beb9:	c9                   	leave  
    beba:	c3                   	ret    

0000bebb <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    bebb:	55                   	push   %ebp
    bebc:	89 e5                	mov    %esp,%ebp
    bebe:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    bec1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    bec8:	eb 1c                	jmp    bee6 <lodepng_chunk_type+0x2b>
    beca:	8b 55 08             	mov    0x8(%ebp),%edx
    becd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bed0:	01 d0                	add    %edx,%eax
    bed2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bed5:	8d 4a 04             	lea    0x4(%edx),%ecx
    bed8:	8b 55 0c             	mov    0xc(%ebp),%edx
    bedb:	01 ca                	add    %ecx,%edx
    bedd:	0f b6 12             	movzbl (%edx),%edx
    bee0:	88 10                	mov    %dl,(%eax)
    bee2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    bee6:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    beea:	75 de                	jne    beca <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    beec:	8b 45 08             	mov    0x8(%ebp),%eax
    beef:	83 c0 04             	add    $0x4,%eax
    bef2:	c6 00 00             	movb   $0x0,(%eax)
}
    bef5:	90                   	nop
    bef6:	c9                   	leave  
    bef7:	c3                   	ret    

0000bef8 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    bef8:	55                   	push   %ebp
    bef9:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    befb:	ff 75 0c             	pushl  0xc(%ebp)
    befe:	e8 c2 b0 ff ff       	call   6fc5 <lodepng_strlen>
    bf03:	83 c4 04             	add    $0x4,%esp
    bf06:	83 f8 04             	cmp    $0x4,%eax
    bf09:	74 07                	je     bf12 <lodepng_chunk_type_equals+0x1a>
    bf0b:	b8 00 00 00 00       	mov    $0x0,%eax
    bf10:	eb 79                	jmp    bf8b <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    bf12:	8b 45 08             	mov    0x8(%ebp),%eax
    bf15:	83 c0 04             	add    $0x4,%eax
    bf18:	0f b6 00             	movzbl (%eax),%eax
    bf1b:	0f b6 d0             	movzbl %al,%edx
    bf1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf21:	0f b6 00             	movzbl (%eax),%eax
    bf24:	0f be c0             	movsbl %al,%eax
    bf27:	39 c2                	cmp    %eax,%edx
    bf29:	75 5b                	jne    bf86 <lodepng_chunk_type_equals+0x8e>
    bf2b:	8b 45 08             	mov    0x8(%ebp),%eax
    bf2e:	83 c0 05             	add    $0x5,%eax
    bf31:	0f b6 00             	movzbl (%eax),%eax
    bf34:	0f b6 d0             	movzbl %al,%edx
    bf37:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf3a:	83 c0 01             	add    $0x1,%eax
    bf3d:	0f b6 00             	movzbl (%eax),%eax
    bf40:	0f be c0             	movsbl %al,%eax
    bf43:	39 c2                	cmp    %eax,%edx
    bf45:	75 3f                	jne    bf86 <lodepng_chunk_type_equals+0x8e>
    bf47:	8b 45 08             	mov    0x8(%ebp),%eax
    bf4a:	83 c0 06             	add    $0x6,%eax
    bf4d:	0f b6 00             	movzbl (%eax),%eax
    bf50:	0f b6 d0             	movzbl %al,%edx
    bf53:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf56:	83 c0 02             	add    $0x2,%eax
    bf59:	0f b6 00             	movzbl (%eax),%eax
    bf5c:	0f be c0             	movsbl %al,%eax
    bf5f:	39 c2                	cmp    %eax,%edx
    bf61:	75 23                	jne    bf86 <lodepng_chunk_type_equals+0x8e>
    bf63:	8b 45 08             	mov    0x8(%ebp),%eax
    bf66:	83 c0 07             	add    $0x7,%eax
    bf69:	0f b6 00             	movzbl (%eax),%eax
    bf6c:	0f b6 d0             	movzbl %al,%edx
    bf6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf72:	83 c0 03             	add    $0x3,%eax
    bf75:	0f b6 00             	movzbl (%eax),%eax
    bf78:	0f be c0             	movsbl %al,%eax
    bf7b:	39 c2                	cmp    %eax,%edx
    bf7d:	75 07                	jne    bf86 <lodepng_chunk_type_equals+0x8e>
    bf7f:	b8 01 00 00 00       	mov    $0x1,%eax
    bf84:	eb 05                	jmp    bf8b <lodepng_chunk_type_equals+0x93>
    bf86:	b8 00 00 00 00       	mov    $0x0,%eax
}
    bf8b:	c9                   	leave  
    bf8c:	c3                   	ret    

0000bf8d <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    bf8d:	55                   	push   %ebp
    bf8e:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    bf90:	8b 45 08             	mov    0x8(%ebp),%eax
    bf93:	83 c0 04             	add    $0x4,%eax
    bf96:	0f b6 00             	movzbl (%eax),%eax
    bf99:	0f b6 c0             	movzbl %al,%eax
    bf9c:	83 e0 20             	and    $0x20,%eax
    bf9f:	85 c0                	test   %eax,%eax
    bfa1:	0f 95 c0             	setne  %al
}
    bfa4:	5d                   	pop    %ebp
    bfa5:	c3                   	ret    

0000bfa6 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    bfa6:	55                   	push   %ebp
    bfa7:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    bfa9:	8b 45 08             	mov    0x8(%ebp),%eax
    bfac:	83 c0 06             	add    $0x6,%eax
    bfaf:	0f b6 00             	movzbl (%eax),%eax
    bfb2:	0f b6 c0             	movzbl %al,%eax
    bfb5:	83 e0 20             	and    $0x20,%eax
    bfb8:	85 c0                	test   %eax,%eax
    bfba:	0f 95 c0             	setne  %al
}
    bfbd:	5d                   	pop    %ebp
    bfbe:	c3                   	ret    

0000bfbf <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    bfbf:	55                   	push   %ebp
    bfc0:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    bfc2:	8b 45 08             	mov    0x8(%ebp),%eax
    bfc5:	83 c0 07             	add    $0x7,%eax
    bfc8:	0f b6 00             	movzbl (%eax),%eax
    bfcb:	0f b6 c0             	movzbl %al,%eax
    bfce:	83 e0 20             	and    $0x20,%eax
    bfd1:	85 c0                	test   %eax,%eax
    bfd3:	0f 95 c0             	setne  %al
}
    bfd6:	5d                   	pop    %ebp
    bfd7:	c3                   	ret    

0000bfd8 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    bfd8:	55                   	push   %ebp
    bfd9:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    bfdb:	8b 45 08             	mov    0x8(%ebp),%eax
    bfde:	83 c0 08             	add    $0x8,%eax
}
    bfe1:	5d                   	pop    %ebp
    bfe2:	c3                   	ret    

0000bfe3 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    bfe3:	55                   	push   %ebp
    bfe4:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    bfe6:	8b 45 08             	mov    0x8(%ebp),%eax
    bfe9:	83 c0 08             	add    $0x8,%eax
}
    bfec:	5d                   	pop    %ebp
    bfed:	c3                   	ret    

0000bfee <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    bfee:	55                   	push   %ebp
    bfef:	89 e5                	mov    %esp,%ebp
    bff1:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    bff4:	ff 75 08             	pushl  0x8(%ebp)
    bff7:	e8 af fe ff ff       	call   beab <lodepng_chunk_length>
    bffc:	83 c4 04             	add    $0x4,%esp
    bfff:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    c002:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c005:	8d 50 08             	lea    0x8(%eax),%edx
    c008:	8b 45 08             	mov    0x8(%ebp),%eax
    c00b:	01 d0                	add    %edx,%eax
    c00d:	50                   	push   %eax
    c00e:	e8 94 b2 ff ff       	call   72a7 <lodepng_read32bitInt>
    c013:	83 c4 04             	add    $0x4,%esp
    c016:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    c019:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c01c:	83 c0 04             	add    $0x4,%eax
    c01f:	89 c2                	mov    %eax,%edx
    c021:	8b 45 08             	mov    0x8(%ebp),%eax
    c024:	83 c0 04             	add    $0x4,%eax
    c027:	52                   	push   %edx
    c028:	50                   	push   %eax
    c029:	e8 0b fd ff ff       	call   bd39 <lodepng_crc32>
    c02e:	83 c4 08             	add    $0x8,%esp
    c031:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    c034:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c037:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    c03a:	74 07                	je     c043 <lodepng_chunk_check_crc+0x55>
    c03c:	b8 01 00 00 00       	mov    $0x1,%eax
    c041:	eb 05                	jmp    c048 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    c043:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c048:	c9                   	leave  
    c049:	c3                   	ret    

0000c04a <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    c04a:	55                   	push   %ebp
    c04b:	89 e5                	mov    %esp,%ebp
    c04d:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    c050:	ff 75 08             	pushl  0x8(%ebp)
    c053:	e8 53 fe ff ff       	call   beab <lodepng_chunk_length>
    c058:	83 c4 04             	add    $0x4,%esp
    c05b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    c05e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c061:	83 c0 04             	add    $0x4,%eax
    c064:	89 c2                	mov    %eax,%edx
    c066:	8b 45 08             	mov    0x8(%ebp),%eax
    c069:	83 c0 04             	add    $0x4,%eax
    c06c:	52                   	push   %edx
    c06d:	50                   	push   %eax
    c06e:	e8 c6 fc ff ff       	call   bd39 <lodepng_crc32>
    c073:	83 c4 08             	add    $0x8,%esp
    c076:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    c079:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c07c:	8d 50 08             	lea    0x8(%eax),%edx
    c07f:	8b 45 08             	mov    0x8(%ebp),%eax
    c082:	01 d0                	add    %edx,%eax
    c084:	ff 75 f8             	pushl  -0x8(%ebp)
    c087:	50                   	push   %eax
    c088:	e8 5d b2 ff ff       	call   72ea <lodepng_set32bitInt>
    c08d:	83 c4 08             	add    $0x8,%esp
}
    c090:	90                   	nop
    c091:	c9                   	leave  
    c092:	c3                   	ret    

0000c093 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    c093:	55                   	push   %ebp
    c094:	89 e5                	mov    %esp,%ebp
    c096:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    c099:	8b 45 08             	mov    0x8(%ebp),%eax
    c09c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c09f:	73 0f                	jae    c0b0 <lodepng_chunk_next+0x1d>
    c0a1:	8b 55 0c             	mov    0xc(%ebp),%edx
    c0a4:	8b 45 08             	mov    0x8(%ebp),%eax
    c0a7:	29 c2                	sub    %eax,%edx
    c0a9:	89 d0                	mov    %edx,%eax
    c0ab:	83 f8 0b             	cmp    $0xb,%eax
    c0ae:	7f 08                	jg     c0b8 <lodepng_chunk_next+0x25>
    c0b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    c0b3:	e9 af 00 00 00       	jmp    c167 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    c0b8:	8b 45 08             	mov    0x8(%ebp),%eax
    c0bb:	0f b6 00             	movzbl (%eax),%eax
    c0be:	3c 89                	cmp    $0x89,%al
    c0c0:	75 63                	jne    c125 <lodepng_chunk_next+0x92>
    c0c2:	8b 45 08             	mov    0x8(%ebp),%eax
    c0c5:	83 c0 01             	add    $0x1,%eax
    c0c8:	0f b6 00             	movzbl (%eax),%eax
    c0cb:	3c 50                	cmp    $0x50,%al
    c0cd:	75 56                	jne    c125 <lodepng_chunk_next+0x92>
    c0cf:	8b 45 08             	mov    0x8(%ebp),%eax
    c0d2:	83 c0 02             	add    $0x2,%eax
    c0d5:	0f b6 00             	movzbl (%eax),%eax
    c0d8:	3c 4e                	cmp    $0x4e,%al
    c0da:	75 49                	jne    c125 <lodepng_chunk_next+0x92>
    c0dc:	8b 45 08             	mov    0x8(%ebp),%eax
    c0df:	83 c0 03             	add    $0x3,%eax
    c0e2:	0f b6 00             	movzbl (%eax),%eax
    c0e5:	3c 47                	cmp    $0x47,%al
    c0e7:	75 3c                	jne    c125 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    c0e9:	8b 45 08             	mov    0x8(%ebp),%eax
    c0ec:	83 c0 04             	add    $0x4,%eax
    c0ef:	0f b6 00             	movzbl (%eax),%eax
    c0f2:	3c 0d                	cmp    $0xd,%al
    c0f4:	75 2f                	jne    c125 <lodepng_chunk_next+0x92>
    c0f6:	8b 45 08             	mov    0x8(%ebp),%eax
    c0f9:	83 c0 05             	add    $0x5,%eax
    c0fc:	0f b6 00             	movzbl (%eax),%eax
    c0ff:	3c 0a                	cmp    $0xa,%al
    c101:	75 22                	jne    c125 <lodepng_chunk_next+0x92>
    c103:	8b 45 08             	mov    0x8(%ebp),%eax
    c106:	83 c0 06             	add    $0x6,%eax
    c109:	0f b6 00             	movzbl (%eax),%eax
    c10c:	3c 1a                	cmp    $0x1a,%al
    c10e:	75 15                	jne    c125 <lodepng_chunk_next+0x92>
    c110:	8b 45 08             	mov    0x8(%ebp),%eax
    c113:	83 c0 07             	add    $0x7,%eax
    c116:	0f b6 00             	movzbl (%eax),%eax
    c119:	3c 0a                	cmp    $0xa,%al
    c11b:	75 08                	jne    c125 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    c11d:	8b 45 08             	mov    0x8(%ebp),%eax
    c120:	83 c0 08             	add    $0x8,%eax
    c123:	eb 42                	jmp    c167 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    c125:	ff 75 08             	pushl  0x8(%ebp)
    c128:	e8 7e fd ff ff       	call   beab <lodepng_chunk_length>
    c12d:	83 c4 04             	add    $0x4,%esp
    c130:	89 c2                	mov    %eax,%edx
    c132:	8d 45 f8             	lea    -0x8(%ebp),%eax
    c135:	50                   	push   %eax
    c136:	6a 0c                	push   $0xc
    c138:	52                   	push   %edx
    c139:	e8 af ae ff ff       	call   6fed <lodepng_addofl>
    c13e:	83 c4 0c             	add    $0xc,%esp
    c141:	85 c0                	test   %eax,%eax
    c143:	74 05                	je     c14a <lodepng_chunk_next+0xb7>
    c145:	8b 45 0c             	mov    0xc(%ebp),%eax
    c148:	eb 1d                	jmp    c167 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    c14a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c14d:	89 c2                	mov    %eax,%edx
    c14f:	8b 45 08             	mov    0x8(%ebp),%eax
    c152:	01 d0                	add    %edx,%eax
    c154:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    c157:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c15a:	3b 45 08             	cmp    0x8(%ebp),%eax
    c15d:	73 05                	jae    c164 <lodepng_chunk_next+0xd1>
    c15f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c162:	eb 03                	jmp    c167 <lodepng_chunk_next+0xd4>
    return result;
    c164:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    c167:	c9                   	leave  
    c168:	c3                   	ret    

0000c169 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    c169:	55                   	push   %ebp
    c16a:	89 e5                	mov    %esp,%ebp
    c16c:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    c16f:	8b 45 08             	mov    0x8(%ebp),%eax
    c172:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c175:	73 0f                	jae    c186 <lodepng_chunk_next_const+0x1d>
    c177:	8b 55 0c             	mov    0xc(%ebp),%edx
    c17a:	8b 45 08             	mov    0x8(%ebp),%eax
    c17d:	29 c2                	sub    %eax,%edx
    c17f:	89 d0                	mov    %edx,%eax
    c181:	83 f8 0b             	cmp    $0xb,%eax
    c184:	7f 08                	jg     c18e <lodepng_chunk_next_const+0x25>
    c186:	8b 45 0c             	mov    0xc(%ebp),%eax
    c189:	e9 af 00 00 00       	jmp    c23d <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    c18e:	8b 45 08             	mov    0x8(%ebp),%eax
    c191:	0f b6 00             	movzbl (%eax),%eax
    c194:	3c 89                	cmp    $0x89,%al
    c196:	75 63                	jne    c1fb <lodepng_chunk_next_const+0x92>
    c198:	8b 45 08             	mov    0x8(%ebp),%eax
    c19b:	83 c0 01             	add    $0x1,%eax
    c19e:	0f b6 00             	movzbl (%eax),%eax
    c1a1:	3c 50                	cmp    $0x50,%al
    c1a3:	75 56                	jne    c1fb <lodepng_chunk_next_const+0x92>
    c1a5:	8b 45 08             	mov    0x8(%ebp),%eax
    c1a8:	83 c0 02             	add    $0x2,%eax
    c1ab:	0f b6 00             	movzbl (%eax),%eax
    c1ae:	3c 4e                	cmp    $0x4e,%al
    c1b0:	75 49                	jne    c1fb <lodepng_chunk_next_const+0x92>
    c1b2:	8b 45 08             	mov    0x8(%ebp),%eax
    c1b5:	83 c0 03             	add    $0x3,%eax
    c1b8:	0f b6 00             	movzbl (%eax),%eax
    c1bb:	3c 47                	cmp    $0x47,%al
    c1bd:	75 3c                	jne    c1fb <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    c1bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c1c2:	83 c0 04             	add    $0x4,%eax
    c1c5:	0f b6 00             	movzbl (%eax),%eax
    c1c8:	3c 0d                	cmp    $0xd,%al
    c1ca:	75 2f                	jne    c1fb <lodepng_chunk_next_const+0x92>
    c1cc:	8b 45 08             	mov    0x8(%ebp),%eax
    c1cf:	83 c0 05             	add    $0x5,%eax
    c1d2:	0f b6 00             	movzbl (%eax),%eax
    c1d5:	3c 0a                	cmp    $0xa,%al
    c1d7:	75 22                	jne    c1fb <lodepng_chunk_next_const+0x92>
    c1d9:	8b 45 08             	mov    0x8(%ebp),%eax
    c1dc:	83 c0 06             	add    $0x6,%eax
    c1df:	0f b6 00             	movzbl (%eax),%eax
    c1e2:	3c 1a                	cmp    $0x1a,%al
    c1e4:	75 15                	jne    c1fb <lodepng_chunk_next_const+0x92>
    c1e6:	8b 45 08             	mov    0x8(%ebp),%eax
    c1e9:	83 c0 07             	add    $0x7,%eax
    c1ec:	0f b6 00             	movzbl (%eax),%eax
    c1ef:	3c 0a                	cmp    $0xa,%al
    c1f1:	75 08                	jne    c1fb <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    c1f3:	8b 45 08             	mov    0x8(%ebp),%eax
    c1f6:	83 c0 08             	add    $0x8,%eax
    c1f9:	eb 42                	jmp    c23d <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    c1fb:	ff 75 08             	pushl  0x8(%ebp)
    c1fe:	e8 a8 fc ff ff       	call   beab <lodepng_chunk_length>
    c203:	83 c4 04             	add    $0x4,%esp
    c206:	89 c2                	mov    %eax,%edx
    c208:	8d 45 f8             	lea    -0x8(%ebp),%eax
    c20b:	50                   	push   %eax
    c20c:	6a 0c                	push   $0xc
    c20e:	52                   	push   %edx
    c20f:	e8 d9 ad ff ff       	call   6fed <lodepng_addofl>
    c214:	83 c4 0c             	add    $0xc,%esp
    c217:	85 c0                	test   %eax,%eax
    c219:	74 05                	je     c220 <lodepng_chunk_next_const+0xb7>
    c21b:	8b 45 0c             	mov    0xc(%ebp),%eax
    c21e:	eb 1d                	jmp    c23d <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    c220:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c223:	89 c2                	mov    %eax,%edx
    c225:	8b 45 08             	mov    0x8(%ebp),%eax
    c228:	01 d0                	add    %edx,%eax
    c22a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    c22d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c230:	3b 45 08             	cmp    0x8(%ebp),%eax
    c233:	73 05                	jae    c23a <lodepng_chunk_next_const+0xd1>
    c235:	8b 45 0c             	mov    0xc(%ebp),%eax
    c238:	eb 03                	jmp    c23d <lodepng_chunk_next_const+0xd4>
    return result;
    c23a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    c23d:	c9                   	leave  
    c23e:	c3                   	ret    

0000c23f <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    c23f:	55                   	push   %ebp
    c240:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    c242:	8b 45 08             	mov    0x8(%ebp),%eax
    c245:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c248:	73 0f                	jae    c259 <lodepng_chunk_find+0x1a>
    c24a:	8b 55 0c             	mov    0xc(%ebp),%edx
    c24d:	8b 45 08             	mov    0x8(%ebp),%eax
    c250:	29 c2                	sub    %eax,%edx
    c252:	89 d0                	mov    %edx,%eax
    c254:	83 f8 0b             	cmp    $0xb,%eax
    c257:	7f 07                	jg     c260 <lodepng_chunk_find+0x21>
    c259:	b8 00 00 00 00       	mov    $0x0,%eax
    c25e:	eb 2a                	jmp    c28a <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    c260:	ff 75 10             	pushl  0x10(%ebp)
    c263:	ff 75 08             	pushl  0x8(%ebp)
    c266:	e8 8d fc ff ff       	call   bef8 <lodepng_chunk_type_equals>
    c26b:	83 c4 08             	add    $0x8,%esp
    c26e:	84 c0                	test   %al,%al
    c270:	74 05                	je     c277 <lodepng_chunk_find+0x38>
    c272:	8b 45 08             	mov    0x8(%ebp),%eax
    c275:	eb 13                	jmp    c28a <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    c277:	ff 75 0c             	pushl  0xc(%ebp)
    c27a:	ff 75 08             	pushl  0x8(%ebp)
    c27d:	e8 11 fe ff ff       	call   c093 <lodepng_chunk_next>
    c282:	83 c4 08             	add    $0x8,%esp
    c285:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    c288:	eb b8                	jmp    c242 <lodepng_chunk_find+0x3>
}
    c28a:	c9                   	leave  
    c28b:	c3                   	ret    

0000c28c <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    c28c:	55                   	push   %ebp
    c28d:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    c28f:	8b 45 08             	mov    0x8(%ebp),%eax
    c292:	3b 45 0c             	cmp    0xc(%ebp),%eax
    c295:	73 0f                	jae    c2a6 <lodepng_chunk_find_const+0x1a>
    c297:	8b 55 0c             	mov    0xc(%ebp),%edx
    c29a:	8b 45 08             	mov    0x8(%ebp),%eax
    c29d:	29 c2                	sub    %eax,%edx
    c29f:	89 d0                	mov    %edx,%eax
    c2a1:	83 f8 0b             	cmp    $0xb,%eax
    c2a4:	7f 07                	jg     c2ad <lodepng_chunk_find_const+0x21>
    c2a6:	b8 00 00 00 00       	mov    $0x0,%eax
    c2ab:	eb 2a                	jmp    c2d7 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    c2ad:	ff 75 10             	pushl  0x10(%ebp)
    c2b0:	ff 75 08             	pushl  0x8(%ebp)
    c2b3:	e8 40 fc ff ff       	call   bef8 <lodepng_chunk_type_equals>
    c2b8:	83 c4 08             	add    $0x8,%esp
    c2bb:	84 c0                	test   %al,%al
    c2bd:	74 05                	je     c2c4 <lodepng_chunk_find_const+0x38>
    c2bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c2c2:	eb 13                	jmp    c2d7 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    c2c4:	ff 75 0c             	pushl  0xc(%ebp)
    c2c7:	ff 75 08             	pushl  0x8(%ebp)
    c2ca:	e8 9a fe ff ff       	call   c169 <lodepng_chunk_next_const>
    c2cf:	83 c4 08             	add    $0x8,%esp
    c2d2:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    c2d5:	eb b8                	jmp    c28f <lodepng_chunk_find_const+0x3>
}
    c2d7:	c9                   	leave  
    c2d8:	c3                   	ret    

0000c2d9 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    c2d9:	55                   	push   %ebp
    c2da:	89 e5                	mov    %esp,%ebp
    c2dc:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    c2df:	ff 75 10             	pushl  0x10(%ebp)
    c2e2:	e8 c4 fb ff ff       	call   beab <lodepng_chunk_length>
    c2e7:	83 c4 04             	add    $0x4,%esp
    c2ea:	89 c2                	mov    %eax,%edx
    c2ec:	8d 45 f0             	lea    -0x10(%ebp),%eax
    c2ef:	50                   	push   %eax
    c2f0:	6a 0c                	push   $0xc
    c2f2:	52                   	push   %edx
    c2f3:	e8 f5 ac ff ff       	call   6fed <lodepng_addofl>
    c2f8:	83 c4 0c             	add    $0xc,%esp
    c2fb:	85 c0                	test   %eax,%eax
    c2fd:	74 0a                	je     c309 <lodepng_chunk_append+0x30>
    c2ff:	b8 4d 00 00 00       	mov    $0x4d,%eax
    c304:	e9 96 00 00 00       	jmp    c39f <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    c309:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c30c:	8b 45 0c             	mov    0xc(%ebp),%eax
    c30f:	8b 00                	mov    (%eax),%eax
    c311:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    c314:	51                   	push   %ecx
    c315:	52                   	push   %edx
    c316:	50                   	push   %eax
    c317:	e8 d1 ac ff ff       	call   6fed <lodepng_addofl>
    c31c:	83 c4 0c             	add    $0xc,%esp
    c31f:	85 c0                	test   %eax,%eax
    c321:	74 07                	je     c32a <lodepng_chunk_append+0x51>
    c323:	b8 4d 00 00 00       	mov    $0x4d,%eax
    c328:	eb 75                	jmp    c39f <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    c32a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c32d:	8b 45 08             	mov    0x8(%ebp),%eax
    c330:	8b 00                	mov    (%eax),%eax
    c332:	52                   	push   %edx
    c333:	50                   	push   %eax
    c334:	e8 07 ac ff ff       	call   6f40 <lodepng_realloc>
    c339:	83 c4 08             	add    $0x8,%esp
    c33c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    c33f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    c343:	75 07                	jne    c34c <lodepng_chunk_append+0x73>
    c345:	b8 53 00 00 00       	mov    $0x53,%eax
    c34a:	eb 53                	jmp    c39f <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    c34c:	8b 45 08             	mov    0x8(%ebp),%eax
    c34f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c352:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    c354:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c357:	8b 45 0c             	mov    0xc(%ebp),%eax
    c35a:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    c35c:	8b 45 08             	mov    0x8(%ebp),%eax
    c35f:	8b 00                	mov    (%eax),%eax
    c361:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    c364:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c367:	29 d1                	sub    %edx,%ecx
    c369:	89 ca                	mov    %ecx,%edx
    c36b:	01 d0                	add    %edx,%eax
    c36d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    c370:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    c377:	eb 19                	jmp    c392 <lodepng_chunk_append+0xb9>
    c379:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c37c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c37f:	01 c2                	add    %eax,%edx
    c381:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c384:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c387:	01 c8                	add    %ecx,%eax
    c389:	0f b6 00             	movzbl (%eax),%eax
    c38c:	88 02                	mov    %al,(%edx)
    c38e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    c392:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c395:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    c398:	75 df                	jne    c379 <lodepng_chunk_append+0xa0>

  return 0;
    c39a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c39f:	c9                   	leave  
    c3a0:	c3                   	ret    

0000c3a1 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    c3a1:	55                   	push   %ebp
    c3a2:	89 e5                	mov    %esp,%ebp
    c3a4:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    c3a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    c3aa:	8b 40 04             	mov    0x4(%eax),%eax
    c3ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    c3b0:	8b 55 10             	mov    0x10(%ebp),%edx
    c3b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c3b6:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    c3b9:	51                   	push   %ecx
    c3ba:	52                   	push   %edx
    c3bb:	50                   	push   %eax
    c3bc:	e8 2c ac ff ff       	call   6fed <lodepng_addofl>
    c3c1:	83 c4 0c             	add    $0xc,%esp
    c3c4:	85 c0                	test   %eax,%eax
    c3c6:	74 07                	je     c3cf <lodepng_chunk_init+0x2e>
    c3c8:	b8 4d 00 00 00       	mov    $0x4d,%eax
    c3cd:	eb 78                	jmp    c447 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    c3cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c3d2:	8d 55 fc             	lea    -0x4(%ebp),%edx
    c3d5:	52                   	push   %edx
    c3d6:	6a 0c                	push   $0xc
    c3d8:	50                   	push   %eax
    c3d9:	e8 0f ac ff ff       	call   6fed <lodepng_addofl>
    c3de:	83 c4 0c             	add    $0xc,%esp
    c3e1:	85 c0                	test   %eax,%eax
    c3e3:	74 07                	je     c3ec <lodepng_chunk_init+0x4b>
    c3e5:	b8 4d 00 00 00       	mov    $0x4d,%eax
    c3ea:	eb 5b                	jmp    c447 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    c3ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c3ef:	50                   	push   %eax
    c3f0:	ff 75 0c             	pushl  0xc(%ebp)
    c3f3:	e8 8b ad ff ff       	call   7183 <ucvector_resize>
    c3f8:	83 c4 08             	add    $0x8,%esp
    c3fb:	85 c0                	test   %eax,%eax
    c3fd:	75 07                	jne    c406 <lodepng_chunk_init+0x65>
    c3ff:	b8 53 00 00 00       	mov    $0x53,%eax
    c404:	eb 41                	jmp    c447 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    c406:	8b 45 0c             	mov    0xc(%ebp),%eax
    c409:	8b 00                	mov    (%eax),%eax
    c40b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c40e:	2b 55 10             	sub    0x10(%ebp),%edx
    c411:	83 ea 0c             	sub    $0xc,%edx
    c414:	01 c2                	add    %eax,%edx
    c416:	8b 45 08             	mov    0x8(%ebp),%eax
    c419:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    c41b:	8b 45 08             	mov    0x8(%ebp),%eax
    c41e:	8b 00                	mov    (%eax),%eax
    c420:	ff 75 10             	pushl  0x10(%ebp)
    c423:	50                   	push   %eax
    c424:	e8 c1 ae ff ff       	call   72ea <lodepng_set32bitInt>
    c429:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    c42c:	8b 45 08             	mov    0x8(%ebp),%eax
    c42f:	8b 00                	mov    (%eax),%eax
    c431:	83 c0 04             	add    $0x4,%eax
    c434:	6a 04                	push   $0x4
    c436:	ff 75 14             	pushl  0x14(%ebp)
    c439:	50                   	push   %eax
    c43a:	e8 28 ab ff ff       	call   6f67 <lodepng_memcpy>
    c43f:	83 c4 0c             	add    $0xc,%esp

  return 0;
    c442:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c447:	c9                   	leave  
    c448:	c3                   	ret    

0000c449 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    c449:	55                   	push   %ebp
    c44a:	89 e5                	mov    %esp,%ebp
    c44c:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    c44f:	ff 75 10             	pushl  0x10(%ebp)
    c452:	ff 75 0c             	pushl  0xc(%ebp)
    c455:	ff 75 08             	pushl  0x8(%ebp)
    c458:	8d 45 f8             	lea    -0x8(%ebp),%eax
    c45b:	50                   	push   %eax
    c45c:	e8 40 ff ff ff       	call   c3a1 <lodepng_chunk_init>
    c461:	83 c4 10             	add    $0x10,%esp
    c464:	89 45 fc             	mov    %eax,-0x4(%ebp)
    c467:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    c46b:	74 05                	je     c472 <lodepng_chunk_createv+0x29>
    c46d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c470:	eb 27                	jmp    c499 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    c472:	8b 45 0c             	mov    0xc(%ebp),%eax
    c475:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c478:	83 c2 08             	add    $0x8,%edx
    c47b:	50                   	push   %eax
    c47c:	ff 75 14             	pushl  0x14(%ebp)
    c47f:	52                   	push   %edx
    c480:	e8 e2 aa ff ff       	call   6f67 <lodepng_memcpy>
    c485:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    c488:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c48b:	50                   	push   %eax
    c48c:	e8 b9 fb ff ff       	call   c04a <lodepng_chunk_generate_crc>
    c491:	83 c4 04             	add    $0x4,%esp

  return 0;
    c494:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c499:	c9                   	leave  
    c49a:	c3                   	ret    

0000c49b <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    c49b:	55                   	push   %ebp
    c49c:	89 e5                	mov    %esp,%ebp
    c49e:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    c4a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    c4a4:	8b 08                	mov    (%eax),%ecx
    c4a6:	8b 45 08             	mov    0x8(%ebp),%eax
    c4a9:	8b 10                	mov    (%eax),%edx
    c4ab:	8d 45 f0             	lea    -0x10(%ebp),%eax
    c4ae:	51                   	push   %ecx
    c4af:	52                   	push   %edx
    c4b0:	50                   	push   %eax
    c4b1:	e8 34 ad ff ff       	call   71ea <ucvector_init>
    c4b6:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    c4b9:	ff 75 18             	pushl  0x18(%ebp)
    c4bc:	ff 75 14             	pushl  0x14(%ebp)
    c4bf:	ff 75 10             	pushl  0x10(%ebp)
    c4c2:	8d 45 f0             	lea    -0x10(%ebp),%eax
    c4c5:	50                   	push   %eax
    c4c6:	e8 7e ff ff ff       	call   c449 <lodepng_chunk_createv>
    c4cb:	83 c4 10             	add    $0x10,%esp
    c4ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    c4d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c4d4:	8b 45 08             	mov    0x8(%ebp),%eax
    c4d7:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    c4d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c4dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    c4df:	89 10                	mov    %edx,(%eax)
  return error;
    c4e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    c4e4:	c9                   	leave  
    c4e5:	c3                   	ret    

0000c4e6 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    c4e6:	55                   	push   %ebp
    c4e7:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    c4e9:	8b 45 08             	mov    0x8(%ebp),%eax
    c4ec:	83 f8 03             	cmp    $0x3,%eax
    c4ef:	74 6d                	je     c55e <checkColorValidity+0x78>
    c4f1:	83 f8 03             	cmp    $0x3,%eax
    c4f4:	77 0e                	ja     c504 <checkColorValidity+0x1e>
    c4f6:	85 c0                	test   %eax,%eax
    c4f8:	74 28                	je     c522 <checkColorValidity+0x3c>
    c4fa:	83 f8 02             	cmp    $0x2,%eax
    c4fd:	74 4c                	je     c54b <checkColorValidity+0x65>
    c4ff:	e9 a6 00 00 00       	jmp    c5aa <checkColorValidity+0xc4>
    c504:	83 f8 06             	cmp    $0x6,%eax
    c507:	0f 84 83 00 00 00    	je     c590 <checkColorValidity+0xaa>
    c50d:	3d ff 00 00 00       	cmp    $0xff,%eax
    c512:	0f 84 8b 00 00 00    	je     c5a3 <checkColorValidity+0xbd>
    c518:	83 f8 04             	cmp    $0x4,%eax
    c51b:	74 60                	je     c57d <checkColorValidity+0x97>
    c51d:	e9 88 00 00 00       	jmp    c5aa <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    c522:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    c526:	0f 84 85 00 00 00    	je     c5b1 <checkColorValidity+0xcb>
    c52c:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    c530:	74 7f                	je     c5b1 <checkColorValidity+0xcb>
    c532:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    c536:	74 79                	je     c5b1 <checkColorValidity+0xcb>
    c538:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    c53c:	74 73                	je     c5b1 <checkColorValidity+0xcb>
    c53e:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    c542:	74 6d                	je     c5b1 <checkColorValidity+0xcb>
    c544:	b8 25 00 00 00       	mov    $0x25,%eax
    c549:	eb 78                	jmp    c5c3 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    c54b:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    c54f:	74 63                	je     c5b4 <checkColorValidity+0xce>
    c551:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    c555:	74 5d                	je     c5b4 <checkColorValidity+0xce>
    c557:	b8 25 00 00 00       	mov    $0x25,%eax
    c55c:	eb 65                	jmp    c5c3 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    c55e:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    c562:	74 53                	je     c5b7 <checkColorValidity+0xd1>
    c564:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    c568:	74 4d                	je     c5b7 <checkColorValidity+0xd1>
    c56a:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    c56e:	74 47                	je     c5b7 <checkColorValidity+0xd1>
    c570:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    c574:	74 41                	je     c5b7 <checkColorValidity+0xd1>
    c576:	b8 25 00 00 00       	mov    $0x25,%eax
    c57b:	eb 46                	jmp    c5c3 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    c57d:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    c581:	74 37                	je     c5ba <checkColorValidity+0xd4>
    c583:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    c587:	74 31                	je     c5ba <checkColorValidity+0xd4>
    c589:	b8 25 00 00 00       	mov    $0x25,%eax
    c58e:	eb 33                	jmp    c5c3 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    c590:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    c594:	74 27                	je     c5bd <checkColorValidity+0xd7>
    c596:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    c59a:	74 21                	je     c5bd <checkColorValidity+0xd7>
    c59c:	b8 25 00 00 00       	mov    $0x25,%eax
    c5a1:	eb 20                	jmp    c5c3 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    c5a3:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c5a8:	eb 19                	jmp    c5c3 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    c5aa:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c5af:	eb 12                	jmp    c5c3 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    c5b1:	90                   	nop
    c5b2:	eb 0a                	jmp    c5be <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    c5b4:	90                   	nop
    c5b5:	eb 07                	jmp    c5be <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    c5b7:	90                   	nop
    c5b8:	eb 04                	jmp    c5be <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    c5ba:	90                   	nop
    c5bb:	eb 01                	jmp    c5be <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    c5bd:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    c5be:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c5c3:	5d                   	pop    %ebp
    c5c4:	c3                   	ret    

0000c5c5 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    c5c5:	55                   	push   %ebp
    c5c6:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    c5c8:	8b 45 08             	mov    0x8(%ebp),%eax
    c5cb:	83 f8 03             	cmp    $0x3,%eax
    c5ce:	74 31                	je     c601 <getNumColorChannels+0x3c>
    c5d0:	83 f8 03             	cmp    $0x3,%eax
    c5d3:	77 0b                	ja     c5e0 <getNumColorChannels+0x1b>
    c5d5:	85 c0                	test   %eax,%eax
    c5d7:	74 1a                	je     c5f3 <getNumColorChannels+0x2e>
    c5d9:	83 f8 02             	cmp    $0x2,%eax
    c5dc:	74 1c                	je     c5fa <getNumColorChannels+0x35>
    c5de:	eb 3d                	jmp    c61d <getNumColorChannels+0x58>
    c5e0:	83 f8 06             	cmp    $0x6,%eax
    c5e3:	74 2a                	je     c60f <getNumColorChannels+0x4a>
    c5e5:	3d ff 00 00 00       	cmp    $0xff,%eax
    c5ea:	74 2a                	je     c616 <getNumColorChannels+0x51>
    c5ec:	83 f8 04             	cmp    $0x4,%eax
    c5ef:	74 17                	je     c608 <getNumColorChannels+0x43>
    c5f1:	eb 2a                	jmp    c61d <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    c5f3:	b8 01 00 00 00       	mov    $0x1,%eax
    c5f8:	eb 28                	jmp    c622 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    c5fa:	b8 03 00 00 00       	mov    $0x3,%eax
    c5ff:	eb 21                	jmp    c622 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    c601:	b8 01 00 00 00       	mov    $0x1,%eax
    c606:	eb 1a                	jmp    c622 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    c608:	b8 02 00 00 00       	mov    $0x2,%eax
    c60d:	eb 13                	jmp    c622 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    c60f:	b8 04 00 00 00       	mov    $0x4,%eax
    c614:	eb 0c                	jmp    c622 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    c616:	b8 00 00 00 00       	mov    $0x0,%eax
    c61b:	eb 05                	jmp    c622 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    c61d:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    c622:	5d                   	pop    %ebp
    c623:	c3                   	ret    

0000c624 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    c624:	55                   	push   %ebp
    c625:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    c627:	ff 75 08             	pushl  0x8(%ebp)
    c62a:	e8 96 ff ff ff       	call   c5c5 <getNumColorChannels>
    c62f:	83 c4 04             	add    $0x4,%esp
    c632:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    c636:	c9                   	leave  
    c637:	c3                   	ret    

0000c638 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    c638:	55                   	push   %ebp
    c639:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    c63b:	8b 45 08             	mov    0x8(%ebp),%eax
    c63e:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    c645:	8b 45 08             	mov    0x8(%ebp),%eax
    c648:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    c64f:	8b 45 08             	mov    0x8(%ebp),%eax
    c652:	8b 50 1c             	mov    0x1c(%eax),%edx
    c655:	8b 45 08             	mov    0x8(%ebp),%eax
    c658:	89 50 18             	mov    %edx,0x18(%eax)
    c65b:	8b 45 08             	mov    0x8(%ebp),%eax
    c65e:	8b 50 18             	mov    0x18(%eax),%edx
    c661:	8b 45 08             	mov    0x8(%ebp),%eax
    c664:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    c667:	8b 45 08             	mov    0x8(%ebp),%eax
    c66a:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    c670:	8b 45 08             	mov    0x8(%ebp),%eax
    c673:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    c67a:	8b 45 08             	mov    0x8(%ebp),%eax
    c67d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    c684:	8b 45 08             	mov    0x8(%ebp),%eax
    c687:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    c68e:	90                   	nop
    c68f:	5d                   	pop    %ebp
    c690:	c3                   	ret    

0000c691 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    c691:	55                   	push   %ebp
    c692:	89 e5                	mov    %esp,%ebp
    c694:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    c697:	8b 45 08             	mov    0x8(%ebp),%eax
    c69a:	8b 40 08             	mov    0x8(%eax),%eax
    c69d:	85 c0                	test   %eax,%eax
    c69f:	75 18                	jne    c6b9 <lodepng_color_mode_alloc_palette+0x28>
    c6a1:	83 ec 0c             	sub    $0xc,%esp
    c6a4:	68 00 04 00 00       	push   $0x400
    c6a9:	e8 7b a8 ff ff       	call   6f29 <lodepng_malloc>
    c6ae:	83 c4 10             	add    $0x10,%esp
    c6b1:	89 c2                	mov    %eax,%edx
    c6b3:	8b 45 08             	mov    0x8(%ebp),%eax
    c6b6:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    c6b9:	8b 45 08             	mov    0x8(%ebp),%eax
    c6bc:	8b 40 08             	mov    0x8(%eax),%eax
    c6bf:	85 c0                	test   %eax,%eax
    c6c1:	74 65                	je     c728 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    c6c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c6ca:	eb 51                	jmp    c71d <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    c6cc:	8b 45 08             	mov    0x8(%ebp),%eax
    c6cf:	8b 40 08             	mov    0x8(%eax),%eax
    c6d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c6d5:	c1 e2 02             	shl    $0x2,%edx
    c6d8:	01 d0                	add    %edx,%eax
    c6da:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    c6dd:	8b 45 08             	mov    0x8(%ebp),%eax
    c6e0:	8b 40 08             	mov    0x8(%eax),%eax
    c6e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c6e6:	c1 e2 02             	shl    $0x2,%edx
    c6e9:	83 c2 01             	add    $0x1,%edx
    c6ec:	01 d0                	add    %edx,%eax
    c6ee:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    c6f1:	8b 45 08             	mov    0x8(%ebp),%eax
    c6f4:	8b 40 08             	mov    0x8(%eax),%eax
    c6f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c6fa:	c1 e2 02             	shl    $0x2,%edx
    c6fd:	83 c2 02             	add    $0x2,%edx
    c700:	01 d0                	add    %edx,%eax
    c702:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    c705:	8b 45 08             	mov    0x8(%ebp),%eax
    c708:	8b 40 08             	mov    0x8(%eax),%eax
    c70b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c70e:	c1 e2 02             	shl    $0x2,%edx
    c711:	83 c2 03             	add    $0x3,%edx
    c714:	01 d0                	add    %edx,%eax
    c716:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    c719:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c71d:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    c724:	75 a6                	jne    c6cc <lodepng_color_mode_alloc_palette+0x3b>
    c726:	eb 01                	jmp    c729 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    c728:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    c729:	c9                   	leave  
    c72a:	c3                   	ret    

0000c72b <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    c72b:	55                   	push   %ebp
    c72c:	89 e5                	mov    %esp,%ebp
    c72e:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    c731:	83 ec 0c             	sub    $0xc,%esp
    c734:	ff 75 08             	pushl  0x8(%ebp)
    c737:	e8 f3 01 00 00       	call   c92f <lodepng_palette_clear>
    c73c:	83 c4 10             	add    $0x10,%esp
}
    c73f:	90                   	nop
    c740:	c9                   	leave  
    c741:	c3                   	ret    

0000c742 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    c742:	55                   	push   %ebp
    c743:	89 e5                	mov    %esp,%ebp
    c745:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    c748:	83 ec 0c             	sub    $0xc,%esp
    c74b:	ff 75 08             	pushl  0x8(%ebp)
    c74e:	e8 d8 ff ff ff       	call   c72b <lodepng_color_mode_cleanup>
    c753:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    c756:	83 ec 04             	sub    $0x4,%esp
    c759:	6a 20                	push   $0x20
    c75b:	ff 75 0c             	pushl  0xc(%ebp)
    c75e:	ff 75 08             	pushl  0x8(%ebp)
    c761:	e8 01 a8 ff ff       	call   6f67 <lodepng_memcpy>
    c766:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    c769:	8b 45 0c             	mov    0xc(%ebp),%eax
    c76c:	8b 40 08             	mov    0x8(%eax),%eax
    c76f:	85 c0                	test   %eax,%eax
    c771:	74 5a                	je     c7cd <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    c773:	83 ec 0c             	sub    $0xc,%esp
    c776:	68 00 04 00 00       	push   $0x400
    c77b:	e8 a9 a7 ff ff       	call   6f29 <lodepng_malloc>
    c780:	83 c4 10             	add    $0x10,%esp
    c783:	89 c2                	mov    %eax,%edx
    c785:	8b 45 08             	mov    0x8(%ebp),%eax
    c788:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    c78b:	8b 45 08             	mov    0x8(%ebp),%eax
    c78e:	8b 40 08             	mov    0x8(%eax),%eax
    c791:	85 c0                	test   %eax,%eax
    c793:	75 11                	jne    c7a6 <lodepng_color_mode_copy+0x64>
    c795:	8b 45 0c             	mov    0xc(%ebp),%eax
    c798:	8b 40 0c             	mov    0xc(%eax),%eax
    c79b:	85 c0                	test   %eax,%eax
    c79d:	74 07                	je     c7a6 <lodepng_color_mode_copy+0x64>
    c79f:	b8 53 00 00 00       	mov    $0x53,%eax
    c7a4:	eb 2c                	jmp    c7d2 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    c7a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    c7a9:	8b 40 0c             	mov    0xc(%eax),%eax
    c7ac:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    c7b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    c7b6:	8b 50 08             	mov    0x8(%eax),%edx
    c7b9:	8b 45 08             	mov    0x8(%ebp),%eax
    c7bc:	8b 40 08             	mov    0x8(%eax),%eax
    c7bf:	83 ec 04             	sub    $0x4,%esp
    c7c2:	51                   	push   %ecx
    c7c3:	52                   	push   %edx
    c7c4:	50                   	push   %eax
    c7c5:	e8 9d a7 ff ff       	call   6f67 <lodepng_memcpy>
    c7ca:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    c7cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c7d2:	c9                   	leave  
    c7d3:	c3                   	ret    

0000c7d4 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    c7d4:	55                   	push   %ebp
    c7d5:	89 e5                	mov    %esp,%ebp
    c7d7:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    c7da:	8d 45 e0             	lea    -0x20(%ebp),%eax
    c7dd:	50                   	push   %eax
    c7de:	e8 55 fe ff ff       	call   c638 <lodepng_color_mode_init>
    c7e3:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    c7e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    c7e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    c7ec:	8b 45 10             	mov    0x10(%ebp),%eax
    c7ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    c7f2:	8b 45 08             	mov    0x8(%ebp),%eax
    c7f5:	8b 55 e0             	mov    -0x20(%ebp),%edx
    c7f8:	89 10                	mov    %edx,(%eax)
    c7fa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c7fd:	89 50 04             	mov    %edx,0x4(%eax)
    c800:	8b 55 e8             	mov    -0x18(%ebp),%edx
    c803:	89 50 08             	mov    %edx,0x8(%eax)
    c806:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c809:	89 50 0c             	mov    %edx,0xc(%eax)
    c80c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c80f:	89 50 10             	mov    %edx,0x10(%eax)
    c812:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c815:	89 50 14             	mov    %edx,0x14(%eax)
    c818:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c81b:	89 50 18             	mov    %edx,0x18(%eax)
    c81e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c821:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    c824:	8b 45 08             	mov    0x8(%ebp),%eax
    c827:	c9                   	leave  
    c828:	c2 04 00             	ret    $0x4

0000c82b <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    c82b:	55                   	push   %ebp
    c82c:	89 e5                	mov    %esp,%ebp
    c82e:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    c831:	8b 45 08             	mov    0x8(%ebp),%eax
    c834:	8b 10                	mov    (%eax),%edx
    c836:	8b 45 0c             	mov    0xc(%ebp),%eax
    c839:	8b 00                	mov    (%eax),%eax
    c83b:	39 c2                	cmp    %eax,%edx
    c83d:	74 0a                	je     c849 <lodepng_color_mode_equal+0x1e>
    c83f:	b8 00 00 00 00       	mov    $0x0,%eax
    c844:	e9 e4 00 00 00       	jmp    c92d <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    c849:	8b 45 08             	mov    0x8(%ebp),%eax
    c84c:	8b 50 04             	mov    0x4(%eax),%edx
    c84f:	8b 45 0c             	mov    0xc(%ebp),%eax
    c852:	8b 40 04             	mov    0x4(%eax),%eax
    c855:	39 c2                	cmp    %eax,%edx
    c857:	74 0a                	je     c863 <lodepng_color_mode_equal+0x38>
    c859:	b8 00 00 00 00       	mov    $0x0,%eax
    c85e:	e9 ca 00 00 00       	jmp    c92d <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    c863:	8b 45 08             	mov    0x8(%ebp),%eax
    c866:	8b 50 10             	mov    0x10(%eax),%edx
    c869:	8b 45 0c             	mov    0xc(%ebp),%eax
    c86c:	8b 40 10             	mov    0x10(%eax),%eax
    c86f:	39 c2                	cmp    %eax,%edx
    c871:	74 0a                	je     c87d <lodepng_color_mode_equal+0x52>
    c873:	b8 00 00 00 00       	mov    $0x0,%eax
    c878:	e9 b0 00 00 00       	jmp    c92d <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    c87d:	8b 45 08             	mov    0x8(%ebp),%eax
    c880:	8b 40 10             	mov    0x10(%eax),%eax
    c883:	85 c0                	test   %eax,%eax
    c885:	74 48                	je     c8cf <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    c887:	8b 45 08             	mov    0x8(%ebp),%eax
    c88a:	8b 50 14             	mov    0x14(%eax),%edx
    c88d:	8b 45 0c             	mov    0xc(%ebp),%eax
    c890:	8b 40 14             	mov    0x14(%eax),%eax
    c893:	39 c2                	cmp    %eax,%edx
    c895:	74 0a                	je     c8a1 <lodepng_color_mode_equal+0x76>
    c897:	b8 00 00 00 00       	mov    $0x0,%eax
    c89c:	e9 8c 00 00 00       	jmp    c92d <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    c8a1:	8b 45 08             	mov    0x8(%ebp),%eax
    c8a4:	8b 50 18             	mov    0x18(%eax),%edx
    c8a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    c8aa:	8b 40 18             	mov    0x18(%eax),%eax
    c8ad:	39 c2                	cmp    %eax,%edx
    c8af:	74 07                	je     c8b8 <lodepng_color_mode_equal+0x8d>
    c8b1:	b8 00 00 00 00       	mov    $0x0,%eax
    c8b6:	eb 75                	jmp    c92d <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    c8b8:	8b 45 08             	mov    0x8(%ebp),%eax
    c8bb:	8b 50 1c             	mov    0x1c(%eax),%edx
    c8be:	8b 45 0c             	mov    0xc(%ebp),%eax
    c8c1:	8b 40 1c             	mov    0x1c(%eax),%eax
    c8c4:	39 c2                	cmp    %eax,%edx
    c8c6:	74 07                	je     c8cf <lodepng_color_mode_equal+0xa4>
    c8c8:	b8 00 00 00 00       	mov    $0x0,%eax
    c8cd:	eb 5e                	jmp    c92d <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    c8cf:	8b 45 08             	mov    0x8(%ebp),%eax
    c8d2:	8b 50 0c             	mov    0xc(%eax),%edx
    c8d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    c8d8:	8b 40 0c             	mov    0xc(%eax),%eax
    c8db:	39 c2                	cmp    %eax,%edx
    c8dd:	74 07                	je     c8e6 <lodepng_color_mode_equal+0xbb>
    c8df:	b8 00 00 00 00       	mov    $0x0,%eax
    c8e4:	eb 47                	jmp    c92d <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    c8e6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    c8ed:	eb 2b                	jmp    c91a <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    c8ef:	8b 45 08             	mov    0x8(%ebp),%eax
    c8f2:	8b 50 08             	mov    0x8(%eax),%edx
    c8f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c8f8:	01 d0                	add    %edx,%eax
    c8fa:	0f b6 10             	movzbl (%eax),%edx
    c8fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    c900:	8b 48 08             	mov    0x8(%eax),%ecx
    c903:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c906:	01 c8                	add    %ecx,%eax
    c908:	0f b6 00             	movzbl (%eax),%eax
    c90b:	38 c2                	cmp    %al,%dl
    c90d:	74 07                	je     c916 <lodepng_color_mode_equal+0xeb>
    c90f:	b8 00 00 00 00       	mov    $0x0,%eax
    c914:	eb 17                	jmp    c92d <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    c916:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    c91a:	8b 45 08             	mov    0x8(%ebp),%eax
    c91d:	8b 40 0c             	mov    0xc(%eax),%eax
    c920:	c1 e0 02             	shl    $0x2,%eax
    c923:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    c926:	75 c7                	jne    c8ef <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    c928:	b8 01 00 00 00       	mov    $0x1,%eax
}
    c92d:	c9                   	leave  
    c92e:	c3                   	ret    

0000c92f <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    c92f:	55                   	push   %ebp
    c930:	89 e5                	mov    %esp,%ebp
    c932:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    c935:	8b 45 08             	mov    0x8(%ebp),%eax
    c938:	8b 40 08             	mov    0x8(%eax),%eax
    c93b:	85 c0                	test   %eax,%eax
    c93d:	74 12                	je     c951 <lodepng_palette_clear+0x22>
    c93f:	8b 45 08             	mov    0x8(%ebp),%eax
    c942:	8b 40 08             	mov    0x8(%eax),%eax
    c945:	83 ec 0c             	sub    $0xc,%esp
    c948:	50                   	push   %eax
    c949:	e8 fc a5 ff ff       	call   6f4a <lodepng_free>
    c94e:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    c951:	8b 45 08             	mov    0x8(%ebp),%eax
    c954:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    c95b:	8b 45 08             	mov    0x8(%ebp),%eax
    c95e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    c965:	90                   	nop
    c966:	c9                   	leave  
    c967:	c3                   	ret    

0000c968 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    c968:	55                   	push   %ebp
    c969:	89 e5                	mov    %esp,%ebp
    c96b:	53                   	push   %ebx
    c96c:	83 ec 14             	sub    $0x14,%esp
    c96f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    c972:	8b 4d 10             	mov    0x10(%ebp),%ecx
    c975:	8b 55 14             	mov    0x14(%ebp),%edx
    c978:	8b 45 18             	mov    0x18(%ebp),%eax
    c97b:	88 5d f4             	mov    %bl,-0xc(%ebp)
    c97e:	88 4d f0             	mov    %cl,-0x10(%ebp)
    c981:	88 55 ec             	mov    %dl,-0x14(%ebp)
    c984:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    c987:	8b 45 08             	mov    0x8(%ebp),%eax
    c98a:	8b 40 08             	mov    0x8(%eax),%eax
    c98d:	85 c0                	test   %eax,%eax
    c98f:	75 22                	jne    c9b3 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    c991:	83 ec 0c             	sub    $0xc,%esp
    c994:	ff 75 08             	pushl  0x8(%ebp)
    c997:	e8 f5 fc ff ff       	call   c691 <lodepng_color_mode_alloc_palette>
    c99c:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    c99f:	8b 45 08             	mov    0x8(%ebp),%eax
    c9a2:	8b 40 08             	mov    0x8(%eax),%eax
    c9a5:	85 c0                	test   %eax,%eax
    c9a7:	75 0a                	jne    c9b3 <lodepng_palette_add+0x4b>
    c9a9:	b8 53 00 00 00       	mov    $0x53,%eax
    c9ae:	e9 8d 00 00 00       	jmp    ca40 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    c9b3:	8b 45 08             	mov    0x8(%ebp),%eax
    c9b6:	8b 40 0c             	mov    0xc(%eax),%eax
    c9b9:	3d ff 00 00 00       	cmp    $0xff,%eax
    c9be:	7e 07                	jle    c9c7 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    c9c0:	b8 6c 00 00 00       	mov    $0x6c,%eax
    c9c5:	eb 79                	jmp    ca40 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    c9c7:	8b 45 08             	mov    0x8(%ebp),%eax
    c9ca:	8b 50 08             	mov    0x8(%eax),%edx
    c9cd:	8b 45 08             	mov    0x8(%ebp),%eax
    c9d0:	8b 40 0c             	mov    0xc(%eax),%eax
    c9d3:	c1 e0 02             	shl    $0x2,%eax
    c9d6:	01 c2                	add    %eax,%edx
    c9d8:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    c9dc:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    c9de:	8b 45 08             	mov    0x8(%ebp),%eax
    c9e1:	8b 50 08             	mov    0x8(%eax),%edx
    c9e4:	8b 45 08             	mov    0x8(%ebp),%eax
    c9e7:	8b 40 0c             	mov    0xc(%eax),%eax
    c9ea:	c1 e0 02             	shl    $0x2,%eax
    c9ed:	83 c0 01             	add    $0x1,%eax
    c9f0:	01 c2                	add    %eax,%edx
    c9f2:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    c9f6:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    c9f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c9fb:	8b 50 08             	mov    0x8(%eax),%edx
    c9fe:	8b 45 08             	mov    0x8(%ebp),%eax
    ca01:	8b 40 0c             	mov    0xc(%eax),%eax
    ca04:	c1 e0 02             	shl    $0x2,%eax
    ca07:	83 c0 02             	add    $0x2,%eax
    ca0a:	01 c2                	add    %eax,%edx
    ca0c:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    ca10:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    ca12:	8b 45 08             	mov    0x8(%ebp),%eax
    ca15:	8b 50 08             	mov    0x8(%eax),%edx
    ca18:	8b 45 08             	mov    0x8(%ebp),%eax
    ca1b:	8b 40 0c             	mov    0xc(%eax),%eax
    ca1e:	c1 e0 02             	shl    $0x2,%eax
    ca21:	83 c0 03             	add    $0x3,%eax
    ca24:	01 c2                	add    %eax,%edx
    ca26:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    ca2a:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    ca2c:	8b 45 08             	mov    0x8(%ebp),%eax
    ca2f:	8b 40 0c             	mov    0xc(%eax),%eax
    ca32:	8d 50 01             	lea    0x1(%eax),%edx
    ca35:	8b 45 08             	mov    0x8(%ebp),%eax
    ca38:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    ca3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ca40:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    ca43:	c9                   	leave  
    ca44:	c3                   	ret    

0000ca45 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    ca45:	55                   	push   %ebp
    ca46:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    ca48:	8b 45 08             	mov    0x8(%ebp),%eax
    ca4b:	8b 50 04             	mov    0x4(%eax),%edx
    ca4e:	8b 45 08             	mov    0x8(%ebp),%eax
    ca51:	8b 00                	mov    (%eax),%eax
    ca53:	52                   	push   %edx
    ca54:	50                   	push   %eax
    ca55:	e8 ca fb ff ff       	call   c624 <lodepng_get_bpp_lct>
    ca5a:	83 c4 08             	add    $0x8,%esp
}
    ca5d:	c9                   	leave  
    ca5e:	c3                   	ret    

0000ca5f <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    ca5f:	55                   	push   %ebp
    ca60:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    ca62:	8b 45 08             	mov    0x8(%ebp),%eax
    ca65:	8b 00                	mov    (%eax),%eax
    ca67:	50                   	push   %eax
    ca68:	e8 58 fb ff ff       	call   c5c5 <getNumColorChannels>
    ca6d:	83 c4 04             	add    $0x4,%esp
}
    ca70:	c9                   	leave  
    ca71:	c3                   	ret    

0000ca72 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    ca72:	55                   	push   %ebp
    ca73:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    ca75:	8b 45 08             	mov    0x8(%ebp),%eax
    ca78:	8b 00                	mov    (%eax),%eax
    ca7a:	85 c0                	test   %eax,%eax
    ca7c:	74 0a                	je     ca88 <lodepng_is_greyscale_type+0x16>
    ca7e:	8b 45 08             	mov    0x8(%ebp),%eax
    ca81:	8b 00                	mov    (%eax),%eax
    ca83:	83 f8 04             	cmp    $0x4,%eax
    ca86:	75 07                	jne    ca8f <lodepng_is_greyscale_type+0x1d>
    ca88:	b8 01 00 00 00       	mov    $0x1,%eax
    ca8d:	eb 05                	jmp    ca94 <lodepng_is_greyscale_type+0x22>
    ca8f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ca94:	5d                   	pop    %ebp
    ca95:	c3                   	ret    

0000ca96 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    ca96:	55                   	push   %ebp
    ca97:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    ca99:	8b 45 08             	mov    0x8(%ebp),%eax
    ca9c:	8b 00                	mov    (%eax),%eax
    ca9e:	83 e0 04             	and    $0x4,%eax
    caa1:	85 c0                	test   %eax,%eax
    caa3:	0f 95 c0             	setne  %al
    caa6:	0f b6 c0             	movzbl %al,%eax
}
    caa9:	5d                   	pop    %ebp
    caaa:	c3                   	ret    

0000caab <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    caab:	55                   	push   %ebp
    caac:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    caae:	8b 45 08             	mov    0x8(%ebp),%eax
    cab1:	8b 00                	mov    (%eax),%eax
    cab3:	83 f8 03             	cmp    $0x3,%eax
    cab6:	0f 94 c0             	sete   %al
    cab9:	0f b6 c0             	movzbl %al,%eax
}
    cabc:	5d                   	pop    %ebp
    cabd:	c3                   	ret    

0000cabe <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    cabe:	55                   	push   %ebp
    cabf:	89 e5                	mov    %esp,%ebp
    cac1:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    cac4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    cacb:	eb 23                	jmp    caf0 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    cacd:	8b 45 08             	mov    0x8(%ebp),%eax
    cad0:	8b 40 08             	mov    0x8(%eax),%eax
    cad3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    cad6:	c1 e2 02             	shl    $0x2,%edx
    cad9:	83 c2 03             	add    $0x3,%edx
    cadc:	01 d0                	add    %edx,%eax
    cade:	0f b6 00             	movzbl (%eax),%eax
    cae1:	3c ff                	cmp    $0xff,%al
    cae3:	74 07                	je     caec <lodepng_has_palette_alpha+0x2e>
    cae5:	b8 01 00 00 00       	mov    $0x1,%eax
    caea:	eb 14                	jmp    cb00 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    caec:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    caf0:	8b 45 08             	mov    0x8(%ebp),%eax
    caf3:	8b 40 0c             	mov    0xc(%eax),%eax
    caf6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    caf9:	75 d2                	jne    cacd <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    cafb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    cb00:	c9                   	leave  
    cb01:	c3                   	ret    

0000cb02 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    cb02:	55                   	push   %ebp
    cb03:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    cb05:	8b 45 08             	mov    0x8(%ebp),%eax
    cb08:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    cb0b:	85 c0                	test   %eax,%eax
    cb0d:	75 1e                	jne    cb2d <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    cb0f:	ff 75 08             	pushl  0x8(%ebp)
    cb12:	e8 7f ff ff ff       	call   ca96 <lodepng_is_alpha_type>
    cb17:	83 c4 04             	add    $0x4,%esp
    cb1a:	85 c0                	test   %eax,%eax
    cb1c:	75 0f                	jne    cb2d <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    cb1e:	ff 75 08             	pushl  0x8(%ebp)
    cb21:	e8 98 ff ff ff       	call   cabe <lodepng_has_palette_alpha>
    cb26:	83 c4 04             	add    $0x4,%esp
    cb29:	85 c0                	test   %eax,%eax
    cb2b:	74 07                	je     cb34 <lodepng_can_have_alpha+0x32>
    cb2d:	b8 01 00 00 00       	mov    $0x1,%eax
    cb32:	eb 05                	jmp    cb39 <lodepng_can_have_alpha+0x37>
    cb34:	b8 00 00 00 00       	mov    $0x0,%eax
}
    cb39:	c9                   	leave  
    cb3a:	c3                   	ret    

0000cb3b <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    cb3b:	55                   	push   %ebp
    cb3c:	89 e5                	mov    %esp,%ebp
    cb3e:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    cb41:	ff 75 14             	pushl  0x14(%ebp)
    cb44:	ff 75 10             	pushl  0x10(%ebp)
    cb47:	e8 d8 fa ff ff       	call   c624 <lodepng_get_bpp_lct>
    cb4c:	83 c4 08             	add    $0x8,%esp
    cb4f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    cb52:	8b 55 08             	mov    0x8(%ebp),%edx
    cb55:	8b 45 0c             	mov    0xc(%ebp),%eax
    cb58:	0f af c2             	imul   %edx,%eax
    cb5b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    cb5e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cb61:	c1 e8 03             	shr    $0x3,%eax
    cb64:	89 c2                	mov    %eax,%edx
    cb66:	8b 45 fc             	mov    -0x4(%ebp),%eax
    cb69:	0f af c2             	imul   %edx,%eax
    cb6c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    cb6f:	89 d1                	mov    %edx,%ecx
    cb71:	83 e1 07             	and    $0x7,%ecx
    cb74:	8b 55 fc             	mov    -0x4(%ebp),%edx
    cb77:	0f af d1             	imul   %ecx,%edx
    cb7a:	83 c2 07             	add    $0x7,%edx
    cb7d:	c1 ea 03             	shr    $0x3,%edx
    cb80:	01 d0                	add    %edx,%eax
}
    cb82:	c9                   	leave  
    cb83:	c3                   	ret    

0000cb84 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    cb84:	55                   	push   %ebp
    cb85:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    cb87:	8b 45 10             	mov    0x10(%ebp),%eax
    cb8a:	8b 50 04             	mov    0x4(%eax),%edx
    cb8d:	8b 45 10             	mov    0x10(%ebp),%eax
    cb90:	8b 00                	mov    (%eax),%eax
    cb92:	52                   	push   %edx
    cb93:	50                   	push   %eax
    cb94:	ff 75 0c             	pushl  0xc(%ebp)
    cb97:	ff 75 08             	pushl  0x8(%ebp)
    cb9a:	e8 9c ff ff ff       	call   cb3b <lodepng_get_raw_size_lct>
    cb9f:	83 c4 10             	add    $0x10,%esp
}
    cba2:	c9                   	leave  
    cba3:	c3                   	ret    

0000cba4 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    cba4:	55                   	push   %ebp
    cba5:	89 e5                	mov    %esp,%ebp
    cba7:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    cbaa:	8b 45 08             	mov    0x8(%ebp),%eax
    cbad:	c1 e8 03             	shr    $0x3,%eax
    cbb0:	0f af 45 10          	imul   0x10(%ebp),%eax
    cbb4:	8b 55 08             	mov    0x8(%ebp),%edx
    cbb7:	83 e2 07             	and    $0x7,%edx
    cbba:	0f af 55 10          	imul   0x10(%ebp),%edx
    cbbe:	83 c2 07             	add    $0x7,%edx
    cbc1:	c1 ea 03             	shr    $0x3,%edx
    cbc4:	01 d0                	add    %edx,%eax
    cbc6:	83 c0 01             	add    $0x1,%eax
    cbc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    cbcc:	8b 45 0c             	mov    0xc(%ebp),%eax
    cbcf:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    cbd3:	c9                   	leave  
    cbd4:	c3                   	ret    

0000cbd5 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    cbd5:	55                   	push   %ebp
    cbd6:	89 e5                	mov    %esp,%ebp
    cbd8:	53                   	push   %ebx
    cbd9:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    cbdc:	ff 75 10             	pushl  0x10(%ebp)
    cbdf:	e8 61 fe ff ff       	call   ca45 <lodepng_get_bpp>
    cbe4:	83 c4 04             	add    $0x4,%esp
    cbe7:	89 c3                	mov    %eax,%ebx
    cbe9:	ff 75 14             	pushl  0x14(%ebp)
    cbec:	e8 54 fe ff ff       	call   ca45 <lodepng_get_bpp>
    cbf1:	83 c4 04             	add    $0x4,%esp
    cbf4:	39 c3                	cmp    %eax,%ebx
    cbf6:	76 0d                	jbe    cc05 <lodepng_pixel_overflow+0x30>
    cbf8:	ff 75 10             	pushl  0x10(%ebp)
    cbfb:	e8 45 fe ff ff       	call   ca45 <lodepng_get_bpp>
    cc00:	83 c4 04             	add    $0x4,%esp
    cc03:	eb 0b                	jmp    cc10 <lodepng_pixel_overflow+0x3b>
    cc05:	ff 75 14             	pushl  0x14(%ebp)
    cc08:	e8 38 fe ff ff       	call   ca45 <lodepng_get_bpp>
    cc0d:	83 c4 04             	add    $0x4,%esp
    cc10:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    cc13:	8b 55 0c             	mov    0xc(%ebp),%edx
    cc16:	8b 45 08             	mov    0x8(%ebp),%eax
    cc19:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    cc1c:	51                   	push   %ecx
    cc1d:	52                   	push   %edx
    cc1e:	50                   	push   %eax
    cc1f:	e8 e9 a3 ff ff       	call   700d <lodepng_mulofl>
    cc24:	83 c4 0c             	add    $0xc,%esp
    cc27:	85 c0                	test   %eax,%eax
    cc29:	74 0a                	je     cc35 <lodepng_pixel_overflow+0x60>
    cc2b:	b8 01 00 00 00       	mov    $0x1,%eax
    cc30:	e9 b6 00 00 00       	jmp    cceb <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    cc35:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cc38:	8d 55 f0             	lea    -0x10(%ebp),%edx
    cc3b:	52                   	push   %edx
    cc3c:	6a 08                	push   $0x8
    cc3e:	50                   	push   %eax
    cc3f:	e8 c9 a3 ff ff       	call   700d <lodepng_mulofl>
    cc44:	83 c4 0c             	add    $0xc,%esp
    cc47:	85 c0                	test   %eax,%eax
    cc49:	74 0a                	je     cc55 <lodepng_pixel_overflow+0x80>
    cc4b:	b8 01 00 00 00       	mov    $0x1,%eax
    cc50:	e9 96 00 00 00       	jmp    cceb <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    cc55:	8b 45 08             	mov    0x8(%ebp),%eax
    cc58:	c1 e8 03             	shr    $0x3,%eax
    cc5b:	89 c2                	mov    %eax,%edx
    cc5d:	8d 45 ec             	lea    -0x14(%ebp),%eax
    cc60:	50                   	push   %eax
    cc61:	ff 75 f8             	pushl  -0x8(%ebp)
    cc64:	52                   	push   %edx
    cc65:	e8 a3 a3 ff ff       	call   700d <lodepng_mulofl>
    cc6a:	83 c4 0c             	add    $0xc,%esp
    cc6d:	85 c0                	test   %eax,%eax
    cc6f:	74 07                	je     cc78 <lodepng_pixel_overflow+0xa3>
    cc71:	b8 01 00 00 00       	mov    $0x1,%eax
    cc76:	eb 73                	jmp    cceb <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    cc78:	8b 45 08             	mov    0x8(%ebp),%eax
    cc7b:	83 e0 07             	and    $0x7,%eax
    cc7e:	89 c2                	mov    %eax,%edx
    cc80:	8b 45 f8             	mov    -0x8(%ebp),%eax
    cc83:	0f af c2             	imul   %edx,%eax
    cc86:	83 c0 07             	add    $0x7,%eax
    cc89:	c1 e8 03             	shr    $0x3,%eax
    cc8c:	89 c1                	mov    %eax,%ecx
    cc8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    cc91:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cc94:	52                   	push   %edx
    cc95:	51                   	push   %ecx
    cc96:	50                   	push   %eax
    cc97:	e8 51 a3 ff ff       	call   6fed <lodepng_addofl>
    cc9c:	83 c4 0c             	add    $0xc,%esp
    cc9f:	85 c0                	test   %eax,%eax
    cca1:	74 07                	je     ccaa <lodepng_pixel_overflow+0xd5>
    cca3:	b8 01 00 00 00       	mov    $0x1,%eax
    cca8:	eb 41                	jmp    cceb <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    ccaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ccad:	8d 55 ec             	lea    -0x14(%ebp),%edx
    ccb0:	52                   	push   %edx
    ccb1:	6a 05                	push   $0x5
    ccb3:	50                   	push   %eax
    ccb4:	e8 34 a3 ff ff       	call   6fed <lodepng_addofl>
    ccb9:	83 c4 0c             	add    $0xc,%esp
    ccbc:	85 c0                	test   %eax,%eax
    ccbe:	74 07                	je     ccc7 <lodepng_pixel_overflow+0xf2>
    ccc0:	b8 01 00 00 00       	mov    $0x1,%eax
    ccc5:	eb 24                	jmp    cceb <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    ccc7:	8b 55 0c             	mov    0xc(%ebp),%edx
    ccca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    cccd:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    ccd0:	51                   	push   %ecx
    ccd1:	52                   	push   %edx
    ccd2:	50                   	push   %eax
    ccd3:	e8 35 a3 ff ff       	call   700d <lodepng_mulofl>
    ccd8:	83 c4 0c             	add    $0xc,%esp
    ccdb:	85 c0                	test   %eax,%eax
    ccdd:	74 07                	je     cce6 <lodepng_pixel_overflow+0x111>
    ccdf:	b8 01 00 00 00       	mov    $0x1,%eax
    cce4:	eb 05                	jmp    cceb <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    cce6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    cceb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    ccee:	c9                   	leave  
    ccef:	c3                   	ret    

0000ccf0 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    ccf0:	55                   	push   %ebp
    ccf1:	89 e5                	mov    %esp,%ebp
    ccf3:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    ccf6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    ccfd:	eb 15                	jmp    cd14 <LodePNGUnknownChunks_init+0x24>
    ccff:	8b 45 08             	mov    0x8(%ebp),%eax
    cd02:	8b 55 fc             	mov    -0x4(%ebp),%edx
    cd05:	83 c2 30             	add    $0x30,%edx
    cd08:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    cd0f:	00 
    cd10:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    cd14:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    cd18:	75 e5                	jne    ccff <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    cd1a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    cd21:	eb 15                	jmp    cd38 <LodePNGUnknownChunks_init+0x48>
    cd23:	8b 45 08             	mov    0x8(%ebp),%eax
    cd26:	8b 55 fc             	mov    -0x4(%ebp),%edx
    cd29:	83 c2 34             	add    $0x34,%edx
    cd2c:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    cd33:	00 
    cd34:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    cd38:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    cd3c:	75 e5                	jne    cd23 <LodePNGUnknownChunks_init+0x33>
}
    cd3e:	90                   	nop
    cd3f:	c9                   	leave  
    cd40:	c3                   	ret    

0000cd41 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    cd41:	55                   	push   %ebp
    cd42:	89 e5                	mov    %esp,%ebp
    cd44:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    cd47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cd4e:	eb 1d                	jmp    cd6d <LodePNGUnknownChunks_cleanup+0x2c>
    cd50:	8b 45 08             	mov    0x8(%ebp),%eax
    cd53:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cd56:	83 c2 30             	add    $0x30,%edx
    cd59:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    cd5d:	83 ec 0c             	sub    $0xc,%esp
    cd60:	50                   	push   %eax
    cd61:	e8 e4 a1 ff ff       	call   6f4a <lodepng_free>
    cd66:	83 c4 10             	add    $0x10,%esp
    cd69:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cd6d:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    cd71:	75 dd                	jne    cd50 <LodePNGUnknownChunks_cleanup+0xf>
}
    cd73:	90                   	nop
    cd74:	c9                   	leave  
    cd75:	c3                   	ret    

0000cd76 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    cd76:	55                   	push   %ebp
    cd77:	89 e5                	mov    %esp,%ebp
    cd79:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    cd7c:	83 ec 0c             	sub    $0xc,%esp
    cd7f:	ff 75 08             	pushl  0x8(%ebp)
    cd82:	e8 ba ff ff ff       	call   cd41 <LodePNGUnknownChunks_cleanup>
    cd87:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    cd8a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cd91:	e9 b7 00 00 00       	jmp    ce4d <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    cd96:	8b 45 0c             	mov    0xc(%ebp),%eax
    cd99:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cd9c:	83 c2 34             	add    $0x34,%edx
    cd9f:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    cda3:	8b 45 08             	mov    0x8(%ebp),%eax
    cda6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    cda9:	83 c1 34             	add    $0x34,%ecx
    cdac:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    cdb0:	8b 45 0c             	mov    0xc(%ebp),%eax
    cdb3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cdb6:	83 c2 34             	add    $0x34,%edx
    cdb9:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    cdbd:	83 ec 0c             	sub    $0xc,%esp
    cdc0:	50                   	push   %eax
    cdc1:	e8 63 a1 ff ff       	call   6f29 <lodepng_malloc>
    cdc6:	83 c4 10             	add    $0x10,%esp
    cdc9:	89 c1                	mov    %eax,%ecx
    cdcb:	8b 45 08             	mov    0x8(%ebp),%eax
    cdce:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cdd1:	83 c2 30             	add    $0x30,%edx
    cdd4:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    cdd8:	8b 45 08             	mov    0x8(%ebp),%eax
    cddb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cdde:	83 c2 30             	add    $0x30,%edx
    cde1:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    cde5:	85 c0                	test   %eax,%eax
    cde7:	75 18                	jne    ce01 <LodePNGUnknownChunks_copy+0x8b>
    cde9:	8b 45 08             	mov    0x8(%ebp),%eax
    cdec:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cdef:	83 c2 34             	add    $0x34,%edx
    cdf2:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    cdf6:	85 c0                	test   %eax,%eax
    cdf8:	74 07                	je     ce01 <LodePNGUnknownChunks_copy+0x8b>
    cdfa:	b8 53 00 00 00       	mov    $0x53,%eax
    cdff:	eb 5b                	jmp    ce5c <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    ce01:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ce08:	eb 2d                	jmp    ce37 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    ce0a:	8b 45 08             	mov    0x8(%ebp),%eax
    ce0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ce10:	83 c2 30             	add    $0x30,%edx
    ce13:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    ce17:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce1a:	01 c2                	add    %eax,%edx
    ce1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ce1f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    ce22:	83 c1 30             	add    $0x30,%ecx
    ce25:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    ce29:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce2c:	01 c8                	add    %ecx,%eax
    ce2e:	0f b6 00             	movzbl (%eax),%eax
    ce31:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    ce33:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ce37:	8b 45 0c             	mov    0xc(%ebp),%eax
    ce3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ce3d:	83 c2 34             	add    $0x34,%edx
    ce40:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    ce44:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    ce47:	7f c1                	jg     ce0a <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    ce49:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ce4d:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    ce51:	0f 85 3f ff ff ff    	jne    cd96 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    ce57:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ce5c:	c9                   	leave  
    ce5d:	c3                   	ret    

0000ce5e <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    ce5e:	55                   	push   %ebp
    ce5f:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    ce61:	8b 45 08             	mov    0x8(%ebp),%eax
    ce64:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    ce6b:	8b 45 08             	mov    0x8(%ebp),%eax
    ce6e:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    ce75:	8b 45 08             	mov    0x8(%ebp),%eax
    ce78:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    ce7f:	90                   	nop
    ce80:	5d                   	pop    %ebp
    ce81:	c3                   	ret    

0000ce82 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    ce82:	55                   	push   %ebp
    ce83:	89 e5                	mov    %esp,%ebp
    ce85:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    ce88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ce8f:	eb 38                	jmp    cec9 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    ce91:	8b 45 08             	mov    0x8(%ebp),%eax
    ce94:	8b 40 40             	mov    0x40(%eax),%eax
    ce97:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ce9a:	c1 e2 02             	shl    $0x2,%edx
    ce9d:	01 d0                	add    %edx,%eax
    ce9f:	83 ec 0c             	sub    $0xc,%esp
    cea2:	50                   	push   %eax
    cea3:	e8 75 a3 ff ff       	call   721d <string_cleanup>
    cea8:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    ceab:	8b 45 08             	mov    0x8(%ebp),%eax
    ceae:	8b 40 44             	mov    0x44(%eax),%eax
    ceb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ceb4:	c1 e2 02             	shl    $0x2,%edx
    ceb7:	01 d0                	add    %edx,%eax
    ceb9:	83 ec 0c             	sub    $0xc,%esp
    cebc:	50                   	push   %eax
    cebd:	e8 5b a3 ff ff       	call   721d <string_cleanup>
    cec2:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    cec5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cec9:	8b 45 08             	mov    0x8(%ebp),%eax
    cecc:	8b 40 3c             	mov    0x3c(%eax),%eax
    cecf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    ced2:	75 bd                	jne    ce91 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    ced4:	8b 45 08             	mov    0x8(%ebp),%eax
    ced7:	8b 40 40             	mov    0x40(%eax),%eax
    ceda:	83 ec 0c             	sub    $0xc,%esp
    cedd:	50                   	push   %eax
    cede:	e8 67 a0 ff ff       	call   6f4a <lodepng_free>
    cee3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    cee6:	8b 45 08             	mov    0x8(%ebp),%eax
    cee9:	8b 40 44             	mov    0x44(%eax),%eax
    ceec:	83 ec 0c             	sub    $0xc,%esp
    ceef:	50                   	push   %eax
    cef0:	e8 55 a0 ff ff       	call   6f4a <lodepng_free>
    cef5:	83 c4 10             	add    $0x10,%esp
}
    cef8:	90                   	nop
    cef9:	c9                   	leave  
    cefa:	c3                   	ret    

0000cefb <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    cefb:	55                   	push   %ebp
    cefc:	89 e5                	mov    %esp,%ebp
    cefe:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    cf01:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    cf08:	8b 45 08             	mov    0x8(%ebp),%eax
    cf0b:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    cf12:	8b 45 08             	mov    0x8(%ebp),%eax
    cf15:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    cf1c:	8b 45 08             	mov    0x8(%ebp),%eax
    cf1f:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    cf26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cf2d:	eb 42                	jmp    cf71 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    cf2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf32:	8b 40 44             	mov    0x44(%eax),%eax
    cf35:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cf38:	c1 e2 02             	shl    $0x2,%edx
    cf3b:	01 d0                	add    %edx,%eax
    cf3d:	8b 10                	mov    (%eax),%edx
    cf3f:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf42:	8b 40 40             	mov    0x40(%eax),%eax
    cf45:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    cf48:	c1 e1 02             	shl    $0x2,%ecx
    cf4b:	01 c8                	add    %ecx,%eax
    cf4d:	8b 00                	mov    (%eax),%eax
    cf4f:	83 ec 04             	sub    $0x4,%esp
    cf52:	52                   	push   %edx
    cf53:	50                   	push   %eax
    cf54:	ff 75 08             	pushl  0x8(%ebp)
    cf57:	e8 4d 01 00 00       	call   d0a9 <lodepng_add_text>
    cf5c:	83 c4 10             	add    $0x10,%esp
    cf5f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    cf62:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cf66:	74 05                	je     cf6d <LodePNGText_copy+0x72>
    cf68:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf6b:	eb 14                	jmp    cf81 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    cf6d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cf71:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf74:	8b 40 3c             	mov    0x3c(%eax),%eax
    cf77:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    cf7a:	75 b3                	jne    cf2f <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    cf7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    cf81:	c9                   	leave  
    cf82:	c3                   	ret    

0000cf83 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    cf83:	55                   	push   %ebp
    cf84:	89 e5                	mov    %esp,%ebp
    cf86:	53                   	push   %ebx
    cf87:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    cf8a:	8b 45 08             	mov    0x8(%ebp),%eax
    cf8d:	8b 40 3c             	mov    0x3c(%eax),%eax
    cf90:	83 c0 01             	add    $0x1,%eax
    cf93:	c1 e0 02             	shl    $0x2,%eax
    cf96:	89 c2                	mov    %eax,%edx
    cf98:	8b 45 08             	mov    0x8(%ebp),%eax
    cf9b:	8b 40 40             	mov    0x40(%eax),%eax
    cf9e:	52                   	push   %edx
    cf9f:	50                   	push   %eax
    cfa0:	e8 9b 9f ff ff       	call   6f40 <lodepng_realloc>
    cfa5:	83 c4 08             	add    $0x8,%esp
    cfa8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    cfab:	8b 45 08             	mov    0x8(%ebp),%eax
    cfae:	8b 40 3c             	mov    0x3c(%eax),%eax
    cfb1:	83 c0 01             	add    $0x1,%eax
    cfb4:	c1 e0 02             	shl    $0x2,%eax
    cfb7:	89 c2                	mov    %eax,%edx
    cfb9:	8b 45 08             	mov    0x8(%ebp),%eax
    cfbc:	8b 40 44             	mov    0x44(%eax),%eax
    cfbf:	52                   	push   %edx
    cfc0:	50                   	push   %eax
    cfc1:	e8 7a 9f ff ff       	call   6f40 <lodepng_realloc>
    cfc6:	83 c4 08             	add    $0x8,%esp
    cfc9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    cfcc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    cfd0:	74 09                	je     cfdb <lodepng_add_text_sized+0x58>
    cfd2:	8b 45 08             	mov    0x8(%ebp),%eax
    cfd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    cfd8:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    cfdb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cfdf:	74 09                	je     cfea <lodepng_add_text_sized+0x67>
    cfe1:	8b 45 08             	mov    0x8(%ebp),%eax
    cfe4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    cfe7:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    cfea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    cfee:	74 06                	je     cff6 <lodepng_add_text_sized+0x73>
    cff0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cff4:	75 0a                	jne    d000 <lodepng_add_text_sized+0x7d>
    cff6:	b8 53 00 00 00       	mov    $0x53,%eax
    cffb:	e9 a4 00 00 00       	jmp    d0a4 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    d000:	8b 45 08             	mov    0x8(%ebp),%eax
    d003:	8b 40 3c             	mov    0x3c(%eax),%eax
    d006:	8d 50 01             	lea    0x1(%eax),%edx
    d009:	8b 45 08             	mov    0x8(%ebp),%eax
    d00c:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    d00f:	8b 45 08             	mov    0x8(%ebp),%eax
    d012:	8b 50 40             	mov    0x40(%eax),%edx
    d015:	8b 45 08             	mov    0x8(%ebp),%eax
    d018:	8b 40 3c             	mov    0x3c(%eax),%eax
    d01b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    d020:	c1 e0 02             	shl    $0x2,%eax
    d023:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d026:	83 ec 0c             	sub    $0xc,%esp
    d029:	ff 75 0c             	pushl  0xc(%ebp)
    d02c:	e8 54 a2 ff ff       	call   7285 <alloc_string>
    d031:	83 c4 10             	add    $0x10,%esp
    d034:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    d036:	8b 45 08             	mov    0x8(%ebp),%eax
    d039:	8b 50 44             	mov    0x44(%eax),%edx
    d03c:	8b 45 08             	mov    0x8(%ebp),%eax
    d03f:	8b 40 3c             	mov    0x3c(%eax),%eax
    d042:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    d047:	c1 e0 02             	shl    $0x2,%eax
    d04a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d04d:	83 ec 08             	sub    $0x8,%esp
    d050:	ff 75 14             	pushl  0x14(%ebp)
    d053:	ff 75 10             	pushl  0x10(%ebp)
    d056:	e8 e5 a1 ff ff       	call   7240 <alloc_string_sized>
    d05b:	83 c4 10             	add    $0x10,%esp
    d05e:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    d060:	8b 45 08             	mov    0x8(%ebp),%eax
    d063:	8b 50 40             	mov    0x40(%eax),%edx
    d066:	8b 45 08             	mov    0x8(%ebp),%eax
    d069:	8b 40 3c             	mov    0x3c(%eax),%eax
    d06c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    d071:	c1 e0 02             	shl    $0x2,%eax
    d074:	01 d0                	add    %edx,%eax
    d076:	8b 00                	mov    (%eax),%eax
    d078:	85 c0                	test   %eax,%eax
    d07a:	74 1c                	je     d098 <lodepng_add_text_sized+0x115>
    d07c:	8b 45 08             	mov    0x8(%ebp),%eax
    d07f:	8b 50 44             	mov    0x44(%eax),%edx
    d082:	8b 45 08             	mov    0x8(%ebp),%eax
    d085:	8b 40 3c             	mov    0x3c(%eax),%eax
    d088:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    d08d:	c1 e0 02             	shl    $0x2,%eax
    d090:	01 d0                	add    %edx,%eax
    d092:	8b 00                	mov    (%eax),%eax
    d094:	85 c0                	test   %eax,%eax
    d096:	75 07                	jne    d09f <lodepng_add_text_sized+0x11c>
    d098:	b8 53 00 00 00       	mov    $0x53,%eax
    d09d:	eb 05                	jmp    d0a4 <lodepng_add_text_sized+0x121>

  return 0;
    d09f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d0a4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    d0a7:	c9                   	leave  
    d0a8:	c3                   	ret    

0000d0a9 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    d0a9:	55                   	push   %ebp
    d0aa:	89 e5                	mov    %esp,%ebp
    d0ac:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    d0af:	ff 75 10             	pushl  0x10(%ebp)
    d0b2:	e8 0e 9f ff ff       	call   6fc5 <lodepng_strlen>
    d0b7:	83 c4 04             	add    $0x4,%esp
    d0ba:	50                   	push   %eax
    d0bb:	ff 75 10             	pushl  0x10(%ebp)
    d0be:	ff 75 0c             	pushl  0xc(%ebp)
    d0c1:	ff 75 08             	pushl  0x8(%ebp)
    d0c4:	e8 ba fe ff ff       	call   cf83 <lodepng_add_text_sized>
    d0c9:	83 c4 10             	add    $0x10,%esp
}
    d0cc:	c9                   	leave  
    d0cd:	c3                   	ret    

0000d0ce <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    d0ce:	55                   	push   %ebp
    d0cf:	89 e5                	mov    %esp,%ebp
    d0d1:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    d0d4:	83 ec 0c             	sub    $0xc,%esp
    d0d7:	ff 75 08             	pushl  0x8(%ebp)
    d0da:	e8 a3 fd ff ff       	call   ce82 <LodePNGText_cleanup>
    d0df:	83 c4 10             	add    $0x10,%esp
}
    d0e2:	90                   	nop
    d0e3:	c9                   	leave  
    d0e4:	c3                   	ret    

0000d0e5 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    d0e5:	55                   	push   %ebp
    d0e6:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    d0e8:	8b 45 08             	mov    0x8(%ebp),%eax
    d0eb:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    d0f2:	8b 45 08             	mov    0x8(%ebp),%eax
    d0f5:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    d0fc:	8b 45 08             	mov    0x8(%ebp),%eax
    d0ff:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    d106:	8b 45 08             	mov    0x8(%ebp),%eax
    d109:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    d110:	8b 45 08             	mov    0x8(%ebp),%eax
    d113:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    d11a:	90                   	nop
    d11b:	5d                   	pop    %ebp
    d11c:	c3                   	ret    

0000d11d <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    d11d:	55                   	push   %ebp
    d11e:	89 e5                	mov    %esp,%ebp
    d120:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    d123:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d12a:	eb 6c                	jmp    d198 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    d12c:	8b 45 08             	mov    0x8(%ebp),%eax
    d12f:	8b 40 4c             	mov    0x4c(%eax),%eax
    d132:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d135:	c1 e2 02             	shl    $0x2,%edx
    d138:	01 d0                	add    %edx,%eax
    d13a:	83 ec 0c             	sub    $0xc,%esp
    d13d:	50                   	push   %eax
    d13e:	e8 da a0 ff ff       	call   721d <string_cleanup>
    d143:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    d146:	8b 45 08             	mov    0x8(%ebp),%eax
    d149:	8b 40 50             	mov    0x50(%eax),%eax
    d14c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d14f:	c1 e2 02             	shl    $0x2,%edx
    d152:	01 d0                	add    %edx,%eax
    d154:	83 ec 0c             	sub    $0xc,%esp
    d157:	50                   	push   %eax
    d158:	e8 c0 a0 ff ff       	call   721d <string_cleanup>
    d15d:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    d160:	8b 45 08             	mov    0x8(%ebp),%eax
    d163:	8b 40 54             	mov    0x54(%eax),%eax
    d166:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d169:	c1 e2 02             	shl    $0x2,%edx
    d16c:	01 d0                	add    %edx,%eax
    d16e:	83 ec 0c             	sub    $0xc,%esp
    d171:	50                   	push   %eax
    d172:	e8 a6 a0 ff ff       	call   721d <string_cleanup>
    d177:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    d17a:	8b 45 08             	mov    0x8(%ebp),%eax
    d17d:	8b 40 58             	mov    0x58(%eax),%eax
    d180:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d183:	c1 e2 02             	shl    $0x2,%edx
    d186:	01 d0                	add    %edx,%eax
    d188:	83 ec 0c             	sub    $0xc,%esp
    d18b:	50                   	push   %eax
    d18c:	e8 8c a0 ff ff       	call   721d <string_cleanup>
    d191:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    d194:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d198:	8b 45 08             	mov    0x8(%ebp),%eax
    d19b:	8b 40 48             	mov    0x48(%eax),%eax
    d19e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    d1a1:	75 89                	jne    d12c <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    d1a3:	8b 45 08             	mov    0x8(%ebp),%eax
    d1a6:	8b 40 4c             	mov    0x4c(%eax),%eax
    d1a9:	83 ec 0c             	sub    $0xc,%esp
    d1ac:	50                   	push   %eax
    d1ad:	e8 98 9d ff ff       	call   6f4a <lodepng_free>
    d1b2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    d1b5:	8b 45 08             	mov    0x8(%ebp),%eax
    d1b8:	8b 40 50             	mov    0x50(%eax),%eax
    d1bb:	83 ec 0c             	sub    $0xc,%esp
    d1be:	50                   	push   %eax
    d1bf:	e8 86 9d ff ff       	call   6f4a <lodepng_free>
    d1c4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    d1c7:	8b 45 08             	mov    0x8(%ebp),%eax
    d1ca:	8b 40 54             	mov    0x54(%eax),%eax
    d1cd:	83 ec 0c             	sub    $0xc,%esp
    d1d0:	50                   	push   %eax
    d1d1:	e8 74 9d ff ff       	call   6f4a <lodepng_free>
    d1d6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    d1d9:	8b 45 08             	mov    0x8(%ebp),%eax
    d1dc:	8b 40 58             	mov    0x58(%eax),%eax
    d1df:	83 ec 0c             	sub    $0xc,%esp
    d1e2:	50                   	push   %eax
    d1e3:	e8 62 9d ff ff       	call   6f4a <lodepng_free>
    d1e8:	83 c4 10             	add    $0x10,%esp
}
    d1eb:	90                   	nop
    d1ec:	c9                   	leave  
    d1ed:	c3                   	ret    

0000d1ee <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    d1ee:	55                   	push   %ebp
    d1ef:	89 e5                	mov    %esp,%ebp
    d1f1:	56                   	push   %esi
    d1f2:	53                   	push   %ebx
    d1f3:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    d1f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    d1fd:	8b 45 08             	mov    0x8(%ebp),%eax
    d200:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    d207:	8b 45 08             	mov    0x8(%ebp),%eax
    d20a:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    d211:	8b 45 08             	mov    0x8(%ebp),%eax
    d214:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    d21b:	8b 45 08             	mov    0x8(%ebp),%eax
    d21e:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    d225:	8b 45 08             	mov    0x8(%ebp),%eax
    d228:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    d22f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d236:	eb 64                	jmp    d29c <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    d238:	8b 45 0c             	mov    0xc(%ebp),%eax
    d23b:	8b 40 58             	mov    0x58(%eax),%eax
    d23e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d241:	c1 e2 02             	shl    $0x2,%edx
    d244:	01 d0                	add    %edx,%eax
    d246:	8b 18                	mov    (%eax),%ebx
    d248:	8b 45 0c             	mov    0xc(%ebp),%eax
    d24b:	8b 40 54             	mov    0x54(%eax),%eax
    d24e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d251:	c1 e2 02             	shl    $0x2,%edx
    d254:	01 d0                	add    %edx,%eax
    d256:	8b 08                	mov    (%eax),%ecx
    d258:	8b 45 0c             	mov    0xc(%ebp),%eax
    d25b:	8b 40 50             	mov    0x50(%eax),%eax
    d25e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d261:	c1 e2 02             	shl    $0x2,%edx
    d264:	01 d0                	add    %edx,%eax
    d266:	8b 10                	mov    (%eax),%edx
    d268:	8b 45 0c             	mov    0xc(%ebp),%eax
    d26b:	8b 40 4c             	mov    0x4c(%eax),%eax
    d26e:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d271:	c1 e6 02             	shl    $0x2,%esi
    d274:	01 f0                	add    %esi,%eax
    d276:	8b 00                	mov    (%eax),%eax
    d278:	83 ec 0c             	sub    $0xc,%esp
    d27b:	53                   	push   %ebx
    d27c:	51                   	push   %ecx
    d27d:	52                   	push   %edx
    d27e:	50                   	push   %eax
    d27f:	ff 75 08             	pushl  0x8(%ebp)
    d282:	e8 e4 01 00 00       	call   d46b <lodepng_add_itext>
    d287:	83 c4 20             	add    $0x20,%esp
    d28a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    d28d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d291:	74 05                	je     d298 <LodePNGIText_copy+0xaa>
    d293:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d296:	eb 14                	jmp    d2ac <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    d298:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d29c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d29f:	8b 40 48             	mov    0x48(%eax),%eax
    d2a2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    d2a5:	75 91                	jne    d238 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    d2a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d2ac:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d2af:	5b                   	pop    %ebx
    d2b0:	5e                   	pop    %esi
    d2b1:	5d                   	pop    %ebp
    d2b2:	c3                   	ret    

0000d2b3 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    d2b3:	55                   	push   %ebp
    d2b4:	89 e5                	mov    %esp,%ebp
    d2b6:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    d2b9:	83 ec 0c             	sub    $0xc,%esp
    d2bc:	ff 75 08             	pushl  0x8(%ebp)
    d2bf:	e8 59 fe ff ff       	call   d11d <LodePNGIText_cleanup>
    d2c4:	83 c4 10             	add    $0x10,%esp
}
    d2c7:	90                   	nop
    d2c8:	c9                   	leave  
    d2c9:	c3                   	ret    

0000d2ca <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    d2ca:	55                   	push   %ebp
    d2cb:	89 e5                	mov    %esp,%ebp
    d2cd:	53                   	push   %ebx
    d2ce:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    d2d1:	8b 45 08             	mov    0x8(%ebp),%eax
    d2d4:	8b 40 48             	mov    0x48(%eax),%eax
    d2d7:	83 c0 01             	add    $0x1,%eax
    d2da:	c1 e0 02             	shl    $0x2,%eax
    d2dd:	89 c2                	mov    %eax,%edx
    d2df:	8b 45 08             	mov    0x8(%ebp),%eax
    d2e2:	8b 40 4c             	mov    0x4c(%eax),%eax
    d2e5:	52                   	push   %edx
    d2e6:	50                   	push   %eax
    d2e7:	e8 54 9c ff ff       	call   6f40 <lodepng_realloc>
    d2ec:	83 c4 08             	add    $0x8,%esp
    d2ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    d2f2:	8b 45 08             	mov    0x8(%ebp),%eax
    d2f5:	8b 40 48             	mov    0x48(%eax),%eax
    d2f8:	83 c0 01             	add    $0x1,%eax
    d2fb:	c1 e0 02             	shl    $0x2,%eax
    d2fe:	89 c2                	mov    %eax,%edx
    d300:	8b 45 08             	mov    0x8(%ebp),%eax
    d303:	8b 40 50             	mov    0x50(%eax),%eax
    d306:	52                   	push   %edx
    d307:	50                   	push   %eax
    d308:	e8 33 9c ff ff       	call   6f40 <lodepng_realloc>
    d30d:	83 c4 08             	add    $0x8,%esp
    d310:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    d313:	8b 45 08             	mov    0x8(%ebp),%eax
    d316:	8b 40 48             	mov    0x48(%eax),%eax
    d319:	83 c0 01             	add    $0x1,%eax
    d31c:	c1 e0 02             	shl    $0x2,%eax
    d31f:	89 c2                	mov    %eax,%edx
    d321:	8b 45 08             	mov    0x8(%ebp),%eax
    d324:	8b 40 54             	mov    0x54(%eax),%eax
    d327:	52                   	push   %edx
    d328:	50                   	push   %eax
    d329:	e8 12 9c ff ff       	call   6f40 <lodepng_realloc>
    d32e:	83 c4 08             	add    $0x8,%esp
    d331:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    d334:	8b 45 08             	mov    0x8(%ebp),%eax
    d337:	8b 40 48             	mov    0x48(%eax),%eax
    d33a:	83 c0 01             	add    $0x1,%eax
    d33d:	c1 e0 02             	shl    $0x2,%eax
    d340:	89 c2                	mov    %eax,%edx
    d342:	8b 45 08             	mov    0x8(%ebp),%eax
    d345:	8b 40 58             	mov    0x58(%eax),%eax
    d348:	52                   	push   %edx
    d349:	50                   	push   %eax
    d34a:	e8 f1 9b ff ff       	call   6f40 <lodepng_realloc>
    d34f:	83 c4 08             	add    $0x8,%esp
    d352:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    d355:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d359:	74 09                	je     d364 <lodepng_add_itext_sized+0x9a>
    d35b:	8b 45 08             	mov    0x8(%ebp),%eax
    d35e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d361:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    d364:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d368:	74 09                	je     d373 <lodepng_add_itext_sized+0xa9>
    d36a:	8b 45 08             	mov    0x8(%ebp),%eax
    d36d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d370:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    d373:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d377:	74 09                	je     d382 <lodepng_add_itext_sized+0xb8>
    d379:	8b 45 08             	mov    0x8(%ebp),%eax
    d37c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d37f:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    d382:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d386:	74 09                	je     d391 <lodepng_add_itext_sized+0xc7>
    d388:	8b 45 08             	mov    0x8(%ebp),%eax
    d38b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    d38e:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    d391:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d395:	74 12                	je     d3a9 <lodepng_add_itext_sized+0xdf>
    d397:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d39b:	74 0c                	je     d3a9 <lodepng_add_itext_sized+0xdf>
    d39d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d3a1:	74 06                	je     d3a9 <lodepng_add_itext_sized+0xdf>
    d3a3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d3a7:	75 0a                	jne    d3b3 <lodepng_add_itext_sized+0xe9>
    d3a9:	b8 53 00 00 00       	mov    $0x53,%eax
    d3ae:	e9 b3 00 00 00       	jmp    d466 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    d3b3:	8b 45 08             	mov    0x8(%ebp),%eax
    d3b6:	8b 40 48             	mov    0x48(%eax),%eax
    d3b9:	8d 50 01             	lea    0x1(%eax),%edx
    d3bc:	8b 45 08             	mov    0x8(%ebp),%eax
    d3bf:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    d3c2:	8b 45 08             	mov    0x8(%ebp),%eax
    d3c5:	8b 50 4c             	mov    0x4c(%eax),%edx
    d3c8:	8b 45 08             	mov    0x8(%ebp),%eax
    d3cb:	8b 40 48             	mov    0x48(%eax),%eax
    d3ce:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    d3d3:	c1 e0 02             	shl    $0x2,%eax
    d3d6:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d3d9:	83 ec 0c             	sub    $0xc,%esp
    d3dc:	ff 75 0c             	pushl  0xc(%ebp)
    d3df:	e8 a1 9e ff ff       	call   7285 <alloc_string>
    d3e4:	83 c4 10             	add    $0x10,%esp
    d3e7:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    d3e9:	8b 45 08             	mov    0x8(%ebp),%eax
    d3ec:	8b 50 50             	mov    0x50(%eax),%edx
    d3ef:	8b 45 08             	mov    0x8(%ebp),%eax
    d3f2:	8b 40 48             	mov    0x48(%eax),%eax
    d3f5:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    d3fa:	c1 e0 02             	shl    $0x2,%eax
    d3fd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d400:	83 ec 0c             	sub    $0xc,%esp
    d403:	ff 75 10             	pushl  0x10(%ebp)
    d406:	e8 7a 9e ff ff       	call   7285 <alloc_string>
    d40b:	83 c4 10             	add    $0x10,%esp
    d40e:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    d410:	8b 45 08             	mov    0x8(%ebp),%eax
    d413:	8b 50 54             	mov    0x54(%eax),%edx
    d416:	8b 45 08             	mov    0x8(%ebp),%eax
    d419:	8b 40 48             	mov    0x48(%eax),%eax
    d41c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    d421:	c1 e0 02             	shl    $0x2,%eax
    d424:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d427:	83 ec 0c             	sub    $0xc,%esp
    d42a:	ff 75 14             	pushl  0x14(%ebp)
    d42d:	e8 53 9e ff ff       	call   7285 <alloc_string>
    d432:	83 c4 10             	add    $0x10,%esp
    d435:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    d437:	8b 45 08             	mov    0x8(%ebp),%eax
    d43a:	8b 50 58             	mov    0x58(%eax),%edx
    d43d:	8b 45 08             	mov    0x8(%ebp),%eax
    d440:	8b 40 48             	mov    0x48(%eax),%eax
    d443:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    d448:	c1 e0 02             	shl    $0x2,%eax
    d44b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d44e:	83 ec 08             	sub    $0x8,%esp
    d451:	ff 75 1c             	pushl  0x1c(%ebp)
    d454:	ff 75 18             	pushl  0x18(%ebp)
    d457:	e8 e4 9d ff ff       	call   7240 <alloc_string_sized>
    d45c:	83 c4 10             	add    $0x10,%esp
    d45f:	89 03                	mov    %eax,(%ebx)

  return 0;
    d461:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d466:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    d469:	c9                   	leave  
    d46a:	c3                   	ret    

0000d46b <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    d46b:	55                   	push   %ebp
    d46c:	89 e5                	mov    %esp,%ebp
    d46e:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    d471:	ff 75 18             	pushl  0x18(%ebp)
    d474:	e8 4c 9b ff ff       	call   6fc5 <lodepng_strlen>
    d479:	83 c4 04             	add    $0x4,%esp
    d47c:	83 ec 08             	sub    $0x8,%esp
    d47f:	50                   	push   %eax
    d480:	ff 75 18             	pushl  0x18(%ebp)
    d483:	ff 75 14             	pushl  0x14(%ebp)
    d486:	ff 75 10             	pushl  0x10(%ebp)
    d489:	ff 75 0c             	pushl  0xc(%ebp)
    d48c:	ff 75 08             	pushl  0x8(%ebp)
    d48f:	e8 36 fe ff ff       	call   d2ca <lodepng_add_itext_sized>
    d494:	83 c4 20             	add    $0x20,%esp
}
    d497:	c9                   	leave  
    d498:	c3                   	ret    

0000d499 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    d499:	55                   	push   %ebp
    d49a:	89 e5                	mov    %esp,%ebp
    d49c:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    d49f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d4a3:	75 0a                	jne    d4af <lodepng_assign_icc+0x16>
    d4a5:	b8 64 00 00 00       	mov    $0x64,%eax
    d4aa:	e9 81 00 00 00       	jmp    d530 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    d4af:	83 ec 0c             	sub    $0xc,%esp
    d4b2:	ff 75 0c             	pushl  0xc(%ebp)
    d4b5:	e8 cb 9d ff ff       	call   7285 <alloc_string>
    d4ba:	83 c4 10             	add    $0x10,%esp
    d4bd:	89 c2                	mov    %eax,%edx
    d4bf:	8b 45 08             	mov    0x8(%ebp),%eax
    d4c2:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    d4c8:	8b 45 14             	mov    0x14(%ebp),%eax
    d4cb:	83 ec 0c             	sub    $0xc,%esp
    d4ce:	50                   	push   %eax
    d4cf:	e8 55 9a ff ff       	call   6f29 <lodepng_malloc>
    d4d4:	83 c4 10             	add    $0x10,%esp
    d4d7:	89 c2                	mov    %eax,%edx
    d4d9:	8b 45 08             	mov    0x8(%ebp),%eax
    d4dc:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    d4e2:	8b 45 08             	mov    0x8(%ebp),%eax
    d4e5:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    d4eb:	85 c0                	test   %eax,%eax
    d4ed:	74 0d                	je     d4fc <lodepng_assign_icc+0x63>
    d4ef:	8b 45 08             	mov    0x8(%ebp),%eax
    d4f2:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    d4f8:	85 c0                	test   %eax,%eax
    d4fa:	75 07                	jne    d503 <lodepng_assign_icc+0x6a>
    d4fc:	b8 53 00 00 00       	mov    $0x53,%eax
    d501:	eb 2d                	jmp    d530 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    d503:	8b 55 14             	mov    0x14(%ebp),%edx
    d506:	8b 45 08             	mov    0x8(%ebp),%eax
    d509:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    d50f:	83 ec 04             	sub    $0x4,%esp
    d512:	52                   	push   %edx
    d513:	ff 75 10             	pushl  0x10(%ebp)
    d516:	50                   	push   %eax
    d517:	e8 4b 9a ff ff       	call   6f67 <lodepng_memcpy>
    d51c:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    d51f:	8b 45 08             	mov    0x8(%ebp),%eax
    d522:	8b 55 14             	mov    0x14(%ebp),%edx
    d525:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    d52b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d530:	c9                   	leave  
    d531:	c3                   	ret    

0000d532 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    d532:	55                   	push   %ebp
    d533:	89 e5                	mov    %esp,%ebp
    d535:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    d538:	8b 45 08             	mov    0x8(%ebp),%eax
    d53b:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    d541:	85 c0                	test   %eax,%eax
    d543:	74 0e                	je     d553 <lodepng_set_icc+0x21>
    d545:	83 ec 0c             	sub    $0xc,%esp
    d548:	ff 75 08             	pushl  0x8(%ebp)
    d54b:	e8 26 00 00 00       	call   d576 <lodepng_clear_icc>
    d550:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    d553:	8b 45 08             	mov    0x8(%ebp),%eax
    d556:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    d55d:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    d560:	ff 75 14             	pushl  0x14(%ebp)
    d563:	ff 75 10             	pushl  0x10(%ebp)
    d566:	ff 75 0c             	pushl  0xc(%ebp)
    d569:	ff 75 08             	pushl  0x8(%ebp)
    d56c:	e8 28 ff ff ff       	call   d499 <lodepng_assign_icc>
    d571:	83 c4 10             	add    $0x10,%esp
}
    d574:	c9                   	leave  
    d575:	c3                   	ret    

0000d576 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    d576:	55                   	push   %ebp
    d577:	89 e5                	mov    %esp,%ebp
    d579:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    d57c:	8b 45 08             	mov    0x8(%ebp),%eax
    d57f:	05 c0 00 00 00       	add    $0xc0,%eax
    d584:	83 ec 0c             	sub    $0xc,%esp
    d587:	50                   	push   %eax
    d588:	e8 90 9c ff ff       	call   721d <string_cleanup>
    d58d:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    d590:	8b 45 08             	mov    0x8(%ebp),%eax
    d593:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    d599:	83 ec 0c             	sub    $0xc,%esp
    d59c:	50                   	push   %eax
    d59d:	e8 a8 99 ff ff       	call   6f4a <lodepng_free>
    d5a2:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    d5a5:	8b 45 08             	mov    0x8(%ebp),%eax
    d5a8:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    d5af:	00 00 00 
  info->iccp_profile_size = 0;
    d5b2:	8b 45 08             	mov    0x8(%ebp),%eax
    d5b5:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    d5bc:	00 00 00 
  info->iccp_defined = 0;
    d5bf:	8b 45 08             	mov    0x8(%ebp),%eax
    d5c2:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    d5c9:	00 00 00 
}
    d5cc:	90                   	nop
    d5cd:	c9                   	leave  
    d5ce:	c3                   	ret    

0000d5cf <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    d5cf:	55                   	push   %ebp
    d5d0:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    d5d2:	8b 45 08             	mov    0x8(%ebp),%eax
    d5d5:	83 c0 0c             	add    $0xc,%eax
    d5d8:	50                   	push   %eax
    d5d9:	e8 5a f0 ff ff       	call   c638 <lodepng_color_mode_init>
    d5de:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    d5e1:	8b 45 08             	mov    0x8(%ebp),%eax
    d5e4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    d5eb:	8b 45 08             	mov    0x8(%ebp),%eax
    d5ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    d5f4:	8b 45 08             	mov    0x8(%ebp),%eax
    d5f7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    d5fe:	8b 45 08             	mov    0x8(%ebp),%eax
    d601:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    d608:	8b 45 08             	mov    0x8(%ebp),%eax
    d60b:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    d612:	8b 45 08             	mov    0x8(%ebp),%eax
    d615:	8b 50 38             	mov    0x38(%eax),%edx
    d618:	8b 45 08             	mov    0x8(%ebp),%eax
    d61b:	89 50 34             	mov    %edx,0x34(%eax)
    d61e:	8b 45 08             	mov    0x8(%ebp),%eax
    d621:	8b 50 34             	mov    0x34(%eax),%edx
    d624:	8b 45 08             	mov    0x8(%ebp),%eax
    d627:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    d62a:	ff 75 08             	pushl  0x8(%ebp)
    d62d:	e8 2c f8 ff ff       	call   ce5e <LodePNGText_init>
    d632:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    d635:	ff 75 08             	pushl  0x8(%ebp)
    d638:	e8 a8 fa ff ff       	call   d0e5 <LodePNGIText_init>
    d63d:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    d640:	8b 45 08             	mov    0x8(%ebp),%eax
    d643:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    d64a:	8b 45 08             	mov    0x8(%ebp),%eax
    d64d:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    d654:	8b 45 08             	mov    0x8(%ebp),%eax
    d657:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    d65e:	00 00 00 
  info->chrm_defined = 0;
    d661:	8b 45 08             	mov    0x8(%ebp),%eax
    d664:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    d66b:	00 00 00 
  info->srgb_defined = 0;
    d66e:	8b 45 08             	mov    0x8(%ebp),%eax
    d671:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    d678:	00 00 00 
  info->iccp_defined = 0;
    d67b:	8b 45 08             	mov    0x8(%ebp),%eax
    d67e:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    d685:	00 00 00 
  info->iccp_name = NULL;
    d688:	8b 45 08             	mov    0x8(%ebp),%eax
    d68b:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    d692:	00 00 00 
  info->iccp_profile = NULL;
    d695:	8b 45 08             	mov    0x8(%ebp),%eax
    d698:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    d69f:	00 00 00 

  LodePNGUnknownChunks_init(info);
    d6a2:	ff 75 08             	pushl  0x8(%ebp)
    d6a5:	e8 46 f6 ff ff       	call   ccf0 <LodePNGUnknownChunks_init>
    d6aa:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    d6ad:	90                   	nop
    d6ae:	c9                   	leave  
    d6af:	c3                   	ret    

0000d6b0 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    d6b0:	55                   	push   %ebp
    d6b1:	89 e5                	mov    %esp,%ebp
    d6b3:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    d6b6:	8b 45 08             	mov    0x8(%ebp),%eax
    d6b9:	83 c0 0c             	add    $0xc,%eax
    d6bc:	83 ec 0c             	sub    $0xc,%esp
    d6bf:	50                   	push   %eax
    d6c0:	e8 66 f0 ff ff       	call   c72b <lodepng_color_mode_cleanup>
    d6c5:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    d6c8:	83 ec 0c             	sub    $0xc,%esp
    d6cb:	ff 75 08             	pushl  0x8(%ebp)
    d6ce:	e8 af f7 ff ff       	call   ce82 <LodePNGText_cleanup>
    d6d3:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    d6d6:	83 ec 0c             	sub    $0xc,%esp
    d6d9:	ff 75 08             	pushl  0x8(%ebp)
    d6dc:	e8 3c fa ff ff       	call   d11d <LodePNGIText_cleanup>
    d6e1:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    d6e4:	83 ec 0c             	sub    $0xc,%esp
    d6e7:	ff 75 08             	pushl  0x8(%ebp)
    d6ea:	e8 87 fe ff ff       	call   d576 <lodepng_clear_icc>
    d6ef:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    d6f2:	83 ec 0c             	sub    $0xc,%esp
    d6f5:	ff 75 08             	pushl  0x8(%ebp)
    d6f8:	e8 44 f6 ff ff       	call   cd41 <LodePNGUnknownChunks_cleanup>
    d6fd:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    d700:	90                   	nop
    d701:	c9                   	leave  
    d702:	c3                   	ret    

0000d703 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    d703:	55                   	push   %ebp
    d704:	89 e5                	mov    %esp,%ebp
    d706:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    d709:	83 ec 0c             	sub    $0xc,%esp
    d70c:	ff 75 08             	pushl  0x8(%ebp)
    d70f:	e8 9c ff ff ff       	call   d6b0 <lodepng_info_cleanup>
    d714:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    d717:	83 ec 04             	sub    $0x4,%esp
    d71a:	68 e4 00 00 00       	push   $0xe4
    d71f:	ff 75 0c             	pushl  0xc(%ebp)
    d722:	ff 75 08             	pushl  0x8(%ebp)
    d725:	e8 3d 98 ff ff       	call   6f67 <lodepng_memcpy>
    d72a:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    d72d:	8b 45 08             	mov    0x8(%ebp),%eax
    d730:	83 c0 0c             	add    $0xc,%eax
    d733:	83 ec 0c             	sub    $0xc,%esp
    d736:	50                   	push   %eax
    d737:	e8 fc ee ff ff       	call   c638 <lodepng_color_mode_init>
    d73c:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    d73f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d742:	8d 50 0c             	lea    0xc(%eax),%edx
    d745:	8b 45 08             	mov    0x8(%ebp),%eax
    d748:	83 c0 0c             	add    $0xc,%eax
    d74b:	83 ec 08             	sub    $0x8,%esp
    d74e:	52                   	push   %edx
    d74f:	50                   	push   %eax
    d750:	e8 ed ef ff ff       	call   c742 <lodepng_color_mode_copy>
    d755:	83 c4 10             	add    $0x10,%esp
    d758:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d75b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d75f:	74 08                	je     d769 <lodepng_info_copy+0x66>
    d761:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d764:	e9 b7 00 00 00       	jmp    d820 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    d769:	83 ec 08             	sub    $0x8,%esp
    d76c:	ff 75 0c             	pushl  0xc(%ebp)
    d76f:	ff 75 08             	pushl  0x8(%ebp)
    d772:	e8 84 f7 ff ff       	call   cefb <LodePNGText_copy>
    d777:	83 c4 10             	add    $0x10,%esp
    d77a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    d77d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d781:	74 08                	je     d78b <lodepng_info_copy+0x88>
    d783:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d786:	e9 95 00 00 00       	jmp    d820 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    d78b:	83 ec 08             	sub    $0x8,%esp
    d78e:	ff 75 0c             	pushl  0xc(%ebp)
    d791:	ff 75 08             	pushl  0x8(%ebp)
    d794:	e8 55 fa ff ff       	call   d1ee <LodePNGIText_copy>
    d799:	83 c4 10             	add    $0x10,%esp
    d79c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    d79f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d7a3:	74 05                	je     d7aa <lodepng_info_copy+0xa7>
    d7a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    d7a8:	eb 76                	jmp    d820 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    d7aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7ad:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    d7b3:	85 c0                	test   %eax,%eax
    d7b5:	74 37                	je     d7ee <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    d7b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7ba:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    d7c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7c3:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    d7c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7cc:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    d7d2:	51                   	push   %ecx
    d7d3:	52                   	push   %edx
    d7d4:	50                   	push   %eax
    d7d5:	ff 75 08             	pushl  0x8(%ebp)
    d7d8:	e8 bc fc ff ff       	call   d499 <lodepng_assign_icc>
    d7dd:	83 c4 10             	add    $0x10,%esp
    d7e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    d7e3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d7e7:	74 05                	je     d7ee <lodepng_info_copy+0xeb>
    d7e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d7ec:	eb 32                	jmp    d820 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    d7ee:	83 ec 0c             	sub    $0xc,%esp
    d7f1:	ff 75 08             	pushl  0x8(%ebp)
    d7f4:	e8 f7 f4 ff ff       	call   ccf0 <LodePNGUnknownChunks_init>
    d7f9:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    d7fc:	83 ec 08             	sub    $0x8,%esp
    d7ff:	ff 75 0c             	pushl  0xc(%ebp)
    d802:	ff 75 08             	pushl  0x8(%ebp)
    d805:	e8 6c f5 ff ff       	call   cd76 <LodePNGUnknownChunks_copy>
    d80a:	83 c4 10             	add    $0x10,%esp
    d80d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    d810:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d814:	74 05                	je     d81b <lodepng_info_copy+0x118>
    d816:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d819:	eb 05                	jmp    d820 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    d81b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    d820:	c9                   	leave  
    d821:	c3                   	ret    

0000d822 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    d822:	55                   	push   %ebp
    d823:	89 e5                	mov    %esp,%ebp
    d825:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    d828:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    d82c:	74 14                	je     d842 <addColorBits+0x20>
    d82e:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    d832:	75 07                	jne    d83b <addColorBits+0x19>
    d834:	b8 03 00 00 00       	mov    $0x3,%eax
    d839:	eb 0c                	jmp    d847 <addColorBits+0x25>
    d83b:	b8 01 00 00 00       	mov    $0x1,%eax
    d840:	eb 05                	jmp    d847 <addColorBits+0x25>
    d842:	b8 07 00 00 00       	mov    $0x7,%eax
    d847:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    d84a:	8b 45 0c             	mov    0xc(%ebp),%eax
    d84d:	23 45 fc             	and    -0x4(%ebp),%eax
    d850:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    d853:	8b 45 10             	mov    0x10(%ebp),%eax
    d856:	ba 01 00 00 00       	mov    $0x1,%edx
    d85b:	89 c1                	mov    %eax,%ecx
    d85d:	d3 e2                	shl    %cl,%edx
    d85f:	89 d0                	mov    %edx,%eax
    d861:	83 e8 01             	sub    $0x1,%eax
    d864:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    d867:	8b 45 fc             	mov    -0x4(%ebp),%eax
    d86a:	2b 45 f8             	sub    -0x8(%ebp),%eax
    d86d:	0f af 45 10          	imul   0x10(%ebp),%eax
    d871:	89 c1                	mov    %eax,%ecx
    d873:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    d876:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    d87a:	75 18                	jne    d894 <addColorBits+0x72>
    d87c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d87f:	0f af 45 10          	imul   0x10(%ebp),%eax
    d883:	c1 e8 03             	shr    $0x3,%eax
    d886:	89 c2                	mov    %eax,%edx
    d888:	8b 45 08             	mov    0x8(%ebp),%eax
    d88b:	01 d0                	add    %edx,%eax
    d88d:	8b 55 14             	mov    0x14(%ebp),%edx
    d890:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    d892:	eb 1e                	jmp    d8b2 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    d894:	8b 45 0c             	mov    0xc(%ebp),%eax
    d897:	0f af 45 10          	imul   0x10(%ebp),%eax
    d89b:	c1 e8 03             	shr    $0x3,%eax
    d89e:	8b 55 08             	mov    0x8(%ebp),%edx
    d8a1:	01 c2                	add    %eax,%edx
    d8a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d8a6:	01 c8                	add    %ecx,%eax
    d8a8:	0f b6 08             	movzbl (%eax),%ecx
    d8ab:	8b 45 14             	mov    0x14(%ebp),%eax
    d8ae:	09 c8                	or     %ecx,%eax
    d8b0:	88 02                	mov    %al,(%edx)
}
    d8b2:	90                   	nop
    d8b3:	c9                   	leave  
    d8b4:	c3                   	ret    

0000d8b5 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    d8b5:	55                   	push   %ebp
    d8b6:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    d8b8:	8b 45 08             	mov    0x8(%ebp),%eax
    d8bb:	6a 40                	push   $0x40
    d8bd:	6a 00                	push   $0x0
    d8bf:	50                   	push   %eax
    d8c0:	e8 d5 96 ff ff       	call   6f9a <lodepng_memset>
    d8c5:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    d8c8:	8b 45 08             	mov    0x8(%ebp),%eax
    d8cb:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    d8d2:	90                   	nop
    d8d3:	c9                   	leave  
    d8d4:	c3                   	ret    

0000d8d5 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    d8d5:	55                   	push   %ebp
    d8d6:	89 e5                	mov    %esp,%ebp
    d8d8:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    d8db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d8e2:	eb 3b                	jmp    d91f <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    d8e4:	8b 45 08             	mov    0x8(%ebp),%eax
    d8e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8ea:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d8ed:	85 c0                	test   %eax,%eax
    d8ef:	74 2a                	je     d91b <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    d8f1:	8b 45 08             	mov    0x8(%ebp),%eax
    d8f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8f7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d8fa:	83 ec 0c             	sub    $0xc,%esp
    d8fd:	50                   	push   %eax
    d8fe:	e8 d2 ff ff ff       	call   d8d5 <color_tree_cleanup>
    d903:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    d906:	8b 45 08             	mov    0x8(%ebp),%eax
    d909:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d90c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d90f:	83 ec 0c             	sub    $0xc,%esp
    d912:	50                   	push   %eax
    d913:	e8 32 96 ff ff       	call   6f4a <lodepng_free>
    d918:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    d91b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d91f:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    d923:	75 bf                	jne    d8e4 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    d925:	90                   	nop
    d926:	c9                   	leave  
    d927:	c3                   	ret    

0000d928 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    d928:	55                   	push   %ebp
    d929:	89 e5                	mov    %esp,%ebp
    d92b:	53                   	push   %ebx
    d92c:	83 ec 20             	sub    $0x20,%esp
    d92f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    d932:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d935:	8b 55 14             	mov    0x14(%ebp),%edx
    d938:	8b 45 18             	mov    0x18(%ebp),%eax
    d93b:	88 5d e8             	mov    %bl,-0x18(%ebp)
    d93e:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    d941:	88 55 e0             	mov    %dl,-0x20(%ebp)
    d944:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    d947:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    d94e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    d955:	eb 76                	jmp    d9cd <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    d957:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    d95b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d95e:	89 c1                	mov    %eax,%ecx
    d960:	d3 fa                	sar    %cl,%edx
    d962:	89 d0                	mov    %edx,%eax
    d964:	83 e0 01             	and    $0x1,%eax
    d967:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    d96a:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    d96e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d971:	89 c1                	mov    %eax,%ecx
    d973:	d3 fa                	sar    %cl,%edx
    d975:	89 d0                	mov    %edx,%eax
    d977:	83 e0 01             	and    $0x1,%eax
    d97a:	01 d8                	add    %ebx,%eax
    d97c:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    d97f:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    d983:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d986:	89 c1                	mov    %eax,%ecx
    d988:	d3 fa                	sar    %cl,%edx
    d98a:	89 d0                	mov    %edx,%eax
    d98c:	83 e0 01             	and    $0x1,%eax
    d98f:	01 d8                	add    %ebx,%eax
    d991:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    d994:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    d998:	8b 45 f8             	mov    -0x8(%ebp),%eax
    d99b:	89 c1                	mov    %eax,%ecx
    d99d:	d3 fa                	sar    %cl,%edx
    d99f:	89 d0                	mov    %edx,%eax
    d9a1:	83 e0 01             	and    $0x1,%eax
    d9a4:	01 d8                	add    %ebx,%eax
    d9a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    d9a9:	8b 45 08             	mov    0x8(%ebp),%eax
    d9ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d9af:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d9b2:	85 c0                	test   %eax,%eax
    d9b4:	75 07                	jne    d9bd <color_tree_get+0x95>
    d9b6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    d9bb:	eb 2a                	jmp    d9e7 <color_tree_get+0xbf>
    else tree = tree->children[i];
    d9bd:	8b 45 08             	mov    0x8(%ebp),%eax
    d9c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d9c3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    d9c6:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    d9c9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    d9cd:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    d9d1:	7e 84                	jle    d957 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    d9d3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d9d7:	74 08                	je     d9e1 <color_tree_get+0xb9>
    d9d9:	8b 45 08             	mov    0x8(%ebp),%eax
    d9dc:	8b 40 40             	mov    0x40(%eax),%eax
    d9df:	eb 05                	jmp    d9e6 <color_tree_get+0xbe>
    d9e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    d9e6:	90                   	nop
}
    d9e7:	83 c4 20             	add    $0x20,%esp
    d9ea:	5b                   	pop    %ebx
    d9eb:	5d                   	pop    %ebp
    d9ec:	c3                   	ret    

0000d9ed <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    d9ed:	55                   	push   %ebp
    d9ee:	89 e5                	mov    %esp,%ebp
    d9f0:	53                   	push   %ebx
    d9f1:	83 ec 10             	sub    $0x10,%esp
    d9f4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    d9f7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d9fa:	8b 55 14             	mov    0x14(%ebp),%edx
    d9fd:	8b 45 18             	mov    0x18(%ebp),%eax
    da00:	88 5d f8             	mov    %bl,-0x8(%ebp)
    da03:	88 4d f4             	mov    %cl,-0xc(%ebp)
    da06:	88 55 f0             	mov    %dl,-0x10(%ebp)
    da09:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    da0c:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    da10:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    da14:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    da18:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    da1c:	53                   	push   %ebx
    da1d:	51                   	push   %ecx
    da1e:	52                   	push   %edx
    da1f:	50                   	push   %eax
    da20:	ff 75 08             	pushl  0x8(%ebp)
    da23:	e8 00 ff ff ff       	call   d928 <color_tree_get>
    da28:	83 c4 14             	add    $0x14,%esp
    da2b:	f7 d0                	not    %eax
    da2d:	c1 e8 1f             	shr    $0x1f,%eax
    da30:	0f b6 c0             	movzbl %al,%eax
}
    da33:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    da36:	c9                   	leave  
    da37:	c3                   	ret    

0000da38 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    da38:	55                   	push   %ebp
    da39:	89 e5                	mov    %esp,%ebp
    da3b:	53                   	push   %ebx
    da3c:	83 ec 24             	sub    $0x24,%esp
    da3f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    da42:	8b 4d 10             	mov    0x10(%ebp),%ecx
    da45:	8b 55 14             	mov    0x14(%ebp),%edx
    da48:	8b 45 18             	mov    0x18(%ebp),%eax
    da4b:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    da4e:	88 4d e0             	mov    %cl,-0x20(%ebp)
    da51:	88 55 dc             	mov    %dl,-0x24(%ebp)
    da54:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    da57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    da5e:	e9 b0 00 00 00       	jmp    db13 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    da63:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    da67:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da6a:	89 c1                	mov    %eax,%ecx
    da6c:	d3 fa                	sar    %cl,%edx
    da6e:	89 d0                	mov    %edx,%eax
    da70:	83 e0 01             	and    $0x1,%eax
    da73:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    da76:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    da7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da7d:	89 c1                	mov    %eax,%ecx
    da7f:	d3 fa                	sar    %cl,%edx
    da81:	89 d0                	mov    %edx,%eax
    da83:	83 e0 01             	and    $0x1,%eax
    da86:	01 d8                	add    %ebx,%eax
    da88:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    da8b:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    da8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da92:	89 c1                	mov    %eax,%ecx
    da94:	d3 fa                	sar    %cl,%edx
    da96:	89 d0                	mov    %edx,%eax
    da98:	83 e0 01             	and    $0x1,%eax
    da9b:	01 d8                	add    %ebx,%eax
    da9d:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    daa0:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    daa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daa7:	89 c1                	mov    %eax,%ecx
    daa9:	d3 fa                	sar    %cl,%edx
    daab:	89 d0                	mov    %edx,%eax
    daad:	83 e0 01             	and    $0x1,%eax
    dab0:	01 d8                	add    %ebx,%eax
    dab2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    dab5:	8b 45 08             	mov    0x8(%ebp),%eax
    dab8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dabb:	8b 04 90             	mov    (%eax,%edx,4),%eax
    dabe:	85 c0                	test   %eax,%eax
    dac0:	75 41                	jne    db03 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    dac2:	83 ec 0c             	sub    $0xc,%esp
    dac5:	6a 44                	push   $0x44
    dac7:	e8 5d 94 ff ff       	call   6f29 <lodepng_malloc>
    dacc:	83 c4 10             	add    $0x10,%esp
    dacf:	89 c1                	mov    %eax,%ecx
    dad1:	8b 45 08             	mov    0x8(%ebp),%eax
    dad4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dad7:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    dada:	8b 45 08             	mov    0x8(%ebp),%eax
    dadd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dae0:	8b 04 90             	mov    (%eax,%edx,4),%eax
    dae3:	85 c0                	test   %eax,%eax
    dae5:	75 07                	jne    daee <color_tree_add+0xb6>
    dae7:	b8 53 00 00 00       	mov    $0x53,%eax
    daec:	eb 3d                	jmp    db2b <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    daee:	8b 45 08             	mov    0x8(%ebp),%eax
    daf1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    daf4:	8b 04 90             	mov    (%eax,%edx,4),%eax
    daf7:	83 ec 0c             	sub    $0xc,%esp
    dafa:	50                   	push   %eax
    dafb:	e8 b5 fd ff ff       	call   d8b5 <color_tree_init>
    db00:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    db03:	8b 45 08             	mov    0x8(%ebp),%eax
    db06:	8b 55 f0             	mov    -0x10(%ebp),%edx
    db09:	8b 04 90             	mov    (%eax,%edx,4),%eax
    db0c:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    db0f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    db13:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    db17:	0f 8e 46 ff ff ff    	jle    da63 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    db1d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    db20:	8b 45 08             	mov    0x8(%ebp),%eax
    db23:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    db26:	b8 00 00 00 00       	mov    $0x0,%eax
}
    db2b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    db2e:	c9                   	leave  
    db2f:	c3                   	ret    

0000db30 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    db30:	55                   	push   %ebp
    db31:	89 e5                	mov    %esp,%ebp
    db33:	53                   	push   %ebx
    db34:	83 ec 20             	sub    $0x20,%esp
    db37:	8b 5d 18             	mov    0x18(%ebp),%ebx
    db3a:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    db3d:	8b 55 20             	mov    0x20(%ebp),%edx
    db40:	8b 45 24             	mov    0x24(%ebp),%eax
    db43:	88 5d e8             	mov    %bl,-0x18(%ebp)
    db46:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    db49:	88 55 e0             	mov    %dl,-0x20(%ebp)
    db4c:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    db4f:	8b 45 10             	mov    0x10(%ebp),%eax
    db52:	8b 00                	mov    (%eax),%eax
    db54:	85 c0                	test   %eax,%eax
    db56:	0f 85 ad 00 00 00    	jne    dc09 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    db5c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    db60:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    db63:	8b 45 10             	mov    0x10(%ebp),%eax
    db66:	8b 40 04             	mov    0x4(%eax),%eax
    db69:	83 f8 08             	cmp    $0x8,%eax
    db6c:	75 13                	jne    db81 <rgba8ToPixel+0x51>
    db6e:	8b 55 0c             	mov    0xc(%ebp),%edx
    db71:	8b 45 08             	mov    0x8(%ebp),%eax
    db74:	01 c2                	add    %eax,%edx
    db76:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    db7a:	88 02                	mov    %al,(%edx)
    db7c:	e9 b4 03 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    db81:	8b 45 10             	mov    0x10(%ebp),%eax
    db84:	8b 40 04             	mov    0x4(%eax),%eax
    db87:	83 f8 10             	cmp    $0x10,%eax
    db8a:	75 2a                	jne    dbb6 <rgba8ToPixel+0x86>
    db8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    db8f:	01 c0                	add    %eax,%eax
    db91:	89 c2                	mov    %eax,%edx
    db93:	8b 45 08             	mov    0x8(%ebp),%eax
    db96:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    db99:	8b 45 0c             	mov    0xc(%ebp),%eax
    db9c:	01 c0                	add    %eax,%eax
    db9e:	8d 50 01             	lea    0x1(%eax),%edx
    dba1:	8b 45 08             	mov    0x8(%ebp),%eax
    dba4:	01 d0                	add    %edx,%eax
    dba6:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    dbaa:	88 10                	mov    %dl,(%eax)
    dbac:	0f b6 00             	movzbl (%eax),%eax
    dbaf:	88 01                	mov    %al,(%ecx)
    dbb1:	e9 7f 03 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    dbb6:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    dbba:	8b 45 10             	mov    0x10(%ebp),%eax
    dbbd:	8b 40 04             	mov    0x4(%eax),%eax
    dbc0:	b9 08 00 00 00       	mov    $0x8,%ecx
    dbc5:	29 c1                	sub    %eax,%ecx
    dbc7:	89 c8                	mov    %ecx,%eax
    dbc9:	89 c1                	mov    %eax,%ecx
    dbcb:	d3 ea                	shr    %cl,%edx
    dbcd:	89 d0                	mov    %edx,%eax
    dbcf:	89 c2                	mov    %eax,%edx
    dbd1:	8b 45 10             	mov    0x10(%ebp),%eax
    dbd4:	8b 40 04             	mov    0x4(%eax),%eax
    dbd7:	bb 01 00 00 00       	mov    $0x1,%ebx
    dbdc:	89 c1                	mov    %eax,%ecx
    dbde:	d3 e3                	shl    %cl,%ebx
    dbe0:	89 d8                	mov    %ebx,%eax
    dbe2:	83 e8 01             	sub    $0x1,%eax
    dbe5:	21 d0                	and    %edx,%eax
    dbe7:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    dbea:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    dbee:	8b 45 10             	mov    0x10(%ebp),%eax
    dbf1:	8b 40 04             	mov    0x4(%eax),%eax
    dbf4:	52                   	push   %edx
    dbf5:	50                   	push   %eax
    dbf6:	ff 75 0c             	pushl  0xc(%ebp)
    dbf9:	ff 75 08             	pushl  0x8(%ebp)
    dbfc:	e8 21 fc ff ff       	call   d822 <addColorBits>
    dc01:	83 c4 10             	add    $0x10,%esp
    dc04:	e9 2c 03 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    dc09:	8b 45 10             	mov    0x10(%ebp),%eax
    dc0c:	8b 00                	mov    (%eax),%eax
    dc0e:	83 f8 02             	cmp    $0x2,%eax
    dc11:	0f 85 ee 00 00 00    	jne    dd05 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    dc17:	8b 45 10             	mov    0x10(%ebp),%eax
    dc1a:	8b 40 04             	mov    0x4(%eax),%eax
    dc1d:	83 f8 08             	cmp    $0x8,%eax
    dc20:	75 49                	jne    dc6b <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    dc22:	8b 55 0c             	mov    0xc(%ebp),%edx
    dc25:	89 d0                	mov    %edx,%eax
    dc27:	01 c0                	add    %eax,%eax
    dc29:	01 d0                	add    %edx,%eax
    dc2b:	89 c2                	mov    %eax,%edx
    dc2d:	8b 45 08             	mov    0x8(%ebp),%eax
    dc30:	01 c2                	add    %eax,%edx
    dc32:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    dc36:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    dc38:	8b 55 0c             	mov    0xc(%ebp),%edx
    dc3b:	89 d0                	mov    %edx,%eax
    dc3d:	01 c0                	add    %eax,%eax
    dc3f:	01 d0                	add    %edx,%eax
    dc41:	8d 50 01             	lea    0x1(%eax),%edx
    dc44:	8b 45 08             	mov    0x8(%ebp),%eax
    dc47:	01 c2                	add    %eax,%edx
    dc49:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    dc4d:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    dc4f:	8b 55 0c             	mov    0xc(%ebp),%edx
    dc52:	89 d0                	mov    %edx,%eax
    dc54:	01 c0                	add    %eax,%eax
    dc56:	01 d0                	add    %edx,%eax
    dc58:	8d 50 02             	lea    0x2(%eax),%edx
    dc5b:	8b 45 08             	mov    0x8(%ebp),%eax
    dc5e:	01 c2                	add    %eax,%edx
    dc60:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    dc64:	88 02                	mov    %al,(%edx)
    dc66:	e9 ca 02 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    dc6b:	8b 55 0c             	mov    0xc(%ebp),%edx
    dc6e:	89 d0                	mov    %edx,%eax
    dc70:	01 c0                	add    %eax,%eax
    dc72:	01 d0                	add    %edx,%eax
    dc74:	01 c0                	add    %eax,%eax
    dc76:	89 c2                	mov    %eax,%edx
    dc78:	8b 45 08             	mov    0x8(%ebp),%eax
    dc7b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    dc7e:	8b 55 0c             	mov    0xc(%ebp),%edx
    dc81:	89 d0                	mov    %edx,%eax
    dc83:	01 c0                	add    %eax,%eax
    dc85:	01 d0                	add    %edx,%eax
    dc87:	01 c0                	add    %eax,%eax
    dc89:	8d 50 01             	lea    0x1(%eax),%edx
    dc8c:	8b 45 08             	mov    0x8(%ebp),%eax
    dc8f:	01 d0                	add    %edx,%eax
    dc91:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    dc95:	88 10                	mov    %dl,(%eax)
    dc97:	0f b6 00             	movzbl (%eax),%eax
    dc9a:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    dc9c:	8b 55 0c             	mov    0xc(%ebp),%edx
    dc9f:	89 d0                	mov    %edx,%eax
    dca1:	01 c0                	add    %eax,%eax
    dca3:	01 d0                	add    %edx,%eax
    dca5:	01 c0                	add    %eax,%eax
    dca7:	8d 50 02             	lea    0x2(%eax),%edx
    dcaa:	8b 45 08             	mov    0x8(%ebp),%eax
    dcad:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    dcb0:	8b 55 0c             	mov    0xc(%ebp),%edx
    dcb3:	89 d0                	mov    %edx,%eax
    dcb5:	01 c0                	add    %eax,%eax
    dcb7:	01 d0                	add    %edx,%eax
    dcb9:	01 c0                	add    %eax,%eax
    dcbb:	8d 50 03             	lea    0x3(%eax),%edx
    dcbe:	8b 45 08             	mov    0x8(%ebp),%eax
    dcc1:	01 d0                	add    %edx,%eax
    dcc3:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    dcc7:	88 10                	mov    %dl,(%eax)
    dcc9:	0f b6 00             	movzbl (%eax),%eax
    dccc:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    dcce:	8b 55 0c             	mov    0xc(%ebp),%edx
    dcd1:	89 d0                	mov    %edx,%eax
    dcd3:	01 c0                	add    %eax,%eax
    dcd5:	01 d0                	add    %edx,%eax
    dcd7:	01 c0                	add    %eax,%eax
    dcd9:	8d 50 04             	lea    0x4(%eax),%edx
    dcdc:	8b 45 08             	mov    0x8(%ebp),%eax
    dcdf:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    dce2:	8b 55 0c             	mov    0xc(%ebp),%edx
    dce5:	89 d0                	mov    %edx,%eax
    dce7:	01 c0                	add    %eax,%eax
    dce9:	01 d0                	add    %edx,%eax
    dceb:	01 c0                	add    %eax,%eax
    dced:	8d 50 05             	lea    0x5(%eax),%edx
    dcf0:	8b 45 08             	mov    0x8(%ebp),%eax
    dcf3:	01 d0                	add    %edx,%eax
    dcf5:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    dcf9:	88 10                	mov    %dl,(%eax)
    dcfb:	0f b6 00             	movzbl (%eax),%eax
    dcfe:	88 01                	mov    %al,(%ecx)
    dd00:	e9 30 02 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    dd05:	8b 45 10             	mov    0x10(%ebp),%eax
    dd08:	8b 00                	mov    (%eax),%eax
    dd0a:	83 f8 03             	cmp    $0x3,%eax
    dd0d:	75 6d                	jne    dd7c <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    dd0f:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    dd13:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    dd17:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    dd1b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    dd1f:	53                   	push   %ebx
    dd20:	51                   	push   %ecx
    dd21:	52                   	push   %edx
    dd22:	50                   	push   %eax
    dd23:	ff 75 14             	pushl  0x14(%ebp)
    dd26:	e8 fd fb ff ff       	call   d928 <color_tree_get>
    dd2b:	83 c4 14             	add    $0x14,%esp
    dd2e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    dd31:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    dd35:	79 0a                	jns    dd41 <rgba8ToPixel+0x211>
    dd37:	b8 52 00 00 00       	mov    $0x52,%eax
    dd3c:	e9 f9 01 00 00       	jmp    df3a <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    dd41:	8b 45 10             	mov    0x10(%ebp),%eax
    dd44:	8b 40 04             	mov    0x4(%eax),%eax
    dd47:	83 f8 08             	cmp    $0x8,%eax
    dd4a:	75 12                	jne    dd5e <rgba8ToPixel+0x22e>
    dd4c:	8b 55 0c             	mov    0xc(%ebp),%edx
    dd4f:	8b 45 08             	mov    0x8(%ebp),%eax
    dd52:	01 d0                	add    %edx,%eax
    dd54:	8b 55 f8             	mov    -0x8(%ebp),%edx
    dd57:	88 10                	mov    %dl,(%eax)
    dd59:	e9 d7 01 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    dd5e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    dd61:	8b 45 10             	mov    0x10(%ebp),%eax
    dd64:	8b 40 04             	mov    0x4(%eax),%eax
    dd67:	52                   	push   %edx
    dd68:	50                   	push   %eax
    dd69:	ff 75 0c             	pushl  0xc(%ebp)
    dd6c:	ff 75 08             	pushl  0x8(%ebp)
    dd6f:	e8 ae fa ff ff       	call   d822 <addColorBits>
    dd74:	83 c4 10             	add    $0x10,%esp
    dd77:	e9 b9 01 00 00       	jmp    df35 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    dd7c:	8b 45 10             	mov    0x10(%ebp),%eax
    dd7f:	8b 00                	mov    (%eax),%eax
    dd81:	83 f8 04             	cmp    $0x4,%eax
    dd84:	0f 85 9f 00 00 00    	jne    de29 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    dd8a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    dd8e:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    dd91:	8b 45 10             	mov    0x10(%ebp),%eax
    dd94:	8b 40 04             	mov    0x4(%eax),%eax
    dd97:	83 f8 08             	cmp    $0x8,%eax
    dd9a:	75 2a                	jne    ddc6 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    dd9c:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd9f:	01 c0                	add    %eax,%eax
    dda1:	89 c2                	mov    %eax,%edx
    dda3:	8b 45 08             	mov    0x8(%ebp),%eax
    dda6:	01 c2                	add    %eax,%edx
    dda8:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    ddac:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    ddae:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddb1:	01 c0                	add    %eax,%eax
    ddb3:	8d 50 01             	lea    0x1(%eax),%edx
    ddb6:	8b 45 08             	mov    0x8(%ebp),%eax
    ddb9:	01 c2                	add    %eax,%edx
    ddbb:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    ddbf:	88 02                	mov    %al,(%edx)
    ddc1:	e9 6f 01 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    ddc6:	8b 45 10             	mov    0x10(%ebp),%eax
    ddc9:	8b 40 04             	mov    0x4(%eax),%eax
    ddcc:	83 f8 10             	cmp    $0x10,%eax
    ddcf:	0f 85 60 01 00 00    	jne    df35 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    ddd5:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddd8:	c1 e0 02             	shl    $0x2,%eax
    dddb:	89 c2                	mov    %eax,%edx
    dddd:	8b 45 08             	mov    0x8(%ebp),%eax
    dde0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    dde3:	8b 45 0c             	mov    0xc(%ebp),%eax
    dde6:	c1 e0 02             	shl    $0x2,%eax
    dde9:	8d 50 01             	lea    0x1(%eax),%edx
    ddec:	8b 45 08             	mov    0x8(%ebp),%eax
    ddef:	01 d0                	add    %edx,%eax
    ddf1:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    ddf5:	88 10                	mov    %dl,(%eax)
    ddf7:	0f b6 00             	movzbl (%eax),%eax
    ddfa:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    ddfc:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddff:	c1 e0 02             	shl    $0x2,%eax
    de02:	8d 50 02             	lea    0x2(%eax),%edx
    de05:	8b 45 08             	mov    0x8(%ebp),%eax
    de08:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    de0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    de0e:	c1 e0 02             	shl    $0x2,%eax
    de11:	8d 50 03             	lea    0x3(%eax),%edx
    de14:	8b 45 08             	mov    0x8(%ebp),%eax
    de17:	01 d0                	add    %edx,%eax
    de19:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    de1d:	88 10                	mov    %dl,(%eax)
    de1f:	0f b6 00             	movzbl (%eax),%eax
    de22:	88 01                	mov    %al,(%ecx)
    de24:	e9 0c 01 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    de29:	8b 45 10             	mov    0x10(%ebp),%eax
    de2c:	8b 00                	mov    (%eax),%eax
    de2e:	83 f8 06             	cmp    $0x6,%eax
    de31:	0f 85 fe 00 00 00    	jne    df35 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    de37:	8b 45 10             	mov    0x10(%ebp),%eax
    de3a:	8b 40 04             	mov    0x4(%eax),%eax
    de3d:	83 f8 08             	cmp    $0x8,%eax
    de40:	75 54                	jne    de96 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    de42:	8b 45 0c             	mov    0xc(%ebp),%eax
    de45:	c1 e0 02             	shl    $0x2,%eax
    de48:	89 c2                	mov    %eax,%edx
    de4a:	8b 45 08             	mov    0x8(%ebp),%eax
    de4d:	01 c2                	add    %eax,%edx
    de4f:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    de53:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    de55:	8b 45 0c             	mov    0xc(%ebp),%eax
    de58:	c1 e0 02             	shl    $0x2,%eax
    de5b:	8d 50 01             	lea    0x1(%eax),%edx
    de5e:	8b 45 08             	mov    0x8(%ebp),%eax
    de61:	01 c2                	add    %eax,%edx
    de63:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    de67:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    de69:	8b 45 0c             	mov    0xc(%ebp),%eax
    de6c:	c1 e0 02             	shl    $0x2,%eax
    de6f:	8d 50 02             	lea    0x2(%eax),%edx
    de72:	8b 45 08             	mov    0x8(%ebp),%eax
    de75:	01 c2                	add    %eax,%edx
    de77:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    de7b:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    de7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    de80:	c1 e0 02             	shl    $0x2,%eax
    de83:	8d 50 03             	lea    0x3(%eax),%edx
    de86:	8b 45 08             	mov    0x8(%ebp),%eax
    de89:	01 c2                	add    %eax,%edx
    de8b:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    de8f:	88 02                	mov    %al,(%edx)
    de91:	e9 9f 00 00 00       	jmp    df35 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    de96:	8b 45 0c             	mov    0xc(%ebp),%eax
    de99:	c1 e0 03             	shl    $0x3,%eax
    de9c:	89 c2                	mov    %eax,%edx
    de9e:	8b 45 08             	mov    0x8(%ebp),%eax
    dea1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    dea4:	8b 45 0c             	mov    0xc(%ebp),%eax
    dea7:	c1 e0 03             	shl    $0x3,%eax
    deaa:	8d 50 01             	lea    0x1(%eax),%edx
    dead:	8b 45 08             	mov    0x8(%ebp),%eax
    deb0:	01 d0                	add    %edx,%eax
    deb2:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    deb6:	88 10                	mov    %dl,(%eax)
    deb8:	0f b6 00             	movzbl (%eax),%eax
    debb:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    debd:	8b 45 0c             	mov    0xc(%ebp),%eax
    dec0:	c1 e0 03             	shl    $0x3,%eax
    dec3:	8d 50 02             	lea    0x2(%eax),%edx
    dec6:	8b 45 08             	mov    0x8(%ebp),%eax
    dec9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    decc:	8b 45 0c             	mov    0xc(%ebp),%eax
    decf:	c1 e0 03             	shl    $0x3,%eax
    ded2:	8d 50 03             	lea    0x3(%eax),%edx
    ded5:	8b 45 08             	mov    0x8(%ebp),%eax
    ded8:	01 d0                	add    %edx,%eax
    deda:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    dede:	88 10                	mov    %dl,(%eax)
    dee0:	0f b6 00             	movzbl (%eax),%eax
    dee3:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    dee5:	8b 45 0c             	mov    0xc(%ebp),%eax
    dee8:	c1 e0 03             	shl    $0x3,%eax
    deeb:	8d 50 04             	lea    0x4(%eax),%edx
    deee:	8b 45 08             	mov    0x8(%ebp),%eax
    def1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    def4:	8b 45 0c             	mov    0xc(%ebp),%eax
    def7:	c1 e0 03             	shl    $0x3,%eax
    defa:	8d 50 05             	lea    0x5(%eax),%edx
    defd:	8b 45 08             	mov    0x8(%ebp),%eax
    df00:	01 d0                	add    %edx,%eax
    df02:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    df06:	88 10                	mov    %dl,(%eax)
    df08:	0f b6 00             	movzbl (%eax),%eax
    df0b:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    df0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    df10:	c1 e0 03             	shl    $0x3,%eax
    df13:	8d 50 06             	lea    0x6(%eax),%edx
    df16:	8b 45 08             	mov    0x8(%ebp),%eax
    df19:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    df1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    df1f:	c1 e0 03             	shl    $0x3,%eax
    df22:	8d 50 07             	lea    0x7(%eax),%edx
    df25:	8b 45 08             	mov    0x8(%ebp),%eax
    df28:	01 d0                	add    %edx,%eax
    df2a:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    df2e:	88 10                	mov    %dl,(%eax)
    df30:	0f b6 00             	movzbl (%eax),%eax
    df33:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    df35:	b8 00 00 00 00       	mov    $0x0,%eax
}
    df3a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    df3d:	c9                   	leave  
    df3e:	c3                   	ret    

0000df3f <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    df3f:	55                   	push   %ebp
    df40:	89 e5                	mov    %esp,%ebp
    df42:	53                   	push   %ebx
    df43:	83 ec 20             	sub    $0x20,%esp
    df46:	8b 5d 14             	mov    0x14(%ebp),%ebx
    df49:	8b 4d 18             	mov    0x18(%ebp),%ecx
    df4c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    df4f:	8b 45 20             	mov    0x20(%ebp),%eax
    df52:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    df56:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    df5a:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    df5e:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    df62:	8b 45 10             	mov    0x10(%ebp),%eax
    df65:	8b 00                	mov    (%eax),%eax
    df67:	85 c0                	test   %eax,%eax
    df69:	75 36                	jne    dfa1 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    df6b:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    df6f:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    df73:	8b 45 0c             	mov    0xc(%ebp),%eax
    df76:	01 c0                	add    %eax,%eax
    df78:	89 c2                	mov    %eax,%edx
    df7a:	8b 45 08             	mov    0x8(%ebp),%eax
    df7d:	01 d0                	add    %edx,%eax
    df7f:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    df83:	66 c1 ea 08          	shr    $0x8,%dx
    df87:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    df89:	8b 45 0c             	mov    0xc(%ebp),%eax
    df8c:	01 c0                	add    %eax,%eax
    df8e:	8d 50 01             	lea    0x1(%eax),%edx
    df91:	8b 45 08             	mov    0x8(%ebp),%eax
    df94:	01 d0                	add    %edx,%eax
    df96:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    df9a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    df9c:	e9 df 01 00 00       	jmp    e180 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    dfa1:	8b 45 10             	mov    0x10(%ebp),%eax
    dfa4:	8b 00                	mov    (%eax),%eax
    dfa6:	83 f8 02             	cmp    $0x2,%eax
    dfa9:	0f 85 a6 00 00 00    	jne    e055 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    dfaf:	8b 55 0c             	mov    0xc(%ebp),%edx
    dfb2:	89 d0                	mov    %edx,%eax
    dfb4:	01 c0                	add    %eax,%eax
    dfb6:	01 d0                	add    %edx,%eax
    dfb8:	01 c0                	add    %eax,%eax
    dfba:	89 c2                	mov    %eax,%edx
    dfbc:	8b 45 08             	mov    0x8(%ebp),%eax
    dfbf:	01 d0                	add    %edx,%eax
    dfc1:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    dfc5:	66 c1 ea 08          	shr    $0x8,%dx
    dfc9:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    dfcb:	8b 55 0c             	mov    0xc(%ebp),%edx
    dfce:	89 d0                	mov    %edx,%eax
    dfd0:	01 c0                	add    %eax,%eax
    dfd2:	01 d0                	add    %edx,%eax
    dfd4:	01 c0                	add    %eax,%eax
    dfd6:	8d 50 01             	lea    0x1(%eax),%edx
    dfd9:	8b 45 08             	mov    0x8(%ebp),%eax
    dfdc:	01 d0                	add    %edx,%eax
    dfde:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    dfe2:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    dfe4:	8b 55 0c             	mov    0xc(%ebp),%edx
    dfe7:	89 d0                	mov    %edx,%eax
    dfe9:	01 c0                	add    %eax,%eax
    dfeb:	01 d0                	add    %edx,%eax
    dfed:	01 c0                	add    %eax,%eax
    dfef:	8d 50 02             	lea    0x2(%eax),%edx
    dff2:	8b 45 08             	mov    0x8(%ebp),%eax
    dff5:	01 d0                	add    %edx,%eax
    dff7:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    dffb:	66 c1 ea 08          	shr    $0x8,%dx
    dfff:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    e001:	8b 55 0c             	mov    0xc(%ebp),%edx
    e004:	89 d0                	mov    %edx,%eax
    e006:	01 c0                	add    %eax,%eax
    e008:	01 d0                	add    %edx,%eax
    e00a:	01 c0                	add    %eax,%eax
    e00c:	8d 50 03             	lea    0x3(%eax),%edx
    e00f:	8b 45 08             	mov    0x8(%ebp),%eax
    e012:	01 d0                	add    %edx,%eax
    e014:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    e018:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    e01a:	8b 55 0c             	mov    0xc(%ebp),%edx
    e01d:	89 d0                	mov    %edx,%eax
    e01f:	01 c0                	add    %eax,%eax
    e021:	01 d0                	add    %edx,%eax
    e023:	01 c0                	add    %eax,%eax
    e025:	8d 50 04             	lea    0x4(%eax),%edx
    e028:	8b 45 08             	mov    0x8(%ebp),%eax
    e02b:	01 d0                	add    %edx,%eax
    e02d:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    e031:	66 c1 ea 08          	shr    $0x8,%dx
    e035:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    e037:	8b 55 0c             	mov    0xc(%ebp),%edx
    e03a:	89 d0                	mov    %edx,%eax
    e03c:	01 c0                	add    %eax,%eax
    e03e:	01 d0                	add    %edx,%eax
    e040:	01 c0                	add    %eax,%eax
    e042:	8d 50 05             	lea    0x5(%eax),%edx
    e045:	8b 45 08             	mov    0x8(%ebp),%eax
    e048:	01 d0                	add    %edx,%eax
    e04a:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    e04e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    e050:	e9 2b 01 00 00       	jmp    e180 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    e055:	8b 45 10             	mov    0x10(%ebp),%eax
    e058:	8b 00                	mov    (%eax),%eax
    e05a:	83 f8 04             	cmp    $0x4,%eax
    e05d:	75 64                	jne    e0c3 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    e05f:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    e063:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    e067:	8b 45 0c             	mov    0xc(%ebp),%eax
    e06a:	c1 e0 02             	shl    $0x2,%eax
    e06d:	89 c2                	mov    %eax,%edx
    e06f:	8b 45 08             	mov    0x8(%ebp),%eax
    e072:	01 d0                	add    %edx,%eax
    e074:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    e078:	66 c1 ea 08          	shr    $0x8,%dx
    e07c:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    e07e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e081:	c1 e0 02             	shl    $0x2,%eax
    e084:	8d 50 01             	lea    0x1(%eax),%edx
    e087:	8b 45 08             	mov    0x8(%ebp),%eax
    e08a:	01 d0                	add    %edx,%eax
    e08c:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    e090:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    e092:	8b 45 0c             	mov    0xc(%ebp),%eax
    e095:	c1 e0 02             	shl    $0x2,%eax
    e098:	8d 50 02             	lea    0x2(%eax),%edx
    e09b:	8b 45 08             	mov    0x8(%ebp),%eax
    e09e:	01 d0                	add    %edx,%eax
    e0a0:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    e0a4:	66 c1 ea 08          	shr    $0x8,%dx
    e0a8:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    e0aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    e0ad:	c1 e0 02             	shl    $0x2,%eax
    e0b0:	8d 50 03             	lea    0x3(%eax),%edx
    e0b3:	8b 45 08             	mov    0x8(%ebp),%eax
    e0b6:	01 d0                	add    %edx,%eax
    e0b8:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    e0bc:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    e0be:	e9 bd 00 00 00       	jmp    e180 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    e0c3:	8b 45 10             	mov    0x10(%ebp),%eax
    e0c6:	8b 00                	mov    (%eax),%eax
    e0c8:	83 f8 06             	cmp    $0x6,%eax
    e0cb:	0f 85 af 00 00 00    	jne    e180 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    e0d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    e0d4:	c1 e0 03             	shl    $0x3,%eax
    e0d7:	89 c2                	mov    %eax,%edx
    e0d9:	8b 45 08             	mov    0x8(%ebp),%eax
    e0dc:	01 d0                	add    %edx,%eax
    e0de:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    e0e2:	66 c1 ea 08          	shr    $0x8,%dx
    e0e6:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    e0e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e0eb:	c1 e0 03             	shl    $0x3,%eax
    e0ee:	8d 50 01             	lea    0x1(%eax),%edx
    e0f1:	8b 45 08             	mov    0x8(%ebp),%eax
    e0f4:	01 d0                	add    %edx,%eax
    e0f6:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    e0fa:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    e0fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    e0ff:	c1 e0 03             	shl    $0x3,%eax
    e102:	8d 50 02             	lea    0x2(%eax),%edx
    e105:	8b 45 08             	mov    0x8(%ebp),%eax
    e108:	01 d0                	add    %edx,%eax
    e10a:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    e10e:	66 c1 ea 08          	shr    $0x8,%dx
    e112:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    e114:	8b 45 0c             	mov    0xc(%ebp),%eax
    e117:	c1 e0 03             	shl    $0x3,%eax
    e11a:	8d 50 03             	lea    0x3(%eax),%edx
    e11d:	8b 45 08             	mov    0x8(%ebp),%eax
    e120:	01 d0                	add    %edx,%eax
    e122:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    e126:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    e128:	8b 45 0c             	mov    0xc(%ebp),%eax
    e12b:	c1 e0 03             	shl    $0x3,%eax
    e12e:	8d 50 04             	lea    0x4(%eax),%edx
    e131:	8b 45 08             	mov    0x8(%ebp),%eax
    e134:	01 d0                	add    %edx,%eax
    e136:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    e13a:	66 c1 ea 08          	shr    $0x8,%dx
    e13e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    e140:	8b 45 0c             	mov    0xc(%ebp),%eax
    e143:	c1 e0 03             	shl    $0x3,%eax
    e146:	8d 50 05             	lea    0x5(%eax),%edx
    e149:	8b 45 08             	mov    0x8(%ebp),%eax
    e14c:	01 d0                	add    %edx,%eax
    e14e:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    e152:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    e154:	8b 45 0c             	mov    0xc(%ebp),%eax
    e157:	c1 e0 03             	shl    $0x3,%eax
    e15a:	8d 50 06             	lea    0x6(%eax),%edx
    e15d:	8b 45 08             	mov    0x8(%ebp),%eax
    e160:	01 d0                	add    %edx,%eax
    e162:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    e166:	66 c1 ea 08          	shr    $0x8,%dx
    e16a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    e16c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e16f:	c1 e0 03             	shl    $0x3,%eax
    e172:	8d 50 07             	lea    0x7(%eax),%edx
    e175:	8b 45 08             	mov    0x8(%ebp),%eax
    e178:	01 d0                	add    %edx,%eax
    e17a:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    e17e:	88 10                	mov    %dl,(%eax)
  }
}
    e180:	90                   	nop
    e181:	83 c4 20             	add    $0x20,%esp
    e184:	5b                   	pop    %ebx
    e185:	5d                   	pop    %ebp
    e186:	c3                   	ret    

0000e187 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    e187:	55                   	push   %ebp
    e188:	89 e5                	mov    %esp,%ebp
    e18a:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    e18d:	8b 45 20             	mov    0x20(%ebp),%eax
    e190:	8b 00                	mov    (%eax),%eax
    e192:	85 c0                	test   %eax,%eax
    e194:	0f 85 8c 01 00 00    	jne    e326 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    e19a:	8b 45 20             	mov    0x20(%ebp),%eax
    e19d:	8b 40 04             	mov    0x4(%eax),%eax
    e1a0:	83 f8 08             	cmp    $0x8,%eax
    e1a3:	75 59                	jne    e1fe <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    e1a5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e1a8:	8b 45 18             	mov    0x18(%ebp),%eax
    e1ab:	01 d0                	add    %edx,%eax
    e1ad:	0f b6 10             	movzbl (%eax),%edx
    e1b0:	8b 45 10             	mov    0x10(%ebp),%eax
    e1b3:	88 10                	mov    %dl,(%eax)
    e1b5:	8b 45 10             	mov    0x10(%ebp),%eax
    e1b8:	0f b6 10             	movzbl (%eax),%edx
    e1bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e1be:	88 10                	mov    %dl,(%eax)
    e1c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e1c3:	0f b6 10             	movzbl (%eax),%edx
    e1c6:	8b 45 08             	mov    0x8(%ebp),%eax
    e1c9:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    e1cb:	8b 45 20             	mov    0x20(%ebp),%eax
    e1ce:	8b 40 10             	mov    0x10(%eax),%eax
    e1d1:	85 c0                	test   %eax,%eax
    e1d3:	74 1e                	je     e1f3 <getPixelColorRGBA8+0x6c>
    e1d5:	8b 45 08             	mov    0x8(%ebp),%eax
    e1d8:	0f b6 00             	movzbl (%eax),%eax
    e1db:	0f b6 d0             	movzbl %al,%edx
    e1de:	8b 45 20             	mov    0x20(%ebp),%eax
    e1e1:	8b 40 14             	mov    0x14(%eax),%eax
    e1e4:	39 c2                	cmp    %eax,%edx
    e1e6:	75 0b                	jne    e1f3 <getPixelColorRGBA8+0x6c>
    e1e8:	8b 45 14             	mov    0x14(%ebp),%eax
    e1eb:	c6 00 00             	movb   $0x0,(%eax)
    e1ee:	e9 5e 05 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    e1f3:	8b 45 14             	mov    0x14(%ebp),%eax
    e1f6:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e1f9:	e9 53 05 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    e1fe:	8b 45 20             	mov    0x20(%ebp),%eax
    e201:	8b 40 04             	mov    0x4(%eax),%eax
    e204:	83 f8 10             	cmp    $0x10,%eax
    e207:	0f 85 80 00 00 00    	jne    e28d <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    e20d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e210:	01 c0                	add    %eax,%eax
    e212:	89 c2                	mov    %eax,%edx
    e214:	8b 45 18             	mov    0x18(%ebp),%eax
    e217:	01 d0                	add    %edx,%eax
    e219:	0f b6 10             	movzbl (%eax),%edx
    e21c:	8b 45 10             	mov    0x10(%ebp),%eax
    e21f:	88 10                	mov    %dl,(%eax)
    e221:	8b 45 10             	mov    0x10(%ebp),%eax
    e224:	0f b6 10             	movzbl (%eax),%edx
    e227:	8b 45 0c             	mov    0xc(%ebp),%eax
    e22a:	88 10                	mov    %dl,(%eax)
    e22c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e22f:	0f b6 10             	movzbl (%eax),%edx
    e232:	8b 45 08             	mov    0x8(%ebp),%eax
    e235:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    e237:	8b 45 20             	mov    0x20(%ebp),%eax
    e23a:	8b 40 10             	mov    0x10(%eax),%eax
    e23d:	85 c0                	test   %eax,%eax
    e23f:	74 41                	je     e282 <getPixelColorRGBA8+0xfb>
    e241:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e244:	01 c0                	add    %eax,%eax
    e246:	89 c2                	mov    %eax,%edx
    e248:	8b 45 18             	mov    0x18(%ebp),%eax
    e24b:	01 d0                	add    %edx,%eax
    e24d:	0f b6 00             	movzbl (%eax),%eax
    e250:	0f b6 c0             	movzbl %al,%eax
    e253:	c1 e0 08             	shl    $0x8,%eax
    e256:	89 c2                	mov    %eax,%edx
    e258:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e25b:	01 c0                	add    %eax,%eax
    e25d:	8d 48 01             	lea    0x1(%eax),%ecx
    e260:	8b 45 18             	mov    0x18(%ebp),%eax
    e263:	01 c8                	add    %ecx,%eax
    e265:	0f b6 00             	movzbl (%eax),%eax
    e268:	0f b6 c0             	movzbl %al,%eax
    e26b:	01 c2                	add    %eax,%edx
    e26d:	8b 45 20             	mov    0x20(%ebp),%eax
    e270:	8b 40 14             	mov    0x14(%eax),%eax
    e273:	39 c2                	cmp    %eax,%edx
    e275:	75 0b                	jne    e282 <getPixelColorRGBA8+0xfb>
    e277:	8b 45 14             	mov    0x14(%ebp),%eax
    e27a:	c6 00 00             	movb   $0x0,(%eax)
    e27d:	e9 cf 04 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    e282:	8b 45 14             	mov    0x14(%ebp),%eax
    e285:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e288:	e9 c4 04 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    e28d:	8b 45 20             	mov    0x20(%ebp),%eax
    e290:	8b 40 04             	mov    0x4(%eax),%eax
    e293:	ba 01 00 00 00       	mov    $0x1,%edx
    e298:	89 c1                	mov    %eax,%ecx
    e29a:	d3 e2                	shl    %cl,%edx
    e29c:	89 d0                	mov    %edx,%eax
    e29e:	83 e8 01             	sub    $0x1,%eax
    e2a1:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    e2a4:	8b 45 20             	mov    0x20(%ebp),%eax
    e2a7:	8b 50 04             	mov    0x4(%eax),%edx
    e2aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e2ad:	0f af c2             	imul   %edx,%eax
    e2b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    e2b3:	8b 45 20             	mov    0x20(%ebp),%eax
    e2b6:	8b 40 04             	mov    0x4(%eax),%eax
    e2b9:	50                   	push   %eax
    e2ba:	ff 75 18             	pushl  0x18(%ebp)
    e2bd:	8d 45 f0             	lea    -0x10(%ebp),%eax
    e2c0:	50                   	push   %eax
    e2c1:	e8 06 db ff ff       	call   bdcc <readBitsFromReversedStream>
    e2c6:	83 c4 0c             	add    $0xc,%esp
    e2c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    e2cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e2cf:	89 d0                	mov    %edx,%eax
    e2d1:	c1 e0 08             	shl    $0x8,%eax
    e2d4:	29 d0                	sub    %edx,%eax
    e2d6:	ba 00 00 00 00       	mov    $0x0,%edx
    e2db:	f7 75 f8             	divl   -0x8(%ebp)
    e2de:	89 c2                	mov    %eax,%edx
    e2e0:	8b 45 10             	mov    0x10(%ebp),%eax
    e2e3:	88 10                	mov    %dl,(%eax)
    e2e5:	8b 45 10             	mov    0x10(%ebp),%eax
    e2e8:	0f b6 10             	movzbl (%eax),%edx
    e2eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e2ee:	88 10                	mov    %dl,(%eax)
    e2f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e2f3:	0f b6 10             	movzbl (%eax),%edx
    e2f6:	8b 45 08             	mov    0x8(%ebp),%eax
    e2f9:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    e2fb:	8b 45 20             	mov    0x20(%ebp),%eax
    e2fe:	8b 40 10             	mov    0x10(%eax),%eax
    e301:	85 c0                	test   %eax,%eax
    e303:	74 16                	je     e31b <getPixelColorRGBA8+0x194>
    e305:	8b 45 20             	mov    0x20(%ebp),%eax
    e308:	8b 40 14             	mov    0x14(%eax),%eax
    e30b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e30e:	75 0b                	jne    e31b <getPixelColorRGBA8+0x194>
    e310:	8b 45 14             	mov    0x14(%ebp),%eax
    e313:	c6 00 00             	movb   $0x0,(%eax)
    e316:	e9 36 04 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    e31b:	8b 45 14             	mov    0x14(%ebp),%eax
    e31e:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e321:	e9 2b 04 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    e326:	8b 45 20             	mov    0x20(%ebp),%eax
    e329:	8b 00                	mov    (%eax),%eax
    e32b:	83 f8 02             	cmp    $0x2,%eax
    e32e:	0f 85 f5 01 00 00    	jne    e529 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    e334:	8b 45 20             	mov    0x20(%ebp),%eax
    e337:	8b 40 04             	mov    0x4(%eax),%eax
    e33a:	83 f8 08             	cmp    $0x8,%eax
    e33d:	0f 85 a3 00 00 00    	jne    e3e6 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    e343:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e346:	89 d0                	mov    %edx,%eax
    e348:	01 c0                	add    %eax,%eax
    e34a:	01 d0                	add    %edx,%eax
    e34c:	89 c2                	mov    %eax,%edx
    e34e:	8b 45 18             	mov    0x18(%ebp),%eax
    e351:	01 d0                	add    %edx,%eax
    e353:	0f b6 10             	movzbl (%eax),%edx
    e356:	8b 45 08             	mov    0x8(%ebp),%eax
    e359:	88 10                	mov    %dl,(%eax)
    e35b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e35e:	89 d0                	mov    %edx,%eax
    e360:	01 c0                	add    %eax,%eax
    e362:	01 d0                	add    %edx,%eax
    e364:	8d 50 01             	lea    0x1(%eax),%edx
    e367:	8b 45 18             	mov    0x18(%ebp),%eax
    e36a:	01 d0                	add    %edx,%eax
    e36c:	0f b6 10             	movzbl (%eax),%edx
    e36f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e372:	88 10                	mov    %dl,(%eax)
    e374:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e377:	89 d0                	mov    %edx,%eax
    e379:	01 c0                	add    %eax,%eax
    e37b:	01 d0                	add    %edx,%eax
    e37d:	8d 50 02             	lea    0x2(%eax),%edx
    e380:	8b 45 18             	mov    0x18(%ebp),%eax
    e383:	01 d0                	add    %edx,%eax
    e385:	0f b6 10             	movzbl (%eax),%edx
    e388:	8b 45 10             	mov    0x10(%ebp),%eax
    e38b:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    e38d:	8b 45 20             	mov    0x20(%ebp),%eax
    e390:	8b 40 10             	mov    0x10(%eax),%eax
    e393:	85 c0                	test   %eax,%eax
    e395:	74 44                	je     e3db <getPixelColorRGBA8+0x254>
    e397:	8b 45 08             	mov    0x8(%ebp),%eax
    e39a:	0f b6 00             	movzbl (%eax),%eax
    e39d:	0f b6 d0             	movzbl %al,%edx
    e3a0:	8b 45 20             	mov    0x20(%ebp),%eax
    e3a3:	8b 40 14             	mov    0x14(%eax),%eax
    e3a6:	39 c2                	cmp    %eax,%edx
    e3a8:	75 31                	jne    e3db <getPixelColorRGBA8+0x254>
    e3aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    e3ad:	0f b6 00             	movzbl (%eax),%eax
    e3b0:	0f b6 d0             	movzbl %al,%edx
    e3b3:	8b 45 20             	mov    0x20(%ebp),%eax
    e3b6:	8b 40 18             	mov    0x18(%eax),%eax
    e3b9:	39 c2                	cmp    %eax,%edx
    e3bb:	75 1e                	jne    e3db <getPixelColorRGBA8+0x254>
    e3bd:	8b 45 10             	mov    0x10(%ebp),%eax
    e3c0:	0f b6 00             	movzbl (%eax),%eax
    e3c3:	0f b6 d0             	movzbl %al,%edx
    e3c6:	8b 45 20             	mov    0x20(%ebp),%eax
    e3c9:	8b 40 1c             	mov    0x1c(%eax),%eax
    e3cc:	39 c2                	cmp    %eax,%edx
    e3ce:	75 0b                	jne    e3db <getPixelColorRGBA8+0x254>
    e3d0:	8b 45 14             	mov    0x14(%ebp),%eax
    e3d3:	c6 00 00             	movb   $0x0,(%eax)
    e3d6:	e9 76 03 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    e3db:	8b 45 14             	mov    0x14(%ebp),%eax
    e3de:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e3e1:	e9 6b 03 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    e3e6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e3e9:	89 d0                	mov    %edx,%eax
    e3eb:	01 c0                	add    %eax,%eax
    e3ed:	01 d0                	add    %edx,%eax
    e3ef:	01 c0                	add    %eax,%eax
    e3f1:	89 c2                	mov    %eax,%edx
    e3f3:	8b 45 18             	mov    0x18(%ebp),%eax
    e3f6:	01 d0                	add    %edx,%eax
    e3f8:	0f b6 10             	movzbl (%eax),%edx
    e3fb:	8b 45 08             	mov    0x8(%ebp),%eax
    e3fe:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    e400:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e403:	89 d0                	mov    %edx,%eax
    e405:	01 c0                	add    %eax,%eax
    e407:	01 d0                	add    %edx,%eax
    e409:	01 c0                	add    %eax,%eax
    e40b:	8d 50 02             	lea    0x2(%eax),%edx
    e40e:	8b 45 18             	mov    0x18(%ebp),%eax
    e411:	01 d0                	add    %edx,%eax
    e413:	0f b6 10             	movzbl (%eax),%edx
    e416:	8b 45 0c             	mov    0xc(%ebp),%eax
    e419:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    e41b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e41e:	89 d0                	mov    %edx,%eax
    e420:	01 c0                	add    %eax,%eax
    e422:	01 d0                	add    %edx,%eax
    e424:	01 c0                	add    %eax,%eax
    e426:	8d 50 04             	lea    0x4(%eax),%edx
    e429:	8b 45 18             	mov    0x18(%ebp),%eax
    e42c:	01 d0                	add    %edx,%eax
    e42e:	0f b6 10             	movzbl (%eax),%edx
    e431:	8b 45 10             	mov    0x10(%ebp),%eax
    e434:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    e436:	8b 45 20             	mov    0x20(%ebp),%eax
    e439:	8b 40 10             	mov    0x10(%eax),%eax
    e43c:	85 c0                	test   %eax,%eax
    e43e:	0f 84 da 00 00 00    	je     e51e <getPixelColorRGBA8+0x397>
    e444:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e447:	89 d0                	mov    %edx,%eax
    e449:	01 c0                	add    %eax,%eax
    e44b:	01 d0                	add    %edx,%eax
    e44d:	01 c0                	add    %eax,%eax
    e44f:	89 c2                	mov    %eax,%edx
    e451:	8b 45 18             	mov    0x18(%ebp),%eax
    e454:	01 d0                	add    %edx,%eax
    e456:	0f b6 00             	movzbl (%eax),%eax
    e459:	0f b6 c0             	movzbl %al,%eax
    e45c:	c1 e0 08             	shl    $0x8,%eax
    e45f:	89 c1                	mov    %eax,%ecx
    e461:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e464:	89 d0                	mov    %edx,%eax
    e466:	01 c0                	add    %eax,%eax
    e468:	01 d0                	add    %edx,%eax
    e46a:	01 c0                	add    %eax,%eax
    e46c:	8d 50 01             	lea    0x1(%eax),%edx
    e46f:	8b 45 18             	mov    0x18(%ebp),%eax
    e472:	01 d0                	add    %edx,%eax
    e474:	0f b6 00             	movzbl (%eax),%eax
    e477:	0f b6 c0             	movzbl %al,%eax
    e47a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    e47d:	8b 45 20             	mov    0x20(%ebp),%eax
    e480:	8b 40 14             	mov    0x14(%eax),%eax
    e483:	39 c2                	cmp    %eax,%edx
    e485:	0f 85 93 00 00 00    	jne    e51e <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    e48b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e48e:	89 d0                	mov    %edx,%eax
    e490:	01 c0                	add    %eax,%eax
    e492:	01 d0                	add    %edx,%eax
    e494:	01 c0                	add    %eax,%eax
    e496:	8d 50 02             	lea    0x2(%eax),%edx
    e499:	8b 45 18             	mov    0x18(%ebp),%eax
    e49c:	01 d0                	add    %edx,%eax
    e49e:	0f b6 00             	movzbl (%eax),%eax
    e4a1:	0f b6 c0             	movzbl %al,%eax
    e4a4:	c1 e0 08             	shl    $0x8,%eax
    e4a7:	89 c1                	mov    %eax,%ecx
    e4a9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e4ac:	89 d0                	mov    %edx,%eax
    e4ae:	01 c0                	add    %eax,%eax
    e4b0:	01 d0                	add    %edx,%eax
    e4b2:	01 c0                	add    %eax,%eax
    e4b4:	8d 50 03             	lea    0x3(%eax),%edx
    e4b7:	8b 45 18             	mov    0x18(%ebp),%eax
    e4ba:	01 d0                	add    %edx,%eax
    e4bc:	0f b6 00             	movzbl (%eax),%eax
    e4bf:	0f b6 c0             	movzbl %al,%eax
    e4c2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    e4c5:	8b 45 20             	mov    0x20(%ebp),%eax
    e4c8:	8b 40 18             	mov    0x18(%eax),%eax
    e4cb:	39 c2                	cmp    %eax,%edx
    e4cd:	75 4f                	jne    e51e <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    e4cf:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e4d2:	89 d0                	mov    %edx,%eax
    e4d4:	01 c0                	add    %eax,%eax
    e4d6:	01 d0                	add    %edx,%eax
    e4d8:	01 c0                	add    %eax,%eax
    e4da:	8d 50 04             	lea    0x4(%eax),%edx
    e4dd:	8b 45 18             	mov    0x18(%ebp),%eax
    e4e0:	01 d0                	add    %edx,%eax
    e4e2:	0f b6 00             	movzbl (%eax),%eax
    e4e5:	0f b6 c0             	movzbl %al,%eax
    e4e8:	c1 e0 08             	shl    $0x8,%eax
    e4eb:	89 c1                	mov    %eax,%ecx
    e4ed:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e4f0:	89 d0                	mov    %edx,%eax
    e4f2:	01 c0                	add    %eax,%eax
    e4f4:	01 d0                	add    %edx,%eax
    e4f6:	01 c0                	add    %eax,%eax
    e4f8:	8d 50 05             	lea    0x5(%eax),%edx
    e4fb:	8b 45 18             	mov    0x18(%ebp),%eax
    e4fe:	01 d0                	add    %edx,%eax
    e500:	0f b6 00             	movzbl (%eax),%eax
    e503:	0f b6 c0             	movzbl %al,%eax
    e506:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    e509:	8b 45 20             	mov    0x20(%ebp),%eax
    e50c:	8b 40 1c             	mov    0x1c(%eax),%eax
    e50f:	39 c2                	cmp    %eax,%edx
    e511:	75 0b                	jne    e51e <getPixelColorRGBA8+0x397>
    e513:	8b 45 14             	mov    0x14(%ebp),%eax
    e516:	c6 00 00             	movb   $0x0,(%eax)
    e519:	e9 33 02 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    e51e:	8b 45 14             	mov    0x14(%ebp),%eax
    e521:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e524:	e9 28 02 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    e529:	8b 45 20             	mov    0x20(%ebp),%eax
    e52c:	8b 00                	mov    (%eax),%eax
    e52e:	83 f8 03             	cmp    $0x3,%eax
    e531:	0f 85 ac 00 00 00    	jne    e5e3 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    e537:	8b 45 20             	mov    0x20(%ebp),%eax
    e53a:	8b 40 04             	mov    0x4(%eax),%eax
    e53d:	83 f8 08             	cmp    $0x8,%eax
    e540:	75 13                	jne    e555 <getPixelColorRGBA8+0x3ce>
    e542:	8b 55 1c             	mov    0x1c(%ebp),%edx
    e545:	8b 45 18             	mov    0x18(%ebp),%eax
    e548:	01 d0                	add    %edx,%eax
    e54a:	0f b6 00             	movzbl (%eax),%eax
    e54d:	0f b6 c0             	movzbl %al,%eax
    e550:	89 45 fc             	mov    %eax,-0x4(%ebp)
    e553:	eb 28                	jmp    e57d <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    e555:	8b 45 20             	mov    0x20(%ebp),%eax
    e558:	8b 50 04             	mov    0x4(%eax),%edx
    e55b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e55e:	0f af c2             	imul   %edx,%eax
    e561:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    e564:	8b 45 20             	mov    0x20(%ebp),%eax
    e567:	8b 40 04             	mov    0x4(%eax),%eax
    e56a:	50                   	push   %eax
    e56b:	ff 75 18             	pushl  0x18(%ebp)
    e56e:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e571:	50                   	push   %eax
    e572:	e8 55 d8 ff ff       	call   bdcc <readBitsFromReversedStream>
    e577:	83 c4 0c             	add    $0xc,%esp
    e57a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    e57d:	8b 45 20             	mov    0x20(%ebp),%eax
    e580:	8b 40 08             	mov    0x8(%eax),%eax
    e583:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e586:	c1 e2 02             	shl    $0x2,%edx
    e589:	01 d0                	add    %edx,%eax
    e58b:	0f b6 10             	movzbl (%eax),%edx
    e58e:	8b 45 08             	mov    0x8(%ebp),%eax
    e591:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    e593:	8b 45 20             	mov    0x20(%ebp),%eax
    e596:	8b 40 08             	mov    0x8(%eax),%eax
    e599:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e59c:	c1 e2 02             	shl    $0x2,%edx
    e59f:	83 c2 01             	add    $0x1,%edx
    e5a2:	01 d0                	add    %edx,%eax
    e5a4:	0f b6 10             	movzbl (%eax),%edx
    e5a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5aa:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    e5ac:	8b 45 20             	mov    0x20(%ebp),%eax
    e5af:	8b 40 08             	mov    0x8(%eax),%eax
    e5b2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e5b5:	c1 e2 02             	shl    $0x2,%edx
    e5b8:	83 c2 02             	add    $0x2,%edx
    e5bb:	01 d0                	add    %edx,%eax
    e5bd:	0f b6 10             	movzbl (%eax),%edx
    e5c0:	8b 45 10             	mov    0x10(%ebp),%eax
    e5c3:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    e5c5:	8b 45 20             	mov    0x20(%ebp),%eax
    e5c8:	8b 40 08             	mov    0x8(%eax),%eax
    e5cb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e5ce:	c1 e2 02             	shl    $0x2,%edx
    e5d1:	83 c2 03             	add    $0x3,%edx
    e5d4:	01 d0                	add    %edx,%eax
    e5d6:	0f b6 10             	movzbl (%eax),%edx
    e5d9:	8b 45 14             	mov    0x14(%ebp),%eax
    e5dc:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e5de:	e9 6e 01 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    e5e3:	8b 45 20             	mov    0x20(%ebp),%eax
    e5e6:	8b 00                	mov    (%eax),%eax
    e5e8:	83 f8 04             	cmp    $0x4,%eax
    e5eb:	0f 85 95 00 00 00    	jne    e686 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    e5f1:	8b 45 20             	mov    0x20(%ebp),%eax
    e5f4:	8b 40 04             	mov    0x4(%eax),%eax
    e5f7:	83 f8 08             	cmp    $0x8,%eax
    e5fa:	75 44                	jne    e640 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    e5fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e5ff:	01 c0                	add    %eax,%eax
    e601:	89 c2                	mov    %eax,%edx
    e603:	8b 45 18             	mov    0x18(%ebp),%eax
    e606:	01 d0                	add    %edx,%eax
    e608:	0f b6 10             	movzbl (%eax),%edx
    e60b:	8b 45 10             	mov    0x10(%ebp),%eax
    e60e:	88 10                	mov    %dl,(%eax)
    e610:	8b 45 10             	mov    0x10(%ebp),%eax
    e613:	0f b6 10             	movzbl (%eax),%edx
    e616:	8b 45 0c             	mov    0xc(%ebp),%eax
    e619:	88 10                	mov    %dl,(%eax)
    e61b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e61e:	0f b6 10             	movzbl (%eax),%edx
    e621:	8b 45 08             	mov    0x8(%ebp),%eax
    e624:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    e626:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e629:	01 c0                	add    %eax,%eax
    e62b:	8d 50 01             	lea    0x1(%eax),%edx
    e62e:	8b 45 18             	mov    0x18(%ebp),%eax
    e631:	01 d0                	add    %edx,%eax
    e633:	0f b6 10             	movzbl (%eax),%edx
    e636:	8b 45 14             	mov    0x14(%ebp),%eax
    e639:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e63b:	e9 11 01 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    e640:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e643:	c1 e0 02             	shl    $0x2,%eax
    e646:	89 c2                	mov    %eax,%edx
    e648:	8b 45 18             	mov    0x18(%ebp),%eax
    e64b:	01 d0                	add    %edx,%eax
    e64d:	0f b6 10             	movzbl (%eax),%edx
    e650:	8b 45 10             	mov    0x10(%ebp),%eax
    e653:	88 10                	mov    %dl,(%eax)
    e655:	8b 45 10             	mov    0x10(%ebp),%eax
    e658:	0f b6 10             	movzbl (%eax),%edx
    e65b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e65e:	88 10                	mov    %dl,(%eax)
    e660:	8b 45 0c             	mov    0xc(%ebp),%eax
    e663:	0f b6 10             	movzbl (%eax),%edx
    e666:	8b 45 08             	mov    0x8(%ebp),%eax
    e669:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    e66b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e66e:	c1 e0 02             	shl    $0x2,%eax
    e671:	8d 50 02             	lea    0x2(%eax),%edx
    e674:	8b 45 18             	mov    0x18(%ebp),%eax
    e677:	01 d0                	add    %edx,%eax
    e679:	0f b6 10             	movzbl (%eax),%edx
    e67c:	8b 45 14             	mov    0x14(%ebp),%eax
    e67f:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e681:	e9 cb 00 00 00       	jmp    e751 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    e686:	8b 45 20             	mov    0x20(%ebp),%eax
    e689:	8b 00                	mov    (%eax),%eax
    e68b:	83 f8 06             	cmp    $0x6,%eax
    e68e:	0f 85 bd 00 00 00    	jne    e751 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    e694:	8b 45 20             	mov    0x20(%ebp),%eax
    e697:	8b 40 04             	mov    0x4(%eax),%eax
    e69a:	83 f8 08             	cmp    $0x8,%eax
    e69d:	75 59                	jne    e6f8 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    e69f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e6a2:	c1 e0 02             	shl    $0x2,%eax
    e6a5:	89 c2                	mov    %eax,%edx
    e6a7:	8b 45 18             	mov    0x18(%ebp),%eax
    e6aa:	01 d0                	add    %edx,%eax
    e6ac:	0f b6 10             	movzbl (%eax),%edx
    e6af:	8b 45 08             	mov    0x8(%ebp),%eax
    e6b2:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    e6b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e6b7:	c1 e0 02             	shl    $0x2,%eax
    e6ba:	8d 50 01             	lea    0x1(%eax),%edx
    e6bd:	8b 45 18             	mov    0x18(%ebp),%eax
    e6c0:	01 d0                	add    %edx,%eax
    e6c2:	0f b6 10             	movzbl (%eax),%edx
    e6c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6c8:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    e6ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e6cd:	c1 e0 02             	shl    $0x2,%eax
    e6d0:	8d 50 02             	lea    0x2(%eax),%edx
    e6d3:	8b 45 18             	mov    0x18(%ebp),%eax
    e6d6:	01 d0                	add    %edx,%eax
    e6d8:	0f b6 10             	movzbl (%eax),%edx
    e6db:	8b 45 10             	mov    0x10(%ebp),%eax
    e6de:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    e6e0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e6e3:	c1 e0 02             	shl    $0x2,%eax
    e6e6:	8d 50 03             	lea    0x3(%eax),%edx
    e6e9:	8b 45 18             	mov    0x18(%ebp),%eax
    e6ec:	01 d0                	add    %edx,%eax
    e6ee:	0f b6 10             	movzbl (%eax),%edx
    e6f1:	8b 45 14             	mov    0x14(%ebp),%eax
    e6f4:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    e6f6:	eb 59                	jmp    e751 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    e6f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e6fb:	c1 e0 03             	shl    $0x3,%eax
    e6fe:	89 c2                	mov    %eax,%edx
    e700:	8b 45 18             	mov    0x18(%ebp),%eax
    e703:	01 d0                	add    %edx,%eax
    e705:	0f b6 10             	movzbl (%eax),%edx
    e708:	8b 45 08             	mov    0x8(%ebp),%eax
    e70b:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    e70d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e710:	c1 e0 03             	shl    $0x3,%eax
    e713:	8d 50 02             	lea    0x2(%eax),%edx
    e716:	8b 45 18             	mov    0x18(%ebp),%eax
    e719:	01 d0                	add    %edx,%eax
    e71b:	0f b6 10             	movzbl (%eax),%edx
    e71e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e721:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    e723:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e726:	c1 e0 03             	shl    $0x3,%eax
    e729:	8d 50 04             	lea    0x4(%eax),%edx
    e72c:	8b 45 18             	mov    0x18(%ebp),%eax
    e72f:	01 d0                	add    %edx,%eax
    e731:	0f b6 10             	movzbl (%eax),%edx
    e734:	8b 45 10             	mov    0x10(%ebp),%eax
    e737:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    e739:	8b 45 1c             	mov    0x1c(%ebp),%eax
    e73c:	c1 e0 03             	shl    $0x3,%eax
    e73f:	8d 50 06             	lea    0x6(%eax),%edx
    e742:	8b 45 18             	mov    0x18(%ebp),%eax
    e745:	01 d0                	add    %edx,%eax
    e747:	0f b6 10             	movzbl (%eax),%edx
    e74a:	8b 45 14             	mov    0x14(%ebp),%eax
    e74d:	88 10                	mov    %dl,(%eax)
    }
  }
}
    e74f:	eb 00                	jmp    e751 <getPixelColorRGBA8+0x5ca>
    e751:	90                   	nop
    e752:	c9                   	leave  
    e753:	c3                   	ret    

0000e754 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    e754:	55                   	push   %ebp
    e755:	89 e5                	mov    %esp,%ebp
    e757:	53                   	push   %ebx
    e758:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    e75b:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    e762:	8b 45 14             	mov    0x14(%ebp),%eax
    e765:	8b 00                	mov    (%eax),%eax
    e767:	85 c0                	test   %eax,%eax
    e769:	0f 85 14 02 00 00    	jne    e983 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    e76f:	8b 45 14             	mov    0x14(%ebp),%eax
    e772:	8b 40 04             	mov    0x4(%eax),%eax
    e775:	83 f8 08             	cmp    $0x8,%eax
    e778:	0f 85 a0 00 00 00    	jne    e81e <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e77e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e785:	eb 39                	jmp    e7c0 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    e787:	8b 45 08             	mov    0x8(%ebp),%eax
    e78a:	83 c0 01             	add    $0x1,%eax
    e78d:	8b 55 08             	mov    0x8(%ebp),%edx
    e790:	83 c2 02             	add    $0x2,%edx
    e793:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    e796:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e799:	01 d9                	add    %ebx,%ecx
    e79b:	0f b6 09             	movzbl (%ecx),%ecx
    e79e:	88 0a                	mov    %cl,(%edx)
    e7a0:	0f b6 12             	movzbl (%edx),%edx
    e7a3:	88 10                	mov    %dl,(%eax)
    e7a5:	0f b6 10             	movzbl (%eax),%edx
    e7a8:	8b 45 08             	mov    0x8(%ebp),%eax
    e7ab:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    e7ad:	8b 45 08             	mov    0x8(%ebp),%eax
    e7b0:	83 c0 03             	add    $0x3,%eax
    e7b3:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e7b6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e7ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e7bd:	01 45 08             	add    %eax,0x8(%ebp)
    e7c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e7c3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    e7c6:	75 bf                	jne    e787 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    e7c8:	8b 45 14             	mov    0x14(%ebp),%eax
    e7cb:	8b 40 10             	mov    0x10(%eax),%eax
    e7ce:	85 c0                	test   %eax,%eax
    e7d0:	0f 84 48 06 00 00    	je     ee1e <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    e7d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7d9:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e7dd:	f7 d8                	neg    %eax
    e7df:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e7e2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e7e9:	eb 26                	jmp    e811 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    e7eb:	8b 45 08             	mov    0x8(%ebp),%eax
    e7ee:	0f b6 00             	movzbl (%eax),%eax
    e7f1:	0f b6 d0             	movzbl %al,%edx
    e7f4:	8b 45 14             	mov    0x14(%ebp),%eax
    e7f7:	8b 40 14             	mov    0x14(%eax),%eax
    e7fa:	39 c2                	cmp    %eax,%edx
    e7fc:	75 09                	jne    e807 <getPixelColorsRGBA8+0xb3>
    e7fe:	8b 45 08             	mov    0x8(%ebp),%eax
    e801:	83 c0 03             	add    $0x3,%eax
    e804:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e807:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e80b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e80e:	01 45 08             	add    %eax,0x8(%ebp)
    e811:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e814:	3b 45 0c             	cmp    0xc(%ebp),%eax
    e817:	75 d2                	jne    e7eb <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    e819:	e9 00 06 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    e81e:	8b 45 14             	mov    0x14(%ebp),%eax
    e821:	8b 40 04             	mov    0x4(%eax),%eax
    e824:	83 f8 10             	cmp    $0x10,%eax
    e827:	0f 85 a5 00 00 00    	jne    e8d2 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e82d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e834:	e9 88 00 00 00       	jmp    e8c1 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    e839:	8b 45 08             	mov    0x8(%ebp),%eax
    e83c:	83 c0 01             	add    $0x1,%eax
    e83f:	8b 55 08             	mov    0x8(%ebp),%edx
    e842:	83 c2 02             	add    $0x2,%edx
    e845:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    e848:	01 c9                	add    %ecx,%ecx
    e84a:	89 cb                	mov    %ecx,%ebx
    e84c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e84f:	01 d9                	add    %ebx,%ecx
    e851:	0f b6 09             	movzbl (%ecx),%ecx
    e854:	88 0a                	mov    %cl,(%edx)
    e856:	0f b6 12             	movzbl (%edx),%edx
    e859:	88 10                	mov    %dl,(%eax)
    e85b:	0f b6 10             	movzbl (%eax),%edx
    e85e:	8b 45 08             	mov    0x8(%ebp),%eax
    e861:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    e863:	8b 45 08             	mov    0x8(%ebp),%eax
    e866:	8d 50 03             	lea    0x3(%eax),%edx
    e869:	8b 45 14             	mov    0x14(%ebp),%eax
    e86c:	8b 40 10             	mov    0x10(%eax),%eax
    e86f:	85 c0                	test   %eax,%eax
    e871:	74 3d                	je     e8b0 <getPixelColorsRGBA8+0x15c>
    e873:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e876:	01 c0                	add    %eax,%eax
    e878:	89 c1                	mov    %eax,%ecx
    e87a:	8b 45 10             	mov    0x10(%ebp),%eax
    e87d:	01 c8                	add    %ecx,%eax
    e87f:	0f b6 00             	movzbl (%eax),%eax
    e882:	0f b6 c0             	movzbl %al,%eax
    e885:	c1 e0 08             	shl    $0x8,%eax
    e888:	89 c1                	mov    %eax,%ecx
    e88a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e88d:	01 c0                	add    %eax,%eax
    e88f:	8d 58 01             	lea    0x1(%eax),%ebx
    e892:	8b 45 10             	mov    0x10(%ebp),%eax
    e895:	01 d8                	add    %ebx,%eax
    e897:	0f b6 00             	movzbl (%eax),%eax
    e89a:	0f b6 c0             	movzbl %al,%eax
    e89d:	01 c1                	add    %eax,%ecx
    e89f:	8b 45 14             	mov    0x14(%ebp),%eax
    e8a2:	8b 40 14             	mov    0x14(%eax),%eax
    e8a5:	39 c1                	cmp    %eax,%ecx
    e8a7:	75 07                	jne    e8b0 <getPixelColorsRGBA8+0x15c>
    e8a9:	b8 00 00 00 00       	mov    $0x0,%eax
    e8ae:	eb 05                	jmp    e8b5 <getPixelColorsRGBA8+0x161>
    e8b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    e8b5:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e8b7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e8bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e8be:	01 45 08             	add    %eax,0x8(%ebp)
    e8c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e8c4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    e8c7:	0f 85 6c ff ff ff    	jne    e839 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    e8cd:	e9 4c 05 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    e8d2:	8b 45 14             	mov    0x14(%ebp),%eax
    e8d5:	8b 40 04             	mov    0x4(%eax),%eax
    e8d8:	ba 01 00 00 00       	mov    $0x1,%edx
    e8dd:	89 c1                	mov    %eax,%ecx
    e8df:	d3 e2                	shl    %cl,%edx
    e8e1:	89 d0                	mov    %edx,%eax
    e8e3:	83 e8 01             	sub    $0x1,%eax
    e8e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    e8e9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e8f0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e8f7:	eb 79                	jmp    e972 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    e8f9:	8b 45 14             	mov    0x14(%ebp),%eax
    e8fc:	8b 40 04             	mov    0x4(%eax),%eax
    e8ff:	50                   	push   %eax
    e900:	ff 75 10             	pushl  0x10(%ebp)
    e903:	8d 45 e0             	lea    -0x20(%ebp),%eax
    e906:	50                   	push   %eax
    e907:	e8 c0 d4 ff ff       	call   bdcc <readBitsFromReversedStream>
    e90c:	83 c4 0c             	add    $0xc,%esp
    e90f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    e912:	8b 45 08             	mov    0x8(%ebp),%eax
    e915:	8d 48 01             	lea    0x1(%eax),%ecx
    e918:	8b 45 08             	mov    0x8(%ebp),%eax
    e91b:	8d 58 02             	lea    0x2(%eax),%ebx
    e91e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e921:	89 d0                	mov    %edx,%eax
    e923:	c1 e0 08             	shl    $0x8,%eax
    e926:	29 d0                	sub    %edx,%eax
    e928:	ba 00 00 00 00       	mov    $0x0,%edx
    e92d:	f7 75 f0             	divl   -0x10(%ebp)
    e930:	88 03                	mov    %al,(%ebx)
    e932:	0f b6 03             	movzbl (%ebx),%eax
    e935:	88 01                	mov    %al,(%ecx)
    e937:	0f b6 11             	movzbl (%ecx),%edx
    e93a:	8b 45 08             	mov    0x8(%ebp),%eax
    e93d:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    e93f:	8b 45 08             	mov    0x8(%ebp),%eax
    e942:	8d 50 03             	lea    0x3(%eax),%edx
    e945:	8b 45 14             	mov    0x14(%ebp),%eax
    e948:	8b 40 10             	mov    0x10(%eax),%eax
    e94b:	85 c0                	test   %eax,%eax
    e94d:	74 12                	je     e961 <getPixelColorsRGBA8+0x20d>
    e94f:	8b 45 14             	mov    0x14(%ebp),%eax
    e952:	8b 40 14             	mov    0x14(%eax),%eax
    e955:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e958:	75 07                	jne    e961 <getPixelColorsRGBA8+0x20d>
    e95a:	b8 00 00 00 00       	mov    $0x0,%eax
    e95f:	eb 05                	jmp    e966 <getPixelColorsRGBA8+0x212>
    e961:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    e966:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e968:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e96c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e96f:	01 45 08             	add    %eax,0x8(%ebp)
    e972:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e975:	3b 45 0c             	cmp    0xc(%ebp),%eax
    e978:	0f 85 7b ff ff ff    	jne    e8f9 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    e97e:	e9 9b 04 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    e983:	8b 45 14             	mov    0x14(%ebp),%eax
    e986:	8b 00                	mov    (%eax),%eax
    e988:	83 f8 02             	cmp    $0x2,%eax
    e98b:	0f 85 41 02 00 00    	jne    ebd2 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    e991:	8b 45 14             	mov    0x14(%ebp),%eax
    e994:	8b 40 04             	mov    0x4(%eax),%eax
    e997:	83 f8 08             	cmp    $0x8,%eax
    e99a:	0f 85 c4 00 00 00    	jne    ea64 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e9a0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e9a7:	eb 31                	jmp    e9da <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    e9a9:	8b 55 f8             	mov    -0x8(%ebp),%edx
    e9ac:	89 d0                	mov    %edx,%eax
    e9ae:	01 c0                	add    %eax,%eax
    e9b0:	01 d0                	add    %edx,%eax
    e9b2:	89 c2                	mov    %eax,%edx
    e9b4:	8b 45 10             	mov    0x10(%ebp),%eax
    e9b7:	01 d0                	add    %edx,%eax
    e9b9:	6a 03                	push   $0x3
    e9bb:	50                   	push   %eax
    e9bc:	ff 75 08             	pushl  0x8(%ebp)
    e9bf:	e8 a3 85 ff ff       	call   6f67 <lodepng_memcpy>
    e9c4:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    e9c7:	8b 45 08             	mov    0x8(%ebp),%eax
    e9ca:	83 c0 03             	add    $0x3,%eax
    e9cd:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e9d0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e9d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e9d7:	01 45 08             	add    %eax,0x8(%ebp)
    e9da:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e9dd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    e9e0:	75 c7                	jne    e9a9 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    e9e2:	8b 45 14             	mov    0x14(%ebp),%eax
    e9e5:	8b 40 10             	mov    0x10(%eax),%eax
    e9e8:	85 c0                	test   %eax,%eax
    e9ea:	0f 84 2e 04 00 00    	je     ee1e <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    e9f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9f3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e9f7:	f7 d8                	neg    %eax
    e9f9:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    e9fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ea03:	eb 52                	jmp    ea57 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    ea05:	8b 45 08             	mov    0x8(%ebp),%eax
    ea08:	0f b6 00             	movzbl (%eax),%eax
    ea0b:	0f b6 d0             	movzbl %al,%edx
    ea0e:	8b 45 14             	mov    0x14(%ebp),%eax
    ea11:	8b 40 14             	mov    0x14(%eax),%eax
    ea14:	39 c2                	cmp    %eax,%edx
    ea16:	75 35                	jne    ea4d <getPixelColorsRGBA8+0x2f9>
    ea18:	8b 45 08             	mov    0x8(%ebp),%eax
    ea1b:	83 c0 01             	add    $0x1,%eax
    ea1e:	0f b6 00             	movzbl (%eax),%eax
    ea21:	0f b6 d0             	movzbl %al,%edx
    ea24:	8b 45 14             	mov    0x14(%ebp),%eax
    ea27:	8b 40 18             	mov    0x18(%eax),%eax
    ea2a:	39 c2                	cmp    %eax,%edx
    ea2c:	75 1f                	jne    ea4d <getPixelColorsRGBA8+0x2f9>
    ea2e:	8b 45 08             	mov    0x8(%ebp),%eax
    ea31:	83 c0 02             	add    $0x2,%eax
    ea34:	0f b6 00             	movzbl (%eax),%eax
    ea37:	0f b6 d0             	movzbl %al,%edx
    ea3a:	8b 45 14             	mov    0x14(%ebp),%eax
    ea3d:	8b 40 1c             	mov    0x1c(%eax),%eax
    ea40:	39 c2                	cmp    %eax,%edx
    ea42:	75 09                	jne    ea4d <getPixelColorsRGBA8+0x2f9>
    ea44:	8b 45 08             	mov    0x8(%ebp),%eax
    ea47:	83 c0 03             	add    $0x3,%eax
    ea4a:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ea4d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ea51:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ea54:	01 45 08             	add    %eax,0x8(%ebp)
    ea57:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ea5a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ea5d:	75 a6                	jne    ea05 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ea5f:	e9 ba 03 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ea64:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ea6b:	e9 51 01 00 00       	jmp    ebc1 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    ea70:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ea73:	89 d0                	mov    %edx,%eax
    ea75:	01 c0                	add    %eax,%eax
    ea77:	01 d0                	add    %edx,%eax
    ea79:	01 c0                	add    %eax,%eax
    ea7b:	89 c2                	mov    %eax,%edx
    ea7d:	8b 45 10             	mov    0x10(%ebp),%eax
    ea80:	01 d0                	add    %edx,%eax
    ea82:	0f b6 10             	movzbl (%eax),%edx
    ea85:	8b 45 08             	mov    0x8(%ebp),%eax
    ea88:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    ea8a:	8b 45 08             	mov    0x8(%ebp),%eax
    ea8d:	8d 48 01             	lea    0x1(%eax),%ecx
    ea90:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ea93:	89 d0                	mov    %edx,%eax
    ea95:	01 c0                	add    %eax,%eax
    ea97:	01 d0                	add    %edx,%eax
    ea99:	01 c0                	add    %eax,%eax
    ea9b:	8d 50 02             	lea    0x2(%eax),%edx
    ea9e:	8b 45 10             	mov    0x10(%ebp),%eax
    eaa1:	01 d0                	add    %edx,%eax
    eaa3:	0f b6 00             	movzbl (%eax),%eax
    eaa6:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    eaa8:	8b 45 08             	mov    0x8(%ebp),%eax
    eaab:	8d 48 02             	lea    0x2(%eax),%ecx
    eaae:	8b 55 f8             	mov    -0x8(%ebp),%edx
    eab1:	89 d0                	mov    %edx,%eax
    eab3:	01 c0                	add    %eax,%eax
    eab5:	01 d0                	add    %edx,%eax
    eab7:	01 c0                	add    %eax,%eax
    eab9:	8d 50 04             	lea    0x4(%eax),%edx
    eabc:	8b 45 10             	mov    0x10(%ebp),%eax
    eabf:	01 d0                	add    %edx,%eax
    eac1:	0f b6 00             	movzbl (%eax),%eax
    eac4:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    eac6:	8b 45 08             	mov    0x8(%ebp),%eax
    eac9:	8d 48 03             	lea    0x3(%eax),%ecx
    eacc:	8b 45 14             	mov    0x14(%ebp),%eax
    eacf:	8b 40 10             	mov    0x10(%eax),%eax
    ead2:	85 c0                	test   %eax,%eax
    ead4:	0f 84 d6 00 00 00    	je     ebb0 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    eada:	8b 55 f8             	mov    -0x8(%ebp),%edx
    eadd:	89 d0                	mov    %edx,%eax
    eadf:	01 c0                	add    %eax,%eax
    eae1:	01 d0                	add    %edx,%eax
    eae3:	01 c0                	add    %eax,%eax
    eae5:	89 c2                	mov    %eax,%edx
    eae7:	8b 45 10             	mov    0x10(%ebp),%eax
    eaea:	01 d0                	add    %edx,%eax
    eaec:	0f b6 00             	movzbl (%eax),%eax
    eaef:	0f b6 c0             	movzbl %al,%eax
    eaf2:	c1 e0 08             	shl    $0x8,%eax
    eaf5:	89 c3                	mov    %eax,%ebx
    eaf7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    eafa:	89 d0                	mov    %edx,%eax
    eafc:	01 c0                	add    %eax,%eax
    eafe:	01 d0                	add    %edx,%eax
    eb00:	01 c0                	add    %eax,%eax
    eb02:	8d 50 01             	lea    0x1(%eax),%edx
    eb05:	8b 45 10             	mov    0x10(%ebp),%eax
    eb08:	01 d0                	add    %edx,%eax
    eb0a:	0f b6 00             	movzbl (%eax),%eax
    eb0d:	0f b6 c0             	movzbl %al,%eax
    eb10:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    eb13:	8b 45 14             	mov    0x14(%ebp),%eax
    eb16:	8b 40 14             	mov    0x14(%eax),%eax
    eb19:	39 c2                	cmp    %eax,%edx
    eb1b:	0f 85 8f 00 00 00    	jne    ebb0 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    eb21:	8b 55 f8             	mov    -0x8(%ebp),%edx
    eb24:	89 d0                	mov    %edx,%eax
    eb26:	01 c0                	add    %eax,%eax
    eb28:	01 d0                	add    %edx,%eax
    eb2a:	01 c0                	add    %eax,%eax
    eb2c:	8d 50 02             	lea    0x2(%eax),%edx
    eb2f:	8b 45 10             	mov    0x10(%ebp),%eax
    eb32:	01 d0                	add    %edx,%eax
    eb34:	0f b6 00             	movzbl (%eax),%eax
    eb37:	0f b6 c0             	movzbl %al,%eax
    eb3a:	c1 e0 08             	shl    $0x8,%eax
    eb3d:	89 c3                	mov    %eax,%ebx
    eb3f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    eb42:	89 d0                	mov    %edx,%eax
    eb44:	01 c0                	add    %eax,%eax
    eb46:	01 d0                	add    %edx,%eax
    eb48:	01 c0                	add    %eax,%eax
    eb4a:	8d 50 03             	lea    0x3(%eax),%edx
    eb4d:	8b 45 10             	mov    0x10(%ebp),%eax
    eb50:	01 d0                	add    %edx,%eax
    eb52:	0f b6 00             	movzbl (%eax),%eax
    eb55:	0f b6 c0             	movzbl %al,%eax
    eb58:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    eb5b:	8b 45 14             	mov    0x14(%ebp),%eax
    eb5e:	8b 40 18             	mov    0x18(%eax),%eax
    eb61:	39 c2                	cmp    %eax,%edx
    eb63:	75 4b                	jne    ebb0 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    eb65:	8b 55 f8             	mov    -0x8(%ebp),%edx
    eb68:	89 d0                	mov    %edx,%eax
    eb6a:	01 c0                	add    %eax,%eax
    eb6c:	01 d0                	add    %edx,%eax
    eb6e:	01 c0                	add    %eax,%eax
    eb70:	8d 50 04             	lea    0x4(%eax),%edx
    eb73:	8b 45 10             	mov    0x10(%ebp),%eax
    eb76:	01 d0                	add    %edx,%eax
    eb78:	0f b6 00             	movzbl (%eax),%eax
    eb7b:	0f b6 c0             	movzbl %al,%eax
    eb7e:	c1 e0 08             	shl    $0x8,%eax
    eb81:	89 c3                	mov    %eax,%ebx
    eb83:	8b 55 f8             	mov    -0x8(%ebp),%edx
    eb86:	89 d0                	mov    %edx,%eax
    eb88:	01 c0                	add    %eax,%eax
    eb8a:	01 d0                	add    %edx,%eax
    eb8c:	01 c0                	add    %eax,%eax
    eb8e:	8d 50 05             	lea    0x5(%eax),%edx
    eb91:	8b 45 10             	mov    0x10(%ebp),%eax
    eb94:	01 d0                	add    %edx,%eax
    eb96:	0f b6 00             	movzbl (%eax),%eax
    eb99:	0f b6 c0             	movzbl %al,%eax
    eb9c:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    eb9f:	8b 45 14             	mov    0x14(%ebp),%eax
    eba2:	8b 40 1c             	mov    0x1c(%eax),%eax
    eba5:	39 c2                	cmp    %eax,%edx
    eba7:	75 07                	jne    ebb0 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    eba9:	b8 00 00 00 00       	mov    $0x0,%eax
    ebae:	eb 05                	jmp    ebb5 <getPixelColorsRGBA8+0x461>
    ebb0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ebb5:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ebb7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ebbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ebbe:	01 45 08             	add    %eax,0x8(%ebp)
    ebc1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ebc4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ebc7:	0f 85 a3 fe ff ff    	jne    ea70 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ebcd:	e9 4c 02 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    ebd2:	8b 45 14             	mov    0x14(%ebp),%eax
    ebd5:	8b 00                	mov    (%eax),%eax
    ebd7:	83 f8 03             	cmp    $0x3,%eax
    ebda:	0f 85 b4 00 00 00    	jne    ec94 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    ebe0:	8b 45 14             	mov    0x14(%ebp),%eax
    ebe3:	8b 40 04             	mov    0x4(%eax),%eax
    ebe6:	83 f8 08             	cmp    $0x8,%eax
    ebe9:	75 4d                	jne    ec38 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ebeb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ebf2:	eb 37                	jmp    ec2b <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    ebf4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ebf7:	8b 45 10             	mov    0x10(%ebp),%eax
    ebfa:	01 d0                	add    %edx,%eax
    ebfc:	0f b6 00             	movzbl (%eax),%eax
    ebff:	0f b6 c0             	movzbl %al,%eax
    ec02:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    ec05:	8b 45 14             	mov    0x14(%ebp),%eax
    ec08:	8b 40 08             	mov    0x8(%eax),%eax
    ec0b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ec0e:	c1 e2 02             	shl    $0x2,%edx
    ec11:	01 d0                	add    %edx,%eax
    ec13:	6a 04                	push   $0x4
    ec15:	50                   	push   %eax
    ec16:	ff 75 08             	pushl  0x8(%ebp)
    ec19:	e8 49 83 ff ff       	call   6f67 <lodepng_memcpy>
    ec1e:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ec21:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ec25:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ec28:	01 45 08             	add    %eax,0x8(%ebp)
    ec2b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ec2e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ec31:	75 c1                	jne    ebf4 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ec33:	e9 e6 01 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    ec38:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ec3f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ec46:	eb 3f                	jmp    ec87 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ec48:	8b 45 14             	mov    0x14(%ebp),%eax
    ec4b:	8b 40 04             	mov    0x4(%eax),%eax
    ec4e:	50                   	push   %eax
    ec4f:	ff 75 10             	pushl  0x10(%ebp)
    ec52:	8d 45 dc             	lea    -0x24(%ebp),%eax
    ec55:	50                   	push   %eax
    ec56:	e8 71 d1 ff ff       	call   bdcc <readBitsFromReversedStream>
    ec5b:	83 c4 0c             	add    $0xc,%esp
    ec5e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    ec61:	8b 45 14             	mov    0x14(%ebp),%eax
    ec64:	8b 40 08             	mov    0x8(%eax),%eax
    ec67:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ec6a:	c1 e2 02             	shl    $0x2,%edx
    ec6d:	01 d0                	add    %edx,%eax
    ec6f:	6a 04                	push   $0x4
    ec71:	50                   	push   %eax
    ec72:	ff 75 08             	pushl  0x8(%ebp)
    ec75:	e8 ed 82 ff ff       	call   6f67 <lodepng_memcpy>
    ec7a:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ec7d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ec81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ec84:	01 45 08             	add    %eax,0x8(%ebp)
    ec87:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ec8a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ec8d:	75 b9                	jne    ec48 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ec8f:	e9 8a 01 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    ec94:	8b 45 14             	mov    0x14(%ebp),%eax
    ec97:	8b 00                	mov    (%eax),%eax
    ec99:	83 f8 04             	cmp    $0x4,%eax
    ec9c:	0f 85 d1 00 00 00    	jne    ed73 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    eca2:	8b 45 14             	mov    0x14(%ebp),%eax
    eca5:	8b 40 04             	mov    0x4(%eax),%eax
    eca8:	83 f8 08             	cmp    $0x8,%eax
    ecab:	75 62                	jne    ed0f <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ecad:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ecb4:	eb 4c                	jmp    ed02 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    ecb6:	8b 45 08             	mov    0x8(%ebp),%eax
    ecb9:	83 c0 01             	add    $0x1,%eax
    ecbc:	8b 55 08             	mov    0x8(%ebp),%edx
    ecbf:	83 c2 02             	add    $0x2,%edx
    ecc2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ecc5:	01 c9                	add    %ecx,%ecx
    ecc7:	89 cb                	mov    %ecx,%ebx
    ecc9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    eccc:	01 d9                	add    %ebx,%ecx
    ecce:	0f b6 09             	movzbl (%ecx),%ecx
    ecd1:	88 0a                	mov    %cl,(%edx)
    ecd3:	0f b6 12             	movzbl (%edx),%edx
    ecd6:	88 10                	mov    %dl,(%eax)
    ecd8:	0f b6 10             	movzbl (%eax),%edx
    ecdb:	8b 45 08             	mov    0x8(%ebp),%eax
    ecde:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    ece0:	8b 45 08             	mov    0x8(%ebp),%eax
    ece3:	8d 50 03             	lea    0x3(%eax),%edx
    ece6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ece9:	01 c0                	add    %eax,%eax
    eceb:	8d 48 01             	lea    0x1(%eax),%ecx
    ecee:	8b 45 10             	mov    0x10(%ebp),%eax
    ecf1:	01 c8                	add    %ecx,%eax
    ecf3:	0f b6 00             	movzbl (%eax),%eax
    ecf6:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ecf8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ecfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ecff:	01 45 08             	add    %eax,0x8(%ebp)
    ed02:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ed05:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ed08:	75 ac                	jne    ecb6 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ed0a:	e9 0f 01 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ed0f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ed16:	eb 4e                	jmp    ed66 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    ed18:	8b 45 08             	mov    0x8(%ebp),%eax
    ed1b:	83 c0 01             	add    $0x1,%eax
    ed1e:	8b 55 08             	mov    0x8(%ebp),%edx
    ed21:	83 c2 02             	add    $0x2,%edx
    ed24:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ed27:	c1 e1 02             	shl    $0x2,%ecx
    ed2a:	89 cb                	mov    %ecx,%ebx
    ed2c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed2f:	01 d9                	add    %ebx,%ecx
    ed31:	0f b6 09             	movzbl (%ecx),%ecx
    ed34:	88 0a                	mov    %cl,(%edx)
    ed36:	0f b6 12             	movzbl (%edx),%edx
    ed39:	88 10                	mov    %dl,(%eax)
    ed3b:	0f b6 10             	movzbl (%eax),%edx
    ed3e:	8b 45 08             	mov    0x8(%ebp),%eax
    ed41:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    ed43:	8b 45 08             	mov    0x8(%ebp),%eax
    ed46:	8d 50 03             	lea    0x3(%eax),%edx
    ed49:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ed4c:	c1 e0 02             	shl    $0x2,%eax
    ed4f:	8d 48 02             	lea    0x2(%eax),%ecx
    ed52:	8b 45 10             	mov    0x10(%ebp),%eax
    ed55:	01 c8                	add    %ecx,%eax
    ed57:	0f b6 00             	movzbl (%eax),%eax
    ed5a:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ed5c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ed60:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ed63:	01 45 08             	add    %eax,0x8(%ebp)
    ed66:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ed69:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ed6c:	75 aa                	jne    ed18 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ed6e:	e9 ab 00 00 00       	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    ed73:	8b 45 14             	mov    0x14(%ebp),%eax
    ed76:	8b 00                	mov    (%eax),%eax
    ed78:	83 f8 06             	cmp    $0x6,%eax
    ed7b:	0f 85 9d 00 00 00    	jne    ee1e <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    ed81:	8b 45 14             	mov    0x14(%ebp),%eax
    ed84:	8b 40 04             	mov    0x4(%eax),%eax
    ed87:	83 f8 08             	cmp    $0x8,%eax
    ed8a:	75 17                	jne    eda3 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    ed8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed8f:	c1 e0 02             	shl    $0x2,%eax
    ed92:	50                   	push   %eax
    ed93:	ff 75 10             	pushl  0x10(%ebp)
    ed96:	ff 75 08             	pushl  0x8(%ebp)
    ed99:	e8 c9 81 ff ff       	call   6f67 <lodepng_memcpy>
    ed9e:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    eda1:	eb 7b                	jmp    ee1e <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    eda3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    edaa:	eb 6a                	jmp    ee16 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    edac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    edaf:	c1 e0 03             	shl    $0x3,%eax
    edb2:	89 c2                	mov    %eax,%edx
    edb4:	8b 45 10             	mov    0x10(%ebp),%eax
    edb7:	01 d0                	add    %edx,%eax
    edb9:	0f b6 10             	movzbl (%eax),%edx
    edbc:	8b 45 08             	mov    0x8(%ebp),%eax
    edbf:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    edc1:	8b 45 08             	mov    0x8(%ebp),%eax
    edc4:	8d 50 01             	lea    0x1(%eax),%edx
    edc7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    edca:	c1 e0 03             	shl    $0x3,%eax
    edcd:	8d 48 02             	lea    0x2(%eax),%ecx
    edd0:	8b 45 10             	mov    0x10(%ebp),%eax
    edd3:	01 c8                	add    %ecx,%eax
    edd5:	0f b6 00             	movzbl (%eax),%eax
    edd8:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    edda:	8b 45 08             	mov    0x8(%ebp),%eax
    eddd:	8d 50 02             	lea    0x2(%eax),%edx
    ede0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ede3:	c1 e0 03             	shl    $0x3,%eax
    ede6:	8d 48 04             	lea    0x4(%eax),%ecx
    ede9:	8b 45 10             	mov    0x10(%ebp),%eax
    edec:	01 c8                	add    %ecx,%eax
    edee:	0f b6 00             	movzbl (%eax),%eax
    edf1:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    edf3:	8b 45 08             	mov    0x8(%ebp),%eax
    edf6:	8d 50 03             	lea    0x3(%eax),%edx
    edf9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    edfc:	c1 e0 03             	shl    $0x3,%eax
    edff:	8d 48 06             	lea    0x6(%eax),%ecx
    ee02:	8b 45 10             	mov    0x10(%ebp),%eax
    ee05:	01 c8                	add    %ecx,%eax
    ee07:	0f b6 00             	movzbl (%eax),%eax
    ee0a:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ee0c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ee10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee13:	01 45 08             	add    %eax,0x8(%ebp)
    ee16:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ee19:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ee1c:	75 8e                	jne    edac <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ee1e:	90                   	nop
    ee1f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    ee22:	c9                   	leave  
    ee23:	c3                   	ret    

0000ee24 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    ee24:	55                   	push   %ebp
    ee25:	89 e5                	mov    %esp,%ebp
    ee27:	53                   	push   %ebx
    ee28:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    ee2b:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ee32:	8b 45 14             	mov    0x14(%ebp),%eax
    ee35:	8b 00                	mov    (%eax),%eax
    ee37:	85 c0                	test   %eax,%eax
    ee39:	0f 85 2a 01 00 00    	jne    ef69 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    ee3f:	8b 45 14             	mov    0x14(%ebp),%eax
    ee42:	8b 40 04             	mov    0x4(%eax),%eax
    ee45:	83 f8 08             	cmp    $0x8,%eax
    ee48:	75 46                	jne    ee90 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ee4a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ee51:	eb 30                	jmp    ee83 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ee53:	8b 45 08             	mov    0x8(%ebp),%eax
    ee56:	83 c0 01             	add    $0x1,%eax
    ee59:	8b 55 08             	mov    0x8(%ebp),%edx
    ee5c:	83 c2 02             	add    $0x2,%edx
    ee5f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ee62:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ee65:	01 d9                	add    %ebx,%ecx
    ee67:	0f b6 09             	movzbl (%ecx),%ecx
    ee6a:	88 0a                	mov    %cl,(%edx)
    ee6c:	0f b6 12             	movzbl (%edx),%edx
    ee6f:	88 10                	mov    %dl,(%eax)
    ee71:	0f b6 10             	movzbl (%eax),%edx
    ee74:	8b 45 08             	mov    0x8(%ebp),%eax
    ee77:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ee79:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ee7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ee80:	01 45 08             	add    %eax,0x8(%ebp)
    ee83:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ee86:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ee89:	75 c8                	jne    ee53 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    ee8b:	e9 a8 03 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    ee90:	8b 45 14             	mov    0x14(%ebp),%eax
    ee93:	8b 40 04             	mov    0x4(%eax),%eax
    ee96:	83 f8 10             	cmp    $0x10,%eax
    ee99:	75 4a                	jne    eee5 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ee9b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    eea2:	eb 34                	jmp    eed8 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    eea4:	8b 45 08             	mov    0x8(%ebp),%eax
    eea7:	83 c0 01             	add    $0x1,%eax
    eeaa:	8b 55 08             	mov    0x8(%ebp),%edx
    eead:	83 c2 02             	add    $0x2,%edx
    eeb0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    eeb3:	01 c9                	add    %ecx,%ecx
    eeb5:	89 cb                	mov    %ecx,%ebx
    eeb7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    eeba:	01 d9                	add    %ebx,%ecx
    eebc:	0f b6 09             	movzbl (%ecx),%ecx
    eebf:	88 0a                	mov    %cl,(%edx)
    eec1:	0f b6 12             	movzbl (%edx),%edx
    eec4:	88 10                	mov    %dl,(%eax)
    eec6:	0f b6 10             	movzbl (%eax),%edx
    eec9:	8b 45 08             	mov    0x8(%ebp),%eax
    eecc:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    eece:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    eed2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    eed5:	01 45 08             	add    %eax,0x8(%ebp)
    eed8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    eedb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    eede:	75 c4                	jne    eea4 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    eee0:	e9 53 03 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    eee5:	8b 45 14             	mov    0x14(%ebp),%eax
    eee8:	8b 40 04             	mov    0x4(%eax),%eax
    eeeb:	ba 01 00 00 00       	mov    $0x1,%edx
    eef0:	89 c1                	mov    %eax,%ecx
    eef2:	d3 e2                	shl    %cl,%edx
    eef4:	89 d0                	mov    %edx,%eax
    eef6:	83 e8 01             	sub    $0x1,%eax
    eef9:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    eefc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ef03:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ef0a:	eb 50                	jmp    ef5c <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ef0c:	8b 45 14             	mov    0x14(%ebp),%eax
    ef0f:	8b 40 04             	mov    0x4(%eax),%eax
    ef12:	50                   	push   %eax
    ef13:	ff 75 10             	pushl  0x10(%ebp)
    ef16:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ef19:	50                   	push   %eax
    ef1a:	e8 ad ce ff ff       	call   bdcc <readBitsFromReversedStream>
    ef1f:	83 c4 0c             	add    $0xc,%esp
    ef22:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ef25:	8b 45 08             	mov    0x8(%ebp),%eax
    ef28:	8d 48 01             	lea    0x1(%eax),%ecx
    ef2b:	8b 45 08             	mov    0x8(%ebp),%eax
    ef2e:	8d 58 02             	lea    0x2(%eax),%ebx
    ef31:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ef34:	89 d0                	mov    %edx,%eax
    ef36:	c1 e0 08             	shl    $0x8,%eax
    ef39:	29 d0                	sub    %edx,%eax
    ef3b:	ba 00 00 00 00       	mov    $0x0,%edx
    ef40:	f7 75 f0             	divl   -0x10(%ebp)
    ef43:	88 03                	mov    %al,(%ebx)
    ef45:	0f b6 03             	movzbl (%ebx),%eax
    ef48:	88 01                	mov    %al,(%ecx)
    ef4a:	0f b6 11             	movzbl (%ecx),%edx
    ef4d:	8b 45 08             	mov    0x8(%ebp),%eax
    ef50:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ef52:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ef56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ef59:	01 45 08             	add    %eax,0x8(%ebp)
    ef5c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ef5f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ef62:	75 a8                	jne    ef0c <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    ef64:	e9 cf 02 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ef69:	8b 45 14             	mov    0x14(%ebp),%eax
    ef6c:	8b 00                	mov    (%eax),%eax
    ef6e:	83 f8 02             	cmp    $0x2,%eax
    ef71:	0f 85 9e 00 00 00    	jne    f015 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    ef77:	8b 45 14             	mov    0x14(%ebp),%eax
    ef7a:	8b 40 04             	mov    0x4(%eax),%eax
    ef7d:	83 f8 08             	cmp    $0x8,%eax
    ef80:	75 1d                	jne    ef9f <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    ef82:	8b 55 0c             	mov    0xc(%ebp),%edx
    ef85:	89 d0                	mov    %edx,%eax
    ef87:	01 c0                	add    %eax,%eax
    ef89:	01 d0                	add    %edx,%eax
    ef8b:	50                   	push   %eax
    ef8c:	ff 75 10             	pushl  0x10(%ebp)
    ef8f:	ff 75 08             	pushl  0x8(%ebp)
    ef92:	e8 d0 7f ff ff       	call   6f67 <lodepng_memcpy>
    ef97:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    ef9a:	e9 99 02 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ef9f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    efa6:	eb 60                	jmp    f008 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    efa8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    efab:	89 d0                	mov    %edx,%eax
    efad:	01 c0                	add    %eax,%eax
    efaf:	01 d0                	add    %edx,%eax
    efb1:	01 c0                	add    %eax,%eax
    efb3:	89 c2                	mov    %eax,%edx
    efb5:	8b 45 10             	mov    0x10(%ebp),%eax
    efb8:	01 d0                	add    %edx,%eax
    efba:	0f b6 10             	movzbl (%eax),%edx
    efbd:	8b 45 08             	mov    0x8(%ebp),%eax
    efc0:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    efc2:	8b 45 08             	mov    0x8(%ebp),%eax
    efc5:	8d 48 01             	lea    0x1(%eax),%ecx
    efc8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    efcb:	89 d0                	mov    %edx,%eax
    efcd:	01 c0                	add    %eax,%eax
    efcf:	01 d0                	add    %edx,%eax
    efd1:	01 c0                	add    %eax,%eax
    efd3:	8d 50 02             	lea    0x2(%eax),%edx
    efd6:	8b 45 10             	mov    0x10(%ebp),%eax
    efd9:	01 d0                	add    %edx,%eax
    efdb:	0f b6 00             	movzbl (%eax),%eax
    efde:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    efe0:	8b 45 08             	mov    0x8(%ebp),%eax
    efe3:	8d 48 02             	lea    0x2(%eax),%ecx
    efe6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    efe9:	89 d0                	mov    %edx,%eax
    efeb:	01 c0                	add    %eax,%eax
    efed:	01 d0                	add    %edx,%eax
    efef:	01 c0                	add    %eax,%eax
    eff1:	8d 50 04             	lea    0x4(%eax),%edx
    eff4:	8b 45 10             	mov    0x10(%ebp),%eax
    eff7:	01 d0                	add    %edx,%eax
    eff9:	0f b6 00             	movzbl (%eax),%eax
    effc:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    effe:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f002:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f005:	01 45 08             	add    %eax,0x8(%ebp)
    f008:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f00b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    f00e:	75 98                	jne    efa8 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    f010:	e9 23 02 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    f015:	8b 45 14             	mov    0x14(%ebp),%eax
    f018:	8b 00                	mov    (%eax),%eax
    f01a:	83 f8 03             	cmp    $0x3,%eax
    f01d:	0f 85 b4 00 00 00    	jne    f0d7 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    f023:	8b 45 14             	mov    0x14(%ebp),%eax
    f026:	8b 40 04             	mov    0x4(%eax),%eax
    f029:	83 f8 08             	cmp    $0x8,%eax
    f02c:	75 4d                	jne    f07b <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f02e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f035:	eb 37                	jmp    f06e <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    f037:	8b 55 f8             	mov    -0x8(%ebp),%edx
    f03a:	8b 45 10             	mov    0x10(%ebp),%eax
    f03d:	01 d0                	add    %edx,%eax
    f03f:	0f b6 00             	movzbl (%eax),%eax
    f042:	0f b6 c0             	movzbl %al,%eax
    f045:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    f048:	8b 45 14             	mov    0x14(%ebp),%eax
    f04b:	8b 40 08             	mov    0x8(%eax),%eax
    f04e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f051:	c1 e2 02             	shl    $0x2,%edx
    f054:	01 d0                	add    %edx,%eax
    f056:	6a 03                	push   $0x3
    f058:	50                   	push   %eax
    f059:	ff 75 08             	pushl  0x8(%ebp)
    f05c:	e8 06 7f ff ff       	call   6f67 <lodepng_memcpy>
    f061:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f064:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f068:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f06b:	01 45 08             	add    %eax,0x8(%ebp)
    f06e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f071:	3b 45 0c             	cmp    0xc(%ebp),%eax
    f074:	75 c1                	jne    f037 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    f076:	e9 bd 01 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    f07b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f082:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f089:	eb 3f                	jmp    f0ca <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    f08b:	8b 45 14             	mov    0x14(%ebp),%eax
    f08e:	8b 40 04             	mov    0x4(%eax),%eax
    f091:	50                   	push   %eax
    f092:	ff 75 10             	pushl  0x10(%ebp)
    f095:	8d 45 dc             	lea    -0x24(%ebp),%eax
    f098:	50                   	push   %eax
    f099:	e8 2e cd ff ff       	call   bdcc <readBitsFromReversedStream>
    f09e:	83 c4 0c             	add    $0xc,%esp
    f0a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    f0a4:	8b 45 14             	mov    0x14(%ebp),%eax
    f0a7:	8b 40 08             	mov    0x8(%eax),%eax
    f0aa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f0ad:	c1 e2 02             	shl    $0x2,%edx
    f0b0:	01 d0                	add    %edx,%eax
    f0b2:	6a 03                	push   $0x3
    f0b4:	50                   	push   %eax
    f0b5:	ff 75 08             	pushl  0x8(%ebp)
    f0b8:	e8 aa 7e ff ff       	call   6f67 <lodepng_memcpy>
    f0bd:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f0c0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f0c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f0c7:	01 45 08             	add    %eax,0x8(%ebp)
    f0ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f0cd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    f0d0:	75 b9                	jne    f08b <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    f0d2:	e9 61 01 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    f0d7:	8b 45 14             	mov    0x14(%ebp),%eax
    f0da:	8b 00                	mov    (%eax),%eax
    f0dc:	83 f8 04             	cmp    $0x4,%eax
    f0df:	0f 85 a0 00 00 00    	jne    f185 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    f0e5:	8b 45 14             	mov    0x14(%ebp),%eax
    f0e8:	8b 40 04             	mov    0x4(%eax),%eax
    f0eb:	83 f8 08             	cmp    $0x8,%eax
    f0ee:	75 4a                	jne    f13a <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f0f0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f0f7:	eb 34                	jmp    f12d <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    f0f9:	8b 45 08             	mov    0x8(%ebp),%eax
    f0fc:	83 c0 01             	add    $0x1,%eax
    f0ff:	8b 55 08             	mov    0x8(%ebp),%edx
    f102:	83 c2 02             	add    $0x2,%edx
    f105:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    f108:	01 c9                	add    %ecx,%ecx
    f10a:	89 cb                	mov    %ecx,%ebx
    f10c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f10f:	01 d9                	add    %ebx,%ecx
    f111:	0f b6 09             	movzbl (%ecx),%ecx
    f114:	88 0a                	mov    %cl,(%edx)
    f116:	0f b6 12             	movzbl (%edx),%edx
    f119:	88 10                	mov    %dl,(%eax)
    f11b:	0f b6 10             	movzbl (%eax),%edx
    f11e:	8b 45 08             	mov    0x8(%ebp),%eax
    f121:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f123:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f127:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f12a:	01 45 08             	add    %eax,0x8(%ebp)
    f12d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f130:	3b 45 0c             	cmp    0xc(%ebp),%eax
    f133:	75 c4                	jne    f0f9 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    f135:	e9 fe 00 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f13a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f141:	eb 35                	jmp    f178 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    f143:	8b 45 08             	mov    0x8(%ebp),%eax
    f146:	83 c0 01             	add    $0x1,%eax
    f149:	8b 55 08             	mov    0x8(%ebp),%edx
    f14c:	83 c2 02             	add    $0x2,%edx
    f14f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    f152:	c1 e1 02             	shl    $0x2,%ecx
    f155:	89 cb                	mov    %ecx,%ebx
    f157:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f15a:	01 d9                	add    %ebx,%ecx
    f15c:	0f b6 09             	movzbl (%ecx),%ecx
    f15f:	88 0a                	mov    %cl,(%edx)
    f161:	0f b6 12             	movzbl (%edx),%edx
    f164:	88 10                	mov    %dl,(%eax)
    f166:	0f b6 10             	movzbl (%eax),%edx
    f169:	8b 45 08             	mov    0x8(%ebp),%eax
    f16c:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f16e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f172:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f175:	01 45 08             	add    %eax,0x8(%ebp)
    f178:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f17b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    f17e:	75 c3                	jne    f143 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    f180:	e9 b3 00 00 00       	jmp    f238 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    f185:	8b 45 14             	mov    0x14(%ebp),%eax
    f188:	8b 00                	mov    (%eax),%eax
    f18a:	83 f8 06             	cmp    $0x6,%eax
    f18d:	0f 85 a5 00 00 00    	jne    f238 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    f193:	8b 45 14             	mov    0x14(%ebp),%eax
    f196:	8b 40 04             	mov    0x4(%eax),%eax
    f199:	83 f8 08             	cmp    $0x8,%eax
    f19c:	75 38                	jne    f1d6 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f19e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f1a5:	eb 25                	jmp    f1cc <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    f1a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f1aa:	c1 e0 02             	shl    $0x2,%eax
    f1ad:	89 c2                	mov    %eax,%edx
    f1af:	8b 45 10             	mov    0x10(%ebp),%eax
    f1b2:	01 d0                	add    %edx,%eax
    f1b4:	6a 03                	push   $0x3
    f1b6:	50                   	push   %eax
    f1b7:	ff 75 08             	pushl  0x8(%ebp)
    f1ba:	e8 a8 7d ff ff       	call   6f67 <lodepng_memcpy>
    f1bf:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f1c2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f1c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f1c9:	01 45 08             	add    %eax,0x8(%ebp)
    f1cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f1cf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    f1d2:	75 d3                	jne    f1a7 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    f1d4:	eb 62                	jmp    f238 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f1d6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f1dd:	eb 51                	jmp    f230 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    f1df:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f1e2:	c1 e0 03             	shl    $0x3,%eax
    f1e5:	89 c2                	mov    %eax,%edx
    f1e7:	8b 45 10             	mov    0x10(%ebp),%eax
    f1ea:	01 d0                	add    %edx,%eax
    f1ec:	0f b6 10             	movzbl (%eax),%edx
    f1ef:	8b 45 08             	mov    0x8(%ebp),%eax
    f1f2:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    f1f4:	8b 45 08             	mov    0x8(%ebp),%eax
    f1f7:	8d 50 01             	lea    0x1(%eax),%edx
    f1fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f1fd:	c1 e0 03             	shl    $0x3,%eax
    f200:	8d 48 02             	lea    0x2(%eax),%ecx
    f203:	8b 45 10             	mov    0x10(%ebp),%eax
    f206:	01 c8                	add    %ecx,%eax
    f208:	0f b6 00             	movzbl (%eax),%eax
    f20b:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    f20d:	8b 45 08             	mov    0x8(%ebp),%eax
    f210:	8d 50 02             	lea    0x2(%eax),%edx
    f213:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f216:	c1 e0 03             	shl    $0x3,%eax
    f219:	8d 48 04             	lea    0x4(%eax),%ecx
    f21c:	8b 45 10             	mov    0x10(%ebp),%eax
    f21f:	01 c8                	add    %ecx,%eax
    f221:	0f b6 00             	movzbl (%eax),%eax
    f224:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    f226:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    f22a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f22d:	01 45 08             	add    %eax,0x8(%ebp)
    f230:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f233:	3b 45 0c             	cmp    0xc(%ebp),%eax
    f236:	75 a7                	jne    f1df <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    f238:	90                   	nop
    f239:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f23c:	c9                   	leave  
    f23d:	c3                   	ret    

0000f23e <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    f23e:	55                   	push   %ebp
    f23f:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    f241:	8b 45 20             	mov    0x20(%ebp),%eax
    f244:	8b 00                	mov    (%eax),%eax
    f246:	85 c0                	test   %eax,%eax
    f248:	0f 85 a4 00 00 00    	jne    f2f2 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    f24e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f251:	01 c0                	add    %eax,%eax
    f253:	89 c2                	mov    %eax,%edx
    f255:	8b 45 18             	mov    0x18(%ebp),%eax
    f258:	01 d0                	add    %edx,%eax
    f25a:	0f b6 00             	movzbl (%eax),%eax
    f25d:	0f b6 c0             	movzbl %al,%eax
    f260:	c1 e0 08             	shl    $0x8,%eax
    f263:	89 c2                	mov    %eax,%edx
    f265:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f268:	01 c0                	add    %eax,%eax
    f26a:	8d 48 01             	lea    0x1(%eax),%ecx
    f26d:	8b 45 18             	mov    0x18(%ebp),%eax
    f270:	01 c8                	add    %ecx,%eax
    f272:	0f b6 00             	movzbl (%eax),%eax
    f275:	0f b6 c0             	movzbl %al,%eax
    f278:	01 c2                	add    %eax,%edx
    f27a:	8b 45 10             	mov    0x10(%ebp),%eax
    f27d:	66 89 10             	mov    %dx,(%eax)
    f280:	8b 45 10             	mov    0x10(%ebp),%eax
    f283:	0f b7 10             	movzwl (%eax),%edx
    f286:	8b 45 0c             	mov    0xc(%ebp),%eax
    f289:	66 89 10             	mov    %dx,(%eax)
    f28c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f28f:	0f b7 10             	movzwl (%eax),%edx
    f292:	8b 45 08             	mov    0x8(%ebp),%eax
    f295:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    f298:	8b 45 20             	mov    0x20(%ebp),%eax
    f29b:	8b 40 10             	mov    0x10(%eax),%eax
    f29e:	85 c0                	test   %eax,%eax
    f2a0:	74 43                	je     f2e5 <getPixelColorRGBA16+0xa7>
    f2a2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f2a5:	01 c0                	add    %eax,%eax
    f2a7:	89 c2                	mov    %eax,%edx
    f2a9:	8b 45 18             	mov    0x18(%ebp),%eax
    f2ac:	01 d0                	add    %edx,%eax
    f2ae:	0f b6 00             	movzbl (%eax),%eax
    f2b1:	0f b6 c0             	movzbl %al,%eax
    f2b4:	c1 e0 08             	shl    $0x8,%eax
    f2b7:	89 c2                	mov    %eax,%edx
    f2b9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f2bc:	01 c0                	add    %eax,%eax
    f2be:	8d 48 01             	lea    0x1(%eax),%ecx
    f2c1:	8b 45 18             	mov    0x18(%ebp),%eax
    f2c4:	01 c8                	add    %ecx,%eax
    f2c6:	0f b6 00             	movzbl (%eax),%eax
    f2c9:	0f b6 c0             	movzbl %al,%eax
    f2cc:	01 c2                	add    %eax,%edx
    f2ce:	8b 45 20             	mov    0x20(%ebp),%eax
    f2d1:	8b 40 14             	mov    0x14(%eax),%eax
    f2d4:	39 c2                	cmp    %eax,%edx
    f2d6:	75 0d                	jne    f2e5 <getPixelColorRGBA16+0xa7>
    f2d8:	8b 45 14             	mov    0x14(%ebp),%eax
    f2db:	66 c7 00 00 00       	movw   $0x0,(%eax)
    f2e0:	e9 48 03 00 00       	jmp    f62d <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    f2e5:	8b 45 14             	mov    0x14(%ebp),%eax
    f2e8:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    f2ed:	e9 3b 03 00 00       	jmp    f62d <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    f2f2:	8b 45 20             	mov    0x20(%ebp),%eax
    f2f5:	8b 00                	mov    (%eax),%eax
    f2f7:	83 f8 02             	cmp    $0x2,%eax
    f2fa:	0f 85 b6 01 00 00    	jne    f4b6 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    f300:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f303:	89 d0                	mov    %edx,%eax
    f305:	01 c0                	add    %eax,%eax
    f307:	01 d0                	add    %edx,%eax
    f309:	01 c0                	add    %eax,%eax
    f30b:	89 c2                	mov    %eax,%edx
    f30d:	8b 45 18             	mov    0x18(%ebp),%eax
    f310:	01 d0                	add    %edx,%eax
    f312:	0f b6 00             	movzbl (%eax),%eax
    f315:	0f b6 c0             	movzbl %al,%eax
    f318:	c1 e0 08             	shl    $0x8,%eax
    f31b:	89 c1                	mov    %eax,%ecx
    f31d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f320:	89 d0                	mov    %edx,%eax
    f322:	01 c0                	add    %eax,%eax
    f324:	01 d0                	add    %edx,%eax
    f326:	01 c0                	add    %eax,%eax
    f328:	8d 50 01             	lea    0x1(%eax),%edx
    f32b:	8b 45 18             	mov    0x18(%ebp),%eax
    f32e:	01 d0                	add    %edx,%eax
    f330:	0f b6 00             	movzbl (%eax),%eax
    f333:	0f b6 c0             	movzbl %al,%eax
    f336:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    f339:	8b 45 08             	mov    0x8(%ebp),%eax
    f33c:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    f33f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f342:	89 d0                	mov    %edx,%eax
    f344:	01 c0                	add    %eax,%eax
    f346:	01 d0                	add    %edx,%eax
    f348:	01 c0                	add    %eax,%eax
    f34a:	8d 50 02             	lea    0x2(%eax),%edx
    f34d:	8b 45 18             	mov    0x18(%ebp),%eax
    f350:	01 d0                	add    %edx,%eax
    f352:	0f b6 00             	movzbl (%eax),%eax
    f355:	0f b6 c0             	movzbl %al,%eax
    f358:	c1 e0 08             	shl    $0x8,%eax
    f35b:	89 c1                	mov    %eax,%ecx
    f35d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f360:	89 d0                	mov    %edx,%eax
    f362:	01 c0                	add    %eax,%eax
    f364:	01 d0                	add    %edx,%eax
    f366:	01 c0                	add    %eax,%eax
    f368:	8d 50 03             	lea    0x3(%eax),%edx
    f36b:	8b 45 18             	mov    0x18(%ebp),%eax
    f36e:	01 d0                	add    %edx,%eax
    f370:	0f b6 00             	movzbl (%eax),%eax
    f373:	0f b6 c0             	movzbl %al,%eax
    f376:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    f379:	8b 45 0c             	mov    0xc(%ebp),%eax
    f37c:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    f37f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f382:	89 d0                	mov    %edx,%eax
    f384:	01 c0                	add    %eax,%eax
    f386:	01 d0                	add    %edx,%eax
    f388:	01 c0                	add    %eax,%eax
    f38a:	8d 50 04             	lea    0x4(%eax),%edx
    f38d:	8b 45 18             	mov    0x18(%ebp),%eax
    f390:	01 d0                	add    %edx,%eax
    f392:	0f b6 00             	movzbl (%eax),%eax
    f395:	0f b6 c0             	movzbl %al,%eax
    f398:	c1 e0 08             	shl    $0x8,%eax
    f39b:	89 c1                	mov    %eax,%ecx
    f39d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f3a0:	89 d0                	mov    %edx,%eax
    f3a2:	01 c0                	add    %eax,%eax
    f3a4:	01 d0                	add    %edx,%eax
    f3a6:	01 c0                	add    %eax,%eax
    f3a8:	8d 50 05             	lea    0x5(%eax),%edx
    f3ab:	8b 45 18             	mov    0x18(%ebp),%eax
    f3ae:	01 d0                	add    %edx,%eax
    f3b0:	0f b6 00             	movzbl (%eax),%eax
    f3b3:	0f b6 c0             	movzbl %al,%eax
    f3b6:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    f3b9:	8b 45 10             	mov    0x10(%ebp),%eax
    f3bc:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    f3bf:	8b 45 20             	mov    0x20(%ebp),%eax
    f3c2:	8b 40 10             	mov    0x10(%eax),%eax
    f3c5:	85 c0                	test   %eax,%eax
    f3c7:	0f 84 dc 00 00 00    	je     f4a9 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    f3cd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f3d0:	89 d0                	mov    %edx,%eax
    f3d2:	01 c0                	add    %eax,%eax
    f3d4:	01 d0                	add    %edx,%eax
    f3d6:	01 c0                	add    %eax,%eax
    f3d8:	89 c2                	mov    %eax,%edx
    f3da:	8b 45 18             	mov    0x18(%ebp),%eax
    f3dd:	01 d0                	add    %edx,%eax
    f3df:	0f b6 00             	movzbl (%eax),%eax
    f3e2:	0f b6 c0             	movzbl %al,%eax
    f3e5:	c1 e0 08             	shl    $0x8,%eax
    f3e8:	89 c1                	mov    %eax,%ecx
    f3ea:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f3ed:	89 d0                	mov    %edx,%eax
    f3ef:	01 c0                	add    %eax,%eax
    f3f1:	01 d0                	add    %edx,%eax
    f3f3:	01 c0                	add    %eax,%eax
    f3f5:	8d 50 01             	lea    0x1(%eax),%edx
    f3f8:	8b 45 18             	mov    0x18(%ebp),%eax
    f3fb:	01 d0                	add    %edx,%eax
    f3fd:	0f b6 00             	movzbl (%eax),%eax
    f400:	0f b6 c0             	movzbl %al,%eax
    f403:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    f406:	8b 45 20             	mov    0x20(%ebp),%eax
    f409:	8b 40 14             	mov    0x14(%eax),%eax
    f40c:	39 c2                	cmp    %eax,%edx
    f40e:	0f 85 95 00 00 00    	jne    f4a9 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    f414:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f417:	89 d0                	mov    %edx,%eax
    f419:	01 c0                	add    %eax,%eax
    f41b:	01 d0                	add    %edx,%eax
    f41d:	01 c0                	add    %eax,%eax
    f41f:	8d 50 02             	lea    0x2(%eax),%edx
    f422:	8b 45 18             	mov    0x18(%ebp),%eax
    f425:	01 d0                	add    %edx,%eax
    f427:	0f b6 00             	movzbl (%eax),%eax
    f42a:	0f b6 c0             	movzbl %al,%eax
    f42d:	c1 e0 08             	shl    $0x8,%eax
    f430:	89 c1                	mov    %eax,%ecx
    f432:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f435:	89 d0                	mov    %edx,%eax
    f437:	01 c0                	add    %eax,%eax
    f439:	01 d0                	add    %edx,%eax
    f43b:	01 c0                	add    %eax,%eax
    f43d:	8d 50 03             	lea    0x3(%eax),%edx
    f440:	8b 45 18             	mov    0x18(%ebp),%eax
    f443:	01 d0                	add    %edx,%eax
    f445:	0f b6 00             	movzbl (%eax),%eax
    f448:	0f b6 c0             	movzbl %al,%eax
    f44b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    f44e:	8b 45 20             	mov    0x20(%ebp),%eax
    f451:	8b 40 18             	mov    0x18(%eax),%eax
    f454:	39 c2                	cmp    %eax,%edx
    f456:	75 51                	jne    f4a9 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    f458:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f45b:	89 d0                	mov    %edx,%eax
    f45d:	01 c0                	add    %eax,%eax
    f45f:	01 d0                	add    %edx,%eax
    f461:	01 c0                	add    %eax,%eax
    f463:	8d 50 04             	lea    0x4(%eax),%edx
    f466:	8b 45 18             	mov    0x18(%ebp),%eax
    f469:	01 d0                	add    %edx,%eax
    f46b:	0f b6 00             	movzbl (%eax),%eax
    f46e:	0f b6 c0             	movzbl %al,%eax
    f471:	c1 e0 08             	shl    $0x8,%eax
    f474:	89 c1                	mov    %eax,%ecx
    f476:	8b 55 1c             	mov    0x1c(%ebp),%edx
    f479:	89 d0                	mov    %edx,%eax
    f47b:	01 c0                	add    %eax,%eax
    f47d:	01 d0                	add    %edx,%eax
    f47f:	01 c0                	add    %eax,%eax
    f481:	8d 50 05             	lea    0x5(%eax),%edx
    f484:	8b 45 18             	mov    0x18(%ebp),%eax
    f487:	01 d0                	add    %edx,%eax
    f489:	0f b6 00             	movzbl (%eax),%eax
    f48c:	0f b6 c0             	movzbl %al,%eax
    f48f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    f492:	8b 45 20             	mov    0x20(%ebp),%eax
    f495:	8b 40 1c             	mov    0x1c(%eax),%eax
    f498:	39 c2                	cmp    %eax,%edx
    f49a:	75 0d                	jne    f4a9 <getPixelColorRGBA16+0x26b>
    f49c:	8b 45 14             	mov    0x14(%ebp),%eax
    f49f:	66 c7 00 00 00       	movw   $0x0,(%eax)
    f4a4:	e9 84 01 00 00       	jmp    f62d <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    f4a9:	8b 45 14             	mov    0x14(%ebp),%eax
    f4ac:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    f4b1:	e9 77 01 00 00       	jmp    f62d <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    f4b6:	8b 45 20             	mov    0x20(%ebp),%eax
    f4b9:	8b 00                	mov    (%eax),%eax
    f4bb:	83 f8 04             	cmp    $0x4,%eax
    f4be:	0f 85 86 00 00 00    	jne    f54a <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    f4c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f4c7:	c1 e0 02             	shl    $0x2,%eax
    f4ca:	89 c2                	mov    %eax,%edx
    f4cc:	8b 45 18             	mov    0x18(%ebp),%eax
    f4cf:	01 d0                	add    %edx,%eax
    f4d1:	0f b6 00             	movzbl (%eax),%eax
    f4d4:	0f b6 c0             	movzbl %al,%eax
    f4d7:	c1 e0 08             	shl    $0x8,%eax
    f4da:	89 c2                	mov    %eax,%edx
    f4dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f4df:	c1 e0 02             	shl    $0x2,%eax
    f4e2:	8d 48 01             	lea    0x1(%eax),%ecx
    f4e5:	8b 45 18             	mov    0x18(%ebp),%eax
    f4e8:	01 c8                	add    %ecx,%eax
    f4ea:	0f b6 00             	movzbl (%eax),%eax
    f4ed:	0f b6 c0             	movzbl %al,%eax
    f4f0:	01 c2                	add    %eax,%edx
    f4f2:	8b 45 10             	mov    0x10(%ebp),%eax
    f4f5:	66 89 10             	mov    %dx,(%eax)
    f4f8:	8b 45 10             	mov    0x10(%ebp),%eax
    f4fb:	0f b7 10             	movzwl (%eax),%edx
    f4fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    f501:	66 89 10             	mov    %dx,(%eax)
    f504:	8b 45 0c             	mov    0xc(%ebp),%eax
    f507:	0f b7 10             	movzwl (%eax),%edx
    f50a:	8b 45 08             	mov    0x8(%ebp),%eax
    f50d:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    f510:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f513:	c1 e0 02             	shl    $0x2,%eax
    f516:	8d 50 02             	lea    0x2(%eax),%edx
    f519:	8b 45 18             	mov    0x18(%ebp),%eax
    f51c:	01 d0                	add    %edx,%eax
    f51e:	0f b6 00             	movzbl (%eax),%eax
    f521:	0f b6 c0             	movzbl %al,%eax
    f524:	c1 e0 08             	shl    $0x8,%eax
    f527:	89 c2                	mov    %eax,%edx
    f529:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f52c:	c1 e0 02             	shl    $0x2,%eax
    f52f:	8d 48 03             	lea    0x3(%eax),%ecx
    f532:	8b 45 18             	mov    0x18(%ebp),%eax
    f535:	01 c8                	add    %ecx,%eax
    f537:	0f b6 00             	movzbl (%eax),%eax
    f53a:	0f b6 c0             	movzbl %al,%eax
    f53d:	01 c2                	add    %eax,%edx
    f53f:	8b 45 14             	mov    0x14(%ebp),%eax
    f542:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    f545:	e9 e3 00 00 00       	jmp    f62d <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    f54a:	8b 45 20             	mov    0x20(%ebp),%eax
    f54d:	8b 00                	mov    (%eax),%eax
    f54f:	83 f8 06             	cmp    $0x6,%eax
    f552:	0f 85 d5 00 00 00    	jne    f62d <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    f558:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f55b:	c1 e0 03             	shl    $0x3,%eax
    f55e:	89 c2                	mov    %eax,%edx
    f560:	8b 45 18             	mov    0x18(%ebp),%eax
    f563:	01 d0                	add    %edx,%eax
    f565:	0f b6 00             	movzbl (%eax),%eax
    f568:	0f b6 c0             	movzbl %al,%eax
    f56b:	c1 e0 08             	shl    $0x8,%eax
    f56e:	89 c2                	mov    %eax,%edx
    f570:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f573:	c1 e0 03             	shl    $0x3,%eax
    f576:	8d 48 01             	lea    0x1(%eax),%ecx
    f579:	8b 45 18             	mov    0x18(%ebp),%eax
    f57c:	01 c8                	add    %ecx,%eax
    f57e:	0f b6 00             	movzbl (%eax),%eax
    f581:	0f b6 c0             	movzbl %al,%eax
    f584:	01 c2                	add    %eax,%edx
    f586:	8b 45 08             	mov    0x8(%ebp),%eax
    f589:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    f58c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f58f:	c1 e0 03             	shl    $0x3,%eax
    f592:	8d 50 02             	lea    0x2(%eax),%edx
    f595:	8b 45 18             	mov    0x18(%ebp),%eax
    f598:	01 d0                	add    %edx,%eax
    f59a:	0f b6 00             	movzbl (%eax),%eax
    f59d:	0f b6 c0             	movzbl %al,%eax
    f5a0:	c1 e0 08             	shl    $0x8,%eax
    f5a3:	89 c2                	mov    %eax,%edx
    f5a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f5a8:	c1 e0 03             	shl    $0x3,%eax
    f5ab:	8d 48 03             	lea    0x3(%eax),%ecx
    f5ae:	8b 45 18             	mov    0x18(%ebp),%eax
    f5b1:	01 c8                	add    %ecx,%eax
    f5b3:	0f b6 00             	movzbl (%eax),%eax
    f5b6:	0f b6 c0             	movzbl %al,%eax
    f5b9:	01 c2                	add    %eax,%edx
    f5bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f5be:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    f5c1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f5c4:	c1 e0 03             	shl    $0x3,%eax
    f5c7:	8d 50 04             	lea    0x4(%eax),%edx
    f5ca:	8b 45 18             	mov    0x18(%ebp),%eax
    f5cd:	01 d0                	add    %edx,%eax
    f5cf:	0f b6 00             	movzbl (%eax),%eax
    f5d2:	0f b6 c0             	movzbl %al,%eax
    f5d5:	c1 e0 08             	shl    $0x8,%eax
    f5d8:	89 c2                	mov    %eax,%edx
    f5da:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f5dd:	c1 e0 03             	shl    $0x3,%eax
    f5e0:	8d 48 05             	lea    0x5(%eax),%ecx
    f5e3:	8b 45 18             	mov    0x18(%ebp),%eax
    f5e6:	01 c8                	add    %ecx,%eax
    f5e8:	0f b6 00             	movzbl (%eax),%eax
    f5eb:	0f b6 c0             	movzbl %al,%eax
    f5ee:	01 c2                	add    %eax,%edx
    f5f0:	8b 45 10             	mov    0x10(%ebp),%eax
    f5f3:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    f5f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f5f9:	c1 e0 03             	shl    $0x3,%eax
    f5fc:	8d 50 06             	lea    0x6(%eax),%edx
    f5ff:	8b 45 18             	mov    0x18(%ebp),%eax
    f602:	01 d0                	add    %edx,%eax
    f604:	0f b6 00             	movzbl (%eax),%eax
    f607:	0f b6 c0             	movzbl %al,%eax
    f60a:	c1 e0 08             	shl    $0x8,%eax
    f60d:	89 c2                	mov    %eax,%edx
    f60f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f612:	c1 e0 03             	shl    $0x3,%eax
    f615:	8d 48 07             	lea    0x7(%eax),%ecx
    f618:	8b 45 18             	mov    0x18(%ebp),%eax
    f61b:	01 c8                	add    %ecx,%eax
    f61d:	0f b6 00             	movzbl (%eax),%eax
    f620:	0f b6 c0             	movzbl %al,%eax
    f623:	01 c2                	add    %eax,%edx
    f625:	8b 45 14             	mov    0x14(%ebp),%eax
    f628:	66 89 10             	mov    %dx,(%eax)
  }
}
    f62b:	eb 00                	jmp    f62d <getPixelColorRGBA16+0x3ef>
    f62d:	90                   	nop
    f62e:	5d                   	pop    %ebp
    f62f:	c3                   	ret    

0000f630 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    f630:	55                   	push   %ebp
    f631:	89 e5                	mov    %esp,%ebp
    f633:	56                   	push   %esi
    f634:	53                   	push   %ebx
    f635:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    f638:	8b 55 18             	mov    0x18(%ebp),%edx
    f63b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    f63e:	0f af c2             	imul   %edx,%eax
    f641:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    f644:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    f64b:	8b 45 14             	mov    0x14(%ebp),%eax
    f64e:	8b 00                	mov    (%eax),%eax
    f650:	83 f8 03             	cmp    $0x3,%eax
    f653:	75 14                	jne    f669 <lodepng_convert+0x39>
    f655:	8b 45 14             	mov    0x14(%ebp),%eax
    f658:	8b 40 08             	mov    0x8(%eax),%eax
    f65b:	85 c0                	test   %eax,%eax
    f65d:	75 0a                	jne    f669 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    f65f:	b8 6b 00 00 00       	mov    $0x6b,%eax
    f664:	e9 19 03 00 00       	jmp    f982 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    f669:	ff 75 14             	pushl  0x14(%ebp)
    f66c:	ff 75 10             	pushl  0x10(%ebp)
    f66f:	e8 b7 d1 ff ff       	call   c82b <lodepng_color_mode_equal>
    f674:	83 c4 08             	add    $0x8,%esp
    f677:	85 c0                	test   %eax,%eax
    f679:	74 2f                	je     f6aa <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    f67b:	ff 75 14             	pushl  0x14(%ebp)
    f67e:	ff 75 1c             	pushl  0x1c(%ebp)
    f681:	ff 75 18             	pushl  0x18(%ebp)
    f684:	e8 fb d4 ff ff       	call   cb84 <lodepng_get_raw_size>
    f689:	83 c4 0c             	add    $0xc,%esp
    f68c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    f68f:	ff 75 dc             	pushl  -0x24(%ebp)
    f692:	ff 75 0c             	pushl  0xc(%ebp)
    f695:	ff 75 08             	pushl  0x8(%ebp)
    f698:	e8 ca 78 ff ff       	call   6f67 <lodepng_memcpy>
    f69d:	83 c4 0c             	add    $0xc,%esp
    return 0;
    f6a0:	b8 00 00 00 00       	mov    $0x0,%eax
    f6a5:	e9 d8 02 00 00       	jmp    f982 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    f6aa:	8b 45 10             	mov    0x10(%ebp),%eax
    f6ad:	8b 00                	mov    (%eax),%eax
    f6af:	83 f8 03             	cmp    $0x3,%eax
    f6b2:	0f 85 16 01 00 00    	jne    f7ce <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    f6b8:	8b 45 10             	mov    0x10(%ebp),%eax
    f6bb:	8b 40 0c             	mov    0xc(%eax),%eax
    f6be:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    f6c1:	8b 45 10             	mov    0x10(%ebp),%eax
    f6c4:	8b 40 08             	mov    0x8(%eax),%eax
    f6c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    f6ca:	8b 45 10             	mov    0x10(%ebp),%eax
    f6cd:	8b 40 04             	mov    0x4(%eax),%eax
    f6d0:	ba 01 00 00 00       	mov    $0x1,%edx
    f6d5:	89 c1                	mov    %eax,%ecx
    f6d7:	d3 e2                	shl    %cl,%edx
    f6d9:	89 d0                	mov    %edx,%eax
    f6db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    f6de:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f6e2:	75 5b                	jne    f73f <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    f6e4:	8b 45 14             	mov    0x14(%ebp),%eax
    f6e7:	8b 40 0c             	mov    0xc(%eax),%eax
    f6ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    f6ed:	8b 45 14             	mov    0x14(%ebp),%eax
    f6f0:	8b 40 08             	mov    0x8(%eax),%eax
    f6f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    f6f6:	8b 45 14             	mov    0x14(%ebp),%eax
    f6f9:	8b 00                	mov    (%eax),%eax
    f6fb:	83 f8 03             	cmp    $0x3,%eax
    f6fe:	75 3f                	jne    f73f <lodepng_convert+0x10f>
    f700:	8b 45 14             	mov    0x14(%ebp),%eax
    f703:	8b 50 04             	mov    0x4(%eax),%edx
    f706:	8b 45 10             	mov    0x10(%ebp),%eax
    f709:	8b 40 04             	mov    0x4(%eax),%eax
    f70c:	39 c2                	cmp    %eax,%edx
    f70e:	75 2f                	jne    f73f <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    f710:	ff 75 14             	pushl  0x14(%ebp)
    f713:	ff 75 1c             	pushl  0x1c(%ebp)
    f716:	ff 75 18             	pushl  0x18(%ebp)
    f719:	e8 66 d4 ff ff       	call   cb84 <lodepng_get_raw_size>
    f71e:	83 c4 0c             	add    $0xc,%esp
    f721:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    f724:	ff 75 d8             	pushl  -0x28(%ebp)
    f727:	ff 75 0c             	pushl  0xc(%ebp)
    f72a:	ff 75 08             	pushl  0x8(%ebp)
    f72d:	e8 35 78 ff ff       	call   6f67 <lodepng_memcpy>
    f732:	83 c4 0c             	add    $0xc,%esp
        return 0;
    f735:	b8 00 00 00 00       	mov    $0x0,%eax
    f73a:	e9 43 02 00 00       	jmp    f982 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    f73f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f742:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    f745:	7d 06                	jge    f74d <lodepng_convert+0x11d>
    f747:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f74a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    f74d:	8d 45 90             	lea    -0x70(%ebp),%eax
    f750:	50                   	push   %eax
    f751:	e8 5f e1 ff ff       	call   d8b5 <color_tree_init>
    f756:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    f759:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    f760:	eb 61                	jmp    f7c3 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    f762:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f765:	c1 e0 02             	shl    $0x2,%eax
    f768:	89 c2                	mov    %eax,%edx
    f76a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f76d:	01 d0                	add    %edx,%eax
    f76f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    f772:	8b 75 f4             	mov    -0xc(%ebp),%esi
    f775:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f778:	83 c0 03             	add    $0x3,%eax
    f77b:	0f b6 00             	movzbl (%eax),%eax
    f77e:	0f b6 d8             	movzbl %al,%ebx
    f781:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f784:	83 c0 02             	add    $0x2,%eax
    f787:	0f b6 00             	movzbl (%eax),%eax
    f78a:	0f b6 c8             	movzbl %al,%ecx
    f78d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f790:	83 c0 01             	add    $0x1,%eax
    f793:	0f b6 00             	movzbl (%eax),%eax
    f796:	0f b6 d0             	movzbl %al,%edx
    f799:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f79c:	0f b6 00             	movzbl (%eax),%eax
    f79f:	0f b6 c0             	movzbl %al,%eax
    f7a2:	83 ec 08             	sub    $0x8,%esp
    f7a5:	56                   	push   %esi
    f7a6:	53                   	push   %ebx
    f7a7:	51                   	push   %ecx
    f7a8:	52                   	push   %edx
    f7a9:	50                   	push   %eax
    f7aa:	8d 45 90             	lea    -0x70(%ebp),%eax
    f7ad:	50                   	push   %eax
    f7ae:	e8 85 e2 ff ff       	call   da38 <color_tree_add>
    f7b3:	83 c4 20             	add    $0x20,%esp
    f7b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    f7b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f7bd:	75 0e                	jne    f7cd <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    f7bf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f7c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f7c6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    f7c9:	75 97                	jne    f762 <lodepng_convert+0x132>
    f7cb:	eb 01                	jmp    f7ce <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    f7cd:	90                   	nop
    }
  }

  if(!error) {
    f7ce:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f7d2:	0f 85 8e 01 00 00    	jne    f966 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    f7d8:	8b 45 14             	mov    0x14(%ebp),%eax
    f7db:	8b 40 04             	mov    0x4(%eax),%eax
    f7de:	83 f8 10             	cmp    $0x10,%eax
    f7e1:	0f 85 99 00 00 00    	jne    f880 <lodepng_convert+0x250>
    f7e7:	8b 45 10             	mov    0x10(%ebp),%eax
    f7ea:	8b 40 04             	mov    0x4(%eax),%eax
    f7ed:	83 f8 10             	cmp    $0x10,%eax
    f7f0:	0f 85 8a 00 00 00    	jne    f880 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    f7f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    f7fd:	eb 74                	jmp    f873 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    f7ff:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    f805:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    f80b:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    f811:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    f817:	83 ec 04             	sub    $0x4,%esp
    f81a:	ff 75 14             	pushl  0x14(%ebp)
    f81d:	ff 75 f4             	pushl  -0xc(%ebp)
    f820:	ff 75 0c             	pushl  0xc(%ebp)
    f823:	8d 45 88             	lea    -0x78(%ebp),%eax
    f826:	50                   	push   %eax
    f827:	8d 45 8a             	lea    -0x76(%ebp),%eax
    f82a:	50                   	push   %eax
    f82b:	8d 45 8c             	lea    -0x74(%ebp),%eax
    f82e:	50                   	push   %eax
    f82f:	8d 45 8e             	lea    -0x72(%ebp),%eax
    f832:	50                   	push   %eax
    f833:	e8 06 fa ff ff       	call   f23e <getPixelColorRGBA16>
    f838:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    f83b:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    f83f:	0f b7 d8             	movzwl %ax,%ebx
    f842:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    f846:	0f b7 c8             	movzwl %ax,%ecx
    f849:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    f84d:	0f b7 d0             	movzwl %ax,%edx
    f850:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    f854:	0f b7 c0             	movzwl %ax,%eax
    f857:	83 ec 04             	sub    $0x4,%esp
    f85a:	53                   	push   %ebx
    f85b:	51                   	push   %ecx
    f85c:	52                   	push   %edx
    f85d:	50                   	push   %eax
    f85e:	ff 75 10             	pushl  0x10(%ebp)
    f861:	ff 75 f4             	pushl  -0xc(%ebp)
    f864:	ff 75 08             	pushl  0x8(%ebp)
    f867:	e8 d3 e6 ff ff       	call   df3f <rgba16ToPixel>
    f86c:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    f86f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f873:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f876:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    f879:	75 84                	jne    f7ff <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    f87b:	e9 e6 00 00 00       	jmp    f966 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    f880:	8b 45 10             	mov    0x10(%ebp),%eax
    f883:	8b 40 04             	mov    0x4(%eax),%eax
    f886:	83 f8 08             	cmp    $0x8,%eax
    f889:	75 23                	jne    f8ae <lodepng_convert+0x27e>
    f88b:	8b 45 10             	mov    0x10(%ebp),%eax
    f88e:	8b 00                	mov    (%eax),%eax
    f890:	83 f8 06             	cmp    $0x6,%eax
    f893:	75 19                	jne    f8ae <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    f895:	ff 75 14             	pushl  0x14(%ebp)
    f898:	ff 75 0c             	pushl  0xc(%ebp)
    f89b:	ff 75 e0             	pushl  -0x20(%ebp)
    f89e:	ff 75 08             	pushl  0x8(%ebp)
    f8a1:	e8 ae ee ff ff       	call   e754 <getPixelColorsRGBA8>
    f8a6:	83 c4 10             	add    $0x10,%esp
    f8a9:	e9 b8 00 00 00       	jmp    f966 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    f8ae:	8b 45 10             	mov    0x10(%ebp),%eax
    f8b1:	8b 40 04             	mov    0x4(%eax),%eax
    f8b4:	83 f8 08             	cmp    $0x8,%eax
    f8b7:	75 23                	jne    f8dc <lodepng_convert+0x2ac>
    f8b9:	8b 45 10             	mov    0x10(%ebp),%eax
    f8bc:	8b 00                	mov    (%eax),%eax
    f8be:	83 f8 02             	cmp    $0x2,%eax
    f8c1:	75 19                	jne    f8dc <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    f8c3:	ff 75 14             	pushl  0x14(%ebp)
    f8c6:	ff 75 0c             	pushl  0xc(%ebp)
    f8c9:	ff 75 e0             	pushl  -0x20(%ebp)
    f8cc:	ff 75 08             	pushl  0x8(%ebp)
    f8cf:	e8 50 f5 ff ff       	call   ee24 <getPixelColorsRGB8>
    f8d4:	83 c4 10             	add    $0x10,%esp
    f8d7:	e9 8a 00 00 00       	jmp    f966 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    f8dc:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    f8e0:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    f8e4:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    f8e8:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    f8ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    f8f3:	eb 66                	jmp    f95b <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    f8f5:	83 ec 04             	sub    $0x4,%esp
    f8f8:	ff 75 14             	pushl  0x14(%ebp)
    f8fb:	ff 75 f4             	pushl  -0xc(%ebp)
    f8fe:	ff 75 0c             	pushl  0xc(%ebp)
    f901:	8d 45 84             	lea    -0x7c(%ebp),%eax
    f904:	50                   	push   %eax
    f905:	8d 45 85             	lea    -0x7b(%ebp),%eax
    f908:	50                   	push   %eax
    f909:	8d 45 86             	lea    -0x7a(%ebp),%eax
    f90c:	50                   	push   %eax
    f90d:	8d 45 87             	lea    -0x79(%ebp),%eax
    f910:	50                   	push   %eax
    f911:	e8 71 e8 ff ff       	call   e187 <getPixelColorRGBA8>
    f916:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    f919:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    f91d:	0f b6 d8             	movzbl %al,%ebx
    f920:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    f924:	0f b6 c8             	movzbl %al,%ecx
    f927:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    f92b:	0f b6 d0             	movzbl %al,%edx
    f92e:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    f932:	0f b6 c0             	movzbl %al,%eax
    f935:	53                   	push   %ebx
    f936:	51                   	push   %ecx
    f937:	52                   	push   %edx
    f938:	50                   	push   %eax
    f939:	8d 45 90             	lea    -0x70(%ebp),%eax
    f93c:	50                   	push   %eax
    f93d:	ff 75 10             	pushl  0x10(%ebp)
    f940:	ff 75 f4             	pushl  -0xc(%ebp)
    f943:	ff 75 08             	pushl  0x8(%ebp)
    f946:	e8 e5 e1 ff ff       	call   db30 <rgba8ToPixel>
    f94b:	83 c4 20             	add    $0x20,%esp
    f94e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    f951:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f955:	75 0e                	jne    f965 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    f957:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    f95b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f95e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    f961:	75 92                	jne    f8f5 <lodepng_convert+0x2c5>
    f963:	eb 01                	jmp    f966 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    f965:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    f966:	8b 45 10             	mov    0x10(%ebp),%eax
    f969:	8b 00                	mov    (%eax),%eax
    f96b:	83 f8 03             	cmp    $0x3,%eax
    f96e:	75 0f                	jne    f97f <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    f970:	83 ec 0c             	sub    $0xc,%esp
    f973:	8d 45 90             	lea    -0x70(%ebp),%eax
    f976:	50                   	push   %eax
    f977:	e8 59 df ff ff       	call   d8d5 <color_tree_cleanup>
    f97c:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    f97f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f982:	8d 65 f8             	lea    -0x8(%ebp),%esp
    f985:	5b                   	pop    %ebx
    f986:	5e                   	pop    %esi
    f987:	5d                   	pop    %ebp
    f988:	c3                   	ret    

0000f989 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    f989:	55                   	push   %ebp
    f98a:	89 e5                	mov    %esp,%ebp
    f98c:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    f98f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    f996:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    f99d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    f9a4:	8b 45 24             	mov    0x24(%ebp),%eax
    f9a7:	8b 40 04             	mov    0x4(%eax),%eax
    f9aa:	ba 01 00 00 00       	mov    $0x1,%edx
    f9af:	89 c1                	mov    %eax,%ecx
    f9b1:	d3 e2                	shl    %cl,%edx
    f9b3:	89 d0                	mov    %edx,%eax
    f9b5:	8d 48 ff             	lea    -0x1(%eax),%ecx
    f9b8:	b8 ff ff 00 00       	mov    $0xffff,%eax
    f9bd:	ba 00 00 00 00       	mov    $0x0,%edx
    f9c2:	f7 f1                	div    %ecx
    f9c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    f9c7:	8b 45 20             	mov    0x20(%ebp),%eax
    f9ca:	8b 40 04             	mov    0x4(%eax),%eax
    f9cd:	ba 10 00 00 00       	mov    $0x10,%edx
    f9d2:	29 c2                	sub    %eax,%edx
    f9d4:	89 d0                	mov    %edx,%eax
    f9d6:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    f9d9:	8b 45 24             	mov    0x24(%ebp),%eax
    f9dc:	8b 00                	mov    (%eax),%eax
    f9de:	85 c0                	test   %eax,%eax
    f9e0:	74 0a                	je     f9ec <lodepng_convert_rgb+0x63>
    f9e2:	8b 45 24             	mov    0x24(%ebp),%eax
    f9e5:	8b 00                	mov    (%eax),%eax
    f9e7:	83 f8 04             	cmp    $0x4,%eax
    f9ea:	75 1b                	jne    fa07 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    f9ec:	8b 45 14             	mov    0x14(%ebp),%eax
    f9ef:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    f9f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    f9f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    f9f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    f9fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    f9ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
    fa02:	e9 c2 00 00 00       	jmp    fac9 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    fa07:	8b 45 24             	mov    0x24(%ebp),%eax
    fa0a:	8b 00                	mov    (%eax),%eax
    fa0c:	83 f8 02             	cmp    $0x2,%eax
    fa0f:	74 0a                	je     fa1b <lodepng_convert_rgb+0x92>
    fa11:	8b 45 24             	mov    0x24(%ebp),%eax
    fa14:	8b 00                	mov    (%eax),%eax
    fa16:	83 f8 06             	cmp    $0x6,%eax
    fa19:	75 23                	jne    fa3e <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    fa1b:	8b 45 14             	mov    0x14(%ebp),%eax
    fa1e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    fa22:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    fa25:	8b 45 18             	mov    0x18(%ebp),%eax
    fa28:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    fa2c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    fa2f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    fa32:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    fa36:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fa39:	e9 8b 00 00 00       	jmp    fac9 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    fa3e:	8b 45 24             	mov    0x24(%ebp),%eax
    fa41:	8b 00                	mov    (%eax),%eax
    fa43:	83 f8 03             	cmp    $0x3,%eax
    fa46:	75 77                	jne    fabf <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    fa48:	8b 45 24             	mov    0x24(%ebp),%eax
    fa4b:	8b 40 0c             	mov    0xc(%eax),%eax
    fa4e:	3b 45 14             	cmp    0x14(%ebp),%eax
    fa51:	77 0a                	ja     fa5d <lodepng_convert_rgb+0xd4>
    fa53:	b8 52 00 00 00       	mov    $0x52,%eax
    fa58:	e9 cb 01 00 00       	jmp    fc28 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    fa5d:	8b 45 24             	mov    0x24(%ebp),%eax
    fa60:	8b 40 08             	mov    0x8(%eax),%eax
    fa63:	8b 55 14             	mov    0x14(%ebp),%edx
    fa66:	c1 e2 02             	shl    $0x2,%edx
    fa69:	01 d0                	add    %edx,%eax
    fa6b:	0f b6 00             	movzbl (%eax),%eax
    fa6e:	0f b6 d0             	movzbl %al,%edx
    fa71:	89 d0                	mov    %edx,%eax
    fa73:	c1 e0 08             	shl    $0x8,%eax
    fa76:	01 d0                	add    %edx,%eax
    fa78:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    fa7b:	8b 45 24             	mov    0x24(%ebp),%eax
    fa7e:	8b 40 08             	mov    0x8(%eax),%eax
    fa81:	8b 55 14             	mov    0x14(%ebp),%edx
    fa84:	c1 e2 02             	shl    $0x2,%edx
    fa87:	83 c2 01             	add    $0x1,%edx
    fa8a:	01 d0                	add    %edx,%eax
    fa8c:	0f b6 00             	movzbl (%eax),%eax
    fa8f:	0f b6 d0             	movzbl %al,%edx
    fa92:	89 d0                	mov    %edx,%eax
    fa94:	c1 e0 08             	shl    $0x8,%eax
    fa97:	01 d0                	add    %edx,%eax
    fa99:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    fa9c:	8b 45 24             	mov    0x24(%ebp),%eax
    fa9f:	8b 40 08             	mov    0x8(%eax),%eax
    faa2:	8b 55 14             	mov    0x14(%ebp),%edx
    faa5:	c1 e2 02             	shl    $0x2,%edx
    faa8:	83 c2 02             	add    $0x2,%edx
    faab:	01 d0                	add    %edx,%eax
    faad:	0f b6 00             	movzbl (%eax),%eax
    fab0:	0f b6 d0             	movzbl %al,%edx
    fab3:	89 d0                	mov    %edx,%eax
    fab5:	c1 e0 08             	shl    $0x8,%eax
    fab8:	01 d0                	add    %edx,%eax
    faba:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fabd:	eb 0a                	jmp    fac9 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    fabf:	b8 1f 00 00 00       	mov    $0x1f,%eax
    fac4:	e9 5f 01 00 00       	jmp    fc28 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    fac9:	8b 45 20             	mov    0x20(%ebp),%eax
    facc:	8b 00                	mov    (%eax),%eax
    face:	85 c0                	test   %eax,%eax
    fad0:	74 0a                	je     fadc <lodepng_convert_rgb+0x153>
    fad2:	8b 45 20             	mov    0x20(%ebp),%eax
    fad5:	8b 00                	mov    (%eax),%eax
    fad7:	83 f8 04             	cmp    $0x4,%eax
    fada:	75 14                	jne    faf0 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    fadc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fadf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    fae2:	89 c1                	mov    %eax,%ecx
    fae4:	d3 ea                	shr    %cl,%edx
    fae6:	8b 45 08             	mov    0x8(%ebp),%eax
    fae9:	89 10                	mov    %edx,(%eax)
    faeb:	e9 33 01 00 00       	jmp    fc23 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    faf0:	8b 45 20             	mov    0x20(%ebp),%eax
    faf3:	8b 00                	mov    (%eax),%eax
    faf5:	83 f8 02             	cmp    $0x2,%eax
    faf8:	74 0a                	je     fb04 <lodepng_convert_rgb+0x17b>
    fafa:	8b 45 20             	mov    0x20(%ebp),%eax
    fafd:	8b 00                	mov    (%eax),%eax
    faff:	83 f8 06             	cmp    $0x6,%eax
    fb02:	75 32                	jne    fb36 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    fb04:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fb07:	8b 55 fc             	mov    -0x4(%ebp),%edx
    fb0a:	89 c1                	mov    %eax,%ecx
    fb0c:	d3 ea                	shr    %cl,%edx
    fb0e:	8b 45 08             	mov    0x8(%ebp),%eax
    fb11:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    fb13:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fb16:	8b 55 f8             	mov    -0x8(%ebp),%edx
    fb19:	89 c1                	mov    %eax,%ecx
    fb1b:	d3 ea                	shr    %cl,%edx
    fb1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb20:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    fb22:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fb25:	8b 55 f4             	mov    -0xc(%ebp),%edx
    fb28:	89 c1                	mov    %eax,%ecx
    fb2a:	d3 ea                	shr    %cl,%edx
    fb2c:	8b 45 10             	mov    0x10(%ebp),%eax
    fb2f:	89 10                	mov    %edx,(%eax)
    fb31:	e9 ed 00 00 00       	jmp    fc23 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    fb36:	8b 45 20             	mov    0x20(%ebp),%eax
    fb39:	8b 00                	mov    (%eax),%eax
    fb3b:	83 f8 03             	cmp    $0x3,%eax
    fb3e:	0f 85 d8 00 00 00    	jne    fc1c <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    fb44:	8b 45 fc             	mov    -0x4(%ebp),%eax
    fb47:	c1 e8 08             	shr    $0x8,%eax
    fb4a:	89 c2                	mov    %eax,%edx
    fb4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    fb4f:	0f b6 c0             	movzbl %al,%eax
    fb52:	39 c2                	cmp    %eax,%edx
    fb54:	75 24                	jne    fb7a <lodepng_convert_rgb+0x1f1>
    fb56:	8b 45 f8             	mov    -0x8(%ebp),%eax
    fb59:	c1 e8 08             	shr    $0x8,%eax
    fb5c:	89 c2                	mov    %eax,%edx
    fb5e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    fb61:	0f b6 c0             	movzbl %al,%eax
    fb64:	39 c2                	cmp    %eax,%edx
    fb66:	75 12                	jne    fb7a <lodepng_convert_rgb+0x1f1>
    fb68:	8b 45 f4             	mov    -0xc(%ebp),%eax
    fb6b:	c1 e8 08             	shr    $0x8,%eax
    fb6e:	89 c2                	mov    %eax,%edx
    fb70:	8b 45 f4             	mov    -0xc(%ebp),%eax
    fb73:	0f b6 c0             	movzbl %al,%eax
    fb76:	39 c2                	cmp    %eax,%edx
    fb78:	74 0a                	je     fb84 <lodepng_convert_rgb+0x1fb>
    fb7a:	b8 52 00 00 00       	mov    $0x52,%eax
    fb7f:	e9 a4 00 00 00       	jmp    fc28 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    fb84:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    fb8b:	eb 79                	jmp    fc06 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    fb8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fb90:	c1 e0 02             	shl    $0x2,%eax
    fb93:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    fb96:	8b 45 fc             	mov    -0x4(%ebp),%eax
    fb99:	c1 e8 08             	shr    $0x8,%eax
    fb9c:	89 c1                	mov    %eax,%ecx
    fb9e:	8b 45 20             	mov    0x20(%ebp),%eax
    fba1:	8b 50 08             	mov    0x8(%eax),%edx
    fba4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fba7:	01 d0                	add    %edx,%eax
    fba9:	0f b6 00             	movzbl (%eax),%eax
    fbac:	0f b6 c0             	movzbl %al,%eax
    fbaf:	39 c1                	cmp    %eax,%ecx
    fbb1:	75 4f                	jne    fc02 <lodepng_convert_rgb+0x279>
    fbb3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    fbb6:	c1 e8 08             	shr    $0x8,%eax
    fbb9:	89 c1                	mov    %eax,%ecx
    fbbb:	8b 45 20             	mov    0x20(%ebp),%eax
    fbbe:	8b 40 08             	mov    0x8(%eax),%eax
    fbc1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fbc4:	83 c2 01             	add    $0x1,%edx
    fbc7:	01 d0                	add    %edx,%eax
    fbc9:	0f b6 00             	movzbl (%eax),%eax
    fbcc:	0f b6 c0             	movzbl %al,%eax
    fbcf:	39 c1                	cmp    %eax,%ecx
    fbd1:	75 2f                	jne    fc02 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    fbd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    fbd6:	c1 e8 08             	shr    $0x8,%eax
    fbd9:	89 c1                	mov    %eax,%ecx
    fbdb:	8b 45 20             	mov    0x20(%ebp),%eax
    fbde:	8b 40 08             	mov    0x8(%eax),%eax
    fbe1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fbe4:	83 c2 02             	add    $0x2,%edx
    fbe7:	01 d0                	add    %edx,%eax
    fbe9:	0f b6 00             	movzbl (%eax),%eax
    fbec:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    fbef:	39 c1                	cmp    %eax,%ecx
    fbf1:	75 0f                	jne    fc02 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    fbf3:	8b 45 08             	mov    0x8(%ebp),%eax
    fbf6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fbf9:	89 10                	mov    %edx,(%eax)
        return 0;
    fbfb:	b8 00 00 00 00       	mov    $0x0,%eax
    fc00:	eb 26                	jmp    fc28 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    fc02:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    fc06:	8b 45 20             	mov    0x20(%ebp),%eax
    fc09:	8b 40 0c             	mov    0xc(%eax),%eax
    fc0c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    fc0f:	0f 87 78 ff ff ff    	ja     fb8d <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    fc15:	b8 52 00 00 00       	mov    $0x52,%eax
    fc1a:	eb 0c                	jmp    fc28 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    fc1c:	b8 1f 00 00 00       	mov    $0x1f,%eax
    fc21:	eb 05                	jmp    fc28 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    fc23:	b8 00 00 00 00       	mov    $0x0,%eax
}
    fc28:	c9                   	leave  
    fc29:	c3                   	ret    

0000fc2a <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    fc2a:	55                   	push   %ebp
    fc2b:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    fc2d:	8b 45 08             	mov    0x8(%ebp),%eax
    fc30:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    fc36:	8b 45 08             	mov    0x8(%ebp),%eax
    fc39:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    fc40:	8b 45 08             	mov    0x8(%ebp),%eax
    fc43:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    fc49:	8b 45 08             	mov    0x8(%ebp),%eax
    fc4c:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    fc50:	8b 45 08             	mov    0x8(%ebp),%eax
    fc53:	66 89 50 0a          	mov    %dx,0xa(%eax)
    fc57:	8b 45 08             	mov    0x8(%ebp),%eax
    fc5a:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    fc5e:	8b 45 08             	mov    0x8(%ebp),%eax
    fc61:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    fc65:	8b 45 08             	mov    0x8(%ebp),%eax
    fc68:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    fc6f:	8b 45 08             	mov    0x8(%ebp),%eax
    fc72:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    fc79:	8b 45 08             	mov    0x8(%ebp),%eax
    fc7c:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    fc83:	00 00 00 
  stats->numpixels = 0;
    fc86:	8b 45 08             	mov    0x8(%ebp),%eax
    fc89:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    fc90:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    fc93:	8b 45 08             	mov    0x8(%ebp),%eax
    fc96:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    fc9d:	00 00 00 
  stats->allow_greyscale = 1;
    fca0:	8b 45 08             	mov    0x8(%ebp),%eax
    fca3:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    fcaa:	00 00 00 
}
    fcad:	90                   	nop
    fcae:	5d                   	pop    %ebp
    fcaf:	c3                   	ret    

0000fcb0 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    fcb0:	55                   	push   %ebp
    fcb1:	89 e5                	mov    %esp,%ebp
    fcb3:	53                   	push   %ebx
    fcb4:	83 ec 04             	sub    $0x4,%esp
    fcb7:	8b 45 08             	mov    0x8(%ebp),%eax
    fcba:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    fcbd:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    fcc1:	74 06                	je     fcc9 <getValueRequiredBits+0x19>
    fcc3:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    fcc7:	75 07                	jne    fcd0 <getValueRequiredBits+0x20>
    fcc9:	b8 01 00 00 00       	mov    $0x1,%eax
    fcce:	eb 6b                	jmp    fd3b <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    fcd0:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    fcd4:	0f b6 d9             	movzbl %cl,%ebx
    fcd7:	89 da                	mov    %ebx,%edx
    fcd9:	89 d0                	mov    %edx,%eax
    fcdb:	c1 e0 04             	shl    $0x4,%eax
    fcde:	89 c2                	mov    %eax,%edx
    fce0:	89 d0                	mov    %edx,%eax
    fce2:	c1 e0 04             	shl    $0x4,%eax
    fce5:	29 d0                	sub    %edx,%eax
    fce7:	01 d8                	add    %ebx,%eax
    fce9:	66 c1 e8 08          	shr    $0x8,%ax
    fced:	c0 e8 04             	shr    $0x4,%al
    fcf0:	89 c2                	mov    %eax,%edx
    fcf2:	c1 e2 04             	shl    $0x4,%edx
    fcf5:	01 c2                	add    %eax,%edx
    fcf7:	89 c8                	mov    %ecx,%eax
    fcf9:	29 d0                	sub    %edx,%eax
    fcfb:	84 c0                	test   %al,%al
    fcfd:	75 37                	jne    fd36 <getValueRequiredBits+0x86>
    fcff:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    fd03:	0f b6 d1             	movzbl %cl,%edx
    fd06:	89 d0                	mov    %edx,%eax
    fd08:	01 c0                	add    %eax,%eax
    fd0a:	01 d0                	add    %edx,%eax
    fd0c:	c1 e0 06             	shl    $0x6,%eax
    fd0f:	01 d0                	add    %edx,%eax
    fd11:	66 c1 e8 08          	shr    $0x8,%ax
    fd15:	c0 e8 06             	shr    $0x6,%al
    fd18:	ba 55 00 00 00       	mov    $0x55,%edx
    fd1d:	0f af c2             	imul   %edx,%eax
    fd20:	29 c1                	sub    %eax,%ecx
    fd22:	89 c8                	mov    %ecx,%eax
    fd24:	84 c0                	test   %al,%al
    fd26:	75 07                	jne    fd2f <getValueRequiredBits+0x7f>
    fd28:	b8 02 00 00 00       	mov    $0x2,%eax
    fd2d:	eb 0c                	jmp    fd3b <getValueRequiredBits+0x8b>
    fd2f:	b8 04 00 00 00       	mov    $0x4,%eax
    fd34:	eb 05                	jmp    fd3b <getValueRequiredBits+0x8b>
  return 8;
    fd36:	b8 08 00 00 00       	mov    $0x8,%eax
}
    fd3b:	83 c4 04             	add    $0x4,%esp
    fd3e:	5b                   	pop    %ebx
    fd3f:	5d                   	pop    %ebp
    fd40:	c3                   	ret    

0000fd41 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    fd41:	55                   	push   %ebp
    fd42:	89 e5                	mov    %esp,%ebp
    fd44:	56                   	push   %esi
    fd45:	53                   	push   %ebx
    fd46:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    fd4c:	8b 55 10             	mov    0x10(%ebp),%edx
    fd4f:	8b 45 14             	mov    0x14(%ebp),%eax
    fd52:	0f af c2             	imul   %edx,%eax
    fd55:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    fd58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    fd5f:	ff 75 18             	pushl  0x18(%ebp)
    fd62:	e8 0b cd ff ff       	call   ca72 <lodepng_is_greyscale_type>
    fd67:	83 c4 04             	add    $0x4,%esp
    fd6a:	85 c0                	test   %eax,%eax
    fd6c:	0f 95 c0             	setne  %al
    fd6f:	0f b6 c0             	movzbl %al,%eax
    fd72:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    fd75:	ff 75 18             	pushl  0x18(%ebp)
    fd78:	e8 85 cd ff ff       	call   cb02 <lodepng_can_have_alpha>
    fd7d:	83 c4 04             	add    $0x4,%esp
    fd80:	85 c0                	test   %eax,%eax
    fd82:	0f 94 c0             	sete   %al
    fd85:	0f b6 c0             	movzbl %al,%eax
    fd88:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    fd8b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    fd92:	ff 75 18             	pushl  0x18(%ebp)
    fd95:	e8 ab cc ff ff       	call   ca45 <lodepng_get_bpp>
    fd9a:	83 c4 04             	add    $0x4,%esp
    fd9d:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    fda0:	8b 45 08             	mov    0x8(%ebp),%eax
    fda3:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    fda9:	83 f8 01             	cmp    $0x1,%eax
    fdac:	75 0d                	jne    fdbb <lodepng_compute_color_stats+0x7a>
    fdae:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    fdb2:	75 07                	jne    fdbb <lodepng_compute_color_stats+0x7a>
    fdb4:	b8 01 00 00 00       	mov    $0x1,%eax
    fdb9:	eb 05                	jmp    fdc0 <lodepng_compute_color_stats+0x7f>
    fdbb:	b8 00 00 00 00       	mov    $0x0,%eax
    fdc0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    fdc3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    fdca:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    fdd1:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    fdd5:	77 26                	ja     fdfd <lodepng_compute_color_stats+0xbc>
    fdd7:	8b 45 08             	mov    0x8(%ebp),%eax
    fdda:	8b 50 14             	mov    0x14(%eax),%edx
    fddd:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fde0:	bb 01 00 00 00       	mov    $0x1,%ebx
    fde5:	89 c1                	mov    %eax,%ecx
    fde7:	d3 e3                	shl    %cl,%ebx
    fde9:	89 d8                	mov    %ebx,%eax
    fdeb:	01 d0                	add    %edx,%eax
    fded:	ba 01 01 00 00       	mov    $0x101,%edx
    fdf2:	3d 01 01 00 00       	cmp    $0x101,%eax
    fdf7:	0f 47 c2             	cmova  %edx,%eax
    fdfa:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    fdfd:	8b 45 08             	mov    0x8(%ebp),%eax
    fe00:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    fe06:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe09:	01 c2                	add    %eax,%edx
    fe0b:	8b 45 08             	mov    0x8(%ebp),%eax
    fe0e:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    fe14:	8b 45 08             	mov    0x8(%ebp),%eax
    fe17:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    fe1d:	85 c0                	test   %eax,%eax
    fe1f:	75 07                	jne    fe28 <lodepng_compute_color_stats+0xe7>
    fe21:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    fe28:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    fe2e:	50                   	push   %eax
    fe2f:	e8 81 da ff ff       	call   d8b5 <color_tree_init>
    fe34:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    fe37:	8b 45 08             	mov    0x8(%ebp),%eax
    fe3a:	8b 40 10             	mov    0x10(%eax),%eax
    fe3d:	85 c0                	test   %eax,%eax
    fe3f:	74 07                	je     fe48 <lodepng_compute_color_stats+0x107>
    fe41:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    fe48:	8b 45 08             	mov    0x8(%ebp),%eax
    fe4b:	8b 00                	mov    (%eax),%eax
    fe4d:	85 c0                	test   %eax,%eax
    fe4f:	74 07                	je     fe58 <lodepng_compute_color_stats+0x117>
    fe51:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    fe58:	8b 45 08             	mov    0x8(%ebp),%eax
    fe5b:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    fe61:	83 f8 10             	cmp    $0x10,%eax
    fe64:	75 07                	jne    fe6d <lodepng_compute_color_stats+0x12c>
    fe66:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    fe6d:	8b 45 08             	mov    0x8(%ebp),%eax
    fe70:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    fe76:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    fe79:	72 07                	jb     fe82 <lodepng_compute_color_stats+0x141>
    fe7b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    fe82:	8b 45 08             	mov    0x8(%ebp),%eax
    fe85:	8b 40 14             	mov    0x14(%eax),%eax
    fe88:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    fe8b:	72 07                	jb     fe94 <lodepng_compute_color_stats+0x153>
    fe8d:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    fe94:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    fe98:	0f 85 82 00 00 00    	jne    ff20 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    fe9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    fea5:	eb 6c                	jmp    ff13 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    fea7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    feaa:	c1 e0 02             	shl    $0x2,%eax
    fead:	8d 50 10             	lea    0x10(%eax),%edx
    feb0:	8b 45 08             	mov    0x8(%ebp),%eax
    feb3:	01 d0                	add    %edx,%eax
    feb5:	83 c0 08             	add    $0x8,%eax
    feb8:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    febb:	8b 75 f4             	mov    -0xc(%ebp),%esi
    febe:	8b 45 cc             	mov    -0x34(%ebp),%eax
    fec1:	83 c0 03             	add    $0x3,%eax
    fec4:	0f b6 00             	movzbl (%eax),%eax
    fec7:	0f b6 d8             	movzbl %al,%ebx
    feca:	8b 45 cc             	mov    -0x34(%ebp),%eax
    fecd:	83 c0 02             	add    $0x2,%eax
    fed0:	0f b6 00             	movzbl (%eax),%eax
    fed3:	0f b6 c8             	movzbl %al,%ecx
    fed6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    fed9:	83 c0 01             	add    $0x1,%eax
    fedc:	0f b6 00             	movzbl (%eax),%eax
    fedf:	0f b6 d0             	movzbl %al,%edx
    fee2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    fee5:	0f b6 00             	movzbl (%eax),%eax
    fee8:	0f b6 c0             	movzbl %al,%eax
    feeb:	83 ec 08             	sub    $0x8,%esp
    feee:	56                   	push   %esi
    feef:	53                   	push   %ebx
    fef0:	51                   	push   %ecx
    fef1:	52                   	push   %edx
    fef2:	50                   	push   %eax
    fef3:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    fef9:	50                   	push   %eax
    fefa:	e8 39 db ff ff       	call   da38 <color_tree_add>
    feff:	83 c4 20             	add    $0x20,%esp
    ff02:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    ff05:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ff09:	0f 85 22 09 00 00    	jne    10831 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    ff0f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ff13:	8b 45 08             	mov    0x8(%ebp),%eax
    ff16:	8b 50 14             	mov    0x14(%eax),%edx
    ff19:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ff1c:	39 c2                	cmp    %eax,%edx
    ff1e:	77 87                	ja     fea7 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    ff20:	8b 45 18             	mov    0x18(%ebp),%eax
    ff23:	8b 40 04             	mov    0x4(%eax),%eax
    ff26:	83 f8 10             	cmp    $0x10,%eax
    ff29:	0f 85 1e 01 00 00    	jne    1004d <lodepng_compute_color_stats+0x30c>
    ff2f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ff33:	0f 85 14 01 00 00    	jne    1004d <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    ff39:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    ff40:	00 00 
    ff42:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    ff49:	00 00 
    ff4b:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    ff52:	00 00 
    ff54:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    ff5b:	00 00 
    for(i = 0; i != numpixels; ++i) {
    ff5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    ff64:	e9 d8 00 00 00       	jmp    10041 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    ff69:	83 ec 04             	sub    $0x4,%esp
    ff6c:	ff 75 18             	pushl  0x18(%ebp)
    ff6f:	ff 75 f4             	pushl  -0xc(%ebp)
    ff72:	ff 75 0c             	pushl  0xc(%ebp)
    ff75:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    ff7b:	50                   	push   %eax
    ff7c:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    ff82:	50                   	push   %eax
    ff83:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    ff89:	50                   	push   %eax
    ff8a:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    ff90:	50                   	push   %eax
    ff91:	e8 a8 f2 ff ff       	call   f23e <getPixelColorRGBA16>
    ff96:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    ff99:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    ffa0:	66 c1 e8 08          	shr    $0x8,%ax
    ffa4:	89 c2                	mov    %eax,%edx
    ffa6:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    ffad:	31 d0                	xor    %edx,%eax
    ffaf:	0f b7 c0             	movzwl %ax,%eax
    ffb2:	0f b6 c0             	movzbl %al,%eax
    ffb5:	85 c0                	test   %eax,%eax
    ffb7:	75 60                	jne    10019 <lodepng_compute_color_stats+0x2d8>
    ffb9:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    ffc0:	66 c1 e8 08          	shr    $0x8,%ax
    ffc4:	89 c2                	mov    %eax,%edx
    ffc6:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    ffcd:	31 d0                	xor    %edx,%eax
    ffcf:	0f b7 c0             	movzwl %ax,%eax
    ffd2:	0f b6 c0             	movzbl %al,%eax
    ffd5:	85 c0                	test   %eax,%eax
    ffd7:	75 40                	jne    10019 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    ffd9:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    ffe0:	66 c1 e8 08          	shr    $0x8,%ax
    ffe4:	89 c2                	mov    %eax,%edx
    ffe6:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    ffed:	31 d0                	xor    %edx,%eax
    ffef:	0f b7 c0             	movzwl %ax,%eax
    fff2:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    fff5:	85 c0                	test   %eax,%eax
    fff7:	75 20                	jne    10019 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    fff9:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
   10000:	66 c1 e8 08          	shr    $0x8,%ax
   10004:	89 c2                	mov    %eax,%edx
   10006:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
   1000d:	31 d0                	xor    %edx,%eax
   1000f:	0f b7 c0             	movzwl %ax,%eax
   10012:	0f b6 c0             	movzbl %al,%eax
   10015:	85 c0                	test   %eax,%eax
   10017:	74 24                	je     1003d <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
   10019:	8b 45 08             	mov    0x8(%ebp),%eax
   1001c:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
   10023:	00 00 00 
        sixteen = 1;
   10026:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
   1002d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
   10034:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
   1003b:	eb 10                	jmp    1004d <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
   1003d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10041:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10044:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   10047:	0f 85 1c ff ff ff    	jne    ff69 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
   1004d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   10051:	0f 84 bd 02 00 00    	je     10314 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
   10057:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
   1005e:	00 00 
   10060:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
   10067:	00 00 
   10069:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
   10070:	00 00 
   10072:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
   10079:	00 00 

    for(i = 0; i != numpixels; ++i) {
   1007b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10082:	e9 b1 01 00 00       	jmp    10238 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
   10087:	83 ec 04             	sub    $0x4,%esp
   1008a:	ff 75 18             	pushl  0x18(%ebp)
   1008d:	ff 75 f4             	pushl  -0xc(%ebp)
   10090:	ff 75 0c             	pushl  0xc(%ebp)
   10093:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
   10099:	50                   	push   %eax
   1009a:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
   100a0:	50                   	push   %eax
   100a1:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
   100a7:	50                   	push   %eax
   100a8:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
   100ae:	50                   	push   %eax
   100af:	e8 8a f1 ff ff       	call   f23e <getPixelColorRGBA16>
   100b4:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
   100b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   100bb:	75 36                	jne    100f3 <lodepng_compute_color_stats+0x3b2>
   100bd:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
   100c4:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
   100cb:	66 39 c2             	cmp    %ax,%dx
   100ce:	75 13                	jne    100e3 <lodepng_compute_color_stats+0x3a2>
   100d0:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
   100d7:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
   100de:	66 39 c2             	cmp    %ax,%dx
   100e1:	74 10                	je     100f3 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
   100e3:	8b 45 08             	mov    0x8(%ebp),%eax
   100e6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
   100ec:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
   100f3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   100f7:	0f 85 1f 01 00 00    	jne    1021c <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
   100fd:	8b 45 08             	mov    0x8(%ebp),%eax
   10100:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   10104:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
   1010b:	66 39 c2             	cmp    %ax,%dx
   1010e:	75 2d                	jne    1013d <lodepng_compute_color_stats+0x3fc>
   10110:	8b 45 08             	mov    0x8(%ebp),%eax
   10113:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
   10117:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
   1011e:	66 39 c2             	cmp    %ax,%dx
   10121:	75 1a                	jne    1013d <lodepng_compute_color_stats+0x3fc>
   10123:	8b 45 08             	mov    0x8(%ebp),%eax
   10126:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
   1012a:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
   10131:	66 39 c2             	cmp    %ax,%dx
   10134:	75 07                	jne    1013d <lodepng_compute_color_stats+0x3fc>
   10136:	b8 01 00 00 00       	mov    $0x1,%eax
   1013b:	eb 05                	jmp    10142 <lodepng_compute_color_stats+0x401>
   1013d:	b8 00 00 00 00       	mov    $0x0,%eax
   10142:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
   10145:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   1014c:	66 83 f8 ff          	cmp    $0xffff,%ax
   10150:	74 3c                	je     1018e <lodepng_compute_color_stats+0x44d>
   10152:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   10159:	66 85 c0             	test   %ax,%ax
   1015c:	75 10                	jne    1016e <lodepng_compute_color_stats+0x42d>
   1015e:	8b 45 08             	mov    0x8(%ebp),%eax
   10161:	8b 40 04             	mov    0x4(%eax),%eax
   10164:	85 c0                	test   %eax,%eax
   10166:	74 26                	je     1018e <lodepng_compute_color_stats+0x44d>
   10168:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   1016c:	75 20                	jne    1018e <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
   1016e:	8b 45 08             	mov    0x8(%ebp),%eax
   10171:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   10178:	8b 45 08             	mov    0x8(%ebp),%eax
   1017b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   10182:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
   10189:	e9 8e 00 00 00       	jmp    1021c <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
   1018e:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   10195:	66 85 c0             	test   %ax,%ax
   10198:	75 4a                	jne    101e4 <lodepng_compute_color_stats+0x4a3>
   1019a:	8b 45 08             	mov    0x8(%ebp),%eax
   1019d:	8b 40 10             	mov    0x10(%eax),%eax
   101a0:	85 c0                	test   %eax,%eax
   101a2:	75 40                	jne    101e4 <lodepng_compute_color_stats+0x4a3>
   101a4:	8b 45 08             	mov    0x8(%ebp),%eax
   101a7:	8b 40 04             	mov    0x4(%eax),%eax
   101aa:	85 c0                	test   %eax,%eax
   101ac:	75 36                	jne    101e4 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
   101ae:	8b 45 08             	mov    0x8(%ebp),%eax
   101b1:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
   101b8:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
   101bf:	8b 45 08             	mov    0x8(%ebp),%eax
   101c2:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
   101c6:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
   101cd:	8b 45 08             	mov    0x8(%ebp),%eax
   101d0:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
   101d4:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
   101db:	8b 45 08             	mov    0x8(%ebp),%eax
   101de:	66 89 50 0c          	mov    %dx,0xc(%eax)
   101e2:	eb 38                	jmp    1021c <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
   101e4:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   101eb:	66 83 f8 ff          	cmp    $0xffff,%ax
   101ef:	75 2b                	jne    1021c <lodepng_compute_color_stats+0x4db>
   101f1:	8b 45 08             	mov    0x8(%ebp),%eax
   101f4:	8b 40 04             	mov    0x4(%eax),%eax
   101f7:	85 c0                	test   %eax,%eax
   101f9:	74 21                	je     1021c <lodepng_compute_color_stats+0x4db>
   101fb:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   101ff:	74 1b                	je     1021c <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
   10201:	8b 45 08             	mov    0x8(%ebp),%eax
   10204:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   1020b:	8b 45 08             	mov    0x8(%ebp),%eax
   1020e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   10215:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
   1021c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10220:	74 12                	je     10234 <lodepng_compute_color_stats+0x4f3>
   10222:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10226:	74 0c                	je     10234 <lodepng_compute_color_stats+0x4f3>
   10228:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1022c:	74 06                	je     10234 <lodepng_compute_color_stats+0x4f3>
   1022e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10232:	75 12                	jne    10246 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
   10234:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10238:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1023b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   1023e:	0f 85 43 fe ff ff    	jne    10087 <lodepng_compute_color_stats+0x346>
   10244:	eb 01                	jmp    10247 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
   10246:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
   10247:	8b 45 08             	mov    0x8(%ebp),%eax
   1024a:	8b 40 04             	mov    0x4(%eax),%eax
   1024d:	85 c0                	test   %eax,%eax
   1024f:	0f 84 e0 05 00 00    	je     10835 <lodepng_compute_color_stats+0xaf4>
   10255:	8b 45 08             	mov    0x8(%ebp),%eax
   10258:	8b 40 10             	mov    0x10(%eax),%eax
   1025b:	85 c0                	test   %eax,%eax
   1025d:	0f 85 d2 05 00 00    	jne    10835 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
   10263:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1026a:	e9 94 00 00 00       	jmp    10303 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
   1026f:	83 ec 04             	sub    $0x4,%esp
   10272:	ff 75 18             	pushl  0x18(%ebp)
   10275:	ff 75 f4             	pushl  -0xc(%ebp)
   10278:	ff 75 0c             	pushl  0xc(%ebp)
   1027b:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
   10281:	50                   	push   %eax
   10282:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
   10288:	50                   	push   %eax
   10289:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
   1028f:	50                   	push   %eax
   10290:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
   10296:	50                   	push   %eax
   10297:	e8 a2 ef ff ff       	call   f23e <getPixelColorRGBA16>
   1029c:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
   1029f:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
   102a6:	66 85 c0             	test   %ax,%ax
   102a9:	74 54                	je     102ff <lodepng_compute_color_stats+0x5be>
   102ab:	8b 45 08             	mov    0x8(%ebp),%eax
   102ae:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   102b2:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
   102b9:	66 39 c2             	cmp    %ax,%dx
   102bc:	75 41                	jne    102ff <lodepng_compute_color_stats+0x5be>
   102be:	8b 45 08             	mov    0x8(%ebp),%eax
   102c1:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
   102c5:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
   102cc:	66 39 c2             	cmp    %ax,%dx
   102cf:	75 2e                	jne    102ff <lodepng_compute_color_stats+0x5be>
   102d1:	8b 45 08             	mov    0x8(%ebp),%eax
   102d4:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
   102d8:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
   102df:	66 39 c2             	cmp    %ax,%dx
   102e2:	75 1b                	jne    102ff <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
   102e4:	8b 45 08             	mov    0x8(%ebp),%eax
   102e7:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   102ee:	8b 45 08             	mov    0x8(%ebp),%eax
   102f1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   102f8:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
   102ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10303:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10306:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   10309:	0f 85 60 ff ff ff    	jne    1026f <lodepng_compute_color_stats+0x52e>
   1030f:	e9 21 05 00 00       	jmp    10835 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
   10314:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
   1031b:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
   10322:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
   10329:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
   10330:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10337:	e9 ab 03 00 00       	jmp    106e7 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
   1033c:	83 ec 04             	sub    $0x4,%esp
   1033f:	ff 75 18             	pushl  0x18(%ebp)
   10342:	ff 75 f4             	pushl  -0xc(%ebp)
   10345:	ff 75 0c             	pushl  0xc(%ebp)
   10348:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
   1034e:	50                   	push   %eax
   1034f:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
   10355:	50                   	push   %eax
   10356:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
   1035c:	50                   	push   %eax
   1035d:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
   10363:	50                   	push   %eax
   10364:	e8 1e de ff ff       	call   e187 <getPixelColorRGBA8>
   10369:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
   1036c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10370:	75 41                	jne    103b3 <lodepng_compute_color_stats+0x672>
   10372:	8b 45 08             	mov    0x8(%ebp),%eax
   10375:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   1037b:	83 f8 07             	cmp    $0x7,%eax
   1037e:	77 33                	ja     103b3 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
   10380:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   10387:	0f b6 c0             	movzbl %al,%eax
   1038a:	83 ec 0c             	sub    $0xc,%esp
   1038d:	50                   	push   %eax
   1038e:	e8 1d f9 ff ff       	call   fcb0 <getValueRequiredBits>
   10393:	83 c4 10             	add    $0x10,%esp
   10396:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
   10399:	8b 45 08             	mov    0x8(%ebp),%eax
   1039c:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   103a2:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   103a5:	73 0c                	jae    103b3 <lodepng_compute_color_stats+0x672>
   103a7:	8b 45 08             	mov    0x8(%ebp),%eax
   103aa:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   103ad:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
   103b3:	8b 45 08             	mov    0x8(%ebp),%eax
   103b6:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   103bc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   103bf:	0f 93 c0             	setae  %al
   103c2:	0f b6 c0             	movzbl %al,%eax
   103c5:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
   103c8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   103cc:	75 4f                	jne    1041d <lodepng_compute_color_stats+0x6dc>
   103ce:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
   103d5:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   103dc:	38 c2                	cmp    %al,%dl
   103de:	75 12                	jne    103f2 <lodepng_compute_color_stats+0x6b1>
   103e0:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
   103e7:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   103ee:	38 c2                	cmp    %al,%dl
   103f0:	74 2b                	je     1041d <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
   103f2:	8b 45 08             	mov    0x8(%ebp),%eax
   103f5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
   103fb:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
   10402:	8b 45 08             	mov    0x8(%ebp),%eax
   10405:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   1040b:	83 f8 07             	cmp    $0x7,%eax
   1040e:	77 0d                	ja     1041d <lodepng_compute_color_stats+0x6dc>
   10410:	8b 45 08             	mov    0x8(%ebp),%eax
   10413:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
   1041a:	00 00 00 
      }

      if(!alpha_done) {
   1041d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10421:	0f 85 65 01 00 00    	jne    1058c <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
   10427:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   1042e:	0f b6 d0             	movzbl %al,%edx
   10431:	8b 45 08             	mov    0x8(%ebp),%eax
   10434:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   10438:	66 39 c2             	cmp    %ax,%dx
   1043b:	75 33                	jne    10470 <lodepng_compute_color_stats+0x72f>
   1043d:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   10444:	0f b6 d0             	movzbl %al,%edx
   10447:	8b 45 08             	mov    0x8(%ebp),%eax
   1044a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   1044e:	66 39 c2             	cmp    %ax,%dx
   10451:	75 1d                	jne    10470 <lodepng_compute_color_stats+0x72f>
   10453:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   1045a:	0f b6 d0             	movzbl %al,%edx
   1045d:	8b 45 08             	mov    0x8(%ebp),%eax
   10460:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   10464:	66 39 c2             	cmp    %ax,%dx
   10467:	75 07                	jne    10470 <lodepng_compute_color_stats+0x72f>
   10469:	b8 01 00 00 00       	mov    $0x1,%eax
   1046e:	eb 05                	jmp    10475 <lodepng_compute_color_stats+0x734>
   10470:	b8 00 00 00 00       	mov    $0x0,%eax
   10475:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
   10478:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   1047f:	3c ff                	cmp    $0xff,%al
   10481:	74 5a                	je     104dd <lodepng_compute_color_stats+0x79c>
   10483:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   1048a:	84 c0                	test   %al,%al
   1048c:	75 10                	jne    1049e <lodepng_compute_color_stats+0x75d>
   1048e:	8b 45 08             	mov    0x8(%ebp),%eax
   10491:	8b 40 04             	mov    0x4(%eax),%eax
   10494:	85 c0                	test   %eax,%eax
   10496:	74 45                	je     104dd <lodepng_compute_color_stats+0x79c>
   10498:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   1049c:	75 3f                	jne    104dd <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
   1049e:	8b 45 08             	mov    0x8(%ebp),%eax
   104a1:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   104a8:	8b 45 08             	mov    0x8(%ebp),%eax
   104ab:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   104b2:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
   104b9:	8b 45 08             	mov    0x8(%ebp),%eax
   104bc:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   104c2:	83 f8 07             	cmp    $0x7,%eax
   104c5:	0f 87 c1 00 00 00    	ja     1058c <lodepng_compute_color_stats+0x84b>
   104cb:	8b 45 08             	mov    0x8(%ebp),%eax
   104ce:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
   104d5:	00 00 00 
   104d8:	e9 af 00 00 00       	jmp    1058c <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
   104dd:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   104e4:	84 c0                	test   %al,%al
   104e6:	75 53                	jne    1053b <lodepng_compute_color_stats+0x7fa>
   104e8:	8b 45 08             	mov    0x8(%ebp),%eax
   104eb:	8b 40 10             	mov    0x10(%eax),%eax
   104ee:	85 c0                	test   %eax,%eax
   104f0:	75 49                	jne    1053b <lodepng_compute_color_stats+0x7fa>
   104f2:	8b 45 08             	mov    0x8(%ebp),%eax
   104f5:	8b 40 04             	mov    0x4(%eax),%eax
   104f8:	85 c0                	test   %eax,%eax
   104fa:	75 3f                	jne    1053b <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
   104fc:	8b 45 08             	mov    0x8(%ebp),%eax
   104ff:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
   10506:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   1050d:	0f b6 d0             	movzbl %al,%edx
   10510:	8b 45 08             	mov    0x8(%ebp),%eax
   10513:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
   10517:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   1051e:	0f b6 d0             	movzbl %al,%edx
   10521:	8b 45 08             	mov    0x8(%ebp),%eax
   10524:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
   10528:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   1052f:	0f b6 d0             	movzbl %al,%edx
   10532:	8b 45 08             	mov    0x8(%ebp),%eax
   10535:	66 89 50 0c          	mov    %dx,0xc(%eax)
   10539:	eb 51                	jmp    1058c <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
   1053b:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   10542:	3c ff                	cmp    $0xff,%al
   10544:	75 46                	jne    1058c <lodepng_compute_color_stats+0x84b>
   10546:	8b 45 08             	mov    0x8(%ebp),%eax
   10549:	8b 40 04             	mov    0x4(%eax),%eax
   1054c:	85 c0                	test   %eax,%eax
   1054e:	74 3c                	je     1058c <lodepng_compute_color_stats+0x84b>
   10550:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   10554:	74 36                	je     1058c <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
   10556:	8b 45 08             	mov    0x8(%ebp),%eax
   10559:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   10560:	8b 45 08             	mov    0x8(%ebp),%eax
   10563:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   1056a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
   10571:	8b 45 08             	mov    0x8(%ebp),%eax
   10574:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   1057a:	83 f8 07             	cmp    $0x7,%eax
   1057d:	77 0d                	ja     1058c <lodepng_compute_color_stats+0x84b>
   1057f:	8b 45 08             	mov    0x8(%ebp),%eax
   10582:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
   10589:	00 00 00 
        }
      }

      if(!numcolors_done) {
   1058c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10590:	0f 85 35 01 00 00    	jne    106cb <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
   10596:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   1059d:	0f b6 d8             	movzbl %al,%ebx
   105a0:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   105a7:	0f b6 c8             	movzbl %al,%ecx
   105aa:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   105b1:	0f b6 d0             	movzbl %al,%edx
   105b4:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   105bb:	0f b6 c0             	movzbl %al,%eax
   105be:	83 ec 0c             	sub    $0xc,%esp
   105c1:	53                   	push   %ebx
   105c2:	51                   	push   %ecx
   105c3:	52                   	push   %edx
   105c4:	50                   	push   %eax
   105c5:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   105cb:	50                   	push   %eax
   105cc:	e8 1c d4 ff ff       	call   d9ed <color_tree_has>
   105d1:	83 c4 20             	add    $0x20,%esp
   105d4:	85 c0                	test   %eax,%eax
   105d6:	0f 85 ef 00 00 00    	jne    106cb <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
   105dc:	8b 45 08             	mov    0x8(%ebp),%eax
   105df:	8b 70 14             	mov    0x14(%eax),%esi
   105e2:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   105e9:	0f b6 d8             	movzbl %al,%ebx
   105ec:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   105f3:	0f b6 c8             	movzbl %al,%ecx
   105f6:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   105fd:	0f b6 d0             	movzbl %al,%edx
   10600:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   10607:	0f b6 c0             	movzbl %al,%eax
   1060a:	83 ec 08             	sub    $0x8,%esp
   1060d:	56                   	push   %esi
   1060e:	53                   	push   %ebx
   1060f:	51                   	push   %ecx
   10610:	52                   	push   %edx
   10611:	50                   	push   %eax
   10612:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   10618:	50                   	push   %eax
   10619:	e8 1a d4 ff ff       	call   da38 <color_tree_add>
   1061e:	83 c4 20             	add    $0x20,%esp
   10621:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
   10624:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10628:	0f 85 06 02 00 00    	jne    10834 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
   1062e:	8b 45 08             	mov    0x8(%ebp),%eax
   10631:	8b 40 14             	mov    0x14(%eax),%eax
   10634:	3d ff 00 00 00       	cmp    $0xff,%eax
   10639:	77 6f                	ja     106aa <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
   1063b:	8b 45 08             	mov    0x8(%ebp),%eax
   1063e:	83 c0 18             	add    $0x18,%eax
   10641:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
   10644:	8b 45 08             	mov    0x8(%ebp),%eax
   10647:	8b 40 14             	mov    0x14(%eax),%eax
   1064a:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
   1064d:	8b 45 b8             	mov    -0x48(%ebp),%eax
   10650:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10657:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1065a:	01 c2                	add    %eax,%edx
   1065c:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   10663:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
   10665:	8b 45 b8             	mov    -0x48(%ebp),%eax
   10668:	c1 e0 02             	shl    $0x2,%eax
   1066b:	8d 50 01             	lea    0x1(%eax),%edx
   1066e:	8b 45 bc             	mov    -0x44(%ebp),%eax
   10671:	01 c2                	add    %eax,%edx
   10673:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   1067a:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
   1067c:	8b 45 b8             	mov    -0x48(%ebp),%eax
   1067f:	c1 e0 02             	shl    $0x2,%eax
   10682:	8d 50 02             	lea    0x2(%eax),%edx
   10685:	8b 45 bc             	mov    -0x44(%ebp),%eax
   10688:	01 c2                	add    %eax,%edx
   1068a:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   10691:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
   10693:	8b 45 b8             	mov    -0x48(%ebp),%eax
   10696:	c1 e0 02             	shl    $0x2,%eax
   10699:	8d 50 03             	lea    0x3(%eax),%edx
   1069c:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1069f:	01 c2                	add    %eax,%edx
   106a1:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   106a8:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
   106aa:	8b 45 08             	mov    0x8(%ebp),%eax
   106ad:	8b 40 14             	mov    0x14(%eax),%eax
   106b0:	8d 50 01             	lea    0x1(%eax),%edx
   106b3:	8b 45 08             	mov    0x8(%ebp),%eax
   106b6:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
   106b9:	8b 45 08             	mov    0x8(%ebp),%eax
   106bc:	8b 40 14             	mov    0x14(%eax),%eax
   106bf:	3b 45 d8             	cmp    -0x28(%ebp),%eax
   106c2:	0f 93 c0             	setae  %al
   106c5:	0f b6 c0             	movzbl %al,%eax
   106c8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
   106cb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   106cf:	74 12                	je     106e3 <lodepng_compute_color_stats+0x9a2>
   106d1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   106d5:	74 0c                	je     106e3 <lodepng_compute_color_stats+0x9a2>
   106d7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   106db:	74 06                	je     106e3 <lodepng_compute_color_stats+0x9a2>
   106dd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   106e1:	75 12                	jne    106f5 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
   106e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   106e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   106ea:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   106ed:	0f 85 49 fc ff ff    	jne    1033c <lodepng_compute_color_stats+0x5fb>
   106f3:	eb 01                	jmp    106f6 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
   106f5:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
   106f6:	8b 45 08             	mov    0x8(%ebp),%eax
   106f9:	8b 40 04             	mov    0x4(%eax),%eax
   106fc:	85 c0                	test   %eax,%eax
   106fe:	0f 84 dd 00 00 00    	je     107e1 <lodepng_compute_color_stats+0xaa0>
   10704:	8b 45 08             	mov    0x8(%ebp),%eax
   10707:	8b 40 10             	mov    0x10(%eax),%eax
   1070a:	85 c0                	test   %eax,%eax
   1070c:	0f 85 cf 00 00 00    	jne    107e1 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
   10712:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10719:	e9 b7 00 00 00       	jmp    107d5 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
   1071e:	83 ec 04             	sub    $0x4,%esp
   10721:	ff 75 18             	pushl  0x18(%ebp)
   10724:	ff 75 f4             	pushl  -0xc(%ebp)
   10727:	ff 75 0c             	pushl  0xc(%ebp)
   1072a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
   10730:	50                   	push   %eax
   10731:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
   10737:	50                   	push   %eax
   10738:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
   1073e:	50                   	push   %eax
   1073f:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
   10745:	50                   	push   %eax
   10746:	e8 3c da ff ff       	call   e187 <getPixelColorRGBA8>
   1074b:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
   1074e:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
   10755:	84 c0                	test   %al,%al
   10757:	74 78                	je     107d1 <lodepng_compute_color_stats+0xa90>
   10759:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
   10760:	0f b6 d0             	movzbl %al,%edx
   10763:	8b 45 08             	mov    0x8(%ebp),%eax
   10766:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   1076a:	66 39 c2             	cmp    %ax,%dx
   1076d:	75 62                	jne    107d1 <lodepng_compute_color_stats+0xa90>
   1076f:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
   10776:	0f b6 d0             	movzbl %al,%edx
   10779:	8b 45 08             	mov    0x8(%ebp),%eax
   1077c:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   10780:	66 39 c2             	cmp    %ax,%dx
   10783:	75 4c                	jne    107d1 <lodepng_compute_color_stats+0xa90>
   10785:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
   1078c:	0f b6 d0             	movzbl %al,%edx
   1078f:	8b 45 08             	mov    0x8(%ebp),%eax
   10792:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   10796:	66 39 c2             	cmp    %ax,%dx
   10799:	75 36                	jne    107d1 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
   1079b:	8b 45 08             	mov    0x8(%ebp),%eax
   1079e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
   107a5:	8b 45 08             	mov    0x8(%ebp),%eax
   107a8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
   107af:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
   107b6:	8b 45 08             	mov    0x8(%ebp),%eax
   107b9:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   107bf:	83 f8 07             	cmp    $0x7,%eax
   107c2:	77 0d                	ja     107d1 <lodepng_compute_color_stats+0xa90>
   107c4:	8b 45 08             	mov    0x8(%ebp),%eax
   107c7:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
   107ce:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
   107d1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   107d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107d8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   107db:	0f 85 3d ff ff ff    	jne    1071e <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
   107e1:	8b 45 08             	mov    0x8(%ebp),%eax
   107e4:	0f b7 50 08          	movzwl 0x8(%eax),%edx
   107e8:	8b 45 08             	mov    0x8(%ebp),%eax
   107eb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   107ef:	c1 e0 08             	shl    $0x8,%eax
   107f2:	01 c2                	add    %eax,%edx
   107f4:	8b 45 08             	mov    0x8(%ebp),%eax
   107f7:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
   107fb:	8b 45 08             	mov    0x8(%ebp),%eax
   107fe:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
   10802:	8b 45 08             	mov    0x8(%ebp),%eax
   10805:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   10809:	c1 e0 08             	shl    $0x8,%eax
   1080c:	01 c2                	add    %eax,%edx
   1080e:	8b 45 08             	mov    0x8(%ebp),%eax
   10811:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
   10815:	8b 45 08             	mov    0x8(%ebp),%eax
   10818:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
   1081c:	8b 45 08             	mov    0x8(%ebp),%eax
   1081f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   10823:	c1 e0 08             	shl    $0x8,%eax
   10826:	01 c2                	add    %eax,%edx
   10828:	8b 45 08             	mov    0x8(%ebp),%eax
   1082b:	66 89 50 0c          	mov    %dx,0xc(%eax)
   1082f:	eb 04                	jmp    10835 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
   10831:	90                   	nop
   10832:	eb 01                	jmp    10835 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
   10834:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
   10835:	83 ec 0c             	sub    $0xc,%esp
   10838:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   1083e:	50                   	push   %eax
   1083f:	e8 91 d0 ff ff       	call   d8d5 <color_tree_cleanup>
   10844:	83 c4 10             	add    $0x10,%esp
  return error;
   10847:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1084a:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1084d:	5b                   	pop    %ebx
   1084e:	5e                   	pop    %esi
   1084f:	5d                   	pop    %ebp
   10850:	c3                   	ret    

00010851 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
   10851:	55                   	push   %ebp
   10852:	89 e5                	mov    %esp,%ebp
   10854:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
   10857:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
   1085e:	8d 45 cc             	lea    -0x34(%ebp),%eax
   10861:	50                   	push   %eax
   10862:	e8 d1 bd ff ff       	call   c638 <lodepng_color_mode_init>
   10867:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
   1086a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1086d:	c1 e8 08             	shr    $0x8,%eax
   10870:	88 45 ec             	mov    %al,-0x14(%ebp)
   10873:	8b 45 0c             	mov    0xc(%ebp),%eax
   10876:	88 45 ed             	mov    %al,-0x13(%ebp)
   10879:	8b 45 10             	mov    0x10(%ebp),%eax
   1087c:	c1 e8 08             	shr    $0x8,%eax
   1087f:	88 45 ee             	mov    %al,-0x12(%ebp)
   10882:	8b 45 10             	mov    0x10(%ebp),%eax
   10885:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
   10888:	8b 45 14             	mov    0x14(%ebp),%eax
   1088b:	c1 e8 08             	shr    $0x8,%eax
   1088e:	88 45 f0             	mov    %al,-0x10(%ebp)
   10891:	8b 45 14             	mov    0x14(%ebp),%eax
   10894:	88 45 f1             	mov    %al,-0xf(%ebp)
   10897:	8b 45 18             	mov    0x18(%ebp),%eax
   1089a:	c1 e8 08             	shr    $0x8,%eax
   1089d:	88 45 f2             	mov    %al,-0xe(%ebp)
   108a0:	8b 45 18             	mov    0x18(%ebp),%eax
   108a3:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
   108a6:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
   108ad:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
   108b4:	83 ec 0c             	sub    $0xc,%esp
   108b7:	8d 45 cc             	lea    -0x34(%ebp),%eax
   108ba:	50                   	push   %eax
   108bb:	6a 01                	push   $0x1
   108bd:	6a 01                	push   $0x1
   108bf:	8d 45 ec             	lea    -0x14(%ebp),%eax
   108c2:	50                   	push   %eax
   108c3:	ff 75 08             	pushl  0x8(%ebp)
   108c6:	e8 76 f4 ff ff       	call   fd41 <lodepng_compute_color_stats>
   108cb:	83 c4 20             	add    $0x20,%esp
   108ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
   108d1:	83 ec 0c             	sub    $0xc,%esp
   108d4:	8d 45 cc             	lea    -0x34(%ebp),%eax
   108d7:	50                   	push   %eax
   108d8:	e8 4e be ff ff       	call   c72b <lodepng_color_mode_cleanup>
   108dd:	83 c4 10             	add    $0x10,%esp
  return error;
   108e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   108e3:	c9                   	leave  
   108e4:	c3                   	ret    

000108e5 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
   108e5:	55                   	push   %ebp
   108e6:	89 e5                	mov    %esp,%ebp
   108e8:	56                   	push   %esi
   108e9:	53                   	push   %ebx
   108ea:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
   108ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
   108f4:	8b 45 10             	mov    0x10(%ebp),%eax
   108f7:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
   108fd:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
   10900:	8b 45 10             	mov    0x10(%ebp),%eax
   10903:	8b 40 10             	mov    0x10(%eax),%eax
   10906:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
   10909:	8b 45 10             	mov    0x10(%ebp),%eax
   1090c:	8b 40 04             	mov    0x4(%eax),%eax
   1090f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
   10912:	8b 45 10             	mov    0x10(%ebp),%eax
   10915:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   1091b:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
   1091e:	8b 45 08             	mov    0x8(%ebp),%eax
   10921:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
   10928:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1092c:	74 21                	je     1094f <auto_choose_color+0x6a>
   1092e:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
   10932:	7f 1b                	jg     1094f <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
   10934:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
   1093b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
   10942:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   10946:	77 07                	ja     1094f <auto_choose_color+0x6a>
   10948:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
   1094f:	8b 45 10             	mov    0x10(%ebp),%eax
   10952:	8b 00                	mov    (%eax),%eax
   10954:	85 c0                	test   %eax,%eax
   10956:	0f 94 c0             	sete   %al
   10959:	0f b6 c0             	movzbl %al,%eax
   1095c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
   1095f:	8b 45 10             	mov    0x10(%ebp),%eax
   10962:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
   10968:	85 c0                	test   %eax,%eax
   1096a:	75 07                	jne    10973 <auto_choose_color+0x8e>
   1096c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
   10973:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10977:	75 0d                	jne    10986 <auto_choose_color+0xa1>
   10979:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   1097d:	77 07                	ja     10986 <auto_choose_color+0xa1>
   1097f:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
   10986:	8b 45 10             	mov    0x10(%ebp),%eax
   10989:	8b 40 14             	mov    0x14(%eax),%eax
   1098c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
   1098f:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
   10993:	7e 21                	jle    109b6 <auto_choose_color+0xd1>
   10995:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
   10999:	7e 14                	jle    109af <auto_choose_color+0xca>
   1099b:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
   1099f:	7f 07                	jg     109a8 <auto_choose_color+0xc3>
   109a1:	b8 04 00 00 00       	mov    $0x4,%eax
   109a6:	eb 13                	jmp    109bb <auto_choose_color+0xd6>
   109a8:	b8 08 00 00 00       	mov    $0x8,%eax
   109ad:	eb 0c                	jmp    109bb <auto_choose_color+0xd6>
   109af:	b8 02 00 00 00       	mov    $0x2,%eax
   109b4:	eb 05                	jmp    109bb <auto_choose_color+0xd6>
   109b6:	b8 01 00 00 00       	mov    $0x1,%eax
   109bb:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
   109be:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
   109c5:	7f 13                	jg     109da <auto_choose_color+0xf5>
   109c7:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
   109cb:	77 0d                	ja     109da <auto_choose_color+0xf5>
   109cd:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   109d1:	74 07                	je     109da <auto_choose_color+0xf5>
   109d3:	b8 01 00 00 00       	mov    $0x1,%eax
   109d8:	eb 05                	jmp    109df <auto_choose_color+0xfa>
   109da:	b8 00 00 00 00       	mov    $0x0,%eax
   109df:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
   109e2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   109e5:	01 c0                	add    %eax,%eax
   109e7:	3b 45 d8             	cmp    -0x28(%ebp),%eax
   109ea:	7e 07                	jle    109f3 <auto_choose_color+0x10e>
   109ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
   109f3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   109f7:	74 15                	je     10a0e <auto_choose_color+0x129>
   109f9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   109fd:	75 0f                	jne    10a0e <auto_choose_color+0x129>
   109ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10a02:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   10a05:	77 07                	ja     10a0e <auto_choose_color+0x129>
   10a07:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
   10a0e:	8b 45 10             	mov    0x10(%ebp),%eax
   10a11:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
   10a17:	85 c0                	test   %eax,%eax
   10a19:	75 07                	jne    10a22 <auto_choose_color+0x13d>
   10a1b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
   10a22:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10a26:	0f 84 0a 01 00 00    	je     10b36 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
   10a2c:	8b 45 10             	mov    0x10(%ebp),%eax
   10a2f:	83 c0 18             	add    $0x18,%eax
   10a32:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
   10a35:	83 ec 0c             	sub    $0xc,%esp
   10a38:	ff 75 08             	pushl  0x8(%ebp)
   10a3b:	e8 ef be ff ff       	call   c92f <lodepng_palette_clear>
   10a40:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
   10a43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10a4a:	eb 6e                	jmp    10aba <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
   10a4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a4f:	c1 e0 02             	shl    $0x2,%eax
   10a52:	8d 50 03             	lea    0x3(%eax),%edx
   10a55:	8b 45 cc             	mov    -0x34(%ebp),%eax
   10a58:	01 d0                	add    %edx,%eax
   10a5a:	0f b6 00             	movzbl (%eax),%eax
   10a5d:	0f b6 d8             	movzbl %al,%ebx
   10a60:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a63:	c1 e0 02             	shl    $0x2,%eax
   10a66:	8d 50 02             	lea    0x2(%eax),%edx
   10a69:	8b 45 cc             	mov    -0x34(%ebp),%eax
   10a6c:	01 d0                	add    %edx,%eax
   10a6e:	0f b6 00             	movzbl (%eax),%eax
   10a71:	0f b6 c8             	movzbl %al,%ecx
   10a74:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a77:	c1 e0 02             	shl    $0x2,%eax
   10a7a:	8d 50 01             	lea    0x1(%eax),%edx
   10a7d:	8b 45 cc             	mov    -0x34(%ebp),%eax
   10a80:	01 d0                	add    %edx,%eax
   10a82:	0f b6 00             	movzbl (%eax),%eax
   10a85:	0f b6 d0             	movzbl %al,%edx
   10a88:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a8b:	c1 e0 02             	shl    $0x2,%eax
   10a8e:	89 c6                	mov    %eax,%esi
   10a90:	8b 45 cc             	mov    -0x34(%ebp),%eax
   10a93:	01 f0                	add    %esi,%eax
   10a95:	0f b6 00             	movzbl (%eax),%eax
   10a98:	0f b6 c0             	movzbl %al,%eax
   10a9b:	83 ec 0c             	sub    $0xc,%esp
   10a9e:	53                   	push   %ebx
   10a9f:	51                   	push   %ecx
   10aa0:	52                   	push   %edx
   10aa1:	50                   	push   %eax
   10aa2:	ff 75 08             	pushl  0x8(%ebp)
   10aa5:	e8 be be ff ff       	call   c968 <lodepng_palette_add>
   10aaa:	83 c4 20             	add    $0x20,%esp
   10aad:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
   10ab0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10ab4:	75 13                	jne    10ac9 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
   10ab6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10aba:	8b 45 10             	mov    0x10(%ebp),%eax
   10abd:	8b 50 14             	mov    0x14(%eax),%edx
   10ac0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ac3:	39 c2                	cmp    %eax,%edx
   10ac5:	75 85                	jne    10a4c <auto_choose_color+0x167>
   10ac7:	eb 01                	jmp    10aca <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
   10ac9:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
   10aca:	8b 45 08             	mov    0x8(%ebp),%eax
   10acd:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
   10ad3:	8b 45 08             	mov    0x8(%ebp),%eax
   10ad6:	8b 55 d0             	mov    -0x30(%ebp),%edx
   10ad9:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
   10adc:	8b 45 0c             	mov    0xc(%ebp),%eax
   10adf:	8b 00                	mov    (%eax),%eax
   10ae1:	83 f8 03             	cmp    $0x3,%eax
   10ae4:	0f 85 ec 00 00 00    	jne    10bd6 <auto_choose_color+0x2f1>
   10aea:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aed:	8b 50 0c             	mov    0xc(%eax),%edx
   10af0:	8b 45 08             	mov    0x8(%ebp),%eax
   10af3:	8b 40 0c             	mov    0xc(%eax),%eax
   10af6:	39 c2                	cmp    %eax,%edx
   10af8:	0f 8c d8 00 00 00    	jl     10bd6 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
   10afe:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b01:	8b 50 04             	mov    0x4(%eax),%edx
   10b04:	8b 45 08             	mov    0x8(%ebp),%eax
   10b07:	8b 40 04             	mov    0x4(%eax),%eax
   10b0a:	39 c2                	cmp    %eax,%edx
   10b0c:	0f 85 c4 00 00 00    	jne    10bd6 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
   10b12:	83 ec 0c             	sub    $0xc,%esp
   10b15:	ff 75 08             	pushl  0x8(%ebp)
   10b18:	e8 0e bc ff ff       	call   c72b <lodepng_color_mode_cleanup>
   10b1d:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
   10b20:	83 ec 08             	sub    $0x8,%esp
   10b23:	ff 75 0c             	pushl  0xc(%ebp)
   10b26:	ff 75 08             	pushl  0x8(%ebp)
   10b29:	e8 14 bc ff ff       	call   c742 <lodepng_color_mode_copy>
   10b2e:	83 c4 10             	add    $0x10,%esp
   10b31:	e9 a0 00 00 00       	jmp    10bd6 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
   10b36:	8b 45 08             	mov    0x8(%ebp),%eax
   10b39:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10b3c:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
   10b3f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10b43:	74 14                	je     10b59 <auto_choose_color+0x274>
   10b45:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10b49:	74 07                	je     10b52 <auto_choose_color+0x26d>
   10b4b:	b8 04 00 00 00       	mov    $0x4,%eax
   10b50:	eb 19                	jmp    10b6b <auto_choose_color+0x286>
   10b52:	b8 06 00 00 00       	mov    $0x6,%eax
   10b57:	eb 12                	jmp    10b6b <auto_choose_color+0x286>
   10b59:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10b5d:	74 07                	je     10b66 <auto_choose_color+0x281>
   10b5f:	b8 00 00 00 00       	mov    $0x0,%eax
   10b64:	eb 05                	jmp    10b6b <auto_choose_color+0x286>
   10b66:	b8 02 00 00 00       	mov    $0x2,%eax
   10b6b:	8b 55 08             	mov    0x8(%ebp),%edx
   10b6e:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
   10b70:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10b74:	74 60                	je     10bd6 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
   10b76:	8b 45 08             	mov    0x8(%ebp),%eax
   10b79:	8b 40 04             	mov    0x4(%eax),%eax
   10b7c:	ba 01 00 00 00       	mov    $0x1,%edx
   10b81:	89 c1                	mov    %eax,%ecx
   10b83:	d3 e2                	shl    %cl,%edx
   10b85:	89 d0                	mov    %edx,%eax
   10b87:	83 e8 01             	sub    $0x1,%eax
   10b8a:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
   10b8d:	8b 45 10             	mov    0x10(%ebp),%eax
   10b90:	0f b7 40 08          	movzwl 0x8(%eax),%eax
   10b94:	0f b7 c0             	movzwl %ax,%eax
   10b97:	23 45 c8             	and    -0x38(%ebp),%eax
   10b9a:	89 c2                	mov    %eax,%edx
   10b9c:	8b 45 08             	mov    0x8(%ebp),%eax
   10b9f:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
   10ba2:	8b 45 10             	mov    0x10(%ebp),%eax
   10ba5:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
   10ba9:	0f b7 c0             	movzwl %ax,%eax
   10bac:	23 45 c8             	and    -0x38(%ebp),%eax
   10baf:	89 c2                	mov    %eax,%edx
   10bb1:	8b 45 08             	mov    0x8(%ebp),%eax
   10bb4:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
   10bb7:	8b 45 10             	mov    0x10(%ebp),%eax
   10bba:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
   10bbe:	0f b7 c0             	movzwl %ax,%eax
   10bc1:	23 45 c8             	and    -0x38(%ebp),%eax
   10bc4:	89 c2                	mov    %eax,%edx
   10bc6:	8b 45 08             	mov    0x8(%ebp),%eax
   10bc9:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
   10bcc:	8b 45 08             	mov    0x8(%ebp),%eax
   10bcf:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
   10bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10bd9:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10bdc:	5b                   	pop    %ebx
   10bdd:	5e                   	pop    %esi
   10bde:	5d                   	pop    %ebp
   10bdf:	c3                   	ret    

00010be0 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
   10be0:	55                   	push   %ebp
   10be1:	89 e5                	mov    %esp,%ebp
   10be3:	83 ec 1c             	sub    $0x1c,%esp
   10be6:	8b 4d 08             	mov    0x8(%ebp),%ecx
   10be9:	8b 55 0c             	mov    0xc(%ebp),%edx
   10bec:	8b 45 10             	mov    0x10(%ebp),%eax
   10bef:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
   10bf3:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
   10bf7:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
   10bfb:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   10bff:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
   10c03:	29 c2                	sub    %eax,%edx
   10c05:	89 d0                	mov    %edx,%eax
   10c07:	99                   	cltd   
   10c08:	31 d0                	xor    %edx,%eax
   10c0a:	29 d0                	sub    %edx,%eax
   10c0c:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
   10c10:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
   10c14:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
   10c18:	29 c2                	sub    %eax,%edx
   10c1a:	89 d0                	mov    %edx,%eax
   10c1c:	99                   	cltd   
   10c1d:	31 d0                	xor    %edx,%eax
   10c1f:	29 d0                	sub    %edx,%eax
   10c21:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
   10c25:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
   10c29:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
   10c2d:	01 c2                	add    %eax,%edx
   10c2f:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
   10c33:	29 c2                	sub    %eax,%edx
   10c35:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
   10c39:	29 c2                	sub    %eax,%edx
   10c3b:	89 d0                	mov    %edx,%eax
   10c3d:	99                   	cltd   
   10c3e:	31 d0                	xor    %edx,%eax
   10c40:	29 d0                	sub    %edx,%eax
   10c42:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
   10c46:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   10c4a:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
   10c4e:	7d 10                	jge    10c60 <paethPredictor+0x80>
   10c50:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
   10c54:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
   10c58:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   10c5c:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
   10c60:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
   10c64:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
   10c68:	7d 06                	jge    10c70 <paethPredictor+0x90>
   10c6a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   10c6e:	eb 04                	jmp    10c74 <paethPredictor+0x94>
   10c70:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
   10c74:	c9                   	leave  
   10c75:	c3                   	ret    

00010c76 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
   10c76:	55                   	push   %ebp
   10c77:	89 e5                	mov    %esp,%ebp
   10c79:	56                   	push   %esi
   10c7a:	53                   	push   %ebx
   10c7b:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
   10c7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10c85:	e9 e2 00 00 00       	jmp    10d6c <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
   10c8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c8d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10c94:	8b 45 08             	mov    0x8(%ebp),%eax
   10c97:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10c9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c9d:	8b 14 85 b4 f3 01 00 	mov    0x1f3b4(,%eax,4),%edx
   10ca4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10ca7:	01 c2                	add    %eax,%edx
   10ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cac:	8b 04 85 7c f3 01 00 	mov    0x1f37c(,%eax,4),%eax
   10cb3:	29 c2                	sub    %eax,%edx
   10cb5:	89 d0                	mov    %edx,%eax
   10cb7:	8d 58 ff             	lea    -0x1(%eax),%ebx
   10cba:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cbd:	8b 34 85 b4 f3 01 00 	mov    0x1f3b4(,%eax,4),%esi
   10cc4:	89 d8                	mov    %ebx,%eax
   10cc6:	ba 00 00 00 00       	mov    $0x0,%edx
   10ccb:	f7 f6                	div    %esi
   10ccd:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
   10ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cd2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10cd9:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cdc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   10cdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ce2:	8b 14 85 d0 f3 01 00 	mov    0x1f3d0(,%eax,4),%edx
   10ce9:	8b 45 20             	mov    0x20(%ebp),%eax
   10cec:	01 c2                	add    %eax,%edx
   10cee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10cf1:	8b 04 85 98 f3 01 00 	mov    0x1f398(,%eax,4),%eax
   10cf8:	29 c2                	sub    %eax,%edx
   10cfa:	89 d0                	mov    %edx,%eax
   10cfc:	8d 58 ff             	lea    -0x1(%eax),%ebx
   10cff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d02:	8b 34 85 d0 f3 01 00 	mov    0x1f3d0(,%eax,4),%esi
   10d09:	89 d8                	mov    %ebx,%eax
   10d0b:	ba 00 00 00 00       	mov    $0x0,%edx
   10d10:	f7 f6                	div    %esi
   10d12:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
   10d14:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d17:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10d1e:	8b 45 08             	mov    0x8(%ebp),%eax
   10d21:	01 d0                	add    %edx,%eax
   10d23:	8b 00                	mov    (%eax),%eax
   10d25:	85 c0                	test   %eax,%eax
   10d27:	75 15                	jne    10d3e <Adam7_getpassvalues+0xc8>
   10d29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d2c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10d33:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d36:	01 d0                	add    %edx,%eax
   10d38:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
   10d3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d41:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10d48:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d4b:	01 d0                	add    %edx,%eax
   10d4d:	8b 00                	mov    (%eax),%eax
   10d4f:	85 c0                	test   %eax,%eax
   10d51:	75 15                	jne    10d68 <Adam7_getpassvalues+0xf2>
   10d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d56:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10d5d:	8b 45 08             	mov    0x8(%ebp),%eax
   10d60:	01 d0                	add    %edx,%eax
   10d62:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
   10d68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10d6c:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   10d70:	0f 85 14 ff ff ff    	jne    10c8a <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
   10d76:	8b 45 18             	mov    0x18(%ebp),%eax
   10d79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   10d7f:	8b 45 18             	mov    0x18(%ebp),%eax
   10d82:	8b 10                	mov    (%eax),%edx
   10d84:	8b 45 14             	mov    0x14(%ebp),%eax
   10d87:	89 10                	mov    %edx,(%eax)
   10d89:	8b 45 14             	mov    0x14(%ebp),%eax
   10d8c:	8b 10                	mov    (%eax),%edx
   10d8e:	8b 45 10             	mov    0x10(%ebp),%eax
   10d91:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
   10d93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10d9a:	e9 40 01 00 00       	jmp    10edf <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
   10d9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10da2:	83 c0 01             	add    $0x1,%eax
   10da5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10dac:	8b 45 10             	mov    0x10(%ebp),%eax
   10daf:	01 c2                	add    %eax,%edx
   10db1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10db4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10dbb:	8b 45 10             	mov    0x10(%ebp),%eax
   10dbe:	01 c8                	add    %ecx,%eax
   10dc0:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
   10dc2:	89 c6                	mov    %eax,%esi
   10dc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10dc7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10dce:	8b 45 08             	mov    0x8(%ebp),%eax
   10dd1:	01 c8                	add    %ecx,%eax
   10dd3:	8b 00                	mov    (%eax),%eax
   10dd5:	85 c0                	test   %eax,%eax
   10dd7:	74 49                	je     10e22 <Adam7_getpassvalues+0x1ac>
   10dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ddc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10de3:	8b 45 0c             	mov    0xc(%ebp),%eax
   10de6:	01 c8                	add    %ecx,%eax
   10de8:	8b 00                	mov    (%eax),%eax
   10dea:	85 c0                	test   %eax,%eax
   10dec:	74 34                	je     10e22 <Adam7_getpassvalues+0x1ac>
   10dee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10df1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10df8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10dfb:	01 c8                	add    %ecx,%eax
   10dfd:	8b 08                	mov    (%eax),%ecx
   10dff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e02:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
   10e09:	8b 45 08             	mov    0x8(%ebp),%eax
   10e0c:	01 d8                	add    %ebx,%eax
   10e0e:	8b 00                	mov    (%eax),%eax
   10e10:	0f af 45 24          	imul   0x24(%ebp),%eax
   10e14:	83 c0 07             	add    $0x7,%eax
   10e17:	c1 e8 03             	shr    $0x3,%eax
   10e1a:	83 c0 01             	add    $0x1,%eax
   10e1d:	0f af c1             	imul   %ecx,%eax
   10e20:	eb 05                	jmp    10e27 <Adam7_getpassvalues+0x1b1>
   10e22:	b8 00 00 00 00       	mov    $0x0,%eax
   10e27:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
   10e29:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
   10e2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e2e:	83 c0 01             	add    $0x1,%eax
   10e31:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10e38:	8b 45 14             	mov    0x14(%ebp),%eax
   10e3b:	01 c2                	add    %eax,%edx
   10e3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e40:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10e47:	8b 45 14             	mov    0x14(%ebp),%eax
   10e4a:	01 c8                	add    %ecx,%eax
   10e4c:	8b 00                	mov    (%eax),%eax
   10e4e:	89 c6                	mov    %eax,%esi
   10e50:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e53:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10e5a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10e5d:	01 c8                	add    %ecx,%eax
   10e5f:	8b 08                	mov    (%eax),%ecx
   10e61:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e64:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
   10e6b:	8b 45 08             	mov    0x8(%ebp),%eax
   10e6e:	01 d8                	add    %ebx,%eax
   10e70:	8b 00                	mov    (%eax),%eax
   10e72:	0f af 45 24          	imul   0x24(%ebp),%eax
   10e76:	83 c0 07             	add    $0x7,%eax
   10e79:	c1 e8 03             	shr    $0x3,%eax
   10e7c:	0f af c1             	imul   %ecx,%eax
   10e7f:	01 f0                	add    %esi,%eax
   10e81:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
   10e83:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e86:	83 c0 01             	add    $0x1,%eax
   10e89:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10e90:	8b 45 18             	mov    0x18(%ebp),%eax
   10e93:	01 c2                	add    %eax,%edx
   10e95:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e98:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10e9f:	8b 45 18             	mov    0x18(%ebp),%eax
   10ea2:	01 c8                	add    %ecx,%eax
   10ea4:	8b 00                	mov    (%eax),%eax
   10ea6:	89 c6                	mov    %eax,%esi
   10ea8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10eab:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   10eb2:	8b 45 0c             	mov    0xc(%ebp),%eax
   10eb5:	01 c8                	add    %ecx,%eax
   10eb7:	8b 08                	mov    (%eax),%ecx
   10eb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ebc:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
   10ec3:	8b 45 08             	mov    0x8(%ebp),%eax
   10ec6:	01 d8                	add    %ebx,%eax
   10ec8:	8b 00                	mov    (%eax),%eax
   10eca:	0f af c1             	imul   %ecx,%eax
   10ecd:	0f af 45 24          	imul   0x24(%ebp),%eax
   10ed1:	83 c0 07             	add    $0x7,%eax
   10ed4:	c1 e8 03             	shr    $0x3,%eax
   10ed7:	01 f0                	add    %esi,%eax
   10ed9:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
   10edb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10edf:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   10ee3:	0f 85 b6 fe ff ff    	jne    10d9f <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
   10ee9:	90                   	nop
   10eea:	83 c4 10             	add    $0x10,%esp
   10eed:	5b                   	pop    %ebx
   10eee:	5e                   	pop    %esi
   10eef:	5d                   	pop    %ebp
   10ef0:	c3                   	ret    

00010ef1 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
   10ef1:	55                   	push   %ebp
   10ef2:	89 e5                	mov    %esp,%ebp
   10ef4:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
   10ef7:	8b 45 10             	mov    0x10(%ebp),%eax
   10efa:	05 98 00 00 00       	add    $0x98,%eax
   10eff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
   10f02:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
   10f06:	74 06                	je     10f0e <lodepng_inspect+0x1d>
   10f08:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10f0c:	75 17                	jne    10f25 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
   10f0e:	8b 45 10             	mov    0x10(%ebp),%eax
   10f11:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
   10f18:	00 00 00 
   10f1b:	b8 30 00 00 00       	mov    $0x30,%eax
   10f20:	e9 ce 02 00 00       	jmp    111f3 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
   10f25:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
   10f29:	7f 17                	jg     10f42 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
   10f2b:	8b 45 10             	mov    0x10(%ebp),%eax
   10f2e:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
   10f35:	00 00 00 
   10f38:	b8 1b 00 00 00       	mov    $0x1b,%eax
   10f3d:	e9 b1 02 00 00       	jmp    111f3 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
   10f42:	83 ec 0c             	sub    $0xc,%esp
   10f45:	ff 75 f4             	pushl  -0xc(%ebp)
   10f48:	e8 63 c7 ff ff       	call   d6b0 <lodepng_info_cleanup>
   10f4d:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
   10f50:	83 ec 0c             	sub    $0xc,%esp
   10f53:	ff 75 f4             	pushl  -0xc(%ebp)
   10f56:	e8 74 c6 ff ff       	call   d5cf <lodepng_info_init>
   10f5b:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
   10f5e:	8b 45 14             	mov    0x14(%ebp),%eax
   10f61:	0f b6 00             	movzbl (%eax),%eax
   10f64:	3c 89                	cmp    $0x89,%al
   10f66:	75 5b                	jne    10fc3 <lodepng_inspect+0xd2>
   10f68:	8b 45 14             	mov    0x14(%ebp),%eax
   10f6b:	83 c0 01             	add    $0x1,%eax
   10f6e:	0f b6 00             	movzbl (%eax),%eax
   10f71:	3c 50                	cmp    $0x50,%al
   10f73:	75 4e                	jne    10fc3 <lodepng_inspect+0xd2>
   10f75:	8b 45 14             	mov    0x14(%ebp),%eax
   10f78:	83 c0 02             	add    $0x2,%eax
   10f7b:	0f b6 00             	movzbl (%eax),%eax
   10f7e:	3c 4e                	cmp    $0x4e,%al
   10f80:	75 41                	jne    10fc3 <lodepng_inspect+0xd2>
   10f82:	8b 45 14             	mov    0x14(%ebp),%eax
   10f85:	83 c0 03             	add    $0x3,%eax
   10f88:	0f b6 00             	movzbl (%eax),%eax
   10f8b:	3c 47                	cmp    $0x47,%al
   10f8d:	75 34                	jne    10fc3 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
   10f8f:	8b 45 14             	mov    0x14(%ebp),%eax
   10f92:	83 c0 04             	add    $0x4,%eax
   10f95:	0f b6 00             	movzbl (%eax),%eax
   10f98:	3c 0d                	cmp    $0xd,%al
   10f9a:	75 27                	jne    10fc3 <lodepng_inspect+0xd2>
   10f9c:	8b 45 14             	mov    0x14(%ebp),%eax
   10f9f:	83 c0 05             	add    $0x5,%eax
   10fa2:	0f b6 00             	movzbl (%eax),%eax
   10fa5:	3c 0a                	cmp    $0xa,%al
   10fa7:	75 1a                	jne    10fc3 <lodepng_inspect+0xd2>
   10fa9:	8b 45 14             	mov    0x14(%ebp),%eax
   10fac:	83 c0 06             	add    $0x6,%eax
   10faf:	0f b6 00             	movzbl (%eax),%eax
   10fb2:	3c 1a                	cmp    $0x1a,%al
   10fb4:	75 0d                	jne    10fc3 <lodepng_inspect+0xd2>
   10fb6:	8b 45 14             	mov    0x14(%ebp),%eax
   10fb9:	83 c0 07             	add    $0x7,%eax
   10fbc:	0f b6 00             	movzbl (%eax),%eax
   10fbf:	3c 0a                	cmp    $0xa,%al
   10fc1:	74 17                	je     10fda <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
   10fc3:	8b 45 10             	mov    0x10(%ebp),%eax
   10fc6:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
   10fcd:	00 00 00 
   10fd0:	b8 1c 00 00 00       	mov    $0x1c,%eax
   10fd5:	e9 19 02 00 00       	jmp    111f3 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
   10fda:	8b 45 14             	mov    0x14(%ebp),%eax
   10fdd:	83 c0 08             	add    $0x8,%eax
   10fe0:	83 ec 0c             	sub    $0xc,%esp
   10fe3:	50                   	push   %eax
   10fe4:	e8 c2 ae ff ff       	call   beab <lodepng_chunk_length>
   10fe9:	83 c4 10             	add    $0x10,%esp
   10fec:	83 f8 0d             	cmp    $0xd,%eax
   10fef:	74 17                	je     11008 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
   10ff1:	8b 45 10             	mov    0x10(%ebp),%eax
   10ff4:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
   10ffb:	00 00 00 
   10ffe:	b8 5e 00 00 00       	mov    $0x5e,%eax
   11003:	e9 eb 01 00 00       	jmp    111f3 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
   11008:	8b 45 14             	mov    0x14(%ebp),%eax
   1100b:	83 c0 08             	add    $0x8,%eax
   1100e:	83 ec 08             	sub    $0x8,%esp
   11011:	68 ec f3 01 00       	push   $0x1f3ec
   11016:	50                   	push   %eax
   11017:	e8 dc ae ff ff       	call   bef8 <lodepng_chunk_type_equals>
   1101c:	83 c4 10             	add    $0x10,%esp
   1101f:	84 c0                	test   %al,%al
   11021:	75 17                	jne    1103a <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
   11023:	8b 45 10             	mov    0x10(%ebp),%eax
   11026:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
   1102d:	00 00 00 
   11030:	b8 1d 00 00 00       	mov    $0x1d,%eax
   11035:	e9 b9 01 00 00       	jmp    111f3 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
   1103a:	8b 45 14             	mov    0x14(%ebp),%eax
   1103d:	83 c0 10             	add    $0x10,%eax
   11040:	83 ec 0c             	sub    $0xc,%esp
   11043:	50                   	push   %eax
   11044:	e8 5e 62 ff ff       	call   72a7 <lodepng_read32bitInt>
   11049:	83 c4 10             	add    $0x10,%esp
   1104c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
   1104f:	8b 45 14             	mov    0x14(%ebp),%eax
   11052:	83 c0 14             	add    $0x14,%eax
   11055:	83 ec 0c             	sub    $0xc,%esp
   11058:	50                   	push   %eax
   11059:	e8 49 62 ff ff       	call   72a7 <lodepng_read32bitInt>
   1105e:	83 c4 10             	add    $0x10,%esp
   11061:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
   11064:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11068:	74 08                	je     11072 <lodepng_inspect+0x181>
   1106a:	8b 45 08             	mov    0x8(%ebp),%eax
   1106d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11070:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
   11072:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11076:	74 08                	je     11080 <lodepng_inspect+0x18f>
   11078:	8b 45 0c             	mov    0xc(%ebp),%eax
   1107b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1107e:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
   11080:	8b 45 14             	mov    0x14(%ebp),%eax
   11083:	83 c0 18             	add    $0x18,%eax
   11086:	0f b6 00             	movzbl (%eax),%eax
   11089:	0f b6 d0             	movzbl %al,%edx
   1108c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1108f:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
   11092:	8b 45 14             	mov    0x14(%ebp),%eax
   11095:	83 c0 19             	add    $0x19,%eax
   11098:	0f b6 00             	movzbl (%eax),%eax
   1109b:	0f b6 d0             	movzbl %al,%edx
   1109e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110a1:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
   110a4:	8b 45 14             	mov    0x14(%ebp),%eax
   110a7:	83 c0 1a             	add    $0x1a,%eax
   110aa:	0f b6 00             	movzbl (%eax),%eax
   110ad:	0f b6 d0             	movzbl %al,%edx
   110b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110b3:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
   110b5:	8b 45 14             	mov    0x14(%ebp),%eax
   110b8:	83 c0 1b             	add    $0x1b,%eax
   110bb:	0f b6 00             	movzbl (%eax),%eax
   110be:	0f b6 d0             	movzbl %al,%edx
   110c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110c4:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
   110c7:	8b 45 14             	mov    0x14(%ebp),%eax
   110ca:	83 c0 1c             	add    $0x1c,%eax
   110cd:	0f b6 00             	movzbl (%eax),%eax
   110d0:	0f b6 d0             	movzbl %al,%edx
   110d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110d6:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
   110d9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   110dd:	74 06                	je     110e5 <lodepng_inspect+0x1f4>
   110df:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   110e3:	75 17                	jne    110fc <lodepng_inspect+0x20b>
   110e5:	8b 45 10             	mov    0x10(%ebp),%eax
   110e8:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
   110ef:	00 00 00 
   110f2:	b8 5d 00 00 00       	mov    $0x5d,%eax
   110f7:	e9 f7 00 00 00       	jmp    111f3 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
   110fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   110ff:	8b 50 10             	mov    0x10(%eax),%edx
   11102:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11105:	8b 40 0c             	mov    0xc(%eax),%eax
   11108:	83 ec 08             	sub    $0x8,%esp
   1110b:	52                   	push   %edx
   1110c:	50                   	push   %eax
   1110d:	e8 d4 b3 ff ff       	call   c4e6 <checkColorValidity>
   11112:	83 c4 10             	add    $0x10,%esp
   11115:	89 c2                	mov    %eax,%edx
   11117:	8b 45 10             	mov    0x10(%ebp),%eax
   1111a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
   11120:	8b 45 10             	mov    0x10(%ebp),%eax
   11123:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11129:	85 c0                	test   %eax,%eax
   1112b:	74 0e                	je     1113b <lodepng_inspect+0x24a>
   1112d:	8b 45 10             	mov    0x10(%ebp),%eax
   11130:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   11136:	e9 b8 00 00 00       	jmp    111f3 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
   1113b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1113e:	8b 00                	mov    (%eax),%eax
   11140:	85 c0                	test   %eax,%eax
   11142:	74 17                	je     1115b <lodepng_inspect+0x26a>
   11144:	8b 45 10             	mov    0x10(%ebp),%eax
   11147:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
   1114e:	00 00 00 
   11151:	b8 20 00 00 00       	mov    $0x20,%eax
   11156:	e9 98 00 00 00       	jmp    111f3 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
   1115b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1115e:	8b 40 04             	mov    0x4(%eax),%eax
   11161:	85 c0                	test   %eax,%eax
   11163:	74 14                	je     11179 <lodepng_inspect+0x288>
   11165:	8b 45 10             	mov    0x10(%ebp),%eax
   11168:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
   1116f:	00 00 00 
   11172:	b8 21 00 00 00       	mov    $0x21,%eax
   11177:	eb 7a                	jmp    111f3 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
   11179:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1117c:	8b 40 08             	mov    0x8(%eax),%eax
   1117f:	83 f8 01             	cmp    $0x1,%eax
   11182:	76 14                	jbe    11198 <lodepng_inspect+0x2a7>
   11184:	8b 45 10             	mov    0x10(%ebp),%eax
   11187:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
   1118e:	00 00 00 
   11191:	b8 22 00 00 00       	mov    $0x22,%eax
   11196:	eb 5b                	jmp    111f3 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
   11198:	8b 45 10             	mov    0x10(%ebp),%eax
   1119b:	8b 40 18             	mov    0x18(%eax),%eax
   1119e:	85 c0                	test   %eax,%eax
   111a0:	75 48                	jne    111ea <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
   111a2:	8b 45 14             	mov    0x14(%ebp),%eax
   111a5:	83 c0 1d             	add    $0x1d,%eax
   111a8:	83 ec 0c             	sub    $0xc,%esp
   111ab:	50                   	push   %eax
   111ac:	e8 f6 60 ff ff       	call   72a7 <lodepng_read32bitInt>
   111b1:	83 c4 10             	add    $0x10,%esp
   111b4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
   111b7:	8b 45 14             	mov    0x14(%ebp),%eax
   111ba:	83 c0 0c             	add    $0xc,%eax
   111bd:	83 ec 08             	sub    $0x8,%esp
   111c0:	6a 11                	push   $0x11
   111c2:	50                   	push   %eax
   111c3:	e8 71 ab ff ff       	call   bd39 <lodepng_crc32>
   111c8:	83 c4 10             	add    $0x10,%esp
   111cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
   111ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111d1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   111d4:	74 14                	je     111ea <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
   111d6:	8b 45 10             	mov    0x10(%ebp),%eax
   111d9:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   111e0:	00 00 00 
   111e3:	b8 39 00 00 00       	mov    $0x39,%eax
   111e8:	eb 09                	jmp    111f3 <lodepng_inspect+0x302>
    }
  }

  return state->error;
   111ea:	8b 45 10             	mov    0x10(%ebp),%eax
   111ed:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   111f3:	c9                   	leave  
   111f4:	c3                   	ret    

000111f5 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
   111f5:	55                   	push   %ebp
   111f6:	89 e5                	mov    %esp,%ebp
   111f8:	56                   	push   %esi
   111f9:	53                   	push   %ebx
   111fa:	83 ec 44             	sub    $0x44,%esp
   111fd:	8b 45 18             	mov    0x18(%ebp),%eax
   11200:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
   11203:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
   11207:	83 f8 04             	cmp    $0x4,%eax
   1120a:	0f 87 81 07 00 00    	ja     11991 <unfilterScanline+0x79c>
   11210:	8b 04 85 f4 f3 01 00 	mov    0x1f3f4(,%eax,4),%eax
   11217:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
   11219:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11220:	eb 19                	jmp    1123b <unfilterScanline+0x46>
   11222:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11225:	8b 45 08             	mov    0x8(%ebp),%eax
   11228:	01 c2                	add    %eax,%edx
   1122a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1122d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11230:	01 c8                	add    %ecx,%eax
   11232:	0f b6 00             	movzbl (%eax),%eax
   11235:	88 02                	mov    %al,(%edx)
   11237:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1123b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1123e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   11241:	75 df                	jne    11222 <unfilterScanline+0x2d>
      break;
   11243:	e9 50 07 00 00       	jmp    11998 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
   11248:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1124f:	eb 19                	jmp    1126a <unfilterScanline+0x75>
   11251:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11254:	8b 45 08             	mov    0x8(%ebp),%eax
   11257:	01 c2                	add    %eax,%edx
   11259:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1125c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1125f:	01 c8                	add    %ecx,%eax
   11261:	0f b6 00             	movzbl (%eax),%eax
   11264:	88 02                	mov    %al,(%edx)
   11266:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1126a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1126d:	3b 45 14             	cmp    0x14(%ebp),%eax
   11270:	75 df                	jne    11251 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
   11272:	8b 45 14             	mov    0x14(%ebp),%eax
   11275:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11278:	eb 2b                	jmp    112a5 <unfilterScanline+0xb0>
   1127a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1127d:	8b 45 08             	mov    0x8(%ebp),%eax
   11280:	01 c2                	add    %eax,%edx
   11282:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11285:	8b 45 0c             	mov    0xc(%ebp),%eax
   11288:	01 c8                	add    %ecx,%eax
   1128a:	0f b6 08             	movzbl (%eax),%ecx
   1128d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11290:	2b 45 14             	sub    0x14(%ebp),%eax
   11293:	89 c3                	mov    %eax,%ebx
   11295:	8b 45 08             	mov    0x8(%ebp),%eax
   11298:	01 d8                	add    %ebx,%eax
   1129a:	0f b6 00             	movzbl (%eax),%eax
   1129d:	01 c8                	add    %ecx,%eax
   1129f:	88 02                	mov    %al,(%edx)
   112a1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   112a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   112a8:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   112ab:	7c cd                	jl     1127a <unfilterScanline+0x85>
      break;
   112ad:	e9 e6 06 00 00       	jmp    11998 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
   112b2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   112b6:	74 3c                	je     112f4 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
   112b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   112bf:	eb 26                	jmp    112e7 <unfilterScanline+0xf2>
   112c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   112c4:	8b 45 08             	mov    0x8(%ebp),%eax
   112c7:	01 d0                	add    %edx,%eax
   112c9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   112cc:	8b 55 0c             	mov    0xc(%ebp),%edx
   112cf:	01 ca                	add    %ecx,%edx
   112d1:	0f b6 0a             	movzbl (%edx),%ecx
   112d4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   112d7:	8b 55 10             	mov    0x10(%ebp),%edx
   112da:	01 da                	add    %ebx,%edx
   112dc:	0f b6 12             	movzbl (%edx),%edx
   112df:	01 ca                	add    %ecx,%edx
   112e1:	88 10                	mov    %dl,(%eax)
   112e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   112e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   112ea:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   112ed:	75 d2                	jne    112c1 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
   112ef:	e9 a4 06 00 00       	jmp    11998 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
   112f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   112fb:	eb 19                	jmp    11316 <unfilterScanline+0x121>
   112fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11300:	8b 45 08             	mov    0x8(%ebp),%eax
   11303:	01 c2                	add    %eax,%edx
   11305:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11308:	8b 45 0c             	mov    0xc(%ebp),%eax
   1130b:	01 c8                	add    %ecx,%eax
   1130d:	0f b6 00             	movzbl (%eax),%eax
   11310:	88 02                	mov    %al,(%edx)
   11312:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11316:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11319:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   1131c:	75 df                	jne    112fd <unfilterScanline+0x108>
      }
      break;
   1131e:	e9 75 06 00 00       	jmp    11998 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
   11323:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11327:	0f 84 8e 00 00 00    	je     113bb <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
   1132d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11334:	eb 28                	jmp    1135e <unfilterScanline+0x169>
   11336:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11339:	8b 45 08             	mov    0x8(%ebp),%eax
   1133c:	01 d0                	add    %edx,%eax
   1133e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11341:	8b 55 0c             	mov    0xc(%ebp),%edx
   11344:	01 ca                	add    %ecx,%edx
   11346:	0f b6 12             	movzbl (%edx),%edx
   11349:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1134c:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1134f:	01 d9                	add    %ebx,%ecx
   11351:	0f b6 09             	movzbl (%ecx),%ecx
   11354:	d0 e9                	shr    %cl
   11356:	01 ca                	add    %ecx,%edx
   11358:	88 10                	mov    %dl,(%eax)
   1135a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1135e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11361:	3b 45 14             	cmp    0x14(%ebp),%eax
   11364:	75 d0                	jne    11336 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
   11366:	8b 45 14             	mov    0x14(%ebp),%eax
   11369:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1136c:	eb 40                	jmp    113ae <unfilterScanline+0x1b9>
   1136e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11371:	8b 45 08             	mov    0x8(%ebp),%eax
   11374:	01 c2                	add    %eax,%edx
   11376:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11379:	8b 45 0c             	mov    0xc(%ebp),%eax
   1137c:	01 c8                	add    %ecx,%eax
   1137e:	0f b6 08             	movzbl (%eax),%ecx
   11381:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11384:	2b 45 14             	sub    0x14(%ebp),%eax
   11387:	89 c3                	mov    %eax,%ebx
   11389:	8b 45 08             	mov    0x8(%ebp),%eax
   1138c:	01 d8                	add    %ebx,%eax
   1138e:	0f b6 00             	movzbl (%eax),%eax
   11391:	0f b6 d8             	movzbl %al,%ebx
   11394:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11397:	8b 45 10             	mov    0x10(%ebp),%eax
   1139a:	01 f0                	add    %esi,%eax
   1139c:	0f b6 00             	movzbl (%eax),%eax
   1139f:	0f b6 c0             	movzbl %al,%eax
   113a2:	01 d8                	add    %ebx,%eax
   113a4:	d1 f8                	sar    %eax
   113a6:	01 c8                	add    %ecx,%eax
   113a8:	88 02                	mov    %al,(%edx)
   113aa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   113ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113b1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   113b4:	7c b8                	jl     1136e <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
   113b6:	e9 dd 05 00 00       	jmp    11998 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
   113bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   113c2:	eb 19                	jmp    113dd <unfilterScanline+0x1e8>
   113c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   113c7:	8b 45 08             	mov    0x8(%ebp),%eax
   113ca:	01 c2                	add    %eax,%edx
   113cc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   113cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   113d2:	01 c8                	add    %ecx,%eax
   113d4:	0f b6 00             	movzbl (%eax),%eax
   113d7:	88 02                	mov    %al,(%edx)
   113d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   113dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113e0:	3b 45 14             	cmp    0x14(%ebp),%eax
   113e3:	75 df                	jne    113c4 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
   113e5:	8b 45 14             	mov    0x14(%ebp),%eax
   113e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
   113eb:	eb 2d                	jmp    1141a <unfilterScanline+0x225>
   113ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
   113f0:	8b 45 08             	mov    0x8(%ebp),%eax
   113f3:	01 c2                	add    %eax,%edx
   113f5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   113f8:	8b 45 0c             	mov    0xc(%ebp),%eax
   113fb:	01 c8                	add    %ecx,%eax
   113fd:	0f b6 08             	movzbl (%eax),%ecx
   11400:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11403:	2b 45 14             	sub    0x14(%ebp),%eax
   11406:	89 c3                	mov    %eax,%ebx
   11408:	8b 45 08             	mov    0x8(%ebp),%eax
   1140b:	01 d8                	add    %ebx,%eax
   1140d:	0f b6 00             	movzbl (%eax),%eax
   11410:	d0 e8                	shr    %al
   11412:	01 c8                	add    %ecx,%eax
   11414:	88 02                	mov    %al,(%edx)
   11416:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1141a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1141d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   11420:	7c cb                	jl     113ed <unfilterScanline+0x1f8>
      }
      break;
   11422:	e9 71 05 00 00       	jmp    11998 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
   11427:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1142b:	0f 84 f9 04 00 00    	je     1192a <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
   11431:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11438:	eb 26                	jmp    11460 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
   1143a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1143d:	8b 45 08             	mov    0x8(%ebp),%eax
   11440:	01 d0                	add    %edx,%eax
   11442:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11445:	8b 55 0c             	mov    0xc(%ebp),%edx
   11448:	01 ca                	add    %ecx,%edx
   1144a:	0f b6 0a             	movzbl (%edx),%ecx
   1144d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11450:	8b 55 10             	mov    0x10(%ebp),%edx
   11453:	01 da                	add    %ebx,%edx
   11455:	0f b6 12             	movzbl (%edx),%edx
   11458:	01 ca                	add    %ecx,%edx
   1145a:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
   1145c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11460:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11463:	3b 45 14             	cmp    0x14(%ebp),%eax
   11466:	75 d2                	jne    1143a <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
   11468:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
   1146c:	0f 8e db 01 00 00    	jle    1164d <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
   11472:	e9 c2 01 00 00       	jmp    11639 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
   11477:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1147a:	2b 45 14             	sub    0x14(%ebp),%eax
   1147d:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
   11480:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11483:	8b 45 0c             	mov    0xc(%ebp),%eax
   11486:	01 d0                	add    %edx,%eax
   11488:	0f b6 00             	movzbl (%eax),%eax
   1148b:	88 45 ef             	mov    %al,-0x11(%ebp)
   1148e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11491:	8d 50 01             	lea    0x1(%eax),%edx
   11494:	8b 45 0c             	mov    0xc(%ebp),%eax
   11497:	01 d0                	add    %edx,%eax
   11499:	0f b6 00             	movzbl (%eax),%eax
   1149c:	88 45 ee             	mov    %al,-0x12(%ebp)
   1149f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   114a2:	8d 50 02             	lea    0x2(%eax),%edx
   114a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   114a8:	01 d0                	add    %edx,%eax
   114aa:	0f b6 00             	movzbl (%eax),%eax
   114ad:	88 45 ed             	mov    %al,-0x13(%ebp)
   114b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   114b3:	8d 50 03             	lea    0x3(%eax),%edx
   114b6:	8b 45 0c             	mov    0xc(%ebp),%eax
   114b9:	01 d0                	add    %edx,%eax
   114bb:	0f b6 00             	movzbl (%eax),%eax
   114be:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
   114c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
   114c4:	8b 45 08             	mov    0x8(%ebp),%eax
   114c7:	01 d0                	add    %edx,%eax
   114c9:	0f b6 00             	movzbl (%eax),%eax
   114cc:	88 45 eb             	mov    %al,-0x15(%ebp)
   114cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114d2:	8d 50 01             	lea    0x1(%eax),%edx
   114d5:	8b 45 08             	mov    0x8(%ebp),%eax
   114d8:	01 d0                	add    %edx,%eax
   114da:	0f b6 00             	movzbl (%eax),%eax
   114dd:	88 45 ea             	mov    %al,-0x16(%ebp)
   114e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114e3:	8d 50 02             	lea    0x2(%eax),%edx
   114e6:	8b 45 08             	mov    0x8(%ebp),%eax
   114e9:	01 d0                	add    %edx,%eax
   114eb:	0f b6 00             	movzbl (%eax),%eax
   114ee:	88 45 e9             	mov    %al,-0x17(%ebp)
   114f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   114f4:	8d 50 03             	lea    0x3(%eax),%edx
   114f7:	8b 45 08             	mov    0x8(%ebp),%eax
   114fa:	01 d0                	add    %edx,%eax
   114fc:	0f b6 00             	movzbl (%eax),%eax
   114ff:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
   11502:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11505:	8b 45 10             	mov    0x10(%ebp),%eax
   11508:	01 d0                	add    %edx,%eax
   1150a:	0f b6 00             	movzbl (%eax),%eax
   1150d:	88 45 e7             	mov    %al,-0x19(%ebp)
   11510:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11513:	8d 50 01             	lea    0x1(%eax),%edx
   11516:	8b 45 10             	mov    0x10(%ebp),%eax
   11519:	01 d0                	add    %edx,%eax
   1151b:	0f b6 00             	movzbl (%eax),%eax
   1151e:	88 45 e6             	mov    %al,-0x1a(%ebp)
   11521:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11524:	8d 50 02             	lea    0x2(%eax),%edx
   11527:	8b 45 10             	mov    0x10(%ebp),%eax
   1152a:	01 d0                	add    %edx,%eax
   1152c:	0f b6 00             	movzbl (%eax),%eax
   1152f:	88 45 e5             	mov    %al,-0x1b(%ebp)
   11532:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11535:	8d 50 03             	lea    0x3(%eax),%edx
   11538:	8b 45 10             	mov    0x10(%ebp),%eax
   1153b:	01 d0                	add    %edx,%eax
   1153d:	0f b6 00             	movzbl (%eax),%eax
   11540:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
   11543:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11546:	8b 45 10             	mov    0x10(%ebp),%eax
   11549:	01 d0                	add    %edx,%eax
   1154b:	0f b6 00             	movzbl (%eax),%eax
   1154e:	88 45 e3             	mov    %al,-0x1d(%ebp)
   11551:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11554:	8d 50 01             	lea    0x1(%eax),%edx
   11557:	8b 45 10             	mov    0x10(%ebp),%eax
   1155a:	01 d0                	add    %edx,%eax
   1155c:	0f b6 00             	movzbl (%eax),%eax
   1155f:	88 45 e2             	mov    %al,-0x1e(%ebp)
   11562:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11565:	8d 50 02             	lea    0x2(%eax),%edx
   11568:	8b 45 10             	mov    0x10(%ebp),%eax
   1156b:	01 d0                	add    %edx,%eax
   1156d:	0f b6 00             	movzbl (%eax),%eax
   11570:	88 45 e1             	mov    %al,-0x1f(%ebp)
   11573:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11576:	8d 50 03             	lea    0x3(%eax),%edx
   11579:	8b 45 10             	mov    0x10(%ebp),%eax
   1157c:	01 d0                	add    %edx,%eax
   1157e:	0f b6 00             	movzbl (%eax),%eax
   11581:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
   11584:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11587:	8b 45 08             	mov    0x8(%ebp),%eax
   1158a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1158d:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
   11591:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   11595:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   11599:	51                   	push   %ecx
   1159a:	52                   	push   %edx
   1159b:	50                   	push   %eax
   1159c:	e8 3f f6 ff ff       	call   10be0 <paethPredictor>
   115a1:	83 c4 0c             	add    $0xc,%esp
   115a4:	89 c2                	mov    %eax,%edx
   115a6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   115aa:	01 d0                	add    %edx,%eax
   115ac:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
   115ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115b1:	8d 50 01             	lea    0x1(%eax),%edx
   115b4:	8b 45 08             	mov    0x8(%ebp),%eax
   115b7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   115ba:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
   115be:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   115c2:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
   115c6:	51                   	push   %ecx
   115c7:	52                   	push   %edx
   115c8:	50                   	push   %eax
   115c9:	e8 12 f6 ff ff       	call   10be0 <paethPredictor>
   115ce:	83 c4 0c             	add    $0xc,%esp
   115d1:	89 c2                	mov    %eax,%edx
   115d3:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
   115d7:	01 d0                	add    %edx,%eax
   115d9:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
   115db:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115de:	8d 50 02             	lea    0x2(%eax),%edx
   115e1:	8b 45 08             	mov    0x8(%ebp),%eax
   115e4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   115e7:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
   115eb:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   115ef:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
   115f3:	51                   	push   %ecx
   115f4:	52                   	push   %edx
   115f5:	50                   	push   %eax
   115f6:	e8 e5 f5 ff ff       	call   10be0 <paethPredictor>
   115fb:	83 c4 0c             	add    $0xc,%esp
   115fe:	89 c2                	mov    %eax,%edx
   11600:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
   11604:	01 d0                	add    %edx,%eax
   11606:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
   11608:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1160b:	8d 50 03             	lea    0x3(%eax),%edx
   1160e:	8b 45 08             	mov    0x8(%ebp),%eax
   11611:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11614:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
   11618:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   1161c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   11620:	51                   	push   %ecx
   11621:	52                   	push   %edx
   11622:	50                   	push   %eax
   11623:	e8 b8 f5 ff ff       	call   10be0 <paethPredictor>
   11628:	83 c4 0c             	add    $0xc,%esp
   1162b:	89 c2                	mov    %eax,%edx
   1162d:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   11631:	01 d0                	add    %edx,%eax
   11633:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
   11635:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   11639:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1163c:	83 c0 03             	add    $0x3,%eax
   1163f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   11642:	0f 8c 2f fe ff ff    	jl     11477 <unfilterScanline+0x282>
   11648:	e9 d3 02 00 00       	jmp    11920 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
   1164d:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
   11651:	0f 8e 6a 01 00 00    	jle    117c1 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
   11657:	e9 51 01 00 00       	jmp    117ad <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
   1165c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1165f:	2b 45 14             	sub    0x14(%ebp),%eax
   11662:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
   11665:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11668:	8b 45 0c             	mov    0xc(%ebp),%eax
   1166b:	01 d0                	add    %edx,%eax
   1166d:	0f b6 00             	movzbl (%eax),%eax
   11670:	88 45 db             	mov    %al,-0x25(%ebp)
   11673:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11676:	8d 50 01             	lea    0x1(%eax),%edx
   11679:	8b 45 0c             	mov    0xc(%ebp),%eax
   1167c:	01 d0                	add    %edx,%eax
   1167e:	0f b6 00             	movzbl (%eax),%eax
   11681:	88 45 da             	mov    %al,-0x26(%ebp)
   11684:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11687:	8d 50 02             	lea    0x2(%eax),%edx
   1168a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1168d:	01 d0                	add    %edx,%eax
   1168f:	0f b6 00             	movzbl (%eax),%eax
   11692:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
   11695:	8b 55 dc             	mov    -0x24(%ebp),%edx
   11698:	8b 45 08             	mov    0x8(%ebp),%eax
   1169b:	01 d0                	add    %edx,%eax
   1169d:	0f b6 00             	movzbl (%eax),%eax
   116a0:	88 45 d8             	mov    %al,-0x28(%ebp)
   116a3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   116a6:	8d 50 01             	lea    0x1(%eax),%edx
   116a9:	8b 45 08             	mov    0x8(%ebp),%eax
   116ac:	01 d0                	add    %edx,%eax
   116ae:	0f b6 00             	movzbl (%eax),%eax
   116b1:	88 45 d7             	mov    %al,-0x29(%ebp)
   116b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   116b7:	8d 50 02             	lea    0x2(%eax),%edx
   116ba:	8b 45 08             	mov    0x8(%ebp),%eax
   116bd:	01 d0                	add    %edx,%eax
   116bf:	0f b6 00             	movzbl (%eax),%eax
   116c2:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
   116c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116c8:	8b 45 10             	mov    0x10(%ebp),%eax
   116cb:	01 d0                	add    %edx,%eax
   116cd:	0f b6 00             	movzbl (%eax),%eax
   116d0:	88 45 d5             	mov    %al,-0x2b(%ebp)
   116d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116d6:	8d 50 01             	lea    0x1(%eax),%edx
   116d9:	8b 45 10             	mov    0x10(%ebp),%eax
   116dc:	01 d0                	add    %edx,%eax
   116de:	0f b6 00             	movzbl (%eax),%eax
   116e1:	88 45 d4             	mov    %al,-0x2c(%ebp)
   116e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116e7:	8d 50 02             	lea    0x2(%eax),%edx
   116ea:	8b 45 10             	mov    0x10(%ebp),%eax
   116ed:	01 d0                	add    %edx,%eax
   116ef:	0f b6 00             	movzbl (%eax),%eax
   116f2:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
   116f5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   116f8:	8b 45 10             	mov    0x10(%ebp),%eax
   116fb:	01 d0                	add    %edx,%eax
   116fd:	0f b6 00             	movzbl (%eax),%eax
   11700:	88 45 d2             	mov    %al,-0x2e(%ebp)
   11703:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11706:	8d 50 01             	lea    0x1(%eax),%edx
   11709:	8b 45 10             	mov    0x10(%ebp),%eax
   1170c:	01 d0                	add    %edx,%eax
   1170e:	0f b6 00             	movzbl (%eax),%eax
   11711:	88 45 d1             	mov    %al,-0x2f(%ebp)
   11714:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11717:	8d 50 02             	lea    0x2(%eax),%edx
   1171a:	8b 45 10             	mov    0x10(%ebp),%eax
   1171d:	01 d0                	add    %edx,%eax
   1171f:	0f b6 00             	movzbl (%eax),%eax
   11722:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
   11725:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11728:	8b 45 08             	mov    0x8(%ebp),%eax
   1172b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1172e:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
   11732:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
   11736:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
   1173a:	51                   	push   %ecx
   1173b:	52                   	push   %edx
   1173c:	50                   	push   %eax
   1173d:	e8 9e f4 ff ff       	call   10be0 <paethPredictor>
   11742:	83 c4 0c             	add    $0xc,%esp
   11745:	89 c2                	mov    %eax,%edx
   11747:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
   1174b:	01 d0                	add    %edx,%eax
   1174d:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
   1174f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11752:	8d 50 01             	lea    0x1(%eax),%edx
   11755:	8b 45 08             	mov    0x8(%ebp),%eax
   11758:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1175b:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
   1175f:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
   11763:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
   11767:	51                   	push   %ecx
   11768:	52                   	push   %edx
   11769:	50                   	push   %eax
   1176a:	e8 71 f4 ff ff       	call   10be0 <paethPredictor>
   1176f:	83 c4 0c             	add    $0xc,%esp
   11772:	89 c2                	mov    %eax,%edx
   11774:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
   11778:	01 d0                	add    %edx,%eax
   1177a:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
   1177c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1177f:	8d 50 02             	lea    0x2(%eax),%edx
   11782:	8b 45 08             	mov    0x8(%ebp),%eax
   11785:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11788:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
   1178c:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
   11790:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
   11794:	51                   	push   %ecx
   11795:	52                   	push   %edx
   11796:	50                   	push   %eax
   11797:	e8 44 f4 ff ff       	call   10be0 <paethPredictor>
   1179c:	83 c4 0c             	add    $0xc,%esp
   1179f:	89 c2                	mov    %eax,%edx
   117a1:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
   117a5:	01 d0                	add    %edx,%eax
   117a7:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
   117a9:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
   117ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117b0:	83 c0 02             	add    $0x2,%eax
   117b3:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   117b6:	0f 8c a0 fe ff ff    	jl     1165c <unfilterScanline+0x467>
   117bc:	e9 5f 01 00 00       	jmp    11920 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
   117c1:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
   117c5:	0f 8e 55 01 00 00    	jle    11920 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
   117cb:	e9 e0 00 00 00       	jmp    118b0 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
   117d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117d3:	2b 45 14             	sub    0x14(%ebp),%eax
   117d6:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
   117d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   117df:	01 d0                	add    %edx,%eax
   117e1:	0f b6 00             	movzbl (%eax),%eax
   117e4:	88 45 cb             	mov    %al,-0x35(%ebp)
   117e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117ea:	8d 50 01             	lea    0x1(%eax),%edx
   117ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   117f0:	01 d0                	add    %edx,%eax
   117f2:	0f b6 00             	movzbl (%eax),%eax
   117f5:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
   117f8:	8b 55 cc             	mov    -0x34(%ebp),%edx
   117fb:	8b 45 08             	mov    0x8(%ebp),%eax
   117fe:	01 d0                	add    %edx,%eax
   11800:	0f b6 00             	movzbl (%eax),%eax
   11803:	88 45 c9             	mov    %al,-0x37(%ebp)
   11806:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11809:	8d 50 01             	lea    0x1(%eax),%edx
   1180c:	8b 45 08             	mov    0x8(%ebp),%eax
   1180f:	01 d0                	add    %edx,%eax
   11811:	0f b6 00             	movzbl (%eax),%eax
   11814:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
   11817:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1181a:	8b 45 10             	mov    0x10(%ebp),%eax
   1181d:	01 d0                	add    %edx,%eax
   1181f:	0f b6 00             	movzbl (%eax),%eax
   11822:	88 45 c7             	mov    %al,-0x39(%ebp)
   11825:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11828:	8d 50 01             	lea    0x1(%eax),%edx
   1182b:	8b 45 10             	mov    0x10(%ebp),%eax
   1182e:	01 d0                	add    %edx,%eax
   11830:	0f b6 00             	movzbl (%eax),%eax
   11833:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
   11836:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11839:	8b 45 10             	mov    0x10(%ebp),%eax
   1183c:	01 d0                	add    %edx,%eax
   1183e:	0f b6 00             	movzbl (%eax),%eax
   11841:	88 45 c5             	mov    %al,-0x3b(%ebp)
   11844:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11847:	8d 50 01             	lea    0x1(%eax),%edx
   1184a:	8b 45 10             	mov    0x10(%ebp),%eax
   1184d:	01 d0                	add    %edx,%eax
   1184f:	0f b6 00             	movzbl (%eax),%eax
   11852:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
   11855:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11858:	8b 45 08             	mov    0x8(%ebp),%eax
   1185b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1185e:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
   11862:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
   11866:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
   1186a:	51                   	push   %ecx
   1186b:	52                   	push   %edx
   1186c:	50                   	push   %eax
   1186d:	e8 6e f3 ff ff       	call   10be0 <paethPredictor>
   11872:	83 c4 0c             	add    $0xc,%esp
   11875:	89 c2                	mov    %eax,%edx
   11877:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
   1187b:	01 d0                	add    %edx,%eax
   1187d:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
   1187f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11882:	8d 50 01             	lea    0x1(%eax),%edx
   11885:	8b 45 08             	mov    0x8(%ebp),%eax
   11888:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1188b:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
   1188f:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
   11893:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
   11897:	51                   	push   %ecx
   11898:	52                   	push   %edx
   11899:	50                   	push   %eax
   1189a:	e8 41 f3 ff ff       	call   10be0 <paethPredictor>
   1189f:	83 c4 0c             	add    $0xc,%esp
   118a2:	89 c2                	mov    %eax,%edx
   118a4:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
   118a8:	01 d0                	add    %edx,%eax
   118aa:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
   118ac:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
   118b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118b3:	83 c0 01             	add    $0x1,%eax
   118b6:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   118b9:	0f 8c 11 ff ff ff    	jl     117d0 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
   118bf:	eb 5f                	jmp    11920 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
   118c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118c4:	8b 45 08             	mov    0x8(%ebp),%eax
   118c7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   118ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   118d0:	01 d0                	add    %edx,%eax
   118d2:	0f b6 00             	movzbl (%eax),%eax
   118d5:	88 45 b7             	mov    %al,-0x49(%ebp)
   118d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118db:	2b 45 14             	sub    0x14(%ebp),%eax
   118de:	89 c2                	mov    %eax,%edx
   118e0:	8b 45 10             	mov    0x10(%ebp),%eax
   118e3:	01 d0                	add    %edx,%eax
   118e5:	0f b6 00             	movzbl (%eax),%eax
   118e8:	0f b6 c8             	movzbl %al,%ecx
   118eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118ee:	8b 45 10             	mov    0x10(%ebp),%eax
   118f1:	01 d0                	add    %edx,%eax
   118f3:	0f b6 00             	movzbl (%eax),%eax
   118f6:	0f b6 d0             	movzbl %al,%edx
   118f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118fc:	2b 45 14             	sub    0x14(%ebp),%eax
   118ff:	89 c6                	mov    %eax,%esi
   11901:	8b 45 08             	mov    0x8(%ebp),%eax
   11904:	01 f0                	add    %esi,%eax
   11906:	0f b6 00             	movzbl (%eax),%eax
   11909:	0f b6 c0             	movzbl %al,%eax
   1190c:	51                   	push   %ecx
   1190d:	52                   	push   %edx
   1190e:	50                   	push   %eax
   1190f:	e8 cc f2 ff ff       	call   10be0 <paethPredictor>
   11914:	83 c4 0c             	add    $0xc,%esp
   11917:	02 45 b7             	add    -0x49(%ebp),%al
   1191a:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
   1191c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11920:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11923:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   11926:	75 99                	jne    118c1 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
   11928:	eb 6e                	jmp    11998 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
   1192a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11931:	eb 19                	jmp    1194c <unfilterScanline+0x757>
          recon[i] = scanline[i];
   11933:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11936:	8b 45 08             	mov    0x8(%ebp),%eax
   11939:	01 c2                	add    %eax,%edx
   1193b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1193e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11941:	01 c8                	add    %ecx,%eax
   11943:	0f b6 00             	movzbl (%eax),%eax
   11946:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
   11948:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1194c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1194f:	3b 45 14             	cmp    0x14(%ebp),%eax
   11952:	75 df                	jne    11933 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
   11954:	8b 45 14             	mov    0x14(%ebp),%eax
   11957:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1195a:	eb 2b                	jmp    11987 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
   1195c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1195f:	8b 45 08             	mov    0x8(%ebp),%eax
   11962:	01 c2                	add    %eax,%edx
   11964:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11967:	8b 45 0c             	mov    0xc(%ebp),%eax
   1196a:	01 c8                	add    %ecx,%eax
   1196c:	0f b6 08             	movzbl (%eax),%ecx
   1196f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11972:	2b 45 14             	sub    0x14(%ebp),%eax
   11975:	89 c3                	mov    %eax,%ebx
   11977:	8b 45 08             	mov    0x8(%ebp),%eax
   1197a:	01 d8                	add    %ebx,%eax
   1197c:	0f b6 00             	movzbl (%eax),%eax
   1197f:	01 c8                	add    %ecx,%eax
   11981:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
   11983:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11987:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1198a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   1198d:	7c cd                	jl     1195c <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
   1198f:	eb 07                	jmp    11998 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
   11991:	b8 24 00 00 00       	mov    $0x24,%eax
   11996:	eb 05                	jmp    1199d <unfilterScanline+0x7a8>
  }
  return 0;
   11998:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1199d:	8d 65 f8             	lea    -0x8(%ebp),%esp
   119a0:	5b                   	pop    %ebx
   119a1:	5e                   	pop    %esi
   119a2:	5d                   	pop    %ebp
   119a3:	c3                   	ret    

000119a4 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   119a4:	55                   	push   %ebp
   119a5:	89 e5                	mov    %esp,%ebp
   119a7:	53                   	push   %ebx
   119a8:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
   119ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   119b2:	8b 45 18             	mov    0x18(%ebp),%eax
   119b5:	83 c0 07             	add    $0x7,%eax
   119b8:	c1 e8 03             	shr    $0x3,%eax
   119bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   119be:	ff 75 18             	pushl  0x18(%ebp)
   119c1:	6a 01                	push   $0x1
   119c3:	ff 75 10             	pushl  0x10(%ebp)
   119c6:	e8 d9 b1 ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   119cb:	83 c4 0c             	add    $0xc,%esp
   119ce:	83 e8 01             	sub    $0x1,%eax
   119d1:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
   119d4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   119db:	eb 6d                	jmp    11a4a <unfilter+0xa6>
    size_t outindex = linebytes * y;
   119dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119e0:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   119e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   119e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119ea:	83 c0 01             	add    $0x1,%eax
   119ed:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   119f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
   119f4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   119f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   119fa:	01 d0                	add    %edx,%eax
   119fc:	0f b6 00             	movzbl (%eax),%eax
   119ff:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
   11a02:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
   11a06:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   11a09:	8d 4a 01             	lea    0x1(%edx),%ecx
   11a0c:	8b 55 0c             	mov    0xc(%ebp),%edx
   11a0f:	01 d1                	add    %edx,%ecx
   11a11:	8b 5d e8             	mov    -0x18(%ebp),%ebx
   11a14:	8b 55 08             	mov    0x8(%ebp),%edx
   11a17:	01 da                	add    %ebx,%edx
   11a19:	ff 75 ec             	pushl  -0x14(%ebp)
   11a1c:	50                   	push   %eax
   11a1d:	ff 75 f0             	pushl  -0x10(%ebp)
   11a20:	ff 75 f4             	pushl  -0xc(%ebp)
   11a23:	51                   	push   %ecx
   11a24:	52                   	push   %edx
   11a25:	e8 cb f7 ff ff       	call   111f5 <unfilterScanline>
   11a2a:	83 c4 18             	add    $0x18,%esp
   11a2d:	89 45 dc             	mov    %eax,-0x24(%ebp)
   11a30:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   11a34:	74 05                	je     11a3b <unfilter+0x97>
   11a36:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11a39:	eb 1c                	jmp    11a57 <unfilter+0xb3>

    prevline = &out[outindex];
   11a3b:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11a3e:	8b 45 08             	mov    0x8(%ebp),%eax
   11a41:	01 d0                	add    %edx,%eax
   11a43:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
   11a46:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11a4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11a4d:	3b 45 14             	cmp    0x14(%ebp),%eax
   11a50:	72 8b                	jb     119dd <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
   11a52:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11a57:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11a5a:	c9                   	leave  
   11a5b:	c3                   	ret    

00011a5c <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   11a5c:	55                   	push   %ebp
   11a5d:	89 e5                	mov    %esp,%ebp
   11a5f:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   11a65:	ff 75 18             	pushl  0x18(%ebp)
   11a68:	ff 75 14             	pushl  0x14(%ebp)
   11a6b:	ff 75 10             	pushl  0x10(%ebp)
   11a6e:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   11a74:	50                   	push   %eax
   11a75:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   11a7b:	50                   	push   %eax
   11a7c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   11a82:	50                   	push   %eax
   11a83:	8d 45 94             	lea    -0x6c(%ebp),%eax
   11a86:	50                   	push   %eax
   11a87:	8d 45 b0             	lea    -0x50(%ebp),%eax
   11a8a:	50                   	push   %eax
   11a8b:	e8 e6 f1 ff ff       	call   10c76 <Adam7_getpassvalues>
   11a90:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   11a93:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   11a97:	0f 86 0a 01 00 00    	jbe    11ba7 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
   11a9d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   11aa4:	e9 ef 00 00 00       	jmp    11b98 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   11aa9:	8b 45 18             	mov    0x18(%ebp),%eax
   11aac:	c1 e8 03             	shr    $0x3,%eax
   11aaf:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   11ab2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11ab9:	e9 c6 00 00 00       	jmp    11b84 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   11abe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11ac5:	e9 a6 00 00 00       	jmp    11b70 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   11aca:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11acd:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   11ad4:	89 c1                	mov    %eax,%ecx
   11ad6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ad9:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   11add:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11ae1:	89 c2                	mov    %eax,%edx
   11ae3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11ae6:	01 c2                	add    %eax,%edx
   11ae8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11aeb:	0f af c2             	imul   %edx,%eax
   11aee:	01 c8                	add    %ecx,%eax
   11af0:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
   11af3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11af6:	8b 14 85 98 f3 01 00 	mov    0x1f398(,%eax,4),%edx
   11afd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b00:	8b 04 85 d0 f3 01 00 	mov    0x1f3d0(,%eax,4),%eax
   11b07:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11b0b:	01 d0                	add    %edx,%eax
   11b0d:	0f af 45 10          	imul   0x10(%ebp),%eax
   11b11:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
   11b13:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b16:	8b 04 85 b4 f3 01 00 	mov    0x1f3b4(,%eax,4),%eax
   11b1d:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   11b21:	01 c2                	add    %eax,%edx
   11b23:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b26:	8b 04 85 7c f3 01 00 	mov    0x1f37c(,%eax,4),%eax
   11b2d:	01 c2                	add    %eax,%edx
   11b2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11b32:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
   11b35:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   11b38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b3f:	eb 23                	jmp    11b64 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   11b41:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11b44:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b47:	01 c2                	add    %eax,%edx
   11b49:	8b 45 08             	mov    0x8(%ebp),%eax
   11b4c:	01 c2                	add    %eax,%edx
   11b4e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   11b51:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b54:	01 c1                	add    %eax,%ecx
   11b56:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b59:	01 c8                	add    %ecx,%eax
   11b5b:	0f b6 00             	movzbl (%eax),%eax
   11b5e:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   11b60:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b64:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11b67:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b6a:	72 d5                	jb     11b41 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   11b6c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11b70:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b73:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   11b77:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   11b7a:	0f 87 4a ff ff ff    	ja     11aca <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   11b80:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11b84:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11b87:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   11b8b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   11b8e:	0f 87 2a ff ff ff    	ja     11abe <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   11b94:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   11b98:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   11b9c:	0f 85 07 ff ff ff    	jne    11aa9 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   11ba2:	e9 22 01 00 00       	jmp    11cc9 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   11ba7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   11bae:	e9 0c 01 00 00       	jmp    11cbf <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   11bb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11bb6:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   11bba:	0f af 45 18          	imul   0x18(%ebp),%eax
   11bbe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   11bc1:	8b 45 18             	mov    0x18(%ebp),%eax
   11bc4:	0f af 45 10          	imul   0x10(%ebp),%eax
   11bc8:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   11bcb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   11bd2:	e9 d4 00 00 00       	jmp    11cab <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   11bd7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11bde:	e9 b4 00 00 00       	jmp    11c97 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   11be3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11be6:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   11bed:	c1 e0 03             	shl    $0x3,%eax
   11bf0:	89 c1                	mov    %eax,%ecx
   11bf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11bf5:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   11bf9:	89 c2                	mov    %eax,%edx
   11bfb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11bfe:	0f af 45 18          	imul   0x18(%ebp),%eax
   11c02:	01 d0                	add    %edx,%eax
   11c04:	01 c8                	add    %ecx,%eax
   11c06:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
   11c0c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c0f:	8b 14 85 98 f3 01 00 	mov    0x1f398(,%eax,4),%edx
   11c16:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c19:	8b 04 85 d0 f3 01 00 	mov    0x1f3d0(,%eax,4),%eax
   11c20:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   11c24:	01 d0                	add    %edx,%eax
   11c26:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   11c2a:	89 c2                	mov    %eax,%edx
   11c2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c2f:	8b 0c 85 7c f3 01 00 	mov    0x1f37c(,%eax,4),%ecx
   11c36:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c39:	8b 04 85 b4 f3 01 00 	mov    0x1f3b4(,%eax,4),%eax
   11c40:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c44:	01 c8                	add    %ecx,%eax
   11c46:	0f af 45 18          	imul   0x18(%ebp),%eax
   11c4a:	01 d0                	add    %edx,%eax
   11c4c:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   11c52:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   11c59:	eb 30                	jmp    11c8b <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   11c5b:	ff 75 0c             	pushl  0xc(%ebp)
   11c5e:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   11c64:	50                   	push   %eax
   11c65:	e8 1e a1 ff ff       	call   bd88 <readBitFromReversedStream>
   11c6a:	83 c4 08             	add    $0x8,%esp
   11c6d:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   11c70:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   11c74:	50                   	push   %eax
   11c75:	ff 75 08             	pushl  0x8(%ebp)
   11c78:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   11c7e:	50                   	push   %eax
   11c7f:	e8 86 a1 ff ff       	call   be0a <setBitOfReversedStream>
   11c84:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
   11c87:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   11c8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11c8e:	3b 45 18             	cmp    0x18(%ebp),%eax
   11c91:	72 c8                	jb     11c5b <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   11c93:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11c97:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11c9a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   11c9e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   11ca1:	0f 87 3c ff ff ff    	ja     11be3 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   11ca7:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   11cab:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11cae:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   11cb2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   11cb5:	0f 87 1c ff ff ff    	ja     11bd7 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   11cbb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   11cbf:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   11cc3:	0f 85 ea fe ff ff    	jne    11bb3 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   11cc9:	90                   	nop
   11cca:	c9                   	leave  
   11ccb:	c3                   	ret    

00011ccc <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
   11ccc:	55                   	push   %ebp
   11ccd:	89 e5                	mov    %esp,%ebp
   11ccf:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
   11cd2:	8b 45 14             	mov    0x14(%ebp),%eax
   11cd5:	2b 45 10             	sub    0x10(%ebp),%eax
   11cd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
   11cdb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ce2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
   11ce9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   11cf0:	eb 4a                	jmp    11d3c <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
   11cf2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   11cf9:	eb 2a                	jmp    11d25 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   11cfb:	ff 75 0c             	pushl  0xc(%ebp)
   11cfe:	8d 45 ec             	lea    -0x14(%ebp),%eax
   11d01:	50                   	push   %eax
   11d02:	e8 81 a0 ff ff       	call   bd88 <readBitFromReversedStream>
   11d07:	83 c4 08             	add    $0x8,%esp
   11d0a:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   11d0d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   11d11:	50                   	push   %eax
   11d12:	ff 75 08             	pushl  0x8(%ebp)
   11d15:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11d18:	50                   	push   %eax
   11d19:	e8 ec a0 ff ff       	call   be0a <setBitOfReversedStream>
   11d1e:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
   11d21:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   11d25:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11d28:	3b 45 10             	cmp    0x10(%ebp),%eax
   11d2b:	7c ce                	jl     11cfb <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
   11d2d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11d30:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11d33:	01 d0                	add    %edx,%eax
   11d35:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
   11d38:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   11d3c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11d3f:	3b 45 18             	cmp    0x18(%ebp),%eax
   11d42:	72 ae                	jb     11cf2 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
   11d44:	90                   	nop
   11d45:	c9                   	leave  
   11d46:	c3                   	ret    

00011d47 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
   11d47:	55                   	push   %ebp
   11d48:	89 e5                	mov    %esp,%ebp
   11d4a:	57                   	push   %edi
   11d4b:	56                   	push   %esi
   11d4c:	53                   	push   %ebx
   11d4d:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   11d53:	8b 45 18             	mov    0x18(%ebp),%eax
   11d56:	83 c0 0c             	add    $0xc,%eax
   11d59:	50                   	push   %eax
   11d5a:	e8 e6 ac ff ff       	call   ca45 <lodepng_get_bpp>
   11d5f:	83 c4 04             	add    $0x4,%esp
   11d62:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
   11d65:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11d69:	75 0a                	jne    11d75 <postProcessScanlines+0x2e>
   11d6b:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11d70:	e9 c3 01 00 00       	jmp    11f38 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
   11d75:	8b 45 18             	mov    0x18(%ebp),%eax
   11d78:	8b 40 08             	mov    0x8(%eax),%eax
   11d7b:	85 c0                	test   %eax,%eax
   11d7d:	0f 85 a8 00 00 00    	jne    11e2b <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   11d83:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
   11d87:	77 76                	ja     11dff <postProcessScanlines+0xb8>
   11d89:	8b 45 10             	mov    0x10(%ebp),%eax
   11d8c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d90:	89 c2                	mov    %eax,%edx
   11d92:	8b 45 10             	mov    0x10(%ebp),%eax
   11d95:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d99:	83 c0 07             	add    $0x7,%eax
   11d9c:	c1 e8 03             	shr    $0x3,%eax
   11d9f:	c1 e0 03             	shl    $0x3,%eax
   11da2:	39 c2                	cmp    %eax,%edx
   11da4:	74 59                	je     11dff <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
   11da6:	ff 75 ec             	pushl  -0x14(%ebp)
   11da9:	ff 75 14             	pushl  0x14(%ebp)
   11dac:	ff 75 10             	pushl  0x10(%ebp)
   11daf:	ff 75 0c             	pushl  0xc(%ebp)
   11db2:	ff 75 0c             	pushl  0xc(%ebp)
   11db5:	e8 ea fb ff ff       	call   119a4 <unfilter>
   11dba:	83 c4 14             	add    $0x14,%esp
   11dbd:	89 45 e8             	mov    %eax,-0x18(%ebp)
   11dc0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11dc4:	74 08                	je     11dce <postProcessScanlines+0x87>
   11dc6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11dc9:	e9 6a 01 00 00       	jmp    11f38 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
   11dce:	8b 45 10             	mov    0x10(%ebp),%eax
   11dd1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11dd5:	83 c0 07             	add    $0x7,%eax
   11dd8:	c1 e8 03             	shr    $0x3,%eax
   11ddb:	c1 e0 03             	shl    $0x3,%eax
   11dde:	89 c2                	mov    %eax,%edx
   11de0:	8b 45 10             	mov    0x10(%ebp),%eax
   11de3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11de7:	ff 75 14             	pushl  0x14(%ebp)
   11dea:	52                   	push   %edx
   11deb:	50                   	push   %eax
   11dec:	ff 75 0c             	pushl  0xc(%ebp)
   11def:	ff 75 08             	pushl  0x8(%ebp)
   11df2:	e8 d5 fe ff ff       	call   11ccc <removePaddingBits>
   11df7:	83 c4 14             	add    $0x14,%esp
   11dfa:	e9 34 01 00 00       	jmp    11f33 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
   11dff:	ff 75 ec             	pushl  -0x14(%ebp)
   11e02:	ff 75 14             	pushl  0x14(%ebp)
   11e05:	ff 75 10             	pushl  0x10(%ebp)
   11e08:	ff 75 0c             	pushl  0xc(%ebp)
   11e0b:	ff 75 08             	pushl  0x8(%ebp)
   11e0e:	e8 91 fb ff ff       	call   119a4 <unfilter>
   11e13:	83 c4 14             	add    $0x14,%esp
   11e16:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   11e19:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   11e1d:	0f 84 10 01 00 00    	je     11f33 <postProcessScanlines+0x1ec>
   11e23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11e26:	e9 0d 01 00 00       	jmp    11f38 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   11e2b:	ff 75 ec             	pushl  -0x14(%ebp)
   11e2e:	ff 75 14             	pushl  0x14(%ebp)
   11e31:	ff 75 10             	pushl  0x10(%ebp)
   11e34:	8d 45 88             	lea    -0x78(%ebp),%eax
   11e37:	50                   	push   %eax
   11e38:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
   11e3e:	50                   	push   %eax
   11e3f:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
   11e45:	50                   	push   %eax
   11e46:	8d 45 a8             	lea    -0x58(%ebp),%eax
   11e49:	50                   	push   %eax
   11e4a:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   11e4d:	50                   	push   %eax
   11e4e:	e8 23 ee ff ff       	call   10c76 <Adam7_getpassvalues>
   11e53:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
   11e56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11e5d:	e9 b0 00 00 00       	jmp    11f12 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
   11e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e65:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
   11e69:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e6c:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
   11e70:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11e73:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
   11e7a:	89 cb                	mov    %ecx,%ebx
   11e7c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   11e7f:	01 cb                	add    %ecx,%ebx
   11e81:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11e84:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
   11e8b:	89 ce                	mov    %ecx,%esi
   11e8d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   11e90:	01 f1                	add    %esi,%ecx
   11e92:	ff 75 ec             	pushl  -0x14(%ebp)
   11e95:	52                   	push   %edx
   11e96:	50                   	push   %eax
   11e97:	53                   	push   %ebx
   11e98:	51                   	push   %ecx
   11e99:	e8 06 fb ff ff       	call   119a4 <unfilter>
   11e9e:	83 c4 14             	add    $0x14,%esp
   11ea1:	89 45 e0             	mov    %eax,-0x20(%ebp)
   11ea4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11ea8:	74 08                	je     11eb2 <postProcessScanlines+0x16b>
   11eaa:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11ead:	e9 86 00 00 00       	jmp    11f38 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
   11eb2:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
   11eb6:	77 56                	ja     11f0e <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
   11eb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ebb:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
   11ebf:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11ec2:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
   11ec6:	0f af 55 ec          	imul   -0x14(%ebp),%edx
   11eca:	83 c2 07             	add    $0x7,%edx
   11ecd:	c1 ea 03             	shr    $0x3,%edx
   11ed0:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
   11ed3:	89 d6                	mov    %edx,%esi
   11ed5:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11ed8:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
   11edc:	0f af 55 ec          	imul   -0x14(%ebp),%edx
   11ee0:	89 d3                	mov    %edx,%ebx
   11ee2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11ee5:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
   11eec:	89 d1                	mov    %edx,%ecx
   11eee:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ef1:	01 d1                	add    %edx,%ecx
   11ef3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11ef6:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
   11efa:	89 d7                	mov    %edx,%edi
   11efc:	8b 55 0c             	mov    0xc(%ebp),%edx
   11eff:	01 fa                	add    %edi,%edx
   11f01:	50                   	push   %eax
   11f02:	56                   	push   %esi
   11f03:	53                   	push   %ebx
   11f04:	51                   	push   %ecx
   11f05:	52                   	push   %edx
   11f06:	e8 c1 fd ff ff       	call   11ccc <removePaddingBits>
   11f0b:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
   11f0e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11f12:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
   11f16:	0f 85 46 ff ff ff    	jne    11e62 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
   11f1c:	ff 75 ec             	pushl  -0x14(%ebp)
   11f1f:	ff 75 14             	pushl  0x14(%ebp)
   11f22:	ff 75 10             	pushl  0x10(%ebp)
   11f25:	ff 75 0c             	pushl  0xc(%ebp)
   11f28:	ff 75 08             	pushl  0x8(%ebp)
   11f2b:	e8 2c fb ff ff       	call   11a5c <Adam7_deinterlace>
   11f30:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
   11f33:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11f38:	8d 65 f4             	lea    -0xc(%ebp),%esp
   11f3b:	5b                   	pop    %ebx
   11f3c:	5e                   	pop    %esi
   11f3d:	5f                   	pop    %edi
   11f3e:	5d                   	pop    %ebp
   11f3f:	c3                   	ret    

00011f40 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
   11f40:	55                   	push   %ebp
   11f41:	89 e5                	mov    %esp,%ebp
   11f43:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
   11f46:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
   11f4d:	8b 45 10             	mov    0x10(%ebp),%eax
   11f50:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
   11f55:	f7 e2                	mul    %edx
   11f57:	89 d0                	mov    %edx,%eax
   11f59:	d1 e8                	shr    %eax
   11f5b:	89 c2                	mov    %eax,%edx
   11f5d:	8b 45 08             	mov    0x8(%ebp),%eax
   11f60:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
   11f63:	8b 45 08             	mov    0x8(%ebp),%eax
   11f66:	8b 40 0c             	mov    0xc(%eax),%eax
   11f69:	85 c0                	test   %eax,%eax
   11f6b:	74 0d                	je     11f7a <readChunk_PLTE+0x3a>
   11f6d:	8b 45 08             	mov    0x8(%ebp),%eax
   11f70:	8b 40 0c             	mov    0xc(%eax),%eax
   11f73:	3d 00 01 00 00       	cmp    $0x100,%eax
   11f78:	7e 0a                	jle    11f84 <readChunk_PLTE+0x44>
   11f7a:	b8 26 00 00 00       	mov    $0x26,%eax
   11f7f:	e9 da 00 00 00       	jmp    1205e <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
   11f84:	83 ec 0c             	sub    $0xc,%esp
   11f87:	ff 75 08             	pushl  0x8(%ebp)
   11f8a:	e8 02 a7 ff ff       	call   c691 <lodepng_color_mode_alloc_palette>
   11f8f:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
   11f92:	8b 45 08             	mov    0x8(%ebp),%eax
   11f95:	8b 40 08             	mov    0x8(%eax),%eax
   11f98:	85 c0                	test   %eax,%eax
   11f9a:	75 1e                	jne    11fba <readChunk_PLTE+0x7a>
   11f9c:	8b 45 08             	mov    0x8(%ebp),%eax
   11f9f:	8b 40 0c             	mov    0xc(%eax),%eax
   11fa2:	85 c0                	test   %eax,%eax
   11fa4:	74 14                	je     11fba <readChunk_PLTE+0x7a>
    color->palettesize = 0;
   11fa6:	8b 45 08             	mov    0x8(%ebp),%eax
   11fa9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
   11fb0:	b8 53 00 00 00       	mov    $0x53,%eax
   11fb5:	e9 a4 00 00 00       	jmp    1205e <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
   11fba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11fc1:	e9 84 00 00 00       	jmp    1204a <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
   11fc6:	8b 45 08             	mov    0x8(%ebp),%eax
   11fc9:	8b 40 08             	mov    0x8(%eax),%eax
   11fcc:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11fcf:	c1 e2 02             	shl    $0x2,%edx
   11fd2:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   11fd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fd8:	8d 50 01             	lea    0x1(%eax),%edx
   11fdb:	89 55 f4             	mov    %edx,-0xc(%ebp)
   11fde:	8b 55 0c             	mov    0xc(%ebp),%edx
   11fe1:	01 d0                	add    %edx,%eax
   11fe3:	0f b6 00             	movzbl (%eax),%eax
   11fe6:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
   11fe8:	8b 45 08             	mov    0x8(%ebp),%eax
   11feb:	8b 40 08             	mov    0x8(%eax),%eax
   11fee:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11ff1:	c1 e2 02             	shl    $0x2,%edx
   11ff4:	83 c2 01             	add    $0x1,%edx
   11ff7:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   11ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ffd:	8d 50 01             	lea    0x1(%eax),%edx
   12000:	89 55 f4             	mov    %edx,-0xc(%ebp)
   12003:	8b 55 0c             	mov    0xc(%ebp),%edx
   12006:	01 d0                	add    %edx,%eax
   12008:	0f b6 00             	movzbl (%eax),%eax
   1200b:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
   1200d:	8b 45 08             	mov    0x8(%ebp),%eax
   12010:	8b 40 08             	mov    0x8(%eax),%eax
   12013:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12016:	c1 e2 02             	shl    $0x2,%edx
   12019:	83 c2 02             	add    $0x2,%edx
   1201c:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   1201f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12022:	8d 50 01             	lea    0x1(%eax),%edx
   12025:	89 55 f4             	mov    %edx,-0xc(%ebp)
   12028:	8b 55 0c             	mov    0xc(%ebp),%edx
   1202b:	01 d0                	add    %edx,%eax
   1202d:	0f b6 00             	movzbl (%eax),%eax
   12030:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
   12032:	8b 45 08             	mov    0x8(%ebp),%eax
   12035:	8b 40 08             	mov    0x8(%eax),%eax
   12038:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1203b:	c1 e2 02             	shl    $0x2,%edx
   1203e:	83 c2 03             	add    $0x3,%edx
   12041:	01 d0                	add    %edx,%eax
   12043:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
   12046:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1204a:	8b 45 08             	mov    0x8(%ebp),%eax
   1204d:	8b 40 0c             	mov    0xc(%eax),%eax
   12050:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   12053:	0f 85 6d ff ff ff    	jne    11fc6 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
   12059:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1205e:	c9                   	leave  
   1205f:	c3                   	ret    

00012060 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
   12060:	55                   	push   %ebp
   12061:	89 e5                	mov    %esp,%ebp
   12063:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
   12066:	8b 45 08             	mov    0x8(%ebp),%eax
   12069:	8b 00                	mov    (%eax),%eax
   1206b:	83 f8 03             	cmp    $0x3,%eax
   1206e:	75 4d                	jne    120bd <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
   12070:	8b 45 08             	mov    0x8(%ebp),%eax
   12073:	8b 40 0c             	mov    0xc(%eax),%eax
   12076:	3b 45 10             	cmp    0x10(%ebp),%eax
   12079:	7d 0a                	jge    12085 <readChunk_tRNS+0x25>
   1207b:	b8 27 00 00 00       	mov    $0x27,%eax
   12080:	e9 3c 01 00 00       	jmp    121c1 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
   12085:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1208c:	eb 22                	jmp    120b0 <readChunk_tRNS+0x50>
   1208e:	8b 45 08             	mov    0x8(%ebp),%eax
   12091:	8b 40 08             	mov    0x8(%eax),%eax
   12094:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12097:	c1 e2 02             	shl    $0x2,%edx
   1209a:	83 c2 03             	add    $0x3,%edx
   1209d:	01 c2                	add    %eax,%edx
   1209f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   120a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   120a5:	01 c8                	add    %ecx,%eax
   120a7:	0f b6 00             	movzbl (%eax),%eax
   120aa:	88 02                	mov    %al,(%edx)
   120ac:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   120b0:	8b 45 10             	mov    0x10(%ebp),%eax
   120b3:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   120b6:	75 d6                	jne    1208e <readChunk_tRNS+0x2e>
   120b8:	e9 ff 00 00 00       	jmp    121bc <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
   120bd:	8b 45 08             	mov    0x8(%ebp),%eax
   120c0:	8b 00                	mov    (%eax),%eax
   120c2:	85 c0                	test   %eax,%eax
   120c4:	75 59                	jne    1211f <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
   120c6:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   120ca:	74 0a                	je     120d6 <readChunk_tRNS+0x76>
   120cc:	b8 1e 00 00 00       	mov    $0x1e,%eax
   120d1:	e9 eb 00 00 00       	jmp    121c1 <readChunk_tRNS+0x161>

    color->key_defined = 1;
   120d6:	8b 45 08             	mov    0x8(%ebp),%eax
   120d9:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
   120e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   120e3:	0f b6 00             	movzbl (%eax),%eax
   120e6:	0f b6 c0             	movzbl %al,%eax
   120e9:	c1 e0 08             	shl    $0x8,%eax
   120ec:	89 c2                	mov    %eax,%edx
   120ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   120f1:	83 c0 01             	add    $0x1,%eax
   120f4:	0f b6 00             	movzbl (%eax),%eax
   120f7:	0f b6 c0             	movzbl %al,%eax
   120fa:	01 c2                	add    %eax,%edx
   120fc:	8b 45 08             	mov    0x8(%ebp),%eax
   120ff:	89 50 1c             	mov    %edx,0x1c(%eax)
   12102:	8b 45 08             	mov    0x8(%ebp),%eax
   12105:	8b 50 1c             	mov    0x1c(%eax),%edx
   12108:	8b 45 08             	mov    0x8(%ebp),%eax
   1210b:	89 50 18             	mov    %edx,0x18(%eax)
   1210e:	8b 45 08             	mov    0x8(%ebp),%eax
   12111:	8b 50 18             	mov    0x18(%eax),%edx
   12114:	8b 45 08             	mov    0x8(%ebp),%eax
   12117:	89 50 14             	mov    %edx,0x14(%eax)
   1211a:	e9 9d 00 00 00       	jmp    121bc <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
   1211f:	8b 45 08             	mov    0x8(%ebp),%eax
   12122:	8b 00                	mov    (%eax),%eax
   12124:	83 f8 02             	cmp    $0x2,%eax
   12127:	0f 85 88 00 00 00    	jne    121b5 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
   1212d:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
   12131:	74 0a                	je     1213d <readChunk_tRNS+0xdd>
   12133:	b8 29 00 00 00       	mov    $0x29,%eax
   12138:	e9 84 00 00 00       	jmp    121c1 <readChunk_tRNS+0x161>

    color->key_defined = 1;
   1213d:	8b 45 08             	mov    0x8(%ebp),%eax
   12140:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
   12147:	8b 45 0c             	mov    0xc(%ebp),%eax
   1214a:	0f b6 00             	movzbl (%eax),%eax
   1214d:	0f b6 c0             	movzbl %al,%eax
   12150:	c1 e0 08             	shl    $0x8,%eax
   12153:	89 c2                	mov    %eax,%edx
   12155:	8b 45 0c             	mov    0xc(%ebp),%eax
   12158:	83 c0 01             	add    $0x1,%eax
   1215b:	0f b6 00             	movzbl (%eax),%eax
   1215e:	0f b6 c0             	movzbl %al,%eax
   12161:	01 c2                	add    %eax,%edx
   12163:	8b 45 08             	mov    0x8(%ebp),%eax
   12166:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
   12169:	8b 45 0c             	mov    0xc(%ebp),%eax
   1216c:	83 c0 02             	add    $0x2,%eax
   1216f:	0f b6 00             	movzbl (%eax),%eax
   12172:	0f b6 c0             	movzbl %al,%eax
   12175:	c1 e0 08             	shl    $0x8,%eax
   12178:	89 c2                	mov    %eax,%edx
   1217a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1217d:	83 c0 03             	add    $0x3,%eax
   12180:	0f b6 00             	movzbl (%eax),%eax
   12183:	0f b6 c0             	movzbl %al,%eax
   12186:	01 c2                	add    %eax,%edx
   12188:	8b 45 08             	mov    0x8(%ebp),%eax
   1218b:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
   1218e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12191:	83 c0 04             	add    $0x4,%eax
   12194:	0f b6 00             	movzbl (%eax),%eax
   12197:	0f b6 c0             	movzbl %al,%eax
   1219a:	c1 e0 08             	shl    $0x8,%eax
   1219d:	89 c2                	mov    %eax,%edx
   1219f:	8b 45 0c             	mov    0xc(%ebp),%eax
   121a2:	83 c0 05             	add    $0x5,%eax
   121a5:	0f b6 00             	movzbl (%eax),%eax
   121a8:	0f b6 c0             	movzbl %al,%eax
   121ab:	01 c2                	add    %eax,%edx
   121ad:	8b 45 08             	mov    0x8(%ebp),%eax
   121b0:	89 50 1c             	mov    %edx,0x1c(%eax)
   121b3:	eb 07                	jmp    121bc <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
   121b5:	b8 2a 00 00 00       	mov    $0x2a,%eax
   121ba:	eb 05                	jmp    121c1 <readChunk_tRNS+0x161>

  return 0; /* OK */
   121bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
   121c1:	c9                   	leave  
   121c2:	c3                   	ret    

000121c3 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   121c3:	55                   	push   %ebp
   121c4:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
   121c6:	8b 45 08             	mov    0x8(%ebp),%eax
   121c9:	8b 40 0c             	mov    0xc(%eax),%eax
   121cc:	83 f8 03             	cmp    $0x3,%eax
   121cf:	75 63                	jne    12234 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
   121d1:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
   121d5:	74 0a                	je     121e1 <readChunk_bKGD+0x1e>
   121d7:	b8 2b 00 00 00       	mov    $0x2b,%eax
   121dc:	e9 63 01 00 00       	jmp    12344 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
   121e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   121e4:	0f b6 00             	movzbl (%eax),%eax
   121e7:	0f b6 d0             	movzbl %al,%edx
   121ea:	8b 45 08             	mov    0x8(%ebp),%eax
   121ed:	8b 40 18             	mov    0x18(%eax),%eax
   121f0:	39 c2                	cmp    %eax,%edx
   121f2:	7c 0a                	jl     121fe <readChunk_bKGD+0x3b>
   121f4:	b8 67 00 00 00       	mov    $0x67,%eax
   121f9:	e9 46 01 00 00       	jmp    12344 <readChunk_bKGD+0x181>

    info->background_defined = 1;
   121fe:	8b 45 08             	mov    0x8(%ebp),%eax
   12201:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
   12208:	8b 45 0c             	mov    0xc(%ebp),%eax
   1220b:	0f b6 00             	movzbl (%eax),%eax
   1220e:	0f b6 d0             	movzbl %al,%edx
   12211:	8b 45 08             	mov    0x8(%ebp),%eax
   12214:	89 50 38             	mov    %edx,0x38(%eax)
   12217:	8b 45 08             	mov    0x8(%ebp),%eax
   1221a:	8b 50 38             	mov    0x38(%eax),%edx
   1221d:	8b 45 08             	mov    0x8(%ebp),%eax
   12220:	89 50 34             	mov    %edx,0x34(%eax)
   12223:	8b 45 08             	mov    0x8(%ebp),%eax
   12226:	8b 50 34             	mov    0x34(%eax),%edx
   12229:	8b 45 08             	mov    0x8(%ebp),%eax
   1222c:	89 50 30             	mov    %edx,0x30(%eax)
   1222f:	e9 0b 01 00 00       	jmp    1233f <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   12234:	8b 45 08             	mov    0x8(%ebp),%eax
   12237:	8b 40 0c             	mov    0xc(%eax),%eax
   1223a:	85 c0                	test   %eax,%eax
   1223c:	74 0b                	je     12249 <readChunk_bKGD+0x86>
   1223e:	8b 45 08             	mov    0x8(%ebp),%eax
   12241:	8b 40 0c             	mov    0xc(%eax),%eax
   12244:	83 f8 04             	cmp    $0x4,%eax
   12247:	75 59                	jne    122a2 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
   12249:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   1224d:	74 0a                	je     12259 <readChunk_bKGD+0x96>
   1224f:	b8 2c 00 00 00       	mov    $0x2c,%eax
   12254:	e9 eb 00 00 00       	jmp    12344 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
   12259:	8b 45 08             	mov    0x8(%ebp),%eax
   1225c:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
   12263:	8b 45 0c             	mov    0xc(%ebp),%eax
   12266:	0f b6 00             	movzbl (%eax),%eax
   12269:	0f b6 c0             	movzbl %al,%eax
   1226c:	c1 e0 08             	shl    $0x8,%eax
   1226f:	89 c2                	mov    %eax,%edx
   12271:	8b 45 0c             	mov    0xc(%ebp),%eax
   12274:	83 c0 01             	add    $0x1,%eax
   12277:	0f b6 00             	movzbl (%eax),%eax
   1227a:	0f b6 c0             	movzbl %al,%eax
   1227d:	01 c2                	add    %eax,%edx
   1227f:	8b 45 08             	mov    0x8(%ebp),%eax
   12282:	89 50 38             	mov    %edx,0x38(%eax)
   12285:	8b 45 08             	mov    0x8(%ebp),%eax
   12288:	8b 50 38             	mov    0x38(%eax),%edx
   1228b:	8b 45 08             	mov    0x8(%ebp),%eax
   1228e:	89 50 34             	mov    %edx,0x34(%eax)
   12291:	8b 45 08             	mov    0x8(%ebp),%eax
   12294:	8b 50 34             	mov    0x34(%eax),%edx
   12297:	8b 45 08             	mov    0x8(%ebp),%eax
   1229a:	89 50 30             	mov    %edx,0x30(%eax)
   1229d:	e9 9d 00 00 00       	jmp    1233f <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   122a2:	8b 45 08             	mov    0x8(%ebp),%eax
   122a5:	8b 40 0c             	mov    0xc(%eax),%eax
   122a8:	83 f8 02             	cmp    $0x2,%eax
   122ab:	74 0f                	je     122bc <readChunk_bKGD+0xf9>
   122ad:	8b 45 08             	mov    0x8(%ebp),%eax
   122b0:	8b 40 0c             	mov    0xc(%eax),%eax
   122b3:	83 f8 06             	cmp    $0x6,%eax
   122b6:	0f 85 83 00 00 00    	jne    1233f <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
   122bc:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
   122c0:	74 07                	je     122c9 <readChunk_bKGD+0x106>
   122c2:	b8 2d 00 00 00       	mov    $0x2d,%eax
   122c7:	eb 7b                	jmp    12344 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
   122c9:	8b 45 08             	mov    0x8(%ebp),%eax
   122cc:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
   122d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   122d6:	0f b6 00             	movzbl (%eax),%eax
   122d9:	0f b6 c0             	movzbl %al,%eax
   122dc:	c1 e0 08             	shl    $0x8,%eax
   122df:	89 c2                	mov    %eax,%edx
   122e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   122e4:	83 c0 01             	add    $0x1,%eax
   122e7:	0f b6 00             	movzbl (%eax),%eax
   122ea:	0f b6 c0             	movzbl %al,%eax
   122ed:	01 c2                	add    %eax,%edx
   122ef:	8b 45 08             	mov    0x8(%ebp),%eax
   122f2:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
   122f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   122f8:	83 c0 02             	add    $0x2,%eax
   122fb:	0f b6 00             	movzbl (%eax),%eax
   122fe:	0f b6 c0             	movzbl %al,%eax
   12301:	c1 e0 08             	shl    $0x8,%eax
   12304:	89 c2                	mov    %eax,%edx
   12306:	8b 45 0c             	mov    0xc(%ebp),%eax
   12309:	83 c0 03             	add    $0x3,%eax
   1230c:	0f b6 00             	movzbl (%eax),%eax
   1230f:	0f b6 c0             	movzbl %al,%eax
   12312:	01 c2                	add    %eax,%edx
   12314:	8b 45 08             	mov    0x8(%ebp),%eax
   12317:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
   1231a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1231d:	83 c0 04             	add    $0x4,%eax
   12320:	0f b6 00             	movzbl (%eax),%eax
   12323:	0f b6 c0             	movzbl %al,%eax
   12326:	c1 e0 08             	shl    $0x8,%eax
   12329:	89 c2                	mov    %eax,%edx
   1232b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1232e:	83 c0 05             	add    $0x5,%eax
   12331:	0f b6 00             	movzbl (%eax),%eax
   12334:	0f b6 c0             	movzbl %al,%eax
   12337:	01 c2                	add    %eax,%edx
   12339:	8b 45 08             	mov    0x8(%ebp),%eax
   1233c:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
   1233f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12344:	5d                   	pop    %ebp
   12345:	c3                   	ret    

00012346 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   12346:	55                   	push   %ebp
   12347:	89 e5                	mov    %esp,%ebp
   12349:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
   1234c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
   12353:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1235a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
   12361:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12365:	0f 85 06 01 00 00    	jne    12471 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
   1236b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
   12372:	eb 04                	jmp    12378 <readChunk_tEXt+0x32>
   12374:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12378:	8b 45 10             	mov    0x10(%ebp),%eax
   1237b:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   1237e:	73 0f                	jae    1238f <readChunk_tEXt+0x49>
   12380:	8b 55 0c             	mov    0xc(%ebp),%edx
   12383:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12386:	01 d0                	add    %edx,%eax
   12388:	0f b6 00             	movzbl (%eax),%eax
   1238b:	84 c0                	test   %al,%al
   1238d:	75 e5                	jne    12374 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
   1238f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12393:	74 06                	je     1239b <readChunk_tEXt+0x55>
   12395:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
   12399:	76 0c                	jbe    123a7 <readChunk_tEXt+0x61>
   1239b:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
   123a2:	e9 ca 00 00 00       	jmp    12471 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
   123a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123aa:	83 c0 01             	add    $0x1,%eax
   123ad:	83 ec 0c             	sub    $0xc,%esp
   123b0:	50                   	push   %eax
   123b1:	e8 73 4b ff ff       	call   6f29 <lodepng_malloc>
   123b6:	83 c4 10             	add    $0x10,%esp
   123b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
   123bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   123c0:	75 0c                	jne    123ce <readChunk_tEXt+0x88>
   123c2:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   123c9:	e9 a3 00 00 00       	jmp    12471 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
   123ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123d1:	83 ec 04             	sub    $0x4,%esp
   123d4:	50                   	push   %eax
   123d5:	ff 75 0c             	pushl  0xc(%ebp)
   123d8:	ff 75 f0             	pushl  -0x10(%ebp)
   123db:	e8 87 4b ff ff       	call   6f67 <lodepng_memcpy>
   123e0:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
   123e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   123e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123e9:	01 d0                	add    %edx,%eax
   123eb:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
   123ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123f1:	83 c0 01             	add    $0x1,%eax
   123f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
   123f7:	8b 45 10             	mov    0x10(%ebp),%eax
   123fa:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   123fd:	72 08                	jb     12407 <readChunk_tEXt+0xc1>
   123ff:	8b 45 10             	mov    0x10(%ebp),%eax
   12402:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   12405:	eb 05                	jmp    1240c <readChunk_tEXt+0xc6>
   12407:	b8 00 00 00 00       	mov    $0x0,%eax
   1240c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
   1240f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12412:	83 c0 01             	add    $0x1,%eax
   12415:	83 ec 0c             	sub    $0xc,%esp
   12418:	50                   	push   %eax
   12419:	e8 0b 4b ff ff       	call   6f29 <lodepng_malloc>
   1241e:	83 c4 10             	add    $0x10,%esp
   12421:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
   12424:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12428:	75 09                	jne    12433 <readChunk_tEXt+0xed>
   1242a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   12431:	eb 3e                	jmp    12471 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
   12433:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12436:	8b 4d 0c             	mov    0xc(%ebp),%ecx
   12439:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1243c:	01 ca                	add    %ecx,%edx
   1243e:	83 ec 04             	sub    $0x4,%esp
   12441:	50                   	push   %eax
   12442:	52                   	push   %edx
   12443:	ff 75 ec             	pushl  -0x14(%ebp)
   12446:	e8 1c 4b ff ff       	call   6f67 <lodepng_memcpy>
   1244b:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
   1244e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12451:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12454:	01 d0                	add    %edx,%eax
   12456:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
   12459:	83 ec 04             	sub    $0x4,%esp
   1245c:	ff 75 ec             	pushl  -0x14(%ebp)
   1245f:	ff 75 f0             	pushl  -0x10(%ebp)
   12462:	ff 75 08             	pushl  0x8(%ebp)
   12465:	e8 3f ac ff ff       	call   d0a9 <lodepng_add_text>
   1246a:	83 c4 10             	add    $0x10,%esp
   1246d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
   12470:	90                   	nop
  }

  lodepng_free(key);
   12471:	83 ec 0c             	sub    $0xc,%esp
   12474:	ff 75 f0             	pushl  -0x10(%ebp)
   12477:	e8 ce 4a ff ff       	call   6f4a <lodepng_free>
   1247c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
   1247f:	83 ec 0c             	sub    $0xc,%esp
   12482:	ff 75 ec             	pushl  -0x14(%ebp)
   12485:	e8 c0 4a ff ff       	call   6f4a <lodepng_free>
   1248a:	83 c4 10             	add    $0x10,%esp

  return error;
   1248d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   12490:	c9                   	leave  
   12491:	c3                   	ret    

00012492 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   12492:	55                   	push   %ebp
   12493:	89 e5                	mov    %esp,%ebp
   12495:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
   12498:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   1249f:	8b 45 0c             	mov    0xc(%ebp),%eax
   124a2:	8b 10                	mov    (%eax),%edx
   124a4:	89 55 d0             	mov    %edx,-0x30(%ebp)
   124a7:	8b 50 04             	mov    0x4(%eax),%edx
   124aa:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   124ad:	8b 50 08             	mov    0x8(%eax),%edx
   124b0:	89 55 d8             	mov    %edx,-0x28(%ebp)
   124b3:	8b 50 0c             	mov    0xc(%eax),%edx
   124b6:	89 55 dc             	mov    %edx,-0x24(%ebp)
   124b9:	8b 50 10             	mov    0x10(%eax),%edx
   124bc:	89 55 e0             	mov    %edx,-0x20(%ebp)
   124bf:	8b 40 14             	mov    0x14(%eax),%eax
   124c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
   124c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
   124cc:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
   124d3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
   124da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   124de:	0f 85 48 01 00 00    	jne    1262c <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   124e4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   124eb:	eb 04                	jmp    124f1 <readChunk_zTXt+0x5f>
   124ed:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   124f1:	8b 45 14             	mov    0x14(%ebp),%eax
   124f4:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   124f7:	73 0f                	jae    12508 <readChunk_zTXt+0x76>
   124f9:	8b 55 10             	mov    0x10(%ebp),%edx
   124fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124ff:	01 d0                	add    %edx,%eax
   12501:	0f b6 00             	movzbl (%eax),%eax
   12504:	84 c0                	test   %al,%al
   12506:	75 e5                	jne    124ed <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
   12508:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1250b:	8d 50 02             	lea    0x2(%eax),%edx
   1250e:	8b 45 14             	mov    0x14(%ebp),%eax
   12511:	39 c2                	cmp    %eax,%edx
   12513:	72 0c                	jb     12521 <readChunk_zTXt+0x8f>
   12515:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   1251c:	e9 0b 01 00 00       	jmp    1262c <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
   12521:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12525:	74 06                	je     1252d <readChunk_zTXt+0x9b>
   12527:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   1252b:	76 0c                	jbe    12539 <readChunk_zTXt+0xa7>
   1252d:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
   12534:	e9 f3 00 00 00       	jmp    1262c <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
   12539:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1253c:	83 c0 01             	add    $0x1,%eax
   1253f:	83 ec 0c             	sub    $0xc,%esp
   12542:	50                   	push   %eax
   12543:	e8 e1 49 ff ff       	call   6f29 <lodepng_malloc>
   12548:	83 c4 10             	add    $0x10,%esp
   1254b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
   1254e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12552:	75 0c                	jne    12560 <readChunk_zTXt+0xce>
   12554:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   1255b:	e9 cc 00 00 00       	jmp    1262c <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
   12560:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12563:	83 ec 04             	sub    $0x4,%esp
   12566:	50                   	push   %eax
   12567:	ff 75 10             	pushl  0x10(%ebp)
   1256a:	ff 75 ec             	pushl  -0x14(%ebp)
   1256d:	e8 f5 49 ff ff       	call   6f67 <lodepng_memcpy>
   12572:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
   12575:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12578:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1257b:	01 d0                	add    %edx,%eax
   1257d:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
   12580:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12583:	8d 50 01             	lea    0x1(%eax),%edx
   12586:	8b 45 10             	mov    0x10(%ebp),%eax
   12589:	01 d0                	add    %edx,%eax
   1258b:	0f b6 00             	movzbl (%eax),%eax
   1258e:	84 c0                	test   %al,%al
   12590:	74 0c                	je     1259e <readChunk_zTXt+0x10c>
   12592:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
   12599:	e9 8e 00 00 00       	jmp    1262c <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
   1259e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   125a1:	83 c0 02             	add    $0x2,%eax
   125a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
   125a7:	8b 45 14             	mov    0x14(%ebp),%eax
   125aa:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   125ad:	76 09                	jbe    125b8 <readChunk_zTXt+0x126>
   125af:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   125b6:	eb 74                	jmp    1262c <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
   125b8:	8b 45 14             	mov    0x14(%ebp),%eax
   125bb:	2b 45 e8             	sub    -0x18(%ebp),%eax
   125be:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
   125c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   125c4:	8b 40 30             	mov    0x30(%eax),%eax
   125c7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
   125ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   125cd:	8b 4d 10             	mov    0x10(%ebp),%ecx
   125d0:	8b 55 e8             	mov    -0x18(%ebp),%edx
   125d3:	01 d1                	add    %edx,%ecx
   125d5:	83 ec 08             	sub    $0x8,%esp
   125d8:	8d 55 d0             	lea    -0x30(%ebp),%edx
   125db:	52                   	push   %edx
   125dc:	50                   	push   %eax
   125dd:	51                   	push   %ecx
   125de:	6a 00                	push   $0x0
   125e0:	8d 45 c8             	lea    -0x38(%ebp),%eax
   125e3:	50                   	push   %eax
   125e4:	8d 45 cc             	lea    -0x34(%ebp),%eax
   125e7:	50                   	push   %eax
   125e8:	e8 f7 93 ff ff       	call   b9e4 <zlib_decompress>
   125ed:	83 c4 20             	add    $0x20,%esp
   125f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
   125f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   125f7:	74 11                	je     1260a <readChunk_zTXt+0x178>
   125f9:	8b 55 d8             	mov    -0x28(%ebp),%edx
   125fc:	8b 45 c8             	mov    -0x38(%ebp),%eax
   125ff:	39 c2                	cmp    %eax,%edx
   12601:	7d 07                	jge    1260a <readChunk_zTXt+0x178>
   12603:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
   1260a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1260e:	75 1b                	jne    1262b <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
   12610:	8b 55 c8             	mov    -0x38(%ebp),%edx
   12613:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12616:	52                   	push   %edx
   12617:	50                   	push   %eax
   12618:	ff 75 ec             	pushl  -0x14(%ebp)
   1261b:	ff 75 08             	pushl  0x8(%ebp)
   1261e:	e8 60 a9 ff ff       	call   cf83 <lodepng_add_text_sized>
   12623:	83 c4 10             	add    $0x10,%esp
   12626:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
   12629:	eb 01                	jmp    1262c <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
   1262b:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
   1262c:	83 ec 0c             	sub    $0xc,%esp
   1262f:	ff 75 ec             	pushl  -0x14(%ebp)
   12632:	e8 13 49 ff ff       	call   6f4a <lodepng_free>
   12637:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
   1263a:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1263d:	83 ec 0c             	sub    $0xc,%esp
   12640:	50                   	push   %eax
   12641:	e8 04 49 ff ff       	call   6f4a <lodepng_free>
   12646:	83 c4 10             	add    $0x10,%esp

  return error;
   12649:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1264c:	c9                   	leave  
   1264d:	c3                   	ret    

0001264e <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   1264e:	55                   	push   %ebp
   1264f:	89 e5                	mov    %esp,%ebp
   12651:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
   12654:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   1265b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1265e:	8b 10                	mov    (%eax),%edx
   12660:	89 55 c0             	mov    %edx,-0x40(%ebp)
   12663:	8b 50 04             	mov    0x4(%eax),%edx
   12666:	89 55 c4             	mov    %edx,-0x3c(%ebp)
   12669:	8b 50 08             	mov    0x8(%eax),%edx
   1266c:	89 55 c8             	mov    %edx,-0x38(%ebp)
   1266f:	8b 50 0c             	mov    0xc(%eax),%edx
   12672:	89 55 cc             	mov    %edx,-0x34(%ebp)
   12675:	8b 50 10             	mov    0x10(%eax),%edx
   12678:	89 55 d0             	mov    %edx,-0x30(%ebp)
   1267b:	8b 40 14             	mov    0x14(%eax),%eax
   1267e:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
   12681:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12688:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1268f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
   12696:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1269a:	0f 85 d5 02 00 00    	jne    12975 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
   126a0:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
   126a4:	7f 0c                	jg     126b2 <readChunk_iTXt+0x64>
   126a6:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
   126ad:	e9 c3 02 00 00       	jmp    12975 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   126b2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   126b9:	eb 04                	jmp    126bf <readChunk_iTXt+0x71>
   126bb:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   126bf:	8b 45 14             	mov    0x14(%ebp),%eax
   126c2:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   126c5:	73 0f                	jae    126d6 <readChunk_iTXt+0x88>
   126c7:	8b 55 10             	mov    0x10(%ebp),%edx
   126ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
   126cd:	01 d0                	add    %edx,%eax
   126cf:	0f b6 00             	movzbl (%eax),%eax
   126d2:	84 c0                	test   %al,%al
   126d4:	75 e5                	jne    126bb <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
   126d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   126d9:	8d 50 03             	lea    0x3(%eax),%edx
   126dc:	8b 45 14             	mov    0x14(%ebp),%eax
   126df:	39 c2                	cmp    %eax,%edx
   126e1:	72 0c                	jb     126ef <readChunk_iTXt+0xa1>
   126e3:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
   126ea:	e9 86 02 00 00       	jmp    12975 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
   126ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   126f3:	74 06                	je     126fb <readChunk_iTXt+0xad>
   126f5:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   126f9:	76 0c                	jbe    12707 <readChunk_iTXt+0xb9>
   126fb:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
   12702:	e9 6e 02 00 00       	jmp    12975 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
   12707:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1270a:	83 c0 01             	add    $0x1,%eax
   1270d:	83 ec 0c             	sub    $0xc,%esp
   12710:	50                   	push   %eax
   12711:	e8 13 48 ff ff       	call   6f29 <lodepng_malloc>
   12716:	83 c4 10             	add    $0x10,%esp
   12719:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
   1271c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12720:	75 0c                	jne    1272e <readChunk_iTXt+0xe0>
   12722:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   12729:	e9 47 02 00 00       	jmp    12975 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
   1272e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12731:	83 ec 04             	sub    $0x4,%esp
   12734:	50                   	push   %eax
   12735:	ff 75 10             	pushl  0x10(%ebp)
   12738:	ff 75 e8             	pushl  -0x18(%ebp)
   1273b:	e8 27 48 ff ff       	call   6f67 <lodepng_memcpy>
   12740:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
   12743:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12746:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12749:	01 d0                	add    %edx,%eax
   1274b:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
   1274e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12751:	8d 50 01             	lea    0x1(%eax),%edx
   12754:	8b 45 10             	mov    0x10(%ebp),%eax
   12757:	01 d0                	add    %edx,%eax
   12759:	0f b6 00             	movzbl (%eax),%eax
   1275c:	0f b6 c0             	movzbl %al,%eax
   1275f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
   12762:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12765:	8d 50 02             	lea    0x2(%eax),%edx
   12768:	8b 45 10             	mov    0x10(%ebp),%eax
   1276b:	01 d0                	add    %edx,%eax
   1276d:	0f b6 00             	movzbl (%eax),%eax
   12770:	84 c0                	test   %al,%al
   12772:	74 0c                	je     12780 <readChunk_iTXt+0x132>
   12774:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
   1277b:	e9 f5 01 00 00       	jmp    12975 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
   12780:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12783:	83 c0 03             	add    $0x3,%eax
   12786:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
   12789:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
   12790:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12793:	89 45 f0             	mov    %eax,-0x10(%ebp)
   12796:	eb 08                	jmp    127a0 <readChunk_iTXt+0x152>
   12798:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1279c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   127a0:	8b 45 14             	mov    0x14(%ebp),%eax
   127a3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   127a6:	73 0f                	jae    127b7 <readChunk_iTXt+0x169>
   127a8:	8b 55 10             	mov    0x10(%ebp),%edx
   127ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
   127ae:	01 d0                	add    %edx,%eax
   127b0:	0f b6 00             	movzbl (%eax),%eax
   127b3:	84 c0                	test   %al,%al
   127b5:	75 e1                	jne    12798 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
   127b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   127ba:	83 c0 01             	add    $0x1,%eax
   127bd:	83 ec 0c             	sub    $0xc,%esp
   127c0:	50                   	push   %eax
   127c1:	e8 63 47 ff ff       	call   6f29 <lodepng_malloc>
   127c6:	83 c4 10             	add    $0x10,%esp
   127c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
   127cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   127d0:	75 0c                	jne    127de <readChunk_iTXt+0x190>
   127d2:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   127d9:	e9 97 01 00 00       	jmp    12975 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
   127de:	8b 45 ec             	mov    -0x14(%ebp),%eax
   127e1:	8b 4d 10             	mov    0x10(%ebp),%ecx
   127e4:	8b 55 d8             	mov    -0x28(%ebp),%edx
   127e7:	01 ca                	add    %ecx,%edx
   127e9:	83 ec 04             	sub    $0x4,%esp
   127ec:	50                   	push   %eax
   127ed:	52                   	push   %edx
   127ee:	ff 75 e4             	pushl  -0x1c(%ebp)
   127f1:	e8 71 47 ff ff       	call   6f67 <lodepng_memcpy>
   127f6:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
   127f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   127fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   127ff:	01 d0                	add    %edx,%eax
   12801:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
   12804:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12807:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1280a:	01 d0                	add    %edx,%eax
   1280c:	83 c0 01             	add    $0x1,%eax
   1280f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
   12812:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
   12819:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1281c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1281f:	eb 08                	jmp    12829 <readChunk_iTXt+0x1db>
   12821:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12825:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12829:	8b 45 14             	mov    0x14(%ebp),%eax
   1282c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1282f:	73 0f                	jae    12840 <readChunk_iTXt+0x1f2>
   12831:	8b 55 10             	mov    0x10(%ebp),%edx
   12834:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12837:	01 d0                	add    %edx,%eax
   12839:	0f b6 00             	movzbl (%eax),%eax
   1283c:	84 c0                	test   %al,%al
   1283e:	75 e1                	jne    12821 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
   12840:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12843:	83 c0 01             	add    $0x1,%eax
   12846:	83 ec 0c             	sub    $0xc,%esp
   12849:	50                   	push   %eax
   1284a:	e8 da 46 ff ff       	call   6f29 <lodepng_malloc>
   1284f:	83 c4 10             	add    $0x10,%esp
   12852:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
   12855:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   12859:	75 0c                	jne    12867 <readChunk_iTXt+0x219>
   1285b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
   12862:	e9 0e 01 00 00       	jmp    12975 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
   12867:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1286a:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1286d:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12870:	01 ca                	add    %ecx,%edx
   12872:	83 ec 04             	sub    $0x4,%esp
   12875:	50                   	push   %eax
   12876:	52                   	push   %edx
   12877:	ff 75 e0             	pushl  -0x20(%ebp)
   1287a:	e8 e8 46 ff ff       	call   6f67 <lodepng_memcpy>
   1287f:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
   12882:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12885:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12888:	01 d0                	add    %edx,%eax
   1288a:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
   1288d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12890:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12893:	01 d0                	add    %edx,%eax
   12895:	83 c0 01             	add    $0x1,%eax
   12898:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
   1289b:	8b 45 14             	mov    0x14(%ebp),%eax
   1289e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
   128a1:	72 08                	jb     128ab <readChunk_iTXt+0x25d>
   128a3:	8b 45 14             	mov    0x14(%ebp),%eax
   128a6:	2b 45 d8             	sub    -0x28(%ebp),%eax
   128a9:	eb 05                	jmp    128b0 <readChunk_iTXt+0x262>
   128ab:	b8 00 00 00 00       	mov    $0x0,%eax
   128b0:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
   128b3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   128b7:	0f 84 90 00 00 00    	je     1294d <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
   128bd:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
   128c4:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
   128cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   128ce:	8b 40 30             	mov    0x30(%eax),%eax
   128d1:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
   128d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   128d7:	8b 4d 10             	mov    0x10(%ebp),%ecx
   128da:	8b 55 d8             	mov    -0x28(%ebp),%edx
   128dd:	01 d1                	add    %edx,%ecx
   128df:	83 ec 08             	sub    $0x8,%esp
   128e2:	8d 55 c0             	lea    -0x40(%ebp),%edx
   128e5:	52                   	push   %edx
   128e6:	50                   	push   %eax
   128e7:	51                   	push   %ecx
   128e8:	6a 00                	push   $0x0
   128ea:	8d 45 b8             	lea    -0x48(%ebp),%eax
   128ed:	50                   	push   %eax
   128ee:	8d 45 bc             	lea    -0x44(%ebp),%eax
   128f1:	50                   	push   %eax
   128f2:	e8 ed 90 ff ff       	call   b9e4 <zlib_decompress>
   128f7:	83 c4 20             	add    $0x20,%esp
   128fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
   128fd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12901:	74 11                	je     12914 <readChunk_iTXt+0x2c6>
   12903:	8b 55 c8             	mov    -0x38(%ebp),%edx
   12906:	8b 45 b8             	mov    -0x48(%ebp),%eax
   12909:	39 c2                	cmp    %eax,%edx
   1290b:	7d 07                	jge    12914 <readChunk_iTXt+0x2c6>
   1290d:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
   12914:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12918:	75 22                	jne    1293c <readChunk_iTXt+0x2ee>
   1291a:	8b 55 b8             	mov    -0x48(%ebp),%edx
   1291d:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12920:	83 ec 08             	sub    $0x8,%esp
   12923:	52                   	push   %edx
   12924:	50                   	push   %eax
   12925:	ff 75 e0             	pushl  -0x20(%ebp)
   12928:	ff 75 e4             	pushl  -0x1c(%ebp)
   1292b:	ff 75 e8             	pushl  -0x18(%ebp)
   1292e:	ff 75 08             	pushl  0x8(%ebp)
   12931:	e8 94 a9 ff ff       	call   d2ca <lodepng_add_itext_sized>
   12936:	83 c4 20             	add    $0x20,%esp
   12939:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
   1293c:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1293f:	83 ec 0c             	sub    $0xc,%esp
   12942:	50                   	push   %eax
   12943:	e8 02 46 ff ff       	call   6f4a <lodepng_free>
   12948:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
   1294b:	eb 27                	jmp    12974 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
   1294d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12950:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12953:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12956:	01 ca                	add    %ecx,%edx
   12958:	83 ec 08             	sub    $0x8,%esp
   1295b:	50                   	push   %eax
   1295c:	52                   	push   %edx
   1295d:	ff 75 e0             	pushl  -0x20(%ebp)
   12960:	ff 75 e4             	pushl  -0x1c(%ebp)
   12963:	ff 75 e8             	pushl  -0x18(%ebp)
   12966:	ff 75 08             	pushl  0x8(%ebp)
   12969:	e8 5c a9 ff ff       	call   d2ca <lodepng_add_itext_sized>
   1296e:	83 c4 20             	add    $0x20,%esp
   12971:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
   12974:	90                   	nop
  }

  lodepng_free(key);
   12975:	83 ec 0c             	sub    $0xc,%esp
   12978:	ff 75 e8             	pushl  -0x18(%ebp)
   1297b:	e8 ca 45 ff ff       	call   6f4a <lodepng_free>
   12980:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
   12983:	83 ec 0c             	sub    $0xc,%esp
   12986:	ff 75 e4             	pushl  -0x1c(%ebp)
   12989:	e8 bc 45 ff ff       	call   6f4a <lodepng_free>
   1298e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
   12991:	83 ec 0c             	sub    $0xc,%esp
   12994:	ff 75 e0             	pushl  -0x20(%ebp)
   12997:	e8 ae 45 ff ff       	call   6f4a <lodepng_free>
   1299c:	83 c4 10             	add    $0x10,%esp

  return error;
   1299f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   129a2:	c9                   	leave  
   129a3:	c3                   	ret    

000129a4 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   129a4:	55                   	push   %ebp
   129a5:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
   129a7:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
   129ab:	74 0a                	je     129b7 <readChunk_tIME+0x13>
   129ad:	b8 49 00 00 00       	mov    $0x49,%eax
   129b2:	e9 8b 00 00 00       	jmp    12a42 <readChunk_tIME+0x9e>

  info->time_defined = 1;
   129b7:	8b 45 08             	mov    0x8(%ebp),%eax
   129ba:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
   129c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   129c4:	0f b6 00             	movzbl (%eax),%eax
   129c7:	0f b6 c0             	movzbl %al,%eax
   129ca:	c1 e0 08             	shl    $0x8,%eax
   129cd:	89 c2                	mov    %eax,%edx
   129cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   129d2:	83 c0 01             	add    $0x1,%eax
   129d5:	0f b6 00             	movzbl (%eax),%eax
   129d8:	0f b6 c0             	movzbl %al,%eax
   129db:	01 c2                	add    %eax,%edx
   129dd:	8b 45 08             	mov    0x8(%ebp),%eax
   129e0:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
   129e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   129e6:	83 c0 02             	add    $0x2,%eax
   129e9:	0f b6 00             	movzbl (%eax),%eax
   129ec:	0f b6 d0             	movzbl %al,%edx
   129ef:	8b 45 08             	mov    0x8(%ebp),%eax
   129f2:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
   129f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   129f8:	83 c0 03             	add    $0x3,%eax
   129fb:	0f b6 00             	movzbl (%eax),%eax
   129fe:	0f b6 d0             	movzbl %al,%edx
   12a01:	8b 45 08             	mov    0x8(%ebp),%eax
   12a04:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
   12a07:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a0a:	83 c0 04             	add    $0x4,%eax
   12a0d:	0f b6 00             	movzbl (%eax),%eax
   12a10:	0f b6 d0             	movzbl %al,%edx
   12a13:	8b 45 08             	mov    0x8(%ebp),%eax
   12a16:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
   12a19:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a1c:	83 c0 05             	add    $0x5,%eax
   12a1f:	0f b6 00             	movzbl (%eax),%eax
   12a22:	0f b6 d0             	movzbl %al,%edx
   12a25:	8b 45 08             	mov    0x8(%ebp),%eax
   12a28:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
   12a2b:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a2e:	83 c0 06             	add    $0x6,%eax
   12a31:	0f b6 00             	movzbl (%eax),%eax
   12a34:	0f b6 d0             	movzbl %al,%edx
   12a37:	8b 45 08             	mov    0x8(%ebp),%eax
   12a3a:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
   12a3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12a42:	5d                   	pop    %ebp
   12a43:	c3                   	ret    

00012a44 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   12a44:	55                   	push   %ebp
   12a45:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
   12a47:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
   12a4b:	74 0a                	je     12a57 <readChunk_pHYs+0x13>
   12a4d:	b8 4a 00 00 00       	mov    $0x4a,%eax
   12a52:	e9 ba 00 00 00       	jmp    12b11 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
   12a57:	8b 45 08             	mov    0x8(%ebp),%eax
   12a5a:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
   12a61:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a64:	0f b6 00             	movzbl (%eax),%eax
   12a67:	0f b6 c0             	movzbl %al,%eax
   12a6a:	c1 e0 08             	shl    $0x8,%eax
   12a6d:	89 c2                	mov    %eax,%edx
   12a6f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a72:	83 c0 01             	add    $0x1,%eax
   12a75:	0f b6 00             	movzbl (%eax),%eax
   12a78:	0f b6 c0             	movzbl %al,%eax
   12a7b:	01 d0                	add    %edx,%eax
   12a7d:	c1 e0 08             	shl    $0x8,%eax
   12a80:	89 c2                	mov    %eax,%edx
   12a82:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a85:	83 c0 02             	add    $0x2,%eax
   12a88:	0f b6 00             	movzbl (%eax),%eax
   12a8b:	0f b6 c0             	movzbl %al,%eax
   12a8e:	01 d0                	add    %edx,%eax
   12a90:	c1 e0 08             	shl    $0x8,%eax
   12a93:	89 c2                	mov    %eax,%edx
   12a95:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a98:	83 c0 03             	add    $0x3,%eax
   12a9b:	0f b6 00             	movzbl (%eax),%eax
   12a9e:	0f b6 c0             	movzbl %al,%eax
   12aa1:	01 c2                	add    %eax,%edx
   12aa3:	8b 45 08             	mov    0x8(%ebp),%eax
   12aa6:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
   12aa9:	8b 45 0c             	mov    0xc(%ebp),%eax
   12aac:	83 c0 04             	add    $0x4,%eax
   12aaf:	0f b6 00             	movzbl (%eax),%eax
   12ab2:	0f b6 c0             	movzbl %al,%eax
   12ab5:	c1 e0 08             	shl    $0x8,%eax
   12ab8:	89 c2                	mov    %eax,%edx
   12aba:	8b 45 0c             	mov    0xc(%ebp),%eax
   12abd:	83 c0 05             	add    $0x5,%eax
   12ac0:	0f b6 00             	movzbl (%eax),%eax
   12ac3:	0f b6 c0             	movzbl %al,%eax
   12ac6:	01 d0                	add    %edx,%eax
   12ac8:	c1 e0 08             	shl    $0x8,%eax
   12acb:	89 c2                	mov    %eax,%edx
   12acd:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ad0:	83 c0 06             	add    $0x6,%eax
   12ad3:	0f b6 00             	movzbl (%eax),%eax
   12ad6:	0f b6 c0             	movzbl %al,%eax
   12ad9:	01 d0                	add    %edx,%eax
   12adb:	c1 e0 08             	shl    $0x8,%eax
   12ade:	89 c2                	mov    %eax,%edx
   12ae0:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ae3:	83 c0 07             	add    $0x7,%eax
   12ae6:	0f b6 00             	movzbl (%eax),%eax
   12ae9:	0f b6 c0             	movzbl %al,%eax
   12aec:	01 c2                	add    %eax,%edx
   12aee:	8b 45 08             	mov    0x8(%ebp),%eax
   12af1:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
   12af7:	8b 45 0c             	mov    0xc(%ebp),%eax
   12afa:	83 c0 08             	add    $0x8,%eax
   12afd:	0f b6 00             	movzbl (%eax),%eax
   12b00:	0f b6 d0             	movzbl %al,%edx
   12b03:	8b 45 08             	mov    0x8(%ebp),%eax
   12b06:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
   12b0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12b11:	5d                   	pop    %ebp
   12b12:	c3                   	ret    

00012b13 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   12b13:	55                   	push   %ebp
   12b14:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
   12b16:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
   12b1a:	74 07                	je     12b23 <readChunk_gAMA+0x10>
   12b1c:	b8 60 00 00 00       	mov    $0x60,%eax
   12b21:	eb 5d                	jmp    12b80 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
   12b23:	8b 45 08             	mov    0x8(%ebp),%eax
   12b26:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
   12b2d:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
   12b30:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b33:	0f b6 00             	movzbl (%eax),%eax
   12b36:	0f b6 c0             	movzbl %al,%eax
   12b39:	c1 e0 08             	shl    $0x8,%eax
   12b3c:	89 c2                	mov    %eax,%edx
   12b3e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b41:	83 c0 01             	add    $0x1,%eax
   12b44:	0f b6 00             	movzbl (%eax),%eax
   12b47:	0f b6 c0             	movzbl %al,%eax
   12b4a:	01 d0                	add    %edx,%eax
   12b4c:	c1 e0 08             	shl    $0x8,%eax
   12b4f:	89 c2                	mov    %eax,%edx
   12b51:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b54:	83 c0 02             	add    $0x2,%eax
   12b57:	0f b6 00             	movzbl (%eax),%eax
   12b5a:	0f b6 c0             	movzbl %al,%eax
   12b5d:	01 d0                	add    %edx,%eax
   12b5f:	c1 e0 08             	shl    $0x8,%eax
   12b62:	89 c2                	mov    %eax,%edx
   12b64:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b67:	83 c0 03             	add    $0x3,%eax
   12b6a:	0f b6 00             	movzbl (%eax),%eax
   12b6d:	0f b6 c0             	movzbl %al,%eax
   12b70:	01 c2                	add    %eax,%edx
   12b72:	8b 45 08             	mov    0x8(%ebp),%eax
   12b75:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
   12b7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12b80:	5d                   	pop    %ebp
   12b81:	c3                   	ret    

00012b82 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   12b82:	55                   	push   %ebp
   12b83:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
   12b85:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
   12b89:	74 0a                	je     12b95 <readChunk_cHRM+0x13>
   12b8b:	b8 61 00 00 00       	mov    $0x61,%eax
   12b90:	e9 7f 02 00 00       	jmp    12e14 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
   12b95:	8b 45 08             	mov    0x8(%ebp),%eax
   12b98:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   12b9f:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
   12ba2:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ba5:	0f b6 00             	movzbl (%eax),%eax
   12ba8:	0f b6 c0             	movzbl %al,%eax
   12bab:	c1 e0 08             	shl    $0x8,%eax
   12bae:	89 c2                	mov    %eax,%edx
   12bb0:	8b 45 0c             	mov    0xc(%ebp),%eax
   12bb3:	83 c0 01             	add    $0x1,%eax
   12bb6:	0f b6 00             	movzbl (%eax),%eax
   12bb9:	0f b6 c0             	movzbl %al,%eax
   12bbc:	01 d0                	add    %edx,%eax
   12bbe:	c1 e0 08             	shl    $0x8,%eax
   12bc1:	89 c2                	mov    %eax,%edx
   12bc3:	8b 45 0c             	mov    0xc(%ebp),%eax
   12bc6:	83 c0 02             	add    $0x2,%eax
   12bc9:	0f b6 00             	movzbl (%eax),%eax
   12bcc:	0f b6 c0             	movzbl %al,%eax
   12bcf:	01 d0                	add    %edx,%eax
   12bd1:	c1 e0 08             	shl    $0x8,%eax
   12bd4:	89 c2                	mov    %eax,%edx
   12bd6:	8b 45 0c             	mov    0xc(%ebp),%eax
   12bd9:	83 c0 03             	add    $0x3,%eax
   12bdc:	0f b6 00             	movzbl (%eax),%eax
   12bdf:	0f b6 c0             	movzbl %al,%eax
   12be2:	01 c2                	add    %eax,%edx
   12be4:	8b 45 08             	mov    0x8(%ebp),%eax
   12be7:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
   12bed:	8b 45 0c             	mov    0xc(%ebp),%eax
   12bf0:	83 c0 04             	add    $0x4,%eax
   12bf3:	0f b6 00             	movzbl (%eax),%eax
   12bf6:	0f b6 c0             	movzbl %al,%eax
   12bf9:	c1 e0 08             	shl    $0x8,%eax
   12bfc:	89 c2                	mov    %eax,%edx
   12bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c01:	83 c0 05             	add    $0x5,%eax
   12c04:	0f b6 00             	movzbl (%eax),%eax
   12c07:	0f b6 c0             	movzbl %al,%eax
   12c0a:	01 d0                	add    %edx,%eax
   12c0c:	c1 e0 08             	shl    $0x8,%eax
   12c0f:	89 c2                	mov    %eax,%edx
   12c11:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c14:	83 c0 06             	add    $0x6,%eax
   12c17:	0f b6 00             	movzbl (%eax),%eax
   12c1a:	0f b6 c0             	movzbl %al,%eax
   12c1d:	01 d0                	add    %edx,%eax
   12c1f:	c1 e0 08             	shl    $0x8,%eax
   12c22:	89 c2                	mov    %eax,%edx
   12c24:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c27:	83 c0 07             	add    $0x7,%eax
   12c2a:	0f b6 00             	movzbl (%eax),%eax
   12c2d:	0f b6 c0             	movzbl %al,%eax
   12c30:	01 c2                	add    %eax,%edx
   12c32:	8b 45 08             	mov    0x8(%ebp),%eax
   12c35:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
   12c3b:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c3e:	83 c0 08             	add    $0x8,%eax
   12c41:	0f b6 00             	movzbl (%eax),%eax
   12c44:	0f b6 c0             	movzbl %al,%eax
   12c47:	c1 e0 08             	shl    $0x8,%eax
   12c4a:	89 c2                	mov    %eax,%edx
   12c4c:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c4f:	83 c0 09             	add    $0x9,%eax
   12c52:	0f b6 00             	movzbl (%eax),%eax
   12c55:	0f b6 c0             	movzbl %al,%eax
   12c58:	01 d0                	add    %edx,%eax
   12c5a:	c1 e0 08             	shl    $0x8,%eax
   12c5d:	89 c2                	mov    %eax,%edx
   12c5f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c62:	83 c0 0a             	add    $0xa,%eax
   12c65:	0f b6 00             	movzbl (%eax),%eax
   12c68:	0f b6 c0             	movzbl %al,%eax
   12c6b:	01 d0                	add    %edx,%eax
   12c6d:	c1 e0 08             	shl    $0x8,%eax
   12c70:	89 c2                	mov    %eax,%edx
   12c72:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c75:	83 c0 0b             	add    $0xb,%eax
   12c78:	0f b6 00             	movzbl (%eax),%eax
   12c7b:	0f b6 c0             	movzbl %al,%eax
   12c7e:	01 c2                	add    %eax,%edx
   12c80:	8b 45 08             	mov    0x8(%ebp),%eax
   12c83:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
   12c89:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c8c:	83 c0 0c             	add    $0xc,%eax
   12c8f:	0f b6 00             	movzbl (%eax),%eax
   12c92:	0f b6 c0             	movzbl %al,%eax
   12c95:	c1 e0 08             	shl    $0x8,%eax
   12c98:	89 c2                	mov    %eax,%edx
   12c9a:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c9d:	83 c0 0d             	add    $0xd,%eax
   12ca0:	0f b6 00             	movzbl (%eax),%eax
   12ca3:	0f b6 c0             	movzbl %al,%eax
   12ca6:	01 d0                	add    %edx,%eax
   12ca8:	c1 e0 08             	shl    $0x8,%eax
   12cab:	89 c2                	mov    %eax,%edx
   12cad:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cb0:	83 c0 0e             	add    $0xe,%eax
   12cb3:	0f b6 00             	movzbl (%eax),%eax
   12cb6:	0f b6 c0             	movzbl %al,%eax
   12cb9:	01 d0                	add    %edx,%eax
   12cbb:	c1 e0 08             	shl    $0x8,%eax
   12cbe:	89 c2                	mov    %eax,%edx
   12cc0:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cc3:	83 c0 0f             	add    $0xf,%eax
   12cc6:	0f b6 00             	movzbl (%eax),%eax
   12cc9:	0f b6 c0             	movzbl %al,%eax
   12ccc:	01 c2                	add    %eax,%edx
   12cce:	8b 45 08             	mov    0x8(%ebp),%eax
   12cd1:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
   12cd7:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cda:	83 c0 10             	add    $0x10,%eax
   12cdd:	0f b6 00             	movzbl (%eax),%eax
   12ce0:	0f b6 c0             	movzbl %al,%eax
   12ce3:	c1 e0 08             	shl    $0x8,%eax
   12ce6:	89 c2                	mov    %eax,%edx
   12ce8:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ceb:	83 c0 11             	add    $0x11,%eax
   12cee:	0f b6 00             	movzbl (%eax),%eax
   12cf1:	0f b6 c0             	movzbl %al,%eax
   12cf4:	01 d0                	add    %edx,%eax
   12cf6:	c1 e0 08             	shl    $0x8,%eax
   12cf9:	89 c2                	mov    %eax,%edx
   12cfb:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cfe:	83 c0 12             	add    $0x12,%eax
   12d01:	0f b6 00             	movzbl (%eax),%eax
   12d04:	0f b6 c0             	movzbl %al,%eax
   12d07:	01 d0                	add    %edx,%eax
   12d09:	c1 e0 08             	shl    $0x8,%eax
   12d0c:	89 c2                	mov    %eax,%edx
   12d0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d11:	83 c0 13             	add    $0x13,%eax
   12d14:	0f b6 00             	movzbl (%eax),%eax
   12d17:	0f b6 c0             	movzbl %al,%eax
   12d1a:	01 c2                	add    %eax,%edx
   12d1c:	8b 45 08             	mov    0x8(%ebp),%eax
   12d1f:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
   12d25:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d28:	83 c0 14             	add    $0x14,%eax
   12d2b:	0f b6 00             	movzbl (%eax),%eax
   12d2e:	0f b6 c0             	movzbl %al,%eax
   12d31:	c1 e0 08             	shl    $0x8,%eax
   12d34:	89 c2                	mov    %eax,%edx
   12d36:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d39:	83 c0 15             	add    $0x15,%eax
   12d3c:	0f b6 00             	movzbl (%eax),%eax
   12d3f:	0f b6 c0             	movzbl %al,%eax
   12d42:	01 d0                	add    %edx,%eax
   12d44:	c1 e0 08             	shl    $0x8,%eax
   12d47:	89 c2                	mov    %eax,%edx
   12d49:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d4c:	83 c0 16             	add    $0x16,%eax
   12d4f:	0f b6 00             	movzbl (%eax),%eax
   12d52:	0f b6 c0             	movzbl %al,%eax
   12d55:	01 d0                	add    %edx,%eax
   12d57:	c1 e0 08             	shl    $0x8,%eax
   12d5a:	89 c2                	mov    %eax,%edx
   12d5c:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d5f:	83 c0 17             	add    $0x17,%eax
   12d62:	0f b6 00             	movzbl (%eax),%eax
   12d65:	0f b6 c0             	movzbl %al,%eax
   12d68:	01 c2                	add    %eax,%edx
   12d6a:	8b 45 08             	mov    0x8(%ebp),%eax
   12d6d:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
   12d73:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d76:	83 c0 18             	add    $0x18,%eax
   12d79:	0f b6 00             	movzbl (%eax),%eax
   12d7c:	0f b6 c0             	movzbl %al,%eax
   12d7f:	c1 e0 08             	shl    $0x8,%eax
   12d82:	89 c2                	mov    %eax,%edx
   12d84:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d87:	83 c0 19             	add    $0x19,%eax
   12d8a:	0f b6 00             	movzbl (%eax),%eax
   12d8d:	0f b6 c0             	movzbl %al,%eax
   12d90:	01 d0                	add    %edx,%eax
   12d92:	c1 e0 08             	shl    $0x8,%eax
   12d95:	89 c2                	mov    %eax,%edx
   12d97:	8b 45 0c             	mov    0xc(%ebp),%eax
   12d9a:	83 c0 1a             	add    $0x1a,%eax
   12d9d:	0f b6 00             	movzbl (%eax),%eax
   12da0:	0f b6 c0             	movzbl %al,%eax
   12da3:	01 d0                	add    %edx,%eax
   12da5:	c1 e0 08             	shl    $0x8,%eax
   12da8:	89 c2                	mov    %eax,%edx
   12daa:	8b 45 0c             	mov    0xc(%ebp),%eax
   12dad:	83 c0 1b             	add    $0x1b,%eax
   12db0:	0f b6 00             	movzbl (%eax),%eax
   12db3:	0f b6 c0             	movzbl %al,%eax
   12db6:	01 c2                	add    %eax,%edx
   12db8:	8b 45 08             	mov    0x8(%ebp),%eax
   12dbb:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
   12dc1:	8b 45 0c             	mov    0xc(%ebp),%eax
   12dc4:	83 c0 1c             	add    $0x1c,%eax
   12dc7:	0f b6 00             	movzbl (%eax),%eax
   12dca:	0f b6 c0             	movzbl %al,%eax
   12dcd:	c1 e0 08             	shl    $0x8,%eax
   12dd0:	89 c2                	mov    %eax,%edx
   12dd2:	8b 45 0c             	mov    0xc(%ebp),%eax
   12dd5:	83 c0 1d             	add    $0x1d,%eax
   12dd8:	0f b6 00             	movzbl (%eax),%eax
   12ddb:	0f b6 c0             	movzbl %al,%eax
   12dde:	01 d0                	add    %edx,%eax
   12de0:	c1 e0 08             	shl    $0x8,%eax
   12de3:	89 c2                	mov    %eax,%edx
   12de5:	8b 45 0c             	mov    0xc(%ebp),%eax
   12de8:	83 c0 1e             	add    $0x1e,%eax
   12deb:	0f b6 00             	movzbl (%eax),%eax
   12dee:	0f b6 c0             	movzbl %al,%eax
   12df1:	01 d0                	add    %edx,%eax
   12df3:	c1 e0 08             	shl    $0x8,%eax
   12df6:	89 c2                	mov    %eax,%edx
   12df8:	8b 45 0c             	mov    0xc(%ebp),%eax
   12dfb:	83 c0 1f             	add    $0x1f,%eax
   12dfe:	0f b6 00             	movzbl (%eax),%eax
   12e01:	0f b6 c0             	movzbl %al,%eax
   12e04:	01 c2                	add    %eax,%edx
   12e06:	8b 45 08             	mov    0x8(%ebp),%eax
   12e09:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
   12e0f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12e14:	5d                   	pop    %ebp
   12e15:	c3                   	ret    

00012e16 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
   12e16:	55                   	push   %ebp
   12e17:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
   12e19:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
   12e1d:	74 07                	je     12e26 <readChunk_sRGB+0x10>
   12e1f:	b8 62 00 00 00       	mov    $0x62,%eax
   12e24:	eb 24                	jmp    12e4a <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
   12e26:	8b 45 08             	mov    0x8(%ebp),%eax
   12e29:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
   12e30:	00 00 00 
  info->srgb_intent = data[0];
   12e33:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e36:	0f b6 00             	movzbl (%eax),%eax
   12e39:	0f b6 d0             	movzbl %al,%edx
   12e3c:	8b 45 08             	mov    0x8(%ebp),%eax
   12e3f:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
   12e45:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12e4a:	5d                   	pop    %ebp
   12e4b:	c3                   	ret    

00012e4c <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
   12e4c:	55                   	push   %ebp
   12e4d:	89 e5                	mov    %esp,%ebp
   12e4f:	53                   	push   %ebx
   12e50:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   12e53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
   12e5a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
   12e61:	8b 45 0c             	mov    0xc(%ebp),%eax
   12e64:	8b 10                	mov    (%eax),%edx
   12e66:	89 55 cc             	mov    %edx,-0x34(%ebp)
   12e69:	8b 50 04             	mov    0x4(%eax),%edx
   12e6c:	89 55 d0             	mov    %edx,-0x30(%ebp)
   12e6f:	8b 50 08             	mov    0x8(%eax),%edx
   12e72:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   12e75:	8b 50 0c             	mov    0xc(%eax),%edx
   12e78:	89 55 d8             	mov    %edx,-0x28(%ebp)
   12e7b:	8b 50 10             	mov    0x10(%eax),%edx
   12e7e:	89 55 dc             	mov    %edx,-0x24(%ebp)
   12e81:	8b 40 14             	mov    0x14(%eax),%eax
   12e84:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
   12e87:	8b 45 08             	mov    0x8(%ebp),%eax
   12e8a:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
   12e91:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
   12e94:	8b 45 08             	mov    0x8(%ebp),%eax
   12e97:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   12e9d:	85 c0                	test   %eax,%eax
   12e9f:	74 0e                	je     12eaf <readChunk_iCCP+0x63>
   12ea1:	83 ec 0c             	sub    $0xc,%esp
   12ea4:	ff 75 08             	pushl  0x8(%ebp)
   12ea7:	e8 ca a6 ff ff       	call   d576 <lodepng_clear_icc>
   12eac:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
   12eaf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12eb6:	eb 04                	jmp    12ebc <readChunk_iCCP+0x70>
   12eb8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12ebc:	8b 45 14             	mov    0x14(%ebp),%eax
   12ebf:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   12ec2:	73 0f                	jae    12ed3 <readChunk_iCCP+0x87>
   12ec4:	8b 55 10             	mov    0x10(%ebp),%edx
   12ec7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12eca:	01 d0                	add    %edx,%eax
   12ecc:	0f b6 00             	movzbl (%eax),%eax
   12ecf:	84 c0                	test   %al,%al
   12ed1:	75 e5                	jne    12eb8 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
   12ed3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12ed6:	8d 50 02             	lea    0x2(%eax),%edx
   12ed9:	8b 45 14             	mov    0x14(%ebp),%eax
   12edc:	39 c2                	cmp    %eax,%edx
   12ede:	72 0a                	jb     12eea <readChunk_iCCP+0x9e>
   12ee0:	b8 4b 00 00 00       	mov    $0x4b,%eax
   12ee5:	e9 46 01 00 00       	jmp    13030 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
   12eea:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12eee:	74 06                	je     12ef6 <readChunk_iCCP+0xaa>
   12ef0:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   12ef4:	76 0a                	jbe    12f00 <readChunk_iCCP+0xb4>
   12ef6:	b8 59 00 00 00       	mov    $0x59,%eax
   12efb:	e9 30 01 00 00       	jmp    13030 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
   12f00:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12f03:	83 c0 01             	add    $0x1,%eax
   12f06:	83 ec 0c             	sub    $0xc,%esp
   12f09:	50                   	push   %eax
   12f0a:	e8 1a 40 ff ff       	call   6f29 <lodepng_malloc>
   12f0f:	83 c4 10             	add    $0x10,%esp
   12f12:	89 c2                	mov    %eax,%edx
   12f14:	8b 45 08             	mov    0x8(%ebp),%eax
   12f17:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
   12f1d:	8b 45 08             	mov    0x8(%ebp),%eax
   12f20:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   12f26:	85 c0                	test   %eax,%eax
   12f28:	75 0a                	jne    12f34 <readChunk_iCCP+0xe8>
   12f2a:	b8 53 00 00 00       	mov    $0x53,%eax
   12f2f:	e9 fc 00 00 00       	jmp    13030 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
   12f34:	8b 45 08             	mov    0x8(%ebp),%eax
   12f37:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   12f3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12f40:	01 d0                	add    %edx,%eax
   12f42:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
   12f45:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12f4c:	eb 1f                	jmp    12f6d <readChunk_iCCP+0x121>
   12f4e:	8b 45 08             	mov    0x8(%ebp),%eax
   12f51:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
   12f57:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12f5a:	01 d0                	add    %edx,%eax
   12f5c:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12f5f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12f62:	01 ca                	add    %ecx,%edx
   12f64:	0f b6 12             	movzbl (%edx),%edx
   12f67:	88 10                	mov    %dl,(%eax)
   12f69:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12f6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12f70:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12f73:	75 d9                	jne    12f4e <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
   12f75:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12f78:	8d 50 01             	lea    0x1(%eax),%edx
   12f7b:	8b 45 10             	mov    0x10(%ebp),%eax
   12f7e:	01 d0                	add    %edx,%eax
   12f80:	0f b6 00             	movzbl (%eax),%eax
   12f83:	84 c0                	test   %al,%al
   12f85:	74 0a                	je     12f91 <readChunk_iCCP+0x145>
   12f87:	b8 48 00 00 00       	mov    $0x48,%eax
   12f8c:	e9 9f 00 00 00       	jmp    13030 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
   12f91:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12f94:	83 c0 02             	add    $0x2,%eax
   12f97:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
   12f9a:	8b 45 14             	mov    0x14(%ebp),%eax
   12f9d:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   12fa0:	76 0a                	jbe    12fac <readChunk_iCCP+0x160>
   12fa2:	b8 4b 00 00 00       	mov    $0x4b,%eax
   12fa7:	e9 84 00 00 00       	jmp    13030 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
   12fac:	8b 45 14             	mov    0x14(%ebp),%eax
   12faf:	2b 45 e8             	sub    -0x18(%ebp),%eax
   12fb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
   12fb5:	8b 45 0c             	mov    0xc(%ebp),%eax
   12fb8:	8b 40 34             	mov    0x34(%eax),%eax
   12fbb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
   12fbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12fc1:	8b 4d 10             	mov    0x10(%ebp),%ecx
   12fc4:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12fc7:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
   12fca:	8b 55 08             	mov    0x8(%ebp),%edx
   12fcd:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
   12fd3:	83 ec 08             	sub    $0x8,%esp
   12fd6:	8d 55 cc             	lea    -0x34(%ebp),%edx
   12fd9:	52                   	push   %edx
   12fda:	50                   	push   %eax
   12fdb:	53                   	push   %ebx
   12fdc:	6a 00                	push   $0x0
   12fde:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   12fe1:	50                   	push   %eax
   12fe2:	51                   	push   %ecx
   12fe3:	e8 fc 89 ff ff       	call   b9e4 <zlib_decompress>
   12fe8:	83 c4 20             	add    $0x20,%esp
   12feb:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
   12fee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12ff2:	74 11                	je     13005 <readChunk_iCCP+0x1b9>
   12ff4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12ff7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12ffa:	39 c2                	cmp    %eax,%edx
   12ffc:	7d 07                	jge    13005 <readChunk_iCCP+0x1b9>
   12ffe:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
   13005:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13008:	89 c2                	mov    %eax,%edx
   1300a:	8b 45 08             	mov    0x8(%ebp),%eax
   1300d:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
   13013:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13017:	75 14                	jne    1302d <readChunk_iCCP+0x1e1>
   13019:	8b 45 08             	mov    0x8(%ebp),%eax
   1301c:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
   13022:	85 c0                	test   %eax,%eax
   13024:	75 07                	jne    1302d <readChunk_iCCP+0x1e1>
   13026:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
   1302d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13030:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   13033:	c9                   	leave  
   13034:	c3                   	ret    

00013035 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
   13035:	55                   	push   %ebp
   13036:	89 e5                	mov    %esp,%ebp
   13038:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
   1303b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1303e:	8b 45 10             	mov    0x10(%ebp),%eax
   13041:	01 d0                	add    %edx,%eax
   13043:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
   13046:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
   1304d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
   13054:	8b 45 0c             	mov    0xc(%ebp),%eax
   13057:	83 c0 04             	add    $0x4,%eax
   1305a:	3b 45 14             	cmp    0x14(%ebp),%eax
   1305d:	7e 0a                	jle    13069 <lodepng_inspect_chunk+0x34>
   1305f:	b8 1e 00 00 00       	mov    $0x1e,%eax
   13064:	e9 43 03 00 00       	jmp    133ac <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
   13069:	ff 75 ec             	pushl  -0x14(%ebp)
   1306c:	e8 3a 8e ff ff       	call   beab <lodepng_chunk_length>
   13071:	83 c4 04             	add    $0x4,%esp
   13074:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
   13077:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1307a:	85 c0                	test   %eax,%eax
   1307c:	79 0a                	jns    13088 <lodepng_inspect_chunk+0x53>
   1307e:	b8 3f 00 00 00       	mov    $0x3f,%eax
   13083:	e9 24 03 00 00       	jmp    133ac <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
   13088:	ff 75 ec             	pushl  -0x14(%ebp)
   1308b:	e8 53 8f ff ff       	call   bfe3 <lodepng_chunk_data_const>
   13090:	83 c4 04             	add    $0x4,%esp
   13093:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
   13096:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13099:	8d 50 04             	lea    0x4(%eax),%edx
   1309c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1309f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   130a2:	8b 55 14             	mov    0x14(%ebp),%edx
   130a5:	8b 45 10             	mov    0x10(%ebp),%eax
   130a8:	01 d0                	add    %edx,%eax
   130aa:	39 c1                	cmp    %eax,%ecx
   130ac:	76 0a                	jbe    130b8 <lodepng_inspect_chunk+0x83>
   130ae:	b8 1e 00 00 00       	mov    $0x1e,%eax
   130b3:	e9 f4 02 00 00       	jmp    133ac <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   130b8:	68 08 f4 01 00       	push   $0x1f408
   130bd:	ff 75 ec             	pushl  -0x14(%ebp)
   130c0:	e8 33 8e ff ff       	call   bef8 <lodepng_chunk_type_equals>
   130c5:	83 c4 08             	add    $0x8,%esp
   130c8:	84 c0                	test   %al,%al
   130ca:	74 24                	je     130f0 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   130cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   130cf:	8b 55 08             	mov    0x8(%ebp),%edx
   130d2:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   130d8:	83 ec 04             	sub    $0x4,%esp
   130db:	50                   	push   %eax
   130dc:	ff 75 e4             	pushl  -0x1c(%ebp)
   130df:	52                   	push   %edx
   130e0:	e8 5b ee ff ff       	call   11f40 <readChunk_PLTE>
   130e5:	83 c4 10             	add    $0x10,%esp
   130e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
   130eb:	e9 8a 02 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   130f0:	83 ec 08             	sub    $0x8,%esp
   130f3:	68 0d f4 01 00       	push   $0x1f40d
   130f8:	ff 75 ec             	pushl  -0x14(%ebp)
   130fb:	e8 f8 8d ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13100:	83 c4 10             	add    $0x10,%esp
   13103:	84 c0                	test   %al,%al
   13105:	74 24                	je     1312b <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   13107:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1310a:	8b 55 08             	mov    0x8(%ebp),%edx
   1310d:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   13113:	83 ec 04             	sub    $0x4,%esp
   13116:	50                   	push   %eax
   13117:	ff 75 e4             	pushl  -0x1c(%ebp)
   1311a:	52                   	push   %edx
   1311b:	e8 40 ef ff ff       	call   12060 <readChunk_tRNS>
   13120:	83 c4 10             	add    $0x10,%esp
   13123:	89 45 f0             	mov    %eax,-0x10(%ebp)
   13126:	e9 4f 02 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   1312b:	83 ec 08             	sub    $0x8,%esp
   1312e:	68 12 f4 01 00       	push   $0x1f412
   13133:	ff 75 ec             	pushl  -0x14(%ebp)
   13136:	e8 bd 8d ff ff       	call   bef8 <lodepng_chunk_type_equals>
   1313b:	83 c4 10             	add    $0x10,%esp
   1313e:	84 c0                	test   %al,%al
   13140:	74 24                	je     13166 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
   13142:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13145:	8b 55 08             	mov    0x8(%ebp),%edx
   13148:	81 c2 98 00 00 00    	add    $0x98,%edx
   1314e:	83 ec 04             	sub    $0x4,%esp
   13151:	50                   	push   %eax
   13152:	ff 75 e4             	pushl  -0x1c(%ebp)
   13155:	52                   	push   %edx
   13156:	e8 68 f0 ff ff       	call   121c3 <readChunk_bKGD>
   1315b:	83 c4 10             	add    $0x10,%esp
   1315e:	89 45 f0             	mov    %eax,-0x10(%ebp)
   13161:	e9 14 02 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   13166:	83 ec 08             	sub    $0x8,%esp
   13169:	68 17 f4 01 00       	push   $0x1f417
   1316e:	ff 75 ec             	pushl  -0x14(%ebp)
   13171:	e8 82 8d ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13176:	83 c4 10             	add    $0x10,%esp
   13179:	84 c0                	test   %al,%al
   1317b:	74 24                	je     131a1 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
   1317d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13180:	8b 55 08             	mov    0x8(%ebp),%edx
   13183:	81 c2 98 00 00 00    	add    $0x98,%edx
   13189:	83 ec 04             	sub    $0x4,%esp
   1318c:	50                   	push   %eax
   1318d:	ff 75 e4             	pushl  -0x1c(%ebp)
   13190:	52                   	push   %edx
   13191:	e8 b0 f1 ff ff       	call   12346 <readChunk_tEXt>
   13196:	83 c4 10             	add    $0x10,%esp
   13199:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1319c:	e9 d9 01 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   131a1:	83 ec 08             	sub    $0x8,%esp
   131a4:	68 1c f4 01 00       	push   $0x1f41c
   131a9:	ff 75 ec             	pushl  -0x14(%ebp)
   131ac:	e8 47 8d ff ff       	call   bef8 <lodepng_chunk_type_equals>
   131b1:	83 c4 10             	add    $0x10,%esp
   131b4:	84 c0                	test   %al,%al
   131b6:	74 25                	je     131dd <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   131b8:	8b 55 e8             	mov    -0x18(%ebp),%edx
   131bb:	8b 45 08             	mov    0x8(%ebp),%eax
   131be:	8b 4d 08             	mov    0x8(%ebp),%ecx
   131c1:	81 c1 98 00 00 00    	add    $0x98,%ecx
   131c7:	52                   	push   %edx
   131c8:	ff 75 e4             	pushl  -0x1c(%ebp)
   131cb:	50                   	push   %eax
   131cc:	51                   	push   %ecx
   131cd:	e8 c0 f2 ff ff       	call   12492 <readChunk_zTXt>
   131d2:	83 c4 10             	add    $0x10,%esp
   131d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
   131d8:	e9 9d 01 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   131dd:	83 ec 08             	sub    $0x8,%esp
   131e0:	68 21 f4 01 00       	push   $0x1f421
   131e5:	ff 75 ec             	pushl  -0x14(%ebp)
   131e8:	e8 0b 8d ff ff       	call   bef8 <lodepng_chunk_type_equals>
   131ed:	83 c4 10             	add    $0x10,%esp
   131f0:	84 c0                	test   %al,%al
   131f2:	74 25                	je     13219 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   131f4:	8b 55 e8             	mov    -0x18(%ebp),%edx
   131f7:	8b 45 08             	mov    0x8(%ebp),%eax
   131fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
   131fd:	81 c1 98 00 00 00    	add    $0x98,%ecx
   13203:	52                   	push   %edx
   13204:	ff 75 e4             	pushl  -0x1c(%ebp)
   13207:	50                   	push   %eax
   13208:	51                   	push   %ecx
   13209:	e8 40 f4 ff ff       	call   1264e <readChunk_iTXt>
   1320e:	83 c4 10             	add    $0x10,%esp
   13211:	89 45 f0             	mov    %eax,-0x10(%ebp)
   13214:	e9 61 01 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   13219:	83 ec 08             	sub    $0x8,%esp
   1321c:	68 26 f4 01 00       	push   $0x1f426
   13221:	ff 75 ec             	pushl  -0x14(%ebp)
   13224:	e8 cf 8c ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13229:	83 c4 10             	add    $0x10,%esp
   1322c:	84 c0                	test   %al,%al
   1322e:	74 24                	je     13254 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
   13230:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13233:	8b 55 08             	mov    0x8(%ebp),%edx
   13236:	81 c2 98 00 00 00    	add    $0x98,%edx
   1323c:	83 ec 04             	sub    $0x4,%esp
   1323f:	50                   	push   %eax
   13240:	ff 75 e4             	pushl  -0x1c(%ebp)
   13243:	52                   	push   %edx
   13244:	e8 5b f7 ff ff       	call   129a4 <readChunk_tIME>
   13249:	83 c4 10             	add    $0x10,%esp
   1324c:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1324f:	e9 26 01 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   13254:	83 ec 08             	sub    $0x8,%esp
   13257:	68 2b f4 01 00       	push   $0x1f42b
   1325c:	ff 75 ec             	pushl  -0x14(%ebp)
   1325f:	e8 94 8c ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13264:	83 c4 10             	add    $0x10,%esp
   13267:	84 c0                	test   %al,%al
   13269:	74 24                	je     1328f <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
   1326b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1326e:	8b 55 08             	mov    0x8(%ebp),%edx
   13271:	81 c2 98 00 00 00    	add    $0x98,%edx
   13277:	83 ec 04             	sub    $0x4,%esp
   1327a:	50                   	push   %eax
   1327b:	ff 75 e4             	pushl  -0x1c(%ebp)
   1327e:	52                   	push   %edx
   1327f:	e8 c0 f7 ff ff       	call   12a44 <readChunk_pHYs>
   13284:	83 c4 10             	add    $0x10,%esp
   13287:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1328a:	e9 eb 00 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   1328f:	83 ec 08             	sub    $0x8,%esp
   13292:	68 30 f4 01 00       	push   $0x1f430
   13297:	ff 75 ec             	pushl  -0x14(%ebp)
   1329a:	e8 59 8c ff ff       	call   bef8 <lodepng_chunk_type_equals>
   1329f:	83 c4 10             	add    $0x10,%esp
   132a2:	84 c0                	test   %al,%al
   132a4:	74 24                	je     132ca <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
   132a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   132a9:	8b 55 08             	mov    0x8(%ebp),%edx
   132ac:	81 c2 98 00 00 00    	add    $0x98,%edx
   132b2:	83 ec 04             	sub    $0x4,%esp
   132b5:	50                   	push   %eax
   132b6:	ff 75 e4             	pushl  -0x1c(%ebp)
   132b9:	52                   	push   %edx
   132ba:	e8 54 f8 ff ff       	call   12b13 <readChunk_gAMA>
   132bf:	83 c4 10             	add    $0x10,%esp
   132c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
   132c5:	e9 b0 00 00 00       	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   132ca:	83 ec 08             	sub    $0x8,%esp
   132cd:	68 35 f4 01 00       	push   $0x1f435
   132d2:	ff 75 ec             	pushl  -0x14(%ebp)
   132d5:	e8 1e 8c ff ff       	call   bef8 <lodepng_chunk_type_equals>
   132da:	83 c4 10             	add    $0x10,%esp
   132dd:	84 c0                	test   %al,%al
   132df:	74 21                	je     13302 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
   132e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   132e4:	8b 55 08             	mov    0x8(%ebp),%edx
   132e7:	81 c2 98 00 00 00    	add    $0x98,%edx
   132ed:	83 ec 04             	sub    $0x4,%esp
   132f0:	50                   	push   %eax
   132f1:	ff 75 e4             	pushl  -0x1c(%ebp)
   132f4:	52                   	push   %edx
   132f5:	e8 88 f8 ff ff       	call   12b82 <readChunk_cHRM>
   132fa:	83 c4 10             	add    $0x10,%esp
   132fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
   13300:	eb 78                	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   13302:	83 ec 08             	sub    $0x8,%esp
   13305:	68 3a f4 01 00       	push   $0x1f43a
   1330a:	ff 75 ec             	pushl  -0x14(%ebp)
   1330d:	e8 e6 8b ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13312:	83 c4 10             	add    $0x10,%esp
   13315:	84 c0                	test   %al,%al
   13317:	74 21                	je     1333a <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
   13319:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1331c:	8b 55 08             	mov    0x8(%ebp),%edx
   1331f:	81 c2 98 00 00 00    	add    $0x98,%edx
   13325:	83 ec 04             	sub    $0x4,%esp
   13328:	50                   	push   %eax
   13329:	ff 75 e4             	pushl  -0x1c(%ebp)
   1332c:	52                   	push   %edx
   1332d:	e8 e4 fa ff ff       	call   12e16 <readChunk_sRGB>
   13332:	83 c4 10             	add    $0x10,%esp
   13335:	89 45 f0             	mov    %eax,-0x10(%ebp)
   13338:	eb 40                	jmp    1337a <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   1333a:	83 ec 08             	sub    $0x8,%esp
   1333d:	68 3f f4 01 00       	push   $0x1f43f
   13342:	ff 75 ec             	pushl  -0x14(%ebp)
   13345:	e8 ae 8b ff ff       	call   bef8 <lodepng_chunk_type_equals>
   1334a:	83 c4 10             	add    $0x10,%esp
   1334d:	84 c0                	test   %al,%al
   1334f:	74 22                	je     13373 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   13351:	8b 55 e8             	mov    -0x18(%ebp),%edx
   13354:	8b 45 08             	mov    0x8(%ebp),%eax
   13357:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1335a:	81 c1 98 00 00 00    	add    $0x98,%ecx
   13360:	52                   	push   %edx
   13361:	ff 75 e4             	pushl  -0x1c(%ebp)
   13364:	50                   	push   %eax
   13365:	51                   	push   %ecx
   13366:	e8 e1 fa ff ff       	call   12e4c <readChunk_iCCP>
   1336b:	83 c4 10             	add    $0x10,%esp
   1336e:	89 45 f0             	mov    %eax,-0x10(%ebp)
   13371:	eb 07                	jmp    1337a <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
   13373:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
   1337a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1337e:	75 29                	jne    133a9 <lodepng_inspect_chunk+0x374>
   13380:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13384:	75 23                	jne    133a9 <lodepng_inspect_chunk+0x374>
   13386:	8b 45 08             	mov    0x8(%ebp),%eax
   13389:	8b 40 18             	mov    0x18(%eax),%eax
   1338c:	85 c0                	test   %eax,%eax
   1338e:	75 19                	jne    133a9 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
   13390:	83 ec 0c             	sub    $0xc,%esp
   13393:	ff 75 ec             	pushl  -0x14(%ebp)
   13396:	e8 53 8c ff ff       	call   bfee <lodepng_chunk_check_crc>
   1339b:	83 c4 10             	add    $0x10,%esp
   1339e:	85 c0                	test   %eax,%eax
   133a0:	74 07                	je     133a9 <lodepng_inspect_chunk+0x374>
   133a2:	b8 39 00 00 00       	mov    $0x39,%eax
   133a7:	eb 03                	jmp    133ac <lodepng_inspect_chunk+0x377>
  }

  return error;
   133a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   133ac:	c9                   	leave  
   133ad:	c3                   	ret    

000133ae <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
   133ae:	55                   	push   %ebp
   133af:	89 e5                	mov    %esp,%ebp
   133b1:	56                   	push   %esi
   133b2:	53                   	push   %ebx
   133b3:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
   133b6:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
   133ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
   133c1:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
   133c8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   133cf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
   133d6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
   133dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
   133e4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
   133eb:	8b 45 08             	mov    0x8(%ebp),%eax
   133ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   133f4:	8b 45 10             	mov    0x10(%ebp),%eax
   133f7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   133fd:	8b 45 10             	mov    0x10(%ebp),%eax
   13400:	8b 10                	mov    (%eax),%edx
   13402:	8b 45 0c             	mov    0xc(%ebp),%eax
   13405:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
   13407:	83 ec 0c             	sub    $0xc,%esp
   1340a:	ff 75 1c             	pushl  0x1c(%ebp)
   1340d:	ff 75 18             	pushl  0x18(%ebp)
   13410:	ff 75 14             	pushl  0x14(%ebp)
   13413:	ff 75 10             	pushl  0x10(%ebp)
   13416:	ff 75 0c             	pushl  0xc(%ebp)
   13419:	e8 d3 da ff ff       	call   10ef1 <lodepng_inspect>
   1341e:	83 c4 20             	add    $0x20,%esp
   13421:	89 c2                	mov    %eax,%edx
   13423:	8b 45 14             	mov    0x14(%ebp),%eax
   13426:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
   1342c:	8b 45 14             	mov    0x14(%ebp),%eax
   1342f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13435:	85 c0                	test   %eax,%eax
   13437:	0f 85 24 0a 00 00    	jne    13e61 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
   1343d:	8b 45 14             	mov    0x14(%ebp),%eax
   13440:	8d 58 78             	lea    0x78(%eax),%ebx
   13443:	8b 45 14             	mov    0x14(%ebp),%eax
   13446:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   1344c:	8b 45 10             	mov    0x10(%ebp),%eax
   1344f:	8b 10                	mov    (%eax),%edx
   13451:	8b 45 0c             	mov    0xc(%ebp),%eax
   13454:	8b 00                	mov    (%eax),%eax
   13456:	53                   	push   %ebx
   13457:	51                   	push   %ecx
   13458:	52                   	push   %edx
   13459:	50                   	push   %eax
   1345a:	e8 76 97 ff ff       	call   cbd5 <lodepng_pixel_overflow>
   1345f:	83 c4 10             	add    $0x10,%esp
   13462:	85 c0                	test   %eax,%eax
   13464:	74 12                	je     13478 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
   13466:	8b 45 14             	mov    0x14(%ebp),%eax
   13469:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
   13470:	00 00 00 
   13473:	e9 ea 09 00 00       	jmp    13e62 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
   13478:	83 ec 0c             	sub    $0xc,%esp
   1347b:	ff 75 1c             	pushl  0x1c(%ebp)
   1347e:	e8 a6 3a ff ff       	call   6f29 <lodepng_malloc>
   13483:	83 c4 10             	add    $0x10,%esp
   13486:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
   13489:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1348d:	75 12                	jne    134a1 <decodeGeneric+0xf3>
   1348f:	8b 45 14             	mov    0x14(%ebp),%eax
   13492:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   13499:	00 00 00 
   1349c:	e9 c1 09 00 00       	jmp    13e62 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
   134a1:	8b 45 18             	mov    0x18(%ebp),%eax
   134a4:	83 c0 21             	add    $0x21,%eax
   134a7:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   134aa:	e9 81 06 00 00       	jmp    13b30 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
   134af:	8b 55 f0             	mov    -0x10(%ebp),%edx
   134b2:	8b 45 18             	mov    0x18(%ebp),%eax
   134b5:	29 c2                	sub    %eax,%edx
   134b7:	89 d0                	mov    %edx,%eax
   134b9:	83 c0 0c             	add    $0xc,%eax
   134bc:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   134bf:	7f 08                	jg     134c9 <decodeGeneric+0x11b>
   134c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   134c4:	3b 45 18             	cmp    0x18(%ebp),%eax
   134c7:	73 20                	jae    134e9 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   134c9:	8b 45 14             	mov    0x14(%ebp),%eax
   134cc:	8b 40 20             	mov    0x20(%eax),%eax
   134cf:	85 c0                	test   %eax,%eax
   134d1:	0f 85 72 06 00 00    	jne    13b49 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
   134d7:	8b 45 14             	mov    0x14(%ebp),%eax
   134da:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
   134e1:	00 00 00 
   134e4:	e9 6a 06 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
   134e9:	83 ec 0c             	sub    $0xc,%esp
   134ec:	ff 75 f0             	pushl  -0x10(%ebp)
   134ef:	e8 b7 89 ff ff       	call   beab <lodepng_chunk_length>
   134f4:	83 c4 10             	add    $0x10,%esp
   134f7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
   134fa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   134fd:	85 c0                	test   %eax,%eax
   134ff:	79 20                	jns    13521 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   13501:	8b 45 14             	mov    0x14(%ebp),%eax
   13504:	8b 40 20             	mov    0x20(%eax),%eax
   13507:	85 c0                	test   %eax,%eax
   13509:	0f 85 3d 06 00 00    	jne    13b4c <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
   1350f:	8b 45 14             	mov    0x14(%ebp),%eax
   13512:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
   13519:	00 00 00 
   1351c:	e9 32 06 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
   13521:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13524:	8b 45 18             	mov    0x18(%ebp),%eax
   13527:	29 c2                	sub    %eax,%edx
   13529:	89 d0                	mov    %edx,%eax
   1352b:	89 c2                	mov    %eax,%edx
   1352d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13530:	01 d0                	add    %edx,%eax
   13532:	83 c0 0c             	add    $0xc,%eax
   13535:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   13538:	7f 10                	jg     1354a <decodeGeneric+0x19c>
   1353a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1353d:	8d 50 0c             	lea    0xc(%eax),%edx
   13540:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13543:	01 d0                	add    %edx,%eax
   13545:	3b 45 18             	cmp    0x18(%ebp),%eax
   13548:	73 12                	jae    1355c <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
   1354a:	8b 45 14             	mov    0x14(%ebp),%eax
   1354d:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
   13554:	00 00 00 
   13557:	e9 f7 05 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
   1355c:	83 ec 0c             	sub    $0xc,%esp
   1355f:	ff 75 f0             	pushl  -0x10(%ebp)
   13562:	e8 7c 8a ff ff       	call   bfe3 <lodepng_chunk_data_const>
   13567:	83 c4 10             	add    $0x10,%esp
   1356a:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
   1356d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
   13574:	83 ec 08             	sub    $0x8,%esp
   13577:	68 44 f4 01 00       	push   $0x1f444
   1357c:	ff 75 f0             	pushl  -0x10(%ebp)
   1357f:	e8 74 89 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13584:	83 c4 10             	add    $0x10,%esp
   13587:	84 c0                	test   %al,%al
   13589:	74 79                	je     13604 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
   1358b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1358e:	83 ec 04             	sub    $0x4,%esp
   13591:	8d 55 bc             	lea    -0x44(%ebp),%edx
   13594:	52                   	push   %edx
   13595:	50                   	push   %eax
   13596:	ff 75 ec             	pushl  -0x14(%ebp)
   13599:	e8 4f 3a ff ff       	call   6fed <lodepng_addofl>
   1359e:	83 c4 10             	add    $0x10,%esp
   135a1:	85 c0                	test   %eax,%eax
   135a3:	74 12                	je     135b7 <decodeGeneric+0x209>
   135a5:	8b 45 14             	mov    0x14(%ebp),%eax
   135a8:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   135af:	00 00 00 
   135b2:	e9 9c 05 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
   135b7:	8b 45 bc             	mov    -0x44(%ebp),%eax
   135ba:	3b 45 1c             	cmp    0x1c(%ebp),%eax
   135bd:	7e 13                	jle    135d2 <decodeGeneric+0x224>
   135bf:	8b 45 14             	mov    0x14(%ebp),%eax
   135c2:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
   135c9:	00 00 00 
   135cc:	90                   	nop
   135cd:	e9 81 05 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
   135d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   135d5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   135d8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   135db:	01 ca                	add    %ecx,%edx
   135dd:	83 ec 04             	sub    $0x4,%esp
   135e0:	50                   	push   %eax
   135e1:	ff 75 d0             	pushl  -0x30(%ebp)
   135e4:	52                   	push   %edx
   135e5:	e8 7d 39 ff ff       	call   6f67 <lodepng_memcpy>
   135ea:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
   135ed:	8b 55 ec             	mov    -0x14(%ebp),%edx
   135f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   135f3:	01 d0                	add    %edx,%eax
   135f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
   135f8:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
   135ff:	e9 db 04 00 00       	jmp    13adf <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
   13604:	83 ec 08             	sub    $0x8,%esp
   13607:	68 49 f4 01 00       	push   $0x1f449
   1360c:	ff 75 f0             	pushl  -0x10(%ebp)
   1360f:	e8 e4 88 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13614:	83 c4 10             	add    $0x10,%esp
   13617:	84 c0                	test   %al,%al
   13619:	74 09                	je     13624 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
   1361b:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
   1361f:	e9 bb 04 00 00       	jmp    13adf <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
   13624:	83 ec 08             	sub    $0x8,%esp
   13627:	68 08 f4 01 00       	push   $0x1f408
   1362c:	ff 75 f0             	pushl  -0x10(%ebp)
   1362f:	e8 c4 88 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13634:	83 c4 10             	add    $0x10,%esp
   13637:	84 c0                	test   %al,%al
   13639:	74 44                	je     1367f <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
   1363b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1363e:	8b 55 14             	mov    0x14(%ebp),%edx
   13641:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   13647:	83 ec 04             	sub    $0x4,%esp
   1364a:	50                   	push   %eax
   1364b:	ff 75 d0             	pushl  -0x30(%ebp)
   1364e:	52                   	push   %edx
   1364f:	e8 ec e8 ff ff       	call   11f40 <readChunk_PLTE>
   13654:	83 c4 10             	add    $0x10,%esp
   13657:	89 c2                	mov    %eax,%edx
   13659:	8b 45 14             	mov    0x14(%ebp),%eax
   1365c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   13662:	8b 45 14             	mov    0x14(%ebp),%eax
   13665:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1366b:	85 c0                	test   %eax,%eax
   1366d:	0f 85 dc 04 00 00    	jne    13b4f <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
   13673:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
   1367a:	e9 60 04 00 00       	jmp    13adf <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
   1367f:	83 ec 08             	sub    $0x8,%esp
   13682:	68 0d f4 01 00       	push   $0x1f40d
   13687:	ff 75 f0             	pushl  -0x10(%ebp)
   1368a:	e8 69 88 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   1368f:	83 c4 10             	add    $0x10,%esp
   13692:	84 c0                	test   %al,%al
   13694:	74 3d                	je     136d3 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
   13696:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13699:	8b 55 14             	mov    0x14(%ebp),%edx
   1369c:	81 c2 a4 00 00 00    	add    $0xa4,%edx
   136a2:	83 ec 04             	sub    $0x4,%esp
   136a5:	50                   	push   %eax
   136a6:	ff 75 d0             	pushl  -0x30(%ebp)
   136a9:	52                   	push   %edx
   136aa:	e8 b1 e9 ff ff       	call   12060 <readChunk_tRNS>
   136af:	83 c4 10             	add    $0x10,%esp
   136b2:	89 c2                	mov    %eax,%edx
   136b4:	8b 45 14             	mov    0x14(%ebp),%eax
   136b7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   136bd:	8b 45 14             	mov    0x14(%ebp),%eax
   136c0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   136c6:	85 c0                	test   %eax,%eax
   136c8:	0f 84 11 04 00 00    	je     13adf <decodeGeneric+0x731>
   136ce:	e9 80 04 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
   136d3:	83 ec 08             	sub    $0x8,%esp
   136d6:	68 12 f4 01 00       	push   $0x1f412
   136db:	ff 75 f0             	pushl  -0x10(%ebp)
   136de:	e8 15 88 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   136e3:	83 c4 10             	add    $0x10,%esp
   136e6:	84 c0                	test   %al,%al
   136e8:	74 3d                	je     13727 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
   136ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   136ed:	8b 55 14             	mov    0x14(%ebp),%edx
   136f0:	81 c2 98 00 00 00    	add    $0x98,%edx
   136f6:	83 ec 04             	sub    $0x4,%esp
   136f9:	50                   	push   %eax
   136fa:	ff 75 d0             	pushl  -0x30(%ebp)
   136fd:	52                   	push   %edx
   136fe:	e8 c0 ea ff ff       	call   121c3 <readChunk_bKGD>
   13703:	83 c4 10             	add    $0x10,%esp
   13706:	89 c2                	mov    %eax,%edx
   13708:	8b 45 14             	mov    0x14(%ebp),%eax
   1370b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   13711:	8b 45 14             	mov    0x14(%ebp),%eax
   13714:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1371a:	85 c0                	test   %eax,%eax
   1371c:	0f 84 bd 03 00 00    	je     13adf <decodeGeneric+0x731>
   13722:	e9 2c 04 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
   13727:	83 ec 08             	sub    $0x8,%esp
   1372a:	68 17 f4 01 00       	push   $0x1f417
   1372f:	ff 75 f0             	pushl  -0x10(%ebp)
   13732:	e8 c1 87 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13737:	83 c4 10             	add    $0x10,%esp
   1373a:	84 c0                	test   %al,%al
   1373c:	74 4b                	je     13789 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
   1373e:	8b 45 14             	mov    0x14(%ebp),%eax
   13741:	8b 40 28             	mov    0x28(%eax),%eax
   13744:	85 c0                	test   %eax,%eax
   13746:	0f 84 93 03 00 00    	je     13adf <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
   1374c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1374f:	8b 55 14             	mov    0x14(%ebp),%edx
   13752:	81 c2 98 00 00 00    	add    $0x98,%edx
   13758:	83 ec 04             	sub    $0x4,%esp
   1375b:	50                   	push   %eax
   1375c:	ff 75 d0             	pushl  -0x30(%ebp)
   1375f:	52                   	push   %edx
   13760:	e8 e1 eb ff ff       	call   12346 <readChunk_tEXt>
   13765:	83 c4 10             	add    $0x10,%esp
   13768:	89 c2                	mov    %eax,%edx
   1376a:	8b 45 14             	mov    0x14(%ebp),%eax
   1376d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   13773:	8b 45 14             	mov    0x14(%ebp),%eax
   13776:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1377c:	85 c0                	test   %eax,%eax
   1377e:	0f 84 5b 03 00 00    	je     13adf <decodeGeneric+0x731>
   13784:	e9 ca 03 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
   13789:	83 ec 08             	sub    $0x8,%esp
   1378c:	68 1c f4 01 00       	push   $0x1f41c
   13791:	ff 75 f0             	pushl  -0x10(%ebp)
   13794:	e8 5f 87 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13799:	83 c4 10             	add    $0x10,%esp
   1379c:	84 c0                	test   %al,%al
   1379e:	74 4c                	je     137ec <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
   137a0:	8b 45 14             	mov    0x14(%ebp),%eax
   137a3:	8b 40 28             	mov    0x28(%eax),%eax
   137a6:	85 c0                	test   %eax,%eax
   137a8:	0f 84 31 03 00 00    	je     13adf <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
   137ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   137b1:	8b 45 14             	mov    0x14(%ebp),%eax
   137b4:	8b 4d 14             	mov    0x14(%ebp),%ecx
   137b7:	81 c1 98 00 00 00    	add    $0x98,%ecx
   137bd:	52                   	push   %edx
   137be:	ff 75 d0             	pushl  -0x30(%ebp)
   137c1:	50                   	push   %eax
   137c2:	51                   	push   %ecx
   137c3:	e8 ca ec ff ff       	call   12492 <readChunk_zTXt>
   137c8:	83 c4 10             	add    $0x10,%esp
   137cb:	89 c2                	mov    %eax,%edx
   137cd:	8b 45 14             	mov    0x14(%ebp),%eax
   137d0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   137d6:	8b 45 14             	mov    0x14(%ebp),%eax
   137d9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   137df:	85 c0                	test   %eax,%eax
   137e1:	0f 84 f8 02 00 00    	je     13adf <decodeGeneric+0x731>
   137e7:	e9 67 03 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
   137ec:	83 ec 08             	sub    $0x8,%esp
   137ef:	68 21 f4 01 00       	push   $0x1f421
   137f4:	ff 75 f0             	pushl  -0x10(%ebp)
   137f7:	e8 fc 86 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   137fc:	83 c4 10             	add    $0x10,%esp
   137ff:	84 c0                	test   %al,%al
   13801:	74 4c                	je     1384f <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
   13803:	8b 45 14             	mov    0x14(%ebp),%eax
   13806:	8b 40 28             	mov    0x28(%eax),%eax
   13809:	85 c0                	test   %eax,%eax
   1380b:	0f 84 ce 02 00 00    	je     13adf <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
   13811:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   13814:	8b 45 14             	mov    0x14(%ebp),%eax
   13817:	8b 4d 14             	mov    0x14(%ebp),%ecx
   1381a:	81 c1 98 00 00 00    	add    $0x98,%ecx
   13820:	52                   	push   %edx
   13821:	ff 75 d0             	pushl  -0x30(%ebp)
   13824:	50                   	push   %eax
   13825:	51                   	push   %ecx
   13826:	e8 23 ee ff ff       	call   1264e <readChunk_iTXt>
   1382b:	83 c4 10             	add    $0x10,%esp
   1382e:	89 c2                	mov    %eax,%edx
   13830:	8b 45 14             	mov    0x14(%ebp),%eax
   13833:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
   13839:	8b 45 14             	mov    0x14(%ebp),%eax
   1383c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13842:	85 c0                	test   %eax,%eax
   13844:	0f 84 95 02 00 00    	je     13adf <decodeGeneric+0x731>
   1384a:	e9 04 03 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
   1384f:	83 ec 08             	sub    $0x8,%esp
   13852:	68 26 f4 01 00       	push   $0x1f426
   13857:	ff 75 f0             	pushl  -0x10(%ebp)
   1385a:	e8 99 86 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   1385f:	83 c4 10             	add    $0x10,%esp
   13862:	84 c0                	test   %al,%al
   13864:	74 3d                	je     138a3 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
   13866:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13869:	8b 55 14             	mov    0x14(%ebp),%edx
   1386c:	81 c2 98 00 00 00    	add    $0x98,%edx
   13872:	83 ec 04             	sub    $0x4,%esp
   13875:	50                   	push   %eax
   13876:	ff 75 d0             	pushl  -0x30(%ebp)
   13879:	52                   	push   %edx
   1387a:	e8 25 f1 ff ff       	call   129a4 <readChunk_tIME>
   1387f:	83 c4 10             	add    $0x10,%esp
   13882:	89 c2                	mov    %eax,%edx
   13884:	8b 45 14             	mov    0x14(%ebp),%eax
   13887:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1388d:	8b 45 14             	mov    0x14(%ebp),%eax
   13890:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13896:	85 c0                	test   %eax,%eax
   13898:	0f 84 41 02 00 00    	je     13adf <decodeGeneric+0x731>
   1389e:	e9 b0 02 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
   138a3:	83 ec 08             	sub    $0x8,%esp
   138a6:	68 2b f4 01 00       	push   $0x1f42b
   138ab:	ff 75 f0             	pushl  -0x10(%ebp)
   138ae:	e8 45 86 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   138b3:	83 c4 10             	add    $0x10,%esp
   138b6:	84 c0                	test   %al,%al
   138b8:	74 3d                	je     138f7 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
   138ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   138bd:	8b 55 14             	mov    0x14(%ebp),%edx
   138c0:	81 c2 98 00 00 00    	add    $0x98,%edx
   138c6:	83 ec 04             	sub    $0x4,%esp
   138c9:	50                   	push   %eax
   138ca:	ff 75 d0             	pushl  -0x30(%ebp)
   138cd:	52                   	push   %edx
   138ce:	e8 71 f1 ff ff       	call   12a44 <readChunk_pHYs>
   138d3:	83 c4 10             	add    $0x10,%esp
   138d6:	89 c2                	mov    %eax,%edx
   138d8:	8b 45 14             	mov    0x14(%ebp),%eax
   138db:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   138e1:	8b 45 14             	mov    0x14(%ebp),%eax
   138e4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   138ea:	85 c0                	test   %eax,%eax
   138ec:	0f 84 ed 01 00 00    	je     13adf <decodeGeneric+0x731>
   138f2:	e9 5c 02 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
   138f7:	83 ec 08             	sub    $0x8,%esp
   138fa:	68 30 f4 01 00       	push   $0x1f430
   138ff:	ff 75 f0             	pushl  -0x10(%ebp)
   13902:	e8 f1 85 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13907:	83 c4 10             	add    $0x10,%esp
   1390a:	84 c0                	test   %al,%al
   1390c:	74 3d                	je     1394b <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
   1390e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13911:	8b 55 14             	mov    0x14(%ebp),%edx
   13914:	81 c2 98 00 00 00    	add    $0x98,%edx
   1391a:	83 ec 04             	sub    $0x4,%esp
   1391d:	50                   	push   %eax
   1391e:	ff 75 d0             	pushl  -0x30(%ebp)
   13921:	52                   	push   %edx
   13922:	e8 ec f1 ff ff       	call   12b13 <readChunk_gAMA>
   13927:	83 c4 10             	add    $0x10,%esp
   1392a:	89 c2                	mov    %eax,%edx
   1392c:	8b 45 14             	mov    0x14(%ebp),%eax
   1392f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   13935:	8b 45 14             	mov    0x14(%ebp),%eax
   13938:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1393e:	85 c0                	test   %eax,%eax
   13940:	0f 84 99 01 00 00    	je     13adf <decodeGeneric+0x731>
   13946:	e9 08 02 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   1394b:	83 ec 08             	sub    $0x8,%esp
   1394e:	68 35 f4 01 00       	push   $0x1f435
   13953:	ff 75 f0             	pushl  -0x10(%ebp)
   13956:	e8 9d 85 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   1395b:	83 c4 10             	add    $0x10,%esp
   1395e:	84 c0                	test   %al,%al
   13960:	74 3d                	je     1399f <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   13962:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13965:	8b 55 14             	mov    0x14(%ebp),%edx
   13968:	81 c2 98 00 00 00    	add    $0x98,%edx
   1396e:	83 ec 04             	sub    $0x4,%esp
   13971:	50                   	push   %eax
   13972:	ff 75 d0             	pushl  -0x30(%ebp)
   13975:	52                   	push   %edx
   13976:	e8 07 f2 ff ff       	call   12b82 <readChunk_cHRM>
   1397b:	83 c4 10             	add    $0x10,%esp
   1397e:	89 c2                	mov    %eax,%edx
   13980:	8b 45 14             	mov    0x14(%ebp),%eax
   13983:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   13989:	8b 45 14             	mov    0x14(%ebp),%eax
   1398c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13992:	85 c0                	test   %eax,%eax
   13994:	0f 84 45 01 00 00    	je     13adf <decodeGeneric+0x731>
   1399a:	e9 b4 01 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   1399f:	83 ec 08             	sub    $0x8,%esp
   139a2:	68 3a f4 01 00       	push   $0x1f43a
   139a7:	ff 75 f0             	pushl  -0x10(%ebp)
   139aa:	e8 49 85 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   139af:	83 c4 10             	add    $0x10,%esp
   139b2:	84 c0                	test   %al,%al
   139b4:	74 3d                	je     139f3 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   139b6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   139b9:	8b 55 14             	mov    0x14(%ebp),%edx
   139bc:	81 c2 98 00 00 00    	add    $0x98,%edx
   139c2:	83 ec 04             	sub    $0x4,%esp
   139c5:	50                   	push   %eax
   139c6:	ff 75 d0             	pushl  -0x30(%ebp)
   139c9:	52                   	push   %edx
   139ca:	e8 47 f4 ff ff       	call   12e16 <readChunk_sRGB>
   139cf:	83 c4 10             	add    $0x10,%esp
   139d2:	89 c2                	mov    %eax,%edx
   139d4:	8b 45 14             	mov    0x14(%ebp),%eax
   139d7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   139dd:	8b 45 14             	mov    0x14(%ebp),%eax
   139e0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   139e6:	85 c0                	test   %eax,%eax
   139e8:	0f 84 f1 00 00 00    	je     13adf <decodeGeneric+0x731>
   139ee:	e9 60 01 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   139f3:	83 ec 08             	sub    $0x8,%esp
   139f6:	68 3f f4 01 00       	push   $0x1f43f
   139fb:	ff 75 f0             	pushl  -0x10(%ebp)
   139fe:	e8 f5 84 ff ff       	call   bef8 <lodepng_chunk_type_equals>
   13a03:	83 c4 10             	add    $0x10,%esp
   13a06:	84 c0                	test   %al,%al
   13a08:	74 3e                	je     13a48 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   13a0a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   13a0d:	8b 45 14             	mov    0x14(%ebp),%eax
   13a10:	8b 4d 14             	mov    0x14(%ebp),%ecx
   13a13:	81 c1 98 00 00 00    	add    $0x98,%ecx
   13a19:	52                   	push   %edx
   13a1a:	ff 75 d0             	pushl  -0x30(%ebp)
   13a1d:	50                   	push   %eax
   13a1e:	51                   	push   %ecx
   13a1f:	e8 28 f4 ff ff       	call   12e4c <readChunk_iCCP>
   13a24:	83 c4 10             	add    $0x10,%esp
   13a27:	89 c2                	mov    %eax,%edx
   13a29:	8b 45 14             	mov    0x14(%ebp),%eax
   13a2c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   13a32:	8b 45 14             	mov    0x14(%ebp),%eax
   13a35:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13a3b:	85 c0                	test   %eax,%eax
   13a3d:	0f 84 9c 00 00 00    	je     13adf <decodeGeneric+0x731>
   13a43:	e9 0b 01 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   13a48:	8b 45 14             	mov    0x14(%ebp),%eax
   13a4b:	8b 40 1c             	mov    0x1c(%eax),%eax
   13a4e:	85 c0                	test   %eax,%eax
   13a50:	75 24                	jne    13a76 <decodeGeneric+0x6c8>
   13a52:	83 ec 0c             	sub    $0xc,%esp
   13a55:	ff 75 f0             	pushl  -0x10(%ebp)
   13a58:	e8 30 85 ff ff       	call   bf8d <lodepng_chunk_ancillary>
   13a5d:	83 c4 10             	add    $0x10,%esp
   13a60:	84 c0                	test   %al,%al
   13a62:	75 12                	jne    13a76 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   13a64:	8b 45 14             	mov    0x14(%ebp),%eax
   13a67:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   13a6e:	00 00 00 
   13a71:	e9 dd 00 00 00       	jmp    13b53 <decodeGeneric+0x7a5>
      }

      unknown = 1;
   13a76:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   13a7d:	8b 45 14             	mov    0x14(%ebp),%eax
   13a80:	8b 40 2c             	mov    0x2c(%eax),%eax
   13a83:	85 c0                	test   %eax,%eax
   13a85:	74 58                	je     13adf <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   13a87:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13a8a:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   13a8d:	83 c0 58             	add    $0x58,%eax
   13a90:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13a97:	8b 45 14             	mov    0x14(%ebp),%eax
   13a9a:	01 d0                	add    %edx,%eax
   13a9c:	8d 50 10             	lea    0x10(%eax),%edx
   13a9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   13aa2:	83 e8 01             	sub    $0x1,%eax
   13aa5:	83 c0 54             	add    $0x54,%eax
   13aa8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   13aaf:	8b 45 14             	mov    0x14(%ebp),%eax
   13ab2:	01 c8                	add    %ecx,%eax
   13ab4:	83 c0 14             	add    $0x14,%eax
   13ab7:	83 ec 04             	sub    $0x4,%esp
   13aba:	ff 75 f0             	pushl  -0x10(%ebp)
   13abd:	52                   	push   %edx
   13abe:	50                   	push   %eax
   13abf:	e8 15 88 ff ff       	call   c2d9 <lodepng_chunk_append>
   13ac4:	83 c4 10             	add    $0x10,%esp
   13ac7:	89 c2                	mov    %eax,%edx
   13ac9:	8b 45 14             	mov    0x14(%ebp),%eax
   13acc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   13ad2:	8b 45 14             	mov    0x14(%ebp),%eax
   13ad5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13adb:	85 c0                	test   %eax,%eax
   13add:	75 73                	jne    13b52 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   13adf:	8b 45 14             	mov    0x14(%ebp),%eax
   13ae2:	8b 40 18             	mov    0x18(%eax),%eax
   13ae5:	85 c0                	test   %eax,%eax
   13ae7:	75 27                	jne    13b10 <decodeGeneric+0x762>
   13ae9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13aed:	75 21                	jne    13b10 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   13aef:	83 ec 0c             	sub    $0xc,%esp
   13af2:	ff 75 f0             	pushl  -0x10(%ebp)
   13af5:	e8 f4 84 ff ff       	call   bfee <lodepng_chunk_check_crc>
   13afa:	83 c4 10             	add    $0x10,%esp
   13afd:	85 c0                	test   %eax,%eax
   13aff:	74 0f                	je     13b10 <decodeGeneric+0x762>
   13b01:	8b 45 14             	mov    0x14(%ebp),%eax
   13b04:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   13b0b:	00 00 00 
   13b0e:	eb 43                	jmp    13b53 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   13b10:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   13b14:	75 1a                	jne    13b30 <decodeGeneric+0x782>
   13b16:	8b 55 1c             	mov    0x1c(%ebp),%edx
   13b19:	8b 45 18             	mov    0x18(%ebp),%eax
   13b1c:	01 d0                	add    %edx,%eax
   13b1e:	83 ec 08             	sub    $0x8,%esp
   13b21:	50                   	push   %eax
   13b22:	ff 75 f0             	pushl  -0x10(%ebp)
   13b25:	e8 3f 86 ff ff       	call   c169 <lodepng_chunk_next_const>
   13b2a:	83 c4 10             	add    $0x10,%esp
   13b2d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   13b30:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   13b34:	75 1d                	jne    13b53 <decodeGeneric+0x7a5>
   13b36:	8b 45 14             	mov    0x14(%ebp),%eax
   13b39:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13b3f:	85 c0                	test   %eax,%eax
   13b41:	0f 84 68 f9 ff ff    	je     134af <decodeGeneric+0x101>
   13b47:	eb 0a                	jmp    13b53 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   13b49:	90                   	nop
   13b4a:	eb 07                	jmp    13b53 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   13b4c:	90                   	nop
   13b4d:	eb 04                	jmp    13b53 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   13b4f:	90                   	nop
   13b50:	eb 01                	jmp    13b53 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   13b52:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   13b53:	8b 45 14             	mov    0x14(%ebp),%eax
   13b56:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13b5c:	85 c0                	test   %eax,%eax
   13b5e:	75 28                	jne    13b88 <decodeGeneric+0x7da>
   13b60:	8b 45 14             	mov    0x14(%ebp),%eax
   13b63:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   13b69:	83 f8 03             	cmp    $0x3,%eax
   13b6c:	75 1a                	jne    13b88 <decodeGeneric+0x7da>
   13b6e:	8b 45 14             	mov    0x14(%ebp),%eax
   13b71:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   13b77:	85 c0                	test   %eax,%eax
   13b79:	75 0d                	jne    13b88 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   13b7b:	8b 45 14             	mov    0x14(%ebp),%eax
   13b7e:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   13b85:	00 00 00 
  }

  if(!state->error) {
   13b88:	8b 45 14             	mov    0x14(%ebp),%eax
   13b8b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13b91:	85 c0                	test   %eax,%eax
   13b93:	0f 85 d2 01 00 00    	jne    13d6b <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   13b99:	8b 45 14             	mov    0x14(%ebp),%eax
   13b9c:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   13ba2:	85 c0                	test   %eax,%eax
   13ba4:	75 3a                	jne    13be0 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   13ba6:	8b 45 14             	mov    0x14(%ebp),%eax
   13ba9:	05 a4 00 00 00       	add    $0xa4,%eax
   13bae:	83 ec 0c             	sub    $0xc,%esp
   13bb1:	50                   	push   %eax
   13bb2:	e8 8e 8e ff ff       	call   ca45 <lodepng_get_bpp>
   13bb7:	83 c4 10             	add    $0x10,%esp
   13bba:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   13bbd:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   13bc0:	8b 45 10             	mov    0x10(%ebp),%eax
   13bc3:	8b 10                	mov    (%eax),%edx
   13bc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bc8:	8b 00                	mov    (%eax),%eax
   13bca:	83 ec 04             	sub    $0x4,%esp
   13bcd:	51                   	push   %ecx
   13bce:	52                   	push   %edx
   13bcf:	50                   	push   %eax
   13bd0:	e8 cf 8f ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   13bd5:	83 c4 10             	add    $0x10,%esp
   13bd8:	89 45 e8             	mov    %eax,-0x18(%ebp)
   13bdb:	e9 60 01 00 00       	jmp    13d40 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   13be0:	8b 45 14             	mov    0x14(%ebp),%eax
   13be3:	05 a4 00 00 00       	add    $0xa4,%eax
   13be8:	83 ec 0c             	sub    $0xc,%esp
   13beb:	50                   	push   %eax
   13bec:	e8 54 8e ff ff       	call   ca45 <lodepng_get_bpp>
   13bf1:	83 c4 10             	add    $0x10,%esp
   13bf4:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   13bf7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   13bfe:	8b 45 c8             	mov    -0x38(%ebp),%eax
   13c01:	8b 55 10             	mov    0x10(%ebp),%edx
   13c04:	8b 12                	mov    (%edx),%edx
   13c06:	83 c2 07             	add    $0x7,%edx
   13c09:	89 d1                	mov    %edx,%ecx
   13c0b:	c1 e9 03             	shr    $0x3,%ecx
   13c0e:	8b 55 0c             	mov    0xc(%ebp),%edx
   13c11:	8b 12                	mov    (%edx),%edx
   13c13:	83 c2 07             	add    $0x7,%edx
   13c16:	c1 ea 03             	shr    $0x3,%edx
   13c19:	83 ec 04             	sub    $0x4,%esp
   13c1c:	50                   	push   %eax
   13c1d:	51                   	push   %ecx
   13c1e:	52                   	push   %edx
   13c1f:	e8 80 8f ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   13c24:	83 c4 10             	add    $0x10,%esp
   13c27:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   13c2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c2d:	8b 00                	mov    (%eax),%eax
   13c2f:	83 f8 04             	cmp    $0x4,%eax
   13c32:	76 2c                	jbe    13c60 <decodeGeneric+0x8b2>
   13c34:	8b 45 c8             	mov    -0x38(%ebp),%eax
   13c37:	8b 55 10             	mov    0x10(%ebp),%edx
   13c3a:	8b 12                	mov    (%edx),%edx
   13c3c:	83 c2 07             	add    $0x7,%edx
   13c3f:	89 d1                	mov    %edx,%ecx
   13c41:	c1 e9 03             	shr    $0x3,%ecx
   13c44:	8b 55 0c             	mov    0xc(%ebp),%edx
   13c47:	8b 12                	mov    (%edx),%edx
   13c49:	83 c2 03             	add    $0x3,%edx
   13c4c:	c1 ea 03             	shr    $0x3,%edx
   13c4f:	83 ec 04             	sub    $0x4,%esp
   13c52:	50                   	push   %eax
   13c53:	51                   	push   %ecx
   13c54:	52                   	push   %edx
   13c55:	e8 4a 8f ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   13c5a:	83 c4 10             	add    $0x10,%esp
   13c5d:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   13c60:	8b 45 c8             	mov    -0x38(%ebp),%eax
   13c63:	8b 55 10             	mov    0x10(%ebp),%edx
   13c66:	8b 12                	mov    (%edx),%edx
   13c68:	83 c2 03             	add    $0x3,%edx
   13c6b:	89 d1                	mov    %edx,%ecx
   13c6d:	c1 e9 03             	shr    $0x3,%ecx
   13c70:	8b 55 0c             	mov    0xc(%ebp),%edx
   13c73:	8b 12                	mov    (%edx),%edx
   13c75:	83 c2 03             	add    $0x3,%edx
   13c78:	c1 ea 02             	shr    $0x2,%edx
   13c7b:	83 ec 04             	sub    $0x4,%esp
   13c7e:	50                   	push   %eax
   13c7f:	51                   	push   %ecx
   13c80:	52                   	push   %edx
   13c81:	e8 1e 8f ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   13c86:	83 c4 10             	add    $0x10,%esp
   13c89:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   13c8c:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c8f:	8b 00                	mov    (%eax),%eax
   13c91:	83 f8 02             	cmp    $0x2,%eax
   13c94:	76 2c                	jbe    13cc2 <decodeGeneric+0x914>
   13c96:	8b 45 c8             	mov    -0x38(%ebp),%eax
   13c99:	8b 55 10             	mov    0x10(%ebp),%edx
   13c9c:	8b 12                	mov    (%edx),%edx
   13c9e:	83 c2 03             	add    $0x3,%edx
   13ca1:	89 d1                	mov    %edx,%ecx
   13ca3:	c1 e9 02             	shr    $0x2,%ecx
   13ca6:	8b 55 0c             	mov    0xc(%ebp),%edx
   13ca9:	8b 12                	mov    (%edx),%edx
   13cab:	83 c2 01             	add    $0x1,%edx
   13cae:	c1 ea 02             	shr    $0x2,%edx
   13cb1:	83 ec 04             	sub    $0x4,%esp
   13cb4:	50                   	push   %eax
   13cb5:	51                   	push   %ecx
   13cb6:	52                   	push   %edx
   13cb7:	e8 e8 8e ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   13cbc:	83 c4 10             	add    $0x10,%esp
   13cbf:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   13cc2:	8b 45 c8             	mov    -0x38(%ebp),%eax
   13cc5:	8b 55 10             	mov    0x10(%ebp),%edx
   13cc8:	8b 12                	mov    (%edx),%edx
   13cca:	83 c2 01             	add    $0x1,%edx
   13ccd:	89 d1                	mov    %edx,%ecx
   13ccf:	c1 e9 02             	shr    $0x2,%ecx
   13cd2:	8b 55 0c             	mov    0xc(%ebp),%edx
   13cd5:	8b 12                	mov    (%edx),%edx
   13cd7:	83 c2 01             	add    $0x1,%edx
   13cda:	d1 ea                	shr    %edx
   13cdc:	83 ec 04             	sub    $0x4,%esp
   13cdf:	50                   	push   %eax
   13ce0:	51                   	push   %ecx
   13ce1:	52                   	push   %edx
   13ce2:	e8 bd 8e ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   13ce7:	83 c4 10             	add    $0x10,%esp
   13cea:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   13ced:	8b 45 0c             	mov    0xc(%ebp),%eax
   13cf0:	8b 00                	mov    (%eax),%eax
   13cf2:	83 f8 01             	cmp    $0x1,%eax
   13cf5:	76 27                	jbe    13d1e <decodeGeneric+0x970>
   13cf7:	8b 45 c8             	mov    -0x38(%ebp),%eax
   13cfa:	8b 55 10             	mov    0x10(%ebp),%edx
   13cfd:	8b 12                	mov    (%edx),%edx
   13cff:	83 c2 01             	add    $0x1,%edx
   13d02:	89 d1                	mov    %edx,%ecx
   13d04:	d1 e9                	shr    %ecx
   13d06:	8b 55 0c             	mov    0xc(%ebp),%edx
   13d09:	8b 12                	mov    (%edx),%edx
   13d0b:	d1 ea                	shr    %edx
   13d0d:	83 ec 04             	sub    $0x4,%esp
   13d10:	50                   	push   %eax
   13d11:	51                   	push   %ecx
   13d12:	52                   	push   %edx
   13d13:	e8 8c 8e ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   13d18:	83 c4 10             	add    $0x10,%esp
   13d1b:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   13d1e:	8b 55 c8             	mov    -0x38(%ebp),%edx
   13d21:	8b 45 10             	mov    0x10(%ebp),%eax
   13d24:	8b 00                	mov    (%eax),%eax
   13d26:	d1 e8                	shr    %eax
   13d28:	89 c1                	mov    %eax,%ecx
   13d2a:	8b 45 0c             	mov    0xc(%ebp),%eax
   13d2d:	8b 00                	mov    (%eax),%eax
   13d2f:	83 ec 04             	sub    $0x4,%esp
   13d32:	52                   	push   %edx
   13d33:	51                   	push   %ecx
   13d34:	50                   	push   %eax
   13d35:	e8 6a 8e ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   13d3a:	83 c4 10             	add    $0x10,%esp
   13d3d:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   13d40:	8b 45 14             	mov    0x14(%ebp),%eax
   13d43:	83 ec 08             	sub    $0x8,%esp
   13d46:	50                   	push   %eax
   13d47:	ff 75 ec             	pushl  -0x14(%ebp)
   13d4a:	ff 75 d8             	pushl  -0x28(%ebp)
   13d4d:	ff 75 e8             	pushl  -0x18(%ebp)
   13d50:	8d 45 c0             	lea    -0x40(%ebp),%eax
   13d53:	50                   	push   %eax
   13d54:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   13d57:	50                   	push   %eax
   13d58:	e8 87 7c ff ff       	call   b9e4 <zlib_decompress>
   13d5d:	83 c4 20             	add    $0x20,%esp
   13d60:	89 c2                	mov    %eax,%edx
   13d62:	8b 45 14             	mov    0x14(%ebp),%eax
   13d65:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   13d6b:	8b 45 14             	mov    0x14(%ebp),%eax
   13d6e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13d74:	85 c0                	test   %eax,%eax
   13d76:	75 15                	jne    13d8d <decodeGeneric+0x9df>
   13d78:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13d7b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   13d7e:	74 0d                	je     13d8d <decodeGeneric+0x9df>
   13d80:	8b 45 14             	mov    0x14(%ebp),%eax
   13d83:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   13d8a:	00 00 00 
  lodepng_free(idat);
   13d8d:	83 ec 0c             	sub    $0xc,%esp
   13d90:	ff 75 d8             	pushl  -0x28(%ebp)
   13d93:	e8 b2 31 ff ff       	call   6f4a <lodepng_free>
   13d98:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   13d9b:	8b 45 14             	mov    0x14(%ebp),%eax
   13d9e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13da4:	85 c0                	test   %eax,%eax
   13da6:	75 4f                	jne    13df7 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   13da8:	8b 45 14             	mov    0x14(%ebp),%eax
   13dab:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   13db1:	8b 45 10             	mov    0x10(%ebp),%eax
   13db4:	8b 10                	mov    (%eax),%edx
   13db6:	8b 45 0c             	mov    0xc(%ebp),%eax
   13db9:	8b 00                	mov    (%eax),%eax
   13dbb:	83 ec 04             	sub    $0x4,%esp
   13dbe:	51                   	push   %ecx
   13dbf:	52                   	push   %edx
   13dc0:	50                   	push   %eax
   13dc1:	e8 be 8d ff ff       	call   cb84 <lodepng_get_raw_size>
   13dc6:	83 c4 10             	add    $0x10,%esp
   13dc9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   13dcc:	83 ec 0c             	sub    $0xc,%esp
   13dcf:	ff 75 e4             	pushl  -0x1c(%ebp)
   13dd2:	e8 52 31 ff ff       	call   6f29 <lodepng_malloc>
   13dd7:	83 c4 10             	add    $0x10,%esp
   13dda:	89 c2                	mov    %eax,%edx
   13ddc:	8b 45 08             	mov    0x8(%ebp),%eax
   13ddf:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   13de1:	8b 45 08             	mov    0x8(%ebp),%eax
   13de4:	8b 00                	mov    (%eax),%eax
   13de6:	85 c0                	test   %eax,%eax
   13de8:	75 0d                	jne    13df7 <decodeGeneric+0xa49>
   13dea:	8b 45 14             	mov    0x14(%ebp),%eax
   13ded:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   13df4:	00 00 00 
  }
  if(!state->error) {
   13df7:	8b 45 14             	mov    0x14(%ebp),%eax
   13dfa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13e00:	85 c0                	test   %eax,%eax
   13e02:	75 4c                	jne    13e50 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   13e04:	8b 45 08             	mov    0x8(%ebp),%eax
   13e07:	8b 00                	mov    (%eax),%eax
   13e09:	83 ec 04             	sub    $0x4,%esp
   13e0c:	ff 75 e4             	pushl  -0x1c(%ebp)
   13e0f:	6a 00                	push   $0x0
   13e11:	50                   	push   %eax
   13e12:	e8 83 31 ff ff       	call   6f9a <lodepng_memset>
   13e17:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   13e1a:	8b 45 14             	mov    0x14(%ebp),%eax
   13e1d:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   13e23:	8b 45 10             	mov    0x10(%ebp),%eax
   13e26:	8b 18                	mov    (%eax),%ebx
   13e28:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e2b:	8b 08                	mov    (%eax),%ecx
   13e2d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   13e30:	8b 45 08             	mov    0x8(%ebp),%eax
   13e33:	8b 00                	mov    (%eax),%eax
   13e35:	83 ec 0c             	sub    $0xc,%esp
   13e38:	56                   	push   %esi
   13e39:	53                   	push   %ebx
   13e3a:	51                   	push   %ecx
   13e3b:	52                   	push   %edx
   13e3c:	50                   	push   %eax
   13e3d:	e8 05 df ff ff       	call   11d47 <postProcessScanlines>
   13e42:	83 c4 20             	add    $0x20,%esp
   13e45:	89 c2                	mov    %eax,%edx
   13e47:	8b 45 14             	mov    0x14(%ebp),%eax
   13e4a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   13e50:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13e53:	83 ec 0c             	sub    $0xc,%esp
   13e56:	50                   	push   %eax
   13e57:	e8 ee 30 ff ff       	call   6f4a <lodepng_free>
   13e5c:	83 c4 10             	add    $0x10,%esp
   13e5f:	eb 01                	jmp    13e62 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   13e61:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   13e62:	8d 65 f8             	lea    -0x8(%ebp),%esp
   13e65:	5b                   	pop    %ebx
   13e66:	5e                   	pop    %esi
   13e67:	5d                   	pop    %ebp
   13e68:	c3                   	ret    

00013e69 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   13e69:	55                   	push   %ebp
   13e6a:	89 e5                	mov    %esp,%ebp
   13e6c:	56                   	push   %esi
   13e6d:	53                   	push   %ebx
   13e6e:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   13e71:	8b 45 08             	mov    0x8(%ebp),%eax
   13e74:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   13e7a:	83 ec 08             	sub    $0x8,%esp
   13e7d:	ff 75 1c             	pushl  0x1c(%ebp)
   13e80:	ff 75 18             	pushl  0x18(%ebp)
   13e83:	ff 75 14             	pushl  0x14(%ebp)
   13e86:	ff 75 10             	pushl  0x10(%ebp)
   13e89:	ff 75 0c             	pushl  0xc(%ebp)
   13e8c:	ff 75 08             	pushl  0x8(%ebp)
   13e8f:	e8 1a f5 ff ff       	call   133ae <decodeGeneric>
   13e94:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   13e97:	8b 45 14             	mov    0x14(%ebp),%eax
   13e9a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13ea0:	85 c0                	test   %eax,%eax
   13ea2:	74 0e                	je     13eb2 <lodepng_decode+0x49>
   13ea4:	8b 45 14             	mov    0x14(%ebp),%eax
   13ea7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13ead:	e9 55 01 00 00       	jmp    14007 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   13eb2:	8b 45 14             	mov    0x14(%ebp),%eax
   13eb5:	8b 40 24             	mov    0x24(%eax),%eax
   13eb8:	85 c0                	test   %eax,%eax
   13eba:	74 20                	je     13edc <lodepng_decode+0x73>
   13ebc:	8b 45 14             	mov    0x14(%ebp),%eax
   13ebf:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   13ec5:	8b 45 14             	mov    0x14(%ebp),%eax
   13ec8:	83 c0 78             	add    $0x78,%eax
   13ecb:	83 ec 08             	sub    $0x8,%esp
   13ece:	52                   	push   %edx
   13ecf:	50                   	push   %eax
   13ed0:	e8 56 89 ff ff       	call   c82b <lodepng_color_mode_equal>
   13ed5:	83 c4 10             	add    $0x10,%esp
   13ed8:	85 c0                	test   %eax,%eax
   13eda:	74 54                	je     13f30 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   13edc:	8b 45 14             	mov    0x14(%ebp),%eax
   13edf:	8b 40 24             	mov    0x24(%eax),%eax
   13ee2:	85 c0                	test   %eax,%eax
   13ee4:	0f 85 13 01 00 00    	jne    13ffd <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   13eea:	8b 45 14             	mov    0x14(%ebp),%eax
   13eed:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   13ef3:	8b 45 14             	mov    0x14(%ebp),%eax
   13ef6:	83 c0 78             	add    $0x78,%eax
   13ef9:	83 ec 08             	sub    $0x8,%esp
   13efc:	52                   	push   %edx
   13efd:	50                   	push   %eax
   13efe:	e8 3f 88 ff ff       	call   c742 <lodepng_color_mode_copy>
   13f03:	83 c4 10             	add    $0x10,%esp
   13f06:	89 c2                	mov    %eax,%edx
   13f08:	8b 45 14             	mov    0x14(%ebp),%eax
   13f0b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   13f11:	8b 45 14             	mov    0x14(%ebp),%eax
   13f14:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13f1a:	85 c0                	test   %eax,%eax
   13f1c:	0f 84 db 00 00 00    	je     13ffd <lodepng_decode+0x194>
   13f22:	8b 45 14             	mov    0x14(%ebp),%eax
   13f25:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13f2b:	e9 d7 00 00 00       	jmp    14007 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   13f30:	8b 45 08             	mov    0x8(%ebp),%eax
   13f33:	8b 00                	mov    (%eax),%eax
   13f35:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   13f38:	8b 45 14             	mov    0x14(%ebp),%eax
   13f3b:	8b 40 78             	mov    0x78(%eax),%eax
   13f3e:	83 f8 02             	cmp    $0x2,%eax
   13f41:	74 20                	je     13f63 <lodepng_decode+0xfa>
   13f43:	8b 45 14             	mov    0x14(%ebp),%eax
   13f46:	8b 40 78             	mov    0x78(%eax),%eax
   13f49:	83 f8 06             	cmp    $0x6,%eax
   13f4c:	74 15                	je     13f63 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   13f4e:	8b 45 14             	mov    0x14(%ebp),%eax
   13f51:	8b 40 7c             	mov    0x7c(%eax),%eax
   13f54:	83 f8 08             	cmp    $0x8,%eax
   13f57:	74 0a                	je     13f63 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   13f59:	b8 38 00 00 00       	mov    $0x38,%eax
   13f5e:	e9 a4 00 00 00       	jmp    14007 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   13f63:	8b 45 14             	mov    0x14(%ebp),%eax
   13f66:	8d 48 78             	lea    0x78(%eax),%ecx
   13f69:	8b 45 10             	mov    0x10(%ebp),%eax
   13f6c:	8b 10                	mov    (%eax),%edx
   13f6e:	8b 45 0c             	mov    0xc(%ebp),%eax
   13f71:	8b 00                	mov    (%eax),%eax
   13f73:	83 ec 04             	sub    $0x4,%esp
   13f76:	51                   	push   %ecx
   13f77:	52                   	push   %edx
   13f78:	50                   	push   %eax
   13f79:	e8 06 8c ff ff       	call   cb84 <lodepng_get_raw_size>
   13f7e:	83 c4 10             	add    $0x10,%esp
   13f81:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   13f84:	83 ec 0c             	sub    $0xc,%esp
   13f87:	ff 75 f0             	pushl  -0x10(%ebp)
   13f8a:	e8 9a 2f ff ff       	call   6f29 <lodepng_malloc>
   13f8f:	83 c4 10             	add    $0x10,%esp
   13f92:	89 c2                	mov    %eax,%edx
   13f94:	8b 45 08             	mov    0x8(%ebp),%eax
   13f97:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   13f99:	8b 45 08             	mov    0x8(%ebp),%eax
   13f9c:	8b 00                	mov    (%eax),%eax
   13f9e:	85 c0                	test   %eax,%eax
   13fa0:	75 0f                	jne    13fb1 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   13fa2:	8b 45 14             	mov    0x14(%ebp),%eax
   13fa5:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   13fac:	00 00 00 
   13faf:	eb 3c                	jmp    13fed <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   13fb1:	8b 45 10             	mov    0x10(%ebp),%eax
   13fb4:	8b 08                	mov    (%eax),%ecx
   13fb6:	8b 45 0c             	mov    0xc(%ebp),%eax
   13fb9:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   13fbb:	8b 45 14             	mov    0x14(%ebp),%eax
   13fbe:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   13fc4:	8b 45 14             	mov    0x14(%ebp),%eax
   13fc7:	8d 58 78             	lea    0x78(%eax),%ebx
   13fca:	8b 45 08             	mov    0x8(%ebp),%eax
   13fcd:	8b 00                	mov    (%eax),%eax
   13fcf:	83 ec 08             	sub    $0x8,%esp
   13fd2:	51                   	push   %ecx
   13fd3:	52                   	push   %edx
   13fd4:	56                   	push   %esi
   13fd5:	53                   	push   %ebx
   13fd6:	ff 75 f4             	pushl  -0xc(%ebp)
   13fd9:	50                   	push   %eax
   13fda:	e8 51 b6 ff ff       	call   f630 <lodepng_convert>
   13fdf:	83 c4 20             	add    $0x20,%esp
   13fe2:	89 c2                	mov    %eax,%edx
   13fe4:	8b 45 14             	mov    0x14(%ebp),%eax
   13fe7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   13fed:	83 ec 0c             	sub    $0xc,%esp
   13ff0:	ff 75 f4             	pushl  -0xc(%ebp)
   13ff3:	e8 52 2f ff ff       	call   6f4a <lodepng_free>
   13ff8:	83 c4 10             	add    $0x10,%esp
   13ffb:	eb 01                	jmp    13ffe <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   13ffd:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   13ffe:	8b 45 14             	mov    0x14(%ebp),%eax
   14001:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   14007:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1400a:	5b                   	pop    %ebx
   1400b:	5e                   	pop    %esi
   1400c:	5d                   	pop    %ebp
   1400d:	c3                   	ret    

0001400e <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   1400e:	55                   	push   %ebp
   1400f:	89 e5                	mov    %esp,%ebp
   14011:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   14017:	83 ec 0c             	sub    $0xc,%esp
   1401a:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   14020:	50                   	push   %eax
   14021:	e8 d9 01 00 00       	call   141ff <lodepng_state_init>
   14026:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   14029:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1402c:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   14032:	8b 45 20             	mov    0x20(%ebp),%eax
   14035:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   1403b:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   14042:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   14045:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   1404c:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   1404f:	83 ec 08             	sub    $0x8,%esp
   14052:	ff 75 18             	pushl  0x18(%ebp)
   14055:	ff 75 14             	pushl  0x14(%ebp)
   14058:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1405e:	50                   	push   %eax
   1405f:	ff 75 10             	pushl  0x10(%ebp)
   14062:	ff 75 0c             	pushl  0xc(%ebp)
   14065:	ff 75 08             	pushl  0x8(%ebp)
   14068:	e8 fc fd ff ff       	call   13e69 <lodepng_decode>
   1406d:	83 c4 20             	add    $0x20,%esp
   14070:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   14073:	83 ec 0c             	sub    $0xc,%esp
   14076:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1407c:	50                   	push   %eax
   1407d:	e8 d7 01 00 00       	call   14259 <lodepng_state_cleanup>
   14082:	83 c4 10             	add    $0x10,%esp
  return error;
   14085:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14088:	c9                   	leave  
   14089:	c3                   	ret    

0001408a <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   1408a:	55                   	push   %ebp
   1408b:	89 e5                	mov    %esp,%ebp
   1408d:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   14090:	83 ec 04             	sub    $0x4,%esp
   14093:	6a 08                	push   $0x8
   14095:	6a 06                	push   $0x6
   14097:	ff 75 18             	pushl  0x18(%ebp)
   1409a:	ff 75 14             	pushl  0x14(%ebp)
   1409d:	ff 75 10             	pushl  0x10(%ebp)
   140a0:	ff 75 0c             	pushl  0xc(%ebp)
   140a3:	ff 75 08             	pushl  0x8(%ebp)
   140a6:	e8 63 ff ff ff       	call   1400e <lodepng_decode_memory>
   140ab:	83 c4 20             	add    $0x20,%esp
}
   140ae:	c9                   	leave  
   140af:	c3                   	ret    

000140b0 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   140b0:	55                   	push   %ebp
   140b1:	89 e5                	mov    %esp,%ebp
   140b3:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   140b6:	83 ec 04             	sub    $0x4,%esp
   140b9:	6a 08                	push   $0x8
   140bb:	6a 02                	push   $0x2
   140bd:	ff 75 18             	pushl  0x18(%ebp)
   140c0:	ff 75 14             	pushl  0x14(%ebp)
   140c3:	ff 75 10             	pushl  0x10(%ebp)
   140c6:	ff 75 0c             	pushl  0xc(%ebp)
   140c9:	ff 75 08             	pushl  0x8(%ebp)
   140cc:	e8 3d ff ff ff       	call   1400e <lodepng_decode_memory>
   140d1:	83 c4 20             	add    $0x20,%esp
}
   140d4:	c9                   	leave  
   140d5:	c3                   	ret    

000140d6 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   140d6:	55                   	push   %ebp
   140d7:	89 e5                	mov    %esp,%ebp
   140d9:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   140dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   140e3:	8b 45 08             	mov    0x8(%ebp),%eax
   140e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   140ec:	8b 45 10             	mov    0x10(%ebp),%eax
   140ef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   140f5:	8b 45 10             	mov    0x10(%ebp),%eax
   140f8:	8b 10                	mov    (%eax),%edx
   140fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   140fd:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   140ff:	83 ec 04             	sub    $0x4,%esp
   14102:	ff 75 14             	pushl  0x14(%ebp)
   14105:	8d 45 ec             	lea    -0x14(%ebp),%eax
   14108:	50                   	push   %eax
   14109:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1410c:	50                   	push   %eax
   1410d:	e8 70 32 ff ff       	call   7382 <lodepng_load_file>
   14112:	83 c4 10             	add    $0x10,%esp
   14115:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   14118:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1411c:	75 25                	jne    14143 <lodepng_decode_file+0x6d>
   1411e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14121:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14124:	83 ec 04             	sub    $0x4,%esp
   14127:	ff 75 1c             	pushl  0x1c(%ebp)
   1412a:	ff 75 18             	pushl  0x18(%ebp)
   1412d:	52                   	push   %edx
   1412e:	50                   	push   %eax
   1412f:	ff 75 10             	pushl  0x10(%ebp)
   14132:	ff 75 0c             	pushl  0xc(%ebp)
   14135:	ff 75 08             	pushl  0x8(%ebp)
   14138:	e8 d1 fe ff ff       	call   1400e <lodepng_decode_memory>
   1413d:	83 c4 20             	add    $0x20,%esp
   14140:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   14143:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14146:	83 ec 0c             	sub    $0xc,%esp
   14149:	50                   	push   %eax
   1414a:	e8 fb 2d ff ff       	call   6f4a <lodepng_free>
   1414f:	83 c4 10             	add    $0x10,%esp
  return error;
   14152:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14155:	c9                   	leave  
   14156:	c3                   	ret    

00014157 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   14157:	55                   	push   %ebp
   14158:	89 e5                	mov    %esp,%ebp
   1415a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   1415d:	83 ec 08             	sub    $0x8,%esp
   14160:	6a 08                	push   $0x8
   14162:	6a 06                	push   $0x6
   14164:	ff 75 14             	pushl  0x14(%ebp)
   14167:	ff 75 10             	pushl  0x10(%ebp)
   1416a:	ff 75 0c             	pushl  0xc(%ebp)
   1416d:	ff 75 08             	pushl  0x8(%ebp)
   14170:	e8 61 ff ff ff       	call   140d6 <lodepng_decode_file>
   14175:	83 c4 20             	add    $0x20,%esp
}
   14178:	c9                   	leave  
   14179:	c3                   	ret    

0001417a <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   1417a:	55                   	push   %ebp
   1417b:	89 e5                	mov    %esp,%ebp
   1417d:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   14180:	83 ec 08             	sub    $0x8,%esp
   14183:	6a 08                	push   $0x8
   14185:	6a 02                	push   $0x2
   14187:	ff 75 14             	pushl  0x14(%ebp)
   1418a:	ff 75 10             	pushl  0x10(%ebp)
   1418d:	ff 75 0c             	pushl  0xc(%ebp)
   14190:	ff 75 08             	pushl  0x8(%ebp)
   14193:	e8 3e ff ff ff       	call   140d6 <lodepng_decode_file>
   14198:	83 c4 20             	add    $0x20,%esp
}
   1419b:	c9                   	leave  
   1419c:	c3                   	ret    

0001419d <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   1419d:	55                   	push   %ebp
   1419e:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   141a0:	8b 45 08             	mov    0x8(%ebp),%eax
   141a3:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   141aa:	8b 45 08             	mov    0x8(%ebp),%eax
   141ad:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   141b4:	8b 45 08             	mov    0x8(%ebp),%eax
   141b7:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   141be:	8b 45 08             	mov    0x8(%ebp),%eax
   141c1:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   141c8:	8b 45 08             	mov    0x8(%ebp),%eax
   141cb:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   141d2:	8b 45 08             	mov    0x8(%ebp),%eax
   141d5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   141dc:	8b 45 08             	mov    0x8(%ebp),%eax
   141df:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   141e6:	8b 45 08             	mov    0x8(%ebp),%eax
   141e9:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   141f0:	8b 45 08             	mov    0x8(%ebp),%eax
   141f3:	50                   	push   %eax
   141f4:	e8 ff 7a ff ff       	call   bcf8 <lodepng_decompress_settings_init>
   141f9:	83 c4 04             	add    $0x4,%esp
}
   141fc:	90                   	nop
   141fd:	c9                   	leave  
   141fe:	c3                   	ret    

000141ff <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   141ff:	55                   	push   %ebp
   14200:	89 e5                	mov    %esp,%ebp
   14202:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   14205:	8b 45 08             	mov    0x8(%ebp),%eax
   14208:	50                   	push   %eax
   14209:	e8 8f ff ff ff       	call   1419d <lodepng_decoder_settings_init>
   1420e:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   14211:	8b 45 08             	mov    0x8(%ebp),%eax
   14214:	83 c0 38             	add    $0x38,%eax
   14217:	83 ec 0c             	sub    $0xc,%esp
   1421a:	50                   	push   %eax
   1421b:	e8 fc 30 00 00       	call   1731c <lodepng_encoder_settings_init>
   14220:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   14223:	8b 45 08             	mov    0x8(%ebp),%eax
   14226:	83 c0 78             	add    $0x78,%eax
   14229:	83 ec 0c             	sub    $0xc,%esp
   1422c:	50                   	push   %eax
   1422d:	e8 06 84 ff ff       	call   c638 <lodepng_color_mode_init>
   14232:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   14235:	8b 45 08             	mov    0x8(%ebp),%eax
   14238:	05 98 00 00 00       	add    $0x98,%eax
   1423d:	83 ec 0c             	sub    $0xc,%esp
   14240:	50                   	push   %eax
   14241:	e8 89 93 ff ff       	call   d5cf <lodepng_info_init>
   14246:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   14249:	8b 45 08             	mov    0x8(%ebp),%eax
   1424c:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   14253:	00 00 00 
}
   14256:	90                   	nop
   14257:	c9                   	leave  
   14258:	c3                   	ret    

00014259 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   14259:	55                   	push   %ebp
   1425a:	89 e5                	mov    %esp,%ebp
   1425c:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   1425f:	8b 45 08             	mov    0x8(%ebp),%eax
   14262:	83 c0 78             	add    $0x78,%eax
   14265:	83 ec 0c             	sub    $0xc,%esp
   14268:	50                   	push   %eax
   14269:	e8 bd 84 ff ff       	call   c72b <lodepng_color_mode_cleanup>
   1426e:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   14271:	8b 45 08             	mov    0x8(%ebp),%eax
   14274:	05 98 00 00 00       	add    $0x98,%eax
   14279:	83 ec 0c             	sub    $0xc,%esp
   1427c:	50                   	push   %eax
   1427d:	e8 2e 94 ff ff       	call   d6b0 <lodepng_info_cleanup>
   14282:	83 c4 10             	add    $0x10,%esp
}
   14285:	90                   	nop
   14286:	c9                   	leave  
   14287:	c3                   	ret    

00014288 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   14288:	55                   	push   %ebp
   14289:	89 e5                	mov    %esp,%ebp
   1428b:	57                   	push   %edi
   1428c:	56                   	push   %esi
   1428d:	53                   	push   %ebx
   1428e:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   14291:	83 ec 0c             	sub    $0xc,%esp
   14294:	ff 75 08             	pushl  0x8(%ebp)
   14297:	e8 bd ff ff ff       	call   14259 <lodepng_state_cleanup>
   1429c:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   1429f:	8b 55 08             	mov    0x8(%ebp),%edx
   142a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   142a5:	89 c3                	mov    %eax,%ebx
   142a7:	b8 60 00 00 00       	mov    $0x60,%eax
   142ac:	89 d7                	mov    %edx,%edi
   142ae:	89 de                	mov    %ebx,%esi
   142b0:	89 c1                	mov    %eax,%ecx
   142b2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   142b4:	8b 45 08             	mov    0x8(%ebp),%eax
   142b7:	83 c0 78             	add    $0x78,%eax
   142ba:	83 ec 0c             	sub    $0xc,%esp
   142bd:	50                   	push   %eax
   142be:	e8 75 83 ff ff       	call   c638 <lodepng_color_mode_init>
   142c3:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   142c6:	8b 45 08             	mov    0x8(%ebp),%eax
   142c9:	05 98 00 00 00       	add    $0x98,%eax
   142ce:	83 ec 0c             	sub    $0xc,%esp
   142d1:	50                   	push   %eax
   142d2:	e8 f8 92 ff ff       	call   d5cf <lodepng_info_init>
   142d7:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   142da:	8b 45 0c             	mov    0xc(%ebp),%eax
   142dd:	8d 50 78             	lea    0x78(%eax),%edx
   142e0:	8b 45 08             	mov    0x8(%ebp),%eax
   142e3:	83 c0 78             	add    $0x78,%eax
   142e6:	83 ec 08             	sub    $0x8,%esp
   142e9:	52                   	push   %edx
   142ea:	50                   	push   %eax
   142eb:	e8 52 84 ff ff       	call   c742 <lodepng_color_mode_copy>
   142f0:	83 c4 10             	add    $0x10,%esp
   142f3:	89 c2                	mov    %eax,%edx
   142f5:	8b 45 08             	mov    0x8(%ebp),%eax
   142f8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   142fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14301:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   14307:	85 c0                	test   %eax,%eax
   14309:	75 36                	jne    14341 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   1430b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1430e:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   14314:	8b 45 08             	mov    0x8(%ebp),%eax
   14317:	05 98 00 00 00       	add    $0x98,%eax
   1431c:	83 ec 08             	sub    $0x8,%esp
   1431f:	52                   	push   %edx
   14320:	50                   	push   %eax
   14321:	e8 dd 93 ff ff       	call   d703 <lodepng_info_copy>
   14326:	83 c4 10             	add    $0x10,%esp
   14329:	89 c2                	mov    %eax,%edx
   1432b:	8b 45 08             	mov    0x8(%ebp),%eax
   1432e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   14334:	8b 45 08             	mov    0x8(%ebp),%eax
   14337:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1433d:	85 c0                	test   %eax,%eax
   1433f:	eb 01                	jmp    14342 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   14341:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   14342:	8d 65 f4             	lea    -0xc(%ebp),%esp
   14345:	5b                   	pop    %ebx
   14346:	5e                   	pop    %esi
   14347:	5f                   	pop    %edi
   14348:	5d                   	pop    %ebp
   14349:	c3                   	ret    

0001434a <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   1434a:	55                   	push   %ebp
   1434b:	89 e5                	mov    %esp,%ebp
   1434d:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   14350:	8b 45 08             	mov    0x8(%ebp),%eax
   14353:	8b 40 04             	mov    0x4(%eax),%eax
   14356:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   14359:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   1435d:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   14361:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   14365:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   14369:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   1436d:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   14371:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   14375:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   14379:	8b 45 08             	mov    0x8(%ebp),%eax
   1437c:	8b 40 04             	mov    0x4(%eax),%eax
   1437f:	83 c0 08             	add    $0x8,%eax
   14382:	50                   	push   %eax
   14383:	ff 75 08             	pushl  0x8(%ebp)
   14386:	e8 f8 2d ff ff       	call   7183 <ucvector_resize>
   1438b:	83 c4 08             	add    $0x8,%esp
   1438e:	85 c0                	test   %eax,%eax
   14390:	75 07                	jne    14399 <writeSignature+0x4f>
   14392:	b8 53 00 00 00       	mov    $0x53,%eax
   14397:	eb 1e                	jmp    143b7 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   14399:	8b 45 08             	mov    0x8(%ebp),%eax
   1439c:	8b 10                	mov    (%eax),%edx
   1439e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   143a1:	01 c2                	add    %eax,%edx
   143a3:	6a 08                	push   $0x8
   143a5:	8d 45 f4             	lea    -0xc(%ebp),%eax
   143a8:	50                   	push   %eax
   143a9:	52                   	push   %edx
   143aa:	e8 b8 2b ff ff       	call   6f67 <lodepng_memcpy>
   143af:	83 c4 0c             	add    $0xc,%esp
  return 0;
   143b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   143b7:	c9                   	leave  
   143b8:	c3                   	ret    

000143b9 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   143b9:	55                   	push   %ebp
   143ba:	89 e5                	mov    %esp,%ebp
   143bc:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   143bf:	68 ec f3 01 00       	push   $0x1f3ec
   143c4:	6a 0d                	push   $0xd
   143c6:	ff 75 08             	pushl  0x8(%ebp)
   143c9:	8d 45 f4             	lea    -0xc(%ebp),%eax
   143cc:	50                   	push   %eax
   143cd:	e8 cf 7f ff ff       	call   c3a1 <lodepng_chunk_init>
   143d2:	83 c4 10             	add    $0x10,%esp
   143d5:	89 45 fc             	mov    %eax,-0x4(%ebp)
   143d8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   143dc:	74 05                	je     143e3 <addChunk_IHDR+0x2a>
   143de:	8b 45 fc             	mov    -0x4(%ebp),%eax
   143e1:	eb 6d                	jmp    14450 <addChunk_IHDR+0x97>
  data = chunk + 8;
   143e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143e6:	83 c0 08             	add    $0x8,%eax
   143e9:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   143ec:	ff 75 0c             	pushl  0xc(%ebp)
   143ef:	ff 75 f8             	pushl  -0x8(%ebp)
   143f2:	e8 f3 2e ff ff       	call   72ea <lodepng_set32bitInt>
   143f7:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   143fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
   143fd:	83 c0 04             	add    $0x4,%eax
   14400:	ff 75 10             	pushl  0x10(%ebp)
   14403:	50                   	push   %eax
   14404:	e8 e1 2e ff ff       	call   72ea <lodepng_set32bitInt>
   14409:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   1440c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1440f:	83 c0 08             	add    $0x8,%eax
   14412:	8b 55 18             	mov    0x18(%ebp),%edx
   14415:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   14417:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1441a:	83 c0 09             	add    $0x9,%eax
   1441d:	8b 55 14             	mov    0x14(%ebp),%edx
   14420:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   14422:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14425:	83 c0 0a             	add    $0xa,%eax
   14428:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   1442b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1442e:	83 c0 0b             	add    $0xb,%eax
   14431:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   14434:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14437:	83 c0 0c             	add    $0xc,%eax
   1443a:	8b 55 1c             	mov    0x1c(%ebp),%edx
   1443d:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   1443f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14442:	50                   	push   %eax
   14443:	e8 02 7c ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14448:	83 c4 04             	add    $0x4,%esp
  return 0;
   1444b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14450:	c9                   	leave  
   14451:	c3                   	ret    

00014452 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   14452:	55                   	push   %ebp
   14453:	89 e5                	mov    %esp,%ebp
   14455:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   14458:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   1445f:	8b 45 0c             	mov    0xc(%ebp),%eax
   14462:	8b 50 0c             	mov    0xc(%eax),%edx
   14465:	89 d0                	mov    %edx,%eax
   14467:	01 c0                	add    %eax,%eax
   14469:	01 d0                	add    %edx,%eax
   1446b:	68 08 f4 01 00       	push   $0x1f408
   14470:	50                   	push   %eax
   14471:	ff 75 08             	pushl  0x8(%ebp)
   14474:	8d 45 f0             	lea    -0x10(%ebp),%eax
   14477:	50                   	push   %eax
   14478:	e8 24 7f ff ff       	call   c3a1 <lodepng_chunk_init>
   1447d:	83 c4 10             	add    $0x10,%esp
   14480:	89 45 f4             	mov    %eax,-0xc(%ebp)
   14483:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14487:	74 08                	je     14491 <addChunk_PLTE+0x3f>
   14489:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1448c:	e9 95 00 00 00       	jmp    14526 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   14491:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   14498:	eb 70                	jmp    1450a <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   1449a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   1449d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   144a0:	8d 50 01             	lea    0x1(%eax),%edx
   144a3:	89 55 f8             	mov    %edx,-0x8(%ebp)
   144a6:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   144a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   144ac:	8b 40 08             	mov    0x8(%eax),%eax
   144af:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   144b2:	c1 e1 02             	shl    $0x2,%ecx
   144b5:	01 c8                	add    %ecx,%eax
   144b7:	0f b6 00             	movzbl (%eax),%eax
   144ba:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   144bc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   144bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
   144c2:	8d 50 01             	lea    0x1(%eax),%edx
   144c5:	89 55 f8             	mov    %edx,-0x8(%ebp)
   144c8:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   144cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   144ce:	8b 40 08             	mov    0x8(%eax),%eax
   144d1:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   144d4:	c1 e1 02             	shl    $0x2,%ecx
   144d7:	83 c1 01             	add    $0x1,%ecx
   144da:	01 c8                	add    %ecx,%eax
   144dc:	0f b6 00             	movzbl (%eax),%eax
   144df:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   144e1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   144e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   144e7:	8d 50 01             	lea    0x1(%eax),%edx
   144ea:	89 55 f8             	mov    %edx,-0x8(%ebp)
   144ed:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   144f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   144f3:	8b 40 08             	mov    0x8(%eax),%eax
   144f6:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   144f9:	c1 e1 02             	shl    $0x2,%ecx
   144fc:	83 c1 02             	add    $0x2,%ecx
   144ff:	01 c8                	add    %ecx,%eax
   14501:	0f b6 00             	movzbl (%eax),%eax
   14504:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   14506:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1450a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1450d:	8b 40 0c             	mov    0xc(%eax),%eax
   14510:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   14513:	75 85                	jne    1449a <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   14515:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14518:	50                   	push   %eax
   14519:	e8 2c 7b ff ff       	call   c04a <lodepng_chunk_generate_crc>
   1451e:	83 c4 04             	add    $0x4,%esp
  return 0;
   14521:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14526:	c9                   	leave  
   14527:	c3                   	ret    

00014528 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   14528:	55                   	push   %ebp
   14529:	89 e5                	mov    %esp,%ebp
   1452b:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   1452e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   14535:	8b 45 0c             	mov    0xc(%ebp),%eax
   14538:	8b 00                	mov    (%eax),%eax
   1453a:	83 f8 03             	cmp    $0x3,%eax
   1453d:	0f 85 ae 00 00 00    	jne    145f1 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   14543:	8b 45 0c             	mov    0xc(%ebp),%eax
   14546:	8b 40 0c             	mov    0xc(%eax),%eax
   14549:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   1454c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1454f:	8b 40 0c             	mov    0xc(%eax),%eax
   14552:	89 45 fc             	mov    %eax,-0x4(%ebp)
   14555:	eb 23                	jmp    1457a <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   14557:	8b 45 0c             	mov    0xc(%ebp),%eax
   1455a:	8b 40 08             	mov    0x8(%eax),%eax
   1455d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   14560:	83 ea 01             	sub    $0x1,%edx
   14563:	c1 e2 02             	shl    $0x2,%edx
   14566:	83 c2 03             	add    $0x3,%edx
   14569:	01 d0                	add    %edx,%eax
   1456b:	0f b6 00             	movzbl (%eax),%eax
   1456e:	3c ff                	cmp    $0xff,%al
   14570:	75 10                	jne    14582 <addChunk_tRNS+0x5a>
      --amount;
   14572:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   14576:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   1457a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1457e:	75 d7                	jne    14557 <addChunk_tRNS+0x2f>
   14580:	eb 01                	jmp    14583 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   14582:	90                   	nop
      --amount;
    }
    if(amount) {
   14583:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   14587:	0f 84 63 01 00 00    	je     146f0 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   1458d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14590:	68 0d f4 01 00       	push   $0x1f40d
   14595:	50                   	push   %eax
   14596:	ff 75 08             	pushl  0x8(%ebp)
   14599:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1459c:	50                   	push   %eax
   1459d:	e8 ff 7d ff ff       	call   c3a1 <lodepng_chunk_init>
   145a2:	83 c4 10             	add    $0x10,%esp
   145a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
   145a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   145ac:	74 08                	je     145b6 <addChunk_tRNS+0x8e>
   145ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145b1:	e9 52 01 00 00       	jmp    14708 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   145b6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   145bd:	eb 25                	jmp    145e4 <addChunk_tRNS+0xbc>
   145bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   145c2:	8b 55 fc             	mov    -0x4(%ebp),%edx
   145c5:	83 c2 08             	add    $0x8,%edx
   145c8:	01 c2                	add    %eax,%edx
   145ca:	8b 45 0c             	mov    0xc(%ebp),%eax
   145cd:	8b 40 08             	mov    0x8(%eax),%eax
   145d0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   145d3:	c1 e1 02             	shl    $0x2,%ecx
   145d6:	83 c1 03             	add    $0x3,%ecx
   145d9:	01 c8                	add    %ecx,%eax
   145db:	0f b6 00             	movzbl (%eax),%eax
   145de:	88 02                	mov    %al,(%edx)
   145e0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   145e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   145e7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   145ea:	75 d3                	jne    145bf <addChunk_tRNS+0x97>
   145ec:	e9 ff 00 00 00       	jmp    146f0 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   145f1:	8b 45 0c             	mov    0xc(%ebp),%eax
   145f4:	8b 00                	mov    (%eax),%eax
   145f6:	85 c0                	test   %eax,%eax
   145f8:	75 59                	jne    14653 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   145fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   145fd:	8b 40 10             	mov    0x10(%eax),%eax
   14600:	85 c0                	test   %eax,%eax
   14602:	0f 84 e8 00 00 00    	je     146f0 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   14608:	68 0d f4 01 00       	push   $0x1f40d
   1460d:	6a 02                	push   $0x2
   1460f:	ff 75 08             	pushl  0x8(%ebp)
   14612:	8d 45 e8             	lea    -0x18(%ebp),%eax
   14615:	50                   	push   %eax
   14616:	e8 86 7d ff ff       	call   c3a1 <lodepng_chunk_init>
   1461b:	83 c4 10             	add    $0x10,%esp
   1461e:	89 45 f0             	mov    %eax,-0x10(%ebp)
   14621:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14625:	74 08                	je     1462f <addChunk_tRNS+0x107>
   14627:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1462a:	e9 d9 00 00 00       	jmp    14708 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   1462f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14632:	8d 50 08             	lea    0x8(%eax),%edx
   14635:	8b 45 0c             	mov    0xc(%ebp),%eax
   14638:	8b 40 14             	mov    0x14(%eax),%eax
   1463b:	c1 e8 08             	shr    $0x8,%eax
   1463e:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   14640:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14643:	8d 50 09             	lea    0x9(%eax),%edx
   14646:	8b 45 0c             	mov    0xc(%ebp),%eax
   14649:	8b 40 14             	mov    0x14(%eax),%eax
   1464c:	88 02                	mov    %al,(%edx)
   1464e:	e9 9d 00 00 00       	jmp    146f0 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   14653:	8b 45 0c             	mov    0xc(%ebp),%eax
   14656:	8b 00                	mov    (%eax),%eax
   14658:	83 f8 02             	cmp    $0x2,%eax
   1465b:	0f 85 8f 00 00 00    	jne    146f0 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   14661:	8b 45 0c             	mov    0xc(%ebp),%eax
   14664:	8b 40 10             	mov    0x10(%eax),%eax
   14667:	85 c0                	test   %eax,%eax
   14669:	0f 84 81 00 00 00    	je     146f0 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   1466f:	68 0d f4 01 00       	push   $0x1f40d
   14674:	6a 06                	push   $0x6
   14676:	ff 75 08             	pushl  0x8(%ebp)
   14679:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1467c:	50                   	push   %eax
   1467d:	e8 1f 7d ff ff       	call   c3a1 <lodepng_chunk_init>
   14682:	83 c4 10             	add    $0x10,%esp
   14685:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14688:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1468c:	74 05                	je     14693 <addChunk_tRNS+0x16b>
   1468e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14691:	eb 75                	jmp    14708 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   14693:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14696:	8d 50 08             	lea    0x8(%eax),%edx
   14699:	8b 45 0c             	mov    0xc(%ebp),%eax
   1469c:	8b 40 14             	mov    0x14(%eax),%eax
   1469f:	c1 e8 08             	shr    $0x8,%eax
   146a2:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   146a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146a7:	8d 50 09             	lea    0x9(%eax),%edx
   146aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   146ad:	8b 40 14             	mov    0x14(%eax),%eax
   146b0:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   146b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146b5:	8d 50 0a             	lea    0xa(%eax),%edx
   146b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   146bb:	8b 40 18             	mov    0x18(%eax),%eax
   146be:	c1 e8 08             	shr    $0x8,%eax
   146c1:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   146c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146c6:	8d 50 0b             	lea    0xb(%eax),%edx
   146c9:	8b 45 0c             	mov    0xc(%ebp),%eax
   146cc:	8b 40 18             	mov    0x18(%eax),%eax
   146cf:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   146d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146d4:	8d 50 0c             	lea    0xc(%eax),%edx
   146d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   146da:	8b 40 1c             	mov    0x1c(%eax),%eax
   146dd:	c1 e8 08             	shr    $0x8,%eax
   146e0:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   146e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146e5:	8d 50 0d             	lea    0xd(%eax),%edx
   146e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   146eb:	8b 40 1c             	mov    0x1c(%eax),%eax
   146ee:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   146f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146f3:	85 c0                	test   %eax,%eax
   146f5:	74 0c                	je     14703 <addChunk_tRNS+0x1db>
   146f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   146fa:	50                   	push   %eax
   146fb:	e8 4a 79 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14700:	83 c4 04             	add    $0x4,%esp
  return 0;
   14703:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14708:	c9                   	leave  
   14709:	c3                   	ret    

0001470a <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   1470a:	55                   	push   %ebp
   1470b:	89 e5                	mov    %esp,%ebp
   1470d:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   14710:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   14717:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   1471e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   14725:	83 ec 0c             	sub    $0xc,%esp
   14728:	ff 75 14             	pushl  0x14(%ebp)
   1472b:	ff 75 10             	pushl  0x10(%ebp)
   1472e:	ff 75 0c             	pushl  0xc(%ebp)
   14731:	8d 45 ec             	lea    -0x14(%ebp),%eax
   14734:	50                   	push   %eax
   14735:	8d 45 f0             	lea    -0x10(%ebp),%eax
   14738:	50                   	push   %eax
   14739:	e8 fb 74 ff ff       	call   bc39 <zlib_compress>
   1473e:	83 c4 20             	add    $0x20,%esp
   14741:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   14744:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14748:	75 1b                	jne    14765 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   1474a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1474d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14750:	50                   	push   %eax
   14751:	68 44 f4 01 00       	push   $0x1f444
   14756:	52                   	push   %edx
   14757:	ff 75 08             	pushl  0x8(%ebp)
   1475a:	e8 ea 7c ff ff       	call   c449 <lodepng_chunk_createv>
   1475f:	83 c4 10             	add    $0x10,%esp
   14762:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   14765:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14768:	83 ec 0c             	sub    $0xc,%esp
   1476b:	50                   	push   %eax
   1476c:	e8 d9 27 ff ff       	call   6f4a <lodepng_free>
   14771:	83 c4 10             	add    $0x10,%esp
  return error;
   14774:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14777:	c9                   	leave  
   14778:	c3                   	ret    

00014779 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   14779:	55                   	push   %ebp
   1477a:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   1477c:	6a 00                	push   $0x0
   1477e:	68 49 f4 01 00       	push   $0x1f449
   14783:	6a 00                	push   $0x0
   14785:	ff 75 08             	pushl  0x8(%ebp)
   14788:	e8 bc 7c ff ff       	call   c449 <lodepng_chunk_createv>
   1478d:	83 c4 10             	add    $0x10,%esp
}
   14790:	c9                   	leave  
   14791:	c3                   	ret    

00014792 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   14792:	55                   	push   %ebp
   14793:	89 e5                	mov    %esp,%ebp
   14795:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   14798:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   1479f:	ff 75 0c             	pushl  0xc(%ebp)
   147a2:	e8 1e 28 ff ff       	call   6fc5 <lodepng_strlen>
   147a7:	83 c4 04             	add    $0x4,%esp
   147aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
   147ad:	ff 75 10             	pushl  0x10(%ebp)
   147b0:	e8 10 28 ff ff       	call   6fc5 <lodepng_strlen>
   147b5:	83 c4 04             	add    $0x4,%esp
   147b8:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   147bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   147be:	8d 50 01             	lea    0x1(%eax),%edx
   147c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   147c4:	01 d0                	add    %edx,%eax
   147c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   147c9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   147cd:	7e 06                	jle    147d5 <addChunk_tEXt+0x43>
   147cf:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   147d3:	7e 07                	jle    147dc <addChunk_tEXt+0x4a>
   147d5:	b8 59 00 00 00       	mov    $0x59,%eax
   147da:	eb 74                	jmp    14850 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   147dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147df:	68 17 f4 01 00       	push   $0x1f417
   147e4:	50                   	push   %eax
   147e5:	ff 75 08             	pushl  0x8(%ebp)
   147e8:	8d 45 ec             	lea    -0x14(%ebp),%eax
   147eb:	50                   	push   %eax
   147ec:	e8 b0 7b ff ff       	call   c3a1 <lodepng_chunk_init>
   147f1:	83 c4 10             	add    $0x10,%esp
   147f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
   147f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   147fb:	74 05                	je     14802 <addChunk_tEXt+0x70>
   147fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14800:	eb 4e                	jmp    14850 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   14802:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14805:	83 c0 08             	add    $0x8,%eax
   14808:	ff 75 fc             	pushl  -0x4(%ebp)
   1480b:	ff 75 0c             	pushl  0xc(%ebp)
   1480e:	50                   	push   %eax
   1480f:	e8 53 27 ff ff       	call   6f67 <lodepng_memcpy>
   14814:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   14817:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1481a:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1481d:	83 c2 08             	add    $0x8,%edx
   14820:	01 d0                	add    %edx,%eax
   14822:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   14825:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14828:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1482b:	83 c2 09             	add    $0x9,%edx
   1482e:	01 d0                	add    %edx,%eax
   14830:	ff 75 f8             	pushl  -0x8(%ebp)
   14833:	ff 75 10             	pushl  0x10(%ebp)
   14836:	50                   	push   %eax
   14837:	e8 2b 27 ff ff       	call   6f67 <lodepng_memcpy>
   1483c:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   1483f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14842:	50                   	push   %eax
   14843:	e8 02 78 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14848:	83 c4 04             	add    $0x4,%esp
  return 0;
   1484b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14850:	c9                   	leave  
   14851:	c3                   	ret    

00014852 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   14852:	55                   	push   %ebp
   14853:	89 e5                	mov    %esp,%ebp
   14855:	53                   	push   %ebx
   14856:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   14859:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   14860:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   14867:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   1486e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   14875:	ff 75 10             	pushl  0x10(%ebp)
   14878:	e8 48 27 ff ff       	call   6fc5 <lodepng_strlen>
   1487d:	83 c4 04             	add    $0x4,%esp
   14880:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   14883:	ff 75 0c             	pushl  0xc(%ebp)
   14886:	e8 3a 27 ff ff       	call   6fc5 <lodepng_strlen>
   1488b:	83 c4 04             	add    $0x4,%esp
   1488e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   14891:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14895:	7e 06                	jle    1489d <addChunk_zTXt+0x4b>
   14897:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   1489b:	7e 0a                	jle    148a7 <addChunk_zTXt+0x55>
   1489d:	b8 59 00 00 00       	mov    $0x59,%eax
   148a2:	e9 c8 00 00 00       	jmp    1496f <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   148a7:	83 ec 0c             	sub    $0xc,%esp
   148aa:	ff 75 14             	pushl  0x14(%ebp)
   148ad:	ff 75 f0             	pushl  -0x10(%ebp)
   148b0:	ff 75 10             	pushl  0x10(%ebp)
   148b3:	8d 45 dc             	lea    -0x24(%ebp),%eax
   148b6:	50                   	push   %eax
   148b7:	8d 45 e0             	lea    -0x20(%ebp),%eax
   148ba:	50                   	push   %eax
   148bb:	e8 79 73 ff ff       	call   bc39 <zlib_compress>
   148c0:	83 c4 20             	add    $0x20,%esp
   148c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   148c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   148ca:	75 29                	jne    148f5 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   148cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   148cf:	8d 50 02             	lea    0x2(%eax),%edx
   148d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   148d5:	01 d0                	add    %edx,%eax
   148d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   148da:	8b 45 e8             	mov    -0x18(%ebp),%eax
   148dd:	68 1c f4 01 00       	push   $0x1f41c
   148e2:	50                   	push   %eax
   148e3:	ff 75 08             	pushl  0x8(%ebp)
   148e6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   148e9:	50                   	push   %eax
   148ea:	e8 b2 7a ff ff       	call   c3a1 <lodepng_chunk_init>
   148ef:	83 c4 10             	add    $0x10,%esp
   148f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   148f5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   148f9:	75 62                	jne    1495d <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   148fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   148fe:	83 c0 08             	add    $0x8,%eax
   14901:	83 ec 04             	sub    $0x4,%esp
   14904:	ff 75 ec             	pushl  -0x14(%ebp)
   14907:	ff 75 0c             	pushl  0xc(%ebp)
   1490a:	50                   	push   %eax
   1490b:	e8 57 26 ff ff       	call   6f67 <lodepng_memcpy>
   14910:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   14913:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14916:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14919:	83 c2 08             	add    $0x8,%edx
   1491c:	01 d0                	add    %edx,%eax
   1491e:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   14921:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14924:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14927:	83 c2 09             	add    $0x9,%edx
   1492a:	01 d0                	add    %edx,%eax
   1492c:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   1492f:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14932:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14935:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   14938:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   1493b:	83 c3 0a             	add    $0xa,%ebx
   1493e:	01 d9                	add    %ebx,%ecx
   14940:	83 ec 04             	sub    $0x4,%esp
   14943:	52                   	push   %edx
   14944:	50                   	push   %eax
   14945:	51                   	push   %ecx
   14946:	e8 1c 26 ff ff       	call   6f67 <lodepng_memcpy>
   1494b:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   1494e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14951:	83 ec 0c             	sub    $0xc,%esp
   14954:	50                   	push   %eax
   14955:	e8 f0 76 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   1495a:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1495d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14960:	83 ec 0c             	sub    $0xc,%esp
   14963:	50                   	push   %eax
   14964:	e8 e1 25 ff ff       	call   6f4a <lodepng_free>
   14969:	83 c4 10             	add    $0x10,%esp
  return error;
   1496c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1496f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14972:	c9                   	leave  
   14973:	c3                   	ret    

00014974 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   14974:	55                   	push   %ebp
   14975:	89 e5                	mov    %esp,%ebp
   14977:	53                   	push   %ebx
   14978:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   1497b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   14982:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   14989:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   14990:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   14997:	ff 75 1c             	pushl  0x1c(%ebp)
   1499a:	e8 26 26 ff ff       	call   6fc5 <lodepng_strlen>
   1499f:	83 c4 04             	add    $0x4,%esp
   149a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   149a5:	ff 75 10             	pushl  0x10(%ebp)
   149a8:	e8 18 26 ff ff       	call   6fc5 <lodepng_strlen>
   149ad:	83 c4 04             	add    $0x4,%esp
   149b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
   149b3:	ff 75 14             	pushl  0x14(%ebp)
   149b6:	e8 0a 26 ff ff       	call   6fc5 <lodepng_strlen>
   149bb:	83 c4 04             	add    $0x4,%esp
   149be:	89 45 e8             	mov    %eax,-0x18(%ebp)
   149c1:	ff 75 18             	pushl  0x18(%ebp)
   149c4:	e8 fc 25 ff ff       	call   6fc5 <lodepng_strlen>
   149c9:	83 c4 04             	add    $0x4,%esp
   149cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   149cf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   149d3:	7e 06                	jle    149db <addChunk_iTXt+0x67>
   149d5:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   149d9:	7e 0a                	jle    149e5 <addChunk_iTXt+0x71>
   149db:	b8 59 00 00 00       	mov    $0x59,%eax
   149e0:	e9 9a 01 00 00       	jmp    14b7f <addChunk_iTXt+0x20b>

  if(compress) {
   149e5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   149e9:	74 1f                	je     14a0a <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   149eb:	83 ec 0c             	sub    $0xc,%esp
   149ee:	ff 75 20             	pushl  0x20(%ebp)
   149f1:	ff 75 f0             	pushl  -0x10(%ebp)
   149f4:	ff 75 1c             	pushl  0x1c(%ebp)
   149f7:	8d 45 d0             	lea    -0x30(%ebp),%eax
   149fa:	50                   	push   %eax
   149fb:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   149fe:	50                   	push   %eax
   149ff:	e8 35 72 ff ff       	call   bc39 <zlib_compress>
   14a04:	83 c4 20             	add    $0x20,%esp
   14a07:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   14a0a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14a0e:	75 44                	jne    14a54 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   14a10:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14a13:	8d 50 03             	lea    0x3(%eax),%edx
   14a16:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14a19:	01 d0                	add    %edx,%eax
   14a1b:	8d 50 01             	lea    0x1(%eax),%edx
   14a1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14a21:	01 d0                	add    %edx,%eax
   14a23:	8d 50 01             	lea    0x1(%eax),%edx
   14a26:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14a2a:	74 05                	je     14a31 <addChunk_iTXt+0xbd>
   14a2c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14a2f:	eb 03                	jmp    14a34 <addChunk_iTXt+0xc0>
   14a31:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a34:	01 d0                	add    %edx,%eax
   14a36:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   14a39:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14a3c:	68 21 f4 01 00       	push   $0x1f421
   14a41:	50                   	push   %eax
   14a42:	ff 75 08             	pushl  0x8(%ebp)
   14a45:	8d 45 d8             	lea    -0x28(%ebp),%eax
   14a48:	50                   	push   %eax
   14a49:	e8 53 79 ff ff       	call   c3a1 <lodepng_chunk_init>
   14a4e:	83 c4 10             	add    $0x10,%esp
   14a51:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   14a54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14a58:	0f 85 0f 01 00 00    	jne    14b6d <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   14a5e:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   14a65:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14a68:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14a6b:	01 d0                	add    %edx,%eax
   14a6d:	83 ec 04             	sub    $0x4,%esp
   14a70:	ff 75 ec             	pushl  -0x14(%ebp)
   14a73:	ff 75 10             	pushl  0x10(%ebp)
   14a76:	50                   	push   %eax
   14a77:	e8 eb 24 ff ff       	call   6f67 <lodepng_memcpy>
   14a7c:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   14a7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14a82:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   14a85:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   14a88:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14a8b:	8d 50 01             	lea    0x1(%eax),%edx
   14a8e:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14a91:	01 c8                	add    %ecx,%eax
   14a93:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   14a96:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   14a99:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14a9c:	8d 50 01             	lea    0x1(%eax),%edx
   14a9f:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14aa2:	01 c8                	add    %ecx,%eax
   14aa4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14aa8:	0f 95 c2             	setne  %dl
   14aab:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   14aad:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   14ab0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ab3:	8d 50 01             	lea    0x1(%eax),%edx
   14ab6:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14ab9:	01 c8                	add    %ecx,%eax
   14abb:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   14abe:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14ac1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ac4:	01 d0                	add    %edx,%eax
   14ac6:	83 ec 04             	sub    $0x4,%esp
   14ac9:	ff 75 e8             	pushl  -0x18(%ebp)
   14acc:	ff 75 14             	pushl  0x14(%ebp)
   14acf:	50                   	push   %eax
   14ad0:	e8 92 24 ff ff       	call   6f67 <lodepng_memcpy>
   14ad5:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   14ad8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14adb:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   14ade:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   14ae1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ae4:	8d 50 01             	lea    0x1(%eax),%edx
   14ae7:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14aea:	01 c8                	add    %ecx,%eax
   14aec:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   14aef:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14af2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14af5:	01 d0                	add    %edx,%eax
   14af7:	83 ec 04             	sub    $0x4,%esp
   14afa:	ff 75 e4             	pushl  -0x1c(%ebp)
   14afd:	ff 75 18             	pushl  0x18(%ebp)
   14b00:	50                   	push   %eax
   14b01:	e8 61 24 ff ff       	call   6f67 <lodepng_memcpy>
   14b06:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   14b09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14b0c:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   14b0f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   14b12:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14b15:	8d 50 01             	lea    0x1(%eax),%edx
   14b18:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14b1b:	01 c8                	add    %ecx,%eax
   14b1d:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   14b20:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14b24:	74 1e                	je     14b44 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   14b26:	8b 55 d0             	mov    -0x30(%ebp),%edx
   14b29:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   14b2c:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   14b2f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   14b32:	01 d9                	add    %ebx,%ecx
   14b34:	83 ec 04             	sub    $0x4,%esp
   14b37:	52                   	push   %edx
   14b38:	50                   	push   %eax
   14b39:	51                   	push   %ecx
   14b3a:	e8 28 24 ff ff       	call   6f67 <lodepng_memcpy>
   14b3f:	83 c4 10             	add    $0x10,%esp
   14b42:	eb 1a                	jmp    14b5e <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   14b44:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14b47:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14b4a:	01 d0                	add    %edx,%eax
   14b4c:	83 ec 04             	sub    $0x4,%esp
   14b4f:	ff 75 f0             	pushl  -0x10(%ebp)
   14b52:	ff 75 1c             	pushl  0x1c(%ebp)
   14b55:	50                   	push   %eax
   14b56:	e8 0c 24 ff ff       	call   6f67 <lodepng_memcpy>
   14b5b:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   14b5e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14b61:	83 ec 0c             	sub    $0xc,%esp
   14b64:	50                   	push   %eax
   14b65:	e8 e0 74 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14b6a:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   14b6d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   14b70:	83 ec 0c             	sub    $0xc,%esp
   14b73:	50                   	push   %eax
   14b74:	e8 d1 23 ff ff       	call   6f4a <lodepng_free>
   14b79:	83 c4 10             	add    $0x10,%esp
  return error;
   14b7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14b7f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14b82:	c9                   	leave  
   14b83:	c3                   	ret    

00014b84 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   14b84:	55                   	push   %ebp
   14b85:	89 e5                	mov    %esp,%ebp
   14b87:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   14b8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   14b91:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b94:	8b 40 0c             	mov    0xc(%eax),%eax
   14b97:	85 c0                	test   %eax,%eax
   14b99:	74 0b                	je     14ba6 <addChunk_bKGD+0x22>
   14b9b:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b9e:	8b 40 0c             	mov    0xc(%eax),%eax
   14ba1:	83 f8 04             	cmp    $0x4,%eax
   14ba4:	75 4b                	jne    14bf1 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   14ba6:	68 12 f4 01 00       	push   $0x1f412
   14bab:	6a 02                	push   $0x2
   14bad:	ff 75 08             	pushl  0x8(%ebp)
   14bb0:	8d 45 f0             	lea    -0x10(%ebp),%eax
   14bb3:	50                   	push   %eax
   14bb4:	e8 e8 77 ff ff       	call   c3a1 <lodepng_chunk_init>
   14bb9:	83 c4 10             	add    $0x10,%esp
   14bbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
   14bbf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14bc3:	74 08                	je     14bcd <addChunk_bKGD+0x49>
   14bc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bc8:	e9 19 01 00 00       	jmp    14ce6 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   14bcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14bd0:	8d 50 08             	lea    0x8(%eax),%edx
   14bd3:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bd6:	8b 40 30             	mov    0x30(%eax),%eax
   14bd9:	c1 e8 08             	shr    $0x8,%eax
   14bdc:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   14bde:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14be1:	8d 50 09             	lea    0x9(%eax),%edx
   14be4:	8b 45 0c             	mov    0xc(%ebp),%eax
   14be7:	8b 40 30             	mov    0x30(%eax),%eax
   14bea:	88 02                	mov    %al,(%edx)
   14bec:	e9 dd 00 00 00       	jmp    14cce <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   14bf1:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bf4:	8b 40 0c             	mov    0xc(%eax),%eax
   14bf7:	83 f8 02             	cmp    $0x2,%eax
   14bfa:	74 0f                	je     14c0b <addChunk_bKGD+0x87>
   14bfc:	8b 45 0c             	mov    0xc(%ebp),%eax
   14bff:	8b 40 0c             	mov    0xc(%eax),%eax
   14c02:	83 f8 06             	cmp    $0x6,%eax
   14c05:	0f 85 86 00 00 00    	jne    14c91 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   14c0b:	68 12 f4 01 00       	push   $0x1f412
   14c10:	6a 06                	push   $0x6
   14c12:	ff 75 08             	pushl  0x8(%ebp)
   14c15:	8d 45 f0             	lea    -0x10(%ebp),%eax
   14c18:	50                   	push   %eax
   14c19:	e8 83 77 ff ff       	call   c3a1 <lodepng_chunk_init>
   14c1e:	83 c4 10             	add    $0x10,%esp
   14c21:	89 45 f8             	mov    %eax,-0x8(%ebp)
   14c24:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   14c28:	74 08                	je     14c32 <addChunk_bKGD+0xae>
   14c2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14c2d:	e9 b4 00 00 00       	jmp    14ce6 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   14c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c35:	8d 50 08             	lea    0x8(%eax),%edx
   14c38:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c3b:	8b 40 30             	mov    0x30(%eax),%eax
   14c3e:	c1 e8 08             	shr    $0x8,%eax
   14c41:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   14c43:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c46:	8d 50 09             	lea    0x9(%eax),%edx
   14c49:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c4c:	8b 40 30             	mov    0x30(%eax),%eax
   14c4f:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   14c51:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c54:	8d 50 0a             	lea    0xa(%eax),%edx
   14c57:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c5a:	8b 40 34             	mov    0x34(%eax),%eax
   14c5d:	c1 e8 08             	shr    $0x8,%eax
   14c60:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   14c62:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c65:	8d 50 0b             	lea    0xb(%eax),%edx
   14c68:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c6b:	8b 40 34             	mov    0x34(%eax),%eax
   14c6e:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   14c70:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c73:	8d 50 0c             	lea    0xc(%eax),%edx
   14c76:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c79:	8b 40 38             	mov    0x38(%eax),%eax
   14c7c:	c1 e8 08             	shr    $0x8,%eax
   14c7f:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   14c81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14c84:	8d 50 0d             	lea    0xd(%eax),%edx
   14c87:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c8a:	8b 40 38             	mov    0x38(%eax),%eax
   14c8d:	88 02                	mov    %al,(%edx)
   14c8f:	eb 3d                	jmp    14cce <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   14c91:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c94:	8b 40 0c             	mov    0xc(%eax),%eax
   14c97:	83 f8 03             	cmp    $0x3,%eax
   14c9a:	75 32                	jne    14cce <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   14c9c:	68 12 f4 01 00       	push   $0x1f412
   14ca1:	6a 01                	push   $0x1
   14ca3:	ff 75 08             	pushl  0x8(%ebp)
   14ca6:	8d 45 f0             	lea    -0x10(%ebp),%eax
   14ca9:	50                   	push   %eax
   14caa:	e8 f2 76 ff ff       	call   c3a1 <lodepng_chunk_init>
   14caf:	83 c4 10             	add    $0x10,%esp
   14cb2:	89 45 fc             	mov    %eax,-0x4(%ebp)
   14cb5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   14cb9:	74 05                	je     14cc0 <addChunk_bKGD+0x13c>
   14cbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14cbe:	eb 26                	jmp    14ce6 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   14cc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14cc3:	8d 50 08             	lea    0x8(%eax),%edx
   14cc6:	8b 45 0c             	mov    0xc(%ebp),%eax
   14cc9:	8b 40 30             	mov    0x30(%eax),%eax
   14ccc:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   14cce:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14cd1:	85 c0                	test   %eax,%eax
   14cd3:	74 0c                	je     14ce1 <addChunk_bKGD+0x15d>
   14cd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14cd8:	50                   	push   %eax
   14cd9:	e8 6c 73 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14cde:	83 c4 04             	add    $0x4,%esp
  return 0;
   14ce1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14ce6:	c9                   	leave  
   14ce7:	c3                   	ret    

00014ce8 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   14ce8:	55                   	push   %ebp
   14ce9:	89 e5                	mov    %esp,%ebp
   14ceb:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   14cee:	68 26 f4 01 00       	push   $0x1f426
   14cf3:	6a 07                	push   $0x7
   14cf5:	ff 75 08             	pushl  0x8(%ebp)
   14cf8:	8d 45 f8             	lea    -0x8(%ebp),%eax
   14cfb:	50                   	push   %eax
   14cfc:	e8 a0 76 ff ff       	call   c3a1 <lodepng_chunk_init>
   14d01:	83 c4 10             	add    $0x10,%esp
   14d04:	89 45 fc             	mov    %eax,-0x4(%ebp)
   14d07:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   14d0b:	74 05                	je     14d12 <addChunk_tIME+0x2a>
   14d0d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14d10:	eb 74                	jmp    14d86 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   14d12:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d15:	8d 50 08             	lea    0x8(%eax),%edx
   14d18:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d1b:	8b 00                	mov    (%eax),%eax
   14d1d:	c1 e8 08             	shr    $0x8,%eax
   14d20:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   14d22:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d25:	8d 50 09             	lea    0x9(%eax),%edx
   14d28:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d2b:	8b 00                	mov    (%eax),%eax
   14d2d:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   14d2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d32:	8d 50 0a             	lea    0xa(%eax),%edx
   14d35:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d38:	8b 40 04             	mov    0x4(%eax),%eax
   14d3b:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   14d3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d40:	8d 50 0b             	lea    0xb(%eax),%edx
   14d43:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d46:	8b 40 08             	mov    0x8(%eax),%eax
   14d49:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   14d4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d4e:	8d 50 0c             	lea    0xc(%eax),%edx
   14d51:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d54:	8b 40 0c             	mov    0xc(%eax),%eax
   14d57:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   14d59:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d5c:	8d 50 0d             	lea    0xd(%eax),%edx
   14d5f:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d62:	8b 40 10             	mov    0x10(%eax),%eax
   14d65:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   14d67:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d6a:	8d 50 0e             	lea    0xe(%eax),%edx
   14d6d:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d70:	8b 40 14             	mov    0x14(%eax),%eax
   14d73:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   14d75:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14d78:	50                   	push   %eax
   14d79:	e8 cc 72 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14d7e:	83 c4 04             	add    $0x4,%esp
  return 0;
   14d81:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14d86:	c9                   	leave  
   14d87:	c3                   	ret    

00014d88 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   14d88:	55                   	push   %ebp
   14d89:	89 e5                	mov    %esp,%ebp
   14d8b:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   14d8e:	68 2b f4 01 00       	push   $0x1f42b
   14d93:	6a 09                	push   $0x9
   14d95:	ff 75 08             	pushl  0x8(%ebp)
   14d98:	8d 45 f8             	lea    -0x8(%ebp),%eax
   14d9b:	50                   	push   %eax
   14d9c:	e8 00 76 ff ff       	call   c3a1 <lodepng_chunk_init>
   14da1:	83 c4 10             	add    $0x10,%esp
   14da4:	89 45 fc             	mov    %eax,-0x4(%ebp)
   14da7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   14dab:	74 05                	je     14db2 <addChunk_pHYs+0x2a>
   14dad:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14db0:	eb 51                	jmp    14e03 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   14db2:	8b 45 0c             	mov    0xc(%ebp),%eax
   14db5:	8b 40 7c             	mov    0x7c(%eax),%eax
   14db8:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14dbb:	83 c2 08             	add    $0x8,%edx
   14dbe:	50                   	push   %eax
   14dbf:	52                   	push   %edx
   14dc0:	e8 25 25 ff ff       	call   72ea <lodepng_set32bitInt>
   14dc5:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   14dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dcb:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   14dd1:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14dd4:	83 c2 0c             	add    $0xc,%edx
   14dd7:	50                   	push   %eax
   14dd8:	52                   	push   %edx
   14dd9:	e8 0c 25 ff ff       	call   72ea <lodepng_set32bitInt>
   14dde:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   14de1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14de4:	8d 50 10             	lea    0x10(%eax),%edx
   14de7:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dea:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   14df0:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   14df2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14df5:	50                   	push   %eax
   14df6:	e8 4f 72 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14dfb:	83 c4 04             	add    $0x4,%esp
  return 0;
   14dfe:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14e03:	c9                   	leave  
   14e04:	c3                   	ret    

00014e05 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   14e05:	55                   	push   %ebp
   14e06:	89 e5                	mov    %esp,%ebp
   14e08:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   14e0b:	68 30 f4 01 00       	push   $0x1f430
   14e10:	6a 04                	push   $0x4
   14e12:	ff 75 08             	pushl  0x8(%ebp)
   14e15:	8d 45 f8             	lea    -0x8(%ebp),%eax
   14e18:	50                   	push   %eax
   14e19:	e8 83 75 ff ff       	call   c3a1 <lodepng_chunk_init>
   14e1e:	83 c4 10             	add    $0x10,%esp
   14e21:	89 45 fc             	mov    %eax,-0x4(%ebp)
   14e24:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   14e28:	74 05                	je     14e2f <addChunk_gAMA+0x2a>
   14e2a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14e2d:	eb 2a                	jmp    14e59 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   14e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e32:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   14e38:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14e3b:	83 c2 08             	add    $0x8,%edx
   14e3e:	50                   	push   %eax
   14e3f:	52                   	push   %edx
   14e40:	e8 a5 24 ff ff       	call   72ea <lodepng_set32bitInt>
   14e45:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   14e48:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14e4b:	50                   	push   %eax
   14e4c:	e8 f9 71 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14e51:	83 c4 04             	add    $0x4,%esp
  return 0;
   14e54:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14e59:	c9                   	leave  
   14e5a:	c3                   	ret    

00014e5b <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   14e5b:	55                   	push   %ebp
   14e5c:	89 e5                	mov    %esp,%ebp
   14e5e:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   14e61:	68 35 f4 01 00       	push   $0x1f435
   14e66:	6a 20                	push   $0x20
   14e68:	ff 75 08             	pushl  0x8(%ebp)
   14e6b:	8d 45 f8             	lea    -0x8(%ebp),%eax
   14e6e:	50                   	push   %eax
   14e6f:	e8 2d 75 ff ff       	call   c3a1 <lodepng_chunk_init>
   14e74:	83 c4 10             	add    $0x10,%esp
   14e77:	89 45 fc             	mov    %eax,-0x4(%ebp)
   14e7a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   14e7e:	74 08                	je     14e88 <addChunk_cHRM+0x2d>
   14e80:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14e83:	e9 d9 00 00 00       	jmp    14f61 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   14e88:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e8b:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   14e91:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14e94:	83 c2 08             	add    $0x8,%edx
   14e97:	50                   	push   %eax
   14e98:	52                   	push   %edx
   14e99:	e8 4c 24 ff ff       	call   72ea <lodepng_set32bitInt>
   14e9e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   14ea1:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ea4:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   14eaa:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14ead:	83 c2 0c             	add    $0xc,%edx
   14eb0:	50                   	push   %eax
   14eb1:	52                   	push   %edx
   14eb2:	e8 33 24 ff ff       	call   72ea <lodepng_set32bitInt>
   14eb7:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   14eba:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ebd:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   14ec3:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14ec6:	83 c2 10             	add    $0x10,%edx
   14ec9:	50                   	push   %eax
   14eca:	52                   	push   %edx
   14ecb:	e8 1a 24 ff ff       	call   72ea <lodepng_set32bitInt>
   14ed0:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   14ed3:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ed6:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   14edc:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14edf:	83 c2 14             	add    $0x14,%edx
   14ee2:	50                   	push   %eax
   14ee3:	52                   	push   %edx
   14ee4:	e8 01 24 ff ff       	call   72ea <lodepng_set32bitInt>
   14ee9:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   14eec:	8b 45 0c             	mov    0xc(%ebp),%eax
   14eef:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   14ef5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14ef8:	83 c2 18             	add    $0x18,%edx
   14efb:	50                   	push   %eax
   14efc:	52                   	push   %edx
   14efd:	e8 e8 23 ff ff       	call   72ea <lodepng_set32bitInt>
   14f02:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   14f05:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f08:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   14f0e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14f11:	83 c2 1c             	add    $0x1c,%edx
   14f14:	50                   	push   %eax
   14f15:	52                   	push   %edx
   14f16:	e8 cf 23 ff ff       	call   72ea <lodepng_set32bitInt>
   14f1b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   14f1e:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f21:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   14f27:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14f2a:	83 c2 20             	add    $0x20,%edx
   14f2d:	50                   	push   %eax
   14f2e:	52                   	push   %edx
   14f2f:	e8 b6 23 ff ff       	call   72ea <lodepng_set32bitInt>
   14f34:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   14f37:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f3a:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   14f40:	8b 55 f8             	mov    -0x8(%ebp),%edx
   14f43:	83 c2 24             	add    $0x24,%edx
   14f46:	50                   	push   %eax
   14f47:	52                   	push   %edx
   14f48:	e8 9d 23 ff ff       	call   72ea <lodepng_set32bitInt>
   14f4d:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   14f50:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14f53:	50                   	push   %eax
   14f54:	e8 f1 70 ff ff       	call   c04a <lodepng_chunk_generate_crc>
   14f59:	83 c4 04             	add    $0x4,%esp
  return 0;
   14f5c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14f61:	c9                   	leave  
   14f62:	c3                   	ret    

00014f63 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   14f63:	55                   	push   %ebp
   14f64:	89 e5                	mov    %esp,%ebp
   14f66:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   14f69:	8b 45 0c             	mov    0xc(%ebp),%eax
   14f6c:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   14f72:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   14f75:	8d 45 ff             	lea    -0x1(%ebp),%eax
   14f78:	50                   	push   %eax
   14f79:	68 3a f4 01 00       	push   $0x1f43a
   14f7e:	6a 01                	push   $0x1
   14f80:	ff 75 08             	pushl  0x8(%ebp)
   14f83:	e8 c1 74 ff ff       	call   c449 <lodepng_chunk_createv>
   14f88:	83 c4 10             	add    $0x10,%esp
}
   14f8b:	c9                   	leave  
   14f8c:	c3                   	ret    

00014f8d <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   14f8d:	55                   	push   %ebp
   14f8e:	89 e5                	mov    %esp,%ebp
   14f90:	53                   	push   %ebx
   14f91:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   14f94:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   14f9b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   14fa2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   14fa9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   14fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
   14fb3:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   14fb9:	50                   	push   %eax
   14fba:	e8 06 20 ff ff       	call   6fc5 <lodepng_strlen>
   14fbf:	83 c4 04             	add    $0x4,%esp
   14fc2:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   14fc5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14fc9:	7e 06                	jle    14fd1 <addChunk_iCCP+0x44>
   14fcb:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   14fcf:	7e 0a                	jle    14fdb <addChunk_iCCP+0x4e>
   14fd1:	b8 59 00 00 00       	mov    $0x59,%eax
   14fd6:	e9 df 00 00 00       	jmp    150ba <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   14fdb:	8b 45 0c             	mov    0xc(%ebp),%eax
   14fde:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   14fe4:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   14fe6:	8b 45 0c             	mov    0xc(%ebp),%eax
   14fe9:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   14fef:	83 ec 0c             	sub    $0xc,%esp
   14ff2:	ff 75 10             	pushl  0x10(%ebp)
   14ff5:	52                   	push   %edx
   14ff6:	50                   	push   %eax
   14ff7:	8d 45 e0             	lea    -0x20(%ebp),%eax
   14ffa:	50                   	push   %eax
   14ffb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   14ffe:	50                   	push   %eax
   14fff:	e8 35 6c ff ff       	call   bc39 <zlib_compress>
   15004:	83 c4 20             	add    $0x20,%esp
   15007:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   1500a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1500e:	75 29                	jne    15039 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   15010:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15013:	8d 50 02             	lea    0x2(%eax),%edx
   15016:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15019:	01 d0                	add    %edx,%eax
   1501b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   1501e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15021:	68 3f f4 01 00       	push   $0x1f43f
   15026:	50                   	push   %eax
   15027:	ff 75 08             	pushl  0x8(%ebp)
   1502a:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1502d:	50                   	push   %eax
   1502e:	e8 6e 73 ff ff       	call   c3a1 <lodepng_chunk_init>
   15033:	83 c4 10             	add    $0x10,%esp
   15036:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   15039:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1503d:	75 69                	jne    150a8 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   1503f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15042:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15048:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1504b:	83 c2 08             	add    $0x8,%edx
   1504e:	83 ec 04             	sub    $0x4,%esp
   15051:	ff 75 f0             	pushl  -0x10(%ebp)
   15054:	50                   	push   %eax
   15055:	52                   	push   %edx
   15056:	e8 0c 1f ff ff       	call   6f67 <lodepng_memcpy>
   1505b:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   1505e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15061:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15064:	83 c2 08             	add    $0x8,%edx
   15067:	01 d0                	add    %edx,%eax
   15069:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   1506c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1506f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15072:	83 c2 09             	add    $0x9,%edx
   15075:	01 d0                	add    %edx,%eax
   15077:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   1507a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1507d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15080:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   15083:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   15086:	83 c3 0a             	add    $0xa,%ebx
   15089:	01 d9                	add    %ebx,%ecx
   1508b:	83 ec 04             	sub    $0x4,%esp
   1508e:	52                   	push   %edx
   1508f:	50                   	push   %eax
   15090:	51                   	push   %ecx
   15091:	e8 d1 1e ff ff       	call   6f67 <lodepng_memcpy>
   15096:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   15099:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1509c:	83 ec 0c             	sub    $0xc,%esp
   1509f:	50                   	push   %eax
   150a0:	e8 a5 6f ff ff       	call   c04a <lodepng_chunk_generate_crc>
   150a5:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   150a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   150ab:	83 ec 0c             	sub    $0xc,%esp
   150ae:	50                   	push   %eax
   150af:	e8 96 1e ff ff       	call   6f4a <lodepng_free>
   150b4:	83 c4 10             	add    $0x10,%esp
  return error;
   150b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   150ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   150bd:	c9                   	leave  
   150be:	c3                   	ret    

000150bf <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   150bf:	55                   	push   %ebp
   150c0:	89 e5                	mov    %esp,%ebp
   150c2:	56                   	push   %esi
   150c3:	53                   	push   %ebx
   150c4:	83 ec 14             	sub    $0x14,%esp
   150c7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   150ca:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   150cd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   150d1:	83 f8 04             	cmp    $0x4,%eax
   150d4:	0f 87 41 03 00 00    	ja     1541b <filterScanline+0x35c>
   150da:	8b 04 85 50 f4 01 00 	mov    0x1f450(,%eax,4),%eax
   150e1:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   150e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   150ea:	eb 19                	jmp    15105 <filterScanline+0x46>
   150ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
   150ef:	8b 45 08             	mov    0x8(%ebp),%eax
   150f2:	01 c2                	add    %eax,%edx
   150f4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   150f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   150fa:	01 c8                	add    %ecx,%eax
   150fc:	0f b6 00             	movzbl (%eax),%eax
   150ff:	88 02                	mov    %al,(%edx)
   15101:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15105:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15108:	3b 45 14             	cmp    0x14(%ebp),%eax
   1510b:	75 df                	jne    150ec <filterScanline+0x2d>
      break;
   1510d:	e9 0a 03 00 00       	jmp    1541c <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   15112:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15119:	eb 19                	jmp    15134 <filterScanline+0x75>
   1511b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1511e:	8b 45 08             	mov    0x8(%ebp),%eax
   15121:	01 c2                	add    %eax,%edx
   15123:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   15126:	8b 45 0c             	mov    0xc(%ebp),%eax
   15129:	01 c8                	add    %ecx,%eax
   1512b:	0f b6 00             	movzbl (%eax),%eax
   1512e:	88 02                	mov    %al,(%edx)
   15130:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15134:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15137:	3b 45 18             	cmp    0x18(%ebp),%eax
   1513a:	75 df                	jne    1511b <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   1513c:	8b 45 18             	mov    0x18(%ebp),%eax
   1513f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15142:	eb 2d                	jmp    15171 <filterScanline+0xb2>
   15144:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15147:	8b 45 08             	mov    0x8(%ebp),%eax
   1514a:	01 c2                	add    %eax,%edx
   1514c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1514f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15152:	01 c8                	add    %ecx,%eax
   15154:	0f b6 08             	movzbl (%eax),%ecx
   15157:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1515a:	2b 45 18             	sub    0x18(%ebp),%eax
   1515d:	89 c3                	mov    %eax,%ebx
   1515f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15162:	01 d8                	add    %ebx,%eax
   15164:	0f b6 00             	movzbl (%eax),%eax
   15167:	29 c1                	sub    %eax,%ecx
   15169:	89 c8                	mov    %ecx,%eax
   1516b:	88 02                	mov    %al,(%edx)
   1516d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15171:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15174:	3b 45 14             	cmp    0x14(%ebp),%eax
   15177:	7c cb                	jl     15144 <filterScanline+0x85>
      break;
   15179:	e9 9e 02 00 00       	jmp    1541c <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   1517e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   15182:	74 3e                	je     151c2 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   15184:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1518b:	eb 28                	jmp    151b5 <filterScanline+0xf6>
   1518d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15190:	8b 45 08             	mov    0x8(%ebp),%eax
   15193:	01 d0                	add    %edx,%eax
   15195:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   15198:	8b 55 0c             	mov    0xc(%ebp),%edx
   1519b:	01 ca                	add    %ecx,%edx
   1519d:	0f b6 0a             	movzbl (%edx),%ecx
   151a0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   151a3:	8b 55 10             	mov    0x10(%ebp),%edx
   151a6:	01 da                	add    %ebx,%edx
   151a8:	0f b6 12             	movzbl (%edx),%edx
   151ab:	29 d1                	sub    %edx,%ecx
   151ad:	89 ca                	mov    %ecx,%edx
   151af:	88 10                	mov    %dl,(%eax)
   151b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   151b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151b8:	3b 45 14             	cmp    0x14(%ebp),%eax
   151bb:	75 d0                	jne    1518d <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   151bd:	e9 5a 02 00 00       	jmp    1541c <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   151c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   151c9:	eb 19                	jmp    151e4 <filterScanline+0x125>
   151cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   151ce:	8b 45 08             	mov    0x8(%ebp),%eax
   151d1:	01 c2                	add    %eax,%edx
   151d3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   151d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   151d9:	01 c8                	add    %ecx,%eax
   151db:	0f b6 00             	movzbl (%eax),%eax
   151de:	88 02                	mov    %al,(%edx)
   151e0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   151e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151e7:	3b 45 14             	cmp    0x14(%ebp),%eax
   151ea:	75 df                	jne    151cb <filterScanline+0x10c>
      }
      break;
   151ec:	e9 2b 02 00 00       	jmp    1541c <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   151f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   151f5:	0f 84 90 00 00 00    	je     1528b <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   151fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15202:	eb 28                	jmp    1522c <filterScanline+0x16d>
   15204:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15207:	8b 45 08             	mov    0x8(%ebp),%eax
   1520a:	01 d0                	add    %edx,%eax
   1520c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1520f:	8b 55 0c             	mov    0xc(%ebp),%edx
   15212:	01 ca                	add    %ecx,%edx
   15214:	0f b6 12             	movzbl (%edx),%edx
   15217:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1521a:	8b 4d 10             	mov    0x10(%ebp),%ecx
   1521d:	01 d9                	add    %ebx,%ecx
   1521f:	0f b6 09             	movzbl (%ecx),%ecx
   15222:	d0 e9                	shr    %cl
   15224:	29 ca                	sub    %ecx,%edx
   15226:	88 10                	mov    %dl,(%eax)
   15228:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1522c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1522f:	3b 45 18             	cmp    0x18(%ebp),%eax
   15232:	75 d0                	jne    15204 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   15234:	8b 45 18             	mov    0x18(%ebp),%eax
   15237:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1523a:	eb 42                	jmp    1527e <filterScanline+0x1bf>
   1523c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1523f:	8b 45 08             	mov    0x8(%ebp),%eax
   15242:	01 c2                	add    %eax,%edx
   15244:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   15247:	8b 45 0c             	mov    0xc(%ebp),%eax
   1524a:	01 c8                	add    %ecx,%eax
   1524c:	0f b6 08             	movzbl (%eax),%ecx
   1524f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15252:	2b 45 18             	sub    0x18(%ebp),%eax
   15255:	89 c3                	mov    %eax,%ebx
   15257:	8b 45 0c             	mov    0xc(%ebp),%eax
   1525a:	01 d8                	add    %ebx,%eax
   1525c:	0f b6 00             	movzbl (%eax),%eax
   1525f:	0f b6 d8             	movzbl %al,%ebx
   15262:	8b 75 f4             	mov    -0xc(%ebp),%esi
   15265:	8b 45 10             	mov    0x10(%ebp),%eax
   15268:	01 f0                	add    %esi,%eax
   1526a:	0f b6 00             	movzbl (%eax),%eax
   1526d:	0f b6 c0             	movzbl %al,%eax
   15270:	01 d8                	add    %ebx,%eax
   15272:	d1 f8                	sar    %eax
   15274:	29 c1                	sub    %eax,%ecx
   15276:	89 c8                	mov    %ecx,%eax
   15278:	88 02                	mov    %al,(%edx)
   1527a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1527e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15281:	3b 45 14             	cmp    0x14(%ebp),%eax
   15284:	7c b6                	jl     1523c <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   15286:	e9 91 01 00 00       	jmp    1541c <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1528b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15292:	eb 19                	jmp    152ad <filterScanline+0x1ee>
   15294:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15297:	8b 45 08             	mov    0x8(%ebp),%eax
   1529a:	01 c2                	add    %eax,%edx
   1529c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1529f:	8b 45 0c             	mov    0xc(%ebp),%eax
   152a2:	01 c8                	add    %ecx,%eax
   152a4:	0f b6 00             	movzbl (%eax),%eax
   152a7:	88 02                	mov    %al,(%edx)
   152a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   152ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152b0:	3b 45 18             	cmp    0x18(%ebp),%eax
   152b3:	75 df                	jne    15294 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   152b5:	8b 45 18             	mov    0x18(%ebp),%eax
   152b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
   152bb:	eb 2f                	jmp    152ec <filterScanline+0x22d>
   152bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
   152c0:	8b 45 08             	mov    0x8(%ebp),%eax
   152c3:	01 c2                	add    %eax,%edx
   152c5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   152c8:	8b 45 0c             	mov    0xc(%ebp),%eax
   152cb:	01 c8                	add    %ecx,%eax
   152cd:	0f b6 08             	movzbl (%eax),%ecx
   152d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152d3:	2b 45 18             	sub    0x18(%ebp),%eax
   152d6:	89 c3                	mov    %eax,%ebx
   152d8:	8b 45 0c             	mov    0xc(%ebp),%eax
   152db:	01 d8                	add    %ebx,%eax
   152dd:	0f b6 00             	movzbl (%eax),%eax
   152e0:	d0 e8                	shr    %al
   152e2:	29 c1                	sub    %eax,%ecx
   152e4:	89 c8                	mov    %ecx,%eax
   152e6:	88 02                	mov    %al,(%edx)
   152e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   152ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152ef:	3b 45 14             	cmp    0x14(%ebp),%eax
   152f2:	7c c9                	jl     152bd <filterScanline+0x1fe>
      }
      break;
   152f4:	e9 23 01 00 00       	jmp    1541c <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   152f9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   152fd:	0f 84 af 00 00 00    	je     153b2 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   15303:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1530a:	eb 28                	jmp    15334 <filterScanline+0x275>
   1530c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1530f:	8b 45 08             	mov    0x8(%ebp),%eax
   15312:	01 d0                	add    %edx,%eax
   15314:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   15317:	8b 55 0c             	mov    0xc(%ebp),%edx
   1531a:	01 ca                	add    %ecx,%edx
   1531c:	0f b6 0a             	movzbl (%edx),%ecx
   1531f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   15322:	8b 55 10             	mov    0x10(%ebp),%edx
   15325:	01 da                	add    %ebx,%edx
   15327:	0f b6 12             	movzbl (%edx),%edx
   1532a:	29 d1                	sub    %edx,%ecx
   1532c:	89 ca                	mov    %ecx,%edx
   1532e:	88 10                	mov    %dl,(%eax)
   15330:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15334:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15337:	3b 45 18             	cmp    0x18(%ebp),%eax
   1533a:	75 d0                	jne    1530c <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   1533c:	8b 45 18             	mov    0x18(%ebp),%eax
   1533f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15342:	eb 64                	jmp    153a8 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   15344:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15347:	8b 45 08             	mov    0x8(%ebp),%eax
   1534a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1534d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15350:	8b 45 0c             	mov    0xc(%ebp),%eax
   15353:	01 d0                	add    %edx,%eax
   15355:	0f b6 00             	movzbl (%eax),%eax
   15358:	88 45 e7             	mov    %al,-0x19(%ebp)
   1535b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1535e:	2b 45 18             	sub    0x18(%ebp),%eax
   15361:	89 c2                	mov    %eax,%edx
   15363:	8b 45 10             	mov    0x10(%ebp),%eax
   15366:	01 d0                	add    %edx,%eax
   15368:	0f b6 00             	movzbl (%eax),%eax
   1536b:	0f b6 c8             	movzbl %al,%ecx
   1536e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15371:	8b 45 10             	mov    0x10(%ebp),%eax
   15374:	01 d0                	add    %edx,%eax
   15376:	0f b6 00             	movzbl (%eax),%eax
   15379:	0f b6 d0             	movzbl %al,%edx
   1537c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1537f:	2b 45 18             	sub    0x18(%ebp),%eax
   15382:	89 c6                	mov    %eax,%esi
   15384:	8b 45 0c             	mov    0xc(%ebp),%eax
   15387:	01 f0                	add    %esi,%eax
   15389:	0f b6 00             	movzbl (%eax),%eax
   1538c:	0f b6 c0             	movzbl %al,%eax
   1538f:	51                   	push   %ecx
   15390:	52                   	push   %edx
   15391:	50                   	push   %eax
   15392:	e8 49 b8 ff ff       	call   10be0 <paethPredictor>
   15397:	83 c4 0c             	add    $0xc,%esp
   1539a:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   1539e:	29 c1                	sub    %eax,%ecx
   153a0:	89 c8                	mov    %ecx,%eax
   153a2:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   153a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   153a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   153ab:	3b 45 14             	cmp    0x14(%ebp),%eax
   153ae:	7c 94                	jl     15344 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   153b0:	eb 6a                	jmp    1541c <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   153b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   153b9:	eb 19                	jmp    153d4 <filterScanline+0x315>
   153bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   153be:	8b 45 08             	mov    0x8(%ebp),%eax
   153c1:	01 c2                	add    %eax,%edx
   153c3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   153c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   153c9:	01 c8                	add    %ecx,%eax
   153cb:	0f b6 00             	movzbl (%eax),%eax
   153ce:	88 02                	mov    %al,(%edx)
   153d0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   153d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   153d7:	3b 45 18             	cmp    0x18(%ebp),%eax
   153da:	75 df                	jne    153bb <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   153dc:	8b 45 18             	mov    0x18(%ebp),%eax
   153df:	89 45 f4             	mov    %eax,-0xc(%ebp)
   153e2:	eb 2d                	jmp    15411 <filterScanline+0x352>
   153e4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   153e7:	8b 45 08             	mov    0x8(%ebp),%eax
   153ea:	01 c2                	add    %eax,%edx
   153ec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   153ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   153f2:	01 c8                	add    %ecx,%eax
   153f4:	0f b6 08             	movzbl (%eax),%ecx
   153f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   153fa:	2b 45 18             	sub    0x18(%ebp),%eax
   153fd:	89 c3                	mov    %eax,%ebx
   153ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   15402:	01 d8                	add    %ebx,%eax
   15404:	0f b6 00             	movzbl (%eax),%eax
   15407:	29 c1                	sub    %eax,%ecx
   15409:	89 c8                	mov    %ecx,%eax
   1540b:	88 02                	mov    %al,(%edx)
   1540d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15411:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15414:	3b 45 14             	cmp    0x14(%ebp),%eax
   15417:	7c cb                	jl     153e4 <filterScanline+0x325>
      }
      break;
   15419:	eb 01                	jmp    1541c <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   1541b:	90                   	nop
  }
}
   1541c:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1541f:	5b                   	pop    %ebx
   15420:	5e                   	pop    %esi
   15421:	5d                   	pop    %ebp
   15422:	c3                   	ret    

00015423 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   15423:	55                   	push   %ebp
   15424:	89 e5                	mov    %esp,%ebp
   15426:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   15429:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   15430:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   15437:	7e 08                	jle    15441 <ilog2+0x1e>
   15439:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   1543d:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   15441:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   15448:	7e 08                	jle    15452 <ilog2+0x2f>
   1544a:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   1544e:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   15452:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   15456:	7e 08                	jle    15460 <ilog2+0x3d>
   15458:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   1545c:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   15460:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   15464:	7e 08                	jle    1546e <ilog2+0x4b>
   15466:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   1546a:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   1546e:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   15472:	7e 04                	jle    15478 <ilog2+0x55>
   15474:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   15478:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1547b:	c9                   	leave  
   1547c:	c3                   	ret    

0001547d <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   1547d:	55                   	push   %ebp
   1547e:	89 e5                	mov    %esp,%ebp
   15480:	56                   	push   %esi
   15481:	53                   	push   %ebx
   15482:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   15485:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   15489:	75 07                	jne    15492 <ilog2i+0x15>
   1548b:	b8 00 00 00 00       	mov    $0x0,%eax
   15490:	eb 30                	jmp    154c2 <ilog2i+0x45>
  l = ilog2(i);
   15492:	ff 75 08             	pushl  0x8(%ebp)
   15495:	e8 89 ff ff ff       	call   15423 <ilog2>
   1549a:	83 c4 04             	add    $0x4,%esp
   1549d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   154a0:	8b 45 08             	mov    0x8(%ebp),%eax
   154a3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   154a7:	89 c3                	mov    %eax,%ebx
   154a9:	8b 55 08             	mov    0x8(%ebp),%edx
   154ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   154af:	be 01 00 00 00       	mov    $0x1,%esi
   154b4:	89 c1                	mov    %eax,%ecx
   154b6:	d3 e6                	shl    %cl,%esi
   154b8:	89 f0                	mov    %esi,%eax
   154ba:	29 c2                	sub    %eax,%edx
   154bc:	89 d0                	mov    %edx,%eax
   154be:	01 c0                	add    %eax,%eax
   154c0:	01 d8                	add    %ebx,%eax
}
   154c2:	8d 65 f8             	lea    -0x8(%ebp),%esp
   154c5:	5b                   	pop    %ebx
   154c6:	5e                   	pop    %esi
   154c7:	5d                   	pop    %ebp
   154c8:	c3                   	ret    

000154c9 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   154c9:	55                   	push   %ebp
   154ca:	89 e5                	mov    %esp,%ebp
   154cc:	53                   	push   %ebx
   154cd:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   154d3:	ff 75 18             	pushl  0x18(%ebp)
   154d6:	e8 6a 75 ff ff       	call   ca45 <lodepng_get_bpp>
   154db:	83 c4 04             	add    $0x4,%esp
   154de:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   154e1:	ff 75 b8             	pushl  -0x48(%ebp)
   154e4:	6a 01                	push   $0x1
   154e6:	ff 75 10             	pushl  0x10(%ebp)
   154e9:	e8 b6 76 ff ff       	call   cba4 <lodepng_get_raw_size_idat>
   154ee:	83 c4 0c             	add    $0xc,%esp
   154f1:	83 e8 01             	sub    $0x1,%eax
   154f4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   154f7:	8b 45 b8             	mov    -0x48(%ebp),%eax
   154fa:	83 c0 07             	add    $0x7,%eax
   154fd:	c1 e8 03             	shr    $0x3,%eax
   15500:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   15503:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   1550a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   15511:	8b 45 1c             	mov    0x1c(%ebp),%eax
   15514:	8b 40 2c             	mov    0x2c(%eax),%eax
   15517:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   1551a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1551d:	8b 40 28             	mov    0x28(%eax),%eax
   15520:	85 c0                	test   %eax,%eax
   15522:	74 1c                	je     15540 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   15524:	8b 45 18             	mov    0x18(%ebp),%eax
   15527:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   15529:	83 f8 03             	cmp    $0x3,%eax
   1552c:	74 0b                	je     15539 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   1552e:	8b 45 18             	mov    0x18(%ebp),%eax
   15531:	8b 40 04             	mov    0x4(%eax),%eax
   15534:	83 f8 07             	cmp    $0x7,%eax
   15537:	77 07                	ja     15540 <filter+0x77>
   15539:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   15540:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   15544:	75 0a                	jne    15550 <filter+0x87>
   15546:	b8 1f 00 00 00       	mov    $0x1f,%eax
   1554b:	e9 5b 07 00 00       	jmp    15cab <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   15550:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   15554:	77 7b                	ja     155d1 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   15556:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15559:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   1555c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15563:	eb 5f                	jmp    155c4 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   15565:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15568:	83 c0 01             	add    $0x1,%eax
   1556b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1556f:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   15572:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15575:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15579:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   1557c:	8b 55 9c             	mov    -0x64(%ebp),%edx
   1557f:	8b 45 08             	mov    0x8(%ebp),%eax
   15582:	01 c2                	add    %eax,%edx
   15584:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   15588:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   1558a:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   1558e:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   15591:	8b 55 0c             	mov    0xc(%ebp),%edx
   15594:	01 d1                	add    %edx,%ecx
   15596:	8b 55 9c             	mov    -0x64(%ebp),%edx
   15599:	8d 5a 01             	lea    0x1(%edx),%ebx
   1559c:	8b 55 08             	mov    0x8(%ebp),%edx
   1559f:	01 da                	add    %ebx,%edx
   155a1:	50                   	push   %eax
   155a2:	ff 75 b0             	pushl  -0x50(%ebp)
   155a5:	ff 75 b4             	pushl  -0x4c(%ebp)
   155a8:	ff 75 f4             	pushl  -0xc(%ebp)
   155ab:	51                   	push   %ecx
   155ac:	52                   	push   %edx
   155ad:	e8 0d fb ff ff       	call   150bf <filterScanline>
   155b2:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   155b5:	8b 55 98             	mov    -0x68(%ebp),%edx
   155b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   155bb:	01 d0                	add    %edx,%eax
   155bd:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   155c0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   155c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   155c7:	3b 45 14             	cmp    0x14(%ebp),%eax
   155ca:	75 99                	jne    15565 <filter+0x9c>
   155cc:	e9 d7 06 00 00       	jmp    15ca8 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   155d1:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   155d5:	0f 85 e3 01 00 00    	jne    157be <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   155db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   155e2:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   155e6:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   155ea:	eb 2d                	jmp    15619 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   155ec:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   155f0:	83 ec 0c             	sub    $0xc,%esp
   155f3:	ff 75 b4             	pushl  -0x4c(%ebp)
   155f6:	e8 2e 19 ff ff       	call   6f29 <lodepng_malloc>
   155fb:	83 c4 10             	add    $0x10,%esp
   155fe:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   15602:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   15606:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   1560a:	85 c0                	test   %eax,%eax
   1560c:	75 07                	jne    15615 <filter+0x14c>
   1560e:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   15615:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   15619:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   1561d:	75 cd                	jne    155ec <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   1561f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15623:	0f 85 6c 01 00 00    	jne    15795 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   15629:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15630:	e9 54 01 00 00       	jmp    15789 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   15635:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   15639:	e9 d5 00 00 00       	jmp    15713 <filter+0x24a>
          size_t sum = 0;
   1563e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   15645:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   15649:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1564c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15650:	89 c1                	mov    %eax,%ecx
   15652:	8b 45 0c             	mov    0xc(%ebp),%eax
   15655:	01 c1                	add    %eax,%ecx
   15657:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1565b:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   1565f:	83 ec 08             	sub    $0x8,%esp
   15662:	52                   	push   %edx
   15663:	ff 75 b0             	pushl  -0x50(%ebp)
   15666:	ff 75 b4             	pushl  -0x4c(%ebp)
   15669:	ff 75 f4             	pushl  -0xc(%ebp)
   1566c:	51                   	push   %ecx
   1566d:	50                   	push   %eax
   1566e:	e8 4c fa ff ff       	call   150bf <filterScanline>
   15673:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   15676:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   1567a:	75 2d                	jne    156a9 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   1567c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15683:	eb 1a                	jmp    1569f <filter+0x1d6>
   15685:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   15689:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   1568d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15690:	01 d0                	add    %edx,%eax
   15692:	0f b6 00             	movzbl (%eax),%eax
   15695:	0f b6 c0             	movzbl %al,%eax
   15698:	01 45 d8             	add    %eax,-0x28(%ebp)
   1569b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1569f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   156a2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   156a5:	75 de                	jne    15685 <filter+0x1bc>
   156a7:	eb 4b                	jmp    156f4 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   156a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   156b0:	eb 3a                	jmp    156ec <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   156b2:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   156b6:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   156ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156bd:	01 d0                	add    %edx,%eax
   156bf:	0f b6 00             	movzbl (%eax),%eax
   156c2:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   156c5:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   156c9:	84 c0                	test   %al,%al
   156cb:	78 06                	js     156d3 <filter+0x20a>
   156cd:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   156d1:	eb 0d                	jmp    156e0 <filter+0x217>
   156d3:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   156d7:	ba ff 00 00 00       	mov    $0xff,%edx
   156dc:	29 c2                	sub    %eax,%edx
   156de:	89 d0                	mov    %edx,%eax
   156e0:	8b 55 d8             	mov    -0x28(%ebp),%edx
   156e3:	01 d0                	add    %edx,%eax
   156e5:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   156e8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   156ec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   156ef:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   156f2:	75 be                	jne    156b2 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   156f4:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   156f8:	74 08                	je     15702 <filter+0x239>
   156fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
   156fd:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   15700:	7d 0d                	jge    1570f <filter+0x246>
            bestType = type;
   15702:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   15706:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   15709:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1570c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   1570f:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   15713:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   15717:	0f 85 21 ff ff ff    	jne    1563e <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   1571d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15720:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15724:	89 c2                	mov    %eax,%edx
   15726:	8b 45 0c             	mov    0xc(%ebp),%eax
   15729:	01 d0                	add    %edx,%eax
   1572b:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   1572e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15731:	83 c0 01             	add    $0x1,%eax
   15734:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15738:	89 c2                	mov    %eax,%edx
   1573a:	8b 45 08             	mov    0x8(%ebp),%eax
   1573d:	01 c2                	add    %eax,%edx
   1573f:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   15743:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   15745:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1574c:	eb 2f                	jmp    1577d <filter+0x2b4>
   1574e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15751:	83 c0 01             	add    $0x1,%eax
   15754:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15758:	89 c2                	mov    %eax,%edx
   1575a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1575d:	01 d0                	add    %edx,%eax
   1575f:	8d 50 01             	lea    0x1(%eax),%edx
   15762:	8b 45 08             	mov    0x8(%ebp),%eax
   15765:	01 c2                	add    %eax,%edx
   15767:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   1576b:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   1576f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15772:	01 c8                	add    %ecx,%eax
   15774:	0f b6 00             	movzbl (%eax),%eax
   15777:	88 02                	mov    %al,(%edx)
   15779:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1577d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15780:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   15783:	75 c9                	jne    1574e <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   15785:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15789:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1578c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1578f:	0f 85 a0 fe ff ff    	jne    15635 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   15795:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   15799:	eb 18                	jmp    157b3 <filter+0x2ea>
   1579b:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   1579f:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   157a3:	83 ec 0c             	sub    $0xc,%esp
   157a6:	50                   	push   %eax
   157a7:	e8 9e 17 ff ff       	call   6f4a <lodepng_free>
   157ac:	83 c4 10             	add    $0x10,%esp
   157af:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   157b3:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   157b7:	75 e2                	jne    1579b <filter+0x2d2>
   157b9:	e9 ea 04 00 00       	jmp    15ca8 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   157be:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   157c2:	0f 85 17 02 00 00    	jne    159df <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   157c8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   157cf:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   157d6:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   157dd:	eb 33                	jmp    15812 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   157df:	83 ec 0c             	sub    $0xc,%esp
   157e2:	ff 75 b4             	pushl  -0x4c(%ebp)
   157e5:	e8 3f 17 ff ff       	call   6f29 <lodepng_malloc>
   157ea:	83 c4 10             	add    $0x10,%esp
   157ed:	89 c2                	mov    %eax,%edx
   157ef:	8b 45 d0             	mov    -0x30(%ebp),%eax
   157f2:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   157f9:	8b 45 d0             	mov    -0x30(%ebp),%eax
   157fc:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   15803:	85 c0                	test   %eax,%eax
   15805:	75 07                	jne    1580e <filter+0x345>
   15807:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   1580e:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   15812:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   15816:	75 c7                	jne    157df <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   15818:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1581c:	0f 85 8f 01 00 00    	jne    159b1 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   15822:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15829:	e9 77 01 00 00       	jmp    159a5 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   1582e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   15835:	e9 f4 00 00 00       	jmp    1592e <filter+0x465>
          size_t sum = 0;
   1583a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   15841:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15844:	0f b6 d0             	movzbl %al,%edx
   15847:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1584a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1584e:	89 c1                	mov    %eax,%ecx
   15850:	8b 45 0c             	mov    0xc(%ebp),%eax
   15853:	01 c1                	add    %eax,%ecx
   15855:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15858:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   1585f:	83 ec 08             	sub    $0x8,%esp
   15862:	52                   	push   %edx
   15863:	ff 75 b0             	pushl  -0x50(%ebp)
   15866:	ff 75 b4             	pushl  -0x4c(%ebp)
   15869:	ff 75 f4             	pushl  -0xc(%ebp)
   1586c:	51                   	push   %ecx
   1586d:	50                   	push   %eax
   1586e:	e8 4c f8 ff ff       	call   150bf <filterScanline>
   15873:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   15876:	83 ec 04             	sub    $0x4,%esp
   15879:	68 00 04 00 00       	push   $0x400
   1587e:	6a 00                	push   $0x0
   15880:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   15886:	50                   	push   %eax
   15887:	e8 0e 17 ff ff       	call   6f9a <lodepng_memset>
   1588c:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   1588f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15896:	eb 2a                	jmp    158c2 <filter+0x3f9>
   15898:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1589b:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   158a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158a5:	01 d0                	add    %edx,%eax
   158a7:	0f b6 00             	movzbl (%eax),%eax
   158aa:	0f b6 c0             	movzbl %al,%eax
   158ad:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   158b4:	83 c2 01             	add    $0x1,%edx
   158b7:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   158be:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   158c2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   158c5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   158c8:	75 ce                	jne    15898 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   158ca:	8b 45 d0             	mov    -0x30(%ebp),%eax
   158cd:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   158d4:	8d 50 01             	lea    0x1(%eax),%edx
   158d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   158da:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   158e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   158e8:	eb 1d                	jmp    15907 <filter+0x43e>
            sum += ilog2i(count[x]);
   158ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158ed:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   158f4:	83 ec 0c             	sub    $0xc,%esp
   158f7:	50                   	push   %eax
   158f8:	e8 80 fb ff ff       	call   1547d <ilog2i>
   158fd:	83 c4 10             	add    $0x10,%esp
   15900:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   15903:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15907:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   1590e:	75 da                	jne    158ea <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   15910:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   15914:	74 08                	je     1591e <filter+0x455>
   15916:	8b 45 c8             	mov    -0x38(%ebp),%eax
   15919:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   1591c:	7e 0c                	jle    1592a <filter+0x461>
            bestType = type;
   1591e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15921:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   15924:	8b 45 c8             	mov    -0x38(%ebp),%eax
   15927:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   1592a:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   1592e:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   15932:	0f 85 02 ff ff ff    	jne    1583a <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   15938:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1593b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1593f:	89 c2                	mov    %eax,%edx
   15941:	8b 45 0c             	mov    0xc(%ebp),%eax
   15944:	01 d0                	add    %edx,%eax
   15946:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   15949:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1594c:	83 c0 01             	add    $0x1,%eax
   1594f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15953:	89 c2                	mov    %eax,%edx
   15955:	8b 45 08             	mov    0x8(%ebp),%eax
   15958:	01 d0                	add    %edx,%eax
   1595a:	8b 55 cc             	mov    -0x34(%ebp),%edx
   1595d:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1595f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15966:	eb 31                	jmp    15999 <filter+0x4d0>
   15968:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1596b:	83 c0 01             	add    $0x1,%eax
   1596e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15972:	89 c2                	mov    %eax,%edx
   15974:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15977:	01 d0                	add    %edx,%eax
   15979:	8d 50 01             	lea    0x1(%eax),%edx
   1597c:	8b 45 08             	mov    0x8(%ebp),%eax
   1597f:	01 c2                	add    %eax,%edx
   15981:	8b 45 cc             	mov    -0x34(%ebp),%eax
   15984:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   1598b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1598e:	01 c8                	add    %ecx,%eax
   15990:	0f b6 00             	movzbl (%eax),%eax
   15993:	88 02                	mov    %al,(%edx)
   15995:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15999:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1599c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1599f:	75 c7                	jne    15968 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   159a1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   159a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   159a8:	3b 45 14             	cmp    0x14(%ebp),%eax
   159ab:	0f 85 7d fe ff ff    	jne    1582e <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   159b1:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   159b8:	eb 1a                	jmp    159d4 <filter+0x50b>
   159ba:	8b 45 d0             	mov    -0x30(%ebp),%eax
   159bd:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   159c4:	83 ec 0c             	sub    $0xc,%esp
   159c7:	50                   	push   %eax
   159c8:	e8 7d 15 ff ff       	call   6f4a <lodepng_free>
   159cd:	83 c4 10             	add    $0x10,%esp
   159d0:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   159d4:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   159d8:	75 e0                	jne    159ba <filter+0x4f1>
   159da:	e9 c9 02 00 00       	jmp    15ca8 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   159df:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   159e3:	0f 85 89 00 00 00    	jne    15a72 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   159e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   159f0:	eb 73                	jmp    15a65 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   159f2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   159f5:	83 c0 01             	add    $0x1,%eax
   159f8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   159fc:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   159ff:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15a02:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15a06:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   15a09:	8b 45 1c             	mov    0x1c(%ebp),%eax
   15a0c:	8b 50 30             	mov    0x30(%eax),%edx
   15a0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a12:	01 d0                	add    %edx,%eax
   15a14:	0f b6 00             	movzbl (%eax),%eax
   15a17:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   15a1a:	8b 55 a8             	mov    -0x58(%ebp),%edx
   15a1d:	8b 45 08             	mov    0x8(%ebp),%eax
   15a20:	01 c2                	add    %eax,%edx
   15a22:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   15a26:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   15a28:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   15a2c:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   15a2f:	8b 55 0c             	mov    0xc(%ebp),%edx
   15a32:	01 d1                	add    %edx,%ecx
   15a34:	8b 55 a8             	mov    -0x58(%ebp),%edx
   15a37:	8d 5a 01             	lea    0x1(%edx),%ebx
   15a3a:	8b 55 08             	mov    0x8(%ebp),%edx
   15a3d:	01 da                	add    %ebx,%edx
   15a3f:	83 ec 08             	sub    $0x8,%esp
   15a42:	50                   	push   %eax
   15a43:	ff 75 b0             	pushl  -0x50(%ebp)
   15a46:	ff 75 b4             	pushl  -0x4c(%ebp)
   15a49:	ff 75 f4             	pushl  -0xc(%ebp)
   15a4c:	51                   	push   %ecx
   15a4d:	52                   	push   %edx
   15a4e:	e8 6c f6 ff ff       	call   150bf <filterScanline>
   15a53:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   15a56:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   15a59:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a5c:	01 d0                	add    %edx,%eax
   15a5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   15a61:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15a65:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a68:	3b 45 14             	cmp    0x14(%ebp),%eax
   15a6b:	75 85                	jne    159f2 <filter+0x529>
   15a6d:	e9 36 02 00 00       	jmp    15ca8 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   15a72:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   15a76:	0f 85 25 02 00 00    	jne    15ca1 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   15a7c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   15a83:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   15a8a:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   15a91:	8b 45 1c             	mov    0x1c(%ebp),%eax
   15a94:	83 ec 04             	sub    $0x4,%esp
   15a97:	6a 24                	push   $0x24
   15a99:	50                   	push   %eax
   15a9a:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   15aa0:	50                   	push   %eax
   15aa1:	e8 c1 14 ff ff       	call   6f67 <lodepng_memcpy>
   15aa6:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   15aa9:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   15ab0:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   15ab3:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   15aba:	00 00 00 
    zlibsettings.custom_deflate = 0;
   15abd:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   15ac4:	00 00 00 
    for(type = 0; type != 5; ++type) {
   15ac7:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   15ace:	eb 33                	jmp    15b03 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   15ad0:	83 ec 0c             	sub    $0xc,%esp
   15ad3:	ff 75 b4             	pushl  -0x4c(%ebp)
   15ad6:	e8 4e 14 ff ff       	call   6f29 <lodepng_malloc>
   15adb:	83 c4 10             	add    $0x10,%esp
   15ade:	89 c2                	mov    %eax,%edx
   15ae0:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15ae3:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   15aea:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15aed:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   15af4:	85 c0                	test   %eax,%eax
   15af6:	75 07                	jne    15aff <filter+0x636>
   15af8:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   15aff:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   15b03:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   15b07:	75 c7                	jne    15ad0 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   15b09:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15b0d:	0f 85 63 01 00 00    	jne    15c76 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   15b13:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15b1a:	e9 4b 01 00 00       	jmp    15c6a <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   15b1f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   15b26:	e9 c8 00 00 00       	jmp    15bf3 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   15b2b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15b2e:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   15b31:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15b34:	0f b6 d0             	movzbl %al,%edx
   15b37:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15b3a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15b3e:	89 c1                	mov    %eax,%ecx
   15b40:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b43:	01 c1                	add    %eax,%ecx
   15b45:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15b48:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   15b4f:	83 ec 08             	sub    $0x8,%esp
   15b52:	52                   	push   %edx
   15b53:	ff 75 b0             	pushl  -0x50(%ebp)
   15b56:	ff 75 b4             	pushl  -0x4c(%ebp)
   15b59:	ff 75 f4             	pushl  -0xc(%ebp)
   15b5c:	51                   	push   %ecx
   15b5d:	50                   	push   %eax
   15b5e:	e8 5c f5 ff ff       	call   150bf <filterScanline>
   15b63:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   15b66:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15b69:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   15b70:	00 00 00 00 
          dummy = 0;
   15b74:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   15b7b:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   15b7e:	8b 55 ac             	mov    -0x54(%ebp),%edx
   15b81:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15b84:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   15b8b:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   15b91:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   15b94:	c1 e3 02             	shl    $0x2,%ebx
   15b97:	01 cb                	add    %ecx,%ebx
   15b99:	83 ec 0c             	sub    $0xc,%esp
   15b9c:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   15ba2:	51                   	push   %ecx
   15ba3:	52                   	push   %edx
   15ba4:	50                   	push   %eax
   15ba5:	53                   	push   %ebx
   15ba6:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   15bac:	50                   	push   %eax
   15bad:	e8 87 60 ff ff       	call   bc39 <zlib_compress>
   15bb2:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   15bb5:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   15bbb:	83 ec 0c             	sub    $0xc,%esp
   15bbe:	50                   	push   %eax
   15bbf:	e8 86 13 ff ff       	call   6f4a <lodepng_free>
   15bc4:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   15bc7:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   15bcb:	74 0f                	je     15bdc <filter+0x713>
   15bcd:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15bd0:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   15bd7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   15bda:	7d 13                	jge    15bef <filter+0x726>
            bestType = type;
   15bdc:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15bdf:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   15be2:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15be5:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   15bec:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   15bef:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   15bf3:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   15bf7:	0f 85 2e ff ff ff    	jne    15b2b <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   15bfd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15c00:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15c04:	89 c2                	mov    %eax,%edx
   15c06:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c09:	01 d0                	add    %edx,%eax
   15c0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   15c0e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15c11:	83 c0 01             	add    $0x1,%eax
   15c14:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15c18:	89 c2                	mov    %eax,%edx
   15c1a:	8b 45 08             	mov    0x8(%ebp),%eax
   15c1d:	01 d0                	add    %edx,%eax
   15c1f:	8b 55 bc             	mov    -0x44(%ebp),%edx
   15c22:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   15c24:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15c2b:	eb 31                	jmp    15c5e <filter+0x795>
   15c2d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15c30:	83 c0 01             	add    $0x1,%eax
   15c33:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15c37:	89 c2                	mov    %eax,%edx
   15c39:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c3c:	01 d0                	add    %edx,%eax
   15c3e:	8d 50 01             	lea    0x1(%eax),%edx
   15c41:	8b 45 08             	mov    0x8(%ebp),%eax
   15c44:	01 c2                	add    %eax,%edx
   15c46:	8b 45 bc             	mov    -0x44(%ebp),%eax
   15c49:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   15c50:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c53:	01 c8                	add    %ecx,%eax
   15c55:	0f b6 00             	movzbl (%eax),%eax
   15c58:	88 02                	mov    %al,(%edx)
   15c5a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15c5e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   15c61:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   15c64:	75 c7                	jne    15c2d <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   15c66:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15c6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15c6d:	3b 45 14             	cmp    0x14(%ebp),%eax
   15c70:	0f 85 a9 fe ff ff    	jne    15b1f <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   15c76:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   15c7d:	eb 1a                	jmp    15c99 <filter+0x7d0>
   15c7f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   15c82:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   15c89:	83 ec 0c             	sub    $0xc,%esp
   15c8c:	50                   	push   %eax
   15c8d:	e8 b8 12 ff ff       	call   6f4a <lodepng_free>
   15c92:	83 c4 10             	add    $0x10,%esp
   15c95:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   15c99:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   15c9d:	75 e0                	jne    15c7f <filter+0x7b6>
   15c9f:	eb 07                	jmp    15ca8 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   15ca1:	b8 58 00 00 00       	mov    $0x58,%eax
   15ca6:	eb 03                	jmp    15cab <filter+0x7e2>

  return error;
   15ca8:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   15cab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15cae:	c9                   	leave  
   15caf:	c3                   	ret    

00015cb0 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   15cb0:	55                   	push   %ebp
   15cb1:	89 e5                	mov    %esp,%ebp
   15cb3:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   15cb6:	8b 45 10             	mov    0x10(%ebp),%eax
   15cb9:	2b 45 14             	sub    0x14(%ebp),%eax
   15cbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   15cbf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15cc6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   15ccd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   15cd4:	eb 65                	jmp    15d3b <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   15cd6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   15cdd:	eb 2a                	jmp    15d09 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   15cdf:	ff 75 0c             	pushl  0xc(%ebp)
   15ce2:	8d 45 e8             	lea    -0x18(%ebp),%eax
   15ce5:	50                   	push   %eax
   15ce6:	e8 9d 60 ff ff       	call   bd88 <readBitFromReversedStream>
   15ceb:	83 c4 08             	add    $0x8,%esp
   15cee:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   15cf1:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   15cf5:	50                   	push   %eax
   15cf6:	ff 75 08             	pushl  0x8(%ebp)
   15cf9:	8d 45 ec             	lea    -0x14(%ebp),%eax
   15cfc:	50                   	push   %eax
   15cfd:	e8 08 61 ff ff       	call   be0a <setBitOfReversedStream>
   15d02:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   15d05:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   15d09:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15d0c:	3b 45 14             	cmp    0x14(%ebp),%eax
   15d0f:	7c ce                	jl     15cdf <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   15d11:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   15d18:	eb 15                	jmp    15d2f <addPaddingBits+0x7f>
   15d1a:	6a 00                	push   $0x0
   15d1c:	ff 75 08             	pushl  0x8(%ebp)
   15d1f:	8d 45 ec             	lea    -0x14(%ebp),%eax
   15d22:	50                   	push   %eax
   15d23:	e8 e2 60 ff ff       	call   be0a <setBitOfReversedStream>
   15d28:	83 c4 0c             	add    $0xc,%esp
   15d2b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   15d2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15d32:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15d35:	75 e3                	jne    15d1a <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   15d37:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   15d3b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15d3e:	3b 45 18             	cmp    0x18(%ebp),%eax
   15d41:	75 93                	jne    15cd6 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   15d43:	90                   	nop
   15d44:	c9                   	leave  
   15d45:	c3                   	ret    

00015d46 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   15d46:	55                   	push   %ebp
   15d47:	89 e5                	mov    %esp,%ebp
   15d49:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   15d4f:	ff 75 18             	pushl  0x18(%ebp)
   15d52:	ff 75 14             	pushl  0x14(%ebp)
   15d55:	ff 75 10             	pushl  0x10(%ebp)
   15d58:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   15d5e:	50                   	push   %eax
   15d5f:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   15d65:	50                   	push   %eax
   15d66:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   15d6c:	50                   	push   %eax
   15d6d:	8d 45 94             	lea    -0x6c(%ebp),%eax
   15d70:	50                   	push   %eax
   15d71:	8d 45 b0             	lea    -0x50(%ebp),%eax
   15d74:	50                   	push   %eax
   15d75:	e8 fc ae ff ff       	call   10c76 <Adam7_getpassvalues>
   15d7a:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   15d7d:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   15d81:	0f 86 0a 01 00 00    	jbe    15e91 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   15d87:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   15d8e:	e9 ef 00 00 00       	jmp    15e82 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   15d93:	8b 45 18             	mov    0x18(%ebp),%eax
   15d96:	c1 e8 03             	shr    $0x3,%eax
   15d99:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   15d9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15da3:	e9 c6 00 00 00       	jmp    15e6e <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   15da8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   15daf:	e9 a6 00 00 00       	jmp    15e5a <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   15db4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15db7:	8b 14 85 98 f3 01 00 	mov    0x1f398(,%eax,4),%edx
   15dbe:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15dc1:	8b 04 85 d0 f3 01 00 	mov    0x1f3d0(,%eax,4),%eax
   15dc8:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   15dcc:	01 d0                	add    %edx,%eax
   15dce:	0f af 45 10          	imul   0x10(%ebp),%eax
   15dd2:	89 c2                	mov    %eax,%edx
   15dd4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15dd7:	8b 04 85 b4 f3 01 00 	mov    0x1f3b4(,%eax,4),%eax
   15dde:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   15de2:	01 c2                	add    %eax,%edx
   15de4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15de7:	8b 04 85 7c f3 01 00 	mov    0x1f37c(,%eax,4),%eax
   15dee:	01 c2                	add    %eax,%edx
   15df0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15df3:	0f af c2             	imul   %edx,%eax
   15df6:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   15df9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15dfc:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   15e03:	89 c1                	mov    %eax,%ecx
   15e05:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15e08:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   15e0c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   15e10:	89 c2                	mov    %eax,%edx
   15e12:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15e15:	01 c2                	add    %eax,%edx
   15e17:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e1a:	0f af c2             	imul   %edx,%eax
   15e1d:	01 c8                	add    %ecx,%eax
   15e1f:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   15e22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   15e29:	eb 23                	jmp    15e4e <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   15e2b:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15e2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e31:	01 c2                	add    %eax,%edx
   15e33:	8b 45 08             	mov    0x8(%ebp),%eax
   15e36:	01 c2                	add    %eax,%edx
   15e38:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   15e3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e3e:	01 c1                	add    %eax,%ecx
   15e40:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e43:	01 c8                	add    %ecx,%eax
   15e45:	0f b6 00             	movzbl (%eax),%eax
   15e48:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   15e4a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   15e4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e51:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   15e54:	72 d5                	jb     15e2b <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   15e56:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   15e5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15e5d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   15e61:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   15e64:	0f 87 4a ff ff ff    	ja     15db4 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   15e6a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15e6e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15e71:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   15e75:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   15e78:	0f 87 2a ff ff ff    	ja     15da8 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   15e7e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   15e82:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   15e86:	0f 85 07 ff ff ff    	jne    15d93 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   15e8c:	e9 22 01 00 00       	jmp    15fb3 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   15e91:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   15e98:	e9 0c 01 00 00       	jmp    15fa9 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   15e9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15ea0:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   15ea4:	0f af 45 18          	imul   0x18(%ebp),%eax
   15ea8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   15eab:	8b 45 18             	mov    0x18(%ebp),%eax
   15eae:	0f af 45 10          	imul   0x10(%ebp),%eax
   15eb2:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   15eb5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   15ebc:	e9 d4 00 00 00       	jmp    15f95 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   15ec1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15ec8:	e9 b4 00 00 00       	jmp    15f81 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   15ecd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15ed0:	8b 14 85 98 f3 01 00 	mov    0x1f398(,%eax,4),%edx
   15ed7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15eda:	8b 04 85 d0 f3 01 00 	mov    0x1f3d0(,%eax,4),%eax
   15ee1:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   15ee5:	01 d0                	add    %edx,%eax
   15ee7:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   15eeb:	89 c2                	mov    %eax,%edx
   15eed:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15ef0:	8b 0c 85 7c f3 01 00 	mov    0x1f37c(,%eax,4),%ecx
   15ef7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15efa:	8b 04 85 b4 f3 01 00 	mov    0x1f3b4(,%eax,4),%eax
   15f01:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   15f05:	01 c8                	add    %ecx,%eax
   15f07:	0f af 45 18          	imul   0x18(%ebp),%eax
   15f0b:	01 d0                	add    %edx,%eax
   15f0d:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   15f13:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15f16:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   15f1d:	c1 e0 03             	shl    $0x3,%eax
   15f20:	89 c1                	mov    %eax,%ecx
   15f22:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f25:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   15f29:	89 c2                	mov    %eax,%edx
   15f2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15f2e:	0f af 45 18          	imul   0x18(%ebp),%eax
   15f32:	01 d0                	add    %edx,%eax
   15f34:	01 c8                	add    %ecx,%eax
   15f36:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   15f3c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15f43:	eb 30                	jmp    15f75 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   15f45:	ff 75 0c             	pushl  0xc(%ebp)
   15f48:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   15f4e:	50                   	push   %eax
   15f4f:	e8 34 5e ff ff       	call   bd88 <readBitFromReversedStream>
   15f54:	83 c4 08             	add    $0x8,%esp
   15f57:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   15f5a:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   15f5e:	50                   	push   %eax
   15f5f:	ff 75 08             	pushl  0x8(%ebp)
   15f62:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   15f68:	50                   	push   %eax
   15f69:	e8 9c 5e ff ff       	call   be0a <setBitOfReversedStream>
   15f6e:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   15f71:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15f75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15f78:	3b 45 18             	cmp    0x18(%ebp),%eax
   15f7b:	72 c8                	jb     15f45 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   15f7d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15f81:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15f84:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   15f88:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   15f8b:	0f 87 3c ff ff ff    	ja     15ecd <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   15f91:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   15f95:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15f98:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   15f9c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   15f9f:	0f 87 1c ff ff ff    	ja     15ec1 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   15fa5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   15fa9:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   15fad:	0f 85 ea fe ff ff    	jne    15e9d <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   15fb3:	90                   	nop
   15fb4:	c9                   	leave  
   15fb5:	c3                   	ret    

00015fb6 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   15fb6:	55                   	push   %ebp
   15fb7:	89 e5                	mov    %esp,%ebp
   15fb9:	57                   	push   %edi
   15fba:	56                   	push   %esi
   15fbb:	53                   	push   %ebx
   15fbc:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   15fc2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   15fc5:	83 c0 0c             	add    $0xc,%eax
   15fc8:	50                   	push   %eax
   15fc9:	e8 77 6a ff ff       	call   ca45 <lodepng_get_bpp>
   15fce:	83 c4 04             	add    $0x4,%esp
   15fd1:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   15fd4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   15fdb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   15fde:	8b 40 08             	mov    0x8(%eax),%eax
   15fe1:	85 c0                	test   %eax,%eax
   15fe3:	0f 85 49 01 00 00    	jne    16132 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   15fe9:	8b 45 14             	mov    0x14(%ebp),%eax
   15fec:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   15ff0:	83 c0 07             	add    $0x7,%eax
   15ff3:	c1 e8 03             	shr    $0x3,%eax
   15ff6:	83 c0 01             	add    $0x1,%eax
   15ff9:	0f af 45 18          	imul   0x18(%ebp),%eax
   15ffd:	89 c2                	mov    %eax,%edx
   15fff:	8b 45 0c             	mov    0xc(%ebp),%eax
   16002:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   16004:	8b 45 0c             	mov    0xc(%ebp),%eax
   16007:	8b 00                	mov    (%eax),%eax
   16009:	83 ec 0c             	sub    $0xc,%esp
   1600c:	50                   	push   %eax
   1600d:	e8 17 0f ff ff       	call   6f29 <lodepng_malloc>
   16012:	83 c4 10             	add    $0x10,%esp
   16015:	89 c2                	mov    %eax,%edx
   16017:	8b 45 08             	mov    0x8(%ebp),%eax
   1601a:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   1601c:	8b 45 08             	mov    0x8(%ebp),%eax
   1601f:	8b 00                	mov    (%eax),%eax
   16021:	85 c0                	test   %eax,%eax
   16023:	75 10                	jne    16035 <preProcessScanlines+0x7f>
   16025:	8b 45 0c             	mov    0xc(%ebp),%eax
   16028:	8b 00                	mov    (%eax),%eax
   1602a:	85 c0                	test   %eax,%eax
   1602c:	74 07                	je     16035 <preProcessScanlines+0x7f>
   1602e:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   16035:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   16039:	0f 85 fb 02 00 00    	jne    1633a <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   1603f:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   16043:	0f 87 bd 00 00 00    	ja     16106 <preProcessScanlines+0x150>
   16049:	8b 45 14             	mov    0x14(%ebp),%eax
   1604c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   16050:	89 c2                	mov    %eax,%edx
   16052:	8b 45 14             	mov    0x14(%ebp),%eax
   16055:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   16059:	83 c0 07             	add    $0x7,%eax
   1605c:	c1 e8 03             	shr    $0x3,%eax
   1605f:	c1 e0 03             	shl    $0x3,%eax
   16062:	39 c2                	cmp    %eax,%edx
   16064:	0f 84 9c 00 00 00    	je     16106 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   1606a:	8b 45 14             	mov    0x14(%ebp),%eax
   1606d:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   16071:	83 c0 07             	add    $0x7,%eax
   16074:	c1 e8 03             	shr    $0x3,%eax
   16077:	0f af 45 18          	imul   0x18(%ebp),%eax
   1607b:	83 ec 0c             	sub    $0xc,%esp
   1607e:	50                   	push   %eax
   1607f:	e8 a5 0e ff ff       	call   6f29 <lodepng_malloc>
   16084:	83 c4 10             	add    $0x10,%esp
   16087:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   1608a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1608e:	75 07                	jne    16097 <preProcessScanlines+0xe1>
   16090:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   16097:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1609b:	75 56                	jne    160f3 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   1609d:	8b 45 14             	mov    0x14(%ebp),%eax
   160a0:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   160a4:	89 c2                	mov    %eax,%edx
   160a6:	8b 45 14             	mov    0x14(%ebp),%eax
   160a9:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   160ad:	83 c0 07             	add    $0x7,%eax
   160b0:	c1 e8 03             	shr    $0x3,%eax
   160b3:	c1 e0 03             	shl    $0x3,%eax
   160b6:	83 ec 0c             	sub    $0xc,%esp
   160b9:	ff 75 18             	pushl  0x18(%ebp)
   160bc:	52                   	push   %edx
   160bd:	50                   	push   %eax
   160be:	ff 75 10             	pushl  0x10(%ebp)
   160c1:	ff 75 d8             	pushl  -0x28(%ebp)
   160c4:	e8 e7 fb ff ff       	call   15cb0 <addPaddingBits>
   160c9:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   160cc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   160cf:	8d 50 0c             	lea    0xc(%eax),%edx
   160d2:	8b 45 08             	mov    0x8(%ebp),%eax
   160d5:	8b 00                	mov    (%eax),%eax
   160d7:	83 ec 08             	sub    $0x8,%esp
   160da:	ff 75 20             	pushl  0x20(%ebp)
   160dd:	52                   	push   %edx
   160de:	ff 75 18             	pushl  0x18(%ebp)
   160e1:	ff 75 14             	pushl  0x14(%ebp)
   160e4:	ff 75 d8             	pushl  -0x28(%ebp)
   160e7:	50                   	push   %eax
   160e8:	e8 dc f3 ff ff       	call   154c9 <filter>
   160ed:	83 c4 20             	add    $0x20,%esp
   160f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   160f3:	83 ec 0c             	sub    $0xc,%esp
   160f6:	ff 75 d8             	pushl  -0x28(%ebp)
   160f9:	e8 4c 0e ff ff       	call   6f4a <lodepng_free>
   160fe:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   16101:	e9 34 02 00 00       	jmp    1633a <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   16106:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16109:	8d 50 0c             	lea    0xc(%eax),%edx
   1610c:	8b 45 08             	mov    0x8(%ebp),%eax
   1610f:	8b 00                	mov    (%eax),%eax
   16111:	83 ec 08             	sub    $0x8,%esp
   16114:	ff 75 20             	pushl  0x20(%ebp)
   16117:	52                   	push   %edx
   16118:	ff 75 18             	pushl  0x18(%ebp)
   1611b:	ff 75 14             	pushl  0x14(%ebp)
   1611e:	ff 75 10             	pushl  0x10(%ebp)
   16121:	50                   	push   %eax
   16122:	e8 a2 f3 ff ff       	call   154c9 <filter>
   16127:	83 c4 20             	add    $0x20,%esp
   1612a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   1612d:	e9 08 02 00 00       	jmp    1633a <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   16132:	ff 75 dc             	pushl  -0x24(%ebp)
   16135:	ff 75 18             	pushl  0x18(%ebp)
   16138:	ff 75 14             	pushl  0x14(%ebp)
   1613b:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   16141:	50                   	push   %eax
   16142:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   16148:	50                   	push   %eax
   16149:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   1614f:	50                   	push   %eax
   16150:	8d 45 98             	lea    -0x68(%ebp),%eax
   16153:	50                   	push   %eax
   16154:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   16157:	50                   	push   %eax
   16158:	e8 19 ab ff ff       	call   10c76 <Adam7_getpassvalues>
   1615d:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   16160:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   16166:	8b 45 0c             	mov    0xc(%ebp),%eax
   16169:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   1616b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1616e:	8b 00                	mov    (%eax),%eax
   16170:	83 ec 0c             	sub    $0xc,%esp
   16173:	50                   	push   %eax
   16174:	e8 b0 0d ff ff       	call   6f29 <lodepng_malloc>
   16179:	83 c4 10             	add    $0x10,%esp
   1617c:	89 c2                	mov    %eax,%edx
   1617e:	8b 45 08             	mov    0x8(%ebp),%eax
   16181:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   16183:	8b 45 08             	mov    0x8(%ebp),%eax
   16186:	8b 00                	mov    (%eax),%eax
   16188:	85 c0                	test   %eax,%eax
   1618a:	75 07                	jne    16193 <preProcessScanlines+0x1dd>
   1618c:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   16193:	8b 45 94             	mov    -0x6c(%ebp),%eax
   16196:	83 ec 0c             	sub    $0xc,%esp
   16199:	50                   	push   %eax
   1619a:	e8 8a 0d ff ff       	call   6f29 <lodepng_malloc>
   1619f:	83 c4 10             	add    $0x10,%esp
   161a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   161a5:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   161a9:	75 0e                	jne    161b9 <preProcessScanlines+0x203>
   161ab:	8b 45 94             	mov    -0x6c(%ebp),%eax
   161ae:	85 c0                	test   %eax,%eax
   161b0:	74 07                	je     161b9 <preProcessScanlines+0x203>
   161b2:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   161b9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   161bd:	0f 85 69 01 00 00    	jne    1632c <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   161c3:	83 ec 0c             	sub    $0xc,%esp
   161c6:	ff 75 dc             	pushl  -0x24(%ebp)
   161c9:	ff 75 18             	pushl  0x18(%ebp)
   161cc:	ff 75 14             	pushl  0x14(%ebp)
   161cf:	ff 75 10             	pushl  0x10(%ebp)
   161d2:	ff 75 d4             	pushl  -0x2c(%ebp)
   161d5:	e8 6c fb ff ff       	call   15d46 <Adam7_interlace>
   161da:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   161dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   161e4:	e9 36 01 00 00       	jmp    1631f <preProcessScanlines+0x369>
        if(bpp < 8) {
   161e9:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   161ed:	0f 87 d6 00 00 00    	ja     162c9 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   161f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   161f6:	83 c0 01             	add    $0x1,%eax
   161f9:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   16200:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16203:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   1620a:	29 c2                	sub    %eax,%edx
   1620c:	89 d0                	mov    %edx,%eax
   1620e:	83 ec 0c             	sub    $0xc,%esp
   16211:	50                   	push   %eax
   16212:	e8 12 0d ff ff       	call   6f29 <lodepng_malloc>
   16217:	83 c4 10             	add    $0x10,%esp
   1621a:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   1621d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   16221:	75 0c                	jne    1622f <preProcessScanlines+0x279>
   16223:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   1622a:	e9 fd 00 00 00       	jmp    1632c <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   1622f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16232:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   16236:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16239:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   1623d:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   16241:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   16243:	8b 55 e0             	mov    -0x20(%ebp),%edx
   16246:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   1624a:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   1624e:	83 c2 07             	add    $0x7,%edx
   16251:	c1 ea 03             	shr    $0x3,%edx
   16254:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   16257:	89 d1                	mov    %edx,%ecx
   16259:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1625c:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   16263:	89 d6                	mov    %edx,%esi
   16265:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   16268:	01 f2                	add    %esi,%edx
   1626a:	83 ec 0c             	sub    $0xc,%esp
   1626d:	50                   	push   %eax
   1626e:	53                   	push   %ebx
   1626f:	51                   	push   %ecx
   16270:	52                   	push   %edx
   16271:	ff 75 d0             	pushl  -0x30(%ebp)
   16274:	e8 37 fa ff ff       	call   15cb0 <addPaddingBits>
   16279:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   1627c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1627f:	8d 58 0c             	lea    0xc(%eax),%ebx
   16282:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16285:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   16289:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1628c:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   16290:	8b 4d 08             	mov    0x8(%ebp),%ecx
   16293:	8b 31                	mov    (%ecx),%esi
   16295:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   16298:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   1629f:	01 f1                	add    %esi,%ecx
   162a1:	83 ec 08             	sub    $0x8,%esp
   162a4:	ff 75 20             	pushl  0x20(%ebp)
   162a7:	53                   	push   %ebx
   162a8:	52                   	push   %edx
   162a9:	50                   	push   %eax
   162aa:	ff 75 d0             	pushl  -0x30(%ebp)
   162ad:	51                   	push   %ecx
   162ae:	e8 16 f2 ff ff       	call   154c9 <filter>
   162b3:	83 c4 20             	add    $0x20,%esp
   162b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   162b9:	83 ec 0c             	sub    $0xc,%esp
   162bc:	ff 75 d0             	pushl  -0x30(%ebp)
   162bf:	e8 86 0c ff ff       	call   6f4a <lodepng_free>
   162c4:	83 c4 10             	add    $0x10,%esp
   162c7:	eb 4c                	jmp    16315 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   162c9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   162cc:	8d 70 0c             	lea    0xc(%eax),%esi
   162cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
   162d2:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   162d6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   162d9:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   162dd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   162e0:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   162e7:	89 cb                	mov    %ecx,%ebx
   162e9:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   162ec:	01 cb                	add    %ecx,%ebx
   162ee:	8b 4d 08             	mov    0x8(%ebp),%ecx
   162f1:	8b 39                	mov    (%ecx),%edi
   162f3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   162f6:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   162fd:	01 f9                	add    %edi,%ecx
   162ff:	83 ec 08             	sub    $0x8,%esp
   16302:	ff 75 20             	pushl  0x20(%ebp)
   16305:	56                   	push   %esi
   16306:	52                   	push   %edx
   16307:	50                   	push   %eax
   16308:	53                   	push   %ebx
   16309:	51                   	push   %ecx
   1630a:	e8 ba f1 ff ff       	call   154c9 <filter>
   1630f:	83 c4 20             	add    $0x20,%esp
   16312:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   16315:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   16319:	75 10                	jne    1632b <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   1631b:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   1631f:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   16323:	0f 85 c0 fe ff ff    	jne    161e9 <preProcessScanlines+0x233>
   16329:	eb 01                	jmp    1632c <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   1632b:	90                   	nop
      }
    }

    lodepng_free(adam7);
   1632c:	83 ec 0c             	sub    $0xc,%esp
   1632f:	ff 75 d4             	pushl  -0x2c(%ebp)
   16332:	e8 13 0c ff ff       	call   6f4a <lodepng_free>
   16337:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   1633a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   1633d:	8d 65 f4             	lea    -0xc(%ebp),%esp
   16340:	5b                   	pop    %ebx
   16341:	5e                   	pop    %esi
   16342:	5f                   	pop    %edi
   16343:	5d                   	pop    %ebp
   16344:	c3                   	ret    

00016345 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   16345:	55                   	push   %ebp
   16346:	89 e5                	mov    %esp,%ebp
   16348:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   1634b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1634e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   16351:	eb 47                	jmp    1639a <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   16353:	8b 45 08             	mov    0x8(%ebp),%eax
   16356:	8d 50 04             	lea    0x4(%eax),%edx
   16359:	8b 45 08             	mov    0x8(%ebp),%eax
   1635c:	ff 75 fc             	pushl  -0x4(%ebp)
   1635f:	52                   	push   %edx
   16360:	50                   	push   %eax
   16361:	e8 73 5f ff ff       	call   c2d9 <lodepng_chunk_append>
   16366:	83 c4 0c             	add    $0xc,%esp
   16369:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1636c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   16370:	74 05                	je     16377 <addUnknownChunks+0x32>
   16372:	8b 45 f8             	mov    -0x8(%ebp),%eax
   16375:	eb 37                	jmp    163ae <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   16377:	8b 45 08             	mov    0x8(%ebp),%eax
   1637a:	8b 50 04             	mov    0x4(%eax),%edx
   1637d:	8b 45 08             	mov    0x8(%ebp),%eax
   16380:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   16383:	8b 55 10             	mov    0x10(%ebp),%edx
   16386:	8b 45 0c             	mov    0xc(%ebp),%eax
   16389:	01 d0                	add    %edx,%eax
   1638b:	50                   	push   %eax
   1638c:	ff 75 fc             	pushl  -0x4(%ebp)
   1638f:	e8 ff 5c ff ff       	call   c093 <lodepng_chunk_next>
   16394:	83 c4 08             	add    $0x8,%esp
   16397:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   1639a:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1639d:	8b 45 0c             	mov    0xc(%ebp),%eax
   163a0:	29 c2                	sub    %eax,%edx
   163a2:	89 d0                	mov    %edx,%eax
   163a4:	3b 45 10             	cmp    0x10(%ebp),%eax
   163a7:	7c aa                	jl     16353 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   163a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   163ae:	c9                   	leave  
   163af:	c3                   	ret    

000163b0 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   163b0:	55                   	push   %ebp
   163b1:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   163b3:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   163b7:	77 07                	ja     163c0 <isGrayICCProfile+0x10>
   163b9:	b8 00 00 00 00       	mov    $0x0,%eax
   163be:	eb 40                	jmp    16400 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   163c0:	8b 45 08             	mov    0x8(%ebp),%eax
   163c3:	83 c0 10             	add    $0x10,%eax
   163c6:	0f b6 00             	movzbl (%eax),%eax
   163c9:	3c 47                	cmp    $0x47,%al
   163cb:	75 2e                	jne    163fb <isGrayICCProfile+0x4b>
   163cd:	8b 45 08             	mov    0x8(%ebp),%eax
   163d0:	83 c0 11             	add    $0x11,%eax
   163d3:	0f b6 00             	movzbl (%eax),%eax
   163d6:	3c 52                	cmp    $0x52,%al
   163d8:	75 21                	jne    163fb <isGrayICCProfile+0x4b>
   163da:	8b 45 08             	mov    0x8(%ebp),%eax
   163dd:	83 c0 12             	add    $0x12,%eax
   163e0:	0f b6 00             	movzbl (%eax),%eax
   163e3:	3c 41                	cmp    $0x41,%al
   163e5:	75 14                	jne    163fb <isGrayICCProfile+0x4b>
   163e7:	8b 45 08             	mov    0x8(%ebp),%eax
   163ea:	83 c0 13             	add    $0x13,%eax
   163ed:	0f b6 00             	movzbl (%eax),%eax
   163f0:	3c 59                	cmp    $0x59,%al
   163f2:	75 07                	jne    163fb <isGrayICCProfile+0x4b>
   163f4:	b8 01 00 00 00       	mov    $0x1,%eax
   163f9:	eb 05                	jmp    16400 <isGrayICCProfile+0x50>
   163fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16400:	5d                   	pop    %ebp
   16401:	c3                   	ret    

00016402 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   16402:	55                   	push   %ebp
   16403:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   16405:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   16409:	77 07                	ja     16412 <isRGBICCProfile+0x10>
   1640b:	b8 00 00 00 00       	mov    $0x0,%eax
   16410:	eb 40                	jmp    16452 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   16412:	8b 45 08             	mov    0x8(%ebp),%eax
   16415:	83 c0 10             	add    $0x10,%eax
   16418:	0f b6 00             	movzbl (%eax),%eax
   1641b:	3c 52                	cmp    $0x52,%al
   1641d:	75 2e                	jne    1644d <isRGBICCProfile+0x4b>
   1641f:	8b 45 08             	mov    0x8(%ebp),%eax
   16422:	83 c0 11             	add    $0x11,%eax
   16425:	0f b6 00             	movzbl (%eax),%eax
   16428:	3c 47                	cmp    $0x47,%al
   1642a:	75 21                	jne    1644d <isRGBICCProfile+0x4b>
   1642c:	8b 45 08             	mov    0x8(%ebp),%eax
   1642f:	83 c0 12             	add    $0x12,%eax
   16432:	0f b6 00             	movzbl (%eax),%eax
   16435:	3c 42                	cmp    $0x42,%al
   16437:	75 14                	jne    1644d <isRGBICCProfile+0x4b>
   16439:	8b 45 08             	mov    0x8(%ebp),%eax
   1643c:	83 c0 13             	add    $0x13,%eax
   1643f:	0f b6 00             	movzbl (%eax),%eax
   16442:	3c 20                	cmp    $0x20,%al
   16444:	75 07                	jne    1644d <isRGBICCProfile+0x4b>
   16446:	b8 01 00 00 00       	mov    $0x1,%eax
   1644b:	eb 05                	jmp    16452 <isRGBICCProfile+0x50>
   1644d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16452:	5d                   	pop    %ebp
   16453:	c3                   	ret    

00016454 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   16454:	55                   	push   %ebp
   16455:	89 e5                	mov    %esp,%ebp
   16457:	57                   	push   %edi
   16458:	56                   	push   %esi
   16459:	53                   	push   %ebx
   1645a:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   16460:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   16467:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   1646e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16471:	6a 00                	push   $0x0
   16473:	6a 00                	push   $0x0
   16475:	50                   	push   %eax
   16476:	e8 6f 0d ff ff       	call   71ea <ucvector_init>
   1647b:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   1647e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16481:	05 98 00 00 00       	add    $0x98,%eax
   16486:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   16489:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1648f:	50                   	push   %eax
   16490:	e8 3a 71 ff ff       	call   d5cf <lodepng_info_init>
   16495:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   16498:	8b 45 08             	mov    0x8(%ebp),%eax
   1649b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   164a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   164a4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   164aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   164ad:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   164b4:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   164b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   164ba:	8b 40 0c             	mov    0xc(%eax),%eax
   164bd:	83 f8 03             	cmp    $0x3,%eax
   164c0:	74 0a                	je     164cc <lodepng_encode+0x78>
   164c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   164c5:	8b 40 6c             	mov    0x6c(%eax),%eax
   164c8:	85 c0                	test   %eax,%eax
   164ca:	74 29                	je     164f5 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   164cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   164cf:	8b 40 18             	mov    0x18(%eax),%eax
   164d2:	85 c0                	test   %eax,%eax
   164d4:	74 0d                	je     164e3 <lodepng_encode+0x8f>
   164d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   164d9:	8b 40 18             	mov    0x18(%eax),%eax
   164dc:	3d 00 01 00 00       	cmp    $0x100,%eax
   164e1:	7e 12                	jle    164f5 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   164e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   164e6:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   164ed:	00 00 00 
    goto cleanup;
   164f0:	e9 78 0c 00 00       	jmp    1716d <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   164f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   164f8:	8b 40 38             	mov    0x38(%eax),%eax
   164fb:	83 f8 02             	cmp    $0x2,%eax
   164fe:	76 12                	jbe    16512 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   16500:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16503:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   1650a:	00 00 00 
    goto cleanup;
   1650d:	e9 5b 0c 00 00       	jmp    1716d <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   16512:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16515:	8b 40 08             	mov    0x8(%eax),%eax
   16518:	83 f8 01             	cmp    $0x1,%eax
   1651b:	76 12                	jbe    1652f <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   1651d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16520:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   16527:	00 00 00 
    goto cleanup;
   1652a:	e9 3e 0c 00 00       	jmp    1716d <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   1652f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16532:	8b 50 10             	mov    0x10(%eax),%edx
   16535:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16538:	8b 40 0c             	mov    0xc(%eax),%eax
   1653b:	52                   	push   %edx
   1653c:	50                   	push   %eax
   1653d:	e8 a4 5f ff ff       	call   c4e6 <checkColorValidity>
   16542:	83 c4 08             	add    $0x8,%esp
   16545:	89 c2                	mov    %eax,%edx
   16547:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1654a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   16550:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16553:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16559:	85 c0                	test   %eax,%eax
   1655b:	0f 85 c6 0b 00 00    	jne    17127 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   16561:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16564:	8b 50 7c             	mov    0x7c(%eax),%edx
   16567:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1656a:	8b 40 78             	mov    0x78(%eax),%eax
   1656d:	52                   	push   %edx
   1656e:	50                   	push   %eax
   1656f:	e8 72 5f ff ff       	call   c4e6 <checkColorValidity>
   16574:	83 c4 08             	add    $0x8,%esp
   16577:	89 c2                	mov    %eax,%edx
   16579:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1657c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   16582:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16585:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1658b:	85 c0                	test   %eax,%eax
   1658d:	0f 85 97 0b 00 00    	jne    1712a <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   16593:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16596:	05 98 00 00 00       	add    $0x98,%eax
   1659b:	83 ec 08             	sub    $0x8,%esp
   1659e:	50                   	push   %eax
   1659f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   165a5:	50                   	push   %eax
   165a6:	e8 58 71 ff ff       	call   d703 <lodepng_info_copy>
   165ab:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   165ae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   165b1:	8b 40 5c             	mov    0x5c(%eax),%eax
   165b4:	85 c0                	test   %eax,%eax
   165b6:	0f 84 3c 02 00 00    	je     167f8 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   165bc:	83 ec 0c             	sub    $0xc,%esp
   165bf:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   165c5:	50                   	push   %eax
   165c6:	e8 5f 96 ff ff       	call   fc2a <lodepng_color_stats_init>
   165cb:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   165ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
   165d1:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   165d7:	85 c0                	test   %eax,%eax
   165d9:	74 2d                	je     16608 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   165db:	8b 45 dc             	mov    -0x24(%ebp),%eax
   165de:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   165e4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   165e7:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   165ed:	83 ec 08             	sub    $0x8,%esp
   165f0:	52                   	push   %edx
   165f1:	50                   	push   %eax
   165f2:	e8 b9 fd ff ff       	call   163b0 <isGrayICCProfile>
   165f7:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   165fa:	85 c0                	test   %eax,%eax
   165fc:	74 0a                	je     16608 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   165fe:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   16605:	00 00 00 
    }
    if(info_png->iccp_defined &&
   16608:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1660b:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   16611:	85 c0                	test   %eax,%eax
   16613:	74 2d                	je     16642 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   16615:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16618:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   1661e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16621:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   16627:	83 ec 08             	sub    $0x8,%esp
   1662a:	52                   	push   %edx
   1662b:	50                   	push   %eax
   1662c:	e8 d1 fd ff ff       	call   16402 <isRGBICCProfile>
   16631:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   16634:	85 c0                	test   %eax,%eax
   16636:	74 0a                	je     16642 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   16638:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   1663f:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   16642:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16645:	83 c0 78             	add    $0x78,%eax
   16648:	83 ec 0c             	sub    $0xc,%esp
   1664b:	50                   	push   %eax
   1664c:	ff 75 18             	pushl  0x18(%ebp)
   1664f:	ff 75 14             	pushl  0x14(%ebp)
   16652:	ff 75 10             	pushl  0x10(%ebp)
   16655:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   1665b:	50                   	push   %eax
   1665c:	e8 e0 96 ff ff       	call   fd41 <lodepng_compute_color_stats>
   16661:	83 c4 20             	add    $0x20,%esp
   16664:	89 c2                	mov    %eax,%edx
   16666:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16669:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1666f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16672:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16678:	85 c0                	test   %eax,%eax
   1667a:	0f 85 ad 0a 00 00    	jne    1712d <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   16680:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16683:	8b 40 2c             	mov    0x2c(%eax),%eax
   16686:	85 c0                	test   %eax,%eax
   16688:	0f 84 be 00 00 00    	je     1674c <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   1668e:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   16695:	00 00 00 
   16698:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   1669f:	00 00 00 
   166a2:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   166a9:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   166ac:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   166b2:	83 ec 04             	sub    $0x4,%esp
   166b5:	6a 10                	push   $0x10
   166b7:	6a 02                	push   $0x2
   166b9:	50                   	push   %eax
   166ba:	e8 15 61 ff ff       	call   c7d4 <lodepng_color_mode_make>
   166bf:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   166c2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   166c5:	8d 58 0c             	lea    0xc(%eax),%ebx
   166c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   166cb:	8b 48 38             	mov    0x38(%eax),%ecx
   166ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
   166d1:	8b 50 34             	mov    0x34(%eax),%edx
   166d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   166d7:	8b 40 30             	mov    0x30(%eax),%eax
   166da:	53                   	push   %ebx
   166db:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   166e1:	53                   	push   %ebx
   166e2:	51                   	push   %ecx
   166e3:	52                   	push   %edx
   166e4:	50                   	push   %eax
   166e5:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   166eb:	50                   	push   %eax
   166ec:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   166f2:	50                   	push   %eax
   166f3:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   166f9:	50                   	push   %eax
   166fa:	e8 8a 92 ff ff       	call   f989 <lodepng_convert_rgb>
   166ff:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   16702:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   16708:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   1670e:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   16714:	83 ec 0c             	sub    $0xc,%esp
   16717:	68 ff ff 00 00       	push   $0xffff
   1671c:	51                   	push   %ecx
   1671d:	52                   	push   %edx
   1671e:	50                   	push   %eax
   1671f:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   16725:	50                   	push   %eax
   16726:	e8 26 a1 ff ff       	call   10851 <lodepng_color_stats_add>
   1672b:	83 c4 20             	add    $0x20,%esp
   1672e:	89 c2                	mov    %eax,%edx
   16730:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16733:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16739:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1673c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16742:	85 c0                	test   %eax,%eax
   16744:	74 06                	je     1674c <lodepng_encode+0x2f8>
   16746:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   16747:	e9 e1 09 00 00       	jmp    1712d <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   1674c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1674f:	8d 50 78             	lea    0x78(%eax),%edx
   16752:	83 ec 04             	sub    $0x4,%esp
   16755:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   1675b:	50                   	push   %eax
   1675c:	52                   	push   %edx
   1675d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16763:	83 c0 0c             	add    $0xc,%eax
   16766:	50                   	push   %eax
   16767:	e8 79 a1 ff ff       	call   108e5 <auto_choose_color>
   1676c:	83 c4 10             	add    $0x10,%esp
   1676f:	89 c2                	mov    %eax,%edx
   16771:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16774:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1677a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1677d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16783:	85 c0                	test   %eax,%eax
   16785:	0f 85 a5 09 00 00    	jne    17130 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   1678b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1678e:	8b 40 2c             	mov    0x2c(%eax),%eax
   16791:	85 c0                	test   %eax,%eax
   16793:	74 63                	je     167f8 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   16795:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16798:	8d 58 0c             	lea    0xc(%eax),%ebx
   1679b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1679e:	8b 48 38             	mov    0x38(%eax),%ecx
   167a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   167a4:	8b 50 34             	mov    0x34(%eax),%edx
   167a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   167aa:	8b 40 30             	mov    0x30(%eax),%eax
   167ad:	53                   	push   %ebx
   167ae:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   167b4:	83 c3 0c             	add    $0xc,%ebx
   167b7:	53                   	push   %ebx
   167b8:	51                   	push   %ecx
   167b9:	52                   	push   %edx
   167ba:	50                   	push   %eax
   167bb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   167c1:	83 c0 38             	add    $0x38,%eax
   167c4:	50                   	push   %eax
   167c5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   167cb:	83 c0 34             	add    $0x34,%eax
   167ce:	50                   	push   %eax
   167cf:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   167d5:	83 c0 30             	add    $0x30,%eax
   167d8:	50                   	push   %eax
   167d9:	e8 ab 91 ff ff       	call   f989 <lodepng_convert_rgb>
   167de:	83 c4 20             	add    $0x20,%esp
   167e1:	85 c0                	test   %eax,%eax
   167e3:	74 13                	je     167f8 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   167e5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   167e8:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   167ef:	00 00 00 
        goto cleanup;
   167f2:	90                   	nop
   167f3:	e9 75 09 00 00       	jmp    1716d <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   167f8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   167fb:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   16801:	85 c0                	test   %eax,%eax
   16803:	0f 84 b2 00 00 00    	je     168bb <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   16809:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1680c:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   16812:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16815:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1681b:	83 ec 08             	sub    $0x8,%esp
   1681e:	52                   	push   %edx
   1681f:	50                   	push   %eax
   16820:	e8 8b fb ff ff       	call   163b0 <isGrayICCProfile>
   16825:	83 c4 10             	add    $0x10,%esp
   16828:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   1682b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1682e:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   16834:	8b 45 dc             	mov    -0x24(%ebp),%eax
   16837:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   1683d:	83 ec 08             	sub    $0x8,%esp
   16840:	52                   	push   %edx
   16841:	50                   	push   %eax
   16842:	e8 bb fb ff ff       	call   16402 <isRGBICCProfile>
   16847:	83 c4 10             	add    $0x10,%esp
   1684a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   1684d:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   16853:	85 c0                	test   %eax,%eax
   16855:	74 0b                	je     16862 <lodepng_encode+0x40e>
   16857:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1685d:	83 f8 04             	cmp    $0x4,%eax
   16860:	75 07                	jne    16869 <lodepng_encode+0x415>
   16862:	b8 01 00 00 00       	mov    $0x1,%eax
   16867:	eb 05                	jmp    1686e <lodepng_encode+0x41a>
   16869:	b8 00 00 00 00       	mov    $0x0,%eax
   1686e:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   16871:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   16875:	75 18                	jne    1688f <lodepng_encode+0x43b>
   16877:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   1687b:	75 12                	jne    1688f <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   1687d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16880:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   16887:	00 00 00 
      goto cleanup;
   1688a:	e9 de 08 00 00       	jmp    1716d <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   1688f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   16892:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   16895:	74 24                	je     168bb <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   16897:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1689a:	8b 40 5c             	mov    0x5c(%eax),%eax
   1689d:	85 c0                	test   %eax,%eax
   1689f:	74 07                	je     168a8 <lodepng_encode+0x454>
   168a1:	ba 66 00 00 00       	mov    $0x66,%edx
   168a6:	eb 05                	jmp    168ad <lodepng_encode+0x459>
   168a8:	ba 65 00 00 00       	mov    $0x65,%edx
   168ad:	8b 45 1c             	mov    0x1c(%ebp),%eax
   168b0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   168b6:	e9 b2 08 00 00       	jmp    1716d <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   168bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   168be:	83 c0 78             	add    $0x78,%eax
   168c1:	83 ec 08             	sub    $0x8,%esp
   168c4:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   168ca:	83 c2 0c             	add    $0xc,%edx
   168cd:	52                   	push   %edx
   168ce:	50                   	push   %eax
   168cf:	e8 57 5f ff ff       	call   c82b <lodepng_color_mode_equal>
   168d4:	83 c4 10             	add    $0x10,%esp
   168d7:	85 c0                	test   %eax,%eax
   168d9:	0f 85 f8 00 00 00    	jne    169d7 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   168df:	8b 55 14             	mov    0x14(%ebp),%edx
   168e2:	8b 45 18             	mov    0x18(%ebp),%eax
   168e5:	89 d3                	mov    %edx,%ebx
   168e7:	0f af d8             	imul   %eax,%ebx
   168ea:	83 ec 0c             	sub    $0xc,%esp
   168ed:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   168f3:	83 c0 0c             	add    $0xc,%eax
   168f6:	50                   	push   %eax
   168f7:	e8 49 61 ff ff       	call   ca45 <lodepng_get_bpp>
   168fc:	83 c4 10             	add    $0x10,%esp
   168ff:	0f af c3             	imul   %ebx,%eax
   16902:	83 c0 07             	add    $0x7,%eax
   16905:	c1 e8 03             	shr    $0x3,%eax
   16908:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   1690b:	83 ec 0c             	sub    $0xc,%esp
   1690e:	ff 75 cc             	pushl  -0x34(%ebp)
   16911:	e8 13 06 ff ff       	call   6f29 <lodepng_malloc>
   16916:	83 c4 10             	add    $0x10,%esp
   16919:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   1691c:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   16920:	75 13                	jne    16935 <lodepng_encode+0x4e1>
   16922:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   16926:	74 0d                	je     16935 <lodepng_encode+0x4e1>
   16928:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1692b:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   16932:	00 00 00 
    if(!state->error) {
   16935:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16938:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1693e:	85 c0                	test   %eax,%eax
   16940:	75 33                	jne    16975 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   16942:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16945:	83 c0 78             	add    $0x78,%eax
   16948:	83 ec 08             	sub    $0x8,%esp
   1694b:	ff 75 18             	pushl  0x18(%ebp)
   1694e:	ff 75 14             	pushl  0x14(%ebp)
   16951:	50                   	push   %eax
   16952:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16958:	83 c0 0c             	add    $0xc,%eax
   1695b:	50                   	push   %eax
   1695c:	ff 75 10             	pushl  0x10(%ebp)
   1695f:	ff 75 c8             	pushl  -0x38(%ebp)
   16962:	e8 c9 8c ff ff       	call   f630 <lodepng_convert>
   16967:	83 c4 20             	add    $0x20,%esp
   1696a:	89 c2                	mov    %eax,%edx
   1696c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1696f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   16975:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16978:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1697e:	85 c0                	test   %eax,%eax
   16980:	75 35                	jne    169b7 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   16982:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16985:	83 c0 38             	add    $0x38,%eax
   16988:	83 ec 04             	sub    $0x4,%esp
   1698b:	50                   	push   %eax
   1698c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16992:	50                   	push   %eax
   16993:	ff 75 18             	pushl  0x18(%ebp)
   16996:	ff 75 14             	pushl  0x14(%ebp)
   16999:	ff 75 c8             	pushl  -0x38(%ebp)
   1699c:	8d 45 bc             	lea    -0x44(%ebp),%eax
   1699f:	50                   	push   %eax
   169a0:	8d 45 c0             	lea    -0x40(%ebp),%eax
   169a3:	50                   	push   %eax
   169a4:	e8 0d f6 ff ff       	call   15fb6 <preProcessScanlines>
   169a9:	83 c4 20             	add    $0x20,%esp
   169ac:	89 c2                	mov    %eax,%edx
   169ae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   169b1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   169b7:	83 ec 0c             	sub    $0xc,%esp
   169ba:	ff 75 c8             	pushl  -0x38(%ebp)
   169bd:	e8 88 05 ff ff       	call   6f4a <lodepng_free>
   169c2:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   169c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   169c8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   169ce:	85 c0                	test   %eax,%eax
   169d0:	74 4b                	je     16a1d <lodepng_encode+0x5c9>
   169d2:	e9 96 07 00 00       	jmp    1716d <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   169d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   169da:	83 c0 38             	add    $0x38,%eax
   169dd:	83 ec 04             	sub    $0x4,%esp
   169e0:	50                   	push   %eax
   169e1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   169e7:	50                   	push   %eax
   169e8:	ff 75 18             	pushl  0x18(%ebp)
   169eb:	ff 75 14             	pushl  0x14(%ebp)
   169ee:	ff 75 10             	pushl  0x10(%ebp)
   169f1:	8d 45 bc             	lea    -0x44(%ebp),%eax
   169f4:	50                   	push   %eax
   169f5:	8d 45 c0             	lea    -0x40(%ebp),%eax
   169f8:	50                   	push   %eax
   169f9:	e8 b8 f5 ff ff       	call   15fb6 <preProcessScanlines>
   169fe:	83 c4 20             	add    $0x20,%esp
   16a01:	89 c2                	mov    %eax,%edx
   16a03:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16a06:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   16a0c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16a0f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16a15:	85 c0                	test   %eax,%eax
   16a17:	0f 85 16 07 00 00    	jne    17133 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   16a1d:	83 ec 0c             	sub    $0xc,%esp
   16a20:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16a23:	50                   	push   %eax
   16a24:	e8 21 d9 ff ff       	call   1434a <writeSignature>
   16a29:	83 c4 10             	add    $0x10,%esp
   16a2c:	89 c2                	mov    %eax,%edx
   16a2e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16a31:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   16a37:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16a3a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16a40:	85 c0                	test   %eax,%eax
   16a42:	0f 85 ee 06 00 00    	jne    17136 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   16a48:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   16a4e:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   16a54:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   16a5a:	83 ec 08             	sub    $0x8,%esp
   16a5d:	51                   	push   %ecx
   16a5e:	52                   	push   %edx
   16a5f:	50                   	push   %eax
   16a60:	ff 75 18             	pushl  0x18(%ebp)
   16a63:	ff 75 14             	pushl  0x14(%ebp)
   16a66:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16a69:	50                   	push   %eax
   16a6a:	e8 4a d9 ff ff       	call   143b9 <addChunk_IHDR>
   16a6f:	83 c4 20             	add    $0x20,%esp
   16a72:	89 c2                	mov    %eax,%edx
   16a74:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16a77:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   16a7d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16a80:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16a86:	85 c0                	test   %eax,%eax
   16a88:	0f 85 ab 06 00 00    	jne    17139 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   16a8e:	8b 45 98             	mov    -0x68(%ebp),%eax
   16a91:	85 c0                	test   %eax,%eax
   16a93:	74 33                	je     16ac8 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   16a95:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   16a98:	8b 45 98             	mov    -0x68(%ebp),%eax
   16a9b:	83 ec 04             	sub    $0x4,%esp
   16a9e:	52                   	push   %edx
   16a9f:	50                   	push   %eax
   16aa0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16aa3:	50                   	push   %eax
   16aa4:	e8 9c f8 ff ff       	call   16345 <addUnknownChunks>
   16aa9:	83 c4 10             	add    $0x10,%esp
   16aac:	89 c2                	mov    %eax,%edx
   16aae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16ab1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16ab7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16aba:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16ac0:	85 c0                	test   %eax,%eax
   16ac2:	0f 85 74 06 00 00    	jne    1713c <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   16ac8:	8b 45 88             	mov    -0x78(%ebp),%eax
   16acb:	85 c0                	test   %eax,%eax
   16acd:	74 39                	je     16b08 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   16acf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16ad2:	83 c0 38             	add    $0x38,%eax
   16ad5:	83 ec 04             	sub    $0x4,%esp
   16ad8:	50                   	push   %eax
   16ad9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16adf:	50                   	push   %eax
   16ae0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16ae3:	50                   	push   %eax
   16ae4:	e8 a4 e4 ff ff       	call   14f8d <addChunk_iCCP>
   16ae9:	83 c4 10             	add    $0x10,%esp
   16aec:	89 c2                	mov    %eax,%edx
   16aee:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16af1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16af7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16afa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16b00:	85 c0                	test   %eax,%eax
   16b02:	0f 85 37 06 00 00    	jne    1713f <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   16b08:	8b 45 80             	mov    -0x80(%ebp),%eax
   16b0b:	85 c0                	test   %eax,%eax
   16b0d:	74 32                	je     16b41 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   16b0f:	83 ec 08             	sub    $0x8,%esp
   16b12:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16b18:	50                   	push   %eax
   16b19:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16b1c:	50                   	push   %eax
   16b1d:	e8 41 e4 ff ff       	call   14f63 <addChunk_sRGB>
   16b22:	83 c4 10             	add    $0x10,%esp
   16b25:	89 c2                	mov    %eax,%edx
   16b27:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16b2a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16b30:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16b33:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16b39:	85 c0                	test   %eax,%eax
   16b3b:	0f 85 01 06 00 00    	jne    17142 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   16b41:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   16b47:	85 c0                	test   %eax,%eax
   16b49:	74 32                	je     16b7d <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   16b4b:	83 ec 08             	sub    $0x8,%esp
   16b4e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16b54:	50                   	push   %eax
   16b55:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16b58:	50                   	push   %eax
   16b59:	e8 a7 e2 ff ff       	call   14e05 <addChunk_gAMA>
   16b5e:	83 c4 10             	add    $0x10,%esp
   16b61:	89 c2                	mov    %eax,%edx
   16b63:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16b66:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16b6c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16b6f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16b75:	85 c0                	test   %eax,%eax
   16b77:	0f 85 c8 05 00 00    	jne    17145 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   16b7d:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   16b83:	85 c0                	test   %eax,%eax
   16b85:	74 32                	je     16bb9 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   16b87:	83 ec 08             	sub    $0x8,%esp
   16b8a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16b90:	50                   	push   %eax
   16b91:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16b94:	50                   	push   %eax
   16b95:	e8 c1 e2 ff ff       	call   14e5b <addChunk_cHRM>
   16b9a:	83 c4 10             	add    $0x10,%esp
   16b9d:	89 c2                	mov    %eax,%edx
   16b9f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16ba2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16ba8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16bab:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16bb1:	85 c0                	test   %eax,%eax
   16bb3:	0f 85 8f 05 00 00    	jne    17148 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   16bb9:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   16bbf:	83 f8 03             	cmp    $0x3,%eax
   16bc2:	75 35                	jne    16bf9 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   16bc4:	83 ec 08             	sub    $0x8,%esp
   16bc7:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16bcd:	83 c0 0c             	add    $0xc,%eax
   16bd0:	50                   	push   %eax
   16bd1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16bd4:	50                   	push   %eax
   16bd5:	e8 78 d8 ff ff       	call   14452 <addChunk_PLTE>
   16bda:	83 c4 10             	add    $0x10,%esp
   16bdd:	89 c2                	mov    %eax,%edx
   16bdf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16be2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16be8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16beb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16bf1:	85 c0                	test   %eax,%eax
   16bf3:	0f 85 52 05 00 00    	jne    1714b <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   16bf9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16bfc:	8b 40 6c             	mov    0x6c(%eax),%eax
   16bff:	85 c0                	test   %eax,%eax
   16c01:	74 4b                	je     16c4e <lodepng_encode+0x7fa>
   16c03:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   16c09:	83 f8 02             	cmp    $0x2,%eax
   16c0c:	74 0b                	je     16c19 <lodepng_encode+0x7c5>
   16c0e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   16c14:	83 f8 06             	cmp    $0x6,%eax
   16c17:	75 35                	jne    16c4e <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   16c19:	83 ec 08             	sub    $0x8,%esp
   16c1c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16c22:	83 c0 0c             	add    $0xc,%eax
   16c25:	50                   	push   %eax
   16c26:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16c29:	50                   	push   %eax
   16c2a:	e8 23 d8 ff ff       	call   14452 <addChunk_PLTE>
   16c2f:	83 c4 10             	add    $0x10,%esp
   16c32:	89 c2                	mov    %eax,%edx
   16c34:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16c37:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16c3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16c40:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16c46:	85 c0                	test   %eax,%eax
   16c48:	0f 85 00 05 00 00    	jne    1714e <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   16c4e:	83 ec 08             	sub    $0x8,%esp
   16c51:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16c57:	83 c0 0c             	add    $0xc,%eax
   16c5a:	50                   	push   %eax
   16c5b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16c5e:	50                   	push   %eax
   16c5f:	e8 c4 d8 ff ff       	call   14528 <addChunk_tRNS>
   16c64:	83 c4 10             	add    $0x10,%esp
   16c67:	89 c2                	mov    %eax,%edx
   16c69:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16c6c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   16c72:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16c75:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16c7b:	85 c0                	test   %eax,%eax
   16c7d:	0f 85 ce 04 00 00    	jne    17151 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   16c83:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   16c89:	85 c0                	test   %eax,%eax
   16c8b:	74 32                	je     16cbf <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   16c8d:	83 ec 08             	sub    $0x8,%esp
   16c90:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16c96:	50                   	push   %eax
   16c97:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16c9a:	50                   	push   %eax
   16c9b:	e8 e4 de ff ff       	call   14b84 <addChunk_bKGD>
   16ca0:	83 c4 10             	add    $0x10,%esp
   16ca3:	89 c2                	mov    %eax,%edx
   16ca5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16ca8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16cae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16cb1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16cb7:	85 c0                	test   %eax,%eax
   16cb9:	0f 85 95 04 00 00    	jne    17154 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   16cbf:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   16cc5:	85 c0                	test   %eax,%eax
   16cc7:	74 32                	je     16cfb <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   16cc9:	83 ec 08             	sub    $0x8,%esp
   16ccc:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16cd2:	50                   	push   %eax
   16cd3:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16cd6:	50                   	push   %eax
   16cd7:	e8 ac e0 ff ff       	call   14d88 <addChunk_pHYs>
   16cdc:	83 c4 10             	add    $0x10,%esp
   16cdf:	89 c2                	mov    %eax,%edx
   16ce1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16ce4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16cea:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16ced:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16cf3:	85 c0                	test   %eax,%eax
   16cf5:	0f 85 5c 04 00 00    	jne    17157 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   16cfb:	8b 45 9c             	mov    -0x64(%ebp),%eax
   16cfe:	85 c0                	test   %eax,%eax
   16d00:	74 33                	je     16d35 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   16d02:	8b 55 a8             	mov    -0x58(%ebp),%edx
   16d05:	8b 45 9c             	mov    -0x64(%ebp),%eax
   16d08:	83 ec 04             	sub    $0x4,%esp
   16d0b:	52                   	push   %edx
   16d0c:	50                   	push   %eax
   16d0d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16d10:	50                   	push   %eax
   16d11:	e8 2f f6 ff ff       	call   16345 <addUnknownChunks>
   16d16:	83 c4 10             	add    $0x10,%esp
   16d19:	89 c2                	mov    %eax,%edx
   16d1b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16d1e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16d24:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16d27:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16d2d:	85 c0                	test   %eax,%eax
   16d2f:	0f 85 25 04 00 00    	jne    1715a <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   16d35:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16d38:	8d 48 38             	lea    0x38(%eax),%ecx
   16d3b:	8b 55 bc             	mov    -0x44(%ebp),%edx
   16d3e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   16d41:	51                   	push   %ecx
   16d42:	52                   	push   %edx
   16d43:	50                   	push   %eax
   16d44:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16d47:	50                   	push   %eax
   16d48:	e8 bd d9 ff ff       	call   1470a <addChunk_IDAT>
   16d4d:	83 c4 10             	add    $0x10,%esp
   16d50:	89 c2                	mov    %eax,%edx
   16d52:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16d55:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   16d5b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16d5e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16d64:	85 c0                	test   %eax,%eax
   16d66:	0f 85 f1 03 00 00    	jne    1715d <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   16d6c:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   16d72:	85 c0                	test   %eax,%eax
   16d74:	74 35                	je     16dab <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   16d76:	83 ec 08             	sub    $0x8,%esp
   16d79:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   16d7f:	83 c0 60             	add    $0x60,%eax
   16d82:	50                   	push   %eax
   16d83:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16d86:	50                   	push   %eax
   16d87:	e8 5c df ff ff       	call   14ce8 <addChunk_tIME>
   16d8c:	83 c4 10             	add    $0x10,%esp
   16d8f:	89 c2                	mov    %eax,%edx
   16d91:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16d94:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   16d9a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16d9d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16da3:	85 c0                	test   %eax,%eax
   16da5:	0f 85 b5 03 00 00    	jne    17160 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   16dab:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   16db2:	e9 12 01 00 00       	jmp    16ec9 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   16db7:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   16dbd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16dc0:	c1 e2 02             	shl    $0x2,%edx
   16dc3:	01 d0                	add    %edx,%eax
   16dc5:	8b 00                	mov    (%eax),%eax
   16dc7:	83 ec 0c             	sub    $0xc,%esp
   16dca:	50                   	push   %eax
   16dcb:	e8 f5 01 ff ff       	call   6fc5 <lodepng_strlen>
   16dd0:	83 c4 10             	add    $0x10,%esp
   16dd3:	83 f8 4f             	cmp    $0x4f,%eax
   16dd6:	7e 12                	jle    16dea <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   16dd8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16ddb:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   16de2:	00 00 00 
        goto cleanup;
   16de5:	e9 83 03 00 00       	jmp    1716d <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   16dea:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   16df0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16df3:	c1 e2 02             	shl    $0x2,%edx
   16df6:	01 d0                	add    %edx,%eax
   16df8:	8b 00                	mov    (%eax),%eax
   16dfa:	83 ec 0c             	sub    $0xc,%esp
   16dfd:	50                   	push   %eax
   16dfe:	e8 c2 01 ff ff       	call   6fc5 <lodepng_strlen>
   16e03:	83 c4 10             	add    $0x10,%esp
   16e06:	85 c0                	test   %eax,%eax
   16e08:	7f 12                	jg     16e1c <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   16e0a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16e0d:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   16e14:	00 00 00 
        goto cleanup;
   16e17:	e9 51 03 00 00       	jmp    1716d <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   16e1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16e1f:	8b 40 74             	mov    0x74(%eax),%eax
   16e22:	85 c0                	test   %eax,%eax
   16e24:	74 52                	je     16e78 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   16e26:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16e29:	8d 48 38             	lea    0x38(%eax),%ecx
   16e2c:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   16e32:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16e35:	c1 e2 02             	shl    $0x2,%edx
   16e38:	01 d0                	add    %edx,%eax
   16e3a:	8b 10                	mov    (%eax),%edx
   16e3c:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   16e42:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   16e45:	c1 e3 02             	shl    $0x2,%ebx
   16e48:	01 d8                	add    %ebx,%eax
   16e4a:	8b 00                	mov    (%eax),%eax
   16e4c:	51                   	push   %ecx
   16e4d:	52                   	push   %edx
   16e4e:	50                   	push   %eax
   16e4f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16e52:	50                   	push   %eax
   16e53:	e8 fa d9 ff ff       	call   14852 <addChunk_zTXt>
   16e58:	83 c4 10             	add    $0x10,%esp
   16e5b:	89 c2                	mov    %eax,%edx
   16e5d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16e60:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   16e66:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16e69:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16e6f:	85 c0                	test   %eax,%eax
   16e71:	74 52                	je     16ec5 <lodepng_encode+0xa71>
   16e73:	e9 f5 02 00 00       	jmp    1716d <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   16e78:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   16e7e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16e81:	c1 e2 02             	shl    $0x2,%edx
   16e84:	01 d0                	add    %edx,%eax
   16e86:	8b 10                	mov    (%eax),%edx
   16e88:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   16e8e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   16e91:	c1 e1 02             	shl    $0x2,%ecx
   16e94:	01 c8                	add    %ecx,%eax
   16e96:	8b 00                	mov    (%eax),%eax
   16e98:	83 ec 04             	sub    $0x4,%esp
   16e9b:	52                   	push   %edx
   16e9c:	50                   	push   %eax
   16e9d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16ea0:	50                   	push   %eax
   16ea1:	e8 ec d8 ff ff       	call   14792 <addChunk_tEXt>
   16ea6:	83 c4 10             	add    $0x10,%esp
   16ea9:	89 c2                	mov    %eax,%edx
   16eab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16eae:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   16eb4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16eb7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16ebd:	85 c0                	test   %eax,%eax
   16ebf:	0f 85 9e 02 00 00    	jne    17163 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   16ec5:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   16ec9:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   16ecf:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16ed2:	0f 85 df fe ff ff    	jne    16db7 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   16ed8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16edb:	8b 40 70             	mov    0x70(%eax),%eax
   16ede:	85 c0                	test   %eax,%eax
   16ee0:	0f 84 e3 00 00 00    	je     16fc9 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   16ee6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   16eed:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   16ef4:	e9 85 00 00 00       	jmp    16f7e <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   16ef9:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   16eff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16f02:	c1 e2 02             	shl    $0x2,%edx
   16f05:	01 d0                	add    %edx,%eax
   16f07:	8b 00                	mov    (%eax),%eax
   16f09:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   16f0c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16f0f:	0f b6 00             	movzbl (%eax),%eax
   16f12:	3c 4c                	cmp    $0x4c,%al
   16f14:	75 64                	jne    16f7a <lodepng_encode+0xb26>
   16f16:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16f19:	83 c0 01             	add    $0x1,%eax
   16f1c:	0f b6 00             	movzbl (%eax),%eax
   16f1f:	3c 6f                	cmp    $0x6f,%al
   16f21:	75 57                	jne    16f7a <lodepng_encode+0xb26>
   16f23:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16f26:	83 c0 02             	add    $0x2,%eax
   16f29:	0f b6 00             	movzbl (%eax),%eax
   16f2c:	3c 64                	cmp    $0x64,%al
   16f2e:	75 4a                	jne    16f7a <lodepng_encode+0xb26>
   16f30:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16f33:	83 c0 03             	add    $0x3,%eax
   16f36:	0f b6 00             	movzbl (%eax),%eax
   16f39:	3c 65                	cmp    $0x65,%al
   16f3b:	75 3d                	jne    16f7a <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   16f3d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16f40:	83 c0 04             	add    $0x4,%eax
   16f43:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   16f46:	3c 50                	cmp    $0x50,%al
   16f48:	75 30                	jne    16f7a <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   16f4a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16f4d:	83 c0 05             	add    $0x5,%eax
   16f50:	0f b6 00             	movzbl (%eax),%eax
   16f53:	3c 4e                	cmp    $0x4e,%al
   16f55:	75 23                	jne    16f7a <lodepng_encode+0xb26>
   16f57:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16f5a:	83 c0 06             	add    $0x6,%eax
   16f5d:	0f b6 00             	movzbl (%eax),%eax
   16f60:	3c 47                	cmp    $0x47,%al
   16f62:	75 16                	jne    16f7a <lodepng_encode+0xb26>
   16f64:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   16f67:	83 c0 07             	add    $0x7,%eax
   16f6a:	0f b6 00             	movzbl (%eax),%eax
   16f6d:	84 c0                	test   %al,%al
   16f6f:	75 09                	jne    16f7a <lodepng_encode+0xb26>
          already_added_id_text = 1;
   16f71:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   16f78:	eb 13                	jmp    16f8d <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   16f7a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   16f7e:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   16f84:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16f87:	0f 85 6c ff ff ff    	jne    16ef9 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   16f8d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   16f91:	75 36                	jne    16fc9 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   16f93:	a1 40 39 02 00       	mov    0x23940,%eax
   16f98:	83 ec 04             	sub    $0x4,%esp
   16f9b:	50                   	push   %eax
   16f9c:	68 64 f4 01 00       	push   $0x1f464
   16fa1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   16fa4:	50                   	push   %eax
   16fa5:	e8 e8 d7 ff ff       	call   14792 <addChunk_tEXt>
   16faa:	83 c4 10             	add    $0x10,%esp
   16fad:	89 c2                	mov    %eax,%edx
   16faf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16fb2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   16fb8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16fbb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   16fc1:	85 c0                	test   %eax,%eax
   16fc3:	0f 85 9d 01 00 00    	jne    17166 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   16fc9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   16fd0:	e9 e6 00 00 00       	jmp    170bb <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   16fd5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   16fdb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16fde:	c1 e2 02             	shl    $0x2,%edx
   16fe1:	01 d0                	add    %edx,%eax
   16fe3:	8b 00                	mov    (%eax),%eax
   16fe5:	83 ec 0c             	sub    $0xc,%esp
   16fe8:	50                   	push   %eax
   16fe9:	e8 d7 ff fe ff       	call   6fc5 <lodepng_strlen>
   16fee:	83 c4 10             	add    $0x10,%esp
   16ff1:	83 f8 4f             	cmp    $0x4f,%eax
   16ff4:	7e 12                	jle    17008 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   16ff6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   16ff9:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   17000:	00 00 00 
        goto cleanup;
   17003:	e9 65 01 00 00       	jmp    1716d <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   17008:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   1700e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   17011:	c1 e2 02             	shl    $0x2,%edx
   17014:	01 d0                	add    %edx,%eax
   17016:	8b 00                	mov    (%eax),%eax
   17018:	83 ec 0c             	sub    $0xc,%esp
   1701b:	50                   	push   %eax
   1701c:	e8 a4 ff fe ff       	call   6fc5 <lodepng_strlen>
   17021:	83 c4 10             	add    $0x10,%esp
   17024:	85 c0                	test   %eax,%eax
   17026:	7f 12                	jg     1703a <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   17028:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1702b:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   17032:	00 00 00 
        goto cleanup;
   17035:	e9 33 01 00 00       	jmp    1716d <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   1703a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1703d:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   17040:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   17046:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   17049:	c1 e2 02             	shl    $0x2,%edx
   1704c:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1704e:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   17050:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   17056:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   17059:	c1 e2 02             	shl    $0x2,%edx
   1705c:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1705e:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   17060:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   17066:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   17069:	c1 e2 02             	shl    $0x2,%edx
   1706c:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1706e:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   17070:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   17076:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   17079:	c1 e2 02             	shl    $0x2,%edx
   1707c:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1707e:	8b 10                	mov    (%eax),%edx
   17080:	8b 45 1c             	mov    0x1c(%ebp),%eax
   17083:	8b 40 74             	mov    0x74(%eax),%eax
   17086:	83 ec 04             	sub    $0x4,%esp
   17089:	57                   	push   %edi
   1708a:	56                   	push   %esi
   1708b:	53                   	push   %ebx
   1708c:	51                   	push   %ecx
   1708d:	52                   	push   %edx
   1708e:	50                   	push   %eax
   1708f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   17092:	50                   	push   %eax
   17093:	e8 dc d8 ff ff       	call   14974 <addChunk_iTXt>
   17098:	83 c4 20             	add    $0x20,%esp
   1709b:	89 c2                	mov    %eax,%edx
   1709d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   170a0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   170a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   170a9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   170af:	85 c0                	test   %eax,%eax
   170b1:	0f 85 b2 00 00 00    	jne    17169 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   170b7:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   170bb:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   170c1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   170c4:	0f 85 0b ff ff ff    	jne    16fd5 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   170ca:	8b 45 a0             	mov    -0x60(%ebp),%eax
   170cd:	85 c0                	test   %eax,%eax
   170cf:	74 2f                	je     17100 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   170d1:	8b 55 ac             	mov    -0x54(%ebp),%edx
   170d4:	8b 45 a0             	mov    -0x60(%ebp),%eax
   170d7:	83 ec 04             	sub    $0x4,%esp
   170da:	52                   	push   %edx
   170db:	50                   	push   %eax
   170dc:	8d 45 b0             	lea    -0x50(%ebp),%eax
   170df:	50                   	push   %eax
   170e0:	e8 60 f2 ff ff       	call   16345 <addUnknownChunks>
   170e5:	83 c4 10             	add    $0x10,%esp
   170e8:	89 c2                	mov    %eax,%edx
   170ea:	8b 45 1c             	mov    0x1c(%ebp),%eax
   170ed:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   170f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   170f6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   170fc:	85 c0                	test   %eax,%eax
   170fe:	75 6c                	jne    1716c <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   17100:	83 ec 0c             	sub    $0xc,%esp
   17103:	8d 45 b0             	lea    -0x50(%ebp),%eax
   17106:	50                   	push   %eax
   17107:	e8 6d d6 ff ff       	call   14779 <addChunk_IEND>
   1710c:	83 c4 10             	add    $0x10,%esp
   1710f:	89 c2                	mov    %eax,%edx
   17111:	8b 45 1c             	mov    0x1c(%ebp),%eax
   17114:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1711a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1711d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   17123:	85 c0                	test   %eax,%eax
   17125:	eb 46                	jmp    1716d <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   17127:	90                   	nop
   17128:	eb 43                	jmp    1716d <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1712a:	90                   	nop
   1712b:	eb 40                	jmp    1716d <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   1712d:	90                   	nop
   1712e:	eb 3d                	jmp    1716d <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   17130:	90                   	nop
   17131:	eb 3a                	jmp    1716d <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   17133:	90                   	nop
   17134:	eb 37                	jmp    1716d <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   17136:	90                   	nop
   17137:	eb 34                	jmp    1716d <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   17139:	90                   	nop
   1713a:	eb 31                	jmp    1716d <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   1713c:	90                   	nop
   1713d:	eb 2e                	jmp    1716d <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1713f:	90                   	nop
   17140:	eb 2b                	jmp    1716d <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   17142:	90                   	nop
   17143:	eb 28                	jmp    1716d <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   17145:	90                   	nop
   17146:	eb 25                	jmp    1716d <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   17148:	90                   	nop
   17149:	eb 22                	jmp    1716d <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   1714b:	90                   	nop
   1714c:	eb 1f                	jmp    1716d <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   1714e:	90                   	nop
   1714f:	eb 1c                	jmp    1716d <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   17151:	90                   	nop
   17152:	eb 19                	jmp    1716d <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   17154:	90                   	nop
   17155:	eb 16                	jmp    1716d <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   17157:	90                   	nop
   17158:	eb 13                	jmp    1716d <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   1715a:	90                   	nop
   1715b:	eb 10                	jmp    1716d <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   1715d:	90                   	nop
   1715e:	eb 0d                	jmp    1716d <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   17160:	90                   	nop
   17161:	eb 0a                	jmp    1716d <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   17163:	90                   	nop
   17164:	eb 07                	jmp    1716d <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   17166:	90                   	nop
   17167:	eb 04                	jmp    1716d <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   17169:	90                   	nop
   1716a:	eb 01                	jmp    1716d <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   1716c:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   1716d:	83 ec 0c             	sub    $0xc,%esp
   17170:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   17176:	50                   	push   %eax
   17177:	e8 34 65 ff ff       	call   d6b0 <lodepng_info_cleanup>
   1717c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   1717f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   17182:	83 ec 0c             	sub    $0xc,%esp
   17185:	50                   	push   %eax
   17186:	e8 bf fd fe ff       	call   6f4a <lodepng_free>
   1718b:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   1718e:	8b 55 b0             	mov    -0x50(%ebp),%edx
   17191:	8b 45 08             	mov    0x8(%ebp),%eax
   17194:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   17196:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   17199:	8b 45 0c             	mov    0xc(%ebp),%eax
   1719c:	89 10                	mov    %edx,(%eax)

  return state->error;
   1719e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   171a1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   171a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
   171aa:	5b                   	pop    %ebx
   171ab:	5e                   	pop    %esi
   171ac:	5f                   	pop    %edi
   171ad:	5d                   	pop    %ebp
   171ae:	c3                   	ret    

000171af <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   171af:	55                   	push   %ebp
   171b0:	89 e5                	mov    %esp,%ebp
   171b2:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   171b8:	83 ec 0c             	sub    $0xc,%esp
   171bb:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   171c1:	50                   	push   %eax
   171c2:	e8 38 d0 ff ff       	call   141ff <lodepng_state_init>
   171c7:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   171ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
   171cd:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   171d3:	8b 45 20             	mov    0x20(%ebp),%eax
   171d6:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   171dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   171df:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   171e5:	8b 45 20             	mov    0x20(%ebp),%eax
   171e8:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   171ee:	83 ec 08             	sub    $0x8,%esp
   171f1:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   171f7:	50                   	push   %eax
   171f8:	ff 75 18             	pushl  0x18(%ebp)
   171fb:	ff 75 14             	pushl  0x14(%ebp)
   171fe:	ff 75 10             	pushl  0x10(%ebp)
   17201:	ff 75 0c             	pushl  0xc(%ebp)
   17204:	ff 75 08             	pushl  0x8(%ebp)
   17207:	e8 48 f2 ff ff       	call   16454 <lodepng_encode>
   1720c:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   1720f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17212:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   17215:	83 ec 0c             	sub    $0xc,%esp
   17218:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1721e:	50                   	push   %eax
   1721f:	e8 35 d0 ff ff       	call   14259 <lodepng_state_cleanup>
   17224:	83 c4 10             	add    $0x10,%esp
  return error;
   17227:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1722a:	c9                   	leave  
   1722b:	c3                   	ret    

0001722c <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   1722c:	55                   	push   %ebp
   1722d:	89 e5                	mov    %esp,%ebp
   1722f:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   17232:	83 ec 04             	sub    $0x4,%esp
   17235:	6a 08                	push   $0x8
   17237:	6a 06                	push   $0x6
   17239:	ff 75 18             	pushl  0x18(%ebp)
   1723c:	ff 75 14             	pushl  0x14(%ebp)
   1723f:	ff 75 10             	pushl  0x10(%ebp)
   17242:	ff 75 0c             	pushl  0xc(%ebp)
   17245:	ff 75 08             	pushl  0x8(%ebp)
   17248:	e8 62 ff ff ff       	call   171af <lodepng_encode_memory>
   1724d:	83 c4 20             	add    $0x20,%esp
}
   17250:	c9                   	leave  
   17251:	c3                   	ret    

00017252 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   17252:	55                   	push   %ebp
   17253:	89 e5                	mov    %esp,%ebp
   17255:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   17258:	83 ec 04             	sub    $0x4,%esp
   1725b:	6a 08                	push   $0x8
   1725d:	6a 02                	push   $0x2
   1725f:	ff 75 18             	pushl  0x18(%ebp)
   17262:	ff 75 14             	pushl  0x14(%ebp)
   17265:	ff 75 10             	pushl  0x10(%ebp)
   17268:	ff 75 0c             	pushl  0xc(%ebp)
   1726b:	ff 75 08             	pushl  0x8(%ebp)
   1726e:	e8 3c ff ff ff       	call   171af <lodepng_encode_memory>
   17273:	83 c4 20             	add    $0x20,%esp
}
   17276:	c9                   	leave  
   17277:	c3                   	ret    

00017278 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   17278:	55                   	push   %ebp
   17279:	89 e5                	mov    %esp,%ebp
   1727b:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   1727e:	83 ec 04             	sub    $0x4,%esp
   17281:	ff 75 1c             	pushl  0x1c(%ebp)
   17284:	ff 75 18             	pushl  0x18(%ebp)
   17287:	ff 75 14             	pushl  0x14(%ebp)
   1728a:	ff 75 10             	pushl  0x10(%ebp)
   1728d:	ff 75 0c             	pushl  0xc(%ebp)
   17290:	8d 45 ec             	lea    -0x14(%ebp),%eax
   17293:	50                   	push   %eax
   17294:	8d 45 f0             	lea    -0x10(%ebp),%eax
   17297:	50                   	push   %eax
   17298:	e8 12 ff ff ff       	call   171af <lodepng_encode_memory>
   1729d:	83 c4 20             	add    $0x20,%esp
   172a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   172a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   172a7:	75 19                	jne    172c2 <lodepng_encode_file+0x4a>
   172a9:	8b 55 ec             	mov    -0x14(%ebp),%edx
   172ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   172af:	83 ec 04             	sub    $0x4,%esp
   172b2:	ff 75 08             	pushl  0x8(%ebp)
   172b5:	52                   	push   %edx
   172b6:	50                   	push   %eax
   172b7:	e8 36 01 ff ff       	call   73f2 <lodepng_save_file>
   172bc:	83 c4 10             	add    $0x10,%esp
   172bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   172c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   172c5:	83 ec 0c             	sub    $0xc,%esp
   172c8:	50                   	push   %eax
   172c9:	e8 7c fc fe ff       	call   6f4a <lodepng_free>
   172ce:	83 c4 10             	add    $0x10,%esp
  return error;
   172d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   172d4:	c9                   	leave  
   172d5:	c3                   	ret    

000172d6 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   172d6:	55                   	push   %ebp
   172d7:	89 e5                	mov    %esp,%ebp
   172d9:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   172dc:	83 ec 08             	sub    $0x8,%esp
   172df:	6a 08                	push   $0x8
   172e1:	6a 06                	push   $0x6
   172e3:	ff 75 14             	pushl  0x14(%ebp)
   172e6:	ff 75 10             	pushl  0x10(%ebp)
   172e9:	ff 75 0c             	pushl  0xc(%ebp)
   172ec:	ff 75 08             	pushl  0x8(%ebp)
   172ef:	e8 84 ff ff ff       	call   17278 <lodepng_encode_file>
   172f4:	83 c4 20             	add    $0x20,%esp
}
   172f7:	c9                   	leave  
   172f8:	c3                   	ret    

000172f9 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   172f9:	55                   	push   %ebp
   172fa:	89 e5                	mov    %esp,%ebp
   172fc:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   172ff:	83 ec 08             	sub    $0x8,%esp
   17302:	6a 08                	push   $0x8
   17304:	6a 02                	push   $0x2
   17306:	ff 75 14             	pushl  0x14(%ebp)
   17309:	ff 75 10             	pushl  0x10(%ebp)
   1730c:	ff 75 0c             	pushl  0xc(%ebp)
   1730f:	ff 75 08             	pushl  0x8(%ebp)
   17312:	e8 61 ff ff ff       	call   17278 <lodepng_encode_file>
   17317:	83 c4 20             	add    $0x20,%esp
}
   1731a:	c9                   	leave  
   1731b:	c3                   	ret    

0001731c <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   1731c:	55                   	push   %ebp
   1731d:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   1731f:	8b 45 08             	mov    0x8(%ebp),%eax
   17322:	50                   	push   %eax
   17323:	e8 71 49 ff ff       	call   bc99 <lodepng_compress_settings_init>
   17328:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   1732b:	8b 45 08             	mov    0x8(%ebp),%eax
   1732e:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   17335:	8b 45 08             	mov    0x8(%ebp),%eax
   17338:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   1733f:	8b 45 08             	mov    0x8(%ebp),%eax
   17342:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   17349:	8b 45 08             	mov    0x8(%ebp),%eax
   1734c:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   17353:	8b 45 08             	mov    0x8(%ebp),%eax
   17356:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   1735d:	8b 45 08             	mov    0x8(%ebp),%eax
   17360:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   17367:	8b 45 08             	mov    0x8(%ebp),%eax
   1736a:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   17371:	90                   	nop
   17372:	c9                   	leave  
   17373:	c3                   	ret    

00017374 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   17374:	55                   	push   %ebp
   17375:	89 e5                	mov    %esp,%ebp
  switch(code) {
   17377:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   1737b:	0f 87 c1 03 00 00    	ja     17742 <lodepng_error_text+0x3ce>
   17381:	8b 45 08             	mov    0x8(%ebp),%eax
   17384:	c1 e0 02             	shl    $0x2,%eax
   17387:	05 a0 07 02 00       	add    $0x207a0,%eax
   1738c:	8b 00                	mov    (%eax),%eax
   1738e:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   17390:	b8 6c f4 01 00       	mov    $0x1f46c,%eax
   17395:	e9 ad 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   1739a:	b8 89 f4 01 00       	mov    $0x1f489,%eax
   1739f:	e9 a3 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   173a4:	b8 9c f4 01 00       	mov    $0x1f49c,%eax
   173a9:	e9 99 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   173ae:	b8 d4 f4 01 00       	mov    $0x1f4d4,%eax
   173b3:	e9 8f 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   173b8:	b8 0c f5 01 00       	mov    $0x1f50c,%eax
   173bd:	e9 85 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   173c2:	b8 0c f5 01 00       	mov    $0x1f50c,%eax
   173c7:	e9 7b 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   173cc:	b8 0c f5 01 00       	mov    $0x1f50c,%eax
   173d1:	e9 71 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   173d6:	b8 3c f5 01 00       	mov    $0x1f53c,%eax
   173db:	e9 67 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   173e0:	b8 70 f5 01 00       	mov    $0x1f570,%eax
   173e5:	e9 5d 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   173ea:	b8 a4 f5 01 00       	mov    $0x1f5a4,%eax
   173ef:	e9 53 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   173f4:	b8 70 f5 01 00       	mov    $0x1f570,%eax
   173f9:	e9 49 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   173fe:	b8 cc f5 01 00       	mov    $0x1f5cc,%eax
   17403:	e9 3f 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   17408:	b8 04 f6 01 00       	mov    $0x1f604,%eax
   1740d:	e9 35 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   17412:	b8 70 f5 01 00       	mov    $0x1f570,%eax
   17417:	e9 2b 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   1741c:	b8 3c f6 01 00       	mov    $0x1f63c,%eax
   17421:	e9 21 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   17426:	b8 6c f6 01 00       	mov    $0x1f66c,%eax
   1742b:	e9 17 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   17430:	b8 8c f6 01 00       	mov    $0x1f68c,%eax
   17435:	e9 0d 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   1743a:	b8 b8 f6 01 00       	mov    $0x1f6b8,%eax
   1743f:	e9 03 03 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   17444:	b8 f8 f6 01 00       	mov    $0x1f6f8,%eax
   17449:	e9 f9 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   1744e:	b8 20 f7 01 00       	mov    $0x1f720,%eax
   17453:	e9 ef 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   17458:	b8 54 f7 01 00       	mov    $0x1f754,%eax
   1745d:	e9 e5 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   17462:	b8 78 f7 01 00       	mov    $0x1f778,%eax
   17467:	e9 db 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   1746c:	b8 b0 f7 01 00       	mov    $0x1f7b0,%eax
   17471:	e9 d1 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   17476:	b8 d0 f7 01 00       	mov    $0x1f7d0,%eax
   1747b:	e9 c7 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   17480:	b8 ef f7 01 00       	mov    $0x1f7ef,%eax
   17485:	e9 bd 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   1748a:	b8 09 f8 01 00       	mov    $0x1f809,%eax
   1748f:	e9 b3 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   17494:	b8 28 f8 01 00       	mov    $0x1f828,%eax
   17499:	e9 a9 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   1749e:	b8 64 f8 01 00       	mov    $0x1f864,%eax
   174a3:	e9 9f 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   174a8:	b8 88 f8 01 00       	mov    $0x1f888,%eax
   174ad:	e9 95 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   174b2:	b8 b4 f8 01 00       	mov    $0x1f8b4,%eax
   174b7:	e9 8b 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   174bc:	b8 d8 f8 01 00       	mov    $0x1f8d8,%eax
   174c1:	e9 81 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   174c6:	b8 18 f9 01 00       	mov    $0x1f918,%eax
   174cb:	e9 77 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   174d0:	b8 48 f9 01 00       	mov    $0x1f948,%eax
   174d5:	e9 6d 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   174da:	b8 70 f9 01 00       	mov    $0x1f970,%eax
   174df:	e9 63 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   174e4:	b8 b4 f9 01 00       	mov    $0x1f9b4,%eax
   174e9:	e9 59 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   174ee:	b8 e0 f9 01 00       	mov    $0x1f9e0,%eax
   174f3:	e9 4f 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   174f8:	b8 10 fa 01 00       	mov    $0x1fa10,%eax
   174fd:	e9 45 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   17502:	b8 38 fa 01 00       	mov    $0x1fa38,%eax
   17507:	e9 3b 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   1750c:	b8 80 fa 01 00       	mov    $0x1fa80,%eax
   17511:	e9 31 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   17516:	b8 80 fa 01 00       	mov    $0x1fa80,%eax
   1751b:	e9 27 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   17520:	b8 bc fa 01 00       	mov    $0x1fabc,%eax
   17525:	e9 1d 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   1752a:	b8 f0 fa 01 00       	mov    $0x1faf0,%eax
   1752f:	e9 13 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   17534:	b8 13 fb 01 00       	mov    $0x1fb13,%eax
   17539:	e9 09 02 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   1753e:	b8 30 fb 01 00       	mov    $0x1fb30,%eax
   17543:	e9 ff 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   17548:	b8 6c fb 01 00       	mov    $0x1fb6c,%eax
   1754d:	e9 f5 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   17552:	b8 9c fb 01 00       	mov    $0x1fb9c,%eax
   17557:	e9 eb 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   1755c:	b8 e8 fb 01 00       	mov    $0x1fbe8,%eax
   17561:	e9 e1 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   17566:	b8 20 fc 01 00       	mov    $0x1fc20,%eax
   1756b:	e9 d7 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   17570:	b8 60 fc 01 00       	mov    $0x1fc60,%eax
   17575:	e9 cd 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   1757a:	b8 8c fc 01 00       	mov    $0x1fc8c,%eax
   1757f:	e9 c3 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   17584:	b8 d8 fc 01 00       	mov    $0x1fcd8,%eax
   17589:	e9 b9 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   1758e:	b8 2c fd 01 00       	mov    $0x1fd2c,%eax
   17593:	e9 af 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   17598:	b8 60 fd 01 00       	mov    $0x1fd60,%eax
   1759d:	e9 a5 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   175a2:	b8 b0 fd 01 00       	mov    $0x1fdb0,%eax
   175a7:	e9 9b 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   175ac:	b8 ec fd 01 00       	mov    $0x1fdec,%eax
   175b1:	e9 91 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   175b6:	b8 4c fe 01 00       	mov    $0x1fe4c,%eax
   175bb:	e9 87 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   175c0:	b8 ac fe 01 00       	mov    $0x1feac,%eax
   175c5:	e9 7d 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   175ca:	b8 08 ff 01 00       	mov    $0x1ff08,%eax
   175cf:	e9 73 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   175d4:	b8 4c ff 01 00       	mov    $0x1ff4c,%eax
   175d9:	e9 69 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   175de:	b8 88 ff 01 00       	mov    $0x1ff88,%eax
   175e3:	e9 5f 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   175e8:	b8 e5 ff 01 00       	mov    $0x1ffe5,%eax
   175ed:	e9 55 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   175f2:	b8 fd ff 01 00       	mov    $0x1fffd,%eax
   175f7:	e9 4b 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   175fc:	b8 18 00 02 00       	mov    $0x20018,%eax
   17601:	e9 41 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   17606:	b8 54 00 02 00       	mov    $0x20054,%eax
   1760b:	e9 37 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   17610:	b8 84 00 02 00       	mov    $0x20084,%eax
   17615:	e9 2d 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   1761a:	b8 a4 00 02 00       	mov    $0x200a4,%eax
   1761f:	e9 23 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   17624:	b8 c4 00 02 00       	mov    $0x200c4,%eax
   17629:	e9 19 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   1762e:	b8 e4 00 02 00       	mov    $0x200e4,%eax
   17633:	e9 0f 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   17638:	b8 08 01 02 00       	mov    $0x20108,%eax
   1763d:	e9 05 01 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   17642:	b8 30 01 02 00       	mov    $0x20130,%eax
   17647:	e9 fb 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   1764c:	b8 8d 01 02 00       	mov    $0x2018d,%eax
   17651:	e9 f1 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   17656:	b8 a8 01 02 00       	mov    $0x201a8,%eax
   1765b:	e9 e7 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   17660:	b8 e4 01 02 00       	mov    $0x201e4,%eax
   17665:	e9 dd 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   1766a:	b8 18 02 02 00       	mov    $0x20218,%eax
   1766f:	e9 d3 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   17674:	b8 6c 02 02 00       	mov    $0x2026c,%eax
   17679:	e9 c9 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   1767e:	b8 b8 02 02 00       	mov    $0x202b8,%eax
   17683:	e9 bf 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   17688:	b8 f4 02 02 00       	mov    $0x202f4,%eax
   1768d:	e9 b5 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   17692:	b8 18 03 02 00       	mov    $0x20318,%eax
   17697:	e9 ab 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   1769c:	b8 38 03 02 00       	mov    $0x20338,%eax
   176a1:	e9 a1 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   176a6:	b8 60 03 02 00       	mov    $0x20360,%eax
   176ab:	e9 97 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   176b0:	b8 80 03 02 00       	mov    $0x20380,%eax
   176b5:	e9 8d 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   176ba:	b8 ac 03 02 00       	mov    $0x203ac,%eax
   176bf:	e9 83 00 00 00       	jmp    17747 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   176c4:	b8 db 03 02 00       	mov    $0x203db,%eax
   176c9:	eb 7c                	jmp    17747 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   176cb:	b8 f3 03 02 00       	mov    $0x203f3,%eax
   176d0:	eb 75                	jmp    17747 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   176d2:	b8 0b 04 02 00       	mov    $0x2040b,%eax
   176d7:	eb 6e                	jmp    17747 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   176d9:	b8 23 04 02 00       	mov    $0x20423,%eax
   176de:	eb 67                	jmp    17747 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   176e0:	b8 44 04 02 00       	mov    $0x20444,%eax
   176e5:	eb 60                	jmp    17747 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   176e7:	b8 94 04 02 00       	mov    $0x20494,%eax
   176ec:	eb 59                	jmp    17747 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   176ee:	b8 e8 04 02 00       	mov    $0x204e8,%eax
   176f3:	eb 52                	jmp    17747 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   176f5:	b8 3c 05 02 00       	mov    $0x2053c,%eax
   176fa:	eb 4b                	jmp    17747 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   176fc:	b8 84 05 02 00       	mov    $0x20584,%eax
   17701:	eb 44                	jmp    17747 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   17703:	b8 c8 05 02 00       	mov    $0x205c8,%eax
   17708:	eb 3d                	jmp    17747 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   1770a:	b8 e4 05 02 00       	mov    $0x205e4,%eax
   1770f:	eb 36                	jmp    17747 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   17711:	b8 1c 06 02 00       	mov    $0x2061c,%eax
   17716:	eb 2f                	jmp    17747 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   17718:	b8 70 06 02 00       	mov    $0x20670,%eax
   1771d:	eb 28                	jmp    17747 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   1771f:	b8 a0 06 02 00       	mov    $0x206a0,%eax
   17724:	eb 21                	jmp    17747 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   17726:	b8 f0 06 02 00       	mov    $0x206f0,%eax
   1772b:	eb 1a                	jmp    17747 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   1772d:	b8 1c 07 02 00       	mov    $0x2071c,%eax
   17732:	eb 13                	jmp    17747 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   17734:	b8 48 07 02 00       	mov    $0x20748,%eax
   17739:	eb 0c                	jmp    17747 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   1773b:	b8 6c 07 02 00       	mov    $0x2076c,%eax
   17740:	eb 05                	jmp    17747 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   17742:	b8 8b 07 02 00       	mov    $0x2078b,%eax
}
   17747:	5d                   	pop    %ebp
   17748:	c3                   	ret    

00017749 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   17749:	55                   	push   %ebp
   1774a:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   1774c:	8b 45 08             	mov    0x8(%ebp),%eax
   1774f:	8b 40 28             	mov    0x28(%eax),%eax
   17752:	83 f8 01             	cmp    $0x1,%eax
   17755:	75 08                	jne    1775f <GetImage+0x16>
   17757:	8b 45 08             	mov    0x8(%ebp),%eax
   1775a:	8b 40 54             	mov    0x54(%eax),%eax
   1775d:	eb 09                	jmp    17768 <GetImage+0x1f>
   1775f:	8b 45 08             	mov    0x8(%ebp),%eax
   17762:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   17768:	5d                   	pop    %ebp
   17769:	c3                   	ret    

0001776a <GetWidth>:

int GetWidth(Context* ctx){
   1776a:	55                   	push   %ebp
   1776b:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   1776d:	8b 45 08             	mov    0x8(%ebp),%eax
   17770:	8b 40 10             	mov    0x10(%eax),%eax
}
   17773:	5d                   	pop    %ebp
   17774:	c3                   	ret    

00017775 <GetHeight>:

int GetHeight(Context* ctx){
   17775:	55                   	push   %ebp
   17776:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   17778:	8b 45 08             	mov    0x8(%ebp),%eax
   1777b:	8b 40 14             	mov    0x14(%eax),%eax
}
   1777e:	5d                   	pop    %ebp
   1777f:	c3                   	ret    

00017780 <GetImageSize>:

uint GetImageSize(Context* ctx){
   17780:	55                   	push   %ebp
   17781:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   17783:	8b 45 08             	mov    0x8(%ebp),%eax
   17786:	8b 50 10             	mov    0x10(%eax),%edx
   17789:	8b 45 08             	mov    0x8(%ebp),%eax
   1778c:	8b 40 14             	mov    0x14(%eax),%eax
   1778f:	0f af d0             	imul   %eax,%edx
   17792:	8b 45 08             	mov    0x8(%ebp),%eax
   17795:	8b 40 28             	mov    0x28(%eax),%eax
   17798:	0f af c2             	imul   %edx,%eax
}
   1779b:	5d                   	pop    %ebp
   1779c:	c3                   	ret    

0001779d <_Clip>:

uchar _Clip(const int x){
   1779d:	55                   	push   %ebp
   1779e:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   177a0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   177a4:	78 15                	js     177bb <_Clip+0x1e>
   177a6:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   177ad:	7f 05                	jg     177b4 <_Clip+0x17>
   177af:	8b 45 08             	mov    0x8(%ebp),%eax
   177b2:	eb 0c                	jmp    177c0 <_Clip+0x23>
   177b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   177b9:	eb 05                	jmp    177c0 <_Clip+0x23>
   177bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
   177c0:	5d                   	pop    %ebp
   177c1:	c3                   	ret    

000177c2 <_Skip>:

void _Skip(Context* ctx, int c){
   177c2:	55                   	push   %ebp
   177c3:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   177c5:	8b 45 08             	mov    0x8(%ebp),%eax
   177c8:	8b 50 04             	mov    0x4(%eax),%edx
   177cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   177ce:	01 c2                	add    %eax,%edx
   177d0:	8b 45 08             	mov    0x8(%ebp),%eax
   177d3:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   177d6:	8b 45 08             	mov    0x8(%ebp),%eax
   177d9:	8b 40 08             	mov    0x8(%eax),%eax
   177dc:	2b 45 0c             	sub    0xc(%ebp),%eax
   177df:	89 c2                	mov    %eax,%edx
   177e1:	8b 45 08             	mov    0x8(%ebp),%eax
   177e4:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   177e7:	8b 45 08             	mov    0x8(%ebp),%eax
   177ea:	8b 40 0c             	mov    0xc(%eax),%eax
   177ed:	2b 45 0c             	sub    0xc(%ebp),%eax
   177f0:	89 c2                	mov    %eax,%edx
   177f2:	8b 45 08             	mov    0x8(%ebp),%eax
   177f5:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   177f8:	8b 45 08             	mov    0x8(%ebp),%eax
   177fb:	8b 40 08             	mov    0x8(%eax),%eax
   177fe:	85 c0                	test   %eax,%eax
   17800:	79 09                	jns    1780b <_Skip+0x49>
   17802:	8b 45 08             	mov    0x8(%ebp),%eax
   17805:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   1780b:	90                   	nop
   1780c:	5d                   	pop    %ebp
   1780d:	c3                   	ret    

0001780e <_DecodeLength>:

void _DecodeLength(Context* ctx){
   1780e:	55                   	push   %ebp
   1780f:	89 e5                	mov    %esp,%ebp
   17811:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   17814:	8b 45 08             	mov    0x8(%ebp),%eax
   17817:	8b 40 08             	mov    0x8(%eax),%eax
   1781a:	83 f8 01             	cmp    $0x1,%eax
   1781d:	7f 0b                	jg     1782a <_DecodeLength+0x1c>
   1781f:	8b 45 08             	mov    0x8(%ebp),%eax
   17822:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17828:	eb 45                	jmp    1786f <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   1782a:	8b 45 08             	mov    0x8(%ebp),%eax
   1782d:	8b 40 04             	mov    0x4(%eax),%eax
   17830:	83 ec 0c             	sub    $0xc,%esp
   17833:	50                   	push   %eax
   17834:	e8 38 00 00 00       	call   17871 <_Decode2Bytes>
   17839:	83 c4 10             	add    $0x10,%esp
   1783c:	89 c2                	mov    %eax,%edx
   1783e:	8b 45 08             	mov    0x8(%ebp),%eax
   17841:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   17844:	8b 45 08             	mov    0x8(%ebp),%eax
   17847:	8b 50 0c             	mov    0xc(%eax),%edx
   1784a:	8b 45 08             	mov    0x8(%ebp),%eax
   1784d:	8b 40 08             	mov    0x8(%eax),%eax
   17850:	39 c2                	cmp    %eax,%edx
   17852:	7e 0b                	jle    1785f <_DecodeLength+0x51>
   17854:	8b 45 08             	mov    0x8(%ebp),%eax
   17857:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1785d:	eb 10                	jmp    1786f <_DecodeLength+0x61>
    _Skip(ctx, 2);
   1785f:	83 ec 08             	sub    $0x8,%esp
   17862:	6a 02                	push   $0x2
   17864:	ff 75 08             	pushl  0x8(%ebp)
   17867:	e8 56 ff ff ff       	call   177c2 <_Skip>
   1786c:	83 c4 10             	add    $0x10,%esp
}
   1786f:	c9                   	leave  
   17870:	c3                   	ret    

00017871 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   17871:	55                   	push   %ebp
   17872:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   17874:	8b 45 08             	mov    0x8(%ebp),%eax
   17877:	0f b6 00             	movzbl (%eax),%eax
   1787a:	0f b6 c0             	movzbl %al,%eax
   1787d:	c1 e0 08             	shl    $0x8,%eax
   17880:	89 c2                	mov    %eax,%edx
   17882:	8b 45 08             	mov    0x8(%ebp),%eax
   17885:	83 c0 01             	add    $0x1,%eax
   17888:	0f b6 00             	movzbl (%eax),%eax
   1788b:	0f b6 c0             	movzbl %al,%eax
   1788e:	09 d0                	or     %edx,%eax
}
   17890:	5d                   	pop    %ebp
   17891:	c3                   	ret    

00017892 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   17892:	55                   	push   %ebp
   17893:	89 e5                	mov    %esp,%ebp
   17895:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   17898:	8b 45 08             	mov    0x8(%ebp),%eax
   1789b:	8b 55 10             	mov    0x10(%ebp),%edx
   1789e:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   178a1:	8b 45 14             	mov    0x14(%ebp),%eax
   178a4:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   178a9:	89 c2                	mov    %eax,%edx
   178ab:	8b 45 08             	mov    0x8(%ebp),%eax
   178ae:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   178b1:	8b 45 08             	mov    0x8(%ebp),%eax
   178b4:	8b 40 08             	mov    0x8(%eax),%eax
   178b7:	83 f8 01             	cmp    $0x1,%eax
   178ba:	7e 1d                	jle    178d9 <_DecodeJPEG+0x47>
   178bc:	8b 45 08             	mov    0x8(%ebp),%eax
   178bf:	8b 40 04             	mov    0x4(%eax),%eax
   178c2:	0f b6 00             	movzbl (%eax),%eax
   178c5:	3c ff                	cmp    $0xff,%al
   178c7:	75 10                	jne    178d9 <_DecodeJPEG+0x47>
   178c9:	8b 45 08             	mov    0x8(%ebp),%eax
   178cc:	8b 40 04             	mov    0x4(%eax),%eax
   178cf:	83 c0 01             	add    $0x1,%eax
   178d2:	0f b6 00             	movzbl (%eax),%eax
   178d5:	3c d8                	cmp    $0xd8,%al
   178d7:	74 0a                	je     178e3 <_DecodeJPEG+0x51>
   178d9:	b8 01 00 00 00       	mov    $0x1,%eax
   178de:	e9 56 01 00 00       	jmp    17a39 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   178e3:	6a 02                	push   $0x2
   178e5:	ff 75 08             	pushl  0x8(%ebp)
   178e8:	e8 d5 fe ff ff       	call   177c2 <_Skip>
   178ed:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   178f0:	e9 0a 01 00 00       	jmp    179ff <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   178f5:	8b 45 08             	mov    0x8(%ebp),%eax
   178f8:	8b 40 08             	mov    0x8(%eax),%eax
   178fb:	85 c0                	test   %eax,%eax
   178fd:	78 0d                	js     1790c <_DecodeJPEG+0x7a>
   178ff:	8b 45 08             	mov    0x8(%ebp),%eax
   17902:	8b 40 04             	mov    0x4(%eax),%eax
   17905:	0f b6 00             	movzbl (%eax),%eax
   17908:	3c ff                	cmp    $0xff,%al
   1790a:	74 0a                	je     17916 <_DecodeJPEG+0x84>
   1790c:	b8 05 00 00 00       	mov    $0x5,%eax
   17911:	e9 23 01 00 00       	jmp    17a39 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   17916:	6a 02                	push   $0x2
   17918:	ff 75 08             	pushl  0x8(%ebp)
   1791b:	e8 a2 fe ff ff       	call   177c2 <_Skip>
   17920:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   17923:	8b 45 08             	mov    0x8(%ebp),%eax
   17926:	8b 40 04             	mov    0x4(%eax),%eax
   17929:	83 e8 01             	sub    $0x1,%eax
   1792c:	0f b6 00             	movzbl (%eax),%eax
   1792f:	0f b6 c0             	movzbl %al,%eax
   17932:	3d da 00 00 00       	cmp    $0xda,%eax
   17937:	74 71                	je     179aa <_DecodeJPEG+0x118>
   17939:	3d da 00 00 00       	cmp    $0xda,%eax
   1793e:	7f 10                	jg     17950 <_DecodeJPEG+0xbe>
   17940:	3d c0 00 00 00       	cmp    $0xc0,%eax
   17945:	74 20                	je     17967 <_DecodeJPEG+0xd5>
   17947:	3d c4 00 00 00       	cmp    $0xc4,%eax
   1794c:	74 2c                	je     1797a <_DecodeJPEG+0xe8>
   1794e:	eb 7d                	jmp    179cd <_DecodeJPEG+0x13b>
   17950:	3d dd 00 00 00       	cmp    $0xdd,%eax
   17955:	74 43                	je     1799a <_DecodeJPEG+0x108>
   17957:	3d fe 00 00 00       	cmp    $0xfe,%eax
   1795c:	74 5f                	je     179bd <_DecodeJPEG+0x12b>
   1795e:	3d db 00 00 00       	cmp    $0xdb,%eax
   17963:	74 25                	je     1798a <_DecodeJPEG+0xf8>
   17965:	eb 66                	jmp    179cd <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   17967:	83 ec 0c             	sub    $0xc,%esp
   1796a:	ff 75 08             	pushl  0x8(%ebp)
   1796d:	e8 c9 00 00 00       	call   17a3b <_DecodeSOF>
   17972:	83 c4 10             	add    $0x10,%esp
   17975:	e9 85 00 00 00       	jmp    179ff <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   1797a:	83 ec 0c             	sub    $0xc,%esp
   1797d:	ff 75 08             	pushl  0x8(%ebp)
   17980:	e8 28 05 00 00       	call   17ead <_DecodeDHT>
   17985:	83 c4 10             	add    $0x10,%esp
   17988:	eb 75                	jmp    179ff <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   1798a:	83 ec 0c             	sub    $0xc,%esp
   1798d:	ff 75 08             	pushl  0x8(%ebp)
   17990:	e8 05 07 00 00       	call   1809a <_DecodeDQT>
   17995:	83 c4 10             	add    $0x10,%esp
   17998:	eb 65                	jmp    179ff <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   1799a:	83 ec 0c             	sub    $0xc,%esp
   1799d:	ff 75 08             	pushl  0x8(%ebp)
   179a0:	e8 ff 07 00 00       	call   181a4 <_DecodeDRI>
   179a5:	83 c4 10             	add    $0x10,%esp
   179a8:	eb 55                	jmp    179ff <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   179aa:	83 ec 08             	sub    $0x8,%esp
   179ad:	ff 75 0c             	pushl  0xc(%ebp)
   179b0:	ff 75 08             	pushl  0x8(%ebp)
   179b3:	e8 56 08 00 00       	call   1820e <_DecodeSOS>
   179b8:	83 c4 10             	add    $0x10,%esp
   179bb:	eb 42                	jmp    179ff <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   179bd:	83 ec 0c             	sub    $0xc,%esp
   179c0:	ff 75 08             	pushl  0x8(%ebp)
   179c3:	e8 a8 15 00 00       	call   18f70 <_SkipMarker>
   179c8:	83 c4 10             	add    $0x10,%esp
   179cb:	eb 32                	jmp    179ff <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   179cd:	8b 45 08             	mov    0x8(%ebp),%eax
   179d0:	8b 40 04             	mov    0x4(%eax),%eax
   179d3:	83 e8 01             	sub    $0x1,%eax
   179d6:	0f b6 00             	movzbl (%eax),%eax
   179d9:	0f b6 c0             	movzbl %al,%eax
   179dc:	25 f0 00 00 00       	and    $0xf0,%eax
   179e1:	3d e0 00 00 00       	cmp    $0xe0,%eax
   179e6:	75 10                	jne    179f8 <_DecodeJPEG+0x166>
   179e8:	83 ec 0c             	sub    $0xc,%esp
   179eb:	ff 75 08             	pushl  0x8(%ebp)
   179ee:	e8 7d 15 00 00       	call   18f70 <_SkipMarker>
   179f3:	83 c4 10             	add    $0x10,%esp
   179f6:	eb 07                	jmp    179ff <_DecodeJPEG+0x16d>
                else return Unsupported;
   179f8:	b8 02 00 00 00       	mov    $0x2,%eax
   179fd:	eb 3a                	jmp    17a39 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   179ff:	8b 45 08             	mov    0x8(%ebp),%eax
   17a02:	8b 00                	mov    (%eax),%eax
   17a04:	85 c0                	test   %eax,%eax
   17a06:	0f 84 e9 fe ff ff    	je     178f5 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   17a0c:	8b 45 08             	mov    0x8(%ebp),%eax
   17a0f:	8b 00                	mov    (%eax),%eax
   17a11:	83 f8 06             	cmp    $0x6,%eax
   17a14:	74 07                	je     17a1d <_DecodeJPEG+0x18b>
   17a16:	8b 45 08             	mov    0x8(%ebp),%eax
   17a19:	8b 00                	mov    (%eax),%eax
   17a1b:	eb 1c                	jmp    17a39 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   17a1d:	8b 45 08             	mov    0x8(%ebp),%eax
   17a20:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   17a26:	83 ec 0c             	sub    $0xc,%esp
   17a29:	ff 75 08             	pushl  0x8(%ebp)
   17a2c:	e8 6b 15 00 00       	call   18f9c <_Convert>
   17a31:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   17a34:	8b 45 08             	mov    0x8(%ebp),%eax
   17a37:	8b 00                	mov    (%eax),%eax
 }
   17a39:	c9                   	leave  
   17a3a:	c3                   	ret    

00017a3b <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   17a3b:	55                   	push   %ebp
   17a3c:	89 e5                	mov    %esp,%ebp
   17a3e:	53                   	push   %ebx
   17a3f:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   17a42:	83 ec 0c             	sub    $0xc,%esp
   17a45:	ff 75 08             	pushl  0x8(%ebp)
   17a48:	e8 c1 fd ff ff       	call   1780e <_DecodeLength>
   17a4d:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   17a50:	8b 45 08             	mov    0x8(%ebp),%eax
   17a53:	8b 00                	mov    (%eax),%eax
   17a55:	85 c0                	test   %eax,%eax
   17a57:	0f 85 4a 04 00 00    	jne    17ea7 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   17a5d:	8b 45 08             	mov    0x8(%ebp),%eax
   17a60:	8b 40 0c             	mov    0xc(%eax),%eax
   17a63:	83 f8 08             	cmp    $0x8,%eax
   17a66:	7f 0e                	jg     17a76 <_DecodeSOF+0x3b>
   17a68:	8b 45 08             	mov    0x8(%ebp),%eax
   17a6b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17a71:	e9 32 04 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   17a76:	8b 45 08             	mov    0x8(%ebp),%eax
   17a79:	8b 40 04             	mov    0x4(%eax),%eax
   17a7c:	0f b6 00             	movzbl (%eax),%eax
   17a7f:	3c 08                	cmp    $0x8,%al
   17a81:	74 0e                	je     17a91 <_DecodeSOF+0x56>
   17a83:	8b 45 08             	mov    0x8(%ebp),%eax
   17a86:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   17a8c:	e9 17 04 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   17a91:	8b 45 08             	mov    0x8(%ebp),%eax
   17a94:	8b 40 04             	mov    0x4(%eax),%eax
   17a97:	83 c0 01             	add    $0x1,%eax
   17a9a:	83 ec 0c             	sub    $0xc,%esp
   17a9d:	50                   	push   %eax
   17a9e:	e8 ce fd ff ff       	call   17871 <_Decode2Bytes>
   17aa3:	83 c4 10             	add    $0x10,%esp
   17aa6:	89 c2                	mov    %eax,%edx
   17aa8:	8b 45 08             	mov    0x8(%ebp),%eax
   17aab:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   17aae:	8b 45 08             	mov    0x8(%ebp),%eax
   17ab1:	8b 40 04             	mov    0x4(%eax),%eax
   17ab4:	83 c0 03             	add    $0x3,%eax
   17ab7:	83 ec 0c             	sub    $0xc,%esp
   17aba:	50                   	push   %eax
   17abb:	e8 b1 fd ff ff       	call   17871 <_Decode2Bytes>
   17ac0:	83 c4 10             	add    $0x10,%esp
   17ac3:	89 c2                	mov    %eax,%edx
   17ac5:	8b 45 08             	mov    0x8(%ebp),%eax
   17ac8:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   17acb:	8b 45 08             	mov    0x8(%ebp),%eax
   17ace:	8b 40 04             	mov    0x4(%eax),%eax
   17ad1:	83 c0 05             	add    $0x5,%eax
   17ad4:	0f b6 00             	movzbl (%eax),%eax
   17ad7:	0f b6 d0             	movzbl %al,%edx
   17ada:	8b 45 08             	mov    0x8(%ebp),%eax
   17add:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   17ae0:	83 ec 08             	sub    $0x8,%esp
   17ae3:	6a 06                	push   $0x6
   17ae5:	ff 75 08             	pushl  0x8(%ebp)
   17ae8:	e8 d5 fc ff ff       	call   177c2 <_Skip>
   17aed:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   17af0:	8b 45 08             	mov    0x8(%ebp),%eax
   17af3:	8b 40 28             	mov    0x28(%eax),%eax
   17af6:	83 f8 01             	cmp    $0x1,%eax
   17af9:	74 13                	je     17b0e <_DecodeSOF+0xd3>
   17afb:	83 f8 03             	cmp    $0x3,%eax
   17afe:	74 0e                	je     17b0e <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   17b00:	8b 45 08             	mov    0x8(%ebp),%eax
   17b03:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   17b09:	e9 9a 03 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   17b0e:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   17b0f:	8b 45 08             	mov    0x8(%ebp),%eax
   17b12:	8b 48 0c             	mov    0xc(%eax),%ecx
   17b15:	8b 45 08             	mov    0x8(%ebp),%eax
   17b18:	8b 50 28             	mov    0x28(%eax),%edx
   17b1b:	89 d0                	mov    %edx,%eax
   17b1d:	01 c0                	add    %eax,%eax
   17b1f:	01 d0                	add    %edx,%eax
   17b21:	39 c1                	cmp    %eax,%ecx
   17b23:	7d 0e                	jge    17b33 <_DecodeSOF+0xf8>
   17b25:	8b 45 08             	mov    0x8(%ebp),%eax
   17b28:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17b2e:	e9 75 03 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   17b33:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   17b3a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   17b41:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17b48:	8b 45 08             	mov    0x8(%ebp),%eax
   17b4b:	83 c0 2c             	add    $0x2c,%eax
   17b4e:	89 45 e8             	mov    %eax,-0x18(%ebp)
   17b51:	e9 50 01 00 00       	jmp    17ca6 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   17b56:	8b 45 08             	mov    0x8(%ebp),%eax
   17b59:	8b 40 04             	mov    0x4(%eax),%eax
   17b5c:	0f b6 00             	movzbl (%eax),%eax
   17b5f:	0f b6 d0             	movzbl %al,%edx
   17b62:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17b65:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   17b67:	8b 45 08             	mov    0x8(%ebp),%eax
   17b6a:	8b 40 04             	mov    0x4(%eax),%eax
   17b6d:	83 c0 01             	add    $0x1,%eax
   17b70:	0f b6 00             	movzbl (%eax),%eax
   17b73:	c0 e8 04             	shr    $0x4,%al
   17b76:	0f b6 d0             	movzbl %al,%edx
   17b79:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17b7c:	89 50 04             	mov    %edx,0x4(%eax)
   17b7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17b82:	8b 40 04             	mov    0x4(%eax),%eax
   17b85:	85 c0                	test   %eax,%eax
   17b87:	75 0e                	jne    17b97 <_DecodeSOF+0x15c>
   17b89:	8b 45 08             	mov    0x8(%ebp),%eax
   17b8c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17b92:	e9 11 03 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   17b97:	8b 45 08             	mov    0x8(%ebp),%eax
   17b9a:	8b 40 04             	mov    0x4(%eax),%eax
   17b9d:	83 c0 01             	add    $0x1,%eax
   17ba0:	0f b6 00             	movzbl (%eax),%eax
   17ba3:	0f b6 c0             	movzbl %al,%eax
   17ba6:	83 e0 0f             	and    $0xf,%eax
   17ba9:	89 c2                	mov    %eax,%edx
   17bab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17bae:	89 50 08             	mov    %edx,0x8(%eax)
   17bb1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17bb4:	8b 40 08             	mov    0x8(%eax),%eax
   17bb7:	85 c0                	test   %eax,%eax
   17bb9:	75 0e                	jne    17bc9 <_DecodeSOF+0x18e>
   17bbb:	8b 45 08             	mov    0x8(%ebp),%eax
   17bbe:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17bc4:	e9 df 02 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   17bc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17bcc:	8b 50 04             	mov    0x4(%eax),%edx
   17bcf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17bd2:	8b 40 04             	mov    0x4(%eax),%eax
   17bd5:	83 e8 01             	sub    $0x1,%eax
   17bd8:	21 d0                	and    %edx,%eax
   17bda:	85 c0                	test   %eax,%eax
   17bdc:	74 0e                	je     17bec <_DecodeSOF+0x1b1>
   17bde:	8b 45 08             	mov    0x8(%ebp),%eax
   17be1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   17be7:	e9 bc 02 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   17bec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17bef:	8b 50 08             	mov    0x8(%eax),%edx
   17bf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17bf5:	8b 40 08             	mov    0x8(%eax),%eax
   17bf8:	83 e8 01             	sub    $0x1,%eax
   17bfb:	21 d0                	and    %edx,%eax
   17bfd:	85 c0                	test   %eax,%eax
   17bff:	74 0e                	je     17c0f <_DecodeSOF+0x1d4>
   17c01:	8b 45 08             	mov    0x8(%ebp),%eax
   17c04:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   17c0a:	e9 99 02 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   17c0f:	8b 45 08             	mov    0x8(%ebp),%eax
   17c12:	8b 40 04             	mov    0x4(%eax),%eax
   17c15:	83 c0 02             	add    $0x2,%eax
   17c18:	0f b6 00             	movzbl (%eax),%eax
   17c1b:	0f b6 d0             	movzbl %al,%edx
   17c1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17c21:	89 50 18             	mov    %edx,0x18(%eax)
   17c24:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17c27:	8b 40 18             	mov    0x18(%eax),%eax
   17c2a:	25 fc 00 00 00       	and    $0xfc,%eax
   17c2f:	85 c0                	test   %eax,%eax
   17c31:	74 0e                	je     17c41 <_DecodeSOF+0x206>
   17c33:	8b 45 08             	mov    0x8(%ebp),%eax
   17c36:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17c3c:	e9 67 02 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   17c41:	83 ec 08             	sub    $0x8,%esp
   17c44:	6a 03                	push   $0x3
   17c46:	ff 75 08             	pushl  0x8(%ebp)
   17c49:	e8 74 fb ff ff       	call   177c2 <_Skip>
   17c4e:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   17c51:	8b 45 08             	mov    0x8(%ebp),%eax
   17c54:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   17c5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17c5d:	8b 40 18             	mov    0x18(%eax),%eax
   17c60:	bb 01 00 00 00       	mov    $0x1,%ebx
   17c65:	89 c1                	mov    %eax,%ecx
   17c67:	d3 e3                	shl    %cl,%ebx
   17c69:	89 d8                	mov    %ebx,%eax
   17c6b:	09 c2                	or     %eax,%edx
   17c6d:	8b 45 08             	mov    0x8(%ebp),%eax
   17c70:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   17c76:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17c79:	8b 40 04             	mov    0x4(%eax),%eax
   17c7c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   17c7f:	7e 09                	jle    17c8a <_DecodeSOF+0x24f>
   17c81:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17c84:	8b 40 04             	mov    0x4(%eax),%eax
   17c87:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   17c8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17c8d:	8b 40 08             	mov    0x8(%eax),%eax
   17c90:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   17c93:	7e 09                	jle    17c9e <_DecodeSOF+0x263>
   17c95:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17c98:	8b 40 08             	mov    0x8(%eax),%eax
   17c9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   17c9e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17ca2:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   17ca6:	8b 45 08             	mov    0x8(%ebp),%eax
   17ca9:	8b 40 28             	mov    0x28(%eax),%eax
   17cac:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   17caf:	0f 8f a1 fe ff ff    	jg     17b56 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   17cb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17cb8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   17cbf:	8b 45 08             	mov    0x8(%ebp),%eax
   17cc2:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   17cc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17cc8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   17ccf:	8b 45 08             	mov    0x8(%ebp),%eax
   17cd2:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   17cd5:	8b 45 08             	mov    0x8(%ebp),%eax
   17cd8:	8b 50 10             	mov    0x10(%eax),%edx
   17cdb:	8b 45 08             	mov    0x8(%ebp),%eax
   17cde:	8b 40 20             	mov    0x20(%eax),%eax
   17ce1:	01 d0                	add    %edx,%eax
   17ce3:	8d 48 ff             	lea    -0x1(%eax),%ecx
   17ce6:	8b 45 08             	mov    0x8(%ebp),%eax
   17ce9:	8b 58 20             	mov    0x20(%eax),%ebx
   17cec:	89 c8                	mov    %ecx,%eax
   17cee:	99                   	cltd   
   17cef:	f7 fb                	idiv   %ebx
   17cf1:	89 c2                	mov    %eax,%edx
   17cf3:	8b 45 08             	mov    0x8(%ebp),%eax
   17cf6:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   17cf9:	8b 45 08             	mov    0x8(%ebp),%eax
   17cfc:	8b 50 14             	mov    0x14(%eax),%edx
   17cff:	8b 45 08             	mov    0x8(%ebp),%eax
   17d02:	8b 40 24             	mov    0x24(%eax),%eax
   17d05:	01 d0                	add    %edx,%eax
   17d07:	8d 48 ff             	lea    -0x1(%eax),%ecx
   17d0a:	8b 45 08             	mov    0x8(%ebp),%eax
   17d0d:	8b 58 24             	mov    0x24(%eax),%ebx
   17d10:	89 c8                	mov    %ecx,%eax
   17d12:	99                   	cltd   
   17d13:	f7 fb                	idiv   %ebx
   17d15:	89 c2                	mov    %eax,%edx
   17d17:	8b 45 08             	mov    0x8(%ebp),%eax
   17d1a:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   17d1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17d24:	8b 45 08             	mov    0x8(%ebp),%eax
   17d27:	83 c0 2c             	add    $0x2c,%eax
   17d2a:	89 45 e8             	mov    %eax,-0x18(%ebp)
   17d2d:	e9 fd 00 00 00       	jmp    17e2f <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   17d32:	8b 45 08             	mov    0x8(%ebp),%eax
   17d35:	8b 50 10             	mov    0x10(%eax),%edx
   17d38:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17d3b:	8b 40 04             	mov    0x4(%eax),%eax
   17d3e:	0f af d0             	imul   %eax,%edx
   17d41:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17d44:	01 d0                	add    %edx,%eax
   17d46:	83 e8 01             	sub    $0x1,%eax
   17d49:	99                   	cltd   
   17d4a:	f7 7d ec             	idivl  -0x14(%ebp)
   17d4d:	89 c2                	mov    %eax,%edx
   17d4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17d52:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   17d55:	8b 45 08             	mov    0x8(%ebp),%eax
   17d58:	8b 50 14             	mov    0x14(%eax),%edx
   17d5b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17d5e:	8b 40 08             	mov    0x8(%eax),%eax
   17d61:	0f af d0             	imul   %eax,%edx
   17d64:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17d67:	01 d0                	add    %edx,%eax
   17d69:	83 e8 01             	sub    $0x1,%eax
   17d6c:	99                   	cltd   
   17d6d:	f7 7d f0             	idivl  -0x10(%ebp)
   17d70:	89 c2                	mov    %eax,%edx
   17d72:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17d75:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   17d78:	8b 45 08             	mov    0x8(%ebp),%eax
   17d7b:	8b 50 18             	mov    0x18(%eax),%edx
   17d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   17d81:	8b 40 20             	mov    0x20(%eax),%eax
   17d84:	0f af d0             	imul   %eax,%edx
   17d87:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17d8a:	8b 40 04             	mov    0x4(%eax),%eax
   17d8d:	0f af c2             	imul   %edx,%eax
   17d90:	99                   	cltd   
   17d91:	f7 7d ec             	idivl  -0x14(%ebp)
   17d94:	89 c2                	mov    %eax,%edx
   17d96:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17d99:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   17d9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17d9f:	8b 40 0c             	mov    0xc(%eax),%eax
   17da2:	83 f8 02             	cmp    $0x2,%eax
   17da5:	7f 0b                	jg     17db2 <_DecodeSOF+0x377>
   17da7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17daa:	8b 40 04             	mov    0x4(%eax),%eax
   17dad:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   17db0:	75 16                	jne    17dc8 <_DecodeSOF+0x38d>
   17db2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17db5:	8b 40 10             	mov    0x10(%eax),%eax
   17db8:	83 f8 02             	cmp    $0x2,%eax
   17dbb:	7f 19                	jg     17dd6 <_DecodeSOF+0x39b>
   17dbd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17dc0:	8b 40 08             	mov    0x8(%eax),%eax
   17dc3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   17dc6:	74 0e                	je     17dd6 <_DecodeSOF+0x39b>
   17dc8:	8b 45 08             	mov    0x8(%ebp),%eax
   17dcb:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   17dd1:	e9 d2 00 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   17dd6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17dd9:	8b 48 14             	mov    0x14(%eax),%ecx
   17ddc:	8b 45 08             	mov    0x8(%ebp),%eax
   17ddf:	8b 50 1c             	mov    0x1c(%eax),%edx
   17de2:	8b 45 08             	mov    0x8(%ebp),%eax
   17de5:	8b 40 24             	mov    0x24(%eax),%eax
   17de8:	0f af d0             	imul   %eax,%edx
   17deb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17dee:	8b 40 08             	mov    0x8(%eax),%eax
   17df1:	0f af c2             	imul   %edx,%eax
   17df4:	99                   	cltd   
   17df5:	f7 7d f0             	idivl  -0x10(%ebp)
   17df8:	0f af c1             	imul   %ecx,%eax
   17dfb:	83 ec 0c             	sub    $0xc,%esp
   17dfe:	50                   	push   %eax
   17dff:	e8 45 c5 fe ff       	call   4349 <malloc>
   17e04:	83 c4 10             	add    $0x10,%esp
   17e07:	89 c2                	mov    %eax,%edx
   17e09:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17e0c:	89 50 28             	mov    %edx,0x28(%eax)
   17e0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17e12:	8b 40 28             	mov    0x28(%eax),%eax
   17e15:	85 c0                	test   %eax,%eax
   17e17:	75 0e                	jne    17e27 <_DecodeSOF+0x3ec>
   17e19:	8b 45 08             	mov    0x8(%ebp),%eax
   17e1c:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   17e22:	e9 81 00 00 00       	jmp    17ea8 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   17e27:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17e2b:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   17e2f:	8b 45 08             	mov    0x8(%ebp),%eax
   17e32:	8b 40 28             	mov    0x28(%eax),%eax
   17e35:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   17e38:	0f 8f f4 fe ff ff    	jg     17d32 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   17e3e:	8b 45 08             	mov    0x8(%ebp),%eax
   17e41:	8b 40 28             	mov    0x28(%eax),%eax
   17e44:	83 f8 03             	cmp    $0x3,%eax
   17e47:	75 47                	jne    17e90 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   17e49:	8b 45 08             	mov    0x8(%ebp),%eax
   17e4c:	8b 50 10             	mov    0x10(%eax),%edx
   17e4f:	8b 45 08             	mov    0x8(%ebp),%eax
   17e52:	8b 40 14             	mov    0x14(%eax),%eax
   17e55:	0f af d0             	imul   %eax,%edx
   17e58:	8b 45 08             	mov    0x8(%ebp),%eax
   17e5b:	8b 40 28             	mov    0x28(%eax),%eax
   17e5e:	0f af c2             	imul   %edx,%eax
   17e61:	83 ec 0c             	sub    $0xc,%esp
   17e64:	50                   	push   %eax
   17e65:	e8 df c4 fe ff       	call   4349 <malloc>
   17e6a:	83 c4 10             	add    $0x10,%esp
   17e6d:	89 c2                	mov    %eax,%edx
   17e6f:	8b 45 08             	mov    0x8(%ebp),%eax
   17e72:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   17e78:	8b 45 08             	mov    0x8(%ebp),%eax
   17e7b:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   17e81:	85 c0                	test   %eax,%eax
   17e83:	75 0b                	jne    17e90 <_DecodeSOF+0x455>
   17e85:	8b 45 08             	mov    0x8(%ebp),%eax
   17e88:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   17e8e:	eb 18                	jmp    17ea8 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   17e90:	8b 45 08             	mov    0x8(%ebp),%eax
   17e93:	8b 40 0c             	mov    0xc(%eax),%eax
   17e96:	83 ec 08             	sub    $0x8,%esp
   17e99:	50                   	push   %eax
   17e9a:	ff 75 08             	pushl  0x8(%ebp)
   17e9d:	e8 20 f9 ff ff       	call   177c2 <_Skip>
   17ea2:	83 c4 10             	add    $0x10,%esp
   17ea5:	eb 01                	jmp    17ea8 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   17ea7:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   17ea8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   17eab:	c9                   	leave  
   17eac:	c3                   	ret    

00017ead <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   17ead:	55                   	push   %ebp
   17eae:	89 e5                	mov    %esp,%ebp
   17eb0:	53                   	push   %ebx
   17eb1:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   17eb4:	83 ec 0c             	sub    $0xc,%esp
   17eb7:	ff 75 08             	pushl  0x8(%ebp)
   17eba:	e8 4f f9 ff ff       	call   1780e <_DecodeLength>
   17ebf:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   17ec2:	8b 45 08             	mov    0x8(%ebp),%eax
   17ec5:	8b 00                	mov    (%eax),%eax
   17ec7:	85 c0                	test   %eax,%eax
   17ec9:	0f 85 c5 01 00 00    	jne    18094 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   17ecf:	e9 9c 01 00 00       	jmp    18070 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   17ed4:	8b 45 08             	mov    0x8(%ebp),%eax
   17ed7:	8b 40 04             	mov    0x4(%eax),%eax
   17eda:	0f b6 00             	movzbl (%eax),%eax
   17edd:	0f b6 c0             	movzbl %al,%eax
   17ee0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   17ee3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17ee6:	25 ec 00 00 00       	and    $0xec,%eax
   17eeb:	85 c0                	test   %eax,%eax
   17eed:	74 0e                	je     17efd <_DecodeDHT+0x50>
   17eef:	8b 45 08             	mov    0x8(%ebp),%eax
   17ef2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17ef8:	e9 98 01 00 00       	jmp    18095 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   17efd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17f00:	83 e0 02             	and    $0x2,%eax
   17f03:	85 c0                	test   %eax,%eax
   17f05:	74 0e                	je     17f15 <_DecodeDHT+0x68>
   17f07:	8b 45 08             	mov    0x8(%ebp),%eax
   17f0a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   17f10:	e9 80 01 00 00       	jmp    18095 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   17f15:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17f18:	c1 f8 03             	sar    $0x3,%eax
   17f1b:	0b 45 f4             	or     -0xc(%ebp),%eax
   17f1e:	83 e0 03             	and    $0x3,%eax
   17f21:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   17f24:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   17f2b:	eb 1c                	jmp    17f49 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   17f2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17f30:	8d 50 ff             	lea    -0x1(%eax),%edx
   17f33:	8b 45 08             	mov    0x8(%ebp),%eax
   17f36:	8b 48 04             	mov    0x4(%eax),%ecx
   17f39:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17f3c:	01 c8                	add    %ecx,%eax
   17f3e:	0f b6 00             	movzbl (%eax),%eax
   17f41:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   17f45:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   17f49:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   17f4d:	7e de                	jle    17f2d <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   17f4f:	83 ec 08             	sub    $0x8,%esp
   17f52:	6a 11                	push   $0x11
   17f54:	ff 75 08             	pushl  0x8(%ebp)
   17f57:	e8 66 f8 ff ff       	call   177c2 <_Skip>
   17f5c:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   17f5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17f62:	c1 e0 11             	shl    $0x11,%eax
   17f65:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   17f6b:	8b 45 08             	mov    0x8(%ebp),%eax
   17f6e:	01 d0                	add    %edx,%eax
   17f70:	83 c0 08             	add    $0x8,%eax
   17f73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   17f76:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   17f7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17f80:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   17f83:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   17f8a:	e9 be 00 00 00       	jmp    1804d <_DecodeDHT+0x1a0>
            spread >>= 1;
   17f8f:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   17f92:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17f95:	83 e8 01             	sub    $0x1,%eax
   17f98:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   17f9d:	0f b6 c0             	movzbl %al,%eax
   17fa0:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   17fa3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   17fa7:	0f 84 9b 00 00 00    	je     18048 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   17fad:	8b 45 08             	mov    0x8(%ebp),%eax
   17fb0:	8b 40 0c             	mov    0xc(%eax),%eax
   17fb3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   17fb6:	7d 0e                	jge    17fc6 <_DecodeDHT+0x119>
   17fb8:	8b 45 08             	mov    0x8(%ebp),%eax
   17fbb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17fc1:	e9 cf 00 00 00       	jmp    18095 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   17fc6:	b8 10 00 00 00       	mov    $0x10,%eax
   17fcb:	2b 45 f0             	sub    -0x10(%ebp),%eax
   17fce:	8b 55 e0             	mov    -0x20(%ebp),%edx
   17fd1:	89 c1                	mov    %eax,%ecx
   17fd3:	d3 e2                	shl    %cl,%edx
   17fd5:	89 d0                	mov    %edx,%eax
   17fd7:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   17fda:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   17fde:	79 0e                	jns    17fee <_DecodeDHT+0x141>
   17fe0:	8b 45 08             	mov    0x8(%ebp),%eax
   17fe3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   17fe9:	e9 a7 00 00 00       	jmp    18095 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   17fee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17ff5:	eb 36                	jmp    1802d <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   17ff7:	8b 45 08             	mov    0x8(%ebp),%eax
   17ffa:	8b 50 04             	mov    0x4(%eax),%edx
   17ffd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18000:	01 d0                	add    %edx,%eax
   18002:	0f b6 00             	movzbl (%eax),%eax
   18005:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   18007:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   1800a:	eb 14                	jmp    18020 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   1800c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1800f:	89 c2                	mov    %eax,%edx
   18011:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18014:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   18016:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18019:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   1801c:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   18020:	89 d8                	mov    %ebx,%eax
   18022:	8d 58 ff             	lea    -0x1(%eax),%ebx
   18025:	85 c0                	test   %eax,%eax
   18027:	75 e3                	jne    1800c <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   18029:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1802d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18030:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   18033:	7c c2                	jl     17ff7 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   18035:	83 ec 08             	sub    $0x8,%esp
   18038:	ff 75 e0             	pushl  -0x20(%ebp)
   1803b:	ff 75 08             	pushl  0x8(%ebp)
   1803e:	e8 7f f7 ff ff       	call   177c2 <_Skip>
   18043:	83 c4 10             	add    $0x10,%esp
   18046:	eb 01                	jmp    18049 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   18048:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   18049:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1804d:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   18051:	0f 8e 38 ff ff ff    	jle    17f8f <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   18057:	eb 0a                	jmp    18063 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   18059:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1805c:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   1805f:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   18063:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18066:	8d 50 ff             	lea    -0x1(%eax),%edx
   18069:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1806c:	85 c0                	test   %eax,%eax
   1806e:	75 e9                	jne    18059 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   18070:	8b 45 08             	mov    0x8(%ebp),%eax
   18073:	8b 40 0c             	mov    0xc(%eax),%eax
   18076:	83 f8 10             	cmp    $0x10,%eax
   18079:	0f 8f 55 fe ff ff    	jg     17ed4 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1807f:	8b 45 08             	mov    0x8(%ebp),%eax
   18082:	8b 40 0c             	mov    0xc(%eax),%eax
   18085:	85 c0                	test   %eax,%eax
   18087:	74 0c                	je     18095 <_DecodeDHT+0x1e8>
   18089:	8b 45 08             	mov    0x8(%ebp),%eax
   1808c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   18092:	eb 01                	jmp    18095 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   18094:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   18095:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   18098:	c9                   	leave  
   18099:	c3                   	ret    

0001809a <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   1809a:	55                   	push   %ebp
   1809b:	89 e5                	mov    %esp,%ebp
   1809d:	53                   	push   %ebx
   1809e:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   180a1:	83 ec 0c             	sub    $0xc,%esp
   180a4:	ff 75 08             	pushl  0x8(%ebp)
   180a7:	e8 62 f7 ff ff       	call   1780e <_DecodeLength>
   180ac:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   180af:	8b 45 08             	mov    0x8(%ebp),%eax
   180b2:	8b 00                	mov    (%eax),%eax
   180b4:	85 c0                	test   %eax,%eax
   180b6:	0f 85 e2 00 00 00    	jne    1819e <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   180bc:	e9 b8 00 00 00       	jmp    18179 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   180c1:	8b 45 08             	mov    0x8(%ebp),%eax
   180c4:	8b 40 04             	mov    0x4(%eax),%eax
   180c7:	0f b6 00             	movzbl (%eax),%eax
   180ca:	0f b6 c0             	movzbl %al,%eax
   180cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   180d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   180d3:	25 ec 00 00 00       	and    $0xec,%eax
   180d8:	85 c0                	test   %eax,%eax
   180da:	74 0e                	je     180ea <_DecodeDQT+0x50>
   180dc:	8b 45 08             	mov    0x8(%ebp),%eax
   180df:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   180e5:	e9 b5 00 00 00       	jmp    1819f <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   180ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   180ed:	83 e0 10             	and    $0x10,%eax
   180f0:	85 c0                	test   %eax,%eax
   180f2:	74 0e                	je     18102 <_DecodeDQT+0x68>
   180f4:	8b 45 08             	mov    0x8(%ebp),%eax
   180f7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   180fd:	e9 9d 00 00 00       	jmp    1819f <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   18102:	8b 45 08             	mov    0x8(%ebp),%eax
   18105:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   1810b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1810e:	bb 01 00 00 00       	mov    $0x1,%ebx
   18113:	89 c1                	mov    %eax,%ecx
   18115:	d3 e3                	shl    %cl,%ebx
   18117:	89 d8                	mov    %ebx,%eax
   18119:	09 c2                	or     %eax,%edx
   1811b:	8b 45 08             	mov    0x8(%ebp),%eax
   1811e:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   18124:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18127:	c1 e0 06             	shl    $0x6,%eax
   1812a:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   18130:	8b 45 08             	mov    0x8(%ebp),%eax
   18133:	01 d0                	add    %edx,%eax
   18135:	83 c0 08             	add    $0x8,%eax
   18138:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   1813b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   18142:	eb 1f                	jmp    18163 <_DecodeDQT+0xc9>
   18144:	8b 55 f4             	mov    -0xc(%ebp),%edx
   18147:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1814a:	01 c2                	add    %eax,%edx
   1814c:	8b 45 08             	mov    0x8(%ebp),%eax
   1814f:	8b 40 04             	mov    0x4(%eax),%eax
   18152:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   18155:	83 c1 01             	add    $0x1,%ecx
   18158:	01 c8                	add    %ecx,%eax
   1815a:	0f b6 00             	movzbl (%eax),%eax
   1815d:	88 02                	mov    %al,(%edx)
   1815f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   18163:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   18167:	7e db                	jle    18144 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   18169:	83 ec 08             	sub    $0x8,%esp
   1816c:	6a 41                	push   $0x41
   1816e:	ff 75 08             	pushl  0x8(%ebp)
   18171:	e8 4c f6 ff ff       	call   177c2 <_Skip>
   18176:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   18179:	8b 45 08             	mov    0x8(%ebp),%eax
   1817c:	8b 40 0c             	mov    0xc(%eax),%eax
   1817f:	83 f8 40             	cmp    $0x40,%eax
   18182:	0f 8f 39 ff ff ff    	jg     180c1 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   18188:	8b 45 08             	mov    0x8(%ebp),%eax
   1818b:	8b 40 0c             	mov    0xc(%eax),%eax
   1818e:	85 c0                	test   %eax,%eax
   18190:	74 0d                	je     1819f <_DecodeDQT+0x105>
   18192:	8b 45 08             	mov    0x8(%ebp),%eax
   18195:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1819b:	90                   	nop
   1819c:	eb 01                	jmp    1819f <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1819e:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1819f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   181a2:	c9                   	leave  
   181a3:	c3                   	ret    

000181a4 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   181a4:	55                   	push   %ebp
   181a5:	89 e5                	mov    %esp,%ebp
   181a7:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   181aa:	83 ec 0c             	sub    $0xc,%esp
   181ad:	ff 75 08             	pushl  0x8(%ebp)
   181b0:	e8 59 f6 ff ff       	call   1780e <_DecodeLength>
   181b5:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   181b8:	8b 45 08             	mov    0x8(%ebp),%eax
   181bb:	8b 00                	mov    (%eax),%eax
   181bd:	85 c0                	test   %eax,%eax
   181bf:	75 4a                	jne    1820b <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   181c1:	8b 45 08             	mov    0x8(%ebp),%eax
   181c4:	8b 40 0c             	mov    0xc(%eax),%eax
   181c7:	83 f8 01             	cmp    $0x1,%eax
   181ca:	7f 0b                	jg     181d7 <_DecodeDRI+0x33>
   181cc:	8b 45 08             	mov    0x8(%ebp),%eax
   181cf:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   181d5:	eb 35                	jmp    1820c <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   181d7:	8b 45 08             	mov    0x8(%ebp),%eax
   181da:	8b 40 04             	mov    0x4(%eax),%eax
   181dd:	83 ec 0c             	sub    $0xc,%esp
   181e0:	50                   	push   %eax
   181e1:	e8 8b f6 ff ff       	call   17871 <_Decode2Bytes>
   181e6:	83 c4 10             	add    $0x10,%esp
   181e9:	89 c2                	mov    %eax,%edx
   181eb:	8b 45 08             	mov    0x8(%ebp),%eax
   181ee:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   181f4:	8b 45 08             	mov    0x8(%ebp),%eax
   181f7:	8b 40 0c             	mov    0xc(%eax),%eax
   181fa:	83 ec 08             	sub    $0x8,%esp
   181fd:	50                   	push   %eax
   181fe:	ff 75 08             	pushl  0x8(%ebp)
   18201:	e8 bc f5 ff ff       	call   177c2 <_Skip>
   18206:	83 c4 10             	add    $0x10,%esp
   18209:	eb 01                	jmp    1820c <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   1820b:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   1820c:	c9                   	leave  
   1820d:	c3                   	ret    

0001820e <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   1820e:	55                   	push   %ebp
   1820f:	89 e5                	mov    %esp,%ebp
   18211:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   18214:	8b 45 08             	mov    0x8(%ebp),%eax
   18217:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   1821d:	89 45 e0             	mov    %eax,-0x20(%ebp)
   18220:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   18227:	83 ec 0c             	sub    $0xc,%esp
   1822a:	ff 75 08             	pushl  0x8(%ebp)
   1822d:	e8 dc f5 ff ff       	call   1780e <_DecodeLength>
   18232:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   18235:	8b 45 08             	mov    0x8(%ebp),%eax
   18238:	8b 00                	mov    (%eax),%eax
   1823a:	85 c0                	test   %eax,%eax
   1823c:	0f 85 c2 02 00 00    	jne    18504 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   18242:	8b 45 08             	mov    0x8(%ebp),%eax
   18245:	8b 50 0c             	mov    0xc(%eax),%edx
   18248:	8b 45 08             	mov    0x8(%ebp),%eax
   1824b:	8b 40 28             	mov    0x28(%eax),%eax
   1824e:	83 c0 02             	add    $0x2,%eax
   18251:	01 c0                	add    %eax,%eax
   18253:	39 c2                	cmp    %eax,%edx
   18255:	7c 16                	jl     1826d <_DecodeSOS+0x5f>
   18257:	8b 45 08             	mov    0x8(%ebp),%eax
   1825a:	8b 40 04             	mov    0x4(%eax),%eax
   1825d:	0f b6 00             	movzbl (%eax),%eax
   18260:	0f b6 d0             	movzbl %al,%edx
   18263:	8b 45 08             	mov    0x8(%ebp),%eax
   18266:	8b 40 28             	mov    0x28(%eax),%eax
   18269:	39 c2                	cmp    %eax,%edx
   1826b:	74 0e                	je     1827b <_DecodeSOS+0x6d>
   1826d:	8b 45 08             	mov    0x8(%ebp),%eax
   18270:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   18276:	e9 8d 02 00 00       	jmp    18508 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   1827b:	83 ec 08             	sub    $0x8,%esp
   1827e:	6a 01                	push   $0x1
   18280:	ff 75 08             	pushl  0x8(%ebp)
   18283:	e8 3a f5 ff ff       	call   177c2 <_Skip>
   18288:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1828b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   18292:	8b 45 08             	mov    0x8(%ebp),%eax
   18295:	83 c0 2c             	add    $0x2c,%eax
   18298:	89 45 dc             	mov    %eax,-0x24(%ebp)
   1829b:	e9 ba 00 00 00       	jmp    1835a <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   182a0:	8b 45 08             	mov    0x8(%ebp),%eax
   182a3:	8b 40 04             	mov    0x4(%eax),%eax
   182a6:	0f b6 00             	movzbl (%eax),%eax
   182a9:	0f b6 d0             	movzbl %al,%edx
   182ac:	8b 45 dc             	mov    -0x24(%ebp),%eax
   182af:	8b 00                	mov    (%eax),%eax
   182b1:	39 c2                	cmp    %eax,%edx
   182b3:	74 0e                	je     182c3 <_DecodeSOS+0xb5>
   182b5:	8b 45 08             	mov    0x8(%ebp),%eax
   182b8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   182be:	e9 45 02 00 00       	jmp    18508 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   182c3:	8b 45 08             	mov    0x8(%ebp),%eax
   182c6:	8b 40 04             	mov    0x4(%eax),%eax
   182c9:	83 c0 01             	add    $0x1,%eax
   182cc:	0f b6 00             	movzbl (%eax),%eax
   182cf:	0f b6 c0             	movzbl %al,%eax
   182d2:	25 ec 00 00 00       	and    $0xec,%eax
   182d7:	85 c0                	test   %eax,%eax
   182d9:	74 0e                	je     182e9 <_DecodeSOS+0xdb>
   182db:	8b 45 08             	mov    0x8(%ebp),%eax
   182de:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   182e4:	e9 1f 02 00 00       	jmp    18508 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   182e9:	8b 45 08             	mov    0x8(%ebp),%eax
   182ec:	8b 40 04             	mov    0x4(%eax),%eax
   182ef:	83 c0 01             	add    $0x1,%eax
   182f2:	0f b6 00             	movzbl (%eax),%eax
   182f5:	0f b6 c0             	movzbl %al,%eax
   182f8:	83 e0 02             	and    $0x2,%eax
   182fb:	85 c0                	test   %eax,%eax
   182fd:	74 0e                	je     1830d <_DecodeSOS+0xff>
   182ff:	8b 45 08             	mov    0x8(%ebp),%eax
   18302:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   18308:	e9 fb 01 00 00       	jmp    18508 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   1830d:	8b 45 08             	mov    0x8(%ebp),%eax
   18310:	8b 40 04             	mov    0x4(%eax),%eax
   18313:	83 c0 01             	add    $0x1,%eax
   18316:	0f b6 00             	movzbl (%eax),%eax
   18319:	c0 e8 04             	shr    $0x4,%al
   1831c:	0f b6 d0             	movzbl %al,%edx
   1831f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18322:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   18325:	8b 45 08             	mov    0x8(%ebp),%eax
   18328:	8b 40 04             	mov    0x4(%eax),%eax
   1832b:	83 c0 01             	add    $0x1,%eax
   1832e:	0f b6 00             	movzbl (%eax),%eax
   18331:	0f b6 c0             	movzbl %al,%eax
   18334:	83 e0 01             	and    $0x1,%eax
   18337:	83 c8 02             	or     $0x2,%eax
   1833a:	89 c2                	mov    %eax,%edx
   1833c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1833f:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   18342:	83 ec 08             	sub    $0x8,%esp
   18345:	6a 02                	push   $0x2
   18347:	ff 75 08             	pushl  0x8(%ebp)
   1834a:	e8 73 f4 ff ff       	call   177c2 <_Skip>
   1834f:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   18352:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   18356:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1835a:	8b 45 08             	mov    0x8(%ebp),%eax
   1835d:	8b 40 28             	mov    0x28(%eax),%eax
   18360:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   18363:	0f 8f 37 ff ff ff    	jg     182a0 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   18369:	8b 45 08             	mov    0x8(%ebp),%eax
   1836c:	8b 40 04             	mov    0x4(%eax),%eax
   1836f:	0f b6 00             	movzbl (%eax),%eax
   18372:	84 c0                	test   %al,%al
   18374:	75 10                	jne    18386 <_DecodeSOS+0x178>
   18376:	8b 45 08             	mov    0x8(%ebp),%eax
   18379:	8b 40 04             	mov    0x4(%eax),%eax
   1837c:	83 c0 01             	add    $0x1,%eax
   1837f:	0f b6 00             	movzbl (%eax),%eax
   18382:	3c 3f                	cmp    $0x3f,%al
   18384:	74 0e                	je     18394 <_DecodeSOS+0x186>
   18386:	8b 45 08             	mov    0x8(%ebp),%eax
   18389:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1838f:	e9 74 01 00 00       	jmp    18508 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   18394:	8b 45 08             	mov    0x8(%ebp),%eax
   18397:	8b 40 04             	mov    0x4(%eax),%eax
   1839a:	83 c0 02             	add    $0x2,%eax
   1839d:	0f b6 00             	movzbl (%eax),%eax
   183a0:	84 c0                	test   %al,%al
   183a2:	74 0e                	je     183b2 <_DecodeSOS+0x1a4>
   183a4:	8b 45 08             	mov    0x8(%ebp),%eax
   183a7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   183ad:	e9 56 01 00 00       	jmp    18508 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   183b2:	8b 45 08             	mov    0x8(%ebp),%eax
   183b5:	8b 40 0c             	mov    0xc(%eax),%eax
   183b8:	83 ec 08             	sub    $0x8,%esp
   183bb:	50                   	push   %eax
   183bc:	ff 75 08             	pushl  0x8(%ebp)
   183bf:	e8 fe f3 ff ff       	call   177c2 <_Skip>
   183c4:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   183c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   183ce:	e9 17 01 00 00       	jmp    184ea <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   183d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   183da:	e9 f8 00 00 00       	jmp    184d7 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   183df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   183e6:	8b 45 08             	mov    0x8(%ebp),%eax
   183e9:	83 c0 2c             	add    $0x2c,%eax
   183ec:	89 45 dc             	mov    %eax,-0x24(%ebp)
   183ef:	e9 8d 00 00 00       	jmp    18481 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   183f4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   183fb:	eb 71                	jmp    1846e <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   183fd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   18404:	eb 59                	jmp    1845f <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   18406:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18409:	8b 50 28             	mov    0x28(%eax),%edx
   1840c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1840f:	8b 40 08             	mov    0x8(%eax),%eax
   18412:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   18416:	89 c1                	mov    %eax,%ecx
   18418:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1841b:	01 c1                	add    %eax,%ecx
   1841d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18420:	8b 40 14             	mov    0x14(%eax),%eax
   18423:	0f af c8             	imul   %eax,%ecx
   18426:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18429:	8b 40 04             	mov    0x4(%eax),%eax
   1842c:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   18430:	01 c1                	add    %eax,%ecx
   18432:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18435:	01 c8                	add    %ecx,%eax
   18437:	c1 e0 03             	shl    $0x3,%eax
   1843a:	01 d0                	add    %edx,%eax
   1843c:	50                   	push   %eax
   1843d:	ff 75 dc             	pushl  -0x24(%ebp)
   18440:	ff 75 0c             	pushl  0xc(%ebp)
   18443:	ff 75 08             	pushl  0x8(%ebp)
   18446:	e8 bf 00 00 00       	call   1850a <_DecodeBlock>
   1844b:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   1844e:	8b 45 08             	mov    0x8(%ebp),%eax
   18451:	8b 00                	mov    (%eax),%eax
   18453:	85 c0                	test   %eax,%eax
   18455:	0f 85 ac 00 00 00    	jne    18507 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   1845b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1845f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18462:	8b 40 04             	mov    0x4(%eax),%eax
   18465:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   18468:	7f 9c                	jg     18406 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   1846a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1846e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18471:	8b 40 08             	mov    0x8(%eax),%eax
   18474:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   18477:	7f 84                	jg     183fd <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   18479:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1847d:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   18481:	8b 45 08             	mov    0x8(%ebp),%eax
   18484:	8b 40 28             	mov    0x28(%eax),%eax
   18487:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1848a:	0f 8f 64 ff ff ff    	jg     183f4 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   18490:	8b 45 08             	mov    0x8(%ebp),%eax
   18493:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   18499:	85 c0                	test   %eax,%eax
   1849b:	74 36                	je     184d3 <_DecodeSOS+0x2c5>
   1849d:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   184a1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   184a5:	75 2c                	jne    184d3 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   184a7:	83 ec 0c             	sub    $0xc,%esp
   184aa:	ff 75 08             	pushl  0x8(%ebp)
   184ad:	e8 9f 0a 00 00       	call   18f51 <_ByteAlign>
   184b2:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   184b5:	83 ec 08             	sub    $0x8,%esp
   184b8:	6a 10                	push   $0x10
   184ba:	ff 75 08             	pushl  0x8(%ebp)
   184bd:	e8 ce 04 00 00       	call   18990 <_GetBits>
   184c2:	83 c4 10             	add    $0x10,%esp
   184c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   184c8:	8b 45 08             	mov    0x8(%ebp),%eax
   184cb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   184d1:	eb 35                	jmp    18508 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   184d3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   184d7:	8b 45 08             	mov    0x8(%ebp),%eax
   184da:	8b 40 18             	mov    0x18(%eax),%eax
   184dd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   184e0:	0f 8f f9 fe ff ff    	jg     183df <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   184e6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   184ea:	8b 45 08             	mov    0x8(%ebp),%eax
   184ed:	8b 40 1c             	mov    0x1c(%eax),%eax
   184f0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   184f3:	0f 8f da fe ff ff    	jg     183d3 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   184f9:	8b 45 08             	mov    0x8(%ebp),%eax
   184fc:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   18502:	eb 04                	jmp    18508 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   18504:	90                   	nop
   18505:	eb 01                	jmp    18508 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   18507:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   18508:	c9                   	leave  
   18509:	c3                   	ret    

0001850a <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   1850a:	55                   	push   %ebp
   1850b:	89 e5                	mov    %esp,%ebp
   1850d:	53                   	push   %ebx
   1850e:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   18511:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   18518:	8b 45 08             	mov    0x8(%ebp),%eax
   1851b:	05 c0 01 08 00       	add    $0x801c0,%eax
   18520:	83 ec 04             	sub    $0x4,%esp
   18523:	68 00 01 00 00       	push   $0x100
   18528:	6a 00                	push   $0x0
   1852a:	50                   	push   %eax
   1852b:	e8 04 b8 fe ff       	call   3d34 <memset>
   18530:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   18533:	8b 45 10             	mov    0x10(%ebp),%eax
   18536:	8b 40 20             	mov    0x20(%eax),%eax
   18539:	c1 e0 11             	shl    $0x11,%eax
   1853c:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   18542:	8b 45 08             	mov    0x8(%ebp),%eax
   18545:	01 d0                	add    %edx,%eax
   18547:	83 c0 08             	add    $0x8,%eax
   1854a:	83 ec 04             	sub    $0x4,%esp
   1854d:	6a 00                	push   $0x0
   1854f:	50                   	push   %eax
   18550:	ff 75 08             	pushl  0x8(%ebp)
   18553:	e8 86 01 00 00       	call   186de <_GetVLC>
   18558:	83 c4 10             	add    $0x10,%esp
   1855b:	89 c2                	mov    %eax,%edx
   1855d:	8b 45 10             	mov    0x10(%ebp),%eax
   18560:	8b 40 24             	mov    0x24(%eax),%eax
   18563:	01 c2                	add    %eax,%edx
   18565:	8b 45 10             	mov    0x10(%ebp),%eax
   18568:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   1856b:	8b 45 10             	mov    0x10(%ebp),%eax
   1856e:	8b 50 24             	mov    0x24(%eax),%edx
   18571:	8b 45 10             	mov    0x10(%ebp),%eax
   18574:	8b 48 18             	mov    0x18(%eax),%ecx
   18577:	8b 45 08             	mov    0x8(%ebp),%eax
   1857a:	c1 e1 06             	shl    $0x6,%ecx
   1857d:	01 c8                	add    %ecx,%eax
   1857f:	05 b8 00 00 00       	add    $0xb8,%eax
   18584:	0f b6 00             	movzbl (%eax),%eax
   18587:	0f b6 c0             	movzbl %al,%eax
   1858a:	0f af d0             	imul   %eax,%edx
   1858d:	8b 45 08             	mov    0x8(%ebp),%eax
   18590:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   18596:	8b 45 10             	mov    0x10(%ebp),%eax
   18599:	8b 40 1c             	mov    0x1c(%eax),%eax
   1859c:	c1 e0 11             	shl    $0x11,%eax
   1859f:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   185a5:	8b 45 08             	mov    0x8(%ebp),%eax
   185a8:	01 d0                	add    %edx,%eax
   185aa:	8d 50 08             	lea    0x8(%eax),%edx
   185ad:	83 ec 04             	sub    $0x4,%esp
   185b0:	8d 45 ef             	lea    -0x11(%ebp),%eax
   185b3:	50                   	push   %eax
   185b4:	52                   	push   %edx
   185b5:	ff 75 08             	pushl  0x8(%ebp)
   185b8:	e8 21 01 00 00       	call   186de <_GetVLC>
   185bd:	83 c4 10             	add    $0x10,%esp
   185c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   185c3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   185c7:	84 c0                	test   %al,%al
   185c9:	0f 84 92 00 00 00    	je     18661 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   185cf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   185d3:	0f b6 c0             	movzbl %al,%eax
   185d6:	83 e0 0f             	and    $0xf,%eax
   185d9:	85 c0                	test   %eax,%eax
   185db:	75 16                	jne    185f3 <_DecodeBlock+0xe9>
   185dd:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   185e1:	3c f0                	cmp    $0xf0,%al
   185e3:	74 0e                	je     185f3 <_DecodeBlock+0xe9>
   185e5:	8b 45 08             	mov    0x8(%ebp),%eax
   185e8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   185ee:	e9 e6 00 00 00       	jmp    186d9 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   185f3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   185f7:	c0 e8 04             	shr    $0x4,%al
   185fa:	0f b6 c0             	movzbl %al,%eax
   185fd:	83 c0 01             	add    $0x1,%eax
   18600:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   18603:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   18607:	7e 0e                	jle    18617 <_DecodeBlock+0x10d>
   18609:	8b 45 08             	mov    0x8(%ebp),%eax
   1860c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   18612:	e9 c2 00 00 00       	jmp    186d9 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   18617:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1861a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1861d:	01 d0                	add    %edx,%eax
   1861f:	0f b6 00             	movzbl (%eax),%eax
   18622:	0f be c8             	movsbl %al,%ecx
   18625:	8b 45 10             	mov    0x10(%ebp),%eax
   18628:	8b 50 18             	mov    0x18(%eax),%edx
   1862b:	8b 45 08             	mov    0x8(%ebp),%eax
   1862e:	c1 e2 06             	shl    $0x6,%edx
   18631:	01 c2                	add    %eax,%edx
   18633:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18636:	01 d0                	add    %edx,%eax
   18638:	05 b8 00 00 00       	add    $0xb8,%eax
   1863d:	0f b6 00             	movzbl (%eax),%eax
   18640:	0f b6 c0             	movzbl %al,%eax
   18643:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   18647:	89 c2                	mov    %eax,%edx
   18649:	8b 45 08             	mov    0x8(%ebp),%eax
   1864c:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   18652:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   18655:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   18659:	0f 8e 37 ff ff ff    	jle    18596 <_DecodeBlock+0x8c>
   1865f:	eb 01                	jmp    18662 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   18661:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   18662:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   18669:	eb 24                	jmp    1868f <_DecodeBlock+0x185>
   1866b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1866e:	05 70 00 02 00       	add    $0x20070,%eax
   18673:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1867a:	8b 45 08             	mov    0x8(%ebp),%eax
   1867d:	01 d0                	add    %edx,%eax
   1867f:	83 ec 0c             	sub    $0xc,%esp
   18682:	50                   	push   %eax
   18683:	e8 32 03 00 00       	call   189ba <_RowIDCT>
   18688:	83 c4 10             	add    $0x10,%esp
   1868b:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   1868f:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   18693:	7e d6                	jle    1866b <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   18695:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1869c:	eb 35                	jmp    186d3 <_DecodeBlock+0x1c9>
   1869e:	8b 45 10             	mov    0x10(%ebp),%eax
   186a1:	8b 40 14             	mov    0x14(%eax),%eax
   186a4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   186a7:	8b 55 14             	mov    0x14(%ebp),%edx
   186aa:	01 d1                	add    %edx,%ecx
   186ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
   186af:	81 c2 70 00 02 00    	add    $0x20070,%edx
   186b5:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   186bc:	8b 55 08             	mov    0x8(%ebp),%edx
   186bf:	01 da                	add    %ebx,%edx
   186c1:	83 ec 04             	sub    $0x4,%esp
   186c4:	50                   	push   %eax
   186c5:	51                   	push   %ecx
   186c6:	52                   	push   %edx
   186c7:	e8 7b 05 00 00       	call   18c47 <_ColIDCT>
   186cc:	83 c4 10             	add    $0x10,%esp
   186cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   186d3:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   186d7:	7e c5                	jle    1869e <_DecodeBlock+0x194>
}
   186d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   186dc:	c9                   	leave  
   186dd:	c3                   	ret    

000186de <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   186de:	55                   	push   %ebp
   186df:	89 e5                	mov    %esp,%ebp
   186e1:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   186e4:	83 ec 08             	sub    $0x8,%esp
   186e7:	6a 10                	push   $0x10
   186e9:	ff 75 08             	pushl  0x8(%ebp)
   186ec:	e8 c2 00 00 00       	call   187b3 <_ShowBits>
   186f1:	83 c4 10             	add    $0x10,%esp
   186f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   186f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   186fa:	8d 14 00             	lea    (%eax,%eax,1),%edx
   186fd:	8b 45 0c             	mov    0xc(%ebp),%eax
   18700:	01 d0                	add    %edx,%eax
   18702:	0f b6 00             	movzbl (%eax),%eax
   18705:	0f b6 c0             	movzbl %al,%eax
   18708:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   1870b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1870f:	75 13                	jne    18724 <_GetVLC+0x46>
   18711:	8b 45 08             	mov    0x8(%ebp),%eax
   18714:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1871a:	b8 00 00 00 00       	mov    $0x0,%eax
   1871f:	e9 8d 00 00 00       	jmp    187b1 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   18724:	83 ec 08             	sub    $0x8,%esp
   18727:	ff 75 f0             	pushl  -0x10(%ebp)
   1872a:	ff 75 08             	pushl  0x8(%ebp)
   1872d:	e8 25 02 00 00       	call   18957 <_SkipBits>
   18732:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   18735:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18738:	8d 14 00             	lea    (%eax,%eax,1),%edx
   1873b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1873e:	01 d0                	add    %edx,%eax
   18740:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   18744:	0f b6 c0             	movzbl %al,%eax
   18747:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   1874a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1874e:	74 0a                	je     1875a <_GetVLC+0x7c>
   18750:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18753:	89 c2                	mov    %eax,%edx
   18755:	8b 45 10             	mov    0x10(%ebp),%eax
   18758:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   1875a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1875d:	83 e0 0f             	and    $0xf,%eax
   18760:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   18763:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   18767:	75 07                	jne    18770 <_GetVLC+0x92>
   18769:	b8 00 00 00 00       	mov    $0x0,%eax
   1876e:	eb 41                	jmp    187b1 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   18770:	83 ec 08             	sub    $0x8,%esp
   18773:	ff 75 f0             	pushl  -0x10(%ebp)
   18776:	ff 75 08             	pushl  0x8(%ebp)
   18779:	e8 12 02 00 00       	call   18990 <_GetBits>
   1877e:	83 c4 10             	add    $0x10,%esp
   18781:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   18784:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18787:	83 e8 01             	sub    $0x1,%eax
   1878a:	ba 01 00 00 00       	mov    $0x1,%edx
   1878f:	89 c1                	mov    %eax,%ecx
   18791:	d3 e2                	shl    %cl,%edx
   18793:	89 d0                	mov    %edx,%eax
   18795:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   18798:	7e 14                	jle    187ae <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   1879a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1879d:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   187a2:	89 c1                	mov    %eax,%ecx
   187a4:	d3 e2                	shl    %cl,%edx
   187a6:	89 d0                	mov    %edx,%eax
   187a8:	83 c0 01             	add    $0x1,%eax
   187ab:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   187ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   187b1:	c9                   	leave  
   187b2:	c3                   	ret    

000187b3 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   187b3:	55                   	push   %ebp
   187b4:	89 e5                	mov    %esp,%ebp
   187b6:	53                   	push   %ebx
   187b7:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   187ba:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   187be:	0f 85 4f 01 00 00    	jne    18913 <_ShowBits+0x160>
   187c4:	b8 00 00 00 00       	mov    $0x0,%eax
   187c9:	e9 83 01 00 00       	jmp    18951 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   187ce:	8b 45 08             	mov    0x8(%ebp),%eax
   187d1:	8b 40 08             	mov    0x8(%eax),%eax
   187d4:	85 c0                	test   %eax,%eax
   187d6:	7f 33                	jg     1880b <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   187d8:	8b 45 08             	mov    0x8(%ebp),%eax
   187db:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   187e1:	c1 e0 08             	shl    $0x8,%eax
   187e4:	0c ff                	or     $0xff,%al
   187e6:	89 c2                	mov    %eax,%edx
   187e8:	8b 45 08             	mov    0x8(%ebp),%eax
   187eb:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   187f1:	8b 45 08             	mov    0x8(%ebp),%eax
   187f4:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   187fa:	8d 50 08             	lea    0x8(%eax),%edx
   187fd:	8b 45 08             	mov    0x8(%ebp),%eax
   18800:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   18806:	e9 08 01 00 00       	jmp    18913 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   1880b:	8b 45 08             	mov    0x8(%ebp),%eax
   1880e:	8b 40 04             	mov    0x4(%eax),%eax
   18811:	8d 48 01             	lea    0x1(%eax),%ecx
   18814:	8b 55 08             	mov    0x8(%ebp),%edx
   18817:	89 4a 04             	mov    %ecx,0x4(%edx)
   1881a:	0f b6 00             	movzbl (%eax),%eax
   1881d:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   18820:	8b 45 08             	mov    0x8(%ebp),%eax
   18823:	8b 40 08             	mov    0x8(%eax),%eax
   18826:	8d 50 ff             	lea    -0x1(%eax),%edx
   18829:	8b 45 08             	mov    0x8(%ebp),%eax
   1882c:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   1882f:	8b 45 08             	mov    0x8(%ebp),%eax
   18832:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   18838:	8d 50 08             	lea    0x8(%eax),%edx
   1883b:	8b 45 08             	mov    0x8(%ebp),%eax
   1883e:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   18844:	8b 45 08             	mov    0x8(%ebp),%eax
   18847:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   1884d:	c1 e0 08             	shl    $0x8,%eax
   18850:	89 c2                	mov    %eax,%edx
   18852:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   18856:	09 c2                	or     %eax,%edx
   18858:	8b 45 08             	mov    0x8(%ebp),%eax
   1885b:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   18861:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   18865:	0f 85 a8 00 00 00    	jne    18913 <_ShowBits+0x160>
            if(ctx->size){
   1886b:	8b 45 08             	mov    0x8(%ebp),%eax
   1886e:	8b 40 08             	mov    0x8(%eax),%eax
   18871:	85 c0                	test   %eax,%eax
   18873:	0f 84 91 00 00 00    	je     1890a <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   18879:	8b 45 08             	mov    0x8(%ebp),%eax
   1887c:	8b 40 04             	mov    0x4(%eax),%eax
   1887f:	8d 48 01             	lea    0x1(%eax),%ecx
   18882:	8b 55 08             	mov    0x8(%ebp),%edx
   18885:	89 4a 04             	mov    %ecx,0x4(%edx)
   18888:	0f b6 00             	movzbl (%eax),%eax
   1888b:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   1888e:	8b 45 08             	mov    0x8(%ebp),%eax
   18891:	8b 40 08             	mov    0x8(%eax),%eax
   18894:	8d 50 ff             	lea    -0x1(%eax),%edx
   18897:	8b 45 08             	mov    0x8(%ebp),%eax
   1889a:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   1889d:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   188a1:	85 c0                	test   %eax,%eax
   188a3:	74 62                	je     18907 <_ShowBits+0x154>
   188a5:	3d d9 00 00 00       	cmp    $0xd9,%eax
   188aa:	75 0c                	jne    188b8 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   188ac:	8b 45 08             	mov    0x8(%ebp),%eax
   188af:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   188b6:	eb 5b                	jmp    18913 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   188b8:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   188bc:	25 f8 00 00 00       	and    $0xf8,%eax
   188c1:	3d d0 00 00 00       	cmp    $0xd0,%eax
   188c6:	74 0b                	je     188d3 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   188c8:	8b 45 08             	mov    0x8(%ebp),%eax
   188cb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   188d1:	eb 40                	jmp    18913 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   188d3:	8b 45 08             	mov    0x8(%ebp),%eax
   188d6:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   188dc:	c1 e0 08             	shl    $0x8,%eax
   188df:	89 c2                	mov    %eax,%edx
   188e1:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   188e5:	09 c2                	or     %eax,%edx
   188e7:	8b 45 08             	mov    0x8(%ebp),%eax
   188ea:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   188f0:	8b 45 08             	mov    0x8(%ebp),%eax
   188f3:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   188f9:	8d 50 08             	lea    0x8(%eax),%edx
   188fc:	8b 45 08             	mov    0x8(%ebp),%eax
   188ff:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   18905:	eb 0c                	jmp    18913 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   18907:	90                   	nop
   18908:	eb 09                	jmp    18913 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   1890a:	8b 45 08             	mov    0x8(%ebp),%eax
   1890d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   18913:	8b 45 08             	mov    0x8(%ebp),%eax
   18916:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1891c:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1891f:	0f 8c a9 fe ff ff    	jl     187ce <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   18925:	8b 45 08             	mov    0x8(%ebp),%eax
   18928:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   1892e:	8b 45 08             	mov    0x8(%ebp),%eax
   18931:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   18937:	2b 45 0c             	sub    0xc(%ebp),%eax
   1893a:	89 c1                	mov    %eax,%ecx
   1893c:	d3 fa                	sar    %cl,%edx
   1893e:	8b 45 0c             	mov    0xc(%ebp),%eax
   18941:	bb 01 00 00 00       	mov    $0x1,%ebx
   18946:	89 c1                	mov    %eax,%ecx
   18948:	d3 e3                	shl    %cl,%ebx
   1894a:	89 d8                	mov    %ebx,%eax
   1894c:	83 e8 01             	sub    $0x1,%eax
   1894f:	21 d0                	and    %edx,%eax
}
   18951:	83 c4 10             	add    $0x10,%esp
   18954:	5b                   	pop    %ebx
   18955:	5d                   	pop    %ebp
   18956:	c3                   	ret    

00018957 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   18957:	55                   	push   %ebp
   18958:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   1895a:	8b 45 08             	mov    0x8(%ebp),%eax
   1895d:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   18963:	3b 45 0c             	cmp    0xc(%ebp),%eax
   18966:	7d 0e                	jge    18976 <_SkipBits+0x1f>
   18968:	ff 75 0c             	pushl  0xc(%ebp)
   1896b:	ff 75 08             	pushl  0x8(%ebp)
   1896e:	e8 40 fe ff ff       	call   187b3 <_ShowBits>
   18973:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   18976:	8b 45 08             	mov    0x8(%ebp),%eax
   18979:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1897f:	2b 45 0c             	sub    0xc(%ebp),%eax
   18982:	89 c2                	mov    %eax,%edx
   18984:	8b 45 08             	mov    0x8(%ebp),%eax
   18987:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1898d:	90                   	nop
   1898e:	c9                   	leave  
   1898f:	c3                   	ret    

00018990 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   18990:	55                   	push   %ebp
   18991:	89 e5                	mov    %esp,%ebp
   18993:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   18996:	ff 75 0c             	pushl  0xc(%ebp)
   18999:	ff 75 08             	pushl  0x8(%ebp)
   1899c:	e8 12 fe ff ff       	call   187b3 <_ShowBits>
   189a1:	83 c4 08             	add    $0x8,%esp
   189a4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   189a7:	ff 75 0c             	pushl  0xc(%ebp)
   189aa:	ff 75 08             	pushl  0x8(%ebp)
   189ad:	e8 a5 ff ff ff       	call   18957 <_SkipBits>
   189b2:	83 c4 08             	add    $0x8,%esp
    return res;
   189b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   189b8:	c9                   	leave  
   189b9:	c3                   	ret    

000189ba <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   189ba:	55                   	push   %ebp
   189bb:	89 e5                	mov    %esp,%ebp
   189bd:	57                   	push   %edi
   189be:	56                   	push   %esi
   189bf:	53                   	push   %ebx
   189c0:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   189c3:	8b 45 08             	mov    0x8(%ebp),%eax
   189c6:	83 c0 10             	add    $0x10,%eax
   189c9:	8b 00                	mov    (%eax),%eax
   189cb:	c1 e0 0b             	shl    $0xb,%eax
   189ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   189d1:	8b 45 08             	mov    0x8(%ebp),%eax
   189d4:	8b 40 18             	mov    0x18(%eax),%eax
   189d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
   189da:	8b 45 f0             	mov    -0x10(%ebp),%eax
   189dd:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   189e0:	8b 55 08             	mov    0x8(%ebp),%edx
   189e3:	8b 52 08             	mov    0x8(%edx),%edx
   189e6:	89 55 e8             	mov    %edx,-0x18(%ebp)
   189e9:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   189ec:	8b 55 08             	mov    0x8(%ebp),%edx
   189ef:	8b 52 04             	mov    0x4(%edx),%edx
   189f2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   189f5:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   189f8:	8b 55 08             	mov    0x8(%ebp),%edx
   189fb:	8b 52 1c             	mov    0x1c(%edx),%edx
   189fe:	89 55 e0             	mov    %edx,-0x20(%ebp)
   18a01:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   18a04:	8b 55 08             	mov    0x8(%ebp),%edx
   18a07:	8b 52 14             	mov    0x14(%edx),%edx
   18a0a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   18a0d:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   18a10:	8b 55 08             	mov    0x8(%ebp),%edx
   18a13:	8b 52 0c             	mov    0xc(%edx),%edx
   18a16:	89 55 d8             	mov    %edx,-0x28(%ebp)
   18a19:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   18a1c:	85 c0                	test   %eax,%eax
   18a1e:	75 68                	jne    18a88 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   18a20:	8b 45 08             	mov    0x8(%ebp),%eax
   18a23:	8d 48 04             	lea    0x4(%eax),%ecx
   18a26:	8b 45 08             	mov    0x8(%ebp),%eax
   18a29:	8d 58 08             	lea    0x8(%eax),%ebx
   18a2c:	8b 45 08             	mov    0x8(%ebp),%eax
   18a2f:	8d 70 0c             	lea    0xc(%eax),%esi
   18a32:	8b 45 08             	mov    0x8(%ebp),%eax
   18a35:	8d 78 10             	lea    0x10(%eax),%edi
   18a38:	8b 45 08             	mov    0x8(%ebp),%eax
   18a3b:	83 c0 14             	add    $0x14,%eax
   18a3e:	89 45 c0             	mov    %eax,-0x40(%ebp)
   18a41:	8b 45 08             	mov    0x8(%ebp),%eax
   18a44:	83 c0 18             	add    $0x18,%eax
   18a47:	89 45 bc             	mov    %eax,-0x44(%ebp)
   18a4a:	8b 45 08             	mov    0x8(%ebp),%eax
   18a4d:	8d 50 1c             	lea    0x1c(%eax),%edx
   18a50:	8b 45 08             	mov    0x8(%ebp),%eax
   18a53:	8b 00                	mov    (%eax),%eax
   18a55:	c1 e0 03             	shl    $0x3,%eax
   18a58:	89 02                	mov    %eax,(%edx)
   18a5a:	8b 02                	mov    (%edx),%eax
   18a5c:	8b 55 bc             	mov    -0x44(%ebp),%edx
   18a5f:	89 02                	mov    %eax,(%edx)
   18a61:	89 d0                	mov    %edx,%eax
   18a63:	8b 00                	mov    (%eax),%eax
   18a65:	8b 55 c0             	mov    -0x40(%ebp),%edx
   18a68:	89 02                	mov    %eax,(%edx)
   18a6a:	89 d0                	mov    %edx,%eax
   18a6c:	8b 00                	mov    (%eax),%eax
   18a6e:	89 07                	mov    %eax,(%edi)
   18a70:	8b 07                	mov    (%edi),%eax
   18a72:	89 06                	mov    %eax,(%esi)
   18a74:	8b 06                	mov    (%esi),%eax
   18a76:	89 03                	mov    %eax,(%ebx)
   18a78:	8b 03                	mov    (%ebx),%eax
   18a7a:	89 01                	mov    %eax,(%ecx)
   18a7c:	8b 11                	mov    (%ecx),%edx
   18a7e:	8b 45 08             	mov    0x8(%ebp),%eax
   18a81:	89 10                	mov    %edx,(%eax)
        return;
   18a83:	e9 b7 01 00 00       	jmp    18c3f <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   18a88:	8b 45 08             	mov    0x8(%ebp),%eax
   18a8b:	8b 00                	mov    (%eax),%eax
   18a8d:	c1 e0 0b             	shl    $0xb,%eax
   18a90:	83 e8 80             	sub    $0xffffff80,%eax
   18a93:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   18a96:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   18a99:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18a9c:	01 d0                	add    %edx,%eax
   18a9e:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   18aa4:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   18aa7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18aaa:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   18ab0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18ab3:	01 d0                	add    %edx,%eax
   18ab5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   18ab8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18abb:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   18ac1:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18ac4:	01 d0                	add    %edx,%eax
   18ac6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   18ac9:	8b 55 dc             	mov    -0x24(%ebp),%edx
   18acc:	8b 45 d8             	mov    -0x28(%ebp),%eax
   18acf:	01 d0                	add    %edx,%eax
   18ad1:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   18ad7:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   18ada:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18add:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   18ae3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18ae6:	01 d0                	add    %edx,%eax
   18ae8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   18aeb:	8b 45 d8             	mov    -0x28(%ebp),%eax
   18aee:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   18af4:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18af7:	01 d0                	add    %edx,%eax
   18af9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   18afc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   18aff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18b02:	01 d0                	add    %edx,%eax
   18b04:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   18b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18b0a:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   18b0d:	8b 55 e8             	mov    -0x18(%ebp),%edx
   18b10:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18b13:	01 d0                	add    %edx,%eax
   18b15:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   18b1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   18b1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18b21:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   18b27:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18b2a:	01 d0                	add    %edx,%eax
   18b2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   18b2f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18b32:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   18b38:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18b3b:	01 d0                	add    %edx,%eax
   18b3d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   18b40:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   18b43:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18b46:	01 d0                	add    %edx,%eax
   18b48:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   18b4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18b4e:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   18b51:	8b 55 e0             	mov    -0x20(%ebp),%edx
   18b54:	8b 45 d8             	mov    -0x28(%ebp),%eax
   18b57:	01 d0                	add    %edx,%eax
   18b59:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   18b5c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   18b5f:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   18b62:	8b 55 d0             	mov    -0x30(%ebp),%edx
   18b65:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18b68:	01 d0                	add    %edx,%eax
   18b6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   18b6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18b70:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   18b73:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   18b76:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18b79:	01 d0                	add    %edx,%eax
   18b7b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   18b7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18b81:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   18b84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   18b87:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18b8a:	01 d0                	add    %edx,%eax
   18b8c:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   18b92:	83 e8 80             	sub    $0xffffff80,%eax
   18b95:	c1 f8 08             	sar    $0x8,%eax
   18b98:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   18b9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18b9e:	2b 45 e0             	sub    -0x20(%ebp),%eax
   18ba1:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   18ba7:	83 e8 80             	sub    $0xffffff80,%eax
   18baa:	c1 f8 08             	sar    $0x8,%eax
   18bad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   18bb0:	8b 55 d8             	mov    -0x28(%ebp),%edx
   18bb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18bb6:	01 d0                	add    %edx,%eax
   18bb8:	c1 f8 08             	sar    $0x8,%eax
   18bbb:	89 c2                	mov    %eax,%edx
   18bbd:	8b 45 08             	mov    0x8(%ebp),%eax
   18bc0:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   18bc2:	8b 45 08             	mov    0x8(%ebp),%eax
   18bc5:	83 c0 04             	add    $0x4,%eax
   18bc8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   18bcb:	8b 55 ec             	mov    -0x14(%ebp),%edx
   18bce:	01 ca                	add    %ecx,%edx
   18bd0:	c1 fa 08             	sar    $0x8,%edx
   18bd3:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   18bd5:	8b 45 08             	mov    0x8(%ebp),%eax
   18bd8:	83 c0 08             	add    $0x8,%eax
   18bdb:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   18bde:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   18be1:	01 ca                	add    %ecx,%edx
   18be3:	c1 fa 08             	sar    $0x8,%edx
   18be6:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   18be8:	8b 45 08             	mov    0x8(%ebp),%eax
   18beb:	83 c0 0c             	add    $0xc,%eax
   18bee:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   18bf1:	8b 55 dc             	mov    -0x24(%ebp),%edx
   18bf4:	01 ca                	add    %ecx,%edx
   18bf6:	c1 fa 08             	sar    $0x8,%edx
   18bf9:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   18bfb:	8b 45 08             	mov    0x8(%ebp),%eax
   18bfe:	8d 50 10             	lea    0x10(%eax),%edx
   18c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
   18c04:	2b 45 dc             	sub    -0x24(%ebp),%eax
   18c07:	c1 f8 08             	sar    $0x8,%eax
   18c0a:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   18c0c:	8b 45 08             	mov    0x8(%ebp),%eax
   18c0f:	8d 50 14             	lea    0x14(%eax),%edx
   18c12:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   18c15:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   18c18:	c1 f8 08             	sar    $0x8,%eax
   18c1b:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   18c1d:	8b 45 08             	mov    0x8(%ebp),%eax
   18c20:	8d 50 18             	lea    0x18(%eax),%edx
   18c23:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18c26:	2b 45 ec             	sub    -0x14(%ebp),%eax
   18c29:	c1 f8 08             	sar    $0x8,%eax
   18c2c:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   18c2e:	8b 45 08             	mov    0x8(%ebp),%eax
   18c31:	8d 50 1c             	lea    0x1c(%eax),%edx
   18c34:	8b 45 d8             	mov    -0x28(%ebp),%eax
   18c37:	2b 45 f0             	sub    -0x10(%ebp),%eax
   18c3a:	c1 f8 08             	sar    $0x8,%eax
   18c3d:	89 02                	mov    %eax,(%edx)
}
   18c3f:	83 c4 38             	add    $0x38,%esp
   18c42:	5b                   	pop    %ebx
   18c43:	5e                   	pop    %esi
   18c44:	5f                   	pop    %edi
   18c45:	5d                   	pop    %ebp
   18c46:	c3                   	ret    

00018c47 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   18c47:	55                   	push   %ebp
   18c48:	89 e5                	mov    %esp,%ebp
   18c4a:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   18c4d:	8b 45 08             	mov    0x8(%ebp),%eax
   18c50:	83 e8 80             	sub    $0xffffff80,%eax
   18c53:	8b 00                	mov    (%eax),%eax
   18c55:	c1 e0 08             	shl    $0x8,%eax
   18c58:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   18c5b:	8b 45 08             	mov    0x8(%ebp),%eax
   18c5e:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   18c64:	89 45 f4             	mov    %eax,-0xc(%ebp)
   18c67:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18c6a:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   18c6d:	8b 55 08             	mov    0x8(%ebp),%edx
   18c70:	8b 52 40             	mov    0x40(%edx),%edx
   18c73:	89 55 f0             	mov    %edx,-0x10(%ebp)
   18c76:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   18c79:	8b 55 08             	mov    0x8(%ebp),%edx
   18c7c:	8b 52 20             	mov    0x20(%edx),%edx
   18c7f:	89 55 ec             	mov    %edx,-0x14(%ebp)
   18c82:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   18c85:	8b 55 08             	mov    0x8(%ebp),%edx
   18c88:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   18c8e:	89 55 e8             	mov    %edx,-0x18(%ebp)
   18c91:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   18c94:	8b 55 08             	mov    0x8(%ebp),%edx
   18c97:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   18c9d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   18ca0:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   18ca3:	8b 55 08             	mov    0x8(%ebp),%edx
   18ca6:	8b 52 60             	mov    0x60(%edx),%edx
   18ca9:	89 55 e0             	mov    %edx,-0x20(%ebp)
   18cac:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   18caf:	85 c0                	test   %eax,%eax
   18cb1:	75 45                	jne    18cf8 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   18cb3:	8b 45 08             	mov    0x8(%ebp),%eax
   18cb6:	8b 00                	mov    (%eax),%eax
   18cb8:	83 c0 20             	add    $0x20,%eax
   18cbb:	c1 f8 06             	sar    $0x6,%eax
   18cbe:	83 e8 80             	sub    $0xffffff80,%eax
   18cc1:	50                   	push   %eax
   18cc2:	e8 d6 ea ff ff       	call   1779d <_Clip>
   18cc7:	83 c4 04             	add    $0x4,%esp
   18cca:	0f b6 c0             	movzbl %al,%eax
   18ccd:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   18cd0:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   18cd7:	eb 14                	jmp    18ced <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   18cd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18cdc:	89 c2                	mov    %eax,%edx
   18cde:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ce1:	88 10                	mov    %dl,(%eax)
            out += stride;
   18ce3:	8b 45 10             	mov    0x10(%ebp),%eax
   18ce6:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   18ce9:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   18ced:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   18cf1:	75 e6                	jne    18cd9 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   18cf3:	e9 57 02 00 00       	jmp    18f4f <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   18cf8:	8b 45 08             	mov    0x8(%ebp),%eax
   18cfb:	8b 00                	mov    (%eax),%eax
   18cfd:	c1 e0 08             	shl    $0x8,%eax
   18d00:	05 00 20 00 00       	add    $0x2000,%eax
   18d05:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   18d08:	8b 55 ec             	mov    -0x14(%ebp),%edx
   18d0b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18d0e:	01 d0                	add    %edx,%eax
   18d10:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   18d16:	83 c0 04             	add    $0x4,%eax
   18d19:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   18d1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18d1f:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   18d25:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18d28:	01 d0                	add    %edx,%eax
   18d2a:	c1 f8 03             	sar    $0x3,%eax
   18d2d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   18d30:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18d33:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   18d39:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18d3c:	01 d0                	add    %edx,%eax
   18d3e:	c1 f8 03             	sar    $0x3,%eax
   18d41:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   18d44:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   18d47:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18d4a:	01 d0                	add    %edx,%eax
   18d4c:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   18d52:	83 c0 04             	add    $0x4,%eax
   18d55:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   18d58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18d5b:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   18d61:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18d64:	01 d0                	add    %edx,%eax
   18d66:	c1 f8 03             	sar    $0x3,%eax
   18d69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   18d6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18d6f:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   18d75:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18d78:	01 d0                	add    %edx,%eax
   18d7a:	c1 f8 03             	sar    $0x3,%eax
   18d7d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   18d80:	8b 55 fc             	mov    -0x4(%ebp),%edx
   18d83:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18d86:	01 d0                	add    %edx,%eax
   18d88:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   18d8b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18d8e:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   18d91:	8b 55 f0             	mov    -0x10(%ebp),%edx
   18d94:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18d97:	01 d0                	add    %edx,%eax
   18d99:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   18d9f:	83 c0 04             	add    $0x4,%eax
   18da2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   18da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18da8:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   18dae:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18db1:	01 d0                	add    %edx,%eax
   18db3:	c1 f8 03             	sar    $0x3,%eax
   18db6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   18db9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18dbc:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   18dc2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18dc5:	01 d0                	add    %edx,%eax
   18dc7:	c1 f8 03             	sar    $0x3,%eax
   18dca:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   18dcd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   18dd0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18dd3:	01 d0                	add    %edx,%eax
   18dd5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   18dd8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18ddb:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   18dde:	8b 55 e8             	mov    -0x18(%ebp),%edx
   18de1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18de4:	01 d0                	add    %edx,%eax
   18de6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   18de9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18dec:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   18def:	8b 55 dc             	mov    -0x24(%ebp),%edx
   18df2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18df5:	01 d0                	add    %edx,%eax
   18df7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   18dfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18dfd:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   18e00:	8b 55 fc             	mov    -0x4(%ebp),%edx
   18e03:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18e06:	01 d0                	add    %edx,%eax
   18e08:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   18e0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18e0e:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   18e11:	8b 55 ec             	mov    -0x14(%ebp),%edx
   18e14:	8b 45 e8             	mov    -0x18(%ebp),%eax
   18e17:	01 d0                	add    %edx,%eax
   18e19:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   18e1f:	83 e8 80             	sub    $0xffffff80,%eax
   18e22:	c1 f8 08             	sar    $0x8,%eax
   18e25:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   18e28:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18e2b:	2b 45 e8             	sub    -0x18(%ebp),%eax
   18e2e:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   18e34:	83 e8 80             	sub    $0xffffff80,%eax
   18e37:	c1 f8 08             	sar    $0x8,%eax
   18e3a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   18e3d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   18e40:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18e43:	01 d0                	add    %edx,%eax
   18e45:	c1 f8 0e             	sar    $0xe,%eax
   18e48:	83 e8 80             	sub    $0xffffff80,%eax
   18e4b:	50                   	push   %eax
   18e4c:	e8 4c e9 ff ff       	call   1779d <_Clip>
   18e51:	83 c4 04             	add    $0x4,%esp
   18e54:	89 c2                	mov    %eax,%edx
   18e56:	8b 45 0c             	mov    0xc(%ebp),%eax
   18e59:	88 10                	mov    %dl,(%eax)
   18e5b:	8b 45 10             	mov    0x10(%ebp),%eax
   18e5e:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   18e61:	8b 55 f0             	mov    -0x10(%ebp),%edx
   18e64:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18e67:	01 d0                	add    %edx,%eax
   18e69:	c1 f8 0e             	sar    $0xe,%eax
   18e6c:	83 e8 80             	sub    $0xffffff80,%eax
   18e6f:	50                   	push   %eax
   18e70:	e8 28 e9 ff ff       	call   1779d <_Clip>
   18e75:	83 c4 04             	add    $0x4,%esp
   18e78:	89 c2                	mov    %eax,%edx
   18e7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   18e7d:	88 10                	mov    %dl,(%eax)
   18e7f:	8b 45 10             	mov    0x10(%ebp),%eax
   18e82:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   18e85:	8b 55 fc             	mov    -0x4(%ebp),%edx
   18e88:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18e8b:	01 d0                	add    %edx,%eax
   18e8d:	c1 f8 0e             	sar    $0xe,%eax
   18e90:	83 e8 80             	sub    $0xffffff80,%eax
   18e93:	50                   	push   %eax
   18e94:	e8 04 e9 ff ff       	call   1779d <_Clip>
   18e99:	83 c4 04             	add    $0x4,%esp
   18e9c:	89 c2                	mov    %eax,%edx
   18e9e:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ea1:	88 10                	mov    %dl,(%eax)
   18ea3:	8b 45 10             	mov    0x10(%ebp),%eax
   18ea6:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   18ea9:	8b 55 dc             	mov    -0x24(%ebp),%edx
   18eac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   18eaf:	01 d0                	add    %edx,%eax
   18eb1:	c1 f8 0e             	sar    $0xe,%eax
   18eb4:	83 e8 80             	sub    $0xffffff80,%eax
   18eb7:	50                   	push   %eax
   18eb8:	e8 e0 e8 ff ff       	call   1779d <_Clip>
   18ebd:	83 c4 04             	add    $0x4,%esp
   18ec0:	89 c2                	mov    %eax,%edx
   18ec2:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ec5:	88 10                	mov    %dl,(%eax)
   18ec7:	8b 45 10             	mov    0x10(%ebp),%eax
   18eca:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   18ecd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   18ed0:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   18ed3:	c1 f8 0e             	sar    $0xe,%eax
   18ed6:	83 e8 80             	sub    $0xffffff80,%eax
   18ed9:	50                   	push   %eax
   18eda:	e8 be e8 ff ff       	call   1779d <_Clip>
   18edf:	83 c4 04             	add    $0x4,%esp
   18ee2:	89 c2                	mov    %eax,%edx
   18ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ee7:	88 10                	mov    %dl,(%eax)
   18ee9:	8b 45 10             	mov    0x10(%ebp),%eax
   18eec:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   18eef:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18ef2:	2b 45 ec             	sub    -0x14(%ebp),%eax
   18ef5:	c1 f8 0e             	sar    $0xe,%eax
   18ef8:	83 e8 80             	sub    $0xffffff80,%eax
   18efb:	50                   	push   %eax
   18efc:	e8 9c e8 ff ff       	call   1779d <_Clip>
   18f01:	83 c4 04             	add    $0x4,%esp
   18f04:	89 c2                	mov    %eax,%edx
   18f06:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f09:	88 10                	mov    %dl,(%eax)
   18f0b:	8b 45 10             	mov    0x10(%ebp),%eax
   18f0e:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   18f11:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18f14:	2b 45 f4             	sub    -0xc(%ebp),%eax
   18f17:	c1 f8 0e             	sar    $0xe,%eax
   18f1a:	83 e8 80             	sub    $0xffffff80,%eax
   18f1d:	50                   	push   %eax
   18f1e:	e8 7a e8 ff ff       	call   1779d <_Clip>
   18f23:	83 c4 04             	add    $0x4,%esp
   18f26:	89 c2                	mov    %eax,%edx
   18f28:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f2b:	88 10                	mov    %dl,(%eax)
   18f2d:	8b 45 10             	mov    0x10(%ebp),%eax
   18f30:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   18f33:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18f36:	2b 45 f8             	sub    -0x8(%ebp),%eax
   18f39:	c1 f8 0e             	sar    $0xe,%eax
   18f3c:	83 e8 80             	sub    $0xffffff80,%eax
   18f3f:	50                   	push   %eax
   18f40:	e8 58 e8 ff ff       	call   1779d <_Clip>
   18f45:	83 c4 04             	add    $0x4,%esp
   18f48:	89 c2                	mov    %eax,%edx
   18f4a:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f4d:	88 10                	mov    %dl,(%eax)
}
   18f4f:	c9                   	leave  
   18f50:	c3                   	ret    

00018f51 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   18f51:	55                   	push   %ebp
   18f52:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   18f54:	8b 45 08             	mov    0x8(%ebp),%eax
   18f57:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   18f5d:	25 f8 00 00 00       	and    $0xf8,%eax
   18f62:	89 c2                	mov    %eax,%edx
   18f64:	8b 45 08             	mov    0x8(%ebp),%eax
   18f67:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   18f6d:	90                   	nop
   18f6e:	5d                   	pop    %ebp
   18f6f:	c3                   	ret    

00018f70 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   18f70:	55                   	push   %ebp
   18f71:	89 e5                	mov    %esp,%ebp
   18f73:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   18f76:	83 ec 0c             	sub    $0xc,%esp
   18f79:	ff 75 08             	pushl  0x8(%ebp)
   18f7c:	e8 8d e8 ff ff       	call   1780e <_DecodeLength>
   18f81:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   18f84:	8b 45 08             	mov    0x8(%ebp),%eax
   18f87:	8b 40 0c             	mov    0xc(%eax),%eax
   18f8a:	83 ec 08             	sub    $0x8,%esp
   18f8d:	50                   	push   %eax
   18f8e:	ff 75 08             	pushl  0x8(%ebp)
   18f91:	e8 2c e8 ff ff       	call   177c2 <_Skip>
   18f96:	83 c4 10             	add    $0x10,%esp
}
   18f99:	90                   	nop
   18f9a:	c9                   	leave  
   18f9b:	c3                   	ret    

00018f9c <_Convert>:

void _Convert(Context* ctx){
   18f9c:	55                   	push   %ebp
   18f9d:	89 e5                	mov    %esp,%ebp
   18f9f:	57                   	push   %edi
   18fa0:	56                   	push   %esi
   18fa1:	53                   	push   %ebx
   18fa2:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   18fa5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   18fac:	8b 45 08             	mov    0x8(%ebp),%eax
   18faf:	83 c0 2c             	add    $0x2c,%eax
   18fb2:	89 45 e0             	mov    %eax,-0x20(%ebp)
   18fb5:	e9 b2 00 00 00       	jmp    1906c <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   18fba:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18fbd:	8b 50 0c             	mov    0xc(%eax),%edx
   18fc0:	8b 45 08             	mov    0x8(%ebp),%eax
   18fc3:	8b 40 10             	mov    0x10(%eax),%eax
   18fc6:	39 c2                	cmp    %eax,%edx
   18fc8:	7d 11                	jge    18fdb <_Convert+0x3f>
   18fca:	83 ec 08             	sub    $0x8,%esp
   18fcd:	ff 75 e0             	pushl  -0x20(%ebp)
   18fd0:	ff 75 08             	pushl  0x8(%ebp)
   18fd3:	e8 79 02 00 00       	call   19251 <_UpsampleH>
   18fd8:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   18fdb:	8b 45 08             	mov    0x8(%ebp),%eax
   18fde:	8b 00                	mov    (%eax),%eax
   18fe0:	85 c0                	test   %eax,%eax
   18fe2:	0f 85 5d 02 00 00    	jne    19245 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   18fe8:	8b 45 e0             	mov    -0x20(%ebp),%eax
   18feb:	8b 50 10             	mov    0x10(%eax),%edx
   18fee:	8b 45 08             	mov    0x8(%ebp),%eax
   18ff1:	8b 40 14             	mov    0x14(%eax),%eax
   18ff4:	39 c2                	cmp    %eax,%edx
   18ff6:	7d 11                	jge    19009 <_Convert+0x6d>
   18ff8:	83 ec 08             	sub    $0x8,%esp
   18ffb:	ff 75 e0             	pushl  -0x20(%ebp)
   18ffe:	ff 75 08             	pushl  0x8(%ebp)
   19001:	e8 db 05 00 00       	call   195e1 <_UpsampleV>
   19006:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   19009:	8b 45 08             	mov    0x8(%ebp),%eax
   1900c:	8b 00                	mov    (%eax),%eax
   1900e:	85 c0                	test   %eax,%eax
   19010:	0f 85 32 02 00 00    	jne    19248 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   19016:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19019:	8b 50 0c             	mov    0xc(%eax),%edx
   1901c:	8b 45 08             	mov    0x8(%ebp),%eax
   1901f:	8b 40 10             	mov    0x10(%eax),%eax
   19022:	39 c2                	cmp    %eax,%edx
   19024:	7c 94                	jl     18fba <_Convert+0x1e>
   19026:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19029:	8b 50 10             	mov    0x10(%eax),%edx
   1902c:	8b 45 08             	mov    0x8(%ebp),%eax
   1902f:	8b 40 14             	mov    0x14(%eax),%eax
   19032:	39 c2                	cmp    %eax,%edx
   19034:	7c 84                	jl     18fba <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   19036:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19039:	8b 50 0c             	mov    0xc(%eax),%edx
   1903c:	8b 45 08             	mov    0x8(%ebp),%eax
   1903f:	8b 40 10             	mov    0x10(%eax),%eax
   19042:	39 c2                	cmp    %eax,%edx
   19044:	7c 10                	jl     19056 <_Convert+0xba>
   19046:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19049:	8b 50 10             	mov    0x10(%eax),%edx
   1904c:	8b 45 08             	mov    0x8(%ebp),%eax
   1904f:	8b 40 14             	mov    0x14(%eax),%eax
   19052:	39 c2                	cmp    %eax,%edx
   19054:	7d 0e                	jge    19064 <_Convert+0xc8>
   19056:	8b 45 08             	mov    0x8(%ebp),%eax
   19059:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   1905f:	e9 e5 01 00 00       	jmp    19249 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   19064:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   19068:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   1906c:	8b 45 08             	mov    0x8(%ebp),%eax
   1906f:	8b 40 28             	mov    0x28(%eax),%eax
   19072:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   19075:	7f 9f                	jg     19016 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   19077:	8b 45 08             	mov    0x8(%ebp),%eax
   1907a:	8b 40 28             	mov    0x28(%eax),%eax
   1907d:	83 f8 03             	cmp    $0x3,%eax
   19080:	0f 85 3d 01 00 00    	jne    191c3 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   19086:	8b 45 08             	mov    0x8(%ebp),%eax
   19089:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1908f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   19092:	8b 45 08             	mov    0x8(%ebp),%eax
   19095:	8b 40 54             	mov    0x54(%eax),%eax
   19098:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   1909b:	8b 45 08             	mov    0x8(%ebp),%eax
   1909e:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   190a4:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   190a7:	8b 45 08             	mov    0x8(%ebp),%eax
   190aa:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   190b0:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   190b3:	8b 45 08             	mov    0x8(%ebp),%eax
   190b6:	8b 40 14             	mov    0x14(%eax),%eax
   190b9:	89 45 d8             	mov    %eax,-0x28(%ebp)
   190bc:	e9 f3 00 00 00       	jmp    191b4 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   190c1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   190c8:	e9 b6 00 00 00       	jmp    19183 <_Convert+0x1e7>
                register int y = py[x] << 8;
   190cd:	8b 55 dc             	mov    -0x24(%ebp),%edx
   190d0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   190d3:	01 d0                	add    %edx,%eax
   190d5:	0f b6 00             	movzbl (%eax),%eax
   190d8:	0f b6 c0             	movzbl %al,%eax
   190db:	c1 e0 08             	shl    $0x8,%eax
   190de:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   190e0:	8b 55 dc             	mov    -0x24(%ebp),%edx
   190e3:	8b 45 cc             	mov    -0x34(%ebp),%eax
   190e6:	01 d0                	add    %edx,%eax
   190e8:	0f b6 00             	movzbl (%eax),%eax
   190eb:	0f b6 c0             	movzbl %al,%eax
   190ee:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   190f1:	8b 55 dc             	mov    -0x24(%ebp),%edx
   190f4:	8b 45 c8             	mov    -0x38(%ebp),%eax
   190f7:	01 d0                	add    %edx,%eax
   190f9:	0f b6 00             	movzbl (%eax),%eax
   190fc:	0f b6 c0             	movzbl %al,%eax
   190ff:	83 c0 80             	add    $0xffffff80,%eax
   19102:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   19104:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   19107:	8d 46 01             	lea    0x1(%esi),%eax
   1910a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1910d:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   19110:	89 c8                	mov    %ecx,%eax
   19112:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   19118:	01 d8                	add    %ebx,%eax
   1911a:	83 e8 80             	sub    $0xffffff80,%eax
   1911d:	c1 f8 08             	sar    $0x8,%eax
   19120:	83 ec 0c             	sub    $0xc,%esp
   19123:	50                   	push   %eax
   19124:	e8 74 e6 ff ff       	call   1779d <_Clip>
   19129:	83 c4 10             	add    $0x10,%esp
   1912c:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   1912e:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   19131:	8d 46 01             	lea    0x1(%esi),%eax
   19134:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   19137:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   1913a:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   1913d:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   19144:	01 d0                	add    %edx,%eax
   19146:	83 e8 80             	sub    $0xffffff80,%eax
   19149:	c1 f8 08             	sar    $0x8,%eax
   1914c:	83 ec 0c             	sub    $0xc,%esp
   1914f:	50                   	push   %eax
   19150:	e8 48 e6 ff ff       	call   1779d <_Clip>
   19155:	83 c4 10             	add    $0x10,%esp
   19158:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   1915a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1915d:	8d 46 01             	lea    0x1(%esi),%eax
   19160:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   19163:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   19169:	01 d8                	add    %ebx,%eax
   1916b:	83 e8 80             	sub    $0xffffff80,%eax
   1916e:	c1 f8 08             	sar    $0x8,%eax
   19171:	83 ec 0c             	sub    $0xc,%esp
   19174:	50                   	push   %eax
   19175:	e8 23 e6 ff ff       	call   1779d <_Clip>
   1917a:	83 c4 10             	add    $0x10,%esp
   1917d:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   1917f:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   19183:	8b 45 08             	mov    0x8(%ebp),%eax
   19186:	8b 40 10             	mov    0x10(%eax),%eax
   19189:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   1918c:	0f 8f 3b ff ff ff    	jg     190cd <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   19192:	8b 45 08             	mov    0x8(%ebp),%eax
   19195:	8b 40 40             	mov    0x40(%eax),%eax
   19198:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   1919b:	8b 45 08             	mov    0x8(%ebp),%eax
   1919e:	8b 40 6c             	mov    0x6c(%eax),%eax
   191a1:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   191a4:	8b 45 08             	mov    0x8(%ebp),%eax
   191a7:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   191ad:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   191b0:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   191b4:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   191b8:	0f 85 03 ff ff ff    	jne    190c1 <_Convert+0x125>
   191be:	e9 86 00 00 00       	jmp    19249 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   191c3:	8b 45 08             	mov    0x8(%ebp),%eax
   191c6:	8b 50 38             	mov    0x38(%eax),%edx
   191c9:	8b 45 08             	mov    0x8(%ebp),%eax
   191cc:	8b 40 40             	mov    0x40(%eax),%eax
   191cf:	39 c2                	cmp    %eax,%edx
   191d1:	74 76                	je     19249 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   191d3:	8b 45 08             	mov    0x8(%ebp),%eax
   191d6:	8b 50 54             	mov    0x54(%eax),%edx
   191d9:	8b 45 08             	mov    0x8(%ebp),%eax
   191dc:	8b 40 40             	mov    0x40(%eax),%eax
   191df:	01 d0                	add    %edx,%eax
   191e1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   191e4:	8b 45 08             	mov    0x8(%ebp),%eax
   191e7:	8b 50 54             	mov    0x54(%eax),%edx
   191ea:	8b 45 08             	mov    0x8(%ebp),%eax
   191ed:	8b 40 38             	mov    0x38(%eax),%eax
   191f0:	01 d0                	add    %edx,%eax
   191f2:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   191f5:	8b 45 08             	mov    0x8(%ebp),%eax
   191f8:	8b 40 3c             	mov    0x3c(%eax),%eax
   191fb:	83 e8 01             	sub    $0x1,%eax
   191fe:	89 45 bc             	mov    %eax,-0x44(%ebp)
   19201:	eb 2e                	jmp    19231 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   19203:	8b 45 08             	mov    0x8(%ebp),%eax
   19206:	8b 40 38             	mov    0x38(%eax),%eax
   19209:	83 ec 04             	sub    $0x4,%esp
   1920c:	50                   	push   %eax
   1920d:	ff 75 c4             	pushl  -0x3c(%ebp)
   19210:	ff 75 c0             	pushl  -0x40(%ebp)
   19213:	e8 72 ac fe ff       	call   3e8a <memmove>
   19218:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   1921b:	8b 45 08             	mov    0x8(%ebp),%eax
   1921e:	8b 40 40             	mov    0x40(%eax),%eax
   19221:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   19224:	8b 45 08             	mov    0x8(%ebp),%eax
   19227:	8b 40 38             	mov    0x38(%eax),%eax
   1922a:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   1922d:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   19231:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   19235:	75 cc                	jne    19203 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   19237:	8b 45 08             	mov    0x8(%ebp),%eax
   1923a:	8b 50 38             	mov    0x38(%eax),%edx
   1923d:	8b 45 08             	mov    0x8(%ebp),%eax
   19240:	89 50 40             	mov    %edx,0x40(%eax)
   19243:	eb 04                	jmp    19249 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   19245:	90                   	nop
   19246:	eb 01                	jmp    19249 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   19248:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   19249:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1924c:	5b                   	pop    %ebx
   1924d:	5e                   	pop    %esi
   1924e:	5f                   	pop    %edi
   1924f:	5d                   	pop    %ebp
   19250:	c3                   	ret    

00019251 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   19251:	55                   	push   %ebp
   19252:	89 e5                	mov    %esp,%ebp
   19254:	53                   	push   %ebx
   19255:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   19258:	8b 45 0c             	mov    0xc(%ebp),%eax
   1925b:	8b 40 0c             	mov    0xc(%eax),%eax
   1925e:	83 e8 03             	sub    $0x3,%eax
   19261:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   19264:	8b 45 0c             	mov    0xc(%ebp),%eax
   19267:	8b 50 0c             	mov    0xc(%eax),%edx
   1926a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1926d:	8b 40 10             	mov    0x10(%eax),%eax
   19270:	0f af c2             	imul   %edx,%eax
   19273:	01 c0                	add    %eax,%eax
   19275:	83 ec 0c             	sub    $0xc,%esp
   19278:	50                   	push   %eax
   19279:	e8 cb b0 fe ff       	call   4349 <malloc>
   1927e:	83 c4 10             	add    $0x10,%esp
   19281:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   19284:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   19288:	75 0e                	jne    19298 <_UpsampleH+0x47>
   1928a:	8b 45 08             	mov    0x8(%ebp),%eax
   1928d:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   19293:	e9 44 03 00 00       	jmp    195dc <_UpsampleH+0x38b>
    lin = c->pixels;
   19298:	8b 45 0c             	mov    0xc(%ebp),%eax
   1929b:	8b 40 28             	mov    0x28(%eax),%eax
   1929e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   192a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   192a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   192a7:	8b 45 0c             	mov    0xc(%ebp),%eax
   192aa:	8b 40 10             	mov    0x10(%eax),%eax
   192ad:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   192b0:	e9 e0 02 00 00       	jmp    19595 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   192b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   192b8:	0f b6 00             	movzbl (%eax),%eax
   192bb:	0f b6 c0             	movzbl %al,%eax
   192be:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   192c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   192c7:	83 c0 01             	add    $0x1,%eax
   192ca:	0f b6 00             	movzbl (%eax),%eax
   192cd:	0f b6 c0             	movzbl %al,%eax
   192d0:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   192d3:	01 d0                	add    %edx,%eax
   192d5:	83 ec 0c             	sub    $0xc,%esp
   192d8:	50                   	push   %eax
   192d9:	e8 c4 06 00 00       	call   199a2 <CF>
   192de:	83 c4 10             	add    $0x10,%esp
   192e1:	89 c2                	mov    %eax,%edx
   192e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   192e6:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   192e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   192eb:	8d 58 01             	lea    0x1(%eax),%ebx
   192ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   192f1:	0f b6 00             	movzbl (%eax),%eax
   192f4:	0f b6 c0             	movzbl %al,%eax
   192f7:	6b c8 68             	imul   $0x68,%eax,%ecx
   192fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   192fd:	83 c0 01             	add    $0x1,%eax
   19300:	0f b6 00             	movzbl (%eax),%eax
   19303:	0f b6 d0             	movzbl %al,%edx
   19306:	89 d0                	mov    %edx,%eax
   19308:	01 c0                	add    %eax,%eax
   1930a:	01 d0                	add    %edx,%eax
   1930c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   19313:	01 d0                	add    %edx,%eax
   19315:	01 c1                	add    %eax,%ecx
   19317:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1931a:	83 c0 02             	add    $0x2,%eax
   1931d:	0f b6 00             	movzbl (%eax),%eax
   19320:	0f b6 d0             	movzbl %al,%edx
   19323:	89 d0                	mov    %edx,%eax
   19325:	01 c0                	add    %eax,%eax
   19327:	01 d0                	add    %edx,%eax
   19329:	f7 d8                	neg    %eax
   1932b:	01 c8                	add    %ecx,%eax
   1932d:	83 ec 0c             	sub    $0xc,%esp
   19330:	50                   	push   %eax
   19331:	e8 6c 06 00 00       	call   199a2 <CF>
   19336:	83 c4 10             	add    $0x10,%esp
   19339:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   1933b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1933e:	8d 58 02             	lea    0x2(%eax),%ebx
   19341:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19344:	0f b6 00             	movzbl (%eax),%eax
   19347:	0f b6 c0             	movzbl %al,%eax
   1934a:	c1 e0 02             	shl    $0x2,%eax
   1934d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   19354:	29 c2                	sub    %eax,%edx
   19356:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19359:	83 c0 01             	add    $0x1,%eax
   1935c:	0f b6 00             	movzbl (%eax),%eax
   1935f:	0f b6 c0             	movzbl %al,%eax
   19362:	6b c0 6d             	imul   $0x6d,%eax,%eax
   19365:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   19368:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1936b:	83 c0 02             	add    $0x2,%eax
   1936e:	0f b6 00             	movzbl (%eax),%eax
   19371:	0f b6 d0             	movzbl %al,%edx
   19374:	89 d0                	mov    %edx,%eax
   19376:	c1 e0 03             	shl    $0x3,%eax
   19379:	01 d0                	add    %edx,%eax
   1937b:	f7 d8                	neg    %eax
   1937d:	01 c8                	add    %ecx,%eax
   1937f:	83 ec 0c             	sub    $0xc,%esp
   19382:	50                   	push   %eax
   19383:	e8 1a 06 00 00       	call   199a2 <CF>
   19388:	83 c4 10             	add    $0x10,%esp
   1938b:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   1938d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   19394:	e9 fa 00 00 00       	jmp    19493 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   19399:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1939c:	01 c0                	add    %eax,%eax
   1939e:	8d 50 03             	lea    0x3(%eax),%edx
   193a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   193a4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   193a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   193aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   193ad:	01 d0                	add    %edx,%eax
   193af:	0f b6 00             	movzbl (%eax),%eax
   193b2:	0f b6 d0             	movzbl %al,%edx
   193b5:	89 d0                	mov    %edx,%eax
   193b7:	c1 e0 03             	shl    $0x3,%eax
   193ba:	01 d0                	add    %edx,%eax
   193bc:	f7 d8                	neg    %eax
   193be:	8b 55 ec             	mov    -0x14(%ebp),%edx
   193c1:	8d 4a 01             	lea    0x1(%edx),%ecx
   193c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   193c7:	01 ca                	add    %ecx,%edx
   193c9:	0f b6 12             	movzbl (%edx),%edx
   193cc:	0f b6 d2             	movzbl %dl,%edx
   193cf:	6b d2 6f             	imul   $0x6f,%edx,%edx
   193d2:	01 c2                	add    %eax,%edx
   193d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   193d7:	8d 48 02             	lea    0x2(%eax),%ecx
   193da:	8b 45 f4             	mov    -0xc(%ebp),%eax
   193dd:	01 c8                	add    %ecx,%eax
   193df:	0f b6 00             	movzbl (%eax),%eax
   193e2:	0f b6 c0             	movzbl %al,%eax
   193e5:	6b c0 1d             	imul   $0x1d,%eax,%eax
   193e8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   193eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   193ee:	8d 50 03             	lea    0x3(%eax),%edx
   193f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   193f4:	01 d0                	add    %edx,%eax
   193f6:	0f b6 00             	movzbl (%eax),%eax
   193f9:	0f b6 d0             	movzbl %al,%edx
   193fc:	89 d0                	mov    %edx,%eax
   193fe:	01 c0                	add    %eax,%eax
   19400:	01 d0                	add    %edx,%eax
   19402:	f7 d8                	neg    %eax
   19404:	01 c8                	add    %ecx,%eax
   19406:	83 ec 0c             	sub    $0xc,%esp
   19409:	50                   	push   %eax
   1940a:	e8 93 05 00 00       	call   199a2 <CF>
   1940f:	83 c4 10             	add    $0x10,%esp
   19412:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   19414:	8b 45 ec             	mov    -0x14(%ebp),%eax
   19417:	01 c0                	add    %eax,%eax
   19419:	8d 50 04             	lea    0x4(%eax),%edx
   1941c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1941f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   19422:	8b 55 ec             	mov    -0x14(%ebp),%edx
   19425:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19428:	01 d0                	add    %edx,%eax
   1942a:	0f b6 00             	movzbl (%eax),%eax
   1942d:	0f b6 d0             	movzbl %al,%edx
   19430:	89 d0                	mov    %edx,%eax
   19432:	01 c0                	add    %eax,%eax
   19434:	01 d0                	add    %edx,%eax
   19436:	f7 d8                	neg    %eax
   19438:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1943b:	8d 4a 01             	lea    0x1(%edx),%ecx
   1943e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   19441:	01 ca                	add    %ecx,%edx
   19443:	0f b6 12             	movzbl (%edx),%edx
   19446:	0f b6 d2             	movzbl %dl,%edx
   19449:	6b d2 1d             	imul   $0x1d,%edx,%edx
   1944c:	01 c2                	add    %eax,%edx
   1944e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   19451:	8d 48 02             	lea    0x2(%eax),%ecx
   19454:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19457:	01 c8                	add    %ecx,%eax
   19459:	0f b6 00             	movzbl (%eax),%eax
   1945c:	0f b6 c0             	movzbl %al,%eax
   1945f:	6b c0 6f             	imul   $0x6f,%eax,%eax
   19462:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   19465:	8b 45 ec             	mov    -0x14(%ebp),%eax
   19468:	8d 50 03             	lea    0x3(%eax),%edx
   1946b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1946e:	01 d0                	add    %edx,%eax
   19470:	0f b6 00             	movzbl (%eax),%eax
   19473:	0f b6 d0             	movzbl %al,%edx
   19476:	89 d0                	mov    %edx,%eax
   19478:	c1 e0 03             	shl    $0x3,%eax
   1947b:	01 d0                	add    %edx,%eax
   1947d:	f7 d8                	neg    %eax
   1947f:	01 c8                	add    %ecx,%eax
   19481:	83 ec 0c             	sub    $0xc,%esp
   19484:	50                   	push   %eax
   19485:	e8 18 05 00 00       	call   199a2 <CF>
   1948a:	83 c4 10             	add    $0x10,%esp
   1948d:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   1948f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   19493:	8b 45 ec             	mov    -0x14(%ebp),%eax
   19496:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   19499:	0f 8c fa fe ff ff    	jl     19399 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   1949f:	8b 45 0c             	mov    0xc(%ebp),%eax
   194a2:	8b 40 14             	mov    0x14(%eax),%eax
   194a5:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   194a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   194ab:	8b 40 0c             	mov    0xc(%eax),%eax
   194ae:	01 c0                	add    %eax,%eax
   194b0:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   194b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   194b6:	8d 58 fd             	lea    -0x3(%eax),%ebx
   194b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   194bc:	83 e8 01             	sub    $0x1,%eax
   194bf:	0f b6 00             	movzbl (%eax),%eax
   194c2:	0f b6 c0             	movzbl %al,%eax
   194c5:	c1 e0 02             	shl    $0x2,%eax
   194c8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   194cf:	29 c2                	sub    %eax,%edx
   194d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   194d4:	83 e8 02             	sub    $0x2,%eax
   194d7:	0f b6 00             	movzbl (%eax),%eax
   194da:	0f b6 c0             	movzbl %al,%eax
   194dd:	6b c0 6d             	imul   $0x6d,%eax,%eax
   194e0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   194e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   194e6:	83 e8 03             	sub    $0x3,%eax
   194e9:	0f b6 00             	movzbl (%eax),%eax
   194ec:	0f b6 d0             	movzbl %al,%edx
   194ef:	89 d0                	mov    %edx,%eax
   194f1:	c1 e0 03             	shl    $0x3,%eax
   194f4:	01 d0                	add    %edx,%eax
   194f6:	f7 d8                	neg    %eax
   194f8:	01 c8                	add    %ecx,%eax
   194fa:	83 ec 0c             	sub    $0xc,%esp
   194fd:	50                   	push   %eax
   194fe:	e8 9f 04 00 00       	call   199a2 <CF>
   19503:	83 c4 10             	add    $0x10,%esp
   19506:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   19508:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1950b:	8d 58 fe             	lea    -0x2(%eax),%ebx
   1950e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19511:	83 e8 01             	sub    $0x1,%eax
   19514:	0f b6 00             	movzbl (%eax),%eax
   19517:	0f b6 c0             	movzbl %al,%eax
   1951a:	6b c8 68             	imul   $0x68,%eax,%ecx
   1951d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19520:	83 e8 02             	sub    $0x2,%eax
   19523:	0f b6 00             	movzbl (%eax),%eax
   19526:	0f b6 d0             	movzbl %al,%edx
   19529:	89 d0                	mov    %edx,%eax
   1952b:	01 c0                	add    %eax,%eax
   1952d:	01 d0                	add    %edx,%eax
   1952f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   19536:	01 d0                	add    %edx,%eax
   19538:	01 c1                	add    %eax,%ecx
   1953a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1953d:	83 e8 03             	sub    $0x3,%eax
   19540:	0f b6 00             	movzbl (%eax),%eax
   19543:	0f b6 d0             	movzbl %al,%edx
   19546:	89 d0                	mov    %edx,%eax
   19548:	01 c0                	add    %eax,%eax
   1954a:	01 d0                	add    %edx,%eax
   1954c:	f7 d8                	neg    %eax
   1954e:	01 c8                	add    %ecx,%eax
   19550:	83 ec 0c             	sub    $0xc,%esp
   19553:	50                   	push   %eax
   19554:	e8 49 04 00 00       	call   199a2 <CF>
   19559:	83 c4 10             	add    $0x10,%esp
   1955c:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   1955e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   19561:	8d 58 ff             	lea    -0x1(%eax),%ebx
   19564:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19567:	83 e8 01             	sub    $0x1,%eax
   1956a:	0f b6 00             	movzbl (%eax),%eax
   1956d:	0f b6 c0             	movzbl %al,%eax
   19570:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   19576:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19579:	83 e8 02             	sub    $0x2,%eax
   1957c:	0f b6 00             	movzbl (%eax),%eax
   1957f:	0f b6 c0             	movzbl %al,%eax
   19582:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   19585:	01 d0                	add    %edx,%eax
   19587:	83 ec 0c             	sub    $0xc,%esp
   1958a:	50                   	push   %eax
   1958b:	e8 12 04 00 00       	call   199a2 <CF>
   19590:	83 c4 10             	add    $0x10,%esp
   19593:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   19595:	8b 45 e8             	mov    -0x18(%ebp),%eax
   19598:	8d 50 ff             	lea    -0x1(%eax),%edx
   1959b:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1959e:	85 c0                	test   %eax,%eax
   195a0:	0f 85 0f fd ff ff    	jne    192b5 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   195a6:	8b 45 0c             	mov    0xc(%ebp),%eax
   195a9:	8b 40 0c             	mov    0xc(%eax),%eax
   195ac:	8d 14 00             	lea    (%eax,%eax,1),%edx
   195af:	8b 45 0c             	mov    0xc(%ebp),%eax
   195b2:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   195b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   195b8:	8b 50 0c             	mov    0xc(%eax),%edx
   195bb:	8b 45 0c             	mov    0xc(%ebp),%eax
   195be:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   195c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   195c4:	8b 40 28             	mov    0x28(%eax),%eax
   195c7:	83 ec 0c             	sub    $0xc,%esp
   195ca:	50                   	push   %eax
   195cb:	e8 37 ac fe ff       	call   4207 <free>
   195d0:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   195d3:	8b 45 0c             	mov    0xc(%ebp),%eax
   195d6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   195d9:	89 50 28             	mov    %edx,0x28(%eax)
}
   195dc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   195df:	c9                   	leave  
   195e0:	c3                   	ret    

000195e1 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   195e1:	55                   	push   %ebp
   195e2:	89 e5                	mov    %esp,%ebp
   195e4:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   195e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   195ea:	8b 40 0c             	mov    0xc(%eax),%eax
   195ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   195f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   195f3:	8b 40 14             	mov    0x14(%eax),%eax
   195f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
   195f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   195fc:	01 c0                	add    %eax,%eax
   195fe:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   19601:	8b 45 0c             	mov    0xc(%ebp),%eax
   19604:	8b 50 0c             	mov    0xc(%eax),%edx
   19607:	8b 45 0c             	mov    0xc(%ebp),%eax
   1960a:	8b 40 10             	mov    0x10(%eax),%eax
   1960d:	0f af c2             	imul   %edx,%eax
   19610:	01 c0                	add    %eax,%eax
   19612:	83 ec 0c             	sub    $0xc,%esp
   19615:	50                   	push   %eax
   19616:	e8 2e ad fe ff       	call   4349 <malloc>
   1961b:	83 c4 10             	add    $0x10,%esp
   1961e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   19621:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   19625:	75 0e                	jne    19635 <_UpsampleV+0x54>
   19627:	8b 45 08             	mov    0x8(%ebp),%eax
   1962a:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   19630:	e9 6b 03 00 00       	jmp    199a0 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   19635:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1963c:	e9 1d 03 00 00       	jmp    1995e <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   19641:	8b 45 0c             	mov    0xc(%ebp),%eax
   19644:	8b 50 28             	mov    0x28(%eax),%edx
   19647:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1964a:	01 d0                	add    %edx,%eax
   1964c:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   1964f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   19652:	8b 45 d8             	mov    -0x28(%ebp),%eax
   19655:	01 d0                	add    %edx,%eax
   19657:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   1965a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1965d:	0f b6 00             	movzbl (%eax),%eax
   19660:	0f b6 c0             	movzbl %al,%eax
   19663:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   19669:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1966c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1966f:	01 c8                	add    %ecx,%eax
   19671:	0f b6 00             	movzbl (%eax),%eax
   19674:	0f b6 c0             	movzbl %al,%eax
   19677:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1967a:	01 d0                	add    %edx,%eax
   1967c:	83 ec 0c             	sub    $0xc,%esp
   1967f:	50                   	push   %eax
   19680:	e8 1d 03 00 00       	call   199a2 <CF>
   19685:	83 c4 10             	add    $0x10,%esp
   19688:	89 c2                	mov    %eax,%edx
   1968a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1968d:	88 10                	mov    %dl,(%eax)
   1968f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   19692:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   19695:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19698:	0f b6 00             	movzbl (%eax),%eax
   1969b:	0f b6 c0             	movzbl %al,%eax
   1969e:	6b c8 68             	imul   $0x68,%eax,%ecx
   196a1:	8b 55 e0             	mov    -0x20(%ebp),%edx
   196a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   196a7:	01 d0                	add    %edx,%eax
   196a9:	0f b6 00             	movzbl (%eax),%eax
   196ac:	0f b6 d0             	movzbl %al,%edx
   196af:	89 d0                	mov    %edx,%eax
   196b1:	01 c0                	add    %eax,%eax
   196b3:	01 d0                	add    %edx,%eax
   196b5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   196bc:	01 d0                	add    %edx,%eax
   196be:	01 c1                	add    %eax,%ecx
   196c0:	8b 55 dc             	mov    -0x24(%ebp),%edx
   196c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   196c6:	01 d0                	add    %edx,%eax
   196c8:	0f b6 00             	movzbl (%eax),%eax
   196cb:	0f b6 d0             	movzbl %al,%edx
   196ce:	89 d0                	mov    %edx,%eax
   196d0:	01 c0                	add    %eax,%eax
   196d2:	01 d0                	add    %edx,%eax
   196d4:	f7 d8                	neg    %eax
   196d6:	01 c8                	add    %ecx,%eax
   196d8:	83 ec 0c             	sub    $0xc,%esp
   196db:	50                   	push   %eax
   196dc:	e8 c1 02 00 00       	call   199a2 <CF>
   196e1:	83 c4 10             	add    $0x10,%esp
   196e4:	89 c2                	mov    %eax,%edx
   196e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   196e9:	88 10                	mov    %dl,(%eax)
   196eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   196ee:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   196f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   196f4:	0f b6 00             	movzbl (%eax),%eax
   196f7:	0f b6 c0             	movzbl %al,%eax
   196fa:	c1 e0 02             	shl    $0x2,%eax
   196fd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   19704:	89 d1                	mov    %edx,%ecx
   19706:	29 c1                	sub    %eax,%ecx
   19708:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1970b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1970e:	01 d0                	add    %edx,%eax
   19710:	0f b6 00             	movzbl (%eax),%eax
   19713:	0f b6 c0             	movzbl %al,%eax
   19716:	6b c0 6d             	imul   $0x6d,%eax,%eax
   19719:	01 c1                	add    %eax,%ecx
   1971b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1971e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19721:	01 d0                	add    %edx,%eax
   19723:	0f b6 00             	movzbl (%eax),%eax
   19726:	0f b6 d0             	movzbl %al,%edx
   19729:	89 d0                	mov    %edx,%eax
   1972b:	c1 e0 03             	shl    $0x3,%eax
   1972e:	01 d0                	add    %edx,%eax
   19730:	f7 d8                	neg    %eax
   19732:	01 c8                	add    %ecx,%eax
   19734:	83 ec 0c             	sub    $0xc,%esp
   19737:	50                   	push   %eax
   19738:	e8 65 02 00 00       	call   199a2 <CF>
   1973d:	83 c4 10             	add    $0x10,%esp
   19740:	89 c2                	mov    %eax,%edx
   19742:	8b 45 f0             	mov    -0x10(%ebp),%eax
   19745:	88 10                	mov    %dl,(%eax)
   19747:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1974a:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   1974d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19750:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   19753:	8b 45 0c             	mov    0xc(%ebp),%eax
   19756:	8b 40 10             	mov    0x10(%eax),%eax
   19759:	83 e8 03             	sub    $0x3,%eax
   1975c:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1975f:	e9 e6 00 00 00       	jmp    1984a <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   19764:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19767:	f7 d8                	neg    %eax
   19769:	89 c2                	mov    %eax,%edx
   1976b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1976e:	01 d0                	add    %edx,%eax
   19770:	0f b6 00             	movzbl (%eax),%eax
   19773:	0f b6 d0             	movzbl %al,%edx
   19776:	89 d0                	mov    %edx,%eax
   19778:	c1 e0 03             	shl    $0x3,%eax
   1977b:	01 d0                	add    %edx,%eax
   1977d:	f7 d8                	neg    %eax
   1977f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   19782:	0f b6 12             	movzbl (%edx),%edx
   19785:	0f b6 d2             	movzbl %dl,%edx
   19788:	6b d2 6f             	imul   $0x6f,%edx,%edx
   1978b:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   1978e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   19791:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19794:	01 d0                	add    %edx,%eax
   19796:	0f b6 00             	movzbl (%eax),%eax
   19799:	0f b6 c0             	movzbl %al,%eax
   1979c:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1979f:	01 c1                	add    %eax,%ecx
   197a1:	8b 55 dc             	mov    -0x24(%ebp),%edx
   197a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   197a7:	01 d0                	add    %edx,%eax
   197a9:	0f b6 00             	movzbl (%eax),%eax
   197ac:	0f b6 d0             	movzbl %al,%edx
   197af:	89 d0                	mov    %edx,%eax
   197b1:	01 c0                	add    %eax,%eax
   197b3:	01 d0                	add    %edx,%eax
   197b5:	f7 d8                	neg    %eax
   197b7:	01 c8                	add    %ecx,%eax
   197b9:	83 ec 0c             	sub    $0xc,%esp
   197bc:	50                   	push   %eax
   197bd:	e8 e0 01 00 00       	call   199a2 <CF>
   197c2:	83 c4 10             	add    $0x10,%esp
   197c5:	89 c2                	mov    %eax,%edx
   197c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   197ca:	88 10                	mov    %dl,(%eax)
   197cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   197cf:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   197d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   197d5:	f7 d8                	neg    %eax
   197d7:	89 c2                	mov    %eax,%edx
   197d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   197dc:	01 d0                	add    %edx,%eax
   197de:	0f b6 00             	movzbl (%eax),%eax
   197e1:	0f b6 d0             	movzbl %al,%edx
   197e4:	89 d0                	mov    %edx,%eax
   197e6:	01 c0                	add    %eax,%eax
   197e8:	01 d0                	add    %edx,%eax
   197ea:	f7 d8                	neg    %eax
   197ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
   197ef:	0f b6 12             	movzbl (%edx),%edx
   197f2:	0f b6 d2             	movzbl %dl,%edx
   197f5:	6b d2 1d             	imul   $0x1d,%edx,%edx
   197f8:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   197fb:	8b 55 e0             	mov    -0x20(%ebp),%edx
   197fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19801:	01 d0                	add    %edx,%eax
   19803:	0f b6 00             	movzbl (%eax),%eax
   19806:	0f b6 c0             	movzbl %al,%eax
   19809:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1980c:	01 c1                	add    %eax,%ecx
   1980e:	8b 55 dc             	mov    -0x24(%ebp),%edx
   19811:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19814:	01 d0                	add    %edx,%eax
   19816:	0f b6 00             	movzbl (%eax),%eax
   19819:	0f b6 d0             	movzbl %al,%edx
   1981c:	89 d0                	mov    %edx,%eax
   1981e:	c1 e0 03             	shl    $0x3,%eax
   19821:	01 d0                	add    %edx,%eax
   19823:	f7 d8                	neg    %eax
   19825:	01 c8                	add    %ecx,%eax
   19827:	83 ec 0c             	sub    $0xc,%esp
   1982a:	50                   	push   %eax
   1982b:	e8 72 01 00 00       	call   199a2 <CF>
   19830:	83 c4 10             	add    $0x10,%esp
   19833:	89 c2                	mov    %eax,%edx
   19835:	8b 45 f0             	mov    -0x10(%ebp),%eax
   19838:	88 10                	mov    %dl,(%eax)
   1983a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1983d:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   19840:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19843:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   19846:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   1984a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1984e:	0f 85 10 ff ff ff    	jne    19764 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   19854:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19857:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   1985a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1985d:	0f b6 00             	movzbl (%eax),%eax
   19860:	0f b6 c0             	movzbl %al,%eax
   19863:	c1 e0 02             	shl    $0x2,%eax
   19866:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1986d:	29 c2                	sub    %eax,%edx
   1986f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19872:	f7 d8                	neg    %eax
   19874:	89 c1                	mov    %eax,%ecx
   19876:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19879:	01 c8                	add    %ecx,%eax
   1987b:	0f b6 00             	movzbl (%eax),%eax
   1987e:	0f b6 c0             	movzbl %al,%eax
   19881:	6b c0 6d             	imul   $0x6d,%eax,%eax
   19884:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   19887:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1988a:	f7 d8                	neg    %eax
   1988c:	89 c2                	mov    %eax,%edx
   1988e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19891:	01 d0                	add    %edx,%eax
   19893:	0f b6 00             	movzbl (%eax),%eax
   19896:	0f b6 d0             	movzbl %al,%edx
   19899:	89 d0                	mov    %edx,%eax
   1989b:	c1 e0 03             	shl    $0x3,%eax
   1989e:	01 d0                	add    %edx,%eax
   198a0:	f7 d8                	neg    %eax
   198a2:	01 c8                	add    %ecx,%eax
   198a4:	83 ec 0c             	sub    $0xc,%esp
   198a7:	50                   	push   %eax
   198a8:	e8 f5 00 00 00       	call   199a2 <CF>
   198ad:	83 c4 10             	add    $0x10,%esp
   198b0:	89 c2                	mov    %eax,%edx
   198b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   198b5:	88 10                	mov    %dl,(%eax)
   198b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   198ba:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   198bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   198c0:	0f b6 00             	movzbl (%eax),%eax
   198c3:	0f b6 c0             	movzbl %al,%eax
   198c6:	6b c8 68             	imul   $0x68,%eax,%ecx
   198c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   198cc:	f7 d8                	neg    %eax
   198ce:	89 c2                	mov    %eax,%edx
   198d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   198d3:	01 d0                	add    %edx,%eax
   198d5:	0f b6 00             	movzbl (%eax),%eax
   198d8:	0f b6 d0             	movzbl %al,%edx
   198db:	89 d0                	mov    %edx,%eax
   198dd:	01 c0                	add    %eax,%eax
   198df:	01 d0                	add    %edx,%eax
   198e1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   198e8:	01 d0                	add    %edx,%eax
   198ea:	01 c1                	add    %eax,%ecx
   198ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   198ef:	f7 d8                	neg    %eax
   198f1:	89 c2                	mov    %eax,%edx
   198f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   198f6:	01 d0                	add    %edx,%eax
   198f8:	0f b6 00             	movzbl (%eax),%eax
   198fb:	0f b6 d0             	movzbl %al,%edx
   198fe:	89 d0                	mov    %edx,%eax
   19900:	01 c0                	add    %eax,%eax
   19902:	01 d0                	add    %edx,%eax
   19904:	f7 d8                	neg    %eax
   19906:	01 c8                	add    %ecx,%eax
   19908:	83 ec 0c             	sub    $0xc,%esp
   1990b:	50                   	push   %eax
   1990c:	e8 91 00 00 00       	call   199a2 <CF>
   19911:	83 c4 10             	add    $0x10,%esp
   19914:	89 c2                	mov    %eax,%edx
   19916:	8b 45 f0             	mov    -0x10(%ebp),%eax
   19919:	88 10                	mov    %dl,(%eax)
   1991b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1991e:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   19921:	8b 45 f4             	mov    -0xc(%ebp),%eax
   19924:	0f b6 00             	movzbl (%eax),%eax
   19927:	0f b6 c0             	movzbl %al,%eax
   1992a:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   19930:	8b 45 e0             	mov    -0x20(%ebp),%eax
   19933:	f7 d8                	neg    %eax
   19935:	89 c1                	mov    %eax,%ecx
   19937:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1993a:	01 c8                	add    %ecx,%eax
   1993c:	0f b6 00             	movzbl (%eax),%eax
   1993f:	0f b6 c0             	movzbl %al,%eax
   19942:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   19945:	01 d0                	add    %edx,%eax
   19947:	83 ec 0c             	sub    $0xc,%esp
   1994a:	50                   	push   %eax
   1994b:	e8 52 00 00 00       	call   199a2 <CF>
   19950:	83 c4 10             	add    $0x10,%esp
   19953:	89 c2                	mov    %eax,%edx
   19955:	8b 45 f0             	mov    -0x10(%ebp),%eax
   19958:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   1995a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1995e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   19961:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   19964:	0f 8c d7 fc ff ff    	jl     19641 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   1996a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1996d:	8b 40 10             	mov    0x10(%eax),%eax
   19970:	8d 14 00             	lea    (%eax,%eax,1),%edx
   19973:	8b 45 0c             	mov    0xc(%ebp),%eax
   19976:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   19979:	8b 45 0c             	mov    0xc(%ebp),%eax
   1997c:	8b 50 0c             	mov    0xc(%eax),%edx
   1997f:	8b 45 0c             	mov    0xc(%ebp),%eax
   19982:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   19985:	8b 45 0c             	mov    0xc(%ebp),%eax
   19988:	8b 40 28             	mov    0x28(%eax),%eax
   1998b:	83 ec 0c             	sub    $0xc,%esp
   1998e:	50                   	push   %eax
   1998f:	e8 73 a8 fe ff       	call   4207 <free>
   19994:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   19997:	8b 45 0c             	mov    0xc(%ebp),%eax
   1999a:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1999d:	89 50 28             	mov    %edx,0x28(%eax)
}
   199a0:	c9                   	leave  
   199a1:	c3                   	ret    

000199a2 <CF>:

uchar CF(const int x){
   199a2:	55                   	push   %ebp
   199a3:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   199a5:	8b 45 08             	mov    0x8(%ebp),%eax
   199a8:	83 c0 40             	add    $0x40,%eax
   199ab:	c1 f8 07             	sar    $0x7,%eax
   199ae:	50                   	push   %eax
   199af:	e8 e9 dd ff ff       	call   1779d <_Clip>
   199b4:	83 c4 04             	add    $0x4,%esp
}
   199b7:	c9                   	leave  
   199b8:	c3                   	ret    
